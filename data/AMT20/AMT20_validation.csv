,description,tags,rating
1/B,popular spreadsheets systems ( example <unknown> ) follow numeration columns use first column number a second — number b etc till column 26 mark z. two - letter number : column 27 number aa 28 — ab column 52 mark az zz follow three - letter number etc row mark integer number start 1 . cell name concatenation column row number example <unknown> name cell column 55 row 23 . sometimes another numeration system use : <unknown> x y integer number show column row number <unknown> instance <unknown> cell previous example task write a program read give sequence cell coordinate produce item write accord rule another numeration system first line input contain integer number n ( 1 ≤ n ≤ 105 ) number coordinate test follow n line contain coordinate coordinate correct cells column and/or row number larger 106 write n line line contain a cell coordinate numeration system,"['implementation', 'math']",1600.0
10/A,tom interest power consumption favourite laptop laptop three modes normal mode laptop consume p1 watt per minute t1 minutes tom move mouse touch keyboard last time a screensaver start power consumption change p2 watt per minute finally t2 minutes start screensaver laptop switch ` ` sleep '' mode consume p3 watt per minute tom move mouse touch keyboard laptop second third mode switch first ( normal ) mode tom 's work laptop divide n time periods [ l1 r1 ] [ l2 r2 ] ... [ ln rn ] interval tom continuously move mouse press button keyboard periods tom stay away laptop find total amount power consume laptop period [ l1 rn ] first line contain 6 integer number n p1 p2 p3 t1 t2 ( 1 ≤ n ≤ 100 0 ≤ p1 p2 p3 ≤ 100 1 ≤ t1 t2 ≤ 60 ) follow n line contain description tom 's work i - th line contain two space - separated integers li ri ( 0 ≤ li < ri ≤ 1440 ri < li + 1 i < n ) stand start end i - th period work output answer problem,['implementation'],900.0
10/B,cinema halls berland rectangles k row k seat k odd number row seat number 1 k. safety reason people come box office buy ticket allow choose seat formerly choice make a cashier responsibility a special seat program find large majority berland 's inhabitants go cinema order watch a movie 's want sit close hall center possible moreover a company m people come watch a movie want necessarily occupy m successive seat one row let 's formulate algorithm accord program choose seat sell ticket request m seat come program determine row number x segment [ yl yr ] seat number row yr - yl + 1 = m. possible variants a final result program choose one minimum function value total seat remoteness center say — row seat number ` ` central '' seat function value seat remoteness hall center amount minimum function value one program choose one closer screen ( i.e row number x lower ) variants still multiple choose one minimum yl get yet task simulate work program first line contain two integers n k ( 1 ≤ n ≤ 1000 1 ≤ k ≤ 99 ) — amount request hall size respectively second line contain n space - separated integers mi range [ 1 k ] — request program output n line i - th line output « -1 » ( without quote ) impossible find mi successive seat one row otherwise output three number x yl yr . separate number a space,"['dp', 'implementation']",1500.0
100/E,n lamps a line lamps number 1 n leave right also n key key number i press lamps number x <unknown> change state two integer number a b say a|b exist integer c a × c = b. <unknown> like play key randomly press k key want know final state lamps help write a pike piece code solve task first line input contain a single integer n number lamps ( 1 ≤ n ≤ 105 ) follow line contain n word i - th word describe initial state lamp number i ( see sample detail ) follow line contain a single integer k ( 1 ≤ k ≤ 104 ) number time a key press next line come k integers range [ 1 n ] number press key write n word output describe final state lamps see sample detail,['math'],1600.0
100/J,aryo get a lot intervals <unknown> birthday really excite decide color intervals color a simple rule call a color nice exist three intervals a b c follow condition satisfy simultaneously : moreover find every intervals i j least one point i n't j. give set intervals find minimum number k aryo find a nice color k color first line contain a single integer n ( 1 ≤ n ≤ 103 ) number intervals follow n line contain a interval description interval describe two number si ei start end point ( - 105 < si ei < 105 si ≤ ei ) see sample clarity a square bracket stand include correspond endpoint a round bracket stand exclude write a single integer k — minimum number color need a nice color,"['greedy', 'math']",2400.0
1003/E,give three integers $$$ n $$$ $$$ d $$$ $$$ k $$$ task construct undirected tree $$$ n $$$ vertices diameter $$$ d $$$ degree vertex $$$ k $$$ say impossible undirected tree a connect undirected graph $$$ n - 1 $$$ edge diameter a tree maximum length a simple path ( a path vertex appear ) pair vertices tree degree a vertex number edge incident vertex ( i.e a vertex $$$ u $$$ number edge $$$ ( u v ) $$$ belong tree $$$ v $$$ vertex a tree ) first line input contain three integers $$$ n $$$ $$$ d $$$ $$$ k $$$ ( $$$ 1 \le n d k \le 400000 $$$ ) tree satisfy condition print one word ` ` '' ( without quote ) otherwise first line print ` ` yes '' ( without quote ) print $$$ n - 1 $$$ line describe edge a tree satisfy condition vertices tree must number $$$ 1 $$$ $$$ n $$$ print edge vertices connect edge order multiple answer print <unknown>,['graphs'],2100.0
1006/B,polycarp practice problem solve skill a list $$$ n $$$ problems difficulties $$$ a_1 a_2 \dots a_n $$$ respectively plan practice exactly $$$ k $$$ days day solve least one problem list polycarp solve problems order give list skip problem list solve $$$ n $$$ problems exactly $$$ k $$$ days thus day polycarp solve a contiguous sequence ( consecutive ) problems start list ca n't skip problems solve multiple time a result $$$ k $$$ days solve $$$ n $$$ problems profit $$$ j $$$ -th day polycarp 's practice maximum among difficulties problems polycarp solve $$$ j $$$ -th day ( i.e solve problems indices $$$ l $$$ $$$ r $$$ a day profit day $$$ \max\limits _ { l \le i \le r } a_i $$$ ) total profit practice sum profit $$$ k $$$ days practice want help polycarp get maximum possible total profit valid ways solve problems task distribute $$$ n $$$ problems $$$ k $$$ days satisfy condition a way total profit maximum example $$$ n = 8 k = 3 $$$ $$$ a = [ 5 4 2 6 5 1 9 2 ] $$$ one possible distributions maximum total profit : $$$ [ 5 4 2 ] [ 6 5 ] [ 1 9 2 ] $$$ total profit equal $$$ 5 + 6 + 9 = 20 $$$ first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 2000 $$$ ) — number problems number days respectively second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 2000 $$$ ) — difficulties problems polycarp 's list order place list ( i.e order polycarp solve ) first line output print maximum possible total profit second line print exactly $$$ k $$$ positive integers $$$ t_1 t_2 \dots t_k $$$ ( $$$ t_1 + t_2 + \dots + t_k $$$ must equal $$$ n $$$ ) $$$ t_j $$$ mean number problems polycarp solve $$$ j $$$ -th day order achieve maximum possible total profit practice many possible answer may print first example describe problem statement second example one possible distribution third example best answer distribute problems follow way : $$$ [ 1 2000 ] [ 2000 2 ] $$$ total profit distribution $$$ 2000 + 2000 = 4000 $$$,"['greedy', 'implementation', 'sortings']",1200.0
1006/C,give array $$$ d_1 d_2 \dots d_n $$$ consist $$$ n $$$ integer number task split array three part ( may empty ) a way element array belong exactly one three part part form a consecutive contiguous subsegment ( possibly empty ) original array let sum elements first part $$$ sum_1 $$$ sum elements second part $$$ sum_2 $$$ sum elements third part $$$ sum_3 $$$ among possible ways split array choose a way $$$ sum_1 = sum_3 $$$ $$$ sum_1 $$$ maximum possible formally first part array contain $$$ a $$$ elements second part array contain $$$ b $$$ elements third part contain $$$ c $$$ elements : $$$ $$$ sum_1 = \sum\limits _ { 1 \le i \le a } d_i $$$ $$$ $$$ $$$ sum_2 = \sum\limits _ { a + 1 \le i \le a + b } d_i $$$ $$$ $$$ $$$ sum_3 = \sum\limits _ { a + b + 1 \le i \le a + b + c } d_i $$$ $$$ sum empty array $$$ 0 $$$ task find a way split array $$$ sum_1 = sum_3 $$$ $$$ sum_1 $$$ maximum possible first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements array $$$ d $$$ second line input contain $$$ n $$$ integers $$$ d_1 d_2 \dots d_n $$$ ( $$$ 1 \le d_i \le 1000000000 $$$ ) — elements array $$$ d $$$ print a single integer — maximum possible value $$$ sum_1 $$$ consider condition $$$ sum_1 = sum_3 $$$ must meet obviously least one valid way split array exist ( use $$$ a = <unknown> $$$ $$$ b = n $$$ ) first example one possible split maximize $$$ sum_1 $$$ : $$$ [ 1 3 1 ] [ ~ ] [ 1 4 ] $$$ second example way $$$ <unknown> $$$ : $$$ [ 1 3 ] [ 2 1 ] [ 4 ] $$$ third example one way split array : $$$ [ ~ ] [ 4 1 2 ] [ ~ ] $$$,"['binary search', 'data structures', 'two pointers']",1200.0
1009/B,give a ternary string ( a string consist character ' 0 ' ' 1 ' ' 2 ' ) swap two adjacent ( consecutive ) character ' 0 ' ' 1 ' ( i.e replace ` ` 01 '' ` ` 10 '' vice versa ) two adjacent ( consecutive ) character ' 1 ' ' 2 ' ( i.e replace ` ` 12 '' ` ` 21 '' vice versa ) example string ` ` <unknown> '' perform follow move : note swap ` ` 02 '' $$$ \rightarrow $$$ ` ` 20 '' vice versa perform operations give string exclude describe task obtain minimum possible ( lexicographically ) string use swap arbitrary number time ( possibly zero ) string $$$ a $$$ lexicographically less string $$$ b $$$ ( string $$$ a $$$ $$$ b $$$ length ) exist position $$$ i $$$ ( $$$ 1 \le i \le |a| $$$ $$$ |s| $$$ length string $$$ s $$$ ) every $$$ j < i $$$ hold $$$ a_j = b_j $$$ $$$ a_i < b_i $$$ first line input contain string $$$ s $$$ consist character ' 0 ' ' 1 ' ' 2 ' length $$$ 1 $$$ $$$ 100000 $$$ ( inclusive ) print a single string — minimum possible ( lexicographically ) string obtain use swap describe arbitrary number time ( possibly zero ),"['greedy', 'implementation']",1400.0
1012/C,welcome innopolis city throughout whole year innopolis citizens suffer <unknown> city construction window room see sequence n hill i - th height ai innopolis administration want build house hill however sake city appearance a house build hill strictly higher neighbour hill ( present ) example sequence heights 5 4 6 2 house could build hill heights 5 6 innopolis administration excavator decrease height arbitrary hill one one hour excavator work one hill a time allow decrease hill zero height even negative value increase height hill impossible city administration want build k house must least k hill satisfy condition minimum time require adjust hill achieve administration 's plan ? however exact value k yet determine could please calculate answer k range ? denote n divide two round first line input contain integer n ( 1 ≤ n ≤ 5000 ) — the number hill sequence second line contain n integers ai ( 1 ≤ ai ≤ 100 000 ) — the heights hill sequence print exactly number separate space i - th print number equal minimum number hours require level hill become possible build i house first example get least one hill suitable construction one decrease second hill one one hour sequence heights become 1 0 1 1 1 first hill become suitable construction first example get least two least three suitable hill one decrease second fourth hill sequence heights become 1 0 1 0 1 hill 1 3 5 become suitable construction,['dp'],1900.0
1015/A,give a set $$$ n $$$ segment axis $$$ ox $$$ segment integer endpoints $$$ 1 $$$ $$$ m $$$ inclusive segment may intersect overlap even coincide segment characterize two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le m $$$ ) — coordinate leave right endpoints consider integer point $$$ 1 $$$ $$$ m $$$ inclusive task print point n't belong segment point $$$ x $$$ belong segment $$$ [ l ; r ] $$$ $$$ l \le x \le r $$$ first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100 $$$ ) — number segment upper bind coordinate next $$$ n $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le m $$$ ) — endpoints $$$ i $$$ -th segment segment may intersect overlap even coincide note possible $$$ l_i = r_i $$$ i.e a segment degenerate a point first line print one integer $$$ k $$$ — number point n't belong segment second line print exactly $$$ k $$$ integers order — point n't belong segment point print distinct point print a single integer $$$ 0 $$$ first line either leave second line empty print first example point $$$ 1 $$$ belong second segment point $$$ 2 $$$ belong first second segment point $$$ 5 $$$ belong third segment point $$$ 3 $$$ $$$ 4 $$$ belong segment second example point $$$ 1 $$$ $$$ 7 $$$ belong first segment,['implementation'],800.0
1015/D,$$$ n $$$ house a row number $$$ 1 $$$ $$$ n $$$ order leave right initially house $$$ 1 $$$ perform $$$ k $$$ move house one move go current house house ca n't stay ( i.e. move new house differ current house ) go house $$$ x $$$ house $$$ y $$$ total distance walk increase $$$ |x - y| $$$ units distance $$$ |a| $$$ absolute value $$$ a $$$ possible visit house multiple time ( ca n't visit house sequence ) goal walk exactly $$$ s $$$ units distance total impossible print ` ` '' otherwise print ` ` yes '' ways remember exactly $$$ k $$$ move first line input contain three integers $$$ n $$$ $$$ k $$$ $$$ s $$$ ( $$$ 2 \le n \le 1000000000 $$$ $$$ 1 \le k \le 200000 $$$ $$$ 1 \le s \le 10^ { 18 } $$$ ) — number house number move total distance want walk perform $$$ k $$$ move total walk distance equal $$$ s $$$ print ` ` '' otherwise print ` ` yes '' first line print exactly $$$ k $$$ integers $$$ h_i $$$ ( $$$ 1 \le h_i \le n $$$ ) second line $$$ h_i $$$ house visit $$$ i $$$ -th move $$$ j $$$ $$$ 1 $$$ $$$ k-1 $$$ follow condition satisfy : $$$ h_j \ne h _ { j + 1 } $$$ also $$$ h_1 \ne 1 $$$ satisfy,['greedy'],1600.0
1016/E,a light source plane source small represent point light source move point $$$ ( a s_y ) $$$ $$$ ( b s_y ) $$$ $$$ ( s_y < 0 ) $$$ speed equal $$$ 1 $$$ unit per second trajectory light source a straight segment connect two point also a fence $$$ ox $$$ axis represent $$$ n $$$ segment $$$ ( l_i r_i ) $$$ ( actual coordinate endpoints segment $$$ ( l_i 0 ) $$$ $$$ ( r_i 0 ) $$$ ) point $$$ ( x y ) $$$ shade segment connect $$$ ( x y ) $$$ current position light source intersect touch segment fence give $$$ q $$$ point point calculate total time point shade light source move $$$ ( a s_y ) $$$ $$$ ( b s_y ) $$$ first line contain three space separate integers $$$ s_y $$$ $$$ a $$$ $$$ b $$$ ( $$$ -1000000000 \le s_y < 0 $$$ $$$ 1 \le a < b \le 1000000000 $$$ ) — correspond coordinate light source second line contain single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number segment fence next $$$ n $$$ line contain two integers per line : $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i < r_i \le 1000000000 $$$ $$$ r _ { i - 1 } < l_i $$$ ) — segment fence increase order segment n't intersect touch next line contain single integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number point check next $$$ q $$$ line contain two integers per line : $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le 1000000000 $$$ ) — point process print $$$ q $$$ line $$$ i $$$ -th line contain one real number — total time $$$ i $$$ -th point shade light source move $$$ ( a s_y ) $$$ $$$ ( b s_y ) $$$ answer consider correct absolute relative error n't exceed $$$ 10^ { -6 } $$$,"['binary search', 'geometry']",2400.0
1025/B,"research properties greatest common divisor ( gcd ) a set number ildar a famous mathematician introduce a brand new concept weaken common divisor ( wcd ) a list pair integers a give list pair integers $$$ ( a_1 b_1 ) $$$ $$$ ( a_2 b_2 ) $$$ ... $$$ ( a_n b_n ) $$$ wcd arbitrary integer greater $$$ 1 $$$ divide least one element pair wcd may exist list example list look like $$$ [ ( 12 15 ) ( 25 18 ) ( 10 24 ) ] $$$ wcd equal $$$ 2 $$$ $$$ 3 $$$ $$$ 5 $$$ $$$ 6 $$$ ( number strictly greater $$$ 1 $$$ divide least one number pair ) 're currently pursue phd degree ildar 's <unknown> 's problem delegate task calculate wcd efficiently first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 150\,000 $$$ ) — number pair next $$$ n $$$ line contain two integer value $$$ a_i $$$ $$$ b_i $$$ ( $$$ 2 \le a_i b_i \le 2000000000 $$$ ) print a single integer — wcd set pair multiple possible answer output ; answer print $$$ -1 $$$ first example answer $$$ 6 $$$ since divide $$$ 18 $$$ first pair $$$ 24 $$$ second $$$ 12 $$$ third ones note valid answer also accept second example integers greater $$$ 1 $$$ satisfy condition third example one possible answer $$$ 5 $$$ note example $$$ 15 $$$ also allow 's necessary maximize output","['brute force', 'greedy', 'number theory']",1600.0
1029/B,give a problemset consist $$$ n $$$ problems difficulty $$$ i $$$ -th problem $$$ a_i $$$ guarantee difficulties distinct give increase order assemble contest consist problems give problemset word contest assemble a subset problems ( necessary consecutive ) give problemset one condition satisfy : problem hardest one ( problem maximum difficulty ) a problem difficulty greater difficulty problem greater twice difficulty problem word let $$$ a _ { i_1 } a _ { i_2 } \dots a _ { i_p } $$$ difficulties select problems increase order $$$ j $$$ $$$ 1 $$$ $$$ p-1 $$$ $$$ a _ { i _ { j + 1 } } \le a _ { i_j } \cdot 2 $$$ hold mean contest consist one problem always valid among contest satisfy condition assemble one maximum number problems task find number problems first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number problems problemset second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — difficulties problems guarantee difficulties problems distinct give increase order print a single integer — maximum number problems contest satisfy condition problem statement description first example : $$$ 10 $$$ valid contest consist $$$ 1 $$$ problem $$$ 10 $$$ valid contest consist $$$ 2 $$$ problems ( $$$ [ 1 2 ] [ 5 6 ] [ 5 7 ] [ 5 10 ] [ 6 7 ] [ 6 10 ] [ 7 10 ] [ 21 23 ] [ 21 24 ] [ 23 24 ] $$$ ) $$$ 5 $$$ valid contest consist $$$ 3 $$$ problems ( $$$ [ 5 6 7 ] [ 5 6 10 ] [ 5 7 10 ] [ 6 7 10 ] [ 21 23 24 ] $$$ ) a single valid contest consist $$$ 4 $$$ problems ( $$$ [ 5 6 7 10 ] $$$ ) second example valid contest consist $$$ 1 $$$ problem third example two contest consist $$$ 3 $$$ problems : $$$ [ 4 7 12 ] $$$ $$$ [ 100 150 199 ] $$$,"['dp', 'greedy', 'math']",1200.0
1029/C,give $$$ n $$$ segment a number line ; endpoint every segment integer coordinate segment degenerate point segment intersect nest even coincide intersection a sequence segment a maximal set point ( necesserily integer coordinate ) point lie within every segment sequence result set n't empty always form continuous segment length intersection length result segment $$$ 0 $$$ case intersection empty set example intersection segment $$$ [ 1 ; 5 ] $$$ $$$ [ 3 ; 10 ] $$$ $$$ [ 3 ; 5 ] $$$ ( length $$$ 2 $$$ ) intersection segment $$$ [ 1 ; 5 ] $$$ $$$ [ 5 ; 7 ] $$$ $$$ [ 5 ; 5 ] $$$ ( length $$$ 0 $$$ ) intersection segment $$$ [ 1 ; 5 ] $$$ $$$ [ 6 ; 6 ] $$$ empty set ( length $$$ 0 $$$ ) task remove exactly one segment give sequence a way intersection remain $$$ ( n - 1 ) $$$ segment maximal possible length first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 300000 $$$ ) — number segment sequence next $$$ n $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 0 \le l_i \le r_i \le 1000000000 $$$ ) — description $$$ i $$$ -th segment print a single integer — maximal possible length intersection $$$ ( n - 1 ) $$$ remain segment remove exactly one segment sequence first example remove segment $$$ [ 3 ; 3 ] $$$ intersection become $$$ [ 2 ; 3 ] $$$ ( length $$$ 1 $$$ ) remove segment result intersection $$$ [ 3 ; 3 ] $$$ ( length $$$ 0 $$$ ) second example remove segment $$$ [ 1 ; 3 ] $$$ segment $$$ [ 2 ; 6 ] $$$ intersection become $$$ [ 2 ; 4 ] $$$ ( length $$$ 2 $$$ ) $$$ [ 1 ; 3 ] $$$ ( length $$$ 2 $$$ ) respectively remove segment result intersection $$$ [ 2 ; 3 ] $$$ ( length $$$ 1 $$$ ) third example intersection become empty set matter segment remove fourth example get intersection $$$ [ 3 ; 10 ] $$$ ( length $$$ 7 $$$ ) remove segment $$$ [ 1 ; 5 ] $$$ intersection $$$ [ 1 ; 5 ] $$$ ( length $$$ 4 $$$ ) remove segment $$$ [ 3 ; 10 ] $$$,"['greedy', 'math', 'sortings']",1600.0
103/C,"events <unknown> know sasha roma decide find still team 's biggest loser thankfully masha find somewhere a <unknown> a rotate cylinder n bullet slot able contain exactly k bullets boys a chance resolve problem sasha select k n slot wish put bullets roma spin cylinder every n possible cylinder 's shift equiprobable game start players take turn sasha start : put gun head shoot bullet front trigger cylinder shift one position weapon give roma make move game continue someone shoot survivor winner sasha want lose must choose slot bullets a way minimize probability loss possible variant want select lexicographically minimal one empty slot lexicographically less a charge one formally cylinder n bullet slot able contain k bullets represent a string n character exactly k ` ` x '' ( charge slot ) others ` ` . '' ( <unknown> slot ) let us describe process a shoot suppose trigger front first character string ( first slot ) a shoot n't kill anyone cylinder shift string shift leave first character become last one second character become first one , trigger n't move front first character result string among string give minimal probability loss sasha choose lexicographically minimal one accord string charge gun help sasha charge gun , xi query must answer : a bullet position xi ? first line contain three integers n k p ( 1 ≤ n ≤ 1018 0 ≤ k ≤ n 1 ≤ p ≤ 1000 ) — number slot cylinder number bullets number query follow p line ; query line contain one integer xi ( 1 ≤ xi ≤ n ) number slot describe please use % lld specificator read write 64 - bit number с++ prefer use cin cout stream % i64d specificator query print ` ` . '' slot empty ` ` x '' slot charge lexicographical comparison perform < operator modern program languages a string lexicographically less b string exist i ( 1 ≤ i ≤ n ) ai < bi j ( 1 ≤ j < i ) aj = bj",['greedy'],1900.0
1030/D,vasya get three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ 'd like find three integer point $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ $$$ ( x_3 y_3 ) $$$ $$$ 0 \le x_1 x_2 x_3 \le n $$$ $$$ 0 \le y_1 y_2 y_3 \le m $$$ area triangle form point equal $$$ \frac { nm } { k } $$$ help vasya ! find point ( 's possible ) multiple solutions print single line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1\le n m \le 1000000000 $$$ $$$ 2 \le k \le 1000000000 $$$ ) point print ` ` '' otherwise print ` ` yes '' first line next three line contain integers $$$ x_i y_i $$$ — coordinate point one point per line multiple solutions print print letter case ( upper lower ) first example area triangle equal $$$ \frac { nm } { k } = 4 $$$ triangle mention output picture : second example triangle area $$$ \frac { nm } { k } = \frac { 16 } { 7 } $$$,"['geometry', 'number theory']",1800.0
1030/F,"infinite line consist cells $$$ n $$$ box cells line $$$ i $$$ -th box stand cell $$$ a_i $$$ weight $$$ w_i $$$ $$$ a_i $$$ distinct moreover $$$ a _ { i - 1 } < a_i $$$ hold valid $$$ i $$$ would like put together box put together box indices segment $$$ [ l r ] $$$ mean move a way position form segment $$$ [ x x + ( r - l ) ] $$$ one step move box a neighbor cell n't occupy another box ( i.e choose $$$ i $$$ change $$$ a_i $$$ $$$ 1 $$$ position remain distinct ) spend $$$ w_i $$$ units energy move box $$$ i $$$ one cell move box number time arbitrary order sometimes weight box change query two type : note minimize answer remainder modulo $$$ 1000000000 + 7 $$$ two possible answer $$$ 2000000000 + 13 $$$ $$$ 2000000000 + 14 $$$ choose first one print $$$ 1000000000 + 6 $$$ even though remainder second answer $$$ 0 $$$ first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n q \le 200000 $$$ ) — number box number query second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — position box $$$ a_i $$$ distinct $$$ a _ { i - 1 } < a_i $$$ hold valid $$$ i $$$ third line contain $$$ n $$$ integers $$$ w_1 w_2 \dots w_n $$$ ( $$$ 1 \le w_i \le 1000000000 $$$ ) — initial weight box next $$$ q $$$ line describe query one query per line query describe a single line contain two integers $$$ x $$$ $$$ y $$$ $$$ x < 0 $$$ query first type $$$ i d = -x $$$ $$$ nw = y $$$ ( $$$ 1 \le i d \le n $$$ $$$ 1 \le nw \le 1000000000 $$$ ) $$$ x > 0 $$$ query second type $$$ l = x $$$ $$$ r = y $$$ ( $$$ 1 \le l_j \le r_j \le n $$$ ) $$$ x $$$ equal $$$ 0 $$$ query second type print answer a separate line since answer large print remainder give divide $$$ 1000\,000\,007 = 1000000000 + 7 $$$ let 's go query example :",['data structures'],2500.0
1031/A,a plate want add gild plate a rectangle split $$$ <unknown> h $$$ cells $$$ k $$$ gild ring first one go along edge plate second one — $$$ 2 $$$ cells away edge ring a width $$$ 1 $$$ cell formally $$$ i $$$ -th ring consist border cells inner rectangle size $$$ ( w - 4 ( i - 1 ) ) \times ( h - 4 ( i - 1 ) ) $$$ task compute number cells gild line contain three integers $$$ w $$$ $$$ h $$$ $$$ k $$$ ( $$$ 3 \le w h \le 100 $$$ $$$ 1 \le k \le \left\lfloor \frac { min ( n m ) + 1 } { 4 } \right\rfloor $$$ $$$ \lfloor x \rfloor $$$ denote number $$$ x $$$ round ) — number row columns number ring respectively print a single positive integer — number cells gild first example show picture second example show picture third example show problem description,"['implementation', 'math']",800.0
1034/D,"little d a friend little c love intervals much instead number ` ` $$$ 3 $$$ ` ` $$$ n $$$ intervals number axis $$$ i $$$ -th $$$ [ a_i b_i ] $$$ $$$ n $$$ intervals satisfy define value interval intervals $$$ [ l r ] $$$ ( $$$ 1 \leq l \leq r \leq n $$$ $$$ l $$$ $$$ r $$$ integers ) total length union intervals $$$ l $$$ -th $$$ r $$$ -th want select exactly $$$ k $$$ different intervals intervals sum value maximal please help calculate maximal sum first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 300000 $$$ $$$ 1 \leq k \leq \min\ { \frac { n ( n+1 ) } { 2 } , 1000000000\ } $$$ ) — number intervals little d number intervals intervals select next $$$ n $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ $$$ i $$$ -th line $$$ n $$$ line describe $$$ i $$$ -th interval ( $$$ 1 \leq a_i < b_i \leq 1000000000 $$$ ) print one integer — maximal sum value little d get first example little d select $$$ [ 1,2 ] $$$ union first interval second interval $$$ [ 1,4 ] $$$ whose length $$$ 3 $$$ second example little d select $$$ [ 1,2 ] $$$ $$$ [ 2,3 ] $$$ $$$ [ 1,3 ] $$$ answer $$$ 5 + 6 + 4=15 $$$","['binary search', 'data structures', 'two pointers']",3500.0
1036/A,"give a set $$$ 2n+1 $$$ integer point a cartesian plane point number $$$ 0 $$$ $$$ 2n $$$ inclusive let $$$ p_i $$$ $$$ i $$$ -th point $$$ x $$$ -coordinate point $$$ p_i $$$ equal $$$ i $$$ $$$ y $$$ -coordinate point $$$ p_i $$$ equal zero ( initially ) thus initially $$$ <unknown> ( i,0 ) $$$ give point vertices a plot a piecewise function $$$ j $$$ -th piece function segment $$$ p _ { j } p _ { j + 1 } $$$ one move increase $$$ y $$$ -coordinate point odd $$$ x $$$ -coordinate ( i.e point $$$ p_1 p_3 \dots p _ { 2n-1 } $$$ ) $$$ 1 $$$ note correspond segment also change example follow plot show a function $$$ n=3 $$$ ( i.e number point $$$ <unknown> + 1=7 $$$ ) increase $$$ y $$$ -coordinate point $$$ p_1 $$$ three time $$$ y $$$ -coordinate point $$$ p_5 $$$ one time : let area plot area plot coordinate axis ox example area plot picture 4 ( light blue area picture area plot draw ) let height plot maximum $$$ y $$$ -coordinate among initial point plot ( i.e point $$$ p_0 p_1 \dots p _ { 2n } $$$ ) height plot picture 3 . problem say minimum possible height plot consist $$$ 2n+1 $$$ vertices area equal $$$ k $$$ note unnecessary minimize number move easy see answer obtain perform move describe always exist integer number exceed $$$ 10^ { 18 } $$$ first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 10^ { 18 } $$$ ) — number vertices a plot a piecewise function area need obtain print one integer — minimum possible height a plot consist $$$ 2n+1 $$$ vertices area equal $$$ k $$$ easy see answer obtain perform move describe always exist integer number exceed $$$ 10^ { 18 } $$$ one possible answer first example : area plot 3 height plot 1 . one possible answer second example : area plot 12 height plot 3",['math'],1000.0
1036/B,mikhail walk a cartesian plane start point $$$ ( 0 0 ) $$$ one move go eight adjacent point example mikhail currently point $$$ ( 0 0 ) $$$ go follow point one move : mikhail go point $$$ ( x1 y1 ) $$$ point $$$ ( x2 y2 ) $$$ one move $$$ x1 \ne x2 $$$ $$$ y1 \ne y2 $$$ a move call a diagonal move mikhail $$$ q $$$ query $$$ i $$$ -th query mikhail 's target go point $$$ ( n_i m_i ) $$$ point $$$ ( 0 0 ) $$$ exactly $$$ k_i $$$ move among possible movements want choose one maximum number diagonal move task find maximum number diagonal move find impossible go point $$$ ( 0 0 ) $$$ point $$$ ( n_i m_i ) $$$ $$$ k_i $$$ move note mikhail visit point number time ( even destination point ! ) first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 10000 $$$ ) — number query $$$ q $$$ line follow $$$ i $$$ -th $$$ q $$$ line contain three integers $$$ n_i $$$ $$$ m_i $$$ $$$ k_i $$$ ( $$$ 1 \le n_i m_i k_i \le 10^ { 18 } $$$ ) — $$$ x $$$ -coordinate destination point query $$$ y $$$ -coordinate destination point query number move query correspondingly print $$$ q $$$ integers $$$ i $$$ -th integer equal -1 mikhail go point $$$ ( 0 0 ) $$$ point $$$ ( n_i m_i ) $$$ exactly $$$ k_i $$$ move describe otherwise $$$ i $$$ -th integer equal maximum number diagonal move among possible movements one possible answer first test case : $$$ ( 0 0 ) \to ( 1 0 ) \to ( 1 1 ) \to ( 2 2 ) $$$ one possible answer second test case : $$$ ( 0 0 ) \to ( 0 1 ) \to ( 1 2 ) \to ( 0 3 ) \to ( 1 4 ) \to ( 2 3 ) \to ( 3 2 ) \to ( 4 3 ) $$$ third test case mikhail reach point $$$ ( 10 1 ) $$$ 9 move,['math'],1600.0
1036/C,let 's call positive integer classy decimal representation contain $$$ 3 $$$ non - zero digits example number $$$ 4 $$$ $$$ 200000 $$$ $$$ 10203 $$$ classy number $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ give a segment $$$ [ l ; r ] $$$ count number classy integers $$$ x $$$ $$$ l \le x \le r $$$ testcase contain several segment require solve problem separately first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number segment a testcase next $$$ t $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le 10^ { 18 } $$$ ) print $$$ t $$$ line — $$$ i $$$ -th line contain number classy integers a segment $$$ [ l_i ; r_i ] $$$,"['combinatorics', 'dp']",1900.0
1036/F,consider positive integer $$$ x $$$ prime factorization form $$$ x = 2^ { k_1 } \cdot 3^ { k_2 } \cdot 5^ { k_3 } \cdot \dots $$$ let 's call $$$ x $$$ elegant greatest common divisor sequence $$$ k_1 k_2 \dots $$$ equal $$$ 1 $$$ example number $$$ 5 = 5 ^ 1 $$$ $$$ 12 = 2 ^ 2 \cdot 3 $$$ $$$ 72 = 2 ^ 3 \cdot 3 ^ 2 $$$ elegant number $$$ 8 = 2 ^ 3 $$$ ( $$$ gcd = 3 $$$ ) $$$ 2500 = 2 ^ 2 \cdot 5 ^ 4 $$$ ( $$$ gcd = 2 $$$ ) count number elegant integers $$$ 2 $$$ $$$ n $$$ testcase contain several value $$$ n $$$ require solve problem separately first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number value $$$ n $$$ testcase next $$$ t $$$ line contain a single integer $$$ n_i $$$ ( $$$ 2 \le n_i \le 10^ { 18 } $$$ ) print $$$ t $$$ line — $$$ i $$$ -th line contain number elegant number $$$ 2 $$$ $$$ n_i $$$ list non - elegant number $$$ 10 $$$ : rest $$$ gcd = 1 $$$,"['combinatorics', 'math', 'number theory']",2400.0
1037/E,"$$$ n $$$ persons initially n't know morning two friends become friends want plan a trip every even $$$ m $$$ days trip select a group people go trip every person one follow hold : note friendship transitive , $$$ a $$$ $$$ b $$$ friends $$$ b $$$ $$$ c $$$ friends necessarily imply $$$ a $$$ $$$ c $$$ friends day find maximum number people go trip day first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \leq n \leq 2 \cdot 100000 1 \leq m \leq 200000 $$$ $$$ 1 \le k < n $$$ ) — number people number days number friends person trip group $$$ i $$$ -th ( $$$ 1 \leq i \leq m $$$ ) next $$$ m $$$ line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1\leq x y\leq n $$$ $$$ <unknown> y $$$ ) mean persons $$$ x $$$ $$$ y $$$ become friends morning day $$$ i $$$ guarantee $$$ x $$$ $$$ y $$$ friends print exactly $$$ m $$$ line $$$ i $$$ -th ( $$$ 1\leq i\leq m $$$ ) contain maximum number people go trip even day $$$ i $$$ first example second example third example ,",['graphs'],2200.0
1039/C,"metropolis computer network consist $$$ n $$$ servers encryption key range $$$ 0 $$$ $$$ 2^k - 1 $$$ assign let $$$ c_i $$$ encryption key assign $$$ i $$$ -th server additionally $$$ m $$$ pair servers directly connect via a data communication channel encryption algorithms specifics a data communication channel consider safe two servers connect distinct encryption key initial assignment encryption key guarantee keep data communication channel safe inform a new virus actively spread across internet capable change encryption key server infect specifically virus body contain unknown number $$$ x $$$ aforementioned range server $$$ i $$$ infect encryption key change $$$ c_i $$$ $$$ c_i \oplus x $$$ $$$ \oplus $$$ denote bitwise xor operation sadly know neither number $$$ x $$$ servers metropolis go infect dangerous virus decide count number situations data communication channel remain safe formally speak need find number pair $$$ ( a x ) $$$ $$$ a $$$ ( possibly empty ) subset set servers $$$ x $$$ number range $$$ 0 $$$ $$$ 2^k - 1 $$$ servers choose subset $$$ a $$$ none others infect a virus contain number $$$ x $$$ data communication channel remain safe since number quite big ask find remainder modulo $$$ 1000000000 + 7 $$$ first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 500\,000 $$$ $$$ 0 \leq m \leq \min ( \frac { n ( n - 1 ) } { 2 } 500\,000 ) $$$ $$$ 0 \leq k \leq 60 $$$ ) — number servers number pair servers directly connect a data communication channel parameter $$$ k $$$ define range possible value encryption key next line contain $$$ n $$$ integers $$$ c_i $$$ ( $$$ 0 \leq c_i \leq 2^k - 1 $$$ ) $$$ i $$$ -th encryption key use $$$ i $$$ -th server next $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ u_i \ne v_i $$$ ) denote servers connect a data communication channel guarantee pair servers appear list output line contain a single integer — number safe infections subset servers a virus parameter modulo $$$ 1000000000 + 7 $$$ consider first example possible value number $$$ x $$$ contain virus $$$ 0 $$$ $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ value $$$ 0 $$$ $$$ 2 $$$ $$$ 3 $$$ virus infect subset set servers give us $$$ 16 $$$ pair value a virus contain number $$$ 1 $$$ infect either servers none give us $$$ 16 + 2 + 16 + 16 = 50 $$$ pair total","['dfs and similar', 'dsu', 'graphs', 'math', 'sortings']",2200.0
1039/D,"a tree undirected graph exactly one simple path pair vertices call a set simple paths $$$ k $$$ -valid vertex tree belong one paths ( include endpoints ) path consist exactly $$$ k $$$ vertices give a tree $$$ n $$$ vertices $$$ k $$$ $$$ 1 $$$ $$$ n $$$ inclusive find maximum possible size a $$$ k $$$ -valid set simple paths first line input contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100\,000 $$$ ) — number vertices tree follow $$$ n - 1 $$$ line describe tree contain two integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le n $$$ ) — endpoints correspond edge guarantee give graph a tree output $$$ n $$$ number $$$ i $$$ -th maximum possible number paths $$$ i $$$ -valid set paths one way achieve optimal number paths second sample illustrate follow picture :","['data structures', 'dp', 'trees']",2800.0
104/A,one rainy gloomy even modules hide nearby <unknown> drink hot energetic cocktails hexadecimal virus decide fly mainframe look a great idea find one ! make codeforces blackjack really cool stuff ? many people surely will visit splendid shrine high culture mainframe a standard pack 52 card use play blackjack pack contain card 13 value : 2 3 4 5 6 7 8 9 10 jack queen kings ace value also exist one four suit : hearts diamonds club spade also card earn value point assign : card value two ten earn 2 10 point correspondingly ace either earn 1 11 whatever player wish picture card ( king queen jack ) earn 10 point number point a card earn depend suit rule game simple player get two card sum point card equal n player win otherwise player lose player already get first card 's queen spade evaluate chance victory determine many ways get second card sum point exactly equal n. line contain n ( 1 ≤ n ≤ 25 ) — require sum point print number ways get second card require way first card queen spade first sample four two 's different suit earn require sum point second sample use tens jack queen kings ; overall 's 15 card queen spade ( card ) present pack card 's already use third sample card would add a zero current ten point,['implementation'],800.0
1041/D,a plane fly a constant height $$$ h $$$ meter grind surface let 's consider fly point $$$ ( -1000000000 h ) $$$ point $$$ ( 1000000000 h ) $$$ parallel $$$ ox $$$ axis a glider inside plane ready start flight moment ( sake simplicity let 's consider may start plane 's coordinate integers ) jump plane fly direction plane parallel $$$ ox $$$ axis cover a unit distance every second naturally also descend ; thus second coordinate decrease one unit every second ascend air flow certain segment segment characterize two number $$$ x_1 $$$ $$$ x_2 $$$ ( $$$ x_1 < x_2 $$$ ) represent endpoints two segment share common point glider inside one segment n't descend second coordinate stay second glider still fly along $$$ ox $$$ axis cover one unit distance every second determine maximum distance along $$$ ox $$$ axis point glider 's flight start point flight end glider choose integer coordinate jump plane start flight touch grind glider stop altogether <unknown> ascend <unknown> segment second coordinate $$$ 0 $$$ first line contain two integers $$$ n $$$ $$$ h $$$ $$$ ( 1 \le n \le 2\cdot10^ { 5 } 1 \le h \le 10^ { 9 } ) $$$ — number ascend air flow segment altitude plane fly respectively next $$$ n $$$ line contain two integers $$$ x _ { i1 } $$$ $$$ x _ { i2 } $$$ $$$ ( 1 \le x _ { i1 } < x _ { i2 } \le 10^ { 9 } ) $$$ — endpoints $$$ i $$$ -th ascend air flow segment two segment intersect give ascend order print one integer — maximum distance along $$$ ox $$$ axis glider fly point jump plane point land start flight integer coordinate first example glider jump $$$ ( 2 4 ) $$$ land point $$$ ( 12 0 ) $$$ distance $$$ 12 - 2 = 10 $$$ second example glider fly $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ distance $$$ 34 - <unknown> $$$ third example glider fly $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ distance $$$ <unknown> ( -100 ) = 1999999999 $$$,"['binary search', 'data structures', 'two pointers']",1700.0
1042/F,give undirected tree consist $$$ n $$$ vertices vertex call a leaf exactly one vertex adjacent distance pair vertices number edge shortest path let 's call set leave beautiful maximum distance pair leave less equal $$$ k $$$ want split leave non - intersecting beautiful set minimal number set a split ? first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 3 \le n \le 1000000 $$$ $$$ 1 \le k \le 1000000 $$$ ) — number vertices tree maximum distance pair leave beautiful set next $$$ n - 1 $$$ line contain two integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ ) — description $$$ i $$$ -th edge guarantee give edge form a tree print a single integer — minimal number beautiful set split graph first example :,"['data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'sortings', 'trees']",2400.0
1046/C,formula 1 officials decide introduce new competition cars replace space ship number point award differ per race give current rank competition point distribution next race task calculate best possible rank a give astronaut next race 's guarantee give astronaut unique number point race first line contain two integer number $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) represent number f1 astronauts current position astronaut $$$ d $$$ ( $$$ 1 \leq d \leq n $$$ ) want calculate best rank ( competitor number point race ) second line contain $$$ n $$$ integer number $$$ s_k $$$ ( $$$ 0 \leq s_k \leq 100000000 $$$ $$$ k=1 ... n $$$ ) separate a single space represent current rank astronauts point sort non - increasing order third line contain $$$ n $$$ integer number $$$ p_k $$$ ( $$$ 0 \leq p_k \leq 100000000 $$$ $$$ k=1 ... n $$$ ) separate a single space represent point award next race point sort non - increasing order winner race get maximum number point output contain one integer number — best possible rank astronaut race multiple astronauts score race share best rank third rank astronaut win race 35 point take lead position overtake second position second rank astronaut finish race last position,['greedy'],1400.0
1047/B,$$$ n $$$ point plane $$$ ( x_1 y_1 ) ( x_2 y_2 ) \ldots ( x_n y_n ) $$$ need place isosceles triangle two side coordinate axis cover point ( a point cover lie inside triangle side triangle ) calculate minimum length shorter side triangle first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \leq x_i y_i \leq 1000000000 $$$ ) print minimum length shorter side triangle prove 's always integer illustration first example : illustration second example :,"['geometry', 'math']",900.0
105/A,<unknown> role - playing game character skills determine character 's ability use certain weapons spell character necessary skill use skill level represent integer increase use skill different character class characterize different skills unfortunately skills uncommon give character 's class quite difficult obtain avoid limitation so - called transmigration transmigration <unknown> character a new creature soul shift a new body retain part experience previous life a result transmigration new character get skills old character skill level reduce accord k coefficient ( skill level equal x transmigration become equal [ kx ] [ y ] integral part y ) skill 's level strictly less 100 skills forget ( character ) new character also gain skills specific class new level additional skills set 0 . thus one create a character skills specific completely different character class via <unknown> example create a mage archer a thief warrior possible suggest solve follow problem : skills character transmigration level skills ? first line contain three number n m k — number skills current character number skills specific class character go transmigrate reduce coefficient respectively ; n m integers k a real number exactly two digits decimal point ( 1 ≤ n m ≤ 20 0.01 ≤ k ≤ 0.99 ) follow n line describe a character 's skill form ` ` name exp '' — skill 's name character 's skill level : name a string exp integer range 0 9999 inclusive follow m line contain name skills specific class character transmigrate name consist lowercase latin letter lengths range 1 20 character inclusive character 's skills distinct name besides skills specific class player transmigrate also distinct name print first line number z — number skills character transmigration print z line print a skill 's name level separate a single space skills give lexicographical order,['implementation'],1700.0
105/B,"dark assembly a govern body <unknown> sit senators take important decisions player example expand range shop improve certain characteristics character dark assembly 's approval need dark assembly consist n senators characterize level loyalty player level a positive integer reflect a senator 's strength loyalty probability a positive decision vote measure a percentage precision 10 % senators make decisions vote make a positive negative decision accordance loyalty strictly half senators take a positive decision player 's proposal approve player 's proposal approve vote player may appeal decision dark assembly , player need kill senators vote ( 's nothing wrong kill senators <unknown> later treat player even worse ) probability a player able kill a certain group senators equal a / ( a + b ) a sum level player 's character b sum level senators group player kill <unknown> senators proposal approve senators fond sweets bribe give candy receive candy a senator increase loyalty player 10 % 's worth mention loyalty exceed 100 % player take k sweets <unknown> candy give senators start vote determine probability dark assembly approve player 's proposal candy distribute among senators optimal way first line contain three integers n k a ( 1 ≤ n k ≤ 8 1 ≤ a ≤ 9999 ) n line follow i - th contain two number — bi li — i - th senator 's level loyalty level senators integers range 1 9999 ( inclusive ) <unknown> senators integers range 0 100 ( inclusive ) divisible 10 . print one real number precision 10 - 6 — maximal possible probability dark assembly approve player 's proposal best possible distribution candy among senators first sample best way candy ' distribution give first three senators ensure vote second sample player give three candy fifth senator",['brute force'],1800.0
1051/E,vasya own three big integers — $$$ a l r $$$ let 's define a partition $$$ x $$$ a sequence string $$$ s_1 s_2 \dots s_k $$$ $$$ s_1 + s_2 + \dots + s_k = x $$$ $$$ + $$$ a <unknown> string $$$ s_i $$$ $$$ i $$$ -th element partition example number $$$ 12345 $$$ follow partition : [ ` ` 1 '' ` ` 2 '' ` ` 3 '' ` ` 4 '' ` ` 5 '' ] [ ` ` 123 '' ` ` 4 '' ` ` 5 '' ] [ ` ` 1 '' ` ` 2345 '' ] [ ` ` 12345 '' ] lot others let 's call partition $$$ a $$$ beautiful elements contain lead zero vasya want know number beautiful partition number $$$ a $$$ $$$ s_i $$$ satisfy condition $$$ l \le s_i \le r $$$ note comparison integer comparison string one help vasya count amount partition number $$$ a $$$ match give requirements result rather big print modulo $$$ 998244353 $$$ first line contain a single integer $$$ a~ ( 1 \le a \le 10^ { 1000000 } ) $$$ second line contain a single integer $$$ <unknown> ( 0 \le l \le 10^ { 1000000 } ) $$$ third line contain a single integer $$$ <unknown> ( 0 \le r \le 10^ { 1000000 } ) $$$ guarantee $$$ l \le r $$$ also guarantee number $$$ a l r $$$ contain lead zero print a single integer — amount partition number $$$ a $$$ match give requirements modulo $$$ 998244353 $$$ first test case two good partition $$$ 13 + 5 $$$ $$$ 1 + 3 + 5 $$$ second test case one good partition $$$ 1 + 0 + 0 + 0 + 0 $$$,"['binary search', 'data structures', 'dp', 'strings']",2600.0
1054/B,"initially ildar empty array perform $$$ n $$$ step step take a subset integers already add array append mex subset array mex multiset integers smallest non - negative integer present multiset example mex multiset $$$ [ 0 2 3 ] $$$ $$$ 1 $$$ mex multiset $$$ [ 1 2 1 ] $$$ $$$ 0 $$$ formally step $$$ m $$$ ildar already array $$$ a_1 a_2 \ldots a _ { m-1 } $$$ choose subset indices $$$ 1 \leq i_1 < i_2 < \ldots < i_k < m $$$ ( possibly empty ) $$$ 0 \leq k < m $$$ append $$$ mex ( a _ { i_1 } a _ { i_2 } \ldots a _ { i_k } ) $$$ end array perform step ildar think might make a mistake somewhere ask determine a give array $$$ a_1 a_2 \ldots a_n $$$ minimum step $$$ t $$$ definitely make a mistake least one step $$$ 1 2 \ldots t $$$ determine could obtain array without mistake first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100\,000 $$$ ) — number step ildar make second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) — array ildar obtain ildar could choose subsets step a way result array $$$ a_1 a_2 \ldots a_n $$$ print $$$ -1 $$$ otherwise print a single integer $$$ t $$$ — smallest index a step a mistake make least one step among step $$$ 1 2 \ldots t $$$ first example possible ildar make mistake process could follow thus get array without mistake answer $$$ -1 $$$ second example definitely make a mistake first step could obtain anything different $$$ 0 $$$ third example could obtain $$$ [ 0 1 2 ] $$$ without mistake $$$ 239 $$$ definitely wrong",['implementation'],1000.0
1055/E,a give a list integers $$$ a_1 a_2 \ldots a_n $$$ $$$ s $$$ segment $$$ [ l_j ; r_j ] $$$ ( $$$ 1 \le l_j \le r_j \le n $$$ ) need select exactly $$$ m $$$ segment a way $$$ k $$$ -th order statistic multiset $$$ a_i $$$ $$$ i $$$ contain least one segment smallest possible 's impossible select a set $$$ m $$$ segment a way multiset contain least $$$ k $$$ elements print -1 . $$$ k $$$ -th order statistic a multiset value $$$ k $$$ -th element sort multiset non - descending order first line contain four integers $$$ n $$$ $$$ s $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le m \le s \le 1500 $$$ $$$ 1 \le k \le n \le 1500 $$$ ) — size list number segment number segment choose statistic number second line contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — value number list next $$$ s $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) — endpoints segment possible segment coincide print exactly one integer — smallest possible $$$ k $$$ -th order statistic -1 's impossible choose segment a way multiset contain least $$$ k $$$ elements first example one possible solution choose first third segment together cover three elements list ( except third one ) way $$$ 2 $$$ -nd order statistic cover elements $$$ 2 $$$,"['binary search', 'dp']",2500.0
1056/C,"say arkady a bite old - fashioned play checker wo n't right also a modern computer game arkady friends keen wo n't discuss rule feature important problem player pick a distinct hero begin game $$$ 2 $$$ team $$$ n $$$ players $$$ 2n $$$ heroes distribute team team take turn pick heroes : first first team choose a hero team second team choose a hero note a hero choose become unavailable team friends estimate power $$$ i $$$ -th heroes $$$ p_i $$$ team want maximize total power heroes however one exception : $$$ m $$$ pair heroes especially strong team choose a hero a pair team must choose one turn hero one pair interactive problem write a program optimally choose heroes one team jury 's program play team note jury 's program may behave <unknown> case take opportunity still maximize total power team formally ever chance reach total power $$$ q $$$ greater regardless jury 's program choices must get $$$ q $$$ greater pass a test first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 1000 $$$ $$$ 0 \le m \le n $$$ ) — number players one team number special pair heroes second line contain $$$ 2n $$$ integers $$$ p_1 p_2 \ldots p _ { 2n } $$$ ( $$$ 1 \le p_i \le 1000 $$$ ) — power heroes next $$$ m $$$ line contain two integer $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le 2n $$$ $$$ a \ne b $$$ ) — a pair heroes especially strong guarantee hero appear list next line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 2 $$$ ) — team play $$$ t = 1 $$$ first turn otherwise second turn <unknown> order hack use format describe one additional line line output $$$ 2n $$$ distinct integers $$$ 1 $$$ $$$ 2n $$$ — priority order jury 's team jury 's team turn select first possible hero list possible mean yet take contradict rule special pair heroes turn print a single integer $$$ x $$$ ( $$$ 1 \le x \le 2n $$$ ) — index hero choose note ca n't choose a hero previously choose either player must follow rule special pair heroes team 's turn read a line contain a single integer $$$ x $$$ ( $$$ 1 \le x \le 2n $$$ ) — index hero choose team guarantee index choose team also follow rule special pair heroes last turn terminate without print anything print choice forget output end line flush output otherwise get idleness limit exceed , use : jury 's answer $$$ -1 $$$ instead a valid choice mean make invalid turn exit immediately receive $$$ -1 $$$ see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream first example first turn example choose $$$ 6 $$$ team force reply $$$ 2 $$$ choose $$$ 5 $$$ team choose $$$ 4 $$$ finally choose $$$ 3 $$$ team choose $$$ 1 $$$ second example second turn team choose $$$ 6 $$$ choose $$$ 5 $$$ force team choose $$$ 1 $$$ choose $$$ 4 $$$ team choose $$$ 3 $$$ choose $$$ 2 $$$","['greedy', 'implementation', 'sortings']",1700.0
1059/D,a forest model a plane live $$$ n $$$ rare animals animal number $$$ i $$$ lair point $$$ ( x _ { i } y _ { i } ) $$$ order protect a decision build a nature reserve make reserve must a form a circle contain lairs also a straight river flow forest animals drink river therefore must least one common point reserve hand ship constantly sail along river reserve must one common point river convenience scientists make a transformation coordinate river define $$$ y = 0 $$$ check whether possible build a reserve possible find minimum possible radius a reserve first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number animals next $$$ n $$$ line contain two integers $$$ x _ { i } $$$ $$$ y _ { i } $$$ ( $$$ -10000000 \le x _ { i } y _ { i } \le 10000000 $$$ ) — coordinate $$$ i $$$ -th animal 's lair guarantee $$$ y _ { i } \neq 0 $$$ two lairs coincide reserve build print $$$ -1 $$$ otherwise print minimum radius answer accept absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer consider correct $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -6 } $$$ first sample optimal build reserve radius equal $$$ 0.5 $$$ center $$$ ( 0 \ 0.5 ) $$$ second sample impossible build a reserve third sample optimal build reserve radius equal $$$ \frac { 5 } { 8 } $$$ center $$$ ( \frac { 1 } { 2 } \ \frac { 5 } { 8 } ) $$$,"['binary search', 'geometry']",2200.0
1060/C,give two array $$$ a $$$ $$$ b $$$ positive integers length $$$ n $$$ $$$ m $$$ respectively let $$$ c $$$ $$$ n \times m $$$ matrix $$$ c _ { i j } = a_i \cdot b_j $$$ need find a subrectangle matrix $$$ c $$$ sum elements $$$ x $$$ area ( total number elements ) largest possible formally need find largest number $$$ s $$$ possible choose integers $$$ x_1 x_2 y_1 y_2 $$$ subject $$$ 1 \leq x_1 \leq x_2 \leq n $$$ $$$ 1 \leq y_1 \leq y_2 \leq m $$$ $$$ ( x_2 - x_1 + 1 ) \times ( y_2 - y_1 + 1 ) = s $$$ $$$ $$$ \sum _ { i = x_1 } ^ { x_2 } { \sum _ { j = y_1 } ^ { y_2 } { c _ { i j } } } \leq x $$$ $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 2000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 2000 $$$ ) third line contain $$$ m $$$ integers $$$ b_1 b_2 \ldots b_m $$$ ( $$$ 1 \leq b_i \leq 2000 $$$ ) fourth line contain a single integer $$$ x $$$ ( $$$ 1 \leq x \leq 2 \cdot 10^ { 9 } $$$ ) possible choose four integers $$$ x_1 x_2 y_1 y_2 $$$ $$$ 1 \leq x_1 \leq x_2 \leq n $$$ $$$ 1 \leq y_1 \leq y_2 \leq m $$$ $$$ \sum _ { i = x_1 } ^ { x_2 } { \sum _ { j = y_1 } ^ { y_2 } { c _ { i j } } } \leq x $$$ output largest value $$$ ( x_2 - x_1 + 1 ) \times ( y_2 - y_1 + 1 ) $$$ among <unknown> otherwise output $$$ 0 $$$ matrix first sample choose subrectangle ( blue color ) : matrix second sample choose subrectangle ( blue color ) :,"['binary search', 'implementation', 'two pointers']",1600.0
1060/E,"sergey semyonovich a mayor a county city n use spend days nights thoughts improvements <unknown> ' live unfortunately anything everything do already possible improvements think day ( prefer sleep night ) however assistants find a solution draw imaginary city a paper sheet suggest mayor propose improvements right a map imaginary city $$$ n $$$ subway station station directly connect tunnel a way whole map a tree ( assistants short time enthusiasm ) mean exist exactly one simple path pair station call a path simple use tunnel one sergey semyonovich 's favorite quality <unknown> sum pairwise distance every pair station distance two station minimum possible number tunnel a path sergey semyonovich decide add new tunnel subway map particular connect two station $$$ u $$$ $$$ v $$$ connect a direct tunnel share a common neighbor i.e exist a station $$$ w $$$ original map a tunnel $$$ u $$$ $$$ w $$$ a tunnel $$$ w $$$ $$$ v $$$ give a task compute sum pairwise distance pair station new map first line input contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 200\,000 $$$ ) — number subway station imaginary city draw mayor 's assistants follow $$$ n - 1 $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ u_i \ne v_i $$$ ) mean station indices connect a direct tunnel guarantee $$$ n $$$ station $$$ n - 1 $$$ tunnel form a tree print one integer equal sum distance pair station sergey semyonovich draw new tunnel pair station share a common neighbor original map first sample new map pair station share a direct connection sum distance $$$ 6 $$$ second sample new map a direct tunnel pair station except pair $$$ ( 1 4 ) $$$ two station distance $$$ 2 $$$","['dfs and similar', 'dp', 'trees']",2000.0
1061/D,$$$ n $$$ tv show want watch suppose whole time split equal part call ` ` minutes '' $$$ i $$$ -th show go $$$ l_i $$$ -th $$$ r_i $$$ -th minute end inclusive need a tv watch a tv show ca n't watch two tv show air time tv possible need multiple tvs minutes example segment $$$ [ l_i r_i ] $$$ $$$ [ l_j r_j ] $$$ intersect show $$$ i $$$ $$$ j $$$ ca n't watch simultaneously one tv start watch a show tv possible ` ` move '' another tv ( since would distract ) watch another show tv show end a tv rental shop near rent a tv $$$ x $$$ rupees charge $$$ y $$$ ( $$$ y < x $$$ ) rupees every extra minute keep tv order rent a tv minutes $$$ [ a ; b ] $$$ need pay $$$ x + y \cdot ( b - a ) $$$ assume take return tv n't take time n't distract watch tv show find minimum possible cost view show since value could large print modulo $$$ 1000000000 + 7 $$$ first line contain integers $$$ n $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 1 \le y < x \le 1000000000 $$$ ) — number tv show cost rent a tv first minute cost rent a tv every subsequent minute next $$$ n $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le 1000000000 $$$ ) denote start end minute $$$ i $$$ -th tv show print exactly one integer — minimum cost view show take modulo $$$ 1000000000 + 7 $$$ first example optimal strategy would rent $$$ 3 $$$ tvs watch : way cost first tv $$$ 4 + 3 \cdot ( 2 - 1 ) = 7 $$$ second $$$ 4 + 3 \cdot ( 10 - 4 ) = 22 $$$ third $$$ 4 + 3 \cdot ( 11 - 2 ) = 31 $$$ give $$$ 60 $$$ int total second example optimal watch show a new tv third example optimal watch show a new tv note answer print modulo $$$ 1000000000 + 7 $$$,"['data structures', 'greedy', 'implementation', 'sortings']",2000.0
1063/D,"children 's festival children dance a circle music stop play children still stand a circle lena remember parent give a candy box exactly $$$ k $$$ candy ` ` <unknown> may '' lena a greedy person decide present candy friends circle lena know friends a sweet tooth others sweet tooth take box two candy box least two candy otherwise take one rest lena 's friends always take exactly one candy box start give candy lena step circle exactly $$$ n $$$ people remain lena number friends a clockwise order positive integers start $$$ 1 $$$ a way index $$$ 1 $$$ assign best friend roma initially lena give box friend number $$$ l $$$ friend ( start friend number $$$ l $$$ ) take candy box pass box next friend clockwise order process end friend number $$$ r $$$ take last candy ( two know ) empty box please note possible lena 's friends take candy box several time , box could go several full circle become empty lena know friends a sweet tooth interest maximum possible number friends a sweet tooth situation could happen lena prove wrong observations please tell line contain four integers $$$ n $$$ $$$ l $$$ $$$ r $$$ $$$ k $$$ ( $$$ 1 \le n k \le 10^ { 11 } $$$ $$$ 1 \le l r \le n $$$ ) — number children circle number friend give a box candy number friend take last candy initial number candy box respectively print exactly one integer — maximum possible number sweet tooth among friends lena ` ` -1 '' ( quote clarity ) lena wrong first example two friends sweet tooths way person receive box candy twice last person take sweets fourth friend second example sweet tooths three friends except friend third position third example one friend take candy still a sweet tooth able take two candy friends circle sweet tooths well able take a candy even fourth example lena wrong situation could n't happen","['brute force', 'math']",2600.0
1065/B,vasya get undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge graph n't contain self - loops multiple edge self - loop edge connect a vertex multiple edge a pair edge connect pair vertices since graph undirected pair edge $$$ ( 1 2 ) $$$ $$$ ( 2 1 ) $$$ consider multiple edge isolate vertex graph a vertex edge connect vertex vertex vasya want know minimum maximum possible number isolate vertices undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge line contain two integers $$$ n $$$ $$$ m~ ( 1 \le n \le 100000 0 \le m \le \frac { n ( n - 1 ) } { 2 } ) $$$ guarantee exist a graph without self - loops multiple edge number vertices edge line print two number $$$ min $$$ $$$ max $$$ — minimum maximum number isolate vertices respectively first example possible construct a graph $$$ 0 $$$ isolate vertices : example contain edge $$$ ( 1 2 ) $$$ $$$ ( 3 4 ) $$$ get one isolate vertex may construct a graph edge $$$ ( 1 2 ) $$$ $$$ ( 1 3 ) $$$ second example graph always contain exactly one isolate vertex,['graphs'],1300.0
1067/A,ivan unexpectedly saw a present one previous birthdays array $$$ n $$$ number $$$ 1 $$$ $$$ 200 $$$ array old number hard read ivan remember elements least one neighbour <unknown> less formally : $$$ a _ { 1 } \le a _ { 2 } $$$ $$$ a _ { n } \le a _ { n-1 } $$$ $$$ a _ { i } \le max ( a _ { i-1 } \ \ a _ { i+1 } ) $$$ $$$ i $$$ $$$ 2 $$$ $$$ n-1 $$$ ivan remember array ask find number ways restore restore elements also integers $$$ 1 $$$ $$$ 200 $$$ since number ways big print modulo $$$ 998244353 $$$ first line input contain one integer $$$ n $$$ ( $$$ 2 \le n \le 10^ { 5 } $$$ ) — size array second line input contain $$$ n $$$ integers $$$ a _ { i } $$$ — elements array either $$$ a _ { i } = -1 $$$ $$$ 1 \le a _ { i } \le 200 $$$ $$$ a _ { i } = -1 $$$ mean $$$ i $$$ -th element ca n't read print number ways restore array modulo $$$ 998244353 $$$ first example possible value $$$ a _ { 2 } $$$ $$$ 2 $$$ second example $$$ a _ { 1 } = a _ { 2 } $$$ $$$ 200 $$$ different value restore elements integers $$$ 1 $$$ $$$ 200 $$$,['dp'],1900.0
107/D,zeyad want commit n crimes egypt punish end several type crimes example bribery a crime consider repeat twice therefore bribery consider a crime repeat even number time speed a crime consider repeat a number time a multiple five specifically c condition crime repetitions know condition describe crime type ti multiplicity mi number time zeyad commit crime ti a multiple mi zeyad punish crime ti crimes may list case fulfil least one condition crime enough punish course certain crime number time zeyad commit zero innocent respect crime zeyad interest a number ways commit exactly n crimes without punishment order commit crimes matter formally two ways sequence w1 w2 commit n crimes equal <unknown> = <unknown> 1 ≤ i ≤ n. first line contain two integers n c ( 0 ≤ n ≤ 1018 0 ≤ c ≤ 1000 ) — number crimes zeyad would like commit number condition aware definitions c condition follow 26 type crimes crime definition consist crime type — a capital latin letter — multiplicity multiplicity crime a positive integer number product <unknown> exceed 123 . condition may repeat input crime multiplicity 1 yield punishment regardless number time commit <unknown> law <unknown> fact 's non - mandatory obviously crime list set condition zeyad consider commit would <unknown> lead punishment please use % lld specificator read write 64 - bit integers с++ prefer use cin stream ( may also use % i64d specificator ) output number different ways zeyad commit exactly n crimes punishment modulo 12345 . first test case 16 ways : aaaaa aaabb aabab aabba abaab ababa <unknown> baaab <unknown> <unknown> bbaaa abbbb babbb <unknown> bbbab <unknown>,"['dp', 'graphs']",2400.0
1070/E,polycarp a lot work recently learn a new time management rule : ` ` a task take five minutes less immediately '' polycarp like new rule however sure five minutes optimal value suppose value $$$ d $$$ choose base exist task list polycarp a list $$$ n $$$ task complete $$$ i $$$ -th task difficulty $$$ p_i $$$ i.e require exactly $$$ p_i $$$ minutes do polycarp read task one one first $$$ n $$$ -th a task difficulty $$$ d $$$ less polycarp start work task immediately a task difficulty strictly greater $$$ d $$$ task allow rearrange task list polycarp n't spend time read a task skip polycarp $$$ t $$$ minutes total complete maximum number task want work time decide make a break group $$$ m $$$ consecutive task work break take amount time spend total completion $$$ m $$$ task example $$$ n=7 $$$ $$$ p= [ 3 1 4 1 5 9 2 ] $$$ $$$ d=3 $$$ $$$ m=2 $$$ polycarp work follow schedule : polycarp stop exactly $$$ t $$$ minutes polycarp start a task finish time task consider complete allow complete less $$$ m $$$ task last group also polycarp consider acceptable shorter break need last group task even break — work day enough time rest anyway please help polycarp find value $$$ d $$$ would allow complete maximum possible number task $$$ t $$$ minutes first line input contain single integer $$$ c $$$ ( $$$ 1 \le c \le 50000 $$$ ) — number test case description $$$ c $$$ test case follow solve test case separately test case completely independent affect test case describe two line first line contain three space - separated integers $$$ n $$$ $$$ m $$$ $$$ t $$$ ( $$$ 1 \le n \le 2 \cdot 100000 1 \le m \le 2 \cdot 100000 1 \le t \le 4 \cdot 10^ { 10 } $$$ ) — number task polycarp 's list number task without a break total amount time polycarp work task second line test case contain $$$ n $$$ space separate integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le 200000 $$$ ) — difficulties task sum value $$$ n $$$ test case input exceed $$$ 200000 $$$ print $$$ c $$$ line line contain answer correspond test case — maximum possible number task polycarp complete integer value $$$ d $$$ ( $$$ 1 \le d \le t $$$ ) polycarp use time management rule separate space several possible value $$$ d $$$ a test case output first test case first example $$$ n=5 $$$ $$$ m=2 $$$ $$$ <unknown> $$$ sequence difficulties $$$ [ 5 6 1 4 7 ] $$$ polycarp choose $$$ d=5 $$$ complete $$$ 3 $$$ task polycarp work follow schedule : total first test case polycarp complete $$$ 3 $$$ task $$$ d=5 $$$ ca n't choose value $$$ d $$$ increase number complete task,"['binary search', 'data structures']",2100.0
1076/B,give integer number $$$ n $$$ follow algorithm apply : determine number <unknown> algorithm make line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 10^ { 10 } $$$ ) print a single integer — number subtractions algorithm make first example $$$ 5 $$$ smallest prime divisor thus get subtract right away make a $$$ 0 $$$ second example $$$ 2 $$$ smallest prime divisor step,"['implementation', 'math', 'number theory']",1200.0
1077/E,polycarp prepare $$$ n $$$ competitive program problems topic $$$ i $$$ -th problem $$$ a_i $$$ problems ' topics may coincide polycarp host several thematic contest problems contest topic contest pairwise distinct topics may use problems possible contest topics polycarp want host competitions consecutive days one contest per day polycarp want host a set contest a way : task calculate maximum number problems set thematic contest note maximize number contest first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number problems polycarp prepare second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ topic $$$ i $$$ -th problem print one integer — maximum number problems set thematic contest first example optimal sequence contest : $$$ 2 $$$ problems topic $$$ 1 $$$ $$$ 4 $$$ problems topic $$$ 2 $$$ $$$ 8 $$$ problems topic $$$ 10 $$$ second example optimal sequence contest : $$$ 3 $$$ problems topic $$$ 3 $$$ $$$ 6 $$$ problems topic $$$ 6 $$$ third example take problems topic $$$ 1337 $$$ ( number problems $$$ 3 $$$ answer $$$ 3 $$$ ) host a single contest,"['greedy', 'sortings']",1800.0
1080/A,"petya a party soon decide invite $$$ n $$$ friends want make invitations form origami invitation need two red sheet five green sheet eight blue sheet store sell infinite number notebooks color notebook consist one color $$$ k $$$ sheet , notebook contain $$$ k $$$ sheet either red green blue find minimum number notebooks petya need buy invite $$$ n $$$ friends first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1\leq n k\leq 100000000 $$$ ) — number petya 's friends number sheet notebook respectively print one number — minimum number notebooks petya need buy first example need $$$ 2 $$$ red notebooks $$$ 3 $$$ green notebooks $$$ 5 $$$ blue notebooks second example need $$$ 5 $$$ red notebooks $$$ 13 $$$ green notebooks $$$ 20 $$$ blue notebooks",['math'],800.0
1081/B,chouti classmates go university soon say goodbye class plan a big farewell party classmates teachers parent sing dance chouti remember $$$ n $$$ persons take part party make party funnier person wear one hat among $$$ n $$$ kinds weird hat number $$$ 1 2 \ldots n $$$ possible several persons wear hat kind kinds hat remain unclaimed anyone party $$$ i $$$ -th person say $$$ a_i $$$ persons wear a hat differ days chouti forget others ' hat curious let $$$ b_i $$$ number hat type $$$ i $$$ -th person wear chouti want find possible $$$ b_1 b_2 \ldots b_n $$$ n't contradict person 's statement persons might a poor memory could solution first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) number persons party second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le n-1 $$$ ) statements people solution print a single line ` ` impossible '' otherwise print ` ` possible '' $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1 \le b_i \le n $$$ ) multiple answer print answer first example hat every person say persons wear a hat different kind $$$ 1 $$$ answer second example first second person wear hat type $$$ 1 $$$ wear a hat type $$$ 2 $$$ first two persons say three persons hat differ similarly three last persons say two persons wear a hat different third example show solution exist first second example possible configurations possible,['implementation'],1500.0
1081/H,learn fancy algorithms palindromes chouti find palindromes interest want challenge problem chouti get two string $$$ a $$$ $$$ b $$$ since like palindromes would like pick $$$ a $$$ non - empty palindromic substring $$$ a $$$ $$$ b $$$ non - empty palindromic substring $$$ b $$$ concatenate get string $$$ ab $$$ chouti think string could get way interest want know many different string get first line contain a single string $$$ a $$$ ( $$$ 1 \le |a| \le 200000 $$$ ) second line contain a single string $$$ b $$$ ( $$$ 1 \le |b| \le 200000 $$$ ) string $$$ a $$$ $$$ b $$$ contain lowercase english letter first line contain a single integer — number possible string first example attainable string second example attainable string ` ` aa '' ` ` aaa '' ` ` aaaa '' ` ` <unknown> '' ` ` aab '' ` ` aaba '' ` ` ab '' ` ` abaa '' ` ` <unknown> '' ` ` abaaba '' ` ` abab '' ` ` ba '' ` ` baa '' ` ` baba '' ` ` bb '' notice though ` ` a '' + '' aa '' = '' aa '' + '' a '' = '' aaa '' ` ` aaa '' count,"['data structures', 'strings']",3500.0
1085/C,<unknown> national forest divide equal $$$ 1 \times 1 $$$ square plot align north - south east - west directions plot uniquely describe integer cartesian coordinate $$$ ( x y ) $$$ south - west corner three friends alice bob charlie go buy three distinct plot land $$$ a b c $$$ forest initially plot forest ( include plot $$$ a b c $$$ ) cover tree friends want visit want clean plot tree clean one able reach plot $$$ a b c $$$ one move adjacent clear plot two plot adjacent share a side course friends n't want <unknown> much help find smallest number plot need clean tree first line contain two integers $$$ x_a $$$ $$$ y_a $$$ — coordinate plot $$$ a $$$ ( $$$ 0 \leq x_a y_a \leq 1000 $$$ ) follow two line describe coordinate $$$ ( x_b y_b ) $$$ $$$ ( x_c y_c ) $$$ plot $$$ b $$$ $$$ c $$$ respectively format ( $$$ 0 \leq x_b y_b x_c y_c \leq 1000 $$$ ) guarantee three plot distinct first line print a single integer $$$ k $$$ — smallest number plot need clean tree follow $$$ k $$$ line contain coordinate plot need clean $$$ k $$$ plot distinct output plot order multiple solutions print first example show picture legend second example illustrate follow image :,"['implementation', 'math']",1600.0
1086/F,berland forest plant several decades ago a formation infinite grid a single tree every cell tree grow form a pretty dense structure dense actually fire become a real danger forest season abnormally hot berland tree get catch fire ! second fire start consider second $$$ 0 $$$ every second fire light intact neightbouring tree every currently burn tree tree neighbour occupy adjacent side corner cell luckily $$$ t $$$ second berland fire department finally reach location fire instantaneously extinguish want calculate destructive power fire let $$$ val _ { x y } $$$ second tree cell $$$ ( x y ) $$$ get catch fire destructive power sum $$$ val _ { x y } $$$ $$$ ( x y ) $$$ burn tree clearly workers fire department <unknown> programmers thus ask help calculate destructive power fire result rather big print modulo $$$ 998244353 $$$ first line contain two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 50 $$$ $$$ 0 \le t \le 100000000 $$$ ) — number tree initially get catch fire time fire department extinguish fire respectively next $$$ n $$$ line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ -100000000 \le x y \le 100000000 $$$ ) — position tree initially get catch fire obviously position cell $$$ ( 0 0 ) $$$ grid directions ax irrelevant grid infinite answer n't depend guarantee give tree position pairwise distinct grid infinite fire n't stop reach $$$ -100000000 $$$ $$$ 100000000 $$$ continue beyond border print a single integer — sum $$$ val _ { x y } $$$ $$$ ( x y ) $$$ burn tree modulo $$$ 998244353 $$$ first three examples grey cells $$$ val = 0 $$$ orange cells $$$ val = 1 $$$ red cells $$$ val = 2 $$$,['math'],3500.0
1088/C,'re give array $$$ a $$$ length $$$ n $$$ perform follow operations : make array strictly increase $$$ n+1 $$$ operations ? first line contain integer $$$ n $$$ $$$ ( 1 \le n \le 2000 ) $$$ number elements array $$$ a $$$ second line contain $$$ n $$$ space - separated integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \dots $$$ $$$ a_n $$$ $$$ ( 0 \le a_i \le 100000 ) $$$ elements array $$$ a $$$ first line print number operations wish perform next line print operations print add operation use format ` ` $$$ 1 $$$ $$$ i $$$ $$$ x $$$ ` ` ; print a <unknown> operation use format ` ` $$$ 2 $$$ $$$ i $$$ $$$ x $$$ ` ` $$$ i $$$ $$$ x $$$ n't satisfy limitations use $$$ n+1 $$$ operations 'll get wrong answer verdict first sample array already increase n't need operations second sample : first step : array become $$$ [ <unknown> ] $$$ second step : array become $$$ [ <unknown> ] $$$,"['greedy', 'math']",1400.0
1088/F,'re give a tree consist $$$ n $$$ nod every node $$$ u $$$ a weight $$$ a_u $$$ guarantee one node minimum weight tree every node $$$ u $$$ ( except node minimum weight ) must a neighbor $$$ v $$$ $$$ a_v < a_u $$$ construct a tree minimize weight $$$ w $$$ calculate follow : first line contain integer $$$ n $$$ $$$ ( 2 \le n \le 5 \cdot 100000 ) $$$ number nod tree second line contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 1 \le a_i \le 1000000000 ) $$$ weight nod next $$$ n-1 $$$ line contain 2 space - separated integers $$$ u $$$ $$$ v $$$ $$$ ( 1 \le u v \le n ) $$$ mean 's edge $$$ u $$$ $$$ v $$$ output one integer minimum possible value $$$ w $$$ first sample tree minimize value $$$ w $$$ second sample optimal tree :,"['data structures', 'trees']",2800.0
1092/F,give a tree consist exactly $$$ n $$$ vertices tree a connect undirected graph $$$ n-1 $$$ edge vertex $$$ v $$$ tree a value $$$ a_v $$$ assign let $$$ dist ( x y ) $$$ distance vertices $$$ x $$$ $$$ y $$$ distance vertices number edge simple path let 's define cost tree follow value : firstly let 's fix vertex tree let $$$ v $$$ cost tree $$$ \sum\limits _ { i = 1 } ^ { n } dist ( i v ) \cdot a_i $$$ task calculate maximum possible cost tree choose $$$ v $$$ arbitrarily first line contain one integer $$$ n $$$ number vertices tree ( $$$ 1 \le n \le 200000 $$$ ) second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 200000 $$$ ) $$$ a_i $$$ value vertex $$$ i $$$ next $$$ n - 1 $$$ line describe edge tree edge $$$ i $$$ denote two integers $$$ u_i $$$ $$$ v_i $$$ label vertices connect ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) guarantee give edge form a tree print one integer — maximum possible cost tree choose vertex $$$ v $$$ picture correspond first example : choose vertex $$$ 3 $$$ a root answer $$$ 18 + 4 + 0 + 21 + 30 + 4 + 24 + 20 = 18 + 4 + 0 + 21 + 30 + 4 + 24 + 20 = 121 $$$ second example tree consist one vertex answer always $$$ 0 $$$,"['dfs and similar', 'dp', 'trees']",1900.0
1095/D,$$$ n $$$ kid number $$$ 1 $$$ $$$ n $$$ dance a circle around christmas tree let 's enumerate a clockwise direction $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_n $$$ ( number $$$ 1 $$$ $$$ n $$$ distinct $$$ p $$$ a permutation ) let next kid a kid $$$ p_i $$$ kid $$$ p _ { i + 1 } $$$ $$$ i < n $$$ $$$ p_1 $$$ otherwise dance kid remember two kid : next kid ( let 's call $$$ x $$$ ) next kid $$$ x $$$ kid tell kid he / she remember : kid $$$ i $$$ remember kid $$$ a _ { i 1 } $$$ $$$ a _ { i 2 } $$$ however order $$$ a _ { i 1 } $$$ $$$ a _ { i 2 } $$$ differ order circle restore order kid circle use information several answer may print guarantee least one solution exist python programmer consider use pypy instead python submit code first line input contain one integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) — number kid next $$$ n $$$ line contain $$$ 2 $$$ integers $$$ i $$$ -th line contain two integers $$$ a _ { i 1 } $$$ $$$ a _ { i 2 } $$$ ( $$$ 1 \le a _ { i 1 } a _ { i 2 } \le n a _ { i 1 } \ne a _ { i 2 } $$$ ) — kid $$$ i $$$ -th kid remember give arbitrary order print $$$ n $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_n $$$ — permutation integers $$$ 1 $$$ $$$ n $$$ correspond order kid circle several answer may print ( example n't matter kid first circle ) guarantee least one solution exist,['implementation'],1600.0
1098/E,"fedya love problems involve data structure especially ones different query subsegments fedya a nice array $$$ a_1 a_2 \ldots a_n $$$ a beautiful data structure data structure give $$$ l $$$ $$$ r $$$ $$$ 1 \le l \le r \le n $$$ could find greatest integer $$$ d $$$ $$$ d $$$ divide $$$ a_l $$$ $$$ a _ { l+1 } $$$ ... $$$ a _ { r } $$$ fedya really like data structure apply every non - empty contiguous subarray array $$$ a $$$ put answer array sort call array $$$ b $$$ 's easy see array $$$ b $$$ contain $$$ n ( n+1 ) /2 $$$ elements , fedya implement another cool data structure allow find sum $$$ b_l + b _ { l+1 } + \ldots + b_r $$$ give $$$ l $$$ $$$ r $$$ $$$ 1 \le l \le r \le n ( n+1 ) /2 $$$ surely fedya apply data structure every contiguous subarray array $$$ b $$$ call result $$$ c $$$ sort help fedya find lower median array $$$ c $$$ recall a sort array length $$$ k $$$ lower median element position $$$ \lfloor \frac { k + 1 } { 2 } \rfloor $$$ elements array enumerate start $$$ 1 $$$ example lower median array $$$ ( 1 1 2 3 6 ) $$$ $$$ 2 $$$ lower median $$$ ( 0 17 23 96 ) $$$ $$$ 17 $$$ first line contain a single integer $$$ n $$$ — number elements array $$$ a $$$ ( $$$ 1 \le n \le 50\,000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ — elements array ( $$$ 1 \le a_i \le 100\,000 $$$ ) print a single integer — lower median array $$$ c $$$ first sample array $$$ b $$$ equal $$$ { 3 3 6 } $$$ array $$$ c $$$ equal $$$ { 3 3 6 6 9 12 } $$$ lower median $$$ 6 $$$ second sample $$$ b $$$ $$$ { 8 8 8 } $$$ $$$ c $$$ $$$ { 8 8 8 16 16 24 } $$$ lower median $$$ 8 $$$","['binary search', 'implementation', 'math', 'number theory']",3400.0
1099/B,little sofia fourth grade today geometry lesson learn segment square way home decide draw $$$ n $$$ square snow a side length $$$ 1 $$$ simplicity assume sofia live a plane draw segment length $$$ 1 $$$ parallel coordinate ax vertices integer point order draw a segment sofia proceed follow want draw a vertical segment coordinate end $$$ ( x y ) $$$ $$$ ( x y+1 ) $$$ sofia look already a draw segment coordinate end $$$ ( x ' y ) $$$ $$$ ( x ' y+1 ) $$$ $$$ x ' $$$ a segment exist sofia quickly draw a new segment use old one a guideline segment sofia take a ruler measure a new segment a long time thing happen sofia want draw a horizontal segment check existence a segment coordinate $$$ x $$$ $$$ x+1 $$$ differ coordinate $$$ y $$$ example sofia need draw one square draw two segment use a ruler : draw remain two segment use first two a guide : sofia need draw two square draw three segment use a ruler : draw remain four segment use first three a guide : sofia a hurry want minimize number segment draw a ruler without a guide help find minimum number line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 10^ { 9 } $$$ ) number square sofia want draw print single integer minimum number segment sofia draw a ruler without a guide order draw $$$ n $$$ square manner describe,"['binary search', 'math']",1100.0
11/D,give a simple graph output number simple cycle a simple cycle a cycle repeat vertices edge first line input contain two integers n m ( 1 ≤ n ≤ 19 0 ≤ m ) – respectively number vertices edge graph subsequent m line contain two integers a b ( 1 ≤ a b ≤ n a ≠ b ) indicate vertices a b connect undirected edge one edge connect pair vertices output number cycle give graph example graph a clique contain four cycle length 3 three cycle length 4,"['bitmasks', 'dp', 'graphs']",2200.0
11/E,"jack become a soldier unfortunately trouble drill instead march begin leave foot change legs step order keep repeat a sequence step sometimes make wrong step — horror <unknown> ! — stop a example jack use sequence ' right leave break ' sergeant <unknown> : ' left ! right ! leave ! right ! leave ! right ! ' jack first make a step right foot one leave foot confuse stop a moment - time accord order - start right foot use leave foot - sergeant 's <unknown> - stop catch breath incorrectly start right foot ... march way jack make step suppose give moment one third case officer convince something jack decide modify basic sequence step repeat however order get tire decide thing 'll add number break position original sequence ( a break correspond stop duration one step ) course jack ca n't make a step foot twice a row pause step , however impossible sequence step use far incorrect ( would explain a lot actually ) help private jack ! give sequence step keep repeat calculate maximal percentage time spend march correctly add break scheme first line input contain a sequence consist character ' l ' ' r ' ' x ' ' l ' correspond a step leave foot ' r ' — right foot ' x ' — a break length sequence exceed 106 . output maximum percentage time jack spend march correctly round exactly six digits decimal point second example add two break receive <unknown> jack march : <unknown> ... instead <unknown> ... make correct step half case n't add break sequence would incorrect — jack ca n't step right foot twice a row","['binary search', 'dp', 'greedy']",2800.0
1100/B,"arkady coordinate round really famous competitive program platform round feature $$$ n $$$ problems distinct difficulty difficulties number $$$ 1 $$$ $$$ n $$$ hold a round arkady need $$$ n $$$ new ( use previously ) problems one difficulty , arkady create problems unfortunately ca n't create a problem a desire difficulty instead create a problem evaluate difficulty $$$ 1 $$$ $$$ n $$$ put problems pool moment arkady choose a set $$$ n $$$ new problems distinct difficulties pool hold a round problems remove pool arkady always create one problem a time hold a round create a problem immediately give a sequence problems ' difficulties order arkady create problem determine whether arkady hold round right create problem , initially problems pool empty first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100000 $$$ ) — number difficulty level number problems arkady create second line contain $$$ m $$$ integers $$$ a_1 a_2 \ldots a_m $$$ ( $$$ 1 \le a_i \le n $$$ ) — problems ' difficulties order arkady create print a line contain $$$ m $$$ digits $$$ i $$$ -th digit $$$ 1 $$$ arkady hold round creation $$$ i $$$ -th problem $$$ 0 $$$ otherwise first example arkady hold round first three problems distinct difficulties last problem","['data structures', 'implementation']",1300.0
1100/C,nn experience internet user mean spend a lot time social media find follow image net ask compare size inner circle : turn circle equal nn surprise fact decide create a similar picture manage calculate number outer circle $$$ n $$$ radius inner circle $$$ r $$$ nn think use information exactly determine radius outer circle $$$ r $$$ inner circle touch outer ones <unknown> pair neighbor outer circle also touch nn try hard guess require radius n't manage help nn find require radius build require picture first line input file contain two number $$$ n $$$ $$$ r $$$ ( $$$ 3 \leq n \leq 100 $$$ $$$ 1 \leq r \leq 100 $$$ ) — number outer circle radius inner circle respectively output a single number $$$ r $$$ — radius outer circle require build require picture answer accept relative absolute error exceed $$$ 10^ { -6 } $$$ formally answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \frac { |a - b| } { max ( 1 |b| ) } \le 10^ { -6 } $$$,"['binary search', 'geometry', 'math']",1200.0
1100/F,"ivan love burgers spend money $$$ n $$$ burger joint street ivan live ivan $$$ q $$$ friends $$$ i $$$ -th friend suggest meet joint $$$ l_i $$$ walk joint $$$ r_i $$$ $$$ ( l_i \leq r_i ) $$$ stroll $$$ i $$$ -th friend ivan visit joint $$$ x $$$ satisfy $$$ l_i \leq x \leq r_i $$$ joint ivan know cost expensive burger cost $$$ c_i $$$ burl ivan want visit subset joint way buy expensive burger spend money a small issue : card break instead charge purchase amount money change follow ivan $$$ d $$$ burl purchase spend $$$ c $$$ burl joint purchase would $$$ d \oplus c $$$ burl $$$ \oplus $$$ denote bitwise xor operation currently ivan $$$ 2^ { 2^ { 100 } } - 1 $$$ burl want go a walk help determine maximal amount burl spend go a walk friend $$$ i $$$ amount burl spend define difference initial amount account final account first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 500\,000 $$$ ) — number burger shop next line contain $$$ n $$$ integers $$$ c_1 c_2 \ldots c_n $$$ ( $$$ 0 \leq c_i \leq 1000000 $$$ ) $$$ c_i $$$ — cost expensive burger burger joint $$$ i $$$ third line contain one integer $$$ q $$$ ( $$$ 1 \leq q \leq 500\,000 $$$ ) — number ivan 's friends next $$$ q $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \leq l_i \leq r_i \leq n $$$ ) — pair number burger shop ivan walk output $$$ q $$$ line $$$ i $$$ -th contain maximum amount money ivan spend friend $$$ i $$$ first test order spend maximum amount money first third friends ivan need go first burger a second friend ivan go third burger second test a third friend ( go walk first third burger ) 8 options spend money — $$$ 0 $$$ $$$ 12 $$$ $$$ 14 $$$ $$$ 23 $$$ $$$ 12 \oplus 14 = 2 $$$ $$$ 14 \oplus 23 = 25 $$$ $$$ 12 \oplus 23 = 27 $$$ $$$ 12 \oplus 14 \oplus 23 = 20 $$$ maximum amount money turn spend go first third burger — $$$ 12 \oplus 23 = 27 $$$","['data structures', 'divide and conquer', 'greedy', 'math']",2500.0
1101/D,give a tree consist $$$ n $$$ vertices a number write vertex ; number vertex $$$ i $$$ equal $$$ a_i $$$ let 's denote function $$$ g ( x y ) $$$ greatest common divisor number write vertices belong simple path vertex $$$ x $$$ vertex $$$ y $$$ ( include two vertices ) also let 's denote $$$ dist ( x y ) $$$ number vertices simple path vertices $$$ x $$$ $$$ y $$$ include endpoints $$$ dist ( x x ) = 1 $$$ every vertex $$$ x $$$ task calculate maximum value $$$ dist ( x y ) $$$ among pair vertices $$$ g ( x y ) > 1 $$$ first line contain one integer $$$ n $$$ — number vertices $$$ ( 1 \le n \le 2 \cdot 100000 ) $$$ second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ $$$ ( 1 \le a_i \le 2 \cdot 100000 ) $$$ — number write vertices $$$ n - 1 $$$ line follow contain two integers $$$ x $$$ $$$ y $$$ $$$ ( 1 \le x y \le n x \ne y ) $$$ denote edge connect vertex $$$ x $$$ vertex $$$ y $$$ guarantee edge form a tree pair vertices $$$ x y $$$ $$$ g ( x y ) > 1 $$$ print $$$ 0 $$$ otherwise print maximum value $$$ dist ( x y ) $$$ among pair,"['data structures', 'dfs and similar', 'dp', 'number theory', 'trees']",2000.0
1101/G,give array $$$ a_1 a_2 \dots a_n $$$ integer number task divide array maximum number segment a way : print maximum number segment array divide print -1 suitable division exist first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — size array second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) print maximum number segment array divide follow give constraints print -1 suitable division exist first example $$$ 2 $$$ maximum number divide array $$$ \ { [ 5 ] [ 5 7 2 ] \ } $$$ xor value subset second segment $$$ 5 \oplus 7 \oplus 2 = 0 $$$ $$$ \ { [ 5 5 ] [ 7 2 ] \ } $$$ value subset first segment $$$ 5 \oplus 5 = 0 $$$ however $$$ \ { [ 5 5 7 ] [ 2 ] \ } $$$ lead subsets $$$ \ { [ 5 5 7 ] \ } $$$ xor $$$ 7 $$$ $$$ \ { [ 2 ] \ } $$$ xor $$$ 2 $$$ $$$ \ { [ 5 5 7 ] [ 2 ] \ } $$$ xor $$$ 5 \oplus 5 \oplus 7 \oplus 2 = 5 $$$ let 's take a look division $$$ 3 $$$ segment — $$$ \ { [ 5 ] [ 5 7 ] [ 2 ] \ } $$$ produce subsets : see subset $$$ \ { [ 5 7 ] [ 2 ] \ } $$$ xor equal $$$ 0 $$$ unacceptable check divisions size $$$ 3 $$$ $$$ 4 $$$ non - empty subset $$$ 0 $$$ xor always exist second example suitable divisions third example array divide $$$ \ { [ 3 ] [ 1 ] [ 10 ] \ } $$$ subset segment xor equal $$$ 0 $$$,['math'],2300.0
1103/C,today tuesday mean a dispute johnny solve team : try understand johnny solve 's guy ask umnik help umnik give guy a connect graph $$$ n $$$ vertices without loop multiedges a degree vertex least $$$ 3 $$$ also give a number $$$ 1 \leq k \leq n $$$ johnny smart promise find a simple path length least $$$ \frac { n } { k } $$$ graph reply solve promise find $$$ k $$$ simple vertices cycle representatives : need help guy resolve dispute need find a solution johnny : a simple path length least $$$ \frac { n } { k } $$$ ( $$$ n $$$ necessarily divide $$$ k $$$ ) solution solve : $$$ k $$$ cycle satisfy condition solution - print $$$ -1 $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \leq k \leq n \leq 2.5 \cdot 100000 1 \leq m \leq 500000 $$$ ) next $$$ m $$$ line describe edge graph format $$$ v $$$ $$$ u $$$ ( $$$ 1 \leq v u \leq n $$$ ) 's guarantee $$$ v \neq u $$$ $$$ m $$$ pair distinct 's guarantee a degree vertex least $$$ 3 $$$ print path first line solve problem johnny second line print number vertices path $$$ c $$$ ( $$$ c \geq \frac { n } { k } $$$ ) third line print vertices describe path route order print cycle first line solve problem solve follow line describe exactly $$$ k $$$ cycle follow format : first line print size cycle $$$ c $$$ ( $$$ c \geq 3 $$$ ) second line print cycle route order also first vertex cycle must a <unknown> print $$$ -1 $$$ solution total amount print number output must $$$ 1000000 $$$ 's guarantee exist solution a correct output satisfy restriction,"['dfs and similar', 'graphs', 'math']",2700.0
1105/D,"kilani play a game friends game represent a grid size $$$ n \times m $$$ cell either empty block every player one castle cells ( two castle one cell ) game play round round players expand turn turn : firstly first player expand second player expand expansion happen follow : castle player own try expand empty cells nearby player $$$ i $$$ expand a cell castle empty cell 's possible reach $$$ s_i $$$ ( $$$ s_i $$$ player 's expansion speed ) move leave , right without go block cells cells occupy player 's castle player examine set cells expand build a castle turn pass next player game end player make a move give game field speed expansion player kilani want know player many cells control ( a castle ) game end first line contain three integers $$$ n $$$ $$$ m $$$ $$$ p $$$ ( $$$ 1 \le n m \le 1000 $$$ $$$ 1 \le p \le 9 $$$ ) — size grid number players second line contain $$$ p $$$ integers $$$ s_i $$$ ( $$$ 1 \le s \le 1000000000 $$$ ) — speed expansion every player follow $$$ n $$$ line describe game grid consist $$$ m $$$ symbols ' . ' denote empty cell ' # ' denote a block cell digit $$$ x $$$ ( $$$ 1 \le x \le p $$$ ) denote castle own player $$$ x $$$ guarantee player least one castle grid print $$$ p $$$ integers — number cells control player game end picture show game start game first round game second round first example : second example first player ` ` block '' capture new cells entire game player expand first two round third round second player move leave","['dfs and similar', 'graphs', 'implementation', 'shortest paths']",1900.0
1108/C,a garland consist $$$ n $$$ lamps lamp color red green blue color $$$ i $$$ -th lamp $$$ s_i $$$ ( ' r ' ' g ' ' b ' — color lamps garland ) recolor lamps garland ( recoloring a lamp mean change initial color another ) a way obtain garland nice a garland call nice two lamps color distance divisible three i.e obtain garland $$$ t $$$ $$$ i j $$$ $$$ t_i = t_j $$$ satisfy $$$ |i - <unknown> mod~ 3 = 0 $$$ value $$$ |x| $$$ mean absolute value $$$ x $$$ operation $$$ <unknown> mod~ y $$$ mean remainder $$$ x $$$ divide $$$ y $$$ example follow garland nice : ` ` <unknown> '' ` ` gb '' ` ` r '' ` ` <unknown> '' ` ` <unknown> '' follow garland nice : ` ` rr '' ` ` <unknown> '' among ways recolor initial garland make nice choose one minimum number recolored lamps multiple optimal solutions print first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number lamps second line input contain string $$$ s $$$ consist $$$ n $$$ character ' r ' ' g ' ' b ' — color lamps garland first line output print one integer $$$ r $$$ — minimum number recolors need obtain a nice garland give one second line output print one string $$$ t $$$ length $$$ n $$$ — a nice garland obtain initial one minimum number recolors multiple optimal solutions print,"['brute force', 'greedy', 'math']",1300.0
111/B,little petya love look number ' divisors one day petya come across follow problem : give n query form ` ` xi yi '' query petya count many divisors number xi divide none number xi - yi xi - yi + 1 ... xi - 1 . help first line contain integer n ( 1 ≤ n ≤ 105 ) follow n line contain two space - separated integers xi yi ( 1 ≤ xi ≤ 105 0 ≤ yi ≤ i - 1 i query 's ordinal number ; numeration start 1 ) yi = 0 query answer query number divisors number xi case need take previous number x consideration query print answer a single line : number positive integers k let 's write divisors give answer first 5 <unknown> ) 1 2 4 2 ) 33 ) 54 ) 2 65 ) 9 18,"['binary search', 'data structures', 'number theory']",1900.0
1110/B,"a long stick consist $$$ m $$$ segment enumerate $$$ 1 $$$ $$$ m $$$ segment $$$ 1 $$$ centimeter long sadly segment break need repair infinitely long repair tape want cut piece tape use cover break segment precise a piece tape integer length $$$ t $$$ place position $$$ s $$$ cover segment $$$ s <unknown> \ldots <unknown> $$$ allow cover non - broken segment ; also possible piece tape overlap time money want cut $$$ k $$$ continuous piece tape cover break segment minimum total length piece ? first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ n \le m \le 1000000000 $$$ $$$ 1 \le k \le n $$$ ) — number break segment length stick maximum number piece use second line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1 \le b_i \le m $$$ ) — position break segment integers give increase order , $$$ b_1 < b_2 < \ldots < b_n $$$ print minimum total length piece first example use a piece length $$$ 11 $$$ cover break segment $$$ 20 $$$ $$$ 30 $$$ another piece length $$$ 6 $$$ cover $$$ 75 $$$ $$$ 80 $$$ a total length $$$ 17 $$$ second example use a piece length $$$ 4 $$$ cover break segment $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$ two piece length $$$ 1 $$$ cover break segment $$$ 60 $$$ $$$ 87 $$$","['greedy', 'sortings']",1400.0
1111/C,"thanos want destroy avengers base need destroy avengers along base let represent base array position occupy many avengers one avenger occupy one position length base a perfect power $$$ 2 $$$ thanos want destroy base use minimum power start whole base one step either follow : first line contain four integers $$$ n $$$ $$$ k $$$ $$$ a $$$ $$$ b $$$ ( $$$ 1 \leq n \leq 30 $$$ $$$ 1 \leq k \leq 100000 $$$ $$$ 1 \leq a b \leq 10000 $$$ ) $$$ 2^n $$$ length base $$$ k $$$ number avengers $$$ a $$$ $$$ b $$$ constants explain question second line contain $$$ k $$$ integers $$$ a _ { 1 } a _ { 2 } a _ { 3 } \ldots a _ { k } $$$ ( $$$ 1 \leq a _ { i } \leq 2^n $$$ ) $$$ a _ { i } $$$ represent position avenger base output one integer — minimum power need destroy avengers base consider first example one option thanos burn whole base $$$ 1 - 4 $$$ power $$$ 4 \cdot 4 = 16 $$$ otherwise divide base two part $$$ 1 - 2 $$$ $$$ 3 - 4 $$$ base $$$ 1 - 2 $$$ either burn power $$$ 2 \cdot 2 = 4 $$$ divide $$$ 2 $$$ part $$$ 1 - 1 $$$ $$$ 2 - 2 $$$ base $$$ 1 - 1 $$$ burn power $$$ 2 \cdot 1 = 2 $$$ $$$ 2 - 2 $$$ destroy power $$$ 1 $$$ avengers , total power destroy $$$ 1 - 2 $$$ $$$ 2 + 1 = 3 $$$ less $$$ 4 $$$ similarly need $$$ 3 $$$ power destroy $$$ 3 - 4 $$$ total minimum power need $$$ 6 $$$","['binary search', 'brute force', 'divide and conquer', 'math']",1700.0
1113/A,sasha a happy guy 's always move $$$ n $$$ cities country sasha live locate one straight line convenience number $$$ 1 $$$ $$$ n $$$ increase order distance two adjacent cities equal $$$ 1 $$$ kilometer since roads country direct 's possible reach city $$$ y $$$ city $$$ x $$$ $$$ x < y $$$ sasha decide go a trip around country visit $$$ n $$$ cities move help car <unknown> tank capacity model $$$ v $$$ liters spend exactly $$$ 1 $$$ liter fuel $$$ 1 $$$ kilometer way begin journey tank empty sasha locate city number $$$ 1 $$$ want get city number $$$ n $$$ a gas station city $$$ i $$$ -th city price $$$ 1 $$$ liter fuel $$$ i $$$ dollars obvious moment time tank contain $$$ v $$$ liters fuel sasha n't like waste money 's want know minimum amount money need finish trip buy fuel city want help figure ! first line contain two integers $$$ n $$$ $$$ v $$$ ( $$$ 2 \le n \le 100 $$$ $$$ 1 \le v \le 100 $$$ ) — number cities country capacity tank print one integer — minimum amount money need finish trip first example sasha buy $$$ 2 $$$ liters $$$ 2 $$$ dollars ( $$$ 1 $$$ dollar per liter ) first city drive second city spend $$$ 1 $$$ liter fuel buy $$$ 1 $$$ liter $$$ 2 $$$ dollars second city drive $$$ 4 $$$ -th city therefore answer $$$ 1 + 1 + 2=4 $$$ second example capacity tank allow fill tank completely first city drive last city without stop cities,"['dp', 'greedy', 'math']",900.0
1114/B,"array $$$ b $$$ call a subarray $$$ a $$$ form a continuous subsequence $$$ a $$$ , equal $$$ a_l $$$ $$$ a _ { l + 1 } $$$ $$$ \ldots $$$ $$$ a_r $$$ $$$ l r $$$ suppose $$$ m $$$ know constant array $$$ m $$$ elements let 's define 's beauty sum $$$ m $$$ largest elements array example : give array $$$ a_1 a_2 \ldots a_n $$$ value say constant $$$ m $$$ integer $$$ k $$$ need split array $$$ a $$$ exactly $$$ k $$$ subarrays : first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 1 \le m $$$ $$$ 2 \le k $$$ $$$ m \cdot k \le n $$$ ) — number elements $$$ a $$$ constant $$$ m $$$ definition beauty number subarrays split second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) first line print maximum possible sum beauties subarrays optimal partition second line print $$$ k-1 $$$ integers $$$ p_1 p_2 \ldots p _ { k-1 } $$$ ( $$$ 1 \le p_1 < p_2 < \ldots < p _ { k-1 } < n $$$ ) represent partition array : several optimal partition print first example one optimal partition $$$ [ 5 2 5 ] $$$ $$$ [ 2 4 ] $$$ $$$ [ 1 1 3 2 ] $$$ sum beauties $$$ 10 + 6 + 5 = 21 $$$ second example one optimal partition $$$ [ 4 ] $$$ $$$ [ 1 3 ] $$$ $$$ [ 2 2 ] $$$ $$$ [ 3 ] $$$","['greedy', 'sortings']",1500.0
1117/A,give array $$$ a_1 a_2 \dots a_n $$$ find subsegment $$$ a_l a _ { l+1 } \dots a_r $$$ ( $$$ 1 \le l \le r \le n $$$ ) maximum arithmetic mean $$$ \frac { 1 } { r - l + 1 } \sum\limits _ { i = l } ^ { r } { a_i } $$$ ( floating - point number i.e without round ) many subsegments find longest one first line contain single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — array $$$ a $$$ print single integer — length longest subsegment maximum possible arithmetic mean subsegment $$$ [ 3 4 ] $$$ longest among subsegments maximum arithmetic mean,"['implementation', 'math']",1100.0
1117/B,"$$$ n $$$ emote popular digital <unknown> card game ( game pretty famous wo n't say name ) $$$ i $$$ -th emote increase opponent 's happiness $$$ a_i $$$ units ( know emote game use make opponents happy ) time use emote $$$ m $$$ time allow use emotion , use restriction use emote $$$ k $$$ time a row ( otherwise opponent think 're troll ) note two emote $$$ i $$$ $$$ j $$$ ( $$$ i \ne j $$$ ) $$$ a_i = a_j $$$ consider different make opponent happy possible find maximum possible opponent 's happiness first line input contain three integers $$$ n m $$$ $$$ k $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 1 \le k \le m \le 2000000000 $$$ ) — number emote number time use emote maximum number time may use emote a row second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ value happiness $$$ i $$$ -th emote print one integer — maximum opponent 's happiness use emote a way satisfy problem statement first example may use emote follow sequence : $$$ 4 4 5 4 4 5 4 4 5 $$$","['greedy', 'math', 'sortings']",1000.0
1120/F,little w little p decide send letter regard important events a day $$$ n $$$ events a day : time moment $$$ t_i $$$ something happen person $$$ p_i $$$ ( $$$ p_i $$$ either w p denote little w little p respectively ) need immediately send a letter person send a letter use one two ways : help friends determine minimum possible total cost send letter first line contain three integers $$$ n c d $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ 1 \leq c \leq 100 $$$ $$$ 1 \leq d \leq 100000000 $$$ ) — number letter cost store a letter one time unit wise r 's <unknown> cost deliver a letter via friendly o. next $$$ n $$$ describe events $$$ i $$$ -th contain integer $$$ t_i $$$ a character $$$ p_i $$$ ( $$$ 0 \leq t_i \leq 1000000 $$$ $$$ p_i $$$ either w p ) — time $$$ i $$$ -th event happen person event happen last line contain a single integer $$$ t _ { n + 1 } $$$ ( $$$ 0 \leq t _ { n+1 } \leq 1000000 $$$ ) — time everybody come wise r a tea take remain letter guarantee $$$ t_i < t _ { i + 1 } $$$ $$$ i $$$ $$$ 1 $$$ $$$ n $$$ print a single integer — minimum possible cost delivery letter one optimal solutions first example : total cost delivery thus $$$ 1 + 4 + 4 + 5 + 2 = 16 $$$ <unknown>,"['data structures', 'dp', 'greedy']",3100.0
113/E,"one day vasya lie bed watch electronic clock fall asleep quicker vasya live a strange country days h hours every hour m minutes clock show time decimal number system format h : m string h always a fix length equal number digits decimal representation number h - 1 . achieve lead zero add necessary string m a similar format length always equal number digits decimal representation number m - 1 . example h = 17 m = 1000 time equal 13 hours 75 minutes display ` ` <unknown> '' vasya watch clock h1 hours m1 minutes h2 hours m2 minutes inclusive fell asleep ask count many time saw moment least k digits change clock simultaneously example switch <unknown> → <unknown> two digits change switch 23:59 → 00:00 four digits change consider vasya watch clock strictly less one day note last time vasya saw clock fall asleep ` ` h2 : m2 '' , vasya n't see moment time ` ` h2 : m2 '' switch next value first line input file contain three space - separated integers h m k ( 2 ≤ h m ≤ 109 1 ≤ k ≤ 20 ) second line contain space - separated integers h1 m1 ( 0 ≤ h1 < h 0 ≤ m1 < m ) third line contain space - separated integers h2 m2 ( 0 ≤ h2 < h 0 ≤ m2 < m ) print a single number — number time vasya saw moment change least k digits simultaneously please use % lld specificator read write 64 - bit integers c++ prefer use cin stream ( also may use % i64d specificator ) first example vasya see follow moments time : 4:4 0:0 → <unknown> → <unknown> → <unknown> → <unknown> 1:0 → 1:1 → 1:2 → <unknown> → <unknown> 2:0 → 2:1 → 2:2 → <unknown> → 2:4 . double arrow ( ) mark seek moments time ( example — vasya see two number change simultaneously ) second example k = 1 . switch time accept since switch clock least one digit change total switch equal <unknown> = 1440 vasya see one — switch 23:59 00:00 . third example vasya fell asleep immediately begin look clock see change","['combinatorics', 'implementation', 'math']",2700.0
1131/A,"order make ` ` sea battle '' game interest boris decide add a new ship type ship consist two rectangles first rectangle a width $$$ w_1 $$$ a height $$$ h_1 $$$ second rectangle a width $$$ w_2 $$$ a height $$$ h_2 $$$ $$$ w_1 \ge w_2 $$$ game exactly one ship use make two rectangles ship field rectangles place field follow way : see picture note : first rectangle color red second rectangle color blue formally let 's introduce a coordinate system , leftmost bottom cell first rectangle coordinate $$$ ( 1 1 ) $$$ rightmost top cell first rectangle coordinate $$$ ( w_1 h_1 ) $$$ leftmost bottom cell second rectangle coordinate $$$ ( 1 h_1 + 1 ) $$$ rightmost top cell second rectangle coordinate $$$ ( w_2 h_1 + h_2 ) $$$ ship completely destroy cells neighbor side a corner ship mark course cells n't belong ship mark picture note cells color green find many cells mark ship destroy field game infinite direction four line contain integers $$$ w_1 h_1 w_2 $$$ $$$ h_2 $$$ ( $$$ 1 \leq w_1 h_1 w_2 h_2 \leq 100000000 $$$ $$$ w_1 \ge w_2 $$$ ) — width first rectangle height first rectangle width second rectangle height second rectangle ca n't rotate rectangles print exactly one integer — number cells mark ship destroy first example field look follow ( first rectangle red second rectangle blue green show mark square ) : second example field look :",['math'],800.0
1131/B,"still partial information score historic football match give a set pair $$$ ( a_i b_i ) $$$ indicate point match score ` ` $$$ a_i $$$ : $$$ b_i $$$ ` ` know current score « $$$ x $$$ : $$$ y $$$ » goal change ` ` $$$ x+1 $$$ : $$$ y $$$ ` ` ` ` $$$ x $$$ : $$$ y+1 $$$ ` ` largest number time a draw could appear scoreboard ? pair ` ` $$$ a_i $$$ : $$$ b_i $$$ ` ` give chronological order ( time increase ) give score moments time last pair correspond end match first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 10000 $$$ ) — number know moments match next $$$ n $$$ line contain integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 0 \le a_i b_i \le 1000000000 $$$ ) denote score match moment ( number goals first team number goals second team ) moments give chronological order , sequence $$$ x_i $$$ $$$ y_j $$$ non - decreasing last score denote final result match print maximum number moments time score a draw start moment match ( a score 0:0 ) also count example one possible score sequence lead maximum number draw follow : 0:0 1:0 2:0 2:1 <unknown> 3:2 <unknown> 3:4","['greedy', 'implementation']",1400.0
1131/E,"roman denis trip program competition since trip long soon get bore hence decide come something roman invent a pizza 's recipe denis invent a string multiplication accord denis result multiplication ( product ) string $$$ s $$$ length $$$ m $$$ $$$ t $$$ a string $$$ t + s_1 + t + s_2 + \ldots + t + s_m + t $$$ $$$ s_i $$$ denote $$$ i $$$ -th symbol string $$$ s $$$ ` ` + '' denote string concatenation example product string ` ` abc '' ` ` de '' a string ` ` <unknown> '' product string ` ` ab '' ` ` z '' a string ` ` <unknown> '' note unlike number multiplication product string $$$ s $$$ $$$ t $$$ necessarily equal product $$$ t $$$ $$$ s $$$ roman jealous denis since invent a cool operation hence decide invent something string - related since roman beauty - lover decide define beauty string length longest substring consist one letter example beauty string ` ` <unknown> '' equal $$$ 3 $$$ since a substring ` ` aaa '' beauty string ` ` <unknown> '' equal $$$ 1 $$$ since neighbor symbols different order entertain roman denis write $$$ n $$$ string $$$ p_1 p_2 p_3 \ldots p_n $$$ paper ask calculate beauty string $$$ ( \ldots ( ( ( p_1 \cdot p_2 ) \cdot p_3 ) \cdot \ldots ) \cdot p_n $$$ $$$ s \cdot t $$$ denote a multiplication string $$$ s $$$ $$$ t $$$ roman n't fully realize denis 's multiplication work ask a help denis know roman <unknown> guarantee beauty result string $$$ 1000000000 $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100\,000 $$$ ) — number string <unknown> denis next $$$ n $$$ line contain non - empty string $$$ p_1 p_2 \ldots p_n $$$ consist lowercase english letter 's guarantee total length string $$$ p_i $$$ $$$ 100\,000 $$$ 's beauty result product $$$ 1000000000 $$$ print exactly one integer — beauty product string first example product string equal ` ` abaaaba '' second example product string equal ` ` <unknown> ''","['dp', 'greedy', 'strings']",2300.0
1132/C,a long fence consist $$$ n $$$ section unfortunately paint decide hire $$$ q $$$ painters paint $$$ i $$$ -th painter paint section $$$ x $$$ $$$ l_i \le x \le r_i $$$ unfortunately a tight budget may hire $$$ q - 2 $$$ painters obviously painters hire work want maximize number paint section choose $$$ q - 2 $$$ painters optimally a section consider paint least one painter paint first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 3 \le n q \le 5000 $$$ ) — number section number painters availible hire respectively $$$ q $$$ line follow describe one painters : $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) print one integer — maximum number paint section hire $$$ q - 2 $$$ painters,['brute force'],1700.0
1132/E,a set items integer weight greater $$$ 8 $$$ denote a subset items good total weight items subset exceed $$$ w $$$ want calculate maximum possible weight a good subset items note consider empty set original set calculate answer first line contain one integer $$$ w $$$ ( $$$ 0 \le w \le 10^ { 18 } $$$ ) — maximum total weight a good subset second line denote set items contain $$$ 8 $$$ integers $$$ cnt_1 $$$ $$$ cnt_2 $$$ ... $$$ <unknown> $$$ ( $$$ 0 \le cnt_i \le 10^ { 16 } $$$ ) $$$ cnt_i $$$ number items weight $$$ i $$$ set print one integer — maximum possible weight a good subset items,"['dfs and similar', 'dp', 'greedy']",2300.0
1132/G,"array $$$ c $$$ let 's denote a greedy subsequence a sequence indices $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_l $$$ $$$ 1 \le p_1 < p_2 < \dots < p_l \le |c| $$$ $$$ i \in [ 1 l - 1 ] $$$ $$$ p _ { i + 1 } $$$ minimum number $$$ p _ { i + 1 } > p_i $$$ $$$ c [ p _ { i + 1 } ] > c [ p_i ] $$$ give array $$$ a_1 a_2 \dots a_n $$$ subsegment length $$$ k $$$ calculate length longest greedy subsequence first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 1000000 $$$ ) — length array $$$ a $$$ length subsegments second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — array $$$ a $$$ print $$$ n - k + 1 $$$ integers — maximum lengths greedy subsequences subsegment length $$$ k $$$ first number correspond subsegment $$$ a [ 1 .. k ] $$$ second — subsegment $$$ a [ 2 .. k + 1 ] $$$ , first example : second example :","['data structures', 'dp', 'trees']",2400.0
1133/A,polycarp go participate contest start $$$ h_1 : m_1 $$$ end $$$ h_2 : m_2 $$$ guarantee contest last even number minutes ( i.e $$$ m_1 \ % 2 = m_2 \ % 2 $$$ $$$ x \ % y $$$ $$$ x $$$ modulo $$$ y $$$ ) also guarantee entire contest hold a single day finally guarantee contest last least two minutes polycarp want know time midpoint contest example contest last $$$ <unknown> $$$ $$$ <unknown> $$$ answer $$$ <unknown> $$$ contest last $$$ <unknown> $$$ $$$ <unknown> $$$ answer $$$ 11:11 $$$ first line input contain two integers $$$ h_1 $$$ $$$ m_1 $$$ format hh : mm second line input contain two integers $$$ h_2 $$$ $$$ m_2 $$$ format ( hh : mm ) guarantee $$$ 0 \le h_1 h_2 \le 23 $$$ $$$ 0 \le m_1 m_2 \le 59 $$$ guarantee contest last even number minutes ( i.e $$$ m_1 \ % 2 = m_2 \ % 2 $$$ $$$ x \ % y $$$ $$$ x $$$ modulo $$$ y $$$ ) also guarantee entire contest hold a single day finally guarantee contest last least two minutes print two integers $$$ h_3 $$$ $$$ m_3 $$$ ( $$$ 0 \le h_3 \le 23 0 \le m_3 \le 59 $$$ ) correspond midpoint contest format hh : mm print number exactly two digits ( prepend a number lead zero need ) separate ' : ',['implementation'],1000.0
1133/F2,give undirected unweighted connect graph consist $$$ n $$$ vertices $$$ m $$$ edge guarantee self - loops multiple edge give graph task find span tree graph degree first vertex ( vertex label $$$ 1 $$$ ) equal $$$ d $$$ ( say span tree ) recall degree a vertex number edge incident first line contain three integers $$$ n $$$ $$$ m $$$ $$$ d $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ n - 1 \le m \le min ( 2 \cdot 100000 \frac { n ( n-1 ) } { 2 } ) 1 \le d < n $$$ ) — number vertices number edge require degree first vertex respectively follow $$$ m $$$ line denote edge : edge $$$ i $$$ represent a pair integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ $$$ u_i \ne v_i $$$ ) indices vertices connect edge loop multiple edge give graph i. e. pair ( $$$ v_i u_i $$$ ) pair ( $$$ v_i u_i $$$ ) ( $$$ u_i v_i $$$ ) list edge pair $$$ ( v_i u_i ) $$$ condition $$$ v_i \ne u_i $$$ satisfy span tree satisfy condition problem statement print ` ` '' first line otherwise print ` ` yes '' first line print $$$ n-1 $$$ line describe edge a span tree degree first vertex ( vertex label $$$ 1 $$$ ) equal $$$ d $$$ make sure edge print span tree form subset input edge ( order n't matter edge $$$ ( v u ) $$$ consider edge $$$ ( u v ) $$$ ) multiple possible answer print picture correspond first second examples : picture correspond third example :,"['dfs and similar', 'dsu', 'graphs', 'greedy']",1900.0
1136/D,big break nastya come school din room $$$ n $$$ pupils school number $$$ 1 $$$ $$$ n $$$ unfortunately nastya come pretty late pupils already stand queue i.e nastya take last place queue course 's a little bite sad nastya go <unknown> pupils queue agree change place pupils formally pair $$$ u $$$ $$$ v $$$ pupil number $$$ u $$$ stand directly front pupil number $$$ v $$$ nastya ask change place nastya ask find maximal number place queue move forward first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 3 \cdot 10^ { 5 } $$$ $$$ 0 \leq m \leq 5 \cdot 10^ { 5 } $$$ ) — number pupils queue number pair pupils first one agree change place second one first directly front second second line contain $$$ n $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_n $$$ — initial arrangement pupils queue queue start end ( $$$ 1 \leq p_i \leq n $$$ $$$ p $$$ a permutation integers $$$ 1 $$$ $$$ n $$$ ) word $$$ p_i $$$ number pupil stand $$$ i $$$ -th position queue $$$ i $$$ -th follow $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n u_i \neq v_i $$$ ) denote pupil number $$$ u_i $$$ agree change place pupil number $$$ v_i $$$ $$$ u_i $$$ directly front $$$ v_i $$$ guarantee $$$ i \neq j $$$ $$$ v_i \neq v_j $$$ $$$ u_i \neq u_j $$$ note possible pair pupils agree change place nastya last person queue i.e pupil number $$$ p_n $$$ print a single integer — number place queue move forward first example nastya change place first pupil queue optimal sequence change second example queue look like $$$ [ 3 1 2 ] $$$ $$$ [ 1 3 2 ] $$$ $$$ [ 1 2 3 ] $$$ finally $$$ [ 2 1 3 ] $$$ operations,['greedy'],1800.0
1137/F,"lena play match natural question arise head child play match whether 's possible set a tree fire a match , let 's say tree a connect graph without cycle vertices label integers $$$ 1 2 \ldots n $$$ also every vertex $$$ v $$$ integer priority $$$ p_v $$$ associate priorities distinct turn set a tree fire burn nothing however process n't happen instantly begin burn leaf ( a vertex call a leaf one adjacent vertex ) tree minimum priority burn leaf minimal priority remain tree , way vertices turn leave burn one vertex remain vertex burn well lena prepare a tree $$$ n $$$ vertices every vertex a priority $$$ p_v = v $$$ lena curious burn tree however understand burn tree disappear completely lena a kind girl feel bad burn tree want study process burn tree mind lena want process $$$ q $$$ query one three follow type : notice priorities would distinct ` ` '' query stay distinct well initially priorities distinct hence ( <unknown> hypothetical course ) burn tree leaf would distinct priorities first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \le n \le 200\,000 $$$ $$$ 1 \le q \le 200\,000 $$$ ) — number vertices tree number query $$$ i $$$ -th follow $$$ n - 1 $$$ line contain two integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ ) denote endpoints $$$ i $$$ -th edge remain $$$ q $$$ line contain a query one follow three type : 's guarantee least one query type ` ` '' ` ` compare '' every query type ` ` '' print one integer range $$$ 1 $$$ $$$ n $$$ — step vertex $$$ v $$$ burn every query type ` ` compare '' print either $$$ v $$$ $$$ u $$$ depend one burn earlier first example process burn tree illustrate follow picture : particular vertices tree burn follow order : $$$ [ 2 4 3 1 5 ] $$$ second example apply ` ` '' operation order vertices change : $$$ [ 2 4 3 5 1 ] $$$","['data structures', 'trees']",3400.0
114/B,little petya grow enter university start take part асм contest later realize n't like асм contest organise : team could three members ( could n't take friends competitions distribute task team members efficiently ) decide organize contest pfast inc . — petr friends solve task corporation pfast inc . rule allow a team unlimited number members make format contest popular organise tournament create team prepare contest organise pfast inc . rule choose several volunteer ( 16 people ) decide compile a team petya understand perfectly a team two people n't get well team perform poorly put together a team many players possible give players get well first line contain two integer number n ( 1 ≤ n ≤ 16 ) — number volunteer m ( ) — number pair get next n line contain volunteer ' name ( name a non - empty string consist 10 uppercase and/or lowercase latin letter ) next m line contain two name — name volunteer get name pair separate a single space pair volunteer get occur exactly string case - sensitive n name distinct first output line contain single number k — number people seek team next k line contain name seek team 's participants lexicographical order several variants solve problem print petya might a member seek team,"['bitmasks', 'brute force', 'graphs']",1500.0
1140/G,"give a special undirected graph consist $$$ 2n $$$ vertices number $$$ 1 $$$ $$$ 2n $$$ follow properties hold graph : graph represent two tree structure $$$ n $$$ edge connect vertex first tree correspond vertex second tree edge graph weight length simple path graph sum weight traverse edge give $$$ q $$$ query graph ; query ask compute length shortest path pair vertices graph answer query ? first line input contain one integer $$$ n $$$ ( $$$ 2 \le n \le 300000 $$$ ) second line contain $$$ n $$$ integers $$$ w _ { 1 2 } $$$ $$$ w _ { 3,4 } $$$ ... $$$ w _ { 2n - 1 2n } $$$ ( $$$ 1 \le w _ { i i + 1 } \le 10^ { 12 } $$$ ) integers describe weight edge connect odd vertices even ones $$$ n-1 $$$ line follow $$$ i $$$ -th line contain four integers $$$ x_i $$$ $$$ y_i $$$ $$$ w _ { i 1 } $$$ $$$ w _ { i 2 } $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ $$$ 1 \le w _ { i j } \le 10^ { 12 } $$$ ) ; describe two edge : one connect $$$ 2x_i - 1 $$$ $$$ 2y_i - 1 $$$ weight $$$ w _ { i 1 } $$$ ; another connect $$$ 2x_i $$$ $$$ 2y_i $$$ weight $$$ w _ { i 2 } $$$ next line contain one integer $$$ q $$$ ( $$$ 1 \le q \le <unknown> $$$ ) — number query $$$ q $$$ line follow $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le 2n $$$ $$$ u_i \ne v_i $$$ ) describe a query ` ` compute length shortest path vertices $$$ u_i $$$ $$$ v_i $$$ ` ` print $$$ q $$$ integers $$$ i $$$ -th integer equal answer $$$ i $$$ -th query graph first test look like :","['data structures', 'divide and conquer', 'shortest paths', 'trees']",2700.0
1141/F1,problem give two editions differ exclusively constraints number $$$ n $$$ give array integers $$$ a [ 1 ] a [ 2 ] \dots a [ n ] $$$ a block a sequence contiguous ( consecutive ) elements $$$ a [ l ] a [ l+1 ] \dots a [ r ] $$$ ( $$$ 1 \le l \le r \le n $$$ ) thus a block define a pair indices $$$ ( l r ) $$$ find a set block $$$ ( l_1 r_1 ) ( l_2 r_2 ) \dots ( l_k r_k ) $$$ : write a program find a set block first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — length give array second line contain sequence elements $$$ a [ 1 ] a [ 2 ] \dots a [ n ] $$$ ( $$$ -100000 \le a_i \le 100000 $$$ ) first line print integer $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) follow $$$ k $$$ line contain block one per line line print a pair indices $$$ l_i r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) — bound $$$ i $$$ -th block print block order multiple answer print,['greedy'],1900.0
1141/F2,problem give two editions differ exclusively constraints number $$$ n $$$ give array integers $$$ a [ 1 ] a [ 2 ] \dots a [ n ] $$$ a block a sequence contiguous ( consecutive ) elements $$$ a [ l ] a [ l+1 ] \dots a [ r ] $$$ ( $$$ 1 \le l \le r \le n $$$ ) thus a block define a pair indices $$$ ( l r ) $$$ find a set block $$$ ( l_1 r_1 ) ( l_2 r_2 ) \dots ( l_k r_k ) $$$ : write a program find a set block first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 1500 $$$ ) — length give array second line contain sequence elements $$$ a [ 1 ] a [ 2 ] \dots a [ n ] $$$ ( $$$ -100000 \le a_i \le 100000 $$$ ) first line print integer $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) follow $$$ k $$$ line contain block one per line line print a pair indices $$$ l_i r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) — bound $$$ i $$$ -th block print block order multiple answer print,"['data structures', 'greedy']",1900.0
1142/B,recently lynyrd skynyrd go a shop lynyrd buy a permutation $$$ p $$$ length $$$ n $$$ skynyrd buy array $$$ a $$$ length $$$ m $$$ consist integers $$$ 1 $$$ $$$ n $$$ lynyrd skynyrd become bore ask $$$ q $$$ query follow form : ` ` subsegment $$$ a $$$ $$$ l $$$ -th $$$ r $$$ -th position inclusive a subsequence a cyclic shift $$$ p $$$ ? '' please answer query a permutation length $$$ n $$$ a sequence $$$ n $$$ integers integer $$$ 1 $$$ $$$ n $$$ appear exactly a cyclic shift a permutation $$$ ( p_1 p_2 \ldots p_n ) $$$ a permutation $$$ ( p_i p _ { i + 1 } \ldots p _ { n } p_1 p_2 \ldots p _ { i - 1 } ) $$$ $$$ i $$$ $$$ 1 $$$ $$$ n $$$ example a permutation $$$ ( 2 1 3 ) $$$ three distinct cyclic shift : $$$ ( 2 1 3 ) $$$ $$$ ( 1 3 2 ) $$$ $$$ ( 3 2 1 ) $$$ a subsequence a subsegment array $$$ a $$$ $$$ l $$$ -th $$$ r $$$ -th position inclusive a sequence $$$ a _ { i_1 } a _ { i_2 } \ldots a _ { i_k } $$$ $$$ i_1 i_2 \ldots i_k $$$ $$$ l \leq i_1 < i_2 < \ldots < i_k \leq r $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \le n m q \le 200000 $$$ ) — length permutation $$$ p $$$ length array $$$ a $$$ number query next line contain $$$ n $$$ integers $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th $$$ i $$$ -th element permutation integer $$$ 1 $$$ $$$ n $$$ appear exactly next line contain $$$ m $$$ integers $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th $$$ i $$$ -th element array $$$ a $$$ next $$$ q $$$ line describe query $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le m $$$ ) mean $$$ i $$$ -th query subsegment array $$$ l_i $$$ -th $$$ r_i $$$ -th position inclusive print a single string length $$$ q $$$ consist $$$ 0 $$$ $$$ 1 $$$ digit $$$ i $$$ -th position $$$ 1 $$$ subsegment array $$$ a $$$ $$$ l_i $$$ -th $$$ r_i $$$ -th position inclusive contain a subsequence a cyclic shift $$$ p $$$ $$$ 0 $$$ otherwise first example segment $$$ 1 $$$ -st $$$ 5 $$$ -th position $$$ 1 2 3 1 2 $$$ a subsequence $$$ 1 3 2 $$$ a cyclic shift permutation subsegment $$$ 2 $$$ -nd $$$ 6 $$$ -th position also contain a subsequence $$$ 2 1 3 $$$ equal permutation subsegment $$$ 3 $$$ -rd $$$ 5 $$$ -th position $$$ 3 1 2 $$$ one subsequence length $$$ 3 $$$ ( $$$ 3 1 2 $$$ ) a cyclic shift permutation second example possible cyclic shift $$$ 1 2 $$$ $$$ 2 1 $$$ subsegment $$$ 1 $$$ -st $$$ 2 $$$ -nd position $$$ 1 1 $$$ subsequences cyclic shift permutation subsegment $$$ 2 $$$ -nd $$$ 3 $$$ -rd position $$$ 1 2 $$$ coincide permutation subsegment $$$ 3 $$$ $$$ 4 $$$ position $$$ 2 2 $$$ subsequences cyclic shift permutation,"['data structures', 'dfs and similar', 'dp', 'math', 'trees']",2000.0
1144/F,give a connect undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge self - loops multiple edge give graph direct edge a way obtain direct graph contain paths length two greater ( length path denote number traverse edge ) first line contain two integer number $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ n - 1 \le m \le 200000 $$$ ) — number vertices edge respectively follow $$$ m $$$ line contain edge : edge $$$ i $$$ give a pair vertices $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) multiple edge give graph i. e. pair ( $$$ u_i v_i $$$ ) pair ( $$$ u_i v_i $$$ ) ( $$$ v_i u_i $$$ ) list edge also guarantee give graph connect ( a path pair vertex give graph ) impossible direct edge give graph a way obtain direct graph contain paths length least two print ` ` '' first line otherwise print ` ` yes '' first line print suitable orientation edge : a binary string ( string consist ' 0 ' ' 1 ' ) length $$$ m $$$ $$$ i $$$ -th element string ' 0 ' $$$ i $$$ -th edge graph direct $$$ u_i $$$ $$$ v_i $$$ ' 1 ' otherwise edge number order give input picture correspond first example : one possible answer :,"['dfs and similar', 'graphs']",1700.0
1146/B,bob a string $$$ s $$$ consist lowercase english letter define $$$ s ' $$$ string remove ` ` a '' character $$$ s $$$ ( keep character order ) generate a new string $$$ t $$$ concatenate $$$ s $$$ $$$ s ' $$$ word $$$ t = <unknown> ' $$$ ( look note example ) give a string $$$ t $$$ task find $$$ s $$$ bob could use generate $$$ t $$$ show answer exist unique first line input contain a string $$$ t $$$ ( $$$ 1 \leq |t| \leq 100000 $$$ ) consist lowercase english letter print a string $$$ s $$$ could generate $$$ t $$$ show answer exist unique string exist print ` ` : ( ` ` ( without double quote space character ) first example $$$ s = $$$ ` ` aaaaa '' $$$ s ' = $$$ ` ` '' second example $$$ s $$$ work generate give $$$ t $$$ third example $$$ s = $$$ ` ` <unknown> '' $$$ s ' = $$$ ` ` <unknown> '' $$$ t = s + s ' = $$$ ` ` <unknown> '',"['implementation', 'strings']",1100.0
1147/A,"alice bob play a game a line $$$ n $$$ cells $$$ n $$$ cells label $$$ 1 $$$ $$$ n $$$ $$$ i $$$ $$$ 1 $$$ $$$ n-1 $$$ cells $$$ i $$$ $$$ i+1 $$$ adjacent alice initially a token cell line bob try guess bob guess a sequence line cell number $$$ x_1 x_2 \ldots x_k $$$ order $$$ i $$$ -th question bob ask alice token currently cell $$$ x_i $$$ , alice answer either ` ` yes '' ` ` '' bob 's question one time process answer a question alice allow move token current cell adjacent cell alice act a way able answer ` ` '' bob 's question note alice even move token answer first question answer last question alice also choose move give $$$ n $$$ bob 's question $$$ x_1 \ldots x_k $$$ would like count number scenarios let alice answer ` ` '' bob 's question let $$$ ( a b ) $$$ denote a scenario alice start cell $$$ a $$$ end cell $$$ b $$$ two scenarios $$$ ( a_i b_i ) $$$ $$$ ( a_j b_j ) $$$ different $$$ a_i \neq a_j $$$ $$$ b_i \neq b_j $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n k \leq 100000 $$$ ) — number cells number question bob ask second line contain $$$ k $$$ integers $$$ x_1 x_2 \ldots x_k $$$ ( $$$ 1 \leq x_i \leq n $$$ ) — bob 's question print a single integer number scenarios let alice answer ` ` '' bob 's question notation $$$ ( i j ) $$$ denote a scenario alice start cell $$$ i $$$ end cell $$$ j $$$ first example valid scenarios $$$ ( 1 2 ) ( 2 1 ) ( 2 2 ) ( 2 3 ) ( 3 2 ) ( 3 3 ) ( 3 4 ) ( 4 3 ) ( 4 5 ) $$$ example $$$ ( 3,4 ) $$$ valid since alice start cell $$$ 3 $$$ stay first three question move cell $$$ 4 $$$ last question $$$ ( 4,5 ) $$$ valid since alice start cell $$$ 4 $$$ stay first question move cell $$$ 5 $$$ next two question note $$$ ( 4,5 ) $$$ count even though different question alice choose move remember count pair start end position second example alice valid scenarios last example $$$ ( i j ) $$$ $$$ |i - j| \leq 1 $$$ except $$$ ( 42 42 ) $$$ valid scenarios",['graphs'],1500.0
115/C,little john <unknown> become a <unknown> ! today draw a grid consist n row m columns consist n × m square cells cell draw a pipe segment draw four type segment number 1 4 illustrate follow : pipe segment two end illustrate arrows picture example segment 1 end top leave side little john consider pip system leak least one pipe segment inside grid whose end connect another pipe 's end border grid image show example leak non - leaking systems size 1 × 2 . give grid partially fill little john cell either contain one four segment empty find number possible different non - leaking final systems little john finish fill empty cells pipe segment print number modulo 1000003 ( 106 + 3 ) note rotations flip grid allow two configurations identical one rotate flip either horizontally vertically consider two different configurations first line contain two single - space separate integers n m ( 1 ≤ n m n·m ≤ 5·105 ) — number row columns respectively n line follow contain exactly m character — description grid character describe a cell either one : print a single integer denote number possible final non - leaking pipe systems modulo 1000003 ( 106 + 3 ) configurations print 0 . first example initial configuration grid follow two possible final non - leaking pipe configurations follow : second example initial grid already leak final grid non - leaking final example 's one possible non - leaking final grid follow,['math'],2200.0
115/E,a car race organizer would like arrange race linear kingdom linear kingdom n consecutive roads span leave right roads number 1 n leave right thus roads follow order number ' increase several race may hold roads race use a consecutive subset roads also race pay amount money race hold race overlap time roads use several race unfortunately roads a bad condition need repair road repair cost associate require pay cost repair road a race take place roads use race renovate task repair roads ( possibly none ) maximize profit profit define total money get race hold minus total money spend repair roads note may decide repair road gain zero profit print maximum profit gain first line contain two single - space separate integers n m ( 1 ≤ n m ≤ 2·105 ) denote number roads number race respectively n line follow line contain a single non - negative integer exceed 109 denote cost repair a road cost give order road 1 road n. finally m line follow line single - space - separated triplets integers triplet give lb ub p ( 1 ≤ lb ≤ ub ≤ n 1 ≤ p ≤ 109 ) mean race three integers describe use roads lb ub inclusive 's hold get p. print a single integer denote maximum possible profit gain please use % lld specificator read write 64 - bit integers c++ recommend use cin cout stream ( also may use % i64d specificator ) first sample optimal solution repair roads 1 2 3 7 . three race take place net 15 . road repair cost 11 hence profit 4,"['data structures', 'dp']",2400.0
1151/A,today scientific lyceum kingdom kremland a biology lesson topic lesson genomes let 's call genome string ` ` actg '' maxim bore sit class teacher come a task : a give string $$$ s $$$ consist uppercase letter length least $$$ 4 $$$ need find minimum number operations need apply genome appear a substring one operation replace letter string $$$ s $$$ next previous alphabet example letter ` ` d '' previous one ` ` c '' next — ` ` e '' problem assume letter ` ` a '' previous one letter ` ` z '' next one ` ` b '' letter ` ` z '' previous one letter ` ` y '' next one letter ` ` a '' help maxim solve problem teacher give a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end first line contain a single integer $$$ n $$$ ( $$$ 4 \leq n \leq 50 $$$ ) — length string $$$ s $$$ second line contain string $$$ s $$$ consist exactly $$$ n $$$ uppercase letter latin alphabet output minimum number operations need apply string $$$ s $$$ genome appear a substring first example replace letter ` ` z '' ` ` a '' one operation letter ` ` h '' — letter ` ` g '' one operation get string ` ` actg '' genome present a substring second example replace letter ` ` a '' ` ` c '' two operations letter ` ` d '' — letter ` ` a '' three operations get string ` ` <unknown> '' a genome,"['brute force', 'strings']",1000.0
1152/E,"a permutation length $$$ k $$$ a sequence $$$ k $$$ integers $$$ 1 $$$ $$$ k $$$ contain integer exactly example sequence $$$ [ 3 1 2 ] $$$ a permutation length $$$ 3 $$$ neko five think array $$$ a $$$ $$$ n $$$ positive integers a permutation $$$ p $$$ length $$$ n - 1 $$$ , perform follow : example array $$$ a $$$ $$$ [ 3 4 6 5 7 ] $$$ permutation $$$ p $$$ $$$ [ 2 4 1 3 ] $$$ neko would construct follow array : write two array $$$ b ' $$$ $$$ c ' $$$ a piece paper forget 14 years later clean room discover old piece paper two array $$$ b ' $$$ $$$ c ' $$$ write however ca n't remember array $$$ a $$$ permutation $$$ p $$$ use case neko make a mistake array $$$ a $$$ permutation $$$ p $$$ result $$$ b ' $$$ $$$ c ' $$$ print -1 . otherwise help recover possible array $$$ a $$$ first line contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 100000 $$$ ) — number elements array $$$ a $$$ second line contain $$$ n-1 $$$ integers $$$ b'_1 <unknown> \ldots b ' _ { n-1 } $$$ ( $$$ 1 \leq b'_i \leq 1000000000 $$$ ) third line contain $$$ n-1 $$$ integers $$$ <unknown> <unknown> \ldots c ' _ { n-1 } $$$ ( $$$ 1 \leq <unknown> \leq 1000000000 $$$ ) neko make a mistake array $$$ a $$$ a permutation $$$ p $$$ lead $$$ b ' $$$ $$$ c ' $$$ print -1 . otherwise print $$$ n $$$ positive integers $$$ a_i $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) denote elements array $$$ a $$$ multiple possible solutions print first example explain problem statement third example $$$ a = [ 3 4 5 2 1 4 3 2 ] $$$ a possible permutation $$$ p $$$ $$$ [ 7 1 5 4 3 2 6 ] $$$ case neko would construct follow array :","['dfs and similar', 'graphs']",2400.0
1153/B,luckily serval get onto right bus come kindergarten time come kindergarten find toy bricks funny a special interest create difficult problems others solve time many $$$ 1 \times 1 \times 1 $$$ toy bricks build a 3 - dimensional object describe object a $$$ n \times m $$$ matrix cell $$$ ( i j ) $$$ $$$ h _ { i j } $$$ bricks stand top however serval n't give $$$ h _ { i j } $$$ give front view leave view top view object ask restore object note front view $$$ m $$$ columns $$$ i $$$ -th height maximum $$$ h _ { 1 i } h _ { 2 i } \dots h _ { n i } $$$ similar leave view $$$ n $$$ columns top view $$$ n \times m $$$ matrix $$$ t _ { i j } $$$ $$$ t _ { i j } $$$ $$$ 0 $$$ $$$ 1 $$$ $$$ t _ { i j } $$$ equal $$$ 1 $$$ mean $$$ h _ { i j } > 0 $$$ otherwise $$$ h _ { i j } = 0 $$$ however serval lonely others bore <unknown> problems refuse solve one although time promise least one object satisfy view best friend a try ? first line contain three positive space - separated integers $$$ n m h $$$ ( $$$ 1\leq n m h \leq 100 $$$ ) — length width height second line contain $$$ m $$$ non - negative space - separated integers $$$ a_1 a_2 \dots a_m $$$ $$$ a_i $$$ height $$$ i $$$ -th column leave right front view ( $$$ 0\leq a_i \leq h $$$ ) third line contain $$$ n $$$ non - negative space - separated integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ 0\leq b_j \leq h $$$ ) $$$ b_j $$$ height $$$ j $$$ -th column leave right leave view follow $$$ n $$$ line contain $$$ m $$$ number $$$ 0 $$$ $$$ 1 $$$ represent top view $$$ j $$$ -th number $$$ i $$$ -th row $$$ 1 $$$ $$$ h _ { i j } > 0 $$$ $$$ 0 $$$ otherwise guarantee least one structure satisfy input output $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th number $$$ i $$$ -th line equal height correspond position top view several object satisfy view output one graph illustrate object first example first graph illustrate object example output second example second graph show three - view draw,['greedy'],1200.0
1153/D,serval a junior high school student japari middle school still thrill math a talented boy mathematics like play number time want play number a root tree a tree a connect graph without cycle a root tree a special vertex call root a parent a node $$$ v $$$ last different $$$ v $$$ vertex path root vertex $$$ v $$$ children vertex $$$ v $$$ nod $$$ v $$$ parent a vertex a leaf children root tree serval own $$$ n $$$ nod node $$$ 1 $$$ root serval write number nod tree however restrictions nod except leave operation $$$ \max $$$ $$$ \min $$$ write indicate number node equal maximum minimum number sons respectively assume $$$ k $$$ leave tree serval want put integers $$$ 1 2 \ldots k $$$ $$$ k $$$ leave ( number use exactly ) love large number want maximize number root best friend help ? first line contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 3\cdot 100000 $$$ ) size tree second line contain $$$ n $$$ integers $$$ i $$$ -th represent operation node $$$ i $$$ $$$ 0 $$$ represent $$$ \min $$$ $$$ 1 $$$ represent $$$ \max $$$ node a leaf still a number $$$ 0 $$$ $$$ 1 $$$ ignore third line contain $$$ n-1 $$$ integers $$$ f_2 f_3 \ldots f_n $$$ ( $$$ 1 \leq f_i \leq i-1 $$$ ) $$$ f_i $$$ represent parent node $$$ i $$$ output one integer — maximum possible number root tree picture explain examples number write middle nod indices number write top number write nod first example matter arrange number answer $$$ 1 $$$ second example matter arrange number answer $$$ 4 $$$ third example one best solution achieve $$$ 4 $$$ arrange $$$ 4 $$$ $$$ 5 $$$ nod $$$ 4 $$$ $$$ 5 $$$ fourth example best solution arrange $$$ 5 $$$ node $$$ 5 $$$,"['binary search', 'dfs and similar', 'dp', 'greedy', 'trees']",1900.0
1154/A,"polycarp guess three positive integers $$$ a $$$ $$$ b $$$ $$$ c $$$ keep number secret write four number a board arbitrary order — pairwise sum ( three number ) sum three number ( one number ) , four number a board random order : $$$ a+b $$$ $$$ a+c $$$ $$$ b+c $$$ $$$ a+b+c $$$ guess three number $$$ a $$$ $$$ b $$$ $$$ c $$$ use give number print three guess integers order pay attention give number $$$ a $$$ $$$ b $$$ $$$ c $$$ equal ( also possible $$$ a = b = c $$$ ) line input contain four positive integers $$$ x_1 x_2 x_3 x_4 $$$ ( $$$ 2 \le x_i \le 1000000000 $$$ ) — number write a board random order guarantee answer exist give number $$$ x_1 x_2 x_3 x_4 $$$ print positive integers $$$ a $$$ $$$ b $$$ $$$ c $$$ four number write a board value $$$ a+b $$$ $$$ a+c $$$ $$$ b+c $$$ $$$ a+b+c $$$ write order print $$$ a $$$ $$$ b $$$ $$$ c $$$ order several answer print guarantee answer exist",['math'],800.0
1154/E,"$$$ n $$$ students stand a row two coach form two team — first coach choose first team second coach choose second team $$$ i $$$ -th student integer program skill $$$ a_i $$$ program skills distinct $$$ 1 $$$ $$$ n $$$ inclusive firstly first coach choose student maximum program skill among students take team $$$ k $$$ closest students leave $$$ k $$$ closest students right ( less $$$ k $$$ students leave right choose ) students choose leave row join first team secondly second coach make move ( students choose join second team ) first coach make move , repeat row become empty ( i. e. process end student become team ) problem determine students take first team students take second team first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 200000 $$$ ) — number students value determine range choose students move respectively second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) $$$ a_i $$$ program skill $$$ i $$$ -th student guarantee program skills distinct print a string $$$ n $$$ character ; $$$ i $$$ -th character 1 $$$ i $$$ -th student join first team 2 otherwise first example first coach choose student a position $$$ 3 $$$ row become empty ( students join first team ) second example first coach choose student position $$$ 4 $$$ row become $$$ [ 2 1 ] $$$ ( students program skills $$$ [ 3 4 5 ] $$$ join first team ) second coach choose student position $$$ 1 $$$ row become empty ( students program skills $$$ [ 1 2 ] $$$ join second team ) third example first coach choose student position $$$ 1 $$$ row become $$$ [ 1 3 5 4 6 ] $$$ ( students program skills $$$ [ 2 7 ] $$$ join first team ) second coach choose student position $$$ 5 $$$ row become $$$ [ 1 3 5 ] $$$ ( students program skills $$$ [ 4 6 ] $$$ join second team ) first coach choose student position $$$ 3 $$$ row become $$$ [ 1 ] $$$ ( students program skills $$$ [ 3 5 ] $$$ join first team ) second coach choose remain student ( student program skill $$$ 1 $$$ join second team ) fourth example first coach choose student position $$$ 3 $$$ row become $$$ [ 2 1 ] $$$ ( students program skills $$$ [ 3 4 5 ] $$$ join first team ) second coach choose student position $$$ 1 $$$ row become empty ( students program skills $$$ [ 1 2 ] $$$ join second team )","['data structures', 'implementation', 'sortings']",1800.0
1155/B,a telephone number a sequence exactly $$$ 11 $$$ digits first digit 8 . vasya petya play a game initially a string $$$ s $$$ length $$$ n $$$ ( $$$ n $$$ odd ) consist digits vasya make first move players alternate turn one move player must choose a character erase current string example current string 1121 player 's move may 112 111 121 . game end length string $$$ s $$$ become 11 . result string a telephone number vasya win otherwise petya win determine vasya a win strategy ( vasya win game matter character petya choose move ) first line contain one integer $$$ n $$$ ( $$$ 13 \le n < 100000 $$$ $$$ n $$$ odd ) — length string $$$ s $$$ second line contain string $$$ s $$$ ( $$$ |s| = n $$$ ) consist decimal digits vasya a strategy guarantee victory print yes otherwise print first example vasya need erase second character petya erase a character remain string <unknown> become a telephone number second example vasya 's turn petya erase one character character 8 . result string ca n't a telephone number digit 8,"['greedy', 'implementation']",1200.0
1157/B,give a long decimal number $$$ a $$$ consist $$$ n $$$ digits $$$ 1 $$$ $$$ 9 $$$ also a function $$$ f $$$ map every digit $$$ 1 $$$ $$$ 9 $$$ ( possibly ) digit $$$ 1 $$$ $$$ 9 $$$ perform follow operation : choose a non - empty contiguous subsegment digits $$$ a $$$ replace digit $$$ x $$$ segment $$$ f ( x ) $$$ example $$$ a = 1337 $$$ $$$ f ( 1 ) = 1 $$$ $$$ f ( 3 ) = 5 $$$ $$$ f ( 7 ) = 3 $$$ choose segment consist three rightmost digits get $$$ <unknown> $$$ result maximum possible number obtain apply operation ? first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number digits $$$ a $$$ second line contain a string $$$ n $$$ character denote number $$$ a $$$ character a decimal digit $$$ 1 $$$ $$$ 9 $$$ third line contain exactly $$$ 9 $$$ integers $$$ f ( 1 ) $$$ $$$ f ( 2 ) $$$ ... $$$ f ( 9 ) $$$ ( $$$ 1 \le f ( i ) \le 9 $$$ ) print maximum number get apply operation describe statement,['greedy'],1300.0
1158/E,"interactive problem vasya enjoy solve quiz find a strange device want know work device encrypt tree ( connect undirected graph without cycle ) $$$ n $$$ vertices number integers $$$ 1 $$$ $$$ n $$$ solve quiz guess tree fortunately device make one operation use guess cipher give device array $$$ d_1 d_2 \ldots d_n $$$ non - negative integers device $$$ n $$$ lamps $$$ i $$$ -th connect $$$ i $$$ -th vertex tree $$$ i $$$ light turn $$$ i $$$ -th lamp exist vertex tree number $$$ j \neq i $$$ $$$ dist ( i j ) \leq d_j $$$ let 's define $$$ dist ( i j ) $$$ distance vertices $$$ i $$$ $$$ j $$$ tree number edge simple path vertices $$$ i $$$ $$$ j $$$ vasya want solve quiz use $$$ \leq 80 $$$ operations device guess tree help ! begin program read one integer $$$ n $$$ — number vertices tree encrypt device ( $$$ 2 \leq n \leq 1000 $$$ ) , make several operations follow format operation print a symbol '' ? '' ( without quote ) $$$ n $$$ integers $$$ d_1 d_2 \ldots d_n $$$ separate space please note $$$ i $$$ use number satisfy inequality $$$ 0 \leq d_i < n $$$ , read a string $$$ s $$$ length $$$ n $$$ consist symbols ` ` 0 '' ` ` 1 '' ( without quote ) $$$ i $$$ symbol $$$ s_i $$$ equal ` ` 0 '' lamp device connect $$$ i $$$ -th vertex tree switch ` ` 1 '' otherwise several operations print guess tree print symbol ` ` ! '' ( without quote ) next $$$ n-1 $$$ line print $$$ 2 $$$ integers $$$ a_i $$$ $$$ b_i $$$ — index vertices connect $$$ i $$$ -th edge tree number satisfy condition $$$ 1 \leq a_i b_i \leq n $$$ $$$ a_i \neq b_i $$$ edge form a tree equal hide tree , program terminate guarantee test tree fix wo n't change depend program 's operations program make $$$ 0 $$$ $$$ 80 $$$ operations device guess tree equal hide program make $$$ 80 $$$ operations get verdict continue read close input program make operation print answer incorrect format get verdict careful n't forget flush output print question answer flush output use : hack : first line contain one integer $$$ n $$$ — number vertices tree ( $$$ 2 \leq n \leq 1000 $$$ ) next $$$ n-1 $$$ line contain $$$ 2 $$$ integers $$$ a_i $$$ $$$ b_i $$$ — index vertices connect $$$ i $$$ -th edge tree ( $$$ 1 \leq a_i b_i \leq n $$$ $$$ a_i \neq b_i $$$ ) edge form a tree careful extra space line break allow a picture tree encrypt device first test : a table pairwise distance vertices tree :","['binary search', 'math', 'trees']",3400.0
1158/F,"let $$$ c $$$ positive integer let 's call array $$$ a_1 a_2 \ldots a_n $$$ positive integers $$$ c $$$ -array $$$ i $$$ condition $$$ 1 \leq a_i \leq c $$$ satisfy let 's call $$$ c $$$ -array $$$ b_1 b_2 \ldots b_k $$$ a subarray $$$ c $$$ -array $$$ a_1 a_2 \ldots a_n $$$ exist set $$$ k $$$ indices $$$ 1 \leq i_1 < i_2 < \ldots < i_k \leq n $$$ $$$ b_j = a _ { i_j } $$$ $$$ 1 \leq j \leq k $$$ let 's define density $$$ c $$$ -array $$$ a_1 a_2 \ldots a_n $$$ maximal non - negative integer $$$ p $$$ $$$ c $$$ -array contain $$$ p $$$ number a subarray $$$ a_1 a_2 \ldots a_n $$$ give a number $$$ c $$$ $$$ c $$$ -array $$$ a_1 a_2 \ldots a_n $$$ $$$ 0 \leq p \leq n $$$ find number sequence indices $$$ 1 \leq i_1 < i_2 < \ldots < i_k \leq n $$$ $$$ 1 \leq k \leq n $$$ density array $$$ a _ { i_1 } a _ { i_2 } \ldots a _ { i_k } $$$ equal $$$ p $$$ find number modulo $$$ 998\,244\,353 $$$ large first line contain two integers $$$ n $$$ $$$ c $$$ separate space ( $$$ 1 \leq n c \leq 3\,000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ separate space ( $$$ 1 \leq a_i \leq c $$$ ) print $$$ n + 1 $$$ number $$$ s_0 s_1 \ldots s_n $$$ $$$ s_p $$$ equal number sequence indices $$$ 1 \leq i_1 < i_2 < \ldots < i_k \leq n $$$ $$$ 1 \leq k \leq n $$$ modulo $$$ 998\,244\,353 $$$ density array $$$ a _ { i_1 } a _ { i_2 } \ldots a _ { i_k } $$$ equal $$$ p $$$ first example 's easy see density array always equal length exist $$$ 4 $$$ sequence one index $$$ 6 $$$ two indices $$$ 4 $$$ three $$$ 1 $$$ four second example sequence indices array non - zero density indices case wo n't least one number $$$ 1 $$$ $$$ 3 $$$ array wo n't satisfy condition density $$$ p \geq 1 $$$","['dp', 'math']",3500.0
116/B,"upon a time several little pig several wolves a two - dimensional grid size n × m. cell grid either empty contain one little pig contain one wolf a little pig a wolf adjacent cells locate share a side little pig afraid wolves one wolf adjacent little pig wolf may adjacent number little pig live peacefully several years today wolves get hungry one one wolf choose one little pig adjacent ( ) eat poor little pig process repeat , wolf get eat one little pig a little pig get eat disappear eat wolf maximum number little pig may eat wolves ? first line contain integers n m ( 1 ≤ n m ≤ 10 ) denote number row columns two - dimensional grid respectively follow n line contain m character — grid description ` ` . '' mean cell empty ` ` p '' mean cell contain a little pig ` ` w '' mean cell contain a wolf guarantee one wolf adjacent little pig print a single number — maximal number little pig may eat wolves first example one possible scenario two little pig get eat wolves follow","['greedy', 'implementation']",1100.0
1165/B,"polycarp want train another program competition first day train solve exactly $$$ 1 $$$ problem second day — exactly $$$ 2 $$$ problems third day — exactly $$$ 3 $$$ problems , $$$ k $$$ -th day solve $$$ k $$$ problems polycarp a list $$$ n $$$ contest $$$ i $$$ -th contest consist $$$ a_i $$$ problems day polycarp choose exactly one contest n't solve yet solve solve exactly $$$ k $$$ problems contest problems discard contest consist least $$$ k $$$ problems polycarp n't solve yet $$$ k $$$ -th day polycarp stop train many days polycarp train choose contest optimally ? first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number contest second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 200000 $$$ ) — number problems $$$ i $$$ -th contest print one integer — maximum number days polycarp train choose contest optimally","['data structures', 'greedy', 'sortings']",1000.0
1165/E,give two array $$$ a $$$ $$$ b $$$ length $$$ n $$$ let 's define a function $$$ f ( l r ) = \sum\limits _ { l \le i \le r } a_i \cdot b_i $$$ task reorder elements ( choose arbitrary order elements ) array $$$ b $$$ minimize value $$$ \sum\limits _ { 1 \le l \le r \le n } f ( l r ) $$$ since answer large print modulo $$$ 998244353 $$$ note minimize answer remainder first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements $$$ a $$$ $$$ b $$$ second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ third line input contain $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ 1 \le b_j \le 1000000 $$$ ) $$$ b_j $$$ $$$ j $$$ -th element $$$ b $$$ print one integer — minimum possible value $$$ \sum\limits _ { 1 \le l \le r \le n } f ( l r ) $$$ rearrange elements $$$ b $$$ take modulo $$$ 998244353 $$$ note minimize answer remainder,"['greedy', 'math', 'sortings']",1600.0
1167/G,"get bore decide take guess would ` ` inception '' production go budget film terribly low first scene remember one feature whole city bend onto : feel like require high <unknown> expense n't ? luckily come a similar - looking scene a tiny bite cheaper make firstly forget 3d 's hard expensive ! city represent a number line ( infinite make easier course ) secondly city n't look natural $$$ n $$$ build line build a square $$$ 1 \times 1 $$$ build number $$$ 1 $$$ $$$ n $$$ ascend order position lower corner build $$$ i $$$ integer point $$$ a_i $$$ $$$ a_i + 1 $$$ number line also distance two neighbour build $$$ i $$$ $$$ i + 1 $$$ n't exceed $$$ d $$$ ( really condition make city look <unknown> ) distance neighbour build $$$ i $$$ $$$ i + 1 $$$ calculate lower right corner build $$$ i $$$ lower leave corner build $$$ i + 1 $$$ finally <unknown> bend also really hard simulate ! let bend integer coordinate $$$ x $$$ perform follow algorithm take ray $$$ x $$$ $$$ + \infty $$$ build ray start turn ray build counter - clockwise around point $$$ x $$$ angle build touch either another build a part line stop bend ( implement build crush also worth money ) let 's call angle two ray final state terminal angle $$$ \alpha_x $$$ thing leave decide integer point $$$ x $$$ best start bend around fortunately ' ve already choose $$$ m $$$ candidates perform bend , please help us calculate terminal angle $$$ \alpha_x $$$ bend $$$ x $$$ list candidates ? first line contain two integer number $$$ n $$$ $$$ d $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 0 \le d \le 7000 $$$ ) — number build maximum distance pair neighbour build respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ a_1 = 0 $$$ $$$ 0 < a _ { i + 1 } - a_i \le d + 1 $$$ ) — coordinate leave corner correspond build ascend order third line contain single integer $$$ m $$$ ( $$$ 1 \le m \le 200000 $$$ ) — number candidates fourth line contain $$$ m $$$ integers $$$ x_1 x_2 \dots x_m $$$ ( $$$ 0 \le x_i \le a_n + 1 $$$ $$$ x_i < x _ { i + 1 } $$$ ) — coordinate bend need calculate terminal angle ascend order print $$$ m $$$ number bend $$$ x_i $$$ print terminal angle $$$ \alpha _ { x_i } $$$ ( radians ) answer consider correct absolute error exceed $$$ 10^ { -9 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ |a - b| \le 10^ { -9 } $$$ see picture city first example bend position $$$ 2 $$$ angle need measure mark blue see 's equal $$$ \frac \pi 4 $$$ see pair neighbour build distance $$$ 4 $$$ $$$ d = 4 $$$ would also suffice test","['brute force', 'geometry']",3100.0
1172/E,"nauuo a girl love travel one day go a tree old driver tree literally a tree old driver tree a connect graph consist $$$ n $$$ nod $$$ n-1 $$$ edge node a color nauuo visit odt a simple path tree old driver 's car nauuo want visit see different color journey n't know simple path travel , want calculate sum number different color different paths help ? 's odt redecorate $$$ m $$$ modifications modification change a single node 's color nauuo want know answer modification note problem consider simple path $$$ u $$$ $$$ v $$$ simple path $$$ v $$$ $$$ u $$$ two different simple paths $$$ u\ne v $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2\le n\le 4\cdot 100000 $$$ $$$ 1\le m\le 4\cdot 100000 $$$ ) — number nod number modifications second line contain $$$ n $$$ integers $$$ c_1 c_2 \ldots c_n $$$ ( $$$ 1\le c_i\le n $$$ ) $$$ c_i $$$ initial color node $$$ i $$$ next $$$ n-1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1\le u v\le n $$$ ) denote edge $$$ u $$$ $$$ v $$$ guarantee give edge form a tree next $$$ m $$$ line contain two integers $$$ u $$$ $$$ x $$$ ( $$$ 1\le u x\le n $$$ ) mean a modification change color node $$$ u $$$ $$$ x $$$ output contain $$$ m+1 $$$ integers — first integer answer begin rest integers answer every modification give order example <unknown> number color simple path begin :",['data structures'],3300.0
1175/F,array $$$ a_1 a_2 \dots a_n $$$ let 's call subarray $$$ a_l a _ { l + 1 } \dots a_r $$$ array a <unknown> contain integers $$$ 1 $$$ $$$ r - l+1 $$$ exactly example array $$$ a = [ 2 2 1 3 2 3 1 ] $$$ contain $$$ 6 $$$ subarrays subpermutations : $$$ [ a_2 \dots a_3 ] $$$ $$$ [ a_2 \dots a_4 ] $$$ $$$ [ a_3 \dots a_3 ] $$$ $$$ [ a_3 \dots a_5 ] $$$ $$$ [ a_5 \dots a_7 ] $$$ $$$ [ a_7 \dots a_7 ] $$$ ask calculate number subpermutations first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) array contain integers print number subpermutations array $$$ a $$$ $$$ 7 $$$ subpermutations first test case segment indices $$$ [ 1 4 ] $$$ $$$ [ 3 3 ] $$$ $$$ [ 3 6 ] $$$ $$$ [ 4 7 ] $$$ $$$ [ 6 7 ] $$$ $$$ [ 7 7 ] $$$ $$$ [ 7 8 ] $$$ second test case $$$ 6 $$$ subpermutations exist : $$$ [ 1 1 ] $$$ $$$ [ 2 2 ] $$$ $$$ [ 2 3 ] $$$ $$$ [ 3 4 ] $$$ $$$ [ 4 4 ] $$$ $$$ [ 4 5 ] $$$,"['brute force', 'data structures', 'divide and conquer', 'math']",2500.0
1176/C,give array $$$ a $$$ consist $$$ n $$$ integers $$$ a_i $$$ one six follow number : $$$ 4 8 15 16 23 42 $$$ task remove minimum number elements make array good array length $$$ k $$$ call good $$$ k $$$ divisible $$$ 6 $$$ possible split $$$ \frac { k } { 6 } $$$ subsequences $$$ 4 8 15 16 23 42 $$$ examples good array : examples bad array : first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) — number elements $$$ a $$$ second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ a_i $$$ one follow number : $$$ 4 8 15 16 23 42 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ print one integer — minimum number elements remove obtain a good array,"['dp', 'greedy', 'implementation']",1300.0
1176/D,"author guess array $$$ a $$$ consist $$$ n $$$ integers ; integer less $$$ 2 $$$ greater $$$ 200000 $$$ n't know array $$$ a $$$ know array $$$ b $$$ form follow sequence operations : $$$ p _ { a_i } $$$ mean $$$ a_i $$$ -th prime number first prime $$$ p_1 = 2 $$$ second one $$$ p_2 = 3 $$$ , task recover suitable array $$$ a $$$ form give array $$$ b $$$ guarantee answer exist ( array $$$ b $$$ obtain suitable array $$$ a $$$ ) multiple answer print first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements $$$ a $$$ second line input contain $$$ 2n $$$ integers $$$ b_1 b_2 \dots b _ { 2n } $$$ ( $$$ 2 \le b_i \le 2750131 $$$ ) $$$ b_i $$$ $$$ i $$$ -th element $$$ b $$$ $$$ 2750131 $$$ $$$ <unknown> $$$ -th prime number line output print $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 2 \le a_i \le 200000 $$$ ) order — array $$$ a $$$ array $$$ b $$$ obtain use sequence move give problem statement multiple answer print","['dfs and similar', 'graphs', 'greedy', 'number theory', 'sortings']",1800.0
1178/G,give a root tree $$$ n $$$ vertices vertices number $$$ 1 $$$ $$$ n $$$ ; root vertex number $$$ 1 $$$ vertex two integers associate : $$$ a_i $$$ $$$ b_i $$$ denote set ancestors $$$ v $$$ ( include $$$ v $$$ ) $$$ r ( v ) $$$ awesomeness a vertex $$$ v $$$ define $$$ $$$ \left| \sum _ { w \in r ( v ) } <unknown> \cdot <unknown> _ { w \in r ( v ) } <unknown> $$$ $$$ $$$ |x| $$$ denote absolute value $$$ x $$$ process $$$ q $$$ query one follow form : first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \leq n \leq 2\cdot 100000 1 \leq q \leq 100000 $$$ ) — number vertices tree number query respectively second line contain $$$ n - 1 $$$ integers $$$ p_2 p_3 \dots p_n $$$ ( $$$ 1 \leq p_i < i $$$ ) $$$ p_i $$$ mean edge vertices $$$ i $$$ $$$ p_i $$$ third line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ -5000 \leq a_i \leq 5000 $$$ ) initial value $$$ a_i $$$ vertex fourth line contain $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ -5000 \leq b_i \leq 5000 $$$ ) value $$$ b_i $$$ vertex next $$$ q $$$ line describe a query one follow form : query second type print a single line maximum awesomeness respective subtree initial awesomeness vertices $$$ [ 100 91 57 64 57 ] $$$ awesome vertex subtree vertex $$$ 1 $$$ ( first query ) $$$ 1 $$$ awesome vertex subtree vertex $$$ 2 $$$ ( second query ) $$$ 2 $$$ first update ( third query ) awesomeness change $$$ [ 100 169 57 160 57 ] $$$ thus awesome vertex whole tree ( fourth query ) $$$ 2 $$$ second update ( fifth query ) awesomeness become $$$ [ 100 <unknown> 57 240 152 ] $$$ hence awesome vertex ( sixth query ) $$$ 4 $$$,"['data structures', 'dfs and similar']",3000.0
1178/H,warn : problem unusual memory limit ! bob decide waste prime years implement <unknown> form a large corporation instead earn supper stock exchange reykjavik stock exchange reykjavik actual stock exchange world type transaction take a single share stock $$$ x $$$ exchange a single share stock $$$ y $$$ provide current price share $$$ x $$$ least current price share $$$ y $$$ $$$ 2n $$$ stock list <unknown> interest bob number $$$ 1 $$$ $$$ 2n $$$ bob own a single share stock $$$ 1 $$$ $$$ n $$$ would like a single share $$$ n+1 $$$ $$$ 2n $$$ time future bob manage forecast price stock — time $$$ t \geq 0 $$$ stock $$$ i $$$ cost $$$ a_i \cdot \lfloor t \rfloor + b_i $$$ time currently $$$ t = 0 $$$ help bob find earliest moment time a single share $$$ n+1 $$$ $$$ 2n $$$ minimum number stock exchange perform order may assume stock exchange unlimited amount stock point time first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 2200 $$$ ) — number stock currently own bob next $$$ 2n $$$ line contain integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 0 \leq a_i b_i \leq 1000000000 $$$ ) represent stock price stock $$$ i $$$ impossible bob achieve goal output a single integer $$$ -1 $$$ otherwise output two integers $$$ t $$$ $$$ e $$$ $$$ t $$$ minimum time achieve goal $$$ e $$$ minimum number exchange achieve goal time $$$ t $$$ first example bob simply wait time $$$ t = 3 $$$ stock cost exactly amount second example optimum strategy exchange stock $$$ 2 $$$ stock $$$ 1 $$$ time $$$ t = 1 $$$ exchange one share stock $$$ 1 $$$ stock $$$ 3 $$$ time $$$ t = 5 $$$ ( cost $$$ 15 $$$ ) time $$$ t = 6 $$$ exchange second stock number $$$ 4 $$$ ( cost $$$ 18 $$$ $$$ 17 $$$ respectively ) note achieve goal also two exchange would take total time $$$ t = 9 $$$ would finally able exchange share number $$$ 2 $$$ share number $$$ 3 $$$ third example bob never achieve goal second stock always strictly expensive first one,"['binary search', 'graphs']",3500.0
1179/A,"recently course algorithms data structure valeriy learn use a deque build a deque fill $$$ n $$$ elements $$$ i $$$ -th element $$$ a_i $$$ ( $$$ i $$$ = $$$ 1 2 \ldots n $$$ ) gradually take first two leftmost elements deque ( let 's call $$$ a $$$ $$$ b $$$ respectively ) follow : $$$ a > b $$$ write $$$ a $$$ begin write $$$ b $$$ end deque otherwise write begin $$$ b $$$ $$$ a $$$ write end deque call sequence action operation example deque $$$ [ 2 3 4 5 1 ] $$$ operation write $$$ b=3 $$$ begin $$$ a=2 $$$ end get $$$ [ 3 4 5 1 2 ] $$$ teacher course see valeriy passionate work approach give $$$ q $$$ query query consist singular number $$$ m_j $$$ $$$ ( j = 1 2 \ldots q ) $$$ require query answer two elements pull $$$ m_j $$$ -th operation note query independent query number $$$ a $$$ $$$ b $$$ print order pull deque deque a data structure represent a list elements insertion new elements deletion exist elements make side first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \leq n \leq 100000 $$$ $$$ 0 \leq q \leq 300000 $$$ ) — number elements deque number query second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ $$$ a_i $$$ $$$ ( 0 \leq a_i \leq 1000000000 ) $$$ — deque element $$$ i $$$ -th position next $$$ q $$$ line contain one number mean $$$ m_j $$$ ( $$$ 1 \leq m_j \leq 10^ { 18 } $$$ ) teacher 's query output two number $$$ a $$$ $$$ b $$$ — number valeriy pull deque $$$ m_j $$$ -th operation , $$$ 2 $$$ write begin deque $$$ 1 $$$ — end get follow status deque : $$$ [ 2 3 4 5 1 ] $$$","['data structures', 'implementation']",1500.0
1179/C,serge come school din room discover a big queue $$$ m $$$ pupils queue 's sure want wait queue clear want know dish receive serge tire ask compute instead initially $$$ n $$$ dish cost $$$ a_1 a_2 \ldots a_n $$$ already know queue $$$ m $$$ pupils $$$ b_1 \ldots b_m $$$ togrogs respectively ( pupils enumerate queue order i.e first pupil queue $$$ b_1 $$$ togrogs last one $$$ b_m $$$ togrogs ) pupils think expensive dish delicious one every pupil buy expensive dish money ( every dish a single copy a pupil buy nobody buy later ) a pupil n't money dish leave queue ( <unknown> <unknown> ... ) money n't a problem serge serge buy expensive dish least one remain moreover serge 's school a unstable economic situation cost dish number togrogs pupils change formally must process $$$ q $$$ query : nobody leave queue query a <unknown> late every query must tell serge price dish buy wait queue clear $$$ -1 $$$ dish point accord rule describe first line contain integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 300\ 000 $$$ ) — number dish pupils respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 10^ { 6 } $$$ ) — elements array $$$ a $$$ third line contain $$$ m $$$ integers $$$ b_1 b_2 \ldots b _ { m } $$$ ( $$$ 1 \leq b_i \leq 10^ { 6 } $$$ ) — elements array $$$ b $$$ fourth line <unknown> integer $$$ q $$$ ( $$$ 1 \leq q \leq 300\ 000 $$$ ) — number query follow $$$ q $$$ line contain follow : $$$ q $$$ query print answer statement describe answer $$$ i $$$ -th query $$$ i $$$ -th line ( price dish serge buy $$$ -1 $$$ nothing remain ) first sample first query one dish price $$$ 100 $$$ togrogs one pupil one togrog serge buy dish price $$$ 100 $$$ togrogs second sample first query one dish price one togrog one pupil $$$ 100 $$$ togrogs serge get nothing third sample first query nobody buy dish price $$$ 8 $$$ serge take second query dish buy third one third fifth pupils first second dish respectively nobody fourth one,"['binary search', 'data structures', 'greedy', 'implementation', 'math', 'trees']",2200.0
118/E,bertown n junctions m bidirectional roads know one get junction one exist roads cars city traffic jam start pose real problems deal government decide make traffic one - directional roads thus ease traffic task determine whether a way make traffic one - directional still possibility get junction one answer positive also find one possible ways orient roads first line contain two space - separated integers n m ( 2 ≤ n ≤ 105 n - 1 ≤ m ≤ 3·105 ) represent number junctions roads town correspondingly follow m line contain two number describe roads city road determine two integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) — number junctions connect guarantee one get junction one along exist bidirectional roads road connect different junctions one road pair junctions 's solution print single number 0 . otherwise print m line contain two integers pi qi — road 's orientation traffic flow move along a one - directional road junction pi junction qi print roads order several solutions problem print,"['dfs and similar', 'graphs']",2000.0
1181/A,"soon <unknown> - <unknown> island discover start acquire form civilization even market economy a new currency arise <unknown> call ` ` chizhik '' one pay chizhiks buy a coconut sasha masha buy coconuts sell price $$$ z $$$ chizhiks per coconut sasha $$$ x $$$ chizhiks masha $$$ y $$$ chizhiks girl buy many coconuts use money way girl buy integer non - negative number coconuts girls discuss plan find total number coconuts buy increase ( decrease ) one give several chizhiks girl chizhiks ca n't split part girls exchange integer number chizhiks consider follow example suppose sasha $$$ 5 $$$ chizhiks masha $$$ 4 $$$ chizhiks price one coconut $$$ 3 $$$ chizhiks girls n't exchange chizhiks buy $$$ 1 + 1 = 2 $$$ coconuts however , example masha give sasha one chizhik sasha $$$ 6 $$$ chizhiks masha $$$ 3 $$$ chizhiks girls buy $$$ 2 + 1 = 3 $$$ coconuts easy live island sasha mash want exchange chizhiks a way buy maximum possible number coconuts nobody want a debt among possible ways buy maximum possible number coconuts find a way minimize number chizhiks one girl give ( important person give chizhiks ) first line contain three integers $$$ x $$$ $$$ y $$$ $$$ z $$$ ( $$$ 0 \le x y \le 10^ { 18 } $$$ $$$ 1 \le z \le 10^ { 18 } $$$ ) — number chizhics sasha number chizhics masha price a coconut print two integers : maximum possible number coconuts girls buy minimum number chizhiks one girl give first example describe statement second example optimal solution dot exchange chizhiks girls buy $$$ 3 + 4 = 7 $$$ coconuts","['greedy', 'math']",1000.0
1181/C,"innokenty work a flea market sell random stuff rare items recently find old rectangular blanket turn blanket split $$$ n \cdot m $$$ color piece form a rectangle $$$ n $$$ row $$$ m $$$ columns color piece attract innokenty 's attention immediately come follow business plan cut a subrectangle consist three color strip sell a flag country innokenty decide a subrectangle similar enough a flag country consist three strip equal heights place one another stripe consist cells equal color course color top stripe must different color middle stripe ; color middle stripe must different color bottom stripe innokenty yet decide part cut sure flag 's boundaries go along grid line also innokenty wo n't rotate blanket please help innokenty count number different subrectangles innokenty cut sell a flag two subrectangles locate different place form flag still consider different subrectangles flag subrectangles flag first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 1\,000 $$$ ) — number row number columns blanket next $$$ n $$$ line contain $$$ m $$$ lowercase english letter ' a ' ' z ' describe a row blanket equal letter correspond equal color different letter correspond different color line print number subrectangles form valid flag select subrectangles flag first example","['brute force', 'combinatorics', 'dp', 'implementation']",1900.0
1182/E,let $$$ f _ { x } = c^ { <unknown> } \cdot f _ { x-1 } \cdot f _ { x-2 } \cdot f _ { x-3 } $$$ $$$ x \ge 4 $$$ give integers $$$ n $$$ $$$ f _ { 1 } $$$ $$$ f _ { 2 } $$$ $$$ f _ { 3 } $$$ $$$ c $$$ find $$$ f _ { n } \bmod ( 10^ { 9 } +7 ) $$$ line contain five integers $$$ n $$$ $$$ f _ { 1 } $$$ $$$ f _ { 2 } $$$ $$$ f _ { 3 } $$$ $$$ c $$$ ( $$$ 4 \le n \le 10^ { 18 } $$$ $$$ 1 \le f _ { 1 } $$$ $$$ f _ { 2 } $$$ $$$ f _ { 3 } $$$ $$$ c \le 10^ { 9 } $$$ ) print $$$ f _ { n } \bmod ( 10^ { 9 } + 7 ) $$$ first example $$$ f _ { 4 } = 90 $$$ $$$ f _ { 5 } = <unknown> $$$ second example $$$ f _ { 17 } \approx <unknown> \times 10^ { <unknown> } $$$,"['dp', 'math', 'number theory']",2300.0
1183/B,$$$ n $$$ products shop price $$$ i $$$ -th product $$$ a_i $$$ owner shop want equalize price products however want change price smoothly fact owner shop change price product $$$ i $$$ a way difference old price product $$$ a_i $$$ new price $$$ b_i $$$ $$$ k $$$ word condition $$$ |a_i - b_i| \le k $$$ satisfy ( $$$ |x| $$$ absolute value $$$ x $$$ ) change price product note leave old price products new price $$$ b_i $$$ product $$$ i $$$ positive ( i.e $$$ b_i > 0 $$$ satisfy $$$ i $$$ $$$ 1 $$$ $$$ n $$$ ) task find maximum possible equal price $$$ b $$$ <unknown> restriction products <unknown> $$$ |a_i - b| \le k $$$ satisfy ( $$$ a_i $$$ old price product $$$ b $$$ new price products ) report impossible find price $$$ b $$$ note choose price $$$ b $$$ integer answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100 $$$ ) — number query query present two line first line query contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100 1 \le k \le 100000000 $$$ ) — number products value $$$ k $$$ second line query contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100000000 $$$ ) $$$ a_i $$$ price $$$ i $$$ -th product print $$$ q $$$ integers $$$ i $$$ -th integer answer $$$ b $$$ $$$ i $$$ -th query impossible equalize price give products restriction products condition $$$ |a_i - b| \le k $$$ satisfy ( $$$ a_i $$$ old price product $$$ b $$$ new equal price products ) print -1 . otherwise print maximum possible equal price products first example query choose price $$$ b=2 $$$ easy see difference old price new price $$$ b=2 $$$ $$$ 1 $$$ second example query choose price $$$ b=6 $$$ differences old new price $$$ b=6 $$$ $$$ 2 $$$ third example query choose suitable price $$$ b $$$ value $$$ b $$$ least one condition two violate : $$$ |1 - b| \le 2 $$$ $$$ |6 - b| \le 2 $$$ fourth example query value $$$ b $$$ $$$ 1 $$$ $$$ 7 $$$ valid maximum $$$ 7 $$$ 's answer,['math'],900.0
1186/A,vus cossack hold a program competition $$$ n $$$ people participate decide award pen notebooks know vus exactly $$$ m $$$ pen $$$ k $$$ notebooks determine whether cossack reward participants give least one pen least one notebook first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \leq n m k \leq 100 $$$ ) — number participants number pen number notebooks respectively print ` ` yes '' possible reward participants otherwise print ` ` '' print letter case ( upper lower ) first example $$$ 5 $$$ participants cossack $$$ 8 $$$ pen $$$ 6 $$$ notebooks therefore enough pen notebooks second example $$$ 3 $$$ participants cossack $$$ 9 $$$ pen $$$ 3 $$$ notebooks enough pen minimum need number notebooks third example $$$ 8 $$$ participants $$$ 5 $$$ pen since cossack enough pen answer ` ` '',['implementation'],800.0
1187/A,"favorite shop sell $$$ n $$$ kinder surprise chocolate egg know exactly $$$ s $$$ stickers exactly $$$ t $$$ toy place $$$ n $$$ egg total kinder surprise one three type : n't know type a particular kinder surprise egg look identical indistinguishable minimum number kinder surprise egg buy sure whichever type 'll obtain least one sticker least one toy ? note open egg purchase process , buy number egg 's guarantee answer always exist first line contain single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number query next $$$ t $$$ line contain three integers $$$ n $$$ $$$ s $$$ $$$ t $$$ ( $$$ 1 \le n \le 1000000000 $$$ $$$ 1 \le s t \le n $$$ $$$ s + t \ge n $$$ ) — number egg stickers toy query independent print $$$ t $$$ integers ( one number per query ) — minimum number kinder surprise egg buy sure whichever type 'll obtain least one sticker one <unknown> first query take least $$$ 6 $$$ egg $$$ 5 $$$ egg toy inside worst case 'll buy second query egg a sticker a toy inside 's 's enough buy one egg third query buy egg : one a sticker one a toy",['math'],900.0
1187/B,letter shop showcase a string $$$ s $$$ consist $$$ n $$$ lowercase latin letter name tell letter sell shop letter sell one one leftmost rightmost customer buy prefix letter string $$$ s $$$ $$$ m $$$ friends $$$ i $$$ -th name $$$ t_i $$$ plan estimate follow value : many letter ( length shortest prefix ) would s / he need buy s / he want construct her / his name buy letter name construct letter present equal greater amount guarantee every friend construct her / his name use letter string $$$ s $$$ note value friends independent friends estimate actually buy letter first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length showcase string $$$ s $$$ second line contain string $$$ s $$$ consist exactly $$$ n $$$ lowercase latin letter third line contain one integer $$$ m $$$ ( $$$ 1 \le m \le 50000 $$$ ) — number friends $$$ i $$$ -th next $$$ m $$$ line contain $$$ t_i $$$ ( $$$ 1 \le |t_i| \le 200000 $$$ ) — name $$$ i $$$ -th friend guarantee $$$ \sum \limits _ { i=1 } ^m |t_i| \le 200000 $$$ friend print length shortest prefix letter $$$ s $$$ s / he would need buy able construct her / his name name construct letter present equal greater amount guarantee every friend construct her / his name use letter string $$$ s $$$,"['binary search', 'implementation', 'strings']",1300.0
1187/C,vasya array $$$ a_1 a_2 \dots a_n $$$ n't know array tell $$$ m $$$ facts array $$$ i $$$ -th fact a triple number $$$ t_i $$$ $$$ l_i $$$ $$$ r_i $$$ ( $$$ 0 \le t_i \le 1 1 \le l_i < r_i \le n $$$ ) mean : example $$$ a = [ 2 1 1 3 2 ] $$$ could give three facts : $$$ t_1=1 l_1=2 <unknown> $$$ ( subarray $$$ [ a_2 a_3 a_4 ] = [ 1 1 3 ] $$$ sort ) $$$ <unknown> l_2=4 <unknown> $$$ ( subarray $$$ [ a_4 a_5 ] = [ 3 2 ] $$$ sort ) $$$ <unknown> <unknown> <unknown> $$$ ( subarray $$$ [ a_3 a_5 ] = [ 1 3 2 ] $$$ sort ) n't know array $$$ a $$$ find array satisfy give facts first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 1000 1 \le m \le 1000 $$$ ) next $$$ m $$$ line contain three integers $$$ t_i $$$ $$$ l_i $$$ $$$ r_i $$$ ( $$$ 0 \le t_i \le 1 1 \le l_i < r_i \le n $$$ ) $$$ t_i = 1 $$$ subbarray $$$ a _ { l_i } a _ { l_i + 1 } \dots a _ { r_i } $$$ sort otherwise ( $$$ t_i = 0 $$$ ) subbarray $$$ a _ { l_i } a _ { l_i + 1 } \dots a _ { r_i } $$$ sort array satisfy facts line print ( letter case ) a solution print yes ( letter case ) second line print $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — array $$$ a $$$ satisfy give facts multiple satisfy array print,"['greedy', 'implementation']",1800.0
1194/G,let 's call a fraction $$$ \frac { x } { y } $$$ good exist least one another fraction $$$ \frac { x ' } { y ' } $$$ $$$ \frac { x } { y } = \frac { x ' } { y ' } $$$ $$$ 1 \le x ' y ' \le 9 $$$ digit denote $$$ x ' $$$ contain decimal representation $$$ x $$$ digit denote $$$ y ' $$$ contain decimal representation $$$ y $$$ example $$$ \frac { 26 } { 13 } $$$ a good fraction $$$ \frac { 26 } { 13 } = \frac { 2 } { 1 } $$$ give integer number $$$ n $$$ please calculate number good fraction $$$ \frac { x } { y } $$$ $$$ 1 \le x \le n $$$ $$$ 1 \le y \le n $$$ answer may really large print modulo $$$ 998244353 $$$ line input contain one integer $$$ n $$$ ( $$$ 1 \le n < 10^ { 100 } $$$ ) print number good fraction $$$ \frac { x } { y } $$$ $$$ 1 \le x \le n $$$ $$$ 1 \le y \le n $$$ answer may really large print modulo $$$ 998244353 $$$,['dp'],2700.0
1195/B,"even dinner sis 's students gather together play game sport mafia tournament alya put candy box serve a prize a winner , perform $$$ n $$$ action first action perform put a single candy box remain move choose two options : thus box empty use second option example one possible sequence alya 's action look follow : way perform $$$ 9 $$$ action number candy end $$$ 11 $$$ alya eat $$$ 4 $$$ candy total know total number action $$$ n $$$ number candy end $$$ k $$$ need find total number sweets alya eat number move first option 's guarantee give $$$ n $$$ $$$ k $$$ answer always exist please note action first option alya take eat exactly one candy first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 1000000000 $$$ ; $$$ 0 \le k \le 1000000000 $$$ ) — total number move number candy box end 's guarantee give $$$ n $$$ $$$ k $$$ answer exist print a single integer — number candy alya eat please note problem n't multiple possible answer — answer unique input data first example alya make one move accord statement first move always put one candy box hence alya eat $$$ 0 $$$ candy second example possible sequence alya 's action look follow : way make exactly $$$ n=9 $$$ action end box contain $$$ 1 + 2 - 1 - 1 + 3 - 1 + 4 - 1 + 5=11 $$$ candy answer $$$ 4 $$$ since eat $$$ 4 $$$ candy total","['binary search', 'brute force', 'math']",1000.0
1196/D2,difference easy hard versions size input give a string $$$ s $$$ consist $$$ n $$$ character character ' r ' ' g ' ' b ' also give integer $$$ k $$$ task change minimum number character initial string $$$ s $$$ change a string length $$$ k $$$ a substring $$$ s $$$ also a substring infinite string ` ` rgbrgbrgb ... '' a string $$$ a $$$ a substring string $$$ b $$$ exist a positive integer $$$ i $$$ $$$ a_1 = b_i $$$ $$$ a_2 = b _ { i + 1 } $$$ $$$ a_3 = b _ { i + 2 } $$$ ... $$$ a _ { |a| } = b _ { i + |a| - 1 } $$$ example string ` ` gbrg '' ` ` b '' ` ` br '' substrings infinite string ` ` rgbrgbrgb ... '' ` ` gr '' ` ` rgr '' ` ` ggg '' answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query $$$ q $$$ query follow first line query contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 200000 $$$ ) — length string $$$ s $$$ length substring second line query contain a string $$$ s $$$ consist $$$ n $$$ character ' r ' ' g ' ' b ' guarantee sum $$$ n $$$ query exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) query print one integer — minimum number character need change initial string $$$ s $$$ change a substring length $$$ k $$$ $$$ s $$$ also a substring infinite string ` ` rgbrgbrgb ... '' first example change first character ' r ' obtain substring ` ` rg '' change second character ' r ' obtain ` ` br '' change third fourth fifth character ' b ' obtain ` ` gb '' second example substring ` ` brg '',"['data structures', 'dp', 'implementation', 'two pointers']",1600.0
1196/F,give a connect undirected weight graph consist $$$ n $$$ vertices $$$ m $$$ edge need print $$$ k $$$ -th smallest shortest path graph ( paths vertex count paths $$$ i $$$ $$$ j $$$ $$$ j $$$ $$$ i $$$ count one ) formally $$$ d $$$ matrix shortest paths $$$ d _ { i j } $$$ length shortest path vertices $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i < j \le n $$$ ) need print $$$ k $$$ -th element sort array consist $$$ d _ { i j } $$$ $$$ 1 \le i < j \le n $$$ first line input contain three integers $$$ n m $$$ $$$ k $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ n - 1 \le m \le \min\big ( \frac { n ( n-1 ) } { 2 } 2 \cdot <unknown> ) $$$ $$$ 1 \le k \le \min\big ( \frac { n ( n-1 ) } { 2 } <unknown> ) $$$ — number vertices graph number edge graph value $$$ k $$$ correspondingly $$$ m $$$ line follow contain three integers $$$ x $$$ $$$ y $$$ $$$ w $$$ ( $$$ 1 \le x y \le n $$$ $$$ 1 \le w \le 1000000000 $$$ $$$ x \ne y $$$ ) denote edge vertices $$$ x $$$ $$$ y $$$ weight $$$ w $$$ guarantee give graph connect ( a path pair vertices ) self - loops ( edge connect vertex ) multiple edge ( pair vertices $$$ x $$$ $$$ y $$$ one edge pair vertices graph ) print one integer — length $$$ k $$$ -th smallest shortest path give graph ( paths vertex count paths $$$ i $$$ $$$ j $$$ $$$ j $$$ $$$ i $$$ count one ),"['brute force', 'shortest paths', 'sortings']",2200.0
1198/B,a country $$$ n $$$ citizens $$$ i $$$ -th initially $$$ a _ { i } $$$ money government strictly control wealth citizens whenever a citizen make a purchase earn money must send a receipt social service mention amount money currently sometimes government make payouts poor : citizens strictly less money $$$ x $$$ pay accordingly <unknown> exactly $$$ x $$$ money case citizens n't send a receipt know initial wealth every citizen log events : receipt payouts restore amount money citizen events first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 2 \cdot 10^ { 5 } $$$ ) — numer citizens next line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 0 \le a _ { i } \le 10^ { 9 } $$$ ) — initial balance citizens next line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 2 \cdot 10^ { 5 } $$$ ) — number events next $$$ q $$$ line contain a single event events give chronological order event describe either 1 p x ( $$$ 1 \le p \le n $$$ $$$ 0 \le x \le 10^ { 9 } $$$ ) 2 x ( $$$ 0 \le x \le 10^ { 9 } $$$ ) first case a receipt balance $$$ p $$$ -th person become equal $$$ x $$$ second case a <unknown> parameter $$$ x $$$ print $$$ n $$$ integers — balance citizens events first example balance change follow : 1 2 3 4 $$$ \rightarrow $$$ 3 3 3 4 $$$ \rightarrow $$$ 3 2 3 4 $$$ \rightarrow $$$ 3 2 3 4 in second example balance change follow : 3 50 2 1 10 $$$ \rightarrow $$$ 3 0 2 1 10 $$$ \rightarrow $$$ 8 8 8 8 10 $$$ \rightarrow $$$ 8 8 20 8 10,"['binary search', 'brute force', 'data structures', 'sortings']",1600.0
1198/C,give a graph $$$ 3 \cdot n $$$ vertices $$$ m $$$ edge find a match $$$ n $$$ edge independent set $$$ n $$$ vertices a set edge call a match two edge share endpoint a set vertices call independent set two vertices connect edge first line contain a single integer $$$ t \ge 1 $$$ — number graph need process description $$$ t $$$ graph follow first line description a single graph contain two integers $$$ n $$$ $$$ m $$$ $$$ 3 \cdot n $$$ number vertices $$$ m $$$ number edge graph ( $$$ 1 \leq n \leq 10^ { 5 } $$$ $$$ 0 \leq m \leq 5 \cdot 10^ { 5 } $$$ ) next $$$ m $$$ line contain two integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \leq v_i u_i \leq 3 \cdot n $$$ ) mean edge vertices $$$ v_i $$$ $$$ u_i $$$ guarantee self - loops multiple edge graph guarantee sum $$$ n $$$ graph a single test exceed $$$ 10^ { 5 } $$$ sum $$$ m $$$ graph a single test exceed $$$ 5 \cdot 10^ { 5 } $$$ print answer $$$ t $$$ graph output answer a single graph follow format find a match size $$$ n $$$ first line print ` ` match '' ( without quote ) second line print $$$ n $$$ integers — indices edge match edge number $$$ 1 $$$ $$$ m $$$ input order find independent set size $$$ n $$$ first line print ` ` <unknown> '' ( without quote ) second line print $$$ n $$$ integers — indices vertices independent set match independent set specify size print ` ` impossible '' ( without quote ) print edge vertices order several solutions print particular a match size $$$ n $$$ independent set size $$$ n $$$ print exactly one match exactly one independent set first two graph a match size 1 independent set size 1 . match independent set a correct answer third graph a match size 2 however independent set size 2 . moreover independent set size 5 : 2 3 4 5 6 . however answer correct ask find independent set ( match ) size exactly $$$ n $$$ fourth graph independent set size 2 a match size 2,"['graphs', 'greedy', 'sortings']",2000.0
12/C,spring come mean a lot fruit appear counter one sunny day little boy valera decide go shop make a list m fruit want buy valera want buy one fruit kind include list several time come fruit stall ashot saw seller n't distribute price tag goods put price tag counter later ashot attach every price tag kind fruit valera able count total price fruit list valera want know smallest total price ( case « lucky » distribution price tag ) largest total price ( case « unlucky » distribution price tag ) first line input contain two integer number n m ( 1 ≤ n m ≤ 100 ) — number price tag ( equal number different kinds fruit ashot sell ) number items valera 's list second line contain n space - separated positive integer number n't exceed 100 stand price one fruit kind follow m line contain name fruit list name a non - empty string small latin letter length n't exceed 32 . guarantee number distinct fruit list less equal n. also know seller stock fruit valera want buy print two number a b ( a ≤ b ) — minimum maximum possible sum valera may need buy fruit list,"['greedy', 'implementation', 'sortings']",1100.0
12/D,n ladies attend ball king 's palace every lady describe three value : beauty intellect richness king 's master <unknown> know ladies special creatures lady understand lady ball beautiful smarter rich jump window know value ladies want find many probable self - murderers ball let denote beauty i - th lady bi intellect ii richness ri i - th lady a probable self - <unknown> j - th lady bi < bj ii < ij ri < rj find number probable self - murderers first line contain one integer n ( 1 ≤ n ≤ 500000 ) second line contain n integer number bi separate single space third fourth line contain sequence ii ri format guarantee 0 ≤ bi ii ri ≤ 109 . output answer problem,"['data structures', 'sortings']",2400.0
120/A,a sky <unknown> 1000 floor build city n. modern <unknown> elevators help travel one floor another elevator two doors front one back one one go front door go back one vice versa elevator two rail number number 1 2 . rail 1 locate leave entrance front door ( correspondingly right entrance back door ) rail 2 locate opposite right entrance front door leave entrance back door know person city n hold a rail strongest hand one day a vip person visit city course take a look skyscraper take a ride elevator know door enter rail hold need determine soon possible whether left - handed right - handed first line indicate door important person enter elevator contain ` ` front '' person enter elevator front door ` ` back '' enter elevator back door second line contain integer a ( 1 ≤ a ≤ 2 ) denote number rail person hold print character ` ` r '' vip right - handed ` ` l '' left - handed,"['brute force', 'implementation', 'math']",1000.0
120/B,a team quiz game call ` ` ? ? ? '' popular berland game center two team compete team six experts versus team audience a person audience ask a question experts allow a minute <unknown> find right answer question take answer a typical question general knowledge common logic question send audience envelop lie a circle a round table envelop mark name <unknown> 's town question position a separate sector centre table a spin arrow thus table rather resemble a roulette table ball a spin arrow instead host set spin arrow choose a question experts : arrow stop spin question point choose arrow point question already ask host choose next <unknown> question clockwise direction task determine number next ask question arrow point sector number k. first line contain two positive integers n k ( 1 ≤ n ≤ 1000 1 ≤ k ≤ n ) — number sectors table number sector arrow point second line contain n number : ai = 0 question sector i already ask ai = 1 question sector i n't ask yet ( 1 ≤ i ≤ n ) sectors give clockwise order first sector follow n - th one print single number — number sector contain question experts ask guarantee answer exist question already ask,['implementation'],1100.0
120/I,vasya collect transport ticket quite a collection contain several thousands tram trolleybus bus ticket vasya already feed traditional definition a lucky ticket thus 's look new perspectives besides vasya understand ticket divide lucky unlucky ones think ticket lucky different degrees give matter think vasya work definition a ticket 's degree luckiness let a ticket consist 2n digits let 's regard digit write show picture : see digits electronic clock : seven segment use show digits segment either color color segment form a digit vasya regard digits write way take right half ticket put one leave one first digit coincide n + 1 - th one second digit coincide n + 2 - th one ... n - th digit coincide 2n - th one pair digits put one another count number segment color digits summarize result number result value call degree luckiness a ticket example degree luckiness ticket 03 equal four degree luckiness ticket 2345 equal six give number a ticket contain 2n digits task find among ticket whose number exceed number ticket also consist 2n digits ticket whose degree luckiness exceed degrees luckiness give ticket moreover several ticket choose one smallest number first line contain number ticket consist k character ( k = 2n 1 ≤ n ≤ 105 ) print number seek ticket ` ` -1 '' ( without quote ) ticket exist,['greedy'],2200.0
1201/D,island represent a $$$ n \times m $$$ table row number $$$ 1 $$$ $$$ n $$$ columns number $$$ 1 $$$ $$$ m $$$ $$$ k $$$ treasure island $$$ i $$$ -th locate position $$$ ( r_i c_i ) $$$ initially stand lower leave corner island position $$$ ( 1 1 ) $$$ moment cell a treasure pick without extra time one move move ( $$$ ( r c ) $$$ $$$ ( r+1 c ) $$$ ) leave ( $$$ ( r c ) $$$ $$$ ( r c-1 ) $$$ ) right ( position $$$ ( r c ) $$$ $$$ ( r c+1 ) $$$ ) trap ca n't move however move also <unknown> move a safe column $$$ q $$$ safe columns : $$$ b_1 b_2 \ldots b_q $$$ want collect treasure fast possible count minimum number move require collect treasure first line contain integers $$$ n $$$ $$$ m $$$ $$$ k $$$ $$$ q $$$ ( $$$ 2 \le n \ m \ k \ q \le 200000 $$$ $$$ q \le m $$$ ) — number row number columns number treasure island number safe columns next $$$ k $$$ line contain two integers $$$ r_i c_i $$$ ( $$$ 1 \le r_i \le n $$$ $$$ 1 \le c_i \le m $$$ ) — coordinate cell a treasure treasure locate distinct cells last line contain $$$ q $$$ distinct integers $$$ b_1 b_2 \ldots b_q $$$ ( $$$ 1 \le b_i \le m $$$ ) — indices safe columns print minimum number move require collect treasure first example use second column go collect row treasure first column second example optimal use first column go third example optimal collect treasure cell $$$ ( 1 ; 6 ) $$$ go row $$$ 2 $$$ column $$$ 6 $$$ collect treasure cell $$$ ( 2 ; 2 ) $$$ go top row column $$$ 1 $$$ collect last treasure cell $$$ ( 3 ; 4 ) $$$ 's a total $$$ 15 $$$ move,"['binary search', 'dp', 'greedy', 'implementation']",2100.0
1202/F,give $$$ a $$$ uppercase latin letter ' a ' $$$ b $$$ letter ' b ' period string smallest positive integer $$$ k $$$ $$$ s_i = s _ { i ~ mod ~ k } $$$ ( $$$ 0 $$$ -indexed ) $$$ i $$$ note imply $$$ k $$$ wo n't always divide $$$ a+b = |s| $$$ example period string ` ` abaabaa '' $$$ 3 $$$ period ` ` aaaa '' $$$ 1 $$$ period ` ` aabbb '' $$$ 5 $$$ find number different periods possible string $$$ a $$$ letter ' a ' $$$ b $$$ letter ' b ' first line contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le 1000000000 $$$ ) — number letter ' a ' ' b ' respectively print number different periods possible string $$$ a $$$ letter ' a ' $$$ b $$$ letter ' b ' possible periods first example : possible periods second example : note possible string give periods,"['binary search', 'implementation', 'math']",2700.0
1203/D2,difference easy hard versions length string give a string $$$ s $$$ a string $$$ t $$$ consist lowercase latin letter guarantee $$$ t $$$ obtain $$$ s $$$ remove ( possibly zero ) number character ( necessary contiguous ) $$$ s $$$ without change order remain character ( word guarantee $$$ t $$$ a subsequence $$$ s $$$ ) example string ` ` test '' ` ` tst '' ` ` tt '' ` ` et '' ` ` '' subsequences string ` ` test '' string ` ` tset '' ` ` se '' ` ` contest '' subsequences string ` ` test '' want remove substring ( contiguous subsequence ) $$$ s $$$ maximum possible length remove substring $$$ t $$$ remain a subsequence $$$ s $$$ want remove substring $$$ s [ l ; r ] $$$ string $$$ s $$$ transform $$$ s_1 s_2 \dots s _ { l-1 } s _ { r+1 } s _ { r+2 } \dots s _ { |s|-1 } s _ { |s| } $$$ ( $$$ |s| $$$ length $$$ s $$$ ) task find maximum possible length substring remove $$$ t $$$ still a subsequence $$$ s $$$ first line input contain one string $$$ s $$$ consist least $$$ 1 $$$ $$$ 200000 $$$ lowercase latin letter second line input contain one string $$$ t $$$ consist least $$$ 1 $$$ $$$ 200000 $$$ lowercase latin letter guarantee $$$ t $$$ a subsequence $$$ s $$$ print one integer — maximum possible length substring remove $$$ t $$$ still a subsequence $$$ s $$$,"['binary search', 'greedy', 'implementation', 'two pointers']",1700.0
1203/E,"$$$ n $$$ boxers weight $$$ i $$$ -th boxer $$$ a_i $$$ change weight $$$ 1 $$$ competition ( weight become equal zero , must remain positive ) weight always integer number necessary choose largest box team term number people boxers ' weight team different ( i.e unique ) write a program give current value <unknown> $$$ a_i $$$ find maximum possible number boxers a team possible change weight boxer $$$ <unknown> $$$ ( ) first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 150000 $$$ ) — number boxers next line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ $$$ a_i $$$ ( $$$ 1 \le a_i \le 150000 $$$ ) weight $$$ i $$$ -th boxer print a single integer — maximum possible number people a team first example boxers change weight — make a team second example one boxer a weight $$$ 1 $$$ increase one ( get weight $$$ 2 $$$ ) one boxer a weight $$$ 4 $$$ reduce one increase one ( result boxers a weight $$$ 3 $$$ $$$ 5 $$$ respectively ) thus get a team consist boxers weight $$$ 5 4 3 2 1 $$$","['greedy', 'sortings']",1500.0
1204/A,city saint petersburg a day last $$$ 2^ { 100 } $$$ minutes main station saint petersburg a train depart $$$ 1 $$$ minute $$$ 4 $$$ minutes $$$ 16 $$$ minutes ; word train depart time $$$ 4^k $$$ integer $$$ k \geq 0 $$$ team <unknown> arrive station time $$$ s $$$ try count many train miss ; word number train depart strictly time $$$ s $$$ example $$$ s = 20 $$$ miss train depart $$$ 1 $$$ $$$ 4 $$$ $$$ 16 $$$ one know time help ! note number $$$ s $$$ give a binary representation without lead zero first line contain a single binary number $$$ s $$$ ( $$$ 0 \leq s < 2^ { 100 } $$$ ) without lead zero output a single number — number train depart strictly time $$$ s $$$ first example $$$ <unknown> = 256 _ { 10 } $$$ miss train depart $$$ 1 $$$ $$$ 4 $$$ $$$ 16 $$$ $$$ 64 $$$ second example $$$ 101_2 = 5 _ { 10 } $$$ train depart $$$ 1 $$$ $$$ 4 $$$ third example explain statements,['math'],1000.0
1204/B,"<unknown> array $$$ a_1 $$$ $$$ a_2 $$$ $$$ \cdots $$$ $$$ a_n $$$ $$$ n $$$ positive integers lose remember follow facts : example $$$ n=5 $$$ $$$ l=2 $$$ $$$ r=3 $$$ array could $$$ [ <unknown> ] $$$ $$$ [ <unknown> ] $$$ ; could n't $$$ [ <unknown> ] $$$ array contain $$$ 4 $$$ different number ; could n't $$$ [ <unknown> ] $$$ $$$ 3 $$$ odd n't equal $$$ 1 $$$ ; could n't $$$ [ <unknown> ] $$$ a number $$$ 16 $$$ array n't a number $$$ \frac { 16 } { 2 } = 8 $$$ accord facts ask count minimal maximal possible sum elements array input line contain three integers $$$ n $$$ $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq n \leq 1\,000 $$$ $$$ 1 \leq l \leq r \leq \min ( n 20 ) $$$ ) — array 's size minimal number maximal number distinct elements array output two number — minimal maximal possible sum elements array first example array could one follow : $$$ [ 1,1,1,2 ] $$$ $$$ [ 1,1,2,2 ] $$$ $$$ [ 1,2,2,2 ] $$$ first case minimal sum reach last case maximal sum reach second example minimal sum reach array $$$ [ 1,1,1,1,1 ] $$$ maximal one reach array $$$ [ <unknown> ] $$$","['greedy', 'math']",900.0
1207/E,"interactive problem remember flush output communicate test program may use fflush ( stdout ) c++ system.out.flush ( ) java stdout.flush ( ) python flush ( output ) pascal flush output use program language consult documentation may also refer guide interactive problems : https : //codeforces.com / blog / entry/45307 jury pick integer $$$ x $$$ less $$$ 0 $$$ greater $$$ 2^ { 14 } - 1 $$$ guess integer , may ask $$$ 2 $$$ query query consist $$$ 100 $$$ integer number $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a _ { 100 } $$$ ( integer less $$$ 0 $$$ greater $$$ 2^ { 14 } - 1 $$$ ) response query jury pick one integer $$$ i $$$ ( $$$ 1 \le i \le 100 $$$ ) tell value $$$ a_i \oplus x $$$ ( bitwise xor $$$ a_i $$$ $$$ x $$$ ) additional constraint query : $$$ 200 $$$ integers use query distinct guarantee value $$$ x $$$ fix beforehand test choice $$$ i $$$ every query may depend integers send give answer program print one line $$$ ! $$$ $$$ x $$$ a line break end , flush output terminate gracefully give answer may submit $$$ 2 $$$ query ask a query print one line follow format : $$$ ? $$$ $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a _ { 100 } $$$ every $$$ a_j $$$ integer range $$$ [ 0 2^ { 14 } - 1 ] $$$ line end a line break character submit a query flush output read answer query — value $$$ a_i \oplus x $$$ $$$ i \in [ 1 100 ] $$$ integer use query submit incorrect query ( ask $$$ 2 $$$ query ) answer one integer $$$ -1 $$$ receive answer program terminate immediately — otherwise may receive verdict ` ` runtime error '' ` ` time limit exceed '' verdict instead ` ` wrong answer '' example interaction correct — <unknown> exactly $$$ 100 $$$ integers query everything else correct hack forbid problem","['bitmasks', 'math']",1900.0
1209/A,give a sequence integers $$$ a_1 a_2 \dots a_n $$$ need paint elements color : example 's fine paint elements $$$ [ 40 10 60 ] $$$ a single color divisible $$$ 10 $$$ use color arbitrary amount time ( particular allow use a color ) elements paint one color need consecutive example $$$ a= [ 6 2 3 4 12 ] $$$ two color require : let 's paint $$$ 6 $$$ $$$ 3 $$$ $$$ 12 $$$ first color ( $$$ 6 $$$ $$$ 3 $$$ $$$ 12 $$$ divisible $$$ 3 $$$ ) paint $$$ 2 $$$ $$$ 4 $$$ second color ( $$$ 2 $$$ $$$ 4 $$$ divisible $$$ 2 $$$ ) example $$$ a= [ 10 7 15 ] $$$ $$$ 3 $$$ color require ( simply paint element unique color ) first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) $$$ n $$$ length give sequence second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100 $$$ ) number contain duplicate print minimal number color paint give number a valid way first example one possible way paint elements $$$ 3 $$$ color : second example use one color paint elements third example one possible way paint elements $$$ 4 $$$ color :,"['greedy', 'implementation', 'math']",800.0
1209/C,give a sequence $$$ n $$$ digits $$$ d_1d_2 \dots d _ { n } $$$ need paint digits two color : example sequence $$$ <unknown> $$$ valid color $$$ 211 $$$ ( paint color $$$ 1 $$$ two last digits paint color $$$ 2 $$$ first digit ) $$$ 122 $$$ a valid color ( $$$ 9 $$$ concatenate $$$ 14 $$$ a non - decreasing sequence ) allow either two color use digits paint color require consecutive position find valid ways paint give sequence digits determine impossible first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case input first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 2\cdot100000 $$$ ) — length a give sequence digits next line contain a sequence $$$ n $$$ digits $$$ d_1d_2 \dots d _ { n } $$$ ( $$$ 0 \le d_i \le 9 $$$ ) digits write a row without space separators sequence start 0 . guarantee sum value ​​of $$$ n $$$ test case input exceed $$$ 2\cdot100000 $$$ print $$$ t $$$ line — answer test case input a solution a test case correspond output line contain valid color write a string $$$ n $$$ digits $$$ t_1t_2 \dots t_n $$$ ( $$$ 1 \le t_i \le 2 $$$ ) $$$ t_i $$$ color $$$ i $$$ -th digit paint several feasible solutions print solution correspond output line contain a single character ' - ' ( minus sign ) first test case $$$ <unknown> $$$ output $$$ <unknown> $$$ correct $$$ <unknown> $$$ ( paint $$$ 1 $$$ ) concatenate $$$ <unknown> $$$ ( paint $$$ 2 $$$ ) $$$ <unknown> $$$ a sort sequence $$$ n $$$ give digits,"['greedy', 'implementation']",1500.0
1209/G1,"easier version next problem version $$$ q = 0 $$$ a sequence integers call nice elements arrange block like $$$ [ 3 3 3 4 1 1 ] $$$ formally two elements equal everything must also equal let 's define difficulty a sequence a minimum possible number elements change get a nice sequence however change least one element value $$$ x $$$ value $$$ y $$$ must also change elements value $$$ x $$$ $$$ y $$$ well example $$$ [ 3 3 1 3 2 1 2 ] $$$ n't allow change first $$$ 1 $$$ $$$ 3 $$$ second $$$ 1 $$$ $$$ 2 $$$ need leave $$$ 1 $$$ 's untouched change value give a sequence integers $$$ a_1 a_2 \ldots a_n $$$ $$$ q $$$ update update form ` ` $$$ i $$$ $$$ x $$$ ` ` — change $$$ a_i $$$ $$$ x $$$ update independent ( change stay future ) print difficulty initial sequence sequence every update first line contain integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n \le 200\,000 $$$ $$$ q = 0 $$$ ) length sequence number update second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 200\,000 $$$ ) initial sequence follow $$$ q $$$ line contain integers $$$ i_t $$$ $$$ x_t $$$ ( $$$ 1 \le i_t \le n $$$ $$$ 1 \le x_t \le 200\,000 $$$ ) position new value position print $$$ q+1 $$$ integers answer initial sequence answer every update","['data structures', 'dsu', 'greedy', 'implementation', 'two pointers']",2000.0
1210/A,anadi a set dominoes every domino two part part contain dot every $$$ a $$$ $$$ b $$$ $$$ 1 \leq a \leq b \leq 6 $$$ exactly one domino $$$ a $$$ dot one half $$$ b $$$ dot half set contain exactly $$$ 21 $$$ dominoes exact illustration set : also anadi undirected graph without self - loops multiple edge want choose dominoes place edge graph use one domino type edge fit one domino 's necessary place a domino edge graph place a domino edge also choose direction word one half place domino must direct toward one endpoints edge half must direct toward endpoint 's a catch : multiple halve dominoes direct toward vertex halve must contain number dot many dominoes anadi place edge graph ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 7 $$$ $$$ 0 \leq m \leq \frac { n\cdot ( n-1 ) } { 2 } $$$ ) — number vertices number edge graph next $$$ m $$$ line contain two integers integers $$$ i $$$ -th line $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a b \leq n $$$ $$$ a \neq b $$$ ) denote edge connect vertices $$$ a_i $$$ $$$ b_i $$$ graph might disconnect 's however guarantee graph n't contain self - loops one edge pair vertices output one integer denote maximum number dominoes anadi place edge graph illustration anadi 's graph first sample test : one ways place a domino edge : note vertex face halve dominoes number dot instance halve direct toward vertex $$$ 1 $$$ three dot,"['brute force', 'graphs']",1700.0
1210/C,"<unknown> like stream competitive program videos <unknown> channel recently reach $$$ 100 $$$ million subscribers order celebrate post a video interest problem could n't solve yet help ? 're give a tree — a connect undirected graph consist $$$ n $$$ vertices connect $$$ n - 1 $$$ edge tree root vertex $$$ 1 $$$ a vertex $$$ u $$$ call ancestor $$$ v $$$ lie shortest path root $$$ v $$$ particular a vertex ancestor vertex $$$ v $$$ assign beauty $$$ x_v $$$ — a non - negative integer larger $$$ 10^ { 12 } $$$ allow us define beauty a path let $$$ u $$$ ancestor $$$ v $$$ define beauty $$$ f ( u v ) $$$ greatest common divisor beauties vertices shortest path $$$ u $$$ $$$ v $$$ formally $$$ u = t_1 t_2 t_3 \dots t_k = v $$$ vertices shortest path $$$ u $$$ $$$ v $$$ $$$ f ( u v ) = \gcd ( x _ { t_1 } x _ { t_2 } \dots x _ { t_k } ) $$$ , $$$ \gcd $$$ denote greatest common divisor a set number particular $$$ f ( u u ) = \gcd ( x_u ) = x_u $$$ task find sum $$$ $$$ \sum _ { <unknown> { ancestor } v } f ( u v ) $$$ $$$ result might large please output modulo $$$ 1000000000 + 7 $$$ note $$$ y $$$ $$$ \gcd ( 0 y ) = \gcd ( y 0 ) = y $$$ particular $$$ \gcd ( 0 0 ) = 0 $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100\,000 $$$ ) — number vertices tree follow line contain $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ 0 \le x_i \le 10^ { 12 } $$$ ) value $$$ x_v $$$ denote beauty vertex $$$ v $$$ follow $$$ n - 1 $$$ line describe edge tree contain two integers $$$ a b $$$ ( $$$ 1 \le a b \le n $$$ $$$ a \neq b $$$ ) — vertices connect a single edge output sum beauties paths $$$ ( u v ) $$$ $$$ u $$$ ancestor $$$ v $$$ sum print modulo $$$ 1000000000 + 7 $$$ follow figure show $$$ 10 $$$ possible paths one endpoint ancestor another endpoint sum beauties paths equal $$$ 42 $$$ :","['math', 'number theory', 'trees']",2000.0
1210/G,"mateusz like travel ! however $$$ 42 $$$ nd visit saint <unknown> much leave sightsee 's decide go escape room friends ! team solve riddle flawlessly one riddle remain — a huge circular table ! $$$ n $$$ weigh scale lie top table distribute along circle scale adjacent exactly two scale : $$$ i \in \ { 1 2 \dots <unknown> } $$$ $$$ i $$$ -th $$$ ( i+1 ) $$$ -th scale adjacent well first $$$ n $$$ -th scale $$$ i $$$ -th scale initially contain $$$ a_i $$$ heavy coin mateusz perform move — move consist <unknown> a single coin one scale put adjacent scale turn riddle solve a specific amount coin scale specifically scale parameters $$$ l_i $$$ $$$ r_i $$$ coin lie a single scale $$$ i $$$ $$$ i $$$ -th scale contain least $$$ l_i $$$ $$$ r_i $$$ coin riddle solve mateusz 's team win ! mateusz aim best possible time therefore want solve riddle quickly possible minimum possible number move require fulfill condition ? first line contain integer $$$ n $$$ ( $$$ 3 \le n \le 35\,000 $$$ ) — number weigh scale circle follow $$$ n $$$ line describe scale $$$ i $$$ -th line describe $$$ i $$$ -th scale consist three integers $$$ a_i l_i r_i $$$ ( $$$ 0 \le a_i \le 35\,000 $$$ $$$ 0 \le l_i \le r_i \le 35\,000 $$$ ) 's guarantee riddle solvable , $$$ \sum _ { i=1 } ^n l_i \le \sum _ { i=1 } ^n a_i \le \sum _ { i=1 } ^n r_i $$$ output one integer — minimum number operations require solve riddle",['dp'],3500.0
1211/G,"$$$ n $$$ cities $$$ n-1 $$$ two - way roads treeland road connect a pair different cities city drive move along roads cities number $$$ 1 $$$ $$$ n $$$ yes course recognize undirected tree description exactly one flag city $$$ i $$$ -th city flag color $$$ c_i $$$ color flag different cities may king travel along route $$$ [ u_1 u_2 u_3 \dots u_k ] $$$ mean start city $$$ u_1 $$$ move city $$$ u_2 $$$ ( $$$ u_2 $$$ connect road $$$ u_1 $$$ ) $$$ u_2 $$$ $$$ u_3 $$$ ( $$$ u_3 $$$ connect road $$$ u_2 $$$ ) arrive city $$$ u_k $$$ possible route king visit city word route $$$ [ u_1 u_2 u_3 \dots u_k ] $$$ necessarily consist different cities term graph theory — king move $$$ u_1 $$$ $$$ u_k $$$ along path $$$ [ u_1 u_2 u_3 \dots u_k ] $$$ necessarily simple ( $$$ j $$$ $$$ 1 $$$ $$$ k-1 $$$ city $$$ u_j $$$ $$$ u _ { j+1 } $$$ connect road ) king move one city another city head exchange flag a sign friendship aesthetic reason king want flag color city $$$ i $$$ equal $$$ d_i $$$ $$$ i $$$ $$$ 1 $$$ $$$ n $$$ determine whether king choose route drive along city flag color turn equal desire color $$$ d_i $$$ note king choose ( drive ) exactly one route yes find shortest possible route king initial color flag already match king 's requirements ( i.e $$$ c_i = d_i $$$ $$$ i $$$ ) consider king make a route length $$$ k=0 $$$ first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case solve follow case case begin a line contain integer $$$ n $$$ ( $$$ 2 \le n \le 2\cdot100000 $$$ ) — number cities treeland follow a line $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \le c_i \le 1000000 $$$ ) $$$ c_i $$$ denote color flag $$$ i $$$ -th vertex king 's journey follow a line $$$ n $$$ integers $$$ d_1 d_2 \dots d_n $$$ ( $$$ 1 \le d_i \le 1000000 $$$ ) $$$ d_i $$$ denote require flag color $$$ i $$$ -th vertex completion king 's journey , $$$ n-1 $$$ line treeland 's roads list road give a line contain two integers $$$ x_j y_j $$$ ( $$$ 1 \le x_j y_j \le n $$$ ) — number cities connect $$$ j $$$ th road guarantee every city get road ( word system cities roads form undirected tree ) sum $$$ n $$$ value ​​for case one test exceed $$$ 2\cdot100000 $$$ print answer case order appearance input data answer must begin a line contain ` ` yes '' ( case a positive answer ) ` ` '' ( case require route exist ) case a positive answer follow line must contain integer $$$ k $$$ — number cities shortest possible route king next line contain require route $$$ u_1 u_2 \dots u_k $$$ ( $$$ 1 \le u_i \le n $$$ ) skip line $$$ k=0 $$$","['math', 'trees']",2500.0
1213/F,author come string $$$ s $$$ consist $$$ n $$$ lowercase latin letter give two permutations indices ( necessary equal ) $$$ p $$$ $$$ q $$$ ( length $$$ n $$$ ) recall permutation array length $$$ n $$$ contain integer $$$ 1 $$$ $$$ n $$$ exactly $$$ i $$$ $$$ 1 $$$ $$$ n-1 $$$ follow properties hold : $$$ s [ p_i ] \le s [ p _ { i + 1 } ] $$$ $$$ s [ q_i ] \le s [ q _ { i + 1 } ] $$$ mean write character $$$ s $$$ order permutation indices result string sort non - decreasing order task restore string $$$ s $$$ length $$$ n $$$ consist least $$$ k $$$ distinct lowercase latin letter suit give permutations multiple answer print first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 2 \cdot 100000 1 \le k \le 26 $$$ ) — length string number distinct character require second line input contain $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i $$$ distinct integers $$$ 1 $$$ $$$ n $$$ ) — permutation $$$ p $$$ third line input contain $$$ n $$$ integers $$$ q_1 q_2 \dots q_n $$$ ( $$$ 1 \le q_i \le n $$$ $$$ q_i $$$ distinct integers $$$ 1 $$$ $$$ n $$$ ) — permutation $$$ q $$$ impossible find suitable string print ` ` '' first line otherwise print ` ` yes '' first line string $$$ s $$$ second line consist $$$ n $$$ lowercase latin letter contain least $$$ k $$$ distinct character suit give permutations multiple answer print,"['data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'implementation', 'strings']",2100.0
1214/A,andrew excite participate olympiad metropolises days fly quickly andrew already airport ready go home $$$ n $$$ rubles leave would like exchange euro dollar bill andrew mix dollar bill euro bill whatever way want price one dollar $$$ d $$$ rubles one euro cost $$$ e $$$ rubles recall exist follow dollar bill : $$$ 1 $$$ $$$ 2 $$$ $$$ 5 $$$ $$$ 10 $$$ $$$ 20 $$$ $$$ 50 $$$ $$$ 100 $$$ follow euro bill — $$$ 5 $$$ $$$ 10 $$$ $$$ 20 $$$ $$$ 50 $$$ $$$ 100 $$$ $$$ 200 $$$ ( note problem consider $$$ 500 $$$ euro bill hard find bill currency exchange point ) andrew buy combination bill goal minimize total number rubles exchange help — write a program give integers $$$ n $$$ $$$ e $$$ $$$ d $$$ find minimum number rubles andrew get buy dollar euro bill first line input contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000000 $$$ ) — initial sum rubles andrew second line input contain one integer $$$ d $$$ ( $$$ 30 \leq d \leq 100 $$$ ) — price one dollar rubles third line input contain integer $$$ e $$$ ( $$$ 30 \leq e \leq 100 $$$ ) — price one euro rubles output one integer — minimum number rubles andrew buy dollar euro bill optimally first example buy $$$ 1 $$$ dollar $$$ 1 $$$ euro bill second example optimal exchange buy $$$ 5 $$$ euro $$$ 1 $$$ dollar third example optimal exchange buy $$$ 10 $$$ dollars one bill,"['brute force', 'math']",1400.0
1214/B,$$$ b $$$ boys $$$ g $$$ girls participate olympiad metropolises a board game tournament even $$$ n $$$ participants accept invitation organizers know many boys girls among organizers prepare red badge girls blue ones boys vasya prepare $$$ n+1 $$$ deck badge $$$ i $$$ -th ( $$$ i $$$ $$$ 0 $$$ $$$ n $$$ inclusive ) deck contain $$$ i $$$ blue badge $$$ n - i $$$ red ones total number badge deck exactly $$$ n $$$ determine minimum number deck among $$$ n+1 $$$ vasya take a suitable deck matter many girls boys among participants tournament first line contain integer $$$ b $$$ ( $$$ 1 \le b \le 300 $$$ ) number boys second line contain integer $$$ g $$$ ( $$$ 1 \le g \le 300 $$$ ) number girls third line contain integer $$$ n $$$ ( $$$ 1 \le n \le b + g $$$ ) number board game tournament participants output integer minimum number badge deck vasya could take first example 4 deck take : ( 0 blue 3 red ) ( 1 blue 2 red ) ( 2 blue 1 red ) ( 3 blue 0 red ) second example 4 deck take : ( 2 blue 3 red ) ( 3 blue 2 red ) ( 4 blue 1 red ) ( 5 blue 0 red ) pile ( 0 blue 5 red ) ( 1 blue 4 red ) use,"['brute force', 'math']",1100.0
1215/B,give a sequence $$$ a_1 a_2 \dots a_n $$$ consist $$$ n $$$ non - zero integers ( i.e $$$ a_i \ne 0 $$$ ) calculate two follow value : first line contain one integer $$$ n $$$ $$$ ( 1 \le n \le 2 \cdot 10^ { 5 } ) $$$ — number elements sequence second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ $$$ ( -10^ { 9 } \le a_i \le 10^ { 9 } ; a_i \neq 0 ) $$$ — elements sequence print two integers — number subsegments negative product number subsegments positive product respectively,"['combinatorics', 'dp', 'implementation']",1400.0
1215/C,monocarp get two string $$$ s $$$ $$$ t $$$ equal length string consist lowercase latin letter ` ` a '' ` ` b '' monocarp want make two string $$$ s $$$ $$$ t $$$ equal follow operation number time : choose index $$$ pos_1 $$$ string $$$ s $$$ choose index $$$ pos_2 $$$ string $$$ t $$$ swap $$$ s _ { pos_1 } $$$ $$$ t _ { pos_2 } $$$ determine minimum number operations monocarp perform make $$$ s $$$ $$$ t $$$ equal print optimal sequence operations — say impossible make string equal first line contain one integer $$$ n $$$ $$$ ( 1 \le n \le 2 \cdot 10^ { 5 } ) $$$ — length $$$ s $$$ $$$ t $$$ second line contain one string $$$ s $$$ consist $$$ n $$$ character ` ` a '' ` ` b '' third line contain one string $$$ t $$$ consist $$$ n $$$ character ` ` a '' ` ` b '' impossible make string equal print $$$ -1 $$$ otherwise first line print $$$ k $$$ — minimum number operations require make string equal next $$$ k $$$ line print two integers — index string $$$ s $$$ index string $$$ t $$$ use correspond swap operation first example two operations enough example swap third letter $$$ s $$$ third letter $$$ t $$$ $$$ s = $$$ ` ` abbb '' $$$ t = $$$ ` ` aaab '' swap third letter $$$ s $$$ second letter $$$ t $$$ $$$ s $$$ $$$ t $$$ equal ` ` abab '' second example 's impossible make two string equal,['greedy'],1500.0
1216/E1,difference easy hard versions maximum value $$$ k $$$ give infinite sequence form ` ` 112123123412345 $$$ \dots $$$ ` ` consist block consecutive positive integers write one another first block consist number $$$ 1 $$$ $$$ 1 $$$ second one — $$$ 1 $$$ $$$ 2 $$$ third one — $$$ 1 $$$ $$$ 3 $$$ $$$ \dots $$$ $$$ i $$$ -th block consist number $$$ 1 $$$ $$$ i $$$ first $$$ 56 $$$ elements sequence ` ` 11212312341234512345612345671234567812345678912345678910 '' elements sequence number one example $$$ 1 $$$ -st element sequence $$$ 1 $$$ $$$ 3 $$$ -rd element sequence $$$ 2 $$$ $$$ 20 $$$ -th element sequence $$$ 5 $$$ $$$ 38 $$$ -th element $$$ 2 $$$ $$$ 56 $$$ -th element sequence $$$ 0 $$$ task answer $$$ q $$$ independent query $$$ i $$$ -th query give one integer $$$ k_i $$$ calculate digit position $$$ k_i $$$ sequence first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 500 $$$ ) — number query $$$ i $$$ -th follow $$$ q $$$ line contain one integer $$$ k_i $$$ $$$ ( 1 \le k_i \le 1000000000 ) $$$ — description correspond query print $$$ q $$$ line $$$ i $$$ -th line print one digit $$$ x_i $$$ $$$ ( 0 \le x_i \le 9 ) $$$ — answer query $$$ i $$$ i.e $$$ x_i $$$ equal element position $$$ k_i $$$ sequence answer query first example describe problem statement,"['binary search', 'brute force', 'math']",1900.0
1218/B,"bob <unknown> get a new job security guard bob responsible safety a collection warehouse contain valuable bubble cup <unknown> - high - quality bubble task detect thieve inside warehouse call police look sky warehouse a shape a convex polygon wall two warehouse intersect course none warehouse build inside another warehouse little bubble cup boss know lazy bob enjoy watch soap <unknown> ( hear full bubble ) coziness office instead go one warehouse another check warehouse secure plan bob monitor warehouse comfort office use special x - ray goggle goggle infinite range a thief warehouse could easily spot however goggle <unknown> break x - ray strong enough let bob see a single wall , bob would really appreciate could help find total area inside warehouse monitor break goggle could know much area warehouse need monitor person first line contain one integer $$$ n $$$ ( $$$ 1 $$$ $$$ \leq $$$ $$$ n $$$ $$$ \leq $$$ $$$ 10000 $$$ ) – number warehouse next $$$ n $$$ line describe warehouse first number line integer $$$ c_i $$$ ( $$$ 3 $$$ $$$ \leq $$$ $$$ c_i $$$ $$$ \leq $$$ $$$ 10000 $$$ ) – number corner $$$ i^ { th } $$$ warehouse follow $$$ c_i $$$ pair integers $$$ j^ { th } $$$ pair $$$ ( x_j y_j ) $$$ – coordinate $$$ j^ { th } $$$ corner ( $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ \leq $$$ $$$ 3 * 10000 $$$ ) corner list clockwise order total number corner warehouse $$$ 5 * 10000 $$$ bob 's office position point coordinate $$$ ( 0 0 ) $$$ office contain within warehouse print a single line contain a single decimal number accurate least four decimal place – total area warehouse bob monitor use break x - ray goggle areas monitor x - ray goggle color green areas monitor goggle color red warehouse $$$ abcd $$$ $$$ ijk $$$ $$$ lmnopq $$$ completely monitor use google warehouse $$$ <unknown> $$$ partially monitor use goggle : part $$$ <unknown> $$$ monitor monitor point inside x - ray must go two wall warehouse $$$ abcd $$$ warehouse $$$ rut $$$ monitor bob 's office two wall warehouse $$$ ijk $$$ bob 's office point $$$ rut $$$ total area monitor goggle $$$ p $$$ = $$$ p _ { abcd } $$$ + $$$ p _ { <unknown> } $$$ + $$$ p _ { ijk } $$$ + $$$ p _ { lmnopq } $$$ = $$$ 4 $$$ + $$$ <unknown> $$$ + $$$ 2 $$$ + $$$ 4 $$$ = $$$ <unknown> $$$","['data structures', 'geometry']",3000.0
1220/F,"gardener alex love grow tree remind tree a connect acyclic graph $$$ n $$$ vertices today decide grow a root binary tree a binary tree a tree vertex two sons luckily alex a permutation number $$$ 1 $$$ $$$ n $$$ present last birthday decide grow a tree accord permutation follow process : find a minimum element make a root tree permutation divide two part : everything leave minimum element everything right minimum element leave part become leave son root minimum element right part become right son root , process repeat recursively part alex want grow a forest tree : one tree cyclic shift permutation interest cyclic shift give tree minimum depth unfortunately grow a forest a hard long process alex want answer right help ? remind cyclic shift permutation $$$ a_1 a_2 \ldots a_k \ldots a_n $$$ $$$ k $$$ elements leave permutation $$$ a _ { k + 1 } a _ { k + 2 } \ldots a_n a_1 a_2 \ldots a_k $$$ first line contain integer number $$$ n ~ ( 1 \leqslant n \leqslant 200\,000 ) $$$ — length permutation second line contain $$$ n $$$ integer number $$$ a_1 a_2 \ldots a_n ~ ( 1 \leqslant a_i \leqslant n ) $$$ guarantee number occur exactly one time print two number separate space : minimum possible depth a tree many elements need shift leave achieve depth number elements a number $$$ 0 $$$ $$$ n - 1 $$$ several possible answer print follow picture depict possible tree sample test cyclic shift achieve","['binary search', 'data structures']",2700.0
1221/A,play a variation game 2048 . initially a multiset $$$ s $$$ $$$ n $$$ integers every integer multiset a power two may perform number ( possibly zero ) operations multiset operation choose two equal integers $$$ s $$$ remove $$$ s $$$ insert number equal sum $$$ s $$$ example $$$ s = \ { 1 2 1 1 4 2 2\ } $$$ choose integers $$$ 2 $$$ $$$ 2 $$$ multiset become $$$ \ { 1 1 1 4 4 2\ } $$$ win number $$$ 2048 $$$ belong multiset example $$$ s = \ { 1024 512 512 4\ } $$$ win follow : choose $$$ 512 $$$ $$$ 512 $$$ multiset turn $$$ \ { 1024 1024 4\ } $$$ choose $$$ 1024 $$$ $$$ 1024 $$$ multiset turn $$$ \ { 2048 4\ } $$$ win determine win game answer $$$ q $$$ independent query first line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100 $$$ ) – number query first line query contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number elements multiset second line query contain $$$ n $$$ integers $$$ s_1 s_2 \dots s_n $$$ ( $$$ 1 \le s_i \le 2^ { 29 } $$$ ) — description multiset guarantee elements multiset power two query print yes possible obtain number $$$ 2048 $$$ multiset otherwise may print every letter case want ( example string yes yes yes yes recognize positive answer ) first query win follow : choose $$$ 512 $$$ $$$ 512 $$$ $$$ s $$$ turn $$$ \ { 1024 64 <unknown> } $$$ choose $$$ 1024 $$$ $$$ 1024 $$$ $$$ s $$$ turn $$$ \ { 2048 <unknown> } $$$ win second query $$$ s $$$ contain $$$ 2048 $$$ initially,"['brute force', 'greedy', 'math']",1000.0
1221/F,petya recently find a game ` ` choose a square '' game $$$ n $$$ point number $$$ 1 $$$ $$$ n $$$ infinite field $$$ i $$$ -th point coordinate $$$ ( x_i y_i ) $$$ cost $$$ c_i $$$ choose a square side parallel coordinate ax lower leave upper right corner belong line $$$ y = x $$$ corner integer coordinate score get sum cost point cover select square minus length side square note length side zero petya ask calculate maximum possible score game achieve place exactly one square first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) — number point field follow $$$ n $$$ line contain three integers $$$ x_i y_i c_i $$$ ( $$$ 0 \le x_i y_i \le 1000000000 -1000000 \le c_i \le 1000000 $$$ ) — coordinate $$$ i $$$ -th point cost respectively first line print maximum score petya achieve second line print four integers $$$ x_1 y_1 x_2 y_2 $$$ ( $$$ 0 \le x_1 y_1 x_2 y_2 \le 2 \cdot 1000000000 x_1 = y_1 x_2 = y_2 x_1 \le x_2 $$$ ) separate space — coordinate lower leave upper right corner square petya select order achieve maximum score field correspond first example :,"['binary search', 'data structures', 'sortings']",2400.0
1221/G,"give undirected graph $$$ n $$$ vertices $$$ m $$$ edge write a number vertex graph number either $$$ 0 $$$ $$$ 1 $$$ , write a number edge equal sum number vertices incident edge choose number write vertices least one edge $$$ 0 $$$ write least one edge $$$ 1 $$$ least one edge $$$ 2 $$$ many ways ? two ways choose number different exist least one vertex different number write two ways first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 40 $$$ $$$ 0 \le m \le \frac { n ( n - 1 ) } { 2 } $$$ ) — number vertices number edge respectively $$$ m $$$ line follow line contain two number $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ ) — endpoints $$$ i $$$ -th edge guarantee pair vertices connect one edge print one integer — number ways write number vertices exist least one edge $$$ 0 $$$ write least one edge $$$ 1 $$$ least one edge $$$ 2 $$$","['bitmasks', 'brute force', 'combinatorics', 'dp']",2900.0
1223/A,"let 's denote correct match equation ( denote cme ) equation $$$ a + b = c $$$ integers $$$ a $$$ $$$ b $$$ $$$ c $$$ greater zero example equations $$$ 2 + 2 = 4 $$$ ( <unknown> ) $$$ 1 + 2 = 3 $$$ ( <unknown> ) cme equations $$$ 1 + 2 = 4 $$$ ( <unknown> ) $$$ 2 + 2 = 3 $$$ ( <unknown> ) $$$ 0 + 1 = 1 $$$ ( + <unknown> ) , $$$ n $$$ match want assemble a cme use match unfortunately possible ca n't assemble cme use match buy extra match assemble cme ! example $$$ n = 2 $$$ buy two match assemble <unknown> $$$ n = 5 $$$ buy one match assemble <unknown> calculate minimum number match buy assemble cme note answer $$$ q $$$ independent query first line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100 $$$ ) — number query line query contain one integer $$$ n $$$ ( $$$ 2 \le n \le 1000000000 $$$ ) — number match test case print one integer single line — minimum number match buy assemble cme first second query explain statement third query assemble $$$ 1 + 3 = 4 $$$ ( <unknown> ) without buy match fourth query buy one match assemble $$$ 2 + 4 = 6 $$$ ( <unknown> )",['math'],800.0
1225/C,vasya fancy number long integer power two petya hand <unknown> like a single integer $$$ p $$$ ( may positive negative zero ) combine taste invent $$$ p $$$ -binary number form $$$ 2^x + p $$$ $$$ x $$$ a non - negative integer example $$$ -9 $$$ -binary ( ` ` minus nine '' binary ) number : $$$ -8 $$$ ( minus eight ) $$$ 7 $$$ $$$ 1015 $$$ ( $$$ <unknown> ^ 0 - 9 $$$ $$$ <unknown> ^ 4 - 9 $$$ $$$ <unknown> { 10 } -9 $$$ ) boys use $$$ p $$$ -binary number represent everything face a problem : give a positive integer $$$ n $$$ 's smallest number $$$ p $$$ -binary number ( necessarily distinct ) need represent $$$ n $$$ sum ? may possible representation impossible altogether help solve problem example $$$ <unknown> $$$ represent $$$ 7 $$$ $$$ 2 ^ 0 + 2 ^ 1 + 2 ^ 2 $$$ $$$ <unknown> $$$ represent $$$ 7 $$$ one number $$$ ( 2 ^ 4 - 9 ) $$$ note negative $$$ p $$$ -binary number allow sum ( see note section example ) line contain two integers $$$ n $$$ $$$ p $$$ ( $$$ 1 \leq n \leq 1000000000 $$$ $$$ -1000 \leq p \leq 1000 $$$ ) impossible represent $$$ n $$$ sum number $$$ p $$$ -binary number print a single integer $$$ -1 $$$ otherwise print smallest possible number summands $$$ 0 $$$ -binary number regular binary power thus first sample case represent $$$ 24 = ( 2 ^ 4 + 0 ) + ( 2 ^ 3 + 0 ) $$$ second sample case represent $$$ 24 = ( 2 ^ 4 + 1 ) + ( 2 ^ 2 + 1 ) + ( 2 ^ 0 + 1 ) $$$ third sample case represent $$$ 24 = ( 2 ^ 4 - 1 ) + ( 2 ^ 2 - 1 ) + ( 2 ^ 2 - 1 ) + ( 2 ^ 2 - 1 ) $$$ note repeat summands allow fourth sample case represent $$$ 4 = ( 2 ^ 4 - 7 ) + ( 2 ^ 1 - 7 ) $$$ note second summand negative allow fifth sample case representation possible,"['bitmasks', 'brute force', 'math']",1600.0
1225/F,"bytelandian tree factory produce tree kinds industrial applications task optimize production a certain type tree especially large important order tree question a root tree $$$ n $$$ vertices label distinct integers $$$ 0 $$$ $$$ n - 1 $$$ vertex label $$$ 0 $$$ root tree non - root vertex $$$ v $$$ label parent $$$ p ( v ) $$$ less label $$$ v $$$ tree factory make bamboo blank a bamboo a root tree vertex exactly one child except a single leaf vertex children vertices a bamboo blank label arbitrarily process start process a bamboo another tree a single type operation make : choose arbitrary non - root vertex $$$ v $$$ parent $$$ p ( v ) $$$ a root either operation consist change parent $$$ v $$$ parent 's parent $$$ p ( p ( v ) ) $$$ note parent vertices remain unchanged particular subtree $$$ v $$$ change efficiency crucial hence minimize number operations make desire tree a bamboo blank construct optimal sequence operations produce desire tree note label result tree coincide label desire tree formally label root equal non - root vertices label label parent guarantee test present problem answer exist , optimal sequence contain $$$ 1000000 $$$ operations note hack meet condition invalid first line contain a single integer $$$ n $$$ — number vertices tree ( $$$ 2 \leq n \leq 100000 $$$ ) second line contain $$$ n - 1 $$$ integers $$$ p ( 1 ) \ldots p ( n - 1 ) $$$ — indices parent vertices $$$ 1 \ldots n - 1 $$$ respectively ( $$$ 0 \leq p ( i ) < i $$$ ) first line print $$$ n $$$ distinct integers $$$ id_1 \ldots id_n $$$ — initial label bamboo blank start root vertex ( $$$ 0 \leq id_i < n $$$ ) second line print a single integer $$$ k $$$ — number operations sequence ( $$$ 0 \leq k \leq 1000000 $$$ ) third line print $$$ k $$$ integers $$$ v_1 \ldots v_k $$$ describe operations order $$$ i $$$ -th operation consist change $$$ p ( v_i ) $$$ $$$ p ( p ( v_i ) ) $$$ operation valid i.e neither $$$ v_i $$$ $$$ p ( v_i ) $$$ root tree moment","['greedy', 'trees']",2500.0
1227/E,"berland forest represent infinite cell plane every cell contain a tree , contain recent events a destructive fire rag forest several tree damage precisely speak a $$$ n \times m $$$ rectangle map represent damage part forest damage tree mark ` ` x '' remain ones mark ` ` . ` ` sure burn tree show map tree outside map undamaged firemen quickly extinguish fire investigate cause main version <unknown> : moment time ( let 's consider $$$ 0 $$$ ) tree set fire begin minute $$$ 0 $$$ tree set fire initially burn end minute fire spread every burn tree $$$ 8 $$$ neighbor tree begin minute $$$ t $$$ fire extinguish firemen want find arsonists quickly possible problem know neither value $$$ t $$$ ( long fire rag ) coordinate tree initially set fire want find maximum value $$$ t $$$ ( know far could arsonists escape ) a possible set tree could initially set fire note 'd like maximize value $$$ t $$$ set tree arbitrary first line contain two integer $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 1000000 $$$ $$$ 1 \le n \cdot m \le 1000000 $$$ ) — size map next $$$ n $$$ line contain map $$$ i $$$ -th line correspond $$$ i $$$ -th row map contain $$$ m $$$ -character string $$$ j $$$ -th character $$$ i $$$ -th string ` ` x '' correspond tree burn ` ` . '' otherwise 's guarantee map contain least one ` ` x '' first line print single integer $$$ t $$$ — maximum time forest fire next $$$ n $$$ line print certificate : map ( $$$ n \times m $$$ rectangle ) tree set fire mark ` ` x '' tree mark ` ` ` `","['binary search', 'graphs', 'graphs', 'shortest paths']",2200.0
1228/A,two integers $$$ l $$$ $$$ r $$$ find integer $$$ x $$$ satisfy condition : multiple answer print first line contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \le l \le r \le 10^ { 5 } $$$ ) answer exist print otherwise print $$$ -1 $$$ first example $$$ 123 $$$ one possible answer however $$$ 121 $$$ ca n't answer multiple $$$ 1 $$$ s different digits second example valid answer,"['brute force', 'implementation']",800.0
1228/B,suppose a $$$ h \times w $$$ grid consist empty full cells let 's make definitions : word $$$ i $$$ -th row start exactly $$$ r_i $$$ full cells similarly $$$ j $$$ -th column start exactly $$$ c_j $$$ full cells value $$$ r $$$ $$$ c $$$ initially cells empty find number ways fill grid cells satisfy value $$$ r $$$ $$$ c $$$ since answer large find answer modulo $$$ 1000000007\ ( 10^ { 9 } + 7 ) $$$ word find remainder division answer $$$ 1000000007\ ( 10^ { 9 } + 7 ) $$$ first line contain two integers $$$ h $$$ $$$ w $$$ ( $$$ 1 \le h w \le 10^ { 3 } $$$ ) — height width grid second line contain $$$ h $$$ integers $$$ r _ { 1 } r _ { 2 } \ldots r _ { h } $$$ ( $$$ 0 \le r _ { i } \le w $$$ ) — value $$$ r $$$ third line contain $$$ w $$$ integers $$$ c _ { 1 } c _ { 2 } \ldots c _ { w } $$$ ( $$$ 0 \le c _ { j } \le h $$$ ) — value $$$ c $$$ print answer modulo $$$ 1000000007\ ( 10^ { 9 } + 7 ) $$$ first example possible case second example 's impossible make a grid satisfy $$$ r $$$ $$$ c $$$ value third example make sure print answer modulo $$$ ( 1000000000 + 7 ) $$$,"['implementation', 'math']",1400.0
123/A,give a string s consist small latin letter let 's denote length string |s| character string number start 1 . task find possible rearrange character string s prime number p ≤ |s| integer i range 1 |s| / p ( inclusive ) follow condition fulfil sp = sp × i. answer positive find one way rearrange character line contain initial string s consist small latin letter ( 1 ≤ |s| ≤ 1000 ) possible rearrange character string above - mentioned condition fulfil print first line ` ` yes '' ( without quote ) print second line one possible result string permutation impossible perform print single string ` ` '' first sample six possible string : ` ` abc '' ` ` acb '' ` ` bac '' ` ` bca '' ` ` cab '' ` ` cba '' second sample letter permutation satisfy condition p = 2 ( s2 = s4 ) third test string character ` ` y '' n't occupy position 2 3 4 6 valid,"['implementation', 'number theory', 'strings']",1300.0
1230/B,"ania a large integer $$$ s $$$ decimal representation length $$$ n $$$ n't contain lead zero ania allow change $$$ k $$$ digits $$$ s $$$ want a way $$$ s $$$ still wo n't contain lead zero 'll minimal possible integer ania finish ? first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 200\,000 $$$ $$$ 0 \leq k \leq n $$$ ) — number digits decimal representation $$$ s $$$ maximum allow number change digits second line contain integer $$$ s $$$ 's guarantee $$$ s $$$ exactly $$$ n $$$ digits n't contain lead zero output minimal possible value $$$ s $$$ ania end note result integer also $$$ n $$$ digits a number lead zero consist least two digits first digit $$$ 0 $$$ example number $$$ 00 $$$ $$$ <unknown> $$$ $$$ 0101 $$$ lead zero $$$ 0 $$$ $$$ 3000 $$$ $$$ 1010 $$$ n't lead zero","['greedy', 'implementation']",1000.0
1234/A,a shop keeper a shop assistant a small nearby shop $$$ n $$$ goods $$$ i $$$ -th good cost $$$ a_i $$$ coin get tire remember price product customers ask thus decide simplify life precisely decide set price $$$ n $$$ goods however n't want lose money want choose price a way sum new price less sum initial price mean sell $$$ n $$$ goods new price receive least ( greater ) amount money sell initial price hand n't want lose customers big price among price choose need choose minimum one need find minimum possible equal price $$$ n $$$ goods sell price receive least ( greater ) amount money sell initial price answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100 $$$ ) — number query $$$ q $$$ query follow first line query contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 ) $$$ — number goods second line query contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 10000000 $$$ ) $$$ a_i $$$ price $$$ i $$$ -th good query print answer — minimum possible equal price $$$ n $$$ goods sell price receive least ( greater ) amount money sell initial price,['math'],800.0
1234/B1,difference easy hard versions constraints $$$ n $$$ $$$ k $$$ message one popular social network via smartphone smartphone show $$$ k $$$ recent conversations friends initially screen empty ( i.e number display conversations equal $$$ 0 $$$ ) conversation friends one conversation friends conversation uniquely define friend ( suddenly ! ) ability see future know day receive $$$ n $$$ message $$$ i $$$ -th message receive friend i d $$$ id_i $$$ ( $$$ 1 \le id_i \le 1000000000 $$$ ) receive a message $$$ id_i $$$ conversation currently display smartphone nothing happen : conversations screen change change order read message continue wait new message otherwise ( i.e conversation $$$ id_i $$$ screen ) : task find list conversations ( order display screen ) process $$$ n $$$ message first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 200 ) $$$ — number message number conversations smartphone show second line input contain $$$ n $$$ integers $$$ id_1 id_2 \dots id_n $$$ ( $$$ 1 \le id_i \le 1000000000 $$$ ) $$$ id_i $$$ i d friend send $$$ i $$$ -th message first line output print one integer $$$ m $$$ ( $$$ 1 \le m \le min ( n k ) $$$ ) — number conversations show receive $$$ n $$$ message second line print $$$ m $$$ integers $$$ ids_1 ids_2 \dots ids_m $$$ $$$ ids_i $$$ equal i d friend correspond conversation display position $$$ i $$$ receive $$$ n $$$ message first example list conversations change follow way ( order first last message ) : second example list conversations change follow way :,['implementation'],1000.0
1234/B2,difference easy hard versions constraints $$$ n $$$ $$$ k $$$ message one popular social network via smartphone smartphone show $$$ k $$$ recent conversations friends initially screen empty ( i.e number display conversations equal $$$ 0 $$$ ) conversation friends one conversation friends conversation uniquely define friend ( suddenly ! ) ability see future know day receive $$$ n $$$ message $$$ i $$$ -th message receive friend i d $$$ id_i $$$ ( $$$ 1 \le id_i \le 1000000000 $$$ ) receive a message $$$ id_i $$$ conversation currently display smartphone nothing happen : conversations screen change change order read message continue wait new message otherwise ( i.e conversation $$$ id_i $$$ screen ) : task find list conversations ( order display screen ) process $$$ n $$$ message first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 2 \cdot 100000 ) $$$ — number message number conversations smartphone show second line input contain $$$ n $$$ integers $$$ id_1 id_2 \dots id_n $$$ ( $$$ 1 \le id_i \le 1000000000 $$$ ) $$$ id_i $$$ i d friend send $$$ i $$$ -th message first line output print one integer $$$ m $$$ ( $$$ 1 \le m \le min ( n k ) $$$ ) — number conversations show receive $$$ n $$$ message second line print $$$ m $$$ integers $$$ ids_1 ids_2 \dots ids_m $$$ $$$ ids_i $$$ equal i d friend correspond conversation display position $$$ i $$$ receive $$$ n $$$ message first example list conversations change follow way ( order first last message ) : second example list conversations change follow way :,"['data structures', 'implementation']",1300.0
1234/C,give a system pip consist two row row consist $$$ n $$$ pip top leave pipe coordinate $$$ ( 1 1 ) $$$ bottom right — $$$ ( 2 n ) $$$ six type pip : two type straight pip four type curve pip examples six type : turn give pip $$$ 90 $$$ degrees clockwise counterclockwise arbitrary ( possibly zero ) number time ( type $$$ 1 $$$ $$$ 2 $$$ become type $$$ 3 4 5 6 $$$ become ) want turn pip a way water flow start $$$ ( 1 0 ) $$$ ( leave top leave pipe ) move pipe $$$ ( 1 1 ) $$$ flow somehow connect pip pipe $$$ ( 2 n ) $$$ flow right $$$ ( 2 n + 1 ) $$$ pip connect adjacent system end connect examples connect pip : let 's describe problem use example : solution : see water flow poorly draw blue line obtain answer need turn pipe $$$ ( 1 2 ) $$$ $$$ 90 $$$ degrees clockwise pipe $$$ ( 2 3 ) $$$ $$$ 90 $$$ degrees pipe $$$ ( 1 6 ) $$$ $$$ 90 $$$ degrees pipe $$$ ( 1 7 ) $$$ $$$ 180 $$$ degrees pipe $$$ ( 2 7 ) $$$ $$$ 180 $$$ degrees flow water reach $$$ ( 2 n + 1 ) $$$ $$$ ( 1 0 ) $$$ answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 10000 $$$ ) — number query $$$ q $$$ query follow query consist exactly three line first line query contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number pip row next two line contain a description first second row correspondingly row description consist $$$ n $$$ digits $$$ 1 $$$ $$$ 6 $$$ without whitespaces digit correspond type pipe correspond cell see problem statement understand digits correspond type pip guarantee sum $$$ n $$$ query exceed $$$ 200000 $$$ $$$ i $$$ -th query print answer — ` ` yes '' ( without quote ) possible turn pip a way water flow reach $$$ ( 2 n + 1 ) $$$ $$$ ( 1 0 ) $$$ ` ` '' otherwise first query example describe problem statement,"['dp', 'implementation']",1500.0
1236/A,alice play stone three number heap stone first contain $$$ a $$$ stone second contain $$$ b $$$ stone third contain $$$ c $$$ stone time one two operations : want get maximum number stone n't know initially $$$ 0 $$$ stone help ? first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case next $$$ t $$$ line describe test case follow format : line contain three non - negative integers $$$ a $$$ $$$ b $$$ $$$ c $$$ separate space ( $$$ 0 \leq a b c \leq 100 $$$ ) — number stone first second third heap respectively hack allow use one test case input $$$ t = 1 $$$ satisfy print $$$ t $$$ line answer test case order input answer test case integer — maximum possible number stone alice take make operations first test case first test alice take two stone second heap four stone third heap make second operation two time take one stone first heap two stone second heap make first operation one time summary number stone alice take $$$ 9 $$$ impossible make operations take $$$ 9 $$$ stone answer $$$ 9 $$$,"['brute force', 'greedy', 'math']",800.0
1236/D,alice get a new doll days even walk ! alice build a maze doll want test maze a grid $$$ n $$$ row $$$ m $$$ columns $$$ k $$$ obstacles $$$ i $$$ -th cell $$$ ( x_i y_i ) $$$ mean cell intersection $$$ x_i $$$ -th row $$$ y_i $$$ -th column however doll clumsy ways walk straight turn right cell ( include start cell ) get a cell obstacle get maze formally exist $$$ 4 $$$ directions doll look : stand cell doll move cell direction look turn right turn right doll switch 's direction follow rule : $$$ 1 \to 2 $$$ $$$ 2 \to 3 $$$ $$$ 3 \to 4 $$$ $$$ 4 \to 1 $$$ stand one cell doll make one turn right alice control doll 's move put doll cell $$$ ( 1 1 ) $$$ ( upper - left cell maze ) initially doll look direction $$$ 1 $$$ along row first cell last want let doll walk across cells without obstacles exactly end place achieve ? first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ separate space ( $$$ 1 \leq n m \leq 100000 0 \leq k \leq 100000 $$$ ) — size maze number obstacles next $$$ k $$$ line describe obstacles $$$ i $$$ -th line contain two integer number $$$ x_i $$$ $$$ y_i $$$ separate space ( $$$ 1 \leq x_i \leq <unknown> \leq y_i \leq m $$$ ) describe position $$$ i $$$ -th obstacle guarantee two obstacles cell obstacle cell $$$ ( 1 1 ) $$$ print ' yes ' ( without quote ) doll walk across cells without obstacles exactly rule describe statement impossible walk across maze rule print ' no ' ( without quote ) picture maze describe first example : first example doll walk way :,"['brute force', 'data structures', 'greedy', 'implementation']",2300.0
1237/G,$$$ n $$$ friends live a circular street friends house number clockwise $$$ 0 $$$ $$$ n-1 $$$ initially person $$$ i $$$ $$$ a_i $$$ stone friends want make distribution stone among perfectly balance : everyone possess number stone way change distribution stone conduct meet a meet people exactly $$$ k $$$ consecutive house ( remember street circular ) gather place bring stone bring stone may redistribute among people attend meet arbitrarily total number stone possess meet meet must stay meet everyone return home find a way make distribution stone perfectly balance conduct meet possible first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le k < n \le 100000 $$$ ) denote number friends size meet second line contain $$$ n $$$ integers $$$ a_0 a_1 \ldots a _ { n-1 } $$$ ( $$$ 0 \le a_i \le 10000 $$$ ) denote number stone people initially sum $$$ a_i $$$ divisible $$$ n $$$ output minimum number meet $$$ m $$$ ( $$$ m \ge 0 $$$ ) follow $$$ m $$$ descriptions meet chronological order $$$ i $$$ -th description must consist integer $$$ s_i $$$ ( $$$ 0 \le s_i < n $$$ ) follow $$$ k $$$ non - negative integers $$$ b _ { i 0 } b _ { i 1 } \ldots b _ { i k-1 } $$$ ( $$$ b _ { i j } \ge 0 $$$ ) a description denote a meet people $$$ s_i ( s_i + 1 ) \bmod n \ldots ( s_i + k - 1 ) \bmod n $$$ $$$ b _ { i j } $$$ denote number stone person $$$ ( s_i + j ) \bmod n $$$ must $$$ i $$$ -th meet sum $$$ b _ { i j } $$$ must match total number stone own people $$$ i $$$ -th meet show a solution exist valid input correct output contain $$$ 10000000 $$$ non - whitespace character first example distribution stone change follow : second example distribution stone change follow :,"['data structures', 'dp', 'greedy']",3500.0
1238/C,play a game character overcome different obstacles current problem come a cliff cliff height $$$ h $$$ a move platform height $$$ x $$$ $$$ 1 $$$ $$$ h $$$ platform either hide inside cliff move first $$$ n $$$ move platforms heights $$$ p_1 p_2 \dots p_n $$$ platform height $$$ h $$$ move ( character initially stand ) character stand move platform height $$$ x $$$ pull a special lever switch state two platforms : height $$$ x $$$ $$$ x - 1 $$$ word platform currently stand hide cliff platform one unit change state : hide move move hide second case safely land note way move one platform another character quite fragile safely fall height $$$ 2 $$$ word fall platform $$$ x $$$ platform $$$ x - 2 $$$ okay fall $$$ x $$$ $$$ x - 3 $$$ ( lower ) certain death sometimes 's possible come cliff always buy ( <unknown> currency ) several magic crystals magic crystal use change state single platform ( except platform height $$$ h $$$ unaffected crystals ) use crystal disappear minimum number magic crystal need buy safely land $$$ 0 $$$ grind level ? first line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100 $$$ ) — number query query contain two line independent query first line query contain two integers $$$ h $$$ $$$ n $$$ ( $$$ 1 \le h \le 1000000000 $$$ $$$ 1 \le n \le \min ( h 2 \cdot 100000 ) $$$ ) — height cliff number move platforms second line contain $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ h = p_1 > p_2 > \dots > p_n \ge 1 $$$ ) — correspond move platforms descend order heights sum $$$ n $$$ query exceed $$$ 200000 $$$ query print one integer — minimum number magic crystals spend safely come grind level ( height $$$ 0 $$$ ),"['dp', 'greedy', 'math']",1600.0
1238/D,string $$$ t_1t_2 \dots t_k $$$ good letter string belong least one palindrome length greater 1 . a palindrome a string read backward forward example string a bab abba <unknown> palindromes string ab abbbaa bbba examples good string : give a string $$$ s $$$ length $$$ n $$$ consist letter a b. calculate number good substrings string $$$ s $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) — length string $$$ s $$$ second line contain string $$$ s $$$ consist letter a b. print one integer — number good substrings string $$$ s $$$ first test case six good substrings : $$$ s_1 \dots s_2 $$$ $$$ s_1 \dots s_4 $$$ $$$ s_1 \dots s_5 $$$ $$$ s_3 \dots s_4 $$$ $$$ s_3 \dots s_5 $$$ $$$ s_4 \dots s_5 $$$ second test case three good substrings : $$$ s_1 \dots s_2 $$$ $$$ s_1 \dots s_3 $$$ $$$ s_2 \dots s_3 $$$,"['binary search', 'combinatorics', 'dp', 'strings']",1900.0
1239/B,"a harder version problem version $$$ n \le 300\,000 $$$ vasya experience developer program competitions ' problems great mind time vasya face a creative crisis improve situation petya gift a string consist open close bracket petya believe beauty bracket string a number cyclical shift form a correct bracket sequence digress problems vasya decide select two position string ( necessarily distinct ) swap character locate position vasya apply operation exactly curious maximum possible beauty achieve way please help remind bracket sequence $$$ s $$$ call correct : example ` ` ( ( ) ( ) ) '' ` ` ( ) '' correct ` ` ) ( ` ` ` ` ( ) ) '' cyclical shift string $$$ s $$$ length $$$ n $$$ $$$ k $$$ ( $$$ 0 \leq k < n $$$ ) a string form a concatenation last $$$ k $$$ symbols string $$$ s $$$ first $$$ n - k $$$ symbols string $$$ s $$$ example cyclical shift string ` ` ( ( ) ) ( ) '' $$$ 2 $$$ equal ` ` ( ) ( ( ) ) '' cyclical shift $$$ i $$$ $$$ j $$$ consider different $$$ i \ne j $$$ first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 300\,000 $$$ ) length string second line contain a string consist exactly $$$ n $$$ character character either ` ` ( ` ` ` ` ) '' first line contain a single integer — largest beauty string achieve swap two character second line contain integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l r \leq n $$$ ) — indices two character swap order maximize string 's beauty case several possible swap print first example swap $$$ 7 $$$ -th $$$ 8 $$$ -th character obtain a string ` ` ( ) ( ) ( ) ( ) ( ) '' cyclical shift $$$ 0 2 4 6 8 $$$ string form a correct bracket sequence second example swap $$$ 5 $$$ -th $$$ 10 $$$ -th character obtain a string ` ` ) ( ( ) ) ( ) ( ) ( ( ) '' cyclical shift $$$ 11 7 5 3 $$$ string form a correct bracket sequence third example swap two bracket result $$$ 0 $$$ cyclical shift correct bracket sequence",['implementation'],2500.0
1239/D,"catowice city next weekend cat contest hold however jury members contestants n't select yet $$$ n $$$ residents $$$ n $$$ cat catowice resident exactly one cat live house residents cat number integers $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th cat live house $$$ i $$$ -th resident catowice resident friendship several cat include one live house order conduct a contest least one jury member need least one cat contestant need course every jury member know none contestants contest successful 's also need number jury members plus number contestants equal $$$ n $$$ please help catowice residents select jury contestants upcoming competition determine 's impossible first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100\,000 $$$ ) number test case description $$$ t $$$ test case follow description follow : first line contain integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le m \le 1000000 $$$ ) number catowice residents number friendship pair residents cat next $$$ m $$$ line contain integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ ) denote $$$ a_i $$$ -th resident acquaintances $$$ b_i $$$ -th cat 's guarantee pair resident cat list 's guarantee every $$$ i $$$ exist a pair $$$ i $$$ -th resident $$$ i $$$ -th cat different test case separate empty line 's guarantee sum $$$ n $$$ test case $$$ 1000000 $$$ sum $$$ m $$$ test case $$$ 1000000 $$$ every test case print : second line print two integers $$$ j $$$ $$$ p $$$ ( $$$ 1 \le j $$$ $$$ 1 \le p $$$ $$$ j + p = n $$$ ) — number jury members number contest participants third line print $$$ j $$$ distinct integers $$$ 1 $$$ $$$ n $$$ indices residents form a jury fourth line print $$$ p $$$ distinct integers $$$ 1 $$$ $$$ n $$$ indices cat participate contest case several correct answer print first test case select first third resident a jury acquaintances a second cat select a contestant second test case select second resident a jury acquaintances a first a third cat select contestants third test case resident acquaintances cat ca n't contest together 's possible make a contest least one jury least one cat fourth test case resident acquaintances every cat 's possible make a contest least one jury least one cat","['dfs and similar', 'graphs']",2400.0
1239/E,"kolya a turtle a field size $$$ 2 \times n $$$ field row number $$$ 1 $$$ $$$ 2 $$$ top bottom columns number $$$ 1 $$$ $$$ n $$$ leave right suppose cell field a lettuce leaf energy value lettuce leaf row $$$ i $$$ column $$$ j $$$ equal $$$ a _ { i j } $$$ turtle initially top leave cell want reach bottom right cell turtle move right among possible ways choose a way maximize total energy value lettuce leave ( case several paths choose ) kolya afraid turtle eat much lettuce bad health want reorder lettuce leave field energetic cost leave eat turtle minimize first line contain integer $$$ n $$$ ( $$$ 2 \le n \le 25 $$$ ) — length field second line contain $$$ n $$$ integers $$$ a _ { 1 i } $$$ ( $$$ 0 \le a _ { 1 i } \le 50\,000 $$$ ) energetic cost lettuce leave first row field third line contain $$$ n $$$ integers $$$ a _ { 2 i } $$$ ( $$$ 0 \le a _ { 2 i } \le 50\,000 $$$ ) energetic cost lettuce leave second row field print two line $$$ n $$$ integers — optimal reorder lettuce input data case several optimal ways reorder lettuce print first example reorder turtle eat lettuce total energetic cost $$$ 1 + 4 + 2 = 7 $$$ second example turtle eat lettuce energetic cost equal $$$ 0 $$$ third example reorder turtle eat lettuce total energetic cost equal $$$ 1 $$$","['dp', 'implementation']",3100.0
1242/A,ujan lazy lately decide bring yard good shape first decide paint path house gate path consist $$$ n $$$ consecutive tile number $$$ 1 $$$ $$$ n $$$ ujan paint tile color consider path aesthetic two different tile number $$$ i $$$ $$$ j $$$ $$$ |j - i| $$$ a divisor $$$ n $$$ greater $$$ 1 $$$ color formally color two tile number $$$ i $$$ $$$ j $$$ $$$ |i - j| > 1 $$$ $$$ n \bmod |i - j| = 0 $$$ ( $$$ x \bmod y $$$ remainder divide $$$ x $$$ $$$ y $$$ ) ujan want <unknown> space maximum number different color ujan use path aesthetic ? first line input contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 10^ { 12 } $$$ ) length path output a single integer maximum possible number color path paint first sample two color maximum number tile $$$ 1 $$$ $$$ 3 $$$ color since $$$ 4 \bmod |3 - 1| = 0 $$$ also tile $$$ 2 $$$ $$$ 4 $$$ color since $$$ 4 \bmod |4 - 2| = 0 $$$ second sample five color use,"['math', 'number theory']",1500.0
1242/C,"ujan a lot number box like order balance decide reorder number $$$ k $$$ box number $$$ 1 $$$ $$$ k $$$ $$$ i $$$ -th box contain $$$ n_i $$$ integer number integers negative integers distinct ujan lazy follow reorder number exactly pick a single integer box $$$ k $$$ integers total insert choose number — one integer box number integers box begin note may also insert integer pick a box back box ujan happy sum integers box achieve make box perfectly balance like things ? first line contain a single integer $$$ k $$$ ( $$$ 1 \leq k \leq 15 $$$ ) number box $$$ i $$$ -th next $$$ k $$$ line first contain a single integer $$$ n_i $$$ ( $$$ 1 \leq n_i \leq 5\,000 $$$ ) number integers box $$$ i $$$ line contain $$$ n_i $$$ integers $$$ a _ { i,1 } \ldots a _ { i n_i } $$$ ( $$$ |a _ { i j } | \leq 1000000000 $$$ ) integers $$$ i $$$ -th box guarantee $$$ a _ { i j } $$$ distinct ujan achieve goal output ` ` '' a single line otherwise first line output ` ` yes '' output $$$ k $$$ line $$$ i $$$ -th line contain two integers $$$ c_i $$$ $$$ p_i $$$ mean ujan pick integer $$$ c_i $$$ $$$ i $$$ -th box place $$$ p_i $$$ -th box afterwards multiple solutions output print letter case ( upper lower ) first sample ujan put number $$$ 7 $$$ $$$ 2 $$$ nd box number $$$ 2 $$$ $$$ 3 $$$ rd box number $$$ 5 $$$ $$$ 1 $$$ st box keep number $$$ 10 $$$ $$$ 4 $$$ th box box contain number $$$ \ { <unknown> } $$$ $$$ \ { 3 7\ } $$$ $$$ \ { <unknown> } $$$ $$$ \ { 10\ } $$$ sum box equal $$$ 10 $$$ second sample possible pick redistribute number require way third sample one swap number $$$ -20 $$$ $$$ -10 $$$ make sum box equal $$$ -10 $$$","['bitmasks', 'dfs and similar', 'dp', 'graphs']",2400.0
1249/C2,difference easy hard versions maximum value $$$ n $$$ give a positive integer number $$$ n $$$ really love good number want find smallest good number greater equal $$$ n $$$ positive integer call good represent a sum distinct power $$$ 3 $$$ ( i.e duplicate power $$$ 3 $$$ allow ) example : note exist representations $$$ 19 $$$ $$$ 20 $$$ sum power $$$ 3 $$$ none consist distinct power $$$ 3 $$$ give positive integer $$$ n $$$ find smallest $$$ m $$$ ( $$$ n \le m $$$ ) $$$ m $$$ a good number answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 500 $$$ ) — number query $$$ q $$$ query follow line query contain one integer $$$ n $$$ ( $$$ 1 \le n \le 10^ { 18 } $$$ ) query print smallest integer $$$ m $$$ ( $$$ n \le m $$$ ) $$$ m $$$ a good number,"['binary search', 'greedy', 'math']",1500.0
125/D,"arithmetic progression a non - empty sequence number difference two successive number constant constant number call common difference example sequence 3 7 11 15 arithmetic progression definition imply sequence whose length equal 1 2 arithmetic sequence whose length equal 0 non - arithmetic give a sequence different integers a1 a2 ... , either split two arithmetic progressions find operation impossible perform split assign member give sequence one two progressions relative order number change split inverse operation merge first line contain a positive integer n ( 2 ≤ n ≤ 30000 ) n length give sequence second line contain elements give sequence a1 a2 ... ( - 108 ≤ ai ≤ 108 ) elements progression different integers print require arithmetic progressions one per line progressions position order progression contain least one number 's solution print ` ` solution '' ( without quote ) line input file several solutions print second sample another solution also possible ( number three assign second progression ) : 1 2 3 -2 -7",['greedy'],2200.0
1251/B,a palindrome a string $$$ t $$$ read backward forward ( formally $$$ t [ i ] = t [ |t| + 1 - i ] $$$ $$$ i \in [ 1 |t| ] $$$ ) $$$ |t| $$$ denote length a string $$$ t $$$ example string 010 1001 0 palindromes $$$ n $$$ binary string $$$ s_1 s_2 \dots s_n $$$ ( $$$ s_i $$$ consist zero and/or ones ) swap pair character number time ( possibly zero ) character either string different string — restrictions formally one move : maximum number string make palindromic simultaneously ? first line contain single integer $$$ q $$$ ( $$$ 1 \le q \le 50 $$$ ) — number test case first line test case contain single integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — number binary string next $$$ n $$$ line contain binary string $$$ s_1 s_2 \dots s_n $$$ — one per line 's guarantee $$$ 1 \le |s_i| \le 50 $$$ string <unknown> zero and/or ones print $$$ q $$$ integers — one per test case $$$ i $$$ -th integer maximum number palindromic string achieve simultaneously perform zero swap string $$$ i $$$ -th test case first test case $$$ s_1 $$$ palindrome answer $$$ 1 $$$ second test case ca n't make three string palindromic time make pair string palindromic example let 's make $$$ s_1 = \text { 0110 } $$$ $$$ s_2 = \text { 111111 } $$$ $$$ s_3 = \text { <unknown> } $$$ third test case make string palindromic example $$$ s_1 = \text { 11011 } $$$ $$$ s_2 = \text { 100001 } $$$ last test case $$$ s_2 $$$ palindrome make $$$ s_1 $$$ palindrome example swap $$$ s_1 [ 2 ] $$$ $$$ s_1 [ 3 ] $$$,"['greedy', 'strings']",1400.0
1251/D,head a large <unknown> $$$ n $$$ people work $$$ n $$$ odd ( i. e. $$$ n $$$ divisible $$$ 2 $$$ ) distribute salaries employees initially $$$ s $$$ dollars $$$ i $$$ -th employee get a salary $$$ l_i $$$ $$$ r_i $$$ dollars distribute salaries a way median salary maximum possible find median a sequence odd length sort take element middle position sort example : guarantee enough money pay minimum salary i.e $$$ l_1 + l_2 + \dots + l_n \le s $$$ note n't spend $$$ s $$$ dollars salaries answer $$$ t $$$ test case first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 200000 $$$ ) — number test case first line query contain two integers $$$ n $$$ $$$ s $$$ ( $$$ 1 \le n < 200000 $$$ $$$ 1 \le s \le 2 \cdot 10^ { 14 } $$$ ) — number employees amount money value $$$ n $$$ divisible $$$ 2 $$$ follow $$$ n $$$ line query contain information employees $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ query exceed $$$ 200000 $$$ also guarantee enough money pay minimum salary employee i. e. $$$ \sum\limits _ { i=1 } ^ { n } l_i \le s $$$ test case print one integer — maximum median salary obtain first test case distribute salaries follow : $$$ sal_1 = 12 sal_2 = 2 sal_3 = 11 $$$ ( $$$ <unknown> $$$ salary $$$ i $$$ -th employee ) median salary $$$ 11 $$$ second test case pay $$$ 1337 $$$ dollars employee third test case distribute salaries follow : $$$ sal_1 = 4 sal_2 = 3 sal_3 = 6 <unknown> = 6 <unknown> = 7 $$$ median salary $$$ 6 $$$,"['binary search', 'greedy', 'sortings']",1900.0
1251/E2,difference easy hard versions constraints elections hold berland want win precisely want everyone vote $$$ n $$$ voters two ways convince vote first way convince $$$ i $$$ -th voter pay $$$ p_i $$$ coin second way make $$$ m_i $$$ voters vote $$$ i $$$ -th voter vote free moreover process vote take place several step example five voters $$$ m_1 = 1 $$$ $$$ m_2 = 2 $$$ $$$ m_3 = 2 $$$ $$$ m_4 = 4 $$$ $$$ m_5 = 5 $$$ buy vote fifth voter eventually everyone vote set people vote change follow : $$$ { 5 } \rightarrow { 1 5 } \rightarrow { 1 2 3 5 } \rightarrow { 1 2 3 4 5 } $$$ calculate minimum number coin spend everyone vote first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 200000 $$$ ) — number test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number voters next $$$ n $$$ line contain description voters $$$ i $$$ -th line contain two integers $$$ m_i $$$ $$$ p_i $$$ ( $$$ 1 \le p_i \le 1000000000 0 \le m_i < n $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print one integer — minimum number coin spend everyone vote first test case buy vote third voter set people vote change follow : $$$ { 3 } \rightarrow { 1 3 } \rightarrow { 1 2 3 } $$$ second example n't need buy vote set people vote change follow : $$$ { 1 } \rightarrow { 1 3 5 } \rightarrow { 1 2 3 5 } \rightarrow { 1 2 3 5 6 7 } \rightarrow { 1 2 3 4 5 6 7 } $$$ third test case buy vote second fifth voters set people vote change follow : $$$ { 2 5 } \rightarrow { 1 2 3 4 5 } \rightarrow { 1 2 3 4 5 6 } $$$,"['binary search', 'data structures', 'greedy']",2400.0
1252/L,"$$$ n $$$ cities country <unknown> number $$$ 1 $$$ $$$ n $$$ currently road connect therefore $$$ n $$$ cities propose a road candidate construct city $$$ i $$$ like connect city $$$ a_i $$$ city $$$ i $$$ propose add a direct bidirectional road connect city $$$ i $$$ city $$$ a_i $$$ guarantee two cities like connect word pair integers $$$ i $$$ $$$ j $$$ $$$ a_i = j $$$ $$$ a_j = i $$$ also guarantee pair cities connect a sequence road proposals word propose roads construct pair cities connect a sequence construct road city $$$ i $$$ also prefer road construct use a specific material material represent integer ( example $$$ 0 $$$ asphalt $$$ 1 $$$ wood etc . ) material use road connect city $$$ i $$$ city $$$ a_i $$$ represent array $$$ b_i $$$ contain $$$ m_i $$$ integers : $$$ [ ( b_i ) _ 1 ( b_i ) _ 2 \dots ( b_i ) _ { m_i } ] $$$ mean road connect city $$$ i $$$ city $$$ a_i $$$ construct either material $$$ b_i $$$ $$$ k $$$ workers construct roads worker familiar one material thus construct a road a specific material particular $$$ i^ { th } $$$ worker construct a road material $$$ c_i $$$ worker construct one road want assign worker construct a road pair cities connect a sequence construct road input begin a line contain two integers : $$$ n $$$ $$$ k $$$ ( $$$ 3 \le n \le 2000 $$$ ; $$$ 1 \le k \le 2000 $$$ ) represent number cities number workers respectively next $$$ n $$$ line contain several integers : $$$ a_i $$$ $$$ m_i $$$ $$$ ( b_i ) _ 1 $$$ $$$ ( b_i ) _ 2 $$$ $$$ \cdots $$$ $$$ ( b_i ) _ { m_i } $$$ ( $$$ 1 \le a_i \le n $$$ ; $$$ a_i \ne i $$$ ; $$$ 1 \le m_i \le 10\,000 $$$ ; $$$ 0 \le ( b_i ) _ 1 < ( b_i ) _ 2 < \dots < ( b_i ) _ { m_i } \le 1000000000 $$$ ) represent bidirectional road city $$$ i $$$ like construct guarantee sum $$$ m_i $$$ exceed $$$ 10\,000 $$$ also guarantee two cities like connect pair cities connect a sequence road proposals next line contain $$$ k $$$ integers : $$$ c_i $$$ ( $$$ 0 \le c_i \le 1000000000 $$$ ) represent material familiarize workers possible assign worker construct a road pair cities connect a sequence construct road simply output -1 a line otherwise worker order input output a line two integers ( separate a single space ) : $$$ u $$$ $$$ v $$$ order mean worker construct a direct bidirectional road connect city $$$ u $$$ $$$ v $$$ worker construct road output ` ` 0 0 '' ( without quote ) instead pair cities assign one worker may output assignment long pair cities connect a sequence construct road explanation sample input / output # 1we assign workers construct follow roads : explanation sample input / output # <unknown> worker construct a road connect city $$$ 1 $$$ thus city $$$ 1 $$$ certainly isolate",['graphs'],2300.0
1253/C,<unknown> bring $$$ n $$$ delicious sweets light music club number $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th sweet a sugar concentration describe integer $$$ a_i $$$ yui love sweets eat $$$ m $$$ sweets day health reason days $$$ 1 $$$ -indexed ( number $$$ 1 2 3 \ldots $$$ ) eat sweet $$$ i $$$ $$$ d $$$ -th day cause a sugar penalty $$$ ( d \cdot a_i ) $$$ sweets become <unknown> time a sweet eat total sugar penalty sum individual <unknown> sweet eat suppose yui choose exactly $$$ k $$$ sweets eat order want minimum total sugar penalty get ? since yui undecided girl want answer question every value $$$ k $$$ $$$ 1 $$$ $$$ n $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le m \le n \le 200\ 000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 200\ 000 $$$ ) output $$$ n $$$ integers $$$ x_1 x_2 \ldots x_n $$$ a single line <unknown> space $$$ x_k $$$ minimum total sugar penalty yui get eat exactly $$$ k $$$ sweets let 's analyze answer $$$ k = 5 $$$ first example one possible ways eat $$$ 5 $$$ sweets minimize total sugar penalty : total penalty $$$ 1 \cdot a_1 + 1 \cdot a_4 + 2 \cdot a_5 + 2 \cdot a_3 + 3 \cdot a_6 = 6 + 4 + 8 + 6 + 6 = 30 $$$ prove 's minimum total sugar penalty yui achieve eat $$$ 5 $$$ sweets hence $$$ x_5 = 30 $$$,"['dp', 'greedy', 'math', 'sortings']",1500.0
1253/D,'re give undirected graph $$$ n $$$ nod $$$ m $$$ edge nod number $$$ 1 $$$ $$$ n $$$ graph consider harmonious follow property hold : word a harmonious graph a node $$$ l $$$ reach a node $$$ r $$$ edge ( $$$ l < r $$$ ) able reach nod $$$ ( l+1 ) ( l+2 ) \ldots ( r-1 ) $$$ minimum number edge need add make graph harmonious ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 3 \le n \le 200\ 000 $$$ $$$ 1 \le m \le 200\ 000 $$$ ) $$$ i $$$ -th next $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \neq v_i $$$ ) mean 's edge nod $$$ u $$$ $$$ v $$$ guarantee give graph simple ( self - loop one edge every pair nod ) print minimum number edge add graph make harmonious first example give graph harmonious ( instance $$$ 1 < 6 < 7 $$$ node $$$ 1 $$$ reach node $$$ 7 $$$ path $$$ 1 \rightarrow 2 \rightarrow 7 $$$ node $$$ 1 $$$ ca n't reach node $$$ 6 $$$ ) however add edge $$$ ( 2 4 ) $$$ sufficient make harmonious second example give graph already harmonious,"['dfs and similar', 'dsu', 'graphs', 'greedy', 'sortings']",1700.0
1253/E,mayor central town want modernize central street represent problem $$$ ( ox ) $$$ axis street $$$ n $$$ antennas number $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th antenna lie position $$$ x_i $$$ initial scope $$$ s_i $$$ : cover integer position inside interval $$$ [ x_i - s_i ; x_i + s_i ] $$$ possible increment scope antenna $$$ 1 $$$ operation cost $$$ 1 $$$ coin operation much want ( multiple time antenna want ) modernize street need make integer position $$$ 1 $$$ $$$ m $$$ inclusive cover least one antenna note authorize cover position outside $$$ [ 1 ; m ] $$$ even 's require minimum amount coin need achieve <unknown> ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 80 $$$ $$$ n \le m \le 100\ 000 $$$ ) $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ s_i $$$ ( $$$ 1 \le x_i \le m $$$ $$$ 0 \le s_i \le m $$$ ) position one antenna ( value $$$ x_i $$$ pairwise distinct ) output a single integer : minimum amount coin require make integer position $$$ 1 $$$ $$$ m $$$ inclusive cover least one antenna first example a possible strategy : total cost $$$ 40 + 210 + 31 = <unknown> $$$ prove 's minimum cost require make position $$$ 1 $$$ $$$ <unknown> $$$ cover least one antenna note position $$$ <unknown> $$$ $$$ 514 $$$ solution cover two different antennas 's <unknown> second example first antenna already cover interval $$$ [ 0 ; 2 ] $$$ nothing note position need cover position $$$ 1 $$$ ; position $$$ 0 $$$ $$$ 2 $$$ cover 's important,"['data structures', 'dp', 'greedy', 'sortings']",2200.0
126/E,doctor prescribe medicine patient medicine represent pills pill consist a shell heal powder shell consist two halve ; half one four color — blue red white yellow doctor want put 28 pills a rectangular box 7 × 8 size besides pill occupy exactly two neighbor cells cell contain exactly one half a pill thus result a four color picture 7 × 8 size doctor think a patient recover sooner picture make pills special unfortunately put pills box get require picture a easy task 's doctor ask help doctor amount pills 10 paint type contain medicine 's n't matter 28 store inside box place pills box require picture form impossible place pills require manner place number match color 56 cells final arrangement doctor 's picture maximum first 7 line contain doctor 's picture line contain 8 character character ` ` b '' ` ` r '' ` ` w '' ` ` y '' stand blue red white yellow color correspondingly next four line contain 10 number stand correspondingly number pills paint : '' '' ` ` bw '' ` ` br '' ` ` bb '' '' ry '' ` ` <unknown> '' ` ` rr '' '' wy '' ` ` ww '' '' yy '' number lie within range 0 28 inclusively guarantee total number pills less 28 . print first line maximal number cells color match print 13 line contain 15 character — pills ' position optimal arrangement intersections odd line odd columns contain character ` ` b '' ` ` r '' ` ` w '' ` ` y '' position contain character ` ` ` ` ` ` - '' ` ` | '' use ` ` - '' ` ` | '' show halve belong one pill see sample clarification several possible solutions print,['brute force'],2900.0
1263/F,electrical grid berland palaces consist 2 grids : main reserve wire palaces make expensive material sell would a good idea ! grid ( main reserve ) a head node ( number $$$ 1 $$$ ) every node get electricity head node node reach head node a unique path also grids exactly $$$ n $$$ nod spread electricity word every grid a root direct tree $$$ n $$$ leave a root node number $$$ 1 $$$ tree independent enumeration nod one grid connect nod another grid also palace $$$ n $$$ electrical devices device connect one node main grid one node reserve grid devices connect nod electricity spread ( nod tree 's leave ) grid 's leaf connect exactly one device guarantee whole grid ( two grids $$$ n $$$ devices ) show way ( like picture ) : formally tree exist a depth - first search node number $$$ 1 $$$ visit leave order connection devices $$$ 1 2 \dots n $$$ ( firstly node connect device $$$ 1 $$$ node connect device $$$ 2 $$$ etc . ) businessman want sell ( remove ) maximal amount wire device power least one grid ( main reserve ) word device exist least one path head node ( main grid reserve grid ) contain nod one grid first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — number devices palace next line contain integer $$$ a $$$ ( $$$ 1 + n \le a \le 1000 + n $$$ ) — amount nod main grid next line contain $$$ a - 1 $$$ integers $$$ p_i $$$ ( $$$ 1 \le p_i \le a $$$ ) integer $$$ p_i $$$ mean main grid contain a wire $$$ p_i $$$ -th node $$$ ( i + 1 ) $$$ -th next line contain $$$ n $$$ integers $$$ x_i $$$ ( $$$ 1 \le x_i \le a $$$ ) — number a node main grid connect $$$ i $$$ -th device next line contain integer $$$ b $$$ ( $$$ 1 + n \le b \le 1000 + n $$$ ) — amount nod reserve grid next line contain $$$ b - 1 $$$ integers $$$ q_i $$$ ( $$$ 1 \le q_i \le b $$$ ) integer $$$ q_i $$$ mean reserve grid contain a wire $$$ q_i $$$ -th node $$$ ( i + 1 ) $$$ -th next line contain $$$ n $$$ integers $$$ y_i $$$ ( $$$ 1 \le y_i \le b $$$ ) — number a node reserve grid connect $$$ i $$$ -th device guarantee grid a tree exactly $$$ n $$$ leave leaf connect one device also guarantee tree exist a depth - first search node $$$ 1 $$$ visit leave order connection devices print a single integer — maximal amount wire cut device power first example picture show one possible solutions ( wire remove mark red ) : second third examples see :,"['data structures', 'dfs and similar', 'dp', 'graphs', 'trees']",2400.0
1264/C,"creatnx $$$ n $$$ mirror number $$$ 1 $$$ $$$ n $$$ every day creatnx ask exactly one mirror ` ` i beautiful ? ` ` $$$ i $$$ -th mirror tell creatnx beautiful probability $$$ \frac { p_i } { 100 } $$$ $$$ 1 \le i \le n $$$ mirror call checkpoints initially $$$ 1 $$$ st mirror a checkpoint remain a checkpoint time creatnx ask mirror one one start $$$ 1 $$$ -st mirror every day ask $$$ i $$$ -th mirror two possibilities : change occur time : mirror become new checkpoints mirror longer checkpoints give $$$ q $$$ query query represent integer $$$ u $$$ : $$$ u $$$ -th mirror n't a checkpoint set a checkpoint otherwise $$$ u $$$ -th mirror longer a checkpoint query need calculate expect number days creatnx become happy number find modulo $$$ 998244353 $$$ formally let $$$ m = 998244353 $$$ show answer express irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \not \equiv 0 \pmod { m } $$$ output integer equal $$$ p \cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \le x < m $$$ $$$ x \cdot q \equiv p \pmod { m } $$$ first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \leq n q \le 200000 $$$ ) — number mirror query second line contain $$$ n $$$ integers : $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \leq p_i \leq 100 $$$ ) $$$ q $$$ follow line contain a single integer $$$ u $$$ ( $$$ 2 \leq u \leq n $$$ ) — next query print $$$ q $$$ number – answer query modulo $$$ 998244353 $$$ first test first query first second mirror checkpoints creatnx ask first mirror say beautiful ask second mirror say beautiful second mirror a checkpoint , become happy probabilities mirror say beautiful equal $$$ \frac { 1 } { 2 } $$$ , expect number days one mirror say beautiful equal $$$ 2 $$$ answer equal $$$ 4 = 2 + 2 $$$",['data structures'],2400.0
1265/B,give a permutation $$$ p= [ p_1 p_2 \ldots p_n ] $$$ integers $$$ 1 $$$ $$$ n $$$ let 's call number $$$ m $$$ ( $$$ 1 \le m \le n $$$ ) beautiful exist two indices $$$ l r $$$ ( $$$ 1 \le l \le r \le n $$$ ) number $$$ [ p_l p _ { l+1 } \ldots p_r ] $$$ a permutation number $$$ 1 2 \ldots m $$$ example let $$$ p = [ 4 5 1 3 2 6 ] $$$ case number $$$ 1 3 5 6 $$$ beautiful $$$ 2 4 $$$ : give a permutation $$$ p= [ p_1 p_2 \ldots p_n ] $$$ $$$ m $$$ ( $$$ 1 \le m \le n $$$ ) determine a beautiful number first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case input next line contain description test case first line a test case contain a number $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length give permutation $$$ p $$$ next line contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i $$$ different ) — give permutation $$$ p $$$ guarantee sum $$$ n $$$ test case input n't exceed $$$ 200000 $$$ print $$$ t $$$ line — answer test case order give input answer a test case string length $$$ n $$$ $$$ i $$$ -th character equal $$$ 1 $$$ $$$ i $$$ a beautiful number equal $$$ 0 $$$ $$$ i $$$ a beautiful number first test case describe problem statement second test case number $$$ 1 $$$ $$$ 5 $$$ beautiful :,"['data structures', 'implementation', 'math', 'two pointers']",1300.0
1266/D,$$$ n $$$ people world conveniently number $$$ 1 $$$ $$$ n $$$ use burl buy goods service occasionally a person might enough currency buy want need borrow money someone else idea repay loan later interest let $$$ d ( a b ) $$$ denote debt $$$ a $$$ towards $$$ b $$$ $$$ 0 $$$ debt sometimes become complex person lend money run financial trouble <unknown> able repay debt find need borrow money process run a long enough time might happen many debts <unknown> two ways do : total debt define sum debts : $$$ $$$ <unknown> = \sum _ { a b } d ( a b ) $$$ $$$ goal use rule order number time make total debt small possible note n't minimise number non - zero debts total debt first line contain two space separate integers $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) $$$ m $$$ ( $$$ 0 \leq m \leq 3\cdot 100000 $$$ ) represent number people number debts respectively $$$ m $$$ line follow contain three space separate integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n u_i \neq v_i $$$ ) $$$ d_i $$$ ( $$$ 1 \leq d_i \leq 1000000000 $$$ ) mean person $$$ u_i $$$ borrow $$$ d_i $$$ burl person $$$ v_i $$$ first line print integer $$$ m ' $$$ ( $$$ 0 \leq m ' \leq 3\cdot 100000 $$$ ) represent number debts <unknown> show answer always exist additional constraint print $$$ m ' $$$ line $$$ i $$$ -th contain three space separate integers $$$ u_i v_i d_i $$$ mean person $$$ u_i $$$ owe person $$$ v_i $$$ exactly $$$ d_i $$$ burl output must satisfy $$$ 1 \leq u_i v_i \leq n $$$ $$$ u_i \neq v_i $$$ $$$ 0 < d_i \leq 10^ { 18 } $$$ pair $$$ i \neq j $$$ hold $$$ u_i \neq u_j $$$ $$$ v_i \neq v_j $$$ word pair people include output first example optimal sequence operations follow : second example optimal sequence operations follow :,"['data structures', 'graphs', 'greedy', 'implementation', 'math', 'two pointers']",2000.0
1267/G,"esports a form competitive sport use video game dota 2 one popular competitive video game esports recently a new video game dota 3 release dota 3 a player buy relics hero relics counter track hero 's action statistics a game gloria like play dota 3 want buy $$$ n $$$ available relics favorite hero relics buy use in - game currency call shards relic price — $$$ c_i $$$ shards $$$ i $$$ -th relic a player buy a relic use one follow options : gloria want buy $$$ n $$$ relics help minimize expect number shards spend buy relics first line contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \le n \le 100 $$$ ; $$$ 1 \le x \le 10\,000 $$$ ) — number relics cost receive a random relic second line consist $$$ n $$$ integers $$$ c_1 c_2 \ldots c_n $$$ ( $$$ x \le c_i \le 10\,000 $$$ ; $$$ \sum { c_i } \le 10\,000 $$$ ) — price $$$ n $$$ relics print a single real number — minimum expect number shards gloria must spend buy relics absolute relative error exceed $$$ 10^ { -9 } $$$ first example optimal strategy randomly get one two relics pay $$$ 20 $$$ shards two scenarios first one happen gloria receive first relic keep get random relics obtain second relic expect number shards spend scenario $$$ 20 + 30 = 50 $$$ second scenario gloria initially get second relic better buy first relic $$$ 25 $$$ shards expect number shards spend scenario $$$ 20 + 25 = 45 $$$ thus expect number shards spend $$$ \frac { 50 + 45 } { 2 } = <unknown> $$$",['math'],3000.0
1268/E,"give a cactus graph graph edge lie one simple cycle give $$$ m $$$ edge $$$ a_i b_i $$$ weight $$$ i $$$ -th edge $$$ i $$$ let 's call a path cactus increase weight edge path increase let 's call a pair vertices $$$ ( u v ) $$$ happy exist increase path start $$$ u $$$ end $$$ v $$$ vertex $$$ u $$$ find number vertices $$$ v $$$ pair $$$ ( u v ) $$$ happy first line input contain two integers $$$ n m $$$ ( $$$ 1 \leq n m \leq 500\,000 $$$ ) : number vertices edge give cactus next $$$ m $$$ line contain a description cactus edge $$$ i $$$ -th contain two integers $$$ a_i b_i $$$ ( $$$ 1 \leq a_i b_i \leq n a_i \neq b_i $$$ ) guarantee multiple edge graph connect print $$$ n $$$ integers require value vertices $$$ 1,2 \ldots n $$$",['dp'],3400.0
127/B,nicholas a painter go paint several new canvas nicholas sure canvas turn great one need frame hang wall frame nicholas decide begin nicholas n stick whose lengths equal a1 a2 ... nicholas want break stick glue together make a h × w - sized frame need two stick whose lengths equal h two stick whose lengths equal w. specifically make a square frame ( h = w ) need four stick length nicholas want make stick many frame possible ; able paint many canvas possible fill frame help uneasy task note necessary use stick nicholas first line contain integer n ( 1 ≤ n ≤ 100 ) — number stick second line contain n space - separated integers i - th integer equal length i - th stick ai ( 1 ≤ ai ≤ 100 ) print single number — maximum number frame nicholas make future canvas,['implementation'],1000.0
1270/E,give a set $$$ <unknown> 2 $$$ pairwise different point integer coordinate task partition point two nonempty group $$$ a $$$ $$$ b $$$ follow condition hold : every two point $$$ p $$$ $$$ q $$$ write euclidean distance blackboard : belong group — a yellow pen belong different group — a blue pen yellow number equal blue number guarantee a partition exist possible input exist multiple partition allow output first line contain one integer $$$ n $$$ $$$ ( 2 \le n \le 1000 ) $$$ — number point $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ -1000000 \le x_i y_i \le 1000000 $$$ ) — coordinate $$$ i $$$ -th point guarantee $$$ n $$$ point pairwise different first line output $$$ a $$$ ( $$$ 1 \le a \le n-1 $$$ ) — number point a group $$$ a $$$ second line output $$$ a $$$ integers — index point include group $$$ a $$$ multiple answer print first example set point $$$ ( 0 0 ) $$$ group $$$ a $$$ point $$$ ( 0 1 ) $$$ $$$ ( 1 0 ) $$$ group $$$ b $$$ way $$$ 1 $$$ yellow number $$$ \sqrt { 2 } $$$ $$$ 2 $$$ blue number $$$ 1 $$$ blackboard second example set point $$$ ( 0 1 ) $$$ $$$ ( 0 -1 ) $$$ group $$$ a $$$ point $$$ ( -1 0 ) $$$ $$$ ( 1 0 ) $$$ group $$$ b $$$ way $$$ 2 $$$ yellow number $$$ 2 $$$ $$$ 4 $$$ blue number $$$ \sqrt { 2 } $$$ blackboard,"['geometry', 'math']",2300.0
1270/I,"give integer $$$ k $$$ a grid $$$ 2^k \times 2^k $$$ number write cells cell $$$ ( i j ) $$$ initially contain number $$$ a _ { ij } $$$ grid consider a <unknown> , cell right $$$ ( i 2^k ) $$$ $$$ ( i 1 ) $$$ cell $$$ ( 2^k i ) $$$ $$$ ( 1 i ) $$$ also give a lattice figure $$$ f $$$ consist $$$ t $$$ cells $$$ t $$$ odd $$$ f $$$ n't connect perform follow operation : place $$$ f $$$ position grid ( translations allow rotations reflections prohibit ) choose nonnegative integer $$$ p $$$ , cell $$$ ( i j ) $$$ cover $$$ f $$$ replace $$$ a _ { ij } $$$ $$$ a _ { ij } \oplus p $$$ $$$ \oplus $$$ denote bitwise xor operation formally let $$$ f $$$ give cells $$$ ( x_1 y_1 ) ( x_2 y_2 ) \dots ( x_t <unknown> ) $$$ follow operation : choose $$$ x y $$$ $$$ 1\le x y \le 2^k $$$ nonnegative integer $$$ p $$$ every $$$ i $$$ $$$ 1 $$$ $$$ n $$$ replace number cell $$$ ( ( ( x + x_i - 1 ) \bmod 2^k ) + 1 ( ( y + y_i - 1 ) \bmod 2^k ) + 1 ) $$$ $$$ a _ { ( ( x + x_i - 1 ) \bmod 2^k ) + 1 ( ( y + y_i - 1 ) \bmod 2^k ) + 1 } \oplus p $$$ goal make number equal $$$ 0 $$$ achieve ? , find smallest number operations possible first line contain a single integer $$$ k $$$ ( $$$ 1 \le k \le 9 $$$ ) $$$ i $$$ -th next $$$ 2^k $$$ line contain $$$ 2^k $$$ integers $$$ a _ { i1 } a _ { i2 } \dots a _ { <unknown> } $$$ ( $$$ 0 \le a _ { ij } < 2^ { 60 } $$$ ) — initial value $$$ i $$$ -th row grid next line contain a single integer $$$ t $$$ ( $$$ 1\le t \le \min ( 99 4^k ) $$$ $$$ t $$$ odd ) — number cells figure $$$ i $$$ -th next $$$ t $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le 2^k $$$ ) describe position $$$ i $$$ -th cell figure guarantee cells different guarantee figure connect impossible make number grid equal $$$ 0 $$$ operations output $$$ -1 $$$ otherwise output a single integer — minimal number operations need show possible make number equal $$$ 0 $$$ possible less $$$ 10^ { 18 } $$$ operations figure operations example show :",['math'],3500.0
1271/B,$$$ n $$$ block arrange a row number leave right start one block either black white may perform follow operation zero time : choose two adjacent block invert color ( white block become black vice versa ) want find a sequence operations make block color n't minimize number operations exceed $$$ 3 \cdot n $$$ impossible find a sequence operations need report first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200 $$$ ) — number block second line contain one string $$$ s $$$ consist $$$ n $$$ character character either ` ` w '' ` ` b '' $$$ i $$$ -th character ` ` w '' $$$ i $$$ -th block white $$$ i $$$ -th character ` ` b '' $$$ i $$$ -th block black impossible make block color print $$$ -1 $$$ otherwise print integer $$$ k $$$ ( $$$ 0 \le k \le 3 \cdot n $$$ ) — number operations print $$$ k $$$ integers $$$ p_1 p_2 \dots p_k $$$ $$$ ( 1 \le p_j \le n - 1 ) $$$ $$$ p_j $$$ position leave block pair block affect $$$ j $$$ -th operation multiple answer print first example possible make block black $$$ 3 $$$ operations start change block $$$ 6 $$$ $$$ 7 $$$ sequence ` ` <unknown> '' change block $$$ 2 $$$ $$$ 3 $$$ sequence ` ` <unknown> '' finally change block $$$ 4 $$$ $$$ 5 $$$ block black impossible make color equal second example block already white third example fourth example possible make block white two operations : first operation change block $$$ 2 $$$ $$$ 3 $$$ ( sequence ` ` <unknown> '' ) change block $$$ 1 $$$ $$$ 2 $$$ ( block white ),"['greedy', 'math']",1300.0
1272/B,recently buy a snow walk robot bring home suppose home a cell $$$ ( 0 0 ) $$$ infinite grid also sequence instructions robot write string $$$ s $$$ consist character ' l ' ' r ' ' u ' 'd ' robot cell $$$ ( x y ) $$$ right move one adjacent cells ( depend current instruction ) ' ve notice warn last page manual : robot visit cell ( except $$$ ( 0 0 ) $$$ ) twice break sequence instructions valid robot start cell $$$ ( 0 0 ) $$$ perform give instructions visit cell $$$ ( 0 0 ) $$$ two time end path cell $$$ ( 0 0 ) $$$ also cell $$$ ( 0 0 ) $$$ visit two time : begin end ( path empty visit ) example follow sequence instructions consider valid : ` ` ud '' ` ` rl '' ` ` <unknown> '' follow consider invalid : ` ` u '' ( endpoint $$$ ( 0 0 ) $$$ ) ` ` <unknown> '' ( cell $$$ ( 0 1 ) $$$ visit twice ) initial sequence instructions however might valid n't want robot break decide <unknown> follow way : remove ( possibly none ) instructions initial sequence instructions rearrange remain instructions wish turn robot move task remove instructions initial sequence possible rearrange remain ones sequence valid report valid sequence maximum length obtain note choose order remain instructions ( n't need minimize number swap similar metric ) answer $$$ q $$$ independent test case first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 20000 $$$ ) — number test case next $$$ q $$$ line contain test case $$$ i $$$ -th test case give string $$$ s $$$ consist least $$$ 1 $$$ $$$ 100000 $$$ character ' l ' ' r ' ' u ' 'd ' — initial sequence instructions guarantee sum $$$ |s| $$$ ( $$$ |s| $$$ length $$$ s $$$ ) exceed $$$ 100000 $$$ test case ( $$$ \sum |s| \le 100000 $$$ ) test case print answer first line print maximum number remain instructions second line print valid sequence remain instructions $$$ t $$$ robot perform move perform leave right order print sequence several answer print answer $$$ 0 $$$ allow print empty line ( n't print ) two possible answer first test case : ` ` lr '' ` ` rl '' picture correspond second test case : another correct answer third test case : ` ` <unknown> '',"['greedy', 'implementation']",1200.0
1272/C,"recently norge find a string $$$ s = s_1 s_2 \ldots s_n $$$ consist $$$ n $$$ lowercase latin letter exercise improve type speed decide type substrings string $$$ s $$$ yes $$$ \frac { n ( n + 1 ) } { 2 } $$$ ! a substring $$$ s $$$ a non - empty string $$$ x = s [ a \ldots b ] = s _ { a } s _ { a + 1 } \ldots s _ { b } $$$ ( $$$ 1 \leq a \leq b \leq n $$$ ) example ` ` auto '' ` ` ton '' substrings ` ` automaton '' shortly start exercise norge realize keyboard break namely could use $$$ k $$$ latin letter $$$ c_1 c_2 \ldots c_k $$$ $$$ 26 $$$ , norge become interest many substrings string $$$ s $$$ could still type use break keyboard help find number first line contain two space - separated integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 200000 $$$ $$$ 1 \leq k \leq 26 $$$ ) — length string $$$ s $$$ number latin letter still available keyboard second line contain string $$$ s $$$ consist exactly $$$ n $$$ lowercase latin letter third line contain $$$ k $$$ space - separated distinct lowercase latin letter $$$ c_1 c_2 \ldots c_k $$$ — letter still available keyboard print a single number — number substrings $$$ s $$$ type use available letter $$$ c_1 c_2 \ldots c_k $$$ first example norge print substrings $$$ s [ <unknown> ] $$$ $$$ s [ <unknown> ] $$$ $$$ s [ <unknown> ] $$$ $$$ s [ <unknown> ] $$$ $$$ s [ <unknown> ] $$$ $$$ s [ <unknown> ] $$$ $$$ s [ <unknown> ] $$$ $$$ s [ <unknown> ] $$$ $$$ s [ <unknown> ] $$$ $$$ s [ <unknown> ] $$$ $$$ s [ <unknown> ] $$$ $$$ s [ <unknown> ] $$$","['combinatorics', 'dp', 'implementation']",1200.0
1276/B,"$$$ n $$$ cities berland pair connect two - way roads guarantee pass city move along roads cities numerate $$$ 1 $$$ $$$ n $$$ two fair currently take place berland — hold two different cities $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le n $$$ ; $$$ a \ne b $$$ ) find number pair cities $$$ x $$$ $$$ y $$$ ( $$$ x \ne a x \ne b y \ne a y \ne b $$$ ) go $$$ x $$$ $$$ y $$$ go fair ( order visit n't matter ) formally need find number pair cities $$$ x y $$$ path $$$ x $$$ $$$ y $$$ go $$$ a $$$ $$$ b $$$ ( order ) print require number pair order two cities a pair matter , pair $$$ ( x y ) $$$ $$$ ( y x ) $$$ must take account first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 4\cdot10000 $$$ ) — number test case input next $$$ t $$$ test case specify first line test case contain four integers $$$ n $$$ $$$ m $$$ $$$ a $$$ $$$ b $$$ ( $$$ 4 \le n \le 2\cdot100000 $$$ $$$ n - 1 \le m \le 5\cdot100000 $$$ $$$ 1 \le a b \le n $$$ $$$ a \ne b $$$ ) — number cities roads berland number two cities fair hold respectively follow $$$ m $$$ line contain descriptions roads cities road description contain a pair integers $$$ u_i v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) — number cities connect road road bi - directional connect two different cities guarantee city pass roads one road a pair cities sum value $$$ n $$$ set input data test exceed $$$ 2\cdot100000 $$$ sum value $$$ m $$$ set input data test exceed $$$ 5\cdot100000 $$$ print $$$ t $$$ integers — answer give test case order write input","['combinatorics', 'dfs and similar', 'dsu', 'graphs']",1900.0
1278/A,polycarp build web service a modern web service include login feature always imply password security problems polycarp decide store hash password generate follow algorithm : example let password $$$ p = $$$ ` ` abacaba '' $$$ p ' $$$ equal ` ` <unknown> '' random string $$$ s1 = $$$ ` ` zyx '' $$$ s2 = $$$ ` ` <unknown> '' $$$ h = $$$ ` ` <unknown> '' note letter could delete add $$$ p $$$ obtain $$$ p ' $$$ order could change polycarp ask help implement password check module give password $$$ p $$$ hash $$$ h $$$ check $$$ h $$$ hash password $$$ p $$$ program answer $$$ t $$$ independent test case first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain a non - empty string $$$ p $$$ consist lowercase latin letter length $$$ p $$$ exceed $$$ 100 $$$ second line test case contain a non - empty string $$$ h $$$ consist lowercase latin letter length $$$ h $$$ exceed $$$ 100 $$$ test case print answer — ` ` yes '' give hash $$$ h $$$ could obtain give password $$$ p $$$ ` ` '' otherwise first test case explain statement second test case $$$ s_1 $$$ $$$ s_2 $$$ empty $$$ p'= $$$ ` ` <unknown> '' $$$ p $$$ shuffle third test case hash could obtain password fourth test case $$$ <unknown> $$$ ` ` n '' $$$ s_2 $$$ empty $$$ p'= $$$ ` ` one '' $$$ p $$$ shuffle ( even think stay ) fifth test case hash could obtain password,"['brute force', 'implementation', 'strings']",1000.0
1278/B,"give two integers $$$ a $$$ $$$ b $$$ perform a sequence operations : first operation choose one number increase $$$ 1 $$$ ; second operation choose one number increase $$$ 2 $$$ , choose number operations example $$$ a = 1 $$$ $$$ b = 3 $$$ perform follow sequence three operations : calculate minimum number operations require make $$$ a $$$ $$$ b $$$ equal first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case line test case contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le 1000000000 $$$ ) test case print one integer — minimum number operations require make $$$ a $$$ $$$ b $$$ equal first test case consider statement second test case integers $$$ a $$$ $$$ b $$$ already equal n't need perform operations third test case apply first second third fourth operation $$$ b $$$ ( $$$ b $$$ turn $$$ 20 + 1 + 2 + 3 + 4 = 30 $$$ )","['greedy', 'math']",1500.0
1279/B,"new year come ! vasya prepare a new year 's verse want recite front santa claus vasya 's verse contain $$$ n $$$ part take $$$ a_i $$$ second recite $$$ i $$$ -th part vasya ca n't change order part verse : firstly recite part take $$$ a_1 $$$ second secondly — part take $$$ a_2 $$$ second , recite verse vasya get number present equal number part fully recite vasya skip one part verse recite ( skip one part santa definitely notice ) santa listen vasya 's verse $$$ s $$$ second example $$$ s = 10 $$$ $$$ a = [ 100 9 1 1 ] $$$ vasya skip first part verse get two present note possible recite whole verse ( enough time ) determine part vasya need skip obtain maximum possible number gift vasya n't skip anything print 0 . multiple answer print process $$$ t $$$ test case first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ s $$$ ( $$$ 1 \le n \le 100000 1 \le s \le 1000000000 $$$ ) — number part verse maximum number second santa listen vasya respectively second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — time take recite part verse guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print one integer — number part vasya need skip obtain maximum number gift vasya n't skip part print 0 . first test case vasya skip second part get three gift second test case matter part verse vasya skip third test case vasya recite whole verse","['binary search', 'brute force', 'implementation']",1300.0
128/D,one day anna get follow task school : arrange several number a circle two neighbor number differ exactly 1 . anna give several number arrange a circle fulfill task want check arrange number correctly point younger sister maria come shuffle number anna get sick anger 's do do result work destroy please tell anna : could <unknown> complete task use give number ? first line contain integer n — many number anna ( 3 ≤ n ≤ 105 ) next line contain number separate a space number integers belong range 1 109 . print single line ` ` yes '' ( without quote ) anna could complete task correctly use number ( use necessary ) anna could n't fulfil task matter hard would try print ` ` '' ( without quote ),['implementation'],2000.0
1280/E,friend kirchhoff shock current state electronics design . ` ` <unknown> ! watt wrong field ? circuit inefficient ! 's much capacity improvement electrical engineer must conduct class well 's absolutely <unknown> '' say <unknown> keep flow even complain many time still n't <unknown> chance directly change anything ` ` circuit much total resistance wire design way ? 's cause a massive loss resistors ! entire field could conserve much money maximize potential design ca n't try alternative ideas ? ` ` frequency protest electrical engineer department <unknown> soul decide take charge help plan create a program optimize circuit keep circuit layout maintain effective resistance a circuit two endpoints associate a certain constant $$$ r $$$ call effective resistance circuit 'll consider form individual resistors join together series parallel form complex circuit follow image illustrate combine circuit series parallel accord friend kirchhoff effective resistance calculate quite easily join circuit way : circuit represent string individual resistors represent asterisk ` ` * '' complex circuit suppose $$$ s_1 s_2 \ldots s_k $$$ represent $$$ k \ge 2 $$$ circuit : example ` ` ( * p ( * s * ) p * ) '' represent follow circuit : give a circuit task assign resistances individual resistors satisfy follow requirements : $$$ n $$$ individual resistors need output list $$$ r_1 r_2 \ldots r_n $$$ ( $$$ 0 \le r_i $$$ $$$ r_i $$$ integer ) $$$ r_i $$$ resistance assign $$$ i $$$ -th individual <unknown> appear input ( leave right ) impossible accomplish task must say well possible guarantee minimum sum resistances $$$ 10^ { 18 } $$$ first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 32000 $$$ ) denote number test case next line contain descriptions test case test case consist a single line contain integer $$$ r $$$ ( $$$ 1 \le r \le 1000000 $$$ ) space string represent circuit guarantee string valid follow description number individual resistors ( symbols ` ` * '' ) least $$$ 1 $$$ $$$ 80000 $$$ guarantee total number individual resistors across test case $$$ <unknown> $$$ test case print a single line : may multiple possible assignments a minimal sum resistances individual resistors output ; follow illustrate third sample case : sum resistances individual resistors $$$ 2 + 1 + 1 = 4 $$$ show minimum note may assignments achieve minimum,['math'],2900.0
1281/A,discover a new data structure research group : a suffix three ! 's useful natural language process give three languages three suffix a suffix three determine language a sentence write 's super simple 100 % accurate n't involve advance machine learn algorithms let us tell work give need implement a suffix three differentiate filipino japanese korean oh i say three suffix ? i mean four first line input contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 30 $$$ ) denote number test case next line contain descriptions test case test case consist a single line contain a single string denote sentence space represent underscore ( symbol ` ` _ '' ) ease read sentence least $$$ 1 $$$ $$$ 1000 $$$ character consist lowercase english letter underscore sentence lead trail underscore two consecutive underscore guarantee sentence end one four suffix mention test case print a single line contain either ` ` filipino '' ` ` japanese '' ` ` korean '' ( uppercase without quote ) depend detect language first sentence end ` ` <unknown> '' write filipino second third sentence end ` ` desu '' ` ` <unknown> '' write japanese fourth sentence end ` ` <unknown> '' write korean,['implementation'],800.0
1281/B,friend jeff <unknown> try run new online company 's go well 's get a lot sales website decide call <unknown> big problem think 's rank high enough search engines could rename products better name competitors 'll top search result a <unknown> research find search engines sort result lexicographically friend could rename products lexicographically smaller string competitor 's 'll top rank ! make strategy less obvious competitors decide swap two letter product name please help jeff find improve name products lexicographically smaller competitor 's ! give string $$$ s $$$ represent jeff 's product name string $$$ c $$$ represent competitor 's product name find a way swap one pair character $$$ s $$$ ( find two distinct indices $$$ i $$$ $$$ j $$$ swap $$$ s_i $$$ $$$ s_j $$$ ) result new name become strictly lexicographically smaller $$$ c $$$ determine impossible note : string $$$ a $$$ strictly lexicographically smaller string $$$ b $$$ one follow hold : first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1500 $$$ ) denote number test case next line contain descriptions test case test case consist a single line contain two space - separated string $$$ s $$$ $$$ c $$$ ( $$$ 2 \le |s| \le 5000 1 \le |c| \le 5000 $$$ ) string $$$ s $$$ $$$ c $$$ consist uppercase english letter guarantee sum $$$ |s| $$$ input $$$ 5000 $$$ sum $$$ |c| $$$ input $$$ 5000 $$$ test case output a single line contain a single string <unknown> first test case possible swap second fourth letter string result string ` ` amazon '' lexicographically smaller ` ` apple '' impossible improve product 's name second test case satisfy condition third test case possible swap a pair character name ` ` apple '' lexicographically smaller ` ` banana '' note valid answer e.g. ` ` <unknown> '',['greedy'],1600.0
1285/D,today a friendship gift bakry give badawy $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ challenge choose integer $$$ x $$$ value $$$ \underset { 1 \leq i \leq n } { \max } ( a_i \oplus x ) $$$ minimum possible $$$ \oplus $$$ denote bitwise xor operation always badawy lazy decide help find minimum possible value $$$ \underset { 1 \leq i \leq n } { \max } ( a_i \oplus x ) $$$ first line contain integer $$$ n $$$ ( $$$ 1\le n \le 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 2^ { 30 } -1 $$$ ) print one integer — minimum possible value $$$ \underset { 1 \leq i \leq n } { \max } ( a_i \oplus x ) $$$ first sample choose $$$ x = 3 $$$ second sample choose $$$ x = 5 $$$,"['bitmasks', 'brute force', 'dfs and similar', 'divide and conquer', 'dp', 'greedy', 'strings', 'trees']",1900.0
1285/E,$$$ n $$$ segment a $$$ ox $$$ axis $$$ [ l_1 r_1 ] $$$ $$$ [ l_2 r_2 ] $$$ ... $$$ [ l_n r_n ] $$$ segment $$$ [ l r ] $$$ cover point $$$ l $$$ $$$ r $$$ inclusive $$$ x $$$ $$$ l \le x \le r $$$ segment place arbitrarily — inside coincide segment degenerate point $$$ l_i = r_i $$$ possible union set segment a set segment cover exactly set point original set example : obviously a union a set pairwise non - intersecting segment ask erase exactly one segment give $$$ n $$$ number segment union rest $$$ n-1 $$$ segment maximum possible example $$$ n=4 $$$ segment $$$ [ 1 4 ] $$$ $$$ [ 2 3 ] $$$ $$$ [ 3 6 ] $$$ $$$ [ 5 7 ] $$$ : thus require erase third segment get answer $$$ 2 $$$ write a program find maximum number segment union $$$ n-1 $$$ segment erase give $$$ n $$$ segment note multiple equal segment give set erase one anyway set erase exactly $$$ n-1 $$$ segment first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test descriptions $$$ t $$$ test case follow first test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 2\cdot100000 $$$ ) — number segment give set $$$ n $$$ line follow contain a description a segment — a pair integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ -1000000000 \le l_i \le r_i \le 1000000000 $$$ ) $$$ l_i $$$ $$$ r_i $$$ coordinate leave right border $$$ i $$$ -th segment respectively segment give arbitrary order guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ print $$$ t $$$ integers — answer $$$ t $$$ give test case order input answer maximum number segment union $$$ n-1 $$$ segment erase give $$$ n $$$ segment,"['brute force', 'data structures', 'dp', 'graphs', 'sortings', 'trees', 'two pointers']",2300.0
1288/B,give two integers $$$ a $$$ $$$ b $$$ calculate number pair $$$ ( a b ) $$$ $$$ 1 \le a \le a $$$ $$$ 1 \le b \le b $$$ equation $$$ a \cdot b + a + b = conc ( a b ) $$$ true ; $$$ conc ( a b ) $$$ concatenation $$$ a $$$ $$$ b $$$ ( example $$$ conc ( 12 23 ) = 1223 $$$ $$$ conc ( 100 11 ) = 10011 $$$ ) $$$ a $$$ $$$ b $$$ contain lead zero first line contain $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case test case contain two integers $$$ a $$$ $$$ b $$$ $$$ ( 1 \le a b \le 1000000000 ) $$$ print one integer — number pair $$$ ( a b ) $$$ $$$ 1 \le a \le a $$$ $$$ 1 \le b \le b $$$ equation $$$ a \cdot b + a + b = conc ( a b ) $$$ true one suitable pair first test case : $$$ a = 1 $$$ $$$ b = 9 $$$ ( $$$ 1 + 9 + 9 = 19 $$$ ),['math'],1100.0
1295/A,a large electronic screen display $$$ 998244353 $$$ decimal digits digits display way different electronic alarm clock : place a digit consist $$$ 7 $$$ segment turn compose different digits follow picture describe display $$$ 10 $$$ decimal digits : see different digits may require different number segment turn example want display $$$ 1 $$$ turn $$$ 2 $$$ segment screen want display $$$ 8 $$$ $$$ 7 $$$ segment place display a digit turn want display a really large integer screen unfortunately screen bug : $$$ n $$$ segment turn simultaneously wonder greatest integer display turn $$$ n $$$ segment program able process $$$ t $$$ different test case first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case input test case follow represent a separate line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — maximum number segment turn correspond testcase guarantee sum $$$ n $$$ test case input exceed $$$ 100000 $$$ test case print greatest integer display turn $$$ n $$$ segment screen note answer may fit standard $$$ 32 $$$ -bit $$$ 64 $$$ -bit integral data type,['greedy'],900.0
1296/B,mishka want buy food nearby shop initially $$$ s $$$ burl card mishka perform follow operation number time ( possibly zero ) : choose positive integer number $$$ 1 \le x \le s $$$ buy food cost exactly $$$ x $$$ burl obtain $$$ \lfloor\frac { x } { 10 } \rfloor $$$ burl a cashback ( word mishka spend $$$ x $$$ burl obtain $$$ \lfloor\frac { x } { 10 } \rfloor $$$ back ) operation $$$ \lfloor\frac { a } { b } \rfloor $$$ mean $$$ a $$$ divide $$$ b $$$ round guarantee always buy food cost $$$ x $$$ possible value $$$ x $$$ task say maximum number burl mishka spend buy food optimally example mishka $$$ <unknown> $$$ burl maximum number burl spend $$$ 21 $$$ firstly spend $$$ x=10 $$$ burl obtain $$$ 1 $$$ burle a cashback $$$ <unknown> $$$ burl spend $$$ x=10 $$$ burl obtain $$$ 1 $$$ burle a cashback spend answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case next $$$ t $$$ line describe test case test case give a separate line consist one integer $$$ s $$$ ( $$$ 1 \le s \le 1000000000 $$$ ) — number burl mishka initially test case print answer — maximum number burl mishka spend buy food optimally,['math'],900.0
1296/E2,a hard version problem actual problems different easy version almost a subtask hard version note constraints output format different give a string $$$ s $$$ consist $$$ n $$$ lowercase latin letter color character minimum number color ( character exactly one color letter color different color i.e choose exactly one color index $$$ s $$$ ) color swap two neighbor character string color different color perform operation arbitrary ( possibly zero ) number time goal make string sort i.e character alphabetical order task find minimum number color color give string color become sort sequence swap note restore color sequence swap first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length $$$ s $$$ second line input contain string $$$ s $$$ consist exactly $$$ n $$$ lowercase latin letter first line print one integer $$$ res $$$ ( $$$ 1 \le res \le n $$$ ) — minimum number color color give string color become sort sequence swap second line print possible color use sort string use sequence swap describe problem statement color array $$$ c $$$ length $$$ n $$$ $$$ 1 \le c_i \le res $$$ $$$ c_i $$$ mean color $$$ i $$$ -th character,"['data structures', 'dp']",2000.0
1299/D,"guy - manuel thomas plan $$$ 144 $$$ trip around world give a simple weight undirected connect graph $$$ n $$$ vertexes $$$ m $$$ edge follow restriction : n't simple cycle ( i. e. a cycle n't pass vertex ) length greater $$$ 3 $$$ pass vertex $$$ 1 $$$ cost a path ( necessarily simple ) graph define xor weight edge path edge count many time path pass trip cost $$$ 0 $$$ n't excite may choose subset edge incident vertex $$$ 1 $$$ remove many subsets , remove nontrivial cycle cost equal $$$ 0 $$$ pass vertex $$$ 1 $$$ result graph ? a cycle call nontrivial pass edge odd number time answer big output modulo $$$ 1000000000 + 7 $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100000 $$$ ) — number vertexes edge graph $$$ i $$$ -th next $$$ m $$$ line contain three integers $$$ a_i $$$ $$$ b_i $$$ $$$ w_i $$$ ( $$$ 1 \le a_i b_i \le n a_i \neq b_i 0 \le w_i < 32 $$$ ) — endpoints $$$ i $$$ -th edge weight 's guarantee n't multiple edge graph connect n't simple cycle length greater $$$ 3 $$$ pass vertex $$$ 1 $$$ output answer modulo $$$ 1000000000 + 7 $$$ picture represent graph examples first example n't nontrivial cycle cost $$$ 0 $$$ either remove keep edge incident vertex $$$ 1 $$$ second example n't remove edge $$$ 1 - 2 $$$ a cycle $$$ 1 - 2 - 4 - 5 - 2 - 1 $$$ cost $$$ 0 $$$ ; also n't remove edge $$$ 1 - 3 $$$ a cycle $$$ 1 - 3 - 2 - 4 - 5 - 2 - 3 - 1 $$$ cost $$$ 0 $$$ valid subset consist edge third example subsets valid except two edge $$$ 1 - 3 $$$ $$$ 1 - 4 $$$ keep","['bitmasks', 'combinatorics', 'dfs and similar', 'dp', 'graphs', 'graphs', 'math', 'trees']",3000.0
1301/B,"dark go attend motarack 's birthday dark decide gift go give motarack array $$$ a $$$ $$$ n $$$ non - negative integers dark create array $$$ 1000 $$$ years ago elements array disappear dark know motarack hat see array two adjacent elements a high absolute difference n't much time want choose integer $$$ k $$$ ( $$$ 0 \leq k \leq 10^ { 9 } $$$ ) replace miss elements array $$$ a $$$ $$$ k $$$ let $$$ m $$$ maximum absolute difference adjacent elements ( i.e maximum value $$$ |a_i - a _ { i+1 } | $$$ $$$ 1 \leq i \leq n - 1 $$$ ) array $$$ a $$$ dark replace miss elements $$$ k $$$ dark choose integer $$$ k $$$ $$$ m $$$ minimize help ? input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 2 \leq n \leq 10^ { 5 } $$$ ) — size array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1 \leq a_i \leq 10 ^ { 9 } $$$ ) $$$ a_i = -1 $$$ $$$ i $$$ -th integer miss guarantee least one integer miss every test case guarantee sum $$$ n $$$ test case exceed $$$ 40 ^ { 5 } $$$ print answer test case follow format : print two integers minimum possible value $$$ m $$$ integer $$$ k $$$ ( $$$ 0 \leq k \leq 10^ { 9 } $$$ ) make maximum absolute difference adjacent elements array $$$ a $$$ equal $$$ m $$$ make sure replace miss elements $$$ k $$$ maximum absolute difference adjacent elements become $$$ m $$$ one possible $$$ k $$$ print first test case replace miss elements $$$ 11 $$$ array become $$$ [ 11 10 11 12 11 ] $$$ absolute difference adjacent elements $$$ 1 $$$ impossible choose a value $$$ k $$$ absolute difference adjacent element $$$ \leq 0 $$$ , answer $$$ 1 $$$ third test case replace miss elements $$$ 6 $$$ array become $$$ [ 6 6 9 6 3 6 ] $$$ , maximum difference adjacent elements $$$ 3 $$$","['binary search', 'greedy']",1500.0
1301/D,"bashar practice national program contest sit much front computer without physical movements eat a lot bashar become much <unknown> bashar go quit program national contest go become actor ( like father ) lose weight order lose weight bashar go run $$$ k $$$ kilometers bashar go run a place look like a grid $$$ n $$$ row $$$ m $$$ columns grid two one - way roads one - kilometer length pair adjacent side cells one road go first cell second one road go second cell first one , exactly $$$ ( 4 n m - 2n - 2 m ) $$$ roads let 's take example $$$ n = 3 $$$ $$$ m = 4 $$$ case $$$ 34 $$$ roads picture case ( arrows describe roads ) : bashar want run rule : bashar ask possible run rule possible tell run give $$$ a $$$ step since bashar ca n't remember many step $$$ a $$$ exceed $$$ 3000 $$$ every step give integer $$$ f $$$ a string move $$$ s $$$ length $$$ 4 $$$ mean repeat move string $$$ s $$$ $$$ f $$$ time perform step order print example step $$$ 2 $$$ rud $$$ 3 $$$ uul move go move rud $$$ + $$$ rud $$$ + $$$ uul $$$ + $$$ uul $$$ + $$$ uul $$$ = $$$ <unknown> help give a correct sequence move total distance run equal $$$ k $$$ kilometers say impossible ? line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \leq n m \leq 500 $$$ $$$ 1 \leq k \leq 10 ^ { 9 } $$$ ) number row number columns grid total distance bashar want run possible way run $$$ k $$$ kilometers print ` ` '' ( without quote ) otherwise print ` ` yes '' ( without quote ) first line answer ` ` yes '' second line print integer $$$ a $$$ ( $$$ 1 \leq a \leq 3000 $$$ ) — number step print $$$ a $$$ line describe step describe a step print integer $$$ f $$$ ( $$$ 1 \leq f \leq 10^ { 9 } $$$ ) a string move $$$ s $$$ length $$$ 4 $$$ every character $$$ s $$$ ' u ' 'd ' ' l ' ' r ' bashar start top - left cell make sure move exactly $$$ k $$$ move without visit road twice without go outside grid finish cell show possible run exactly $$$ k $$$ kilometers possible describe path output constraints move bashar go move first example : ` ` <unknown> '' possible run $$$ 1000000000 $$$ kilometers second example total length roads smaller bashar ca n't run road twice move bashar go move third example : ` ` <unknown> '' move bashar go move fifth example : ` ` <unknown> '' picture run ( roads way mark red number order run ) :","['graphs', 'implementation']",2000.0
1301/F,jaber a superhero a large country describe a grid $$$ n $$$ row $$$ m $$$ columns every cell grid contain a different city jaber give every city country a specific color $$$ 1 $$$ $$$ k $$$ one second go current city cities adjacent side city color current city color jaber $$$ q $$$ missions every mission city row $$$ r_1 $$$ column $$$ c_1 $$$ help someone city row $$$ r_2 $$$ column $$$ c_2 $$$ jaber want help tell minimum possible time go start city finish city every mission first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \leq n m \leq 1000 $$$ $$$ 1 \leq k \leq min ( 40 n \cdot m ) $$$ ) — number row columns color next $$$ n $$$ line contain $$$ m $$$ integers $$$ i $$$ -th line $$$ j $$$ -th integer $$$ a _ { ij } $$$ ( $$$ 1 \leq a _ { ij } \leq k $$$ ) color assign city $$$ i $$$ -th row $$$ j $$$ -th column next line contain one integer $$$ q $$$ ( $$$ 1 \leq q \leq 10^ { 5 } $$$ ) — number missions next $$$ q $$$ line every line contain four integers $$$ r_1 $$$ $$$ c_1 $$$ $$$ r_2 $$$ $$$ c_2 $$$ ( $$$ 1 \leq r_1 r_2 \leq n $$$ $$$ 1 \leq c_1 c_2 \leq m $$$ ) — coordinate start finish cities correspond mission guarantee every color $$$ 1 $$$ $$$ k $$$ least one city color every mission print minimum possible time reach city cell $$$ ( r_2 c_2 ) $$$ start city cell $$$ ( r_1 c_1 ) $$$ first example : second example :,"['dfs and similar', 'graphs', 'implementation', 'shortest paths']",2600.0
1303/G,define sum prefix sum array $$$ [ s_1 s_2 \dots s_k ] $$$ $$$ s_1 + ( s_1 + s_2 ) + ( s_1 + s_2 + s_3 ) + \dots + ( s_1 + s_2 + \dots + s_k ) $$$ give a tree consist $$$ n $$$ vertices vertex $$$ i $$$ integer $$$ a_i $$$ write define value simple path vertex $$$ u $$$ vertex $$$ v $$$ follow : consider vertices appear path $$$ u $$$ $$$ v $$$ write number write vertices order appear path compute sum prefix sum result sequence task calculate maximum value paths tree first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 150000 $$$ ) — number vertices tree $$$ n - 1 $$$ line follow represent edge tree line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) denote edge vertices $$$ u_i $$$ $$$ v_i $$$ guarantee edge form a tree last line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) print one integer — maximum value paths tree best path first example vertex $$$ 3 $$$ vertex $$$ 1 $$$ give sequence $$$ [ 3 3 7 1 ] $$$ sum prefix sum $$$ 36 $$$,"['data structures', 'divide and conquer', 'geometry', 'trees']",2700.0
1304/B,return back problem solve gildong study palindromes learn a palindrome a string reverse example string ` ` pop '' ` ` noon '' ` ` x '' ` ` <unknown> '' palindromes string ` ` moon '' ` ` tv '' ` ` abab '' empty string also a palindrome gildong love concept much want play $$$ n $$$ distinct string equal length $$$ m $$$ want discard string ( possibly none ) reorder remain string concatenation become a palindrome also want palindrome long possible please help find one first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100 $$$ $$$ 1 \le m \le 50 $$$ ) — number string length string next $$$ n $$$ line contain a string length $$$ m $$$ consist lowercase latin letter string distinct first line print length longest palindrome string make second line print palindrome multiple answer print one palindrome empty print empty line n't print line first example ` ` <unknown> '' also a valid answer second example 4 different valid answer include sample output go provide hint others third example empty string valid palindrome string,"['brute force', 'greedy', 'implementation', 'strings']",1100.0
1305/B,"kuroni reach 10 years old a big boy n't like array integers present anymore year want a bracket sequence a birthday present specifically want a bracket sequence complex matter hard try able remove a simple subsequence ! say a string form $$$ n $$$ character ' ( ' ' ) ' simple length $$$ n $$$ even positive first $$$ \frac { n } { 2 } $$$ character ' ( ' last $$$ \frac { n } { 2 } $$$ character ' ) ' example string ( ) ( ( ) ) simple string ) ( ( ) ( ) simple kuroni give a string form character ' ( ' ' ) ' ( give string necessarily simple ) operation consist choose a subsequence character string form a simple string remove character subsequence string note subsequence n't continuous example apply operation string ' ) ( ) ( ( ) ) ) ' choose a subsequence bold character form a simple string ' ( ( ) ) ' delete bold character string get ' ) ) ( ) ' kuroni perform minimum possible number operations string a way operations perform remain string result string empty since give string large kuroni unable figure minimize number operations help instead ? a sequence character $$$ a $$$ a subsequence a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character line input contain a string $$$ s $$$ ( $$$ 1 \le |s| \le 1000 $$$ ) form character ' ( ' ' ) ' $$$ |s| $$$ length $$$ s $$$ first line print integer $$$ k $$$ — minimum number operations apply , print $$$ 2k $$$ line describe operations follow format : operation print a line contain integer $$$ m $$$ — number character subsequence remove , print a line contain $$$ m $$$ integers $$$ 1 \le a_1 < a_2 < \dots < a_m $$$ — indices character remove integers must less equal length current string correspond subsequence must form a simple string multiple valid sequence operations smallest $$$ k $$$ may print first sample string ' ( ( ) ( ( ' operation describe correspond delete bolded subsequence result string ' ( ( ( ' operations perform another valid answer choose indices $$$ 2 $$$ $$$ 3 $$$ result final string second sample already impossible perform operations","['greedy', 'strings', 'two pointers']",1200.0
1305/C,become king codeforces kuroni solve follow problem give $$$ n $$$ number $$$ a_1 a_2 \dots a_n $$$ help kuroni calculate $$$ \prod _ { 1\le i < j\le n } |a_i - a_j| $$$ result big output modulo $$$ m $$$ familiar short notation $$$ \prod _ { 1\le i < j\le n } |a_i - a_j| $$$ equal $$$ |a_1 - <unknown> - <unknown> $$$ $$$ \dots $$$ $$$ <unknown> - <unknown> - <unknown> - <unknown> $$$ $$$ \dots $$$ $$$ <unknown> - a_n| \cdot $$$ $$$ \dots $$$ $$$ \cdot |a _ { n-1 } - a_n| $$$ word product $$$ |a_i - a_j| $$$ $$$ 1\le i < j \le n $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2\le n \le 2\cdot 100000 $$$ $$$ 1\le m \le 1000 $$$ ) — number number modulo second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) output single number — $$$ \prod _ { 1\le i < j\le n } |a_i - a_j| \bmod m $$$ first sample $$$ |8 - 5| = 3 \equiv 3 \bmod 10 $$$ second sample $$$ |1 - 4|\cdot|1 - <unknown> - 5| = 3\cdot 4 = 12 \equiv 0 \bmod 12 $$$ third sample $$$ |1 - 4|\cdot|1 - <unknown> - 9| = 24 \cdot 5 = 120 \equiv 1 \bmod 7 $$$,"['brute force', 'combinatorics', 'math', 'number theory']",1600.0
1307/A,usa construction operation ( <unknown> ) recently order farmer john arrange a row $$$ n $$$ haybale pile farm $$$ i $$$ -th pile contain $$$ a_i $$$ haybales however farmer john leave vacation leave bessie every day bessie naughty cow choose move one haybale pile adjacent pile formally one day choose two indices $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i j \le n $$$ ) $$$ |i - <unknown> $$$ $$$ a_i > 0 $$$ apply $$$ a_i = a_i - 1 $$$ $$$ a_j = a_j + 1 $$$ may also decide anything days lazy bessie want maximize number haybales pile $$$ 1 $$$ ( i.e maximize $$$ a_1 $$$ ) $$$ d $$$ days farmer john return help find maximum number haybales may pile $$$ 1 $$$ act optimally ! input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case next $$$ 2 t $$$ line contain a description test case — two line per test case first line test case contain integers $$$ n $$$ $$$ d $$$ ( $$$ 1 \le n d \le 100 $$$ ) — number haybale pile number days respectively second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 100 $$$ ) — number haybales pile test case output one integer : maximum number haybales may pile $$$ 1 $$$ $$$ d $$$ days bessie act optimally first test case sample one possible way bessie end $$$ 3 $$$ haybales pile $$$ 1 $$$ : second test case sample bessie nothing first day move a haybale pile $$$ 2 $$$ pile $$$ 1 $$$ second day,"['greedy', 'implementation']",800.0
1307/B,"bessie way many friends everyone 's favorite cow ! new friend rabbit try hop play ! specifically want get $$$ ( 0,0 ) $$$ $$$ ( x,0 ) $$$ make multiple hop will hop one point another point 2d plane euclidean distance endpoints a hop one $$$ n $$$ favorite number : $$$ a_1 a_2 \ldots a_n $$$ minimum number hop rabbit need get $$$ ( 0,0 ) $$$ $$$ ( x,0 ) $$$ ? rabbit may land point non - integer coordinate prove rabbit always reach destination recall euclidean distance point $$$ ( x_i y_i ) $$$ $$$ ( x_j y_j ) $$$ $$$ \sqrt { ( x_i - x_j ) ^2 + ( y_i - y_j ) ^2 } $$$ example rabbit favorite number $$$ 1 $$$ $$$ 3 $$$ could hop $$$ ( 0,0 ) $$$ $$$ ( 4,0 ) $$$ two hop show note also exist valid ways hop $$$ ( 4,0 ) $$$ $$$ 2 $$$ hop ( e.g $$$ ( 0,0 ) $$$ $$$ \rightarrow $$$ $$$ ( 2 <unknown> { 5 } ) $$$ $$$ \rightarrow $$$ $$$ ( 4,0 ) $$$ ) word time rabbit choose number $$$ a_i $$$ hop distance equal $$$ a_i $$$ direction want number use multiple time input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next $$$ 2 t $$$ line contain test case — two line per test case first line test case contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 1 \le x \le 1000000000 $$$ ) — number favorite number distance rabbit want travel respectively second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — rabbit 's favorite number guarantee favorite number distinct guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print a single integer — minimum number hop need first test case sample show picture rabbit hop $$$ ( 2 \sqrt { 5 } ) $$$ $$$ ( 4,0 ) $$$ a total two hop hop a distance $$$ 3 $$$ one favorite number second test case sample one way rabbit hop $$$ 3 $$$ time : $$$ ( 0,0 ) $$$ $$$ \rightarrow $$$ $$$ ( 4,0 ) $$$ $$$ \rightarrow $$$ $$$ ( <unknown> ) $$$ $$$ \rightarrow $$$ $$$ ( <unknown> ) $$$ third test case sample rabbit hop $$$ ( 0,0 ) $$$ $$$ ( 5,0 ) $$$ fourth test case sample rabbit hop : $$$ ( 0,0 ) $$$ $$$ \rightarrow $$$ $$$ ( <unknown> { 2 } ) $$$ $$$ \rightarrow $$$ $$$ ( <unknown> ) $$$","['geometry', 'greedy', 'math']",1300.0
1307/C,bessie cow intercept a text farmer john send burger queen ! however bessie sure a secret message hide inside text a string $$$ s $$$ lowercase latin letter consider a string $$$ t $$$ hide string $$$ s $$$ $$$ t $$$ exist a subsequence $$$ s $$$ whose indices form arithmetic progression example string aab hide string aaabb occur indices $$$ 1 $$$ $$$ 3 $$$ $$$ 5 $$$ form arithmetic progression a common difference $$$ 2 $$$ bessie think hide string occur time secret message two occurrences a subsequence $$$ s $$$ distinct set indices different help find number occurrences secret message ! example string aaabb a hide $$$ 3 $$$ time b hide $$$ 2 $$$ time ab hide $$$ 6 $$$ time aa hide $$$ 3 $$$ time bb hide $$$ 1 $$$ time aab hide $$$ 2 $$$ time aaa hide $$$ 1 $$$ time abb hide $$$ 1 $$$ time aaab hide $$$ 1 $$$ time aabb hide $$$ 1 $$$ time aaabb hide $$$ 1 $$$ time number occurrences secret message $$$ 6 $$$ first line contain a string $$$ s $$$ lowercase latin letter ( $$$ 1 \le |s| \le 100000 $$$ ) — text bessie intercept output a single integer — number occurrences secret message first example hide string <unknown> set : second example hide string occur third example hide string letter l,"['brute force', 'dp', 'math', 'strings']",1500.0
1310/C,"vk open second <unknown> st . petersburg ! side office build a huge string $$$ s $$$ write side part office suppose split $$$ m $$$ meet room way meet room wall strictly letter build obviously meet room size 0 small one letter wide meet room name substring $$$ s $$$ write side possible arrangement $$$ m $$$ meet room order a test meet room label meet room lexicographically minimal name deliver label get sort backward lexicographically print $$$ k $$$ th label delivery ? first line give three integer number $$$ n m k $$$ — length string $$$ s $$$ number plan meet room split $$$ s $$$ number interest label ( $$$ 2 \le n \le 1\,000 ; 1 \le m \le 1\,000 ; 1 \le k \le 10^ { 18 } $$$ ) second input line string $$$ s $$$ consist $$$ n $$$ lowercase english letter give $$$ n m k $$$ least $$$ k $$$ ways split $$$ s $$$ $$$ m $$$ substrings output single string – name meet room print $$$ k $$$ -th label delivery first example delivery consist label ` ` aba '' ` ` ab '' ` ` a '' second example delivery consist $$$ <unknown> $$$ label first label ` ` <unknown> '' last one ` ` a ''","['binary search', 'dp', 'strings']",2800.0
1310/F,modern cryptography much tie algorithmic complexity solve several problems one problems a discrete logarithm problem formulate follow : likely modern <unknown> solve problem discrete logarithm a sufficiently large field size example a field <unknown> modulo prime number prim 1024 2048 bits consider safe however calculations large number place a significant load servers perform <unknown> operations reason instead a simple module residue field complex field often use field fast algorithms use a field structure know smaller field use operations properly optimize developer <unknown> trust generally accept methods want invent recently read a strange field — nimbers think 's a great fit purpose field nimbers define a set integers 0 $$$ 2^ { 2^k } - 1 $$$ positive integer $$$ k $$$ bitwise exclusive ( $$$ \oplus $$$ ) operation use addition one ways define multiplication operation ( $$$ \odot $$$ ) follow properties : example : formally algorithm describe follow pseudo - code show operations really form a field moreover make sense game theory operations 's relate problem much help appropriate cache group operations possible calculate product quickly enough important improve speed <unknown> formal definitions well additional properties clarify wikipedia article link author task hope properties list statement enough solution power <unknown> define way formally $$$ a^ { \odot k } = \underbrace { a \odot a \odot \cdots \odot a } _ { <unknown> { time } } $$$ need analyze propose scheme strength pair number $$$ a $$$ $$$ b $$$ need find $$$ x $$$ $$$ a^ { \odot x } = b $$$ determine n't exist first line input single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number pair need find discrete logarithm next $$$ t $$$ line a pair integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b < 2^ { 64 } $$$ ) pair print one integer $$$ x $$$ ( $$$ 0 \le x < 2^ { 64 } $$$ ) $$$ a^ { \odot x } = b $$$ -1 x exist show $$$ x $$$ exist one inside give bound several good value output,"['math', 'number theory']",3400.0
1313/B,nikolay recently start competitive program already qualify finals one prestigious olympiad go $$$ n $$$ participants one nikolay like good olympiad consist two round tire traditional rule participant solve largest number problems win organizers come different rule suppose first round participant a take $$$ x $$$ -th place second round — $$$ y $$$ -th place total score participant a sum $$$ x + y $$$ overall place participant a number participants ( include a ) total score less equal total score a. note participants may end a common overall place also important note first second round two participants tie a common place word every $$$ i $$$ $$$ 1 $$$ $$$ n $$$ exactly one participant take $$$ i $$$ -th place first round exactly one participant take $$$ i $$$ -th place second round right end olympiad nikolay inform get $$$ x $$$ -th place first round $$$ y $$$ -th place second round nikolay n't know result participants yet wonder minimum maximum place take consider favorable <unknown> outcome please help nikolay find answer question first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case solve follow $$$ t $$$ line contain integers $$$ n $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq n \leq 1000000000 $$$ $$$ 1 \le x y \le n $$$ ) — number participants olympiad place nikolay take first round place nikolay take second round print two integers — minimum maximum possible overall place nikolay could take explanation first example : suppose 5 participants a - e. let 's denote nikolay a. favorable result nikolay could look follow : however result olympiad could also look like : first case nikolay would take first place second — third place,"['greedy', 'implementation', 'math']",1700.0
1313/C1,easier version problem version $$$ n \le 1000 $$$ outskirts capital actively build berland company ` ` kernel panic '' manage construction a residential complex skyscrapers new berlskva skyscrapers build along highway know company already buy $$$ n $$$ plot along highway prepare build $$$ n $$$ skyscrapers one skyscraper per plot architects must consider several requirements plan a skyscraper firstly since land plot different properties skyscraper a limit largest number floor secondly accord design code city unacceptable a skyscraper simultaneously higher skyscrapers leave right formally let 's number plot $$$ 1 $$$ $$$ n $$$ skyscraper $$$ i $$$ -th plot $$$ a_i $$$ floor must hold $$$ a_i $$$ $$$ m_i $$$ ( $$$ 1 \le a_i \le m_i $$$ ) also must n't integers $$$ j $$$ $$$ k $$$ $$$ j < i < k $$$ $$$ a_j > a_i < a_k $$$ plot $$$ j $$$ $$$ k $$$ require adjacent $$$ i $$$ company want total number floor build skyscrapers large possible help choose number floor skyscraper optimal way i.e a way requirements fulfil among construction plan choose plan maximum possible total number floor first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000 $$$ ) — number plot second line contain integers $$$ m_1 m_2 \ldots m_n $$$ ( $$$ 1 \leq m_i \leq 1000000000 $$$ ) — limit number floor every possible number floor a skyscraper plot print $$$ n $$$ integers $$$ a_i $$$ — number floor plan skyscraper requirements meet total number floor skyscrapers maximum possible multiple answer possible print first example build skyscrapers highest possible height second test example give maximum height skyscrapers violate design code restriction answer $$$ [ 10 6 6 ] $$$ optimal note answer $$$ [ 6 6 8 ] $$$ also satisfy restrictions optimal,"['brute force', 'data structures', 'dp', 'greedy']",1500.0
1315/C,give a sequence $$$ b_1 b_2 \ldots b_n $$$ find lexicographically minimal permutation $$$ a_1 a_2 \ldots a _ { 2n } $$$ $$$ b_i = \min ( a _ { 2i-1 } a _ { 2i } ) $$$ determine impossible test contain one test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) first line test case consist one integer $$$ n $$$ — number elements sequence $$$ b $$$ ( $$$ 1 \le n \le 100 $$$ ) second line test case consist $$$ n $$$ different integers $$$ b_1 \ldots b_n $$$ — elements sequence $$$ b $$$ ( $$$ 1 \le b_i \le 2n $$$ ) guarantee sum $$$ n $$$ test case n't exceed $$$ 100 $$$ test case appropriate permutation print one number $$$ -1 $$$ otherwise print $$$ 2n $$$ integers $$$ a_1 \ldots a _ { 2n } $$$ — require lexicographically minimal permutation number $$$ 1 $$$ $$$ 2n $$$,['greedy'],1200.0
1316/B,vasya a string $$$ s $$$ length $$$ n $$$ decide make follow modification string : vasya want choose a $$$ k $$$ string obtain above - mentioned modification lexicographically smallest possible among choices $$$ k $$$ among $$$ k $$$ want choose smallest one since busy attend felicity 2020 ask help a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ one follow hold : test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 5000 $$$ ) — length string $$$ s $$$ second line test case contain string $$$ s $$$ $$$ n $$$ lowercase latin letter guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ testcase output two line : first line output lexicographically smallest string $$$ s ' $$$ achievable above - mentioned modification second line output appropriate value $$$ k $$$ ( $$$ 1 \leq k \leq n $$$ ) choose perform modification multiple value $$$ k $$$ give lexicographically smallest string output smallest value $$$ k $$$ among first testcase first sample string modification result sample abab follow : lexicographically smallest string achievable modification abab $$$ k = 1 $$$ $$$ 3 $$$ smallest value $$$ k $$$ need achieve hence $$$ 1 $$$,"['brute force', 'implementation', 'sortings', 'strings']",1400.0
132/C,a lot people associate logo program language turtle graphics case turtle move along straight line accept command ` ` t '' ( ` ` turn around '' ) ` ` f '' ( ` ` move 1 unit forward '' ) give a list command give turtle change exactly n command list ( one command change several time ) far start point turtle move follow command modify list ? first line input contain a string command — original list command string command contain 1 100 character inclusive contain character ` ` t '' ` ` f '' second line contain integer n ( 1 ≤ n ≤ 50 ) — number command change list output maximum distance start point end point turtle 's path end point turtle 's path turtle 's coordinate follow command modify list first example best option change second command ( ` ` t '' ) ` ` f '' — way turtle cover a distance 2 units second example change two command one ways cover maximal distance 6 units change fourth command first last one,['dp'],1800.0
1320/A,"tanya want go a journey across cities berland $$$ n $$$ cities situate along main railroad line berland cities number $$$ 1 $$$ $$$ n $$$ tanya plan journey follow first choose city $$$ c_1 $$$ start journey visit go city $$$ c_2 > c_1 $$$ city $$$ c_3 > c_2 $$$ , choose end journey city $$$ c_k > c _ { k - 1 } $$$ , sequence visit cities $$$ [ c_1 c_2 \dots c_k ] $$$ strictly increase additional constraints sequence cities tanya visit city $$$ i $$$ a beauty value $$$ b_i $$$ associate one city tanya 's journey beauty value imply additional constraints multiple cities sequence pair adjacent cities $$$ c_i $$$ $$$ c _ { i + 1 } $$$ condition $$$ c _ { i + 1 } - c_i = b _ { c _ { i + 1 } } - b _ { c_i } $$$ must hold example $$$ n = 8 $$$ $$$ b = [ 3 4 4 6 6 7 8 9 ] $$$ several three possible ways plan a journey : additional ways plan a journey list tanya want journey beautiful possible beauty value whole journey sum beauty value visit cities help choose optimal plan , maximize beauty value journey ? first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number cities berland second line contain $$$ n $$$ integers $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_n $$$ ( $$$ 1 \le b_i \le 400000 $$$ ) $$$ b_i $$$ beauty value $$$ i $$$ -th city print one integer — maximum beauty a journey tanya choose optimal journey plan first example $$$ c = [ 2 4 5 ] $$$ optimal journey plan second example $$$ c = [ 1 ] $$$ optimal journey plan third example $$$ c = [ 3 6 ] $$$","['data structures', 'dp', 'greedy', 'math', 'sortings']",1400.0
1321/A,"polycarp prepare first program contest robots $$$ n $$$ problems a lot robots go participate robot solve problem $$$ i $$$ get $$$ p_i $$$ point score robot competition calculate sum $$$ p_i $$$ problems $$$ i $$$ solve problem $$$ p_i $$$ integer less $$$ 1 $$$ two corporations specialize problem - solving robot manufacture ` ` robo - coder inc . '' ` ` bionicsolver industries '' go register two robots ( one corporation ) <unknown> well polycarp know advantage flaw robots produce company , problem know precisely whether robot solve competition know try predict result — manipulate reason ( absolutely involve bribe ) polycarp want ` ` robo - coder inc . '' robot outperform ` ` bionicsolver industries '' robot competition polycarp want set value $$$ p_i $$$ a way ` ` robo - coder inc . '' robot get strictly point ` ` bionicsolver industries '' robot however value $$$ p_i $$$ large may look suspicious — polycarp want minimize maximum value $$$ p_i $$$ problems help polycarp determine minimum possible upper bind number point give solve problems ? first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number problems second line contain $$$ n $$$ integers $$$ r_1 $$$ $$$ r_2 $$$ ... $$$ r_n $$$ ( $$$ 0 \le r_i \le 1 $$$ ) $$$ r_i = 1 $$$ mean ` ` robo - coder inc . '' robot solve $$$ i $$$ -th problem $$$ r_i = 0 $$$ mean wo n't solve $$$ i $$$ -th problem third line contain $$$ n $$$ integers $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_n $$$ ( $$$ 0 \le b_i \le 1 $$$ ) $$$ b_i = 1 $$$ mean ` ` bionicsolver industries '' robot solve $$$ i $$$ -th problem $$$ b_i = 0 $$$ mean wo n't solve $$$ i $$$ -th problem ` ` robo - coder inc . '' robot outperform ` ` bionicsolver industries '' robot mean print one integer $$$ -1 $$$ otherwise print minimum possible value $$$ \max \limits _ { i = 1 } ^ { n } p_i $$$ value $$$ p_i $$$ set a way ` ` robo - coder inc . '' robot get strictly point ` ` bionicsolver industries '' robot first example one valid score assignments $$$ p = [ 3 1 3 1 1 ] $$$ ` ` robo - coder '' get $$$ 7 $$$ point ` ` bionicsolver '' — $$$ 6 $$$ point second example robots get $$$ 0 $$$ point score distribution matter third example robots solve problems point equal",['greedy'],900.0
1321/C,"give a string $$$ s $$$ consist lowercase latin letter let length $$$ s $$$ $$$ |s| $$$ may perform several operations string one operation choose index $$$ i $$$ remove $$$ i $$$ -th character $$$ s $$$ ( $$$ s_i $$$ ) least one adjacent character previous letter latin alphabet $$$ s_i $$$ example previous letter b a previous letter s r letter a previous letter note removal length string decrease one , index $$$ i $$$ satisfy condition $$$ 1 \le i \le |s| $$$ operation character $$$ s_i $$$ adjacent character $$$ s _ { i-1 } $$$ $$$ s _ { i+1 } $$$ first last character $$$ s $$$ one adjacent character ( unless $$$ |s| = 1 $$$ ) consider follow example let $$$ s= $$$ <unknown> task find maximum possible number character remove choose sequence operations optimally first line input contain one integer $$$ |s| $$$ ( $$$ 1 \le |s| \le 100 $$$ ) — length $$$ s $$$ second line input contain one string $$$ s $$$ consist $$$ |s| $$$ lowercase latin letter print one integer — maximum possible number character remove choose sequence move optimally first example describe problem statement note sequence move provide statement show maximum possible answer test $$$ 4 $$$ second example remove one character $$$ s $$$ possible answer follow","['brute force', 'greedy', 'strings']",1600.0
1324/B,give array $$$ a $$$ consist $$$ n $$$ integers task determine $$$ a $$$ subsequence length least $$$ 3 $$$ a palindrome recall array $$$ b $$$ call a subsequence array $$$ a $$$ $$$ b $$$ obtain remove ( possibly zero ) elements $$$ a $$$ ( necessarily consecutive ) without change order remain elements example $$$ [ 2 ] $$$ $$$ [ 1 2 1 3 ] $$$ $$$ [ 2 3 ] $$$ subsequences $$$ [ 1 2 1 3 ] $$$ $$$ [ 1 1 2 ] $$$ $$$ [ 4 ] $$$ also recall a palindrome array read backward forward word array $$$ a $$$ length $$$ n $$$ palindrome $$$ a_i = a _ { n - i - 1 } $$$ $$$ i $$$ $$$ 1 $$$ $$$ n $$$ example array $$$ [ 1234 ] $$$ $$$ [ 1 2 1 ] $$$ $$$ [ 1 3 2 2 3 1 ] $$$ $$$ [ 10 100 10 ] $$$ palindromes array $$$ [ 1 2 ] $$$ $$$ [ 1 2 3 1 ] $$$ answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case next $$$ 2 t $$$ line describe test case first line test case contain one integer $$$ n $$$ ( $$$ 3 \le n \le 5000 $$$ ) — length $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ ( $$$ \sum n \le 5000 $$$ ) test case print answer — ` ` yes '' ( without quote ) $$$ a $$$ subsequence length least $$$ 3 $$$ a palindrome ` ` '' otherwise first test case example array $$$ a $$$ a subsequence $$$ [ 1 2 1 ] $$$ a palindrome second test case example array $$$ a $$$ two subsequences length $$$ 3 $$$ palindromes : $$$ [ 2 3 2 ] $$$ $$$ [ 2 2 2 ] $$$ third test case example array $$$ a $$$ subsequences length least $$$ 3 $$$ palindromes fourth test case example array $$$ a $$$ one subsequence length $$$ 4 $$$ a palindrome : $$$ [ 1 2 2 1 ] $$$ ( two subsequences length $$$ 3 $$$ palindromes : $$$ [ 1 2 1 ] $$$ ) fifth test case example array $$$ a $$$ subsequences length least $$$ 3 $$$ palindromes,"['brute force', 'strings']",1100.0
1325/B,"ehab array $$$ a $$$ length $$$ n $$$ enough free time make a new array consist $$$ n $$$ copy old array write back - to - back length new array 's longest increase subsequence ? a sequence $$$ a $$$ a subsequence array $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) elements longest increase subsequence array longest subsequence elements order strictly increase order first line contain integer $$$ t $$$ — number test case need solve description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number elements array $$$ a $$$ second line contain $$$ n $$$ space - separated integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a _ { n } $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements array $$$ a $$$ sum $$$ n $$$ across test case n't exceed $$$ 100000 $$$ testcase output length longest increase subsequence $$$ a $$$ concatenate $$$ n $$$ time first sample new array $$$ [ 3,2 \textbf { 1 } , 3 \textbf { 2 } , 1 \textbf { 3 } , 2,1 ] $$$ longest increase subsequence mark bold second sample longest increase subsequence $$$ [ <unknown> ] $$$","['greedy', 'implementation']",800.0
1326/B,"alicia array $$$ a_1 a_2 \ldots a_n $$$ non - negative integers $$$ 1 \leq i \leq n $$$ find a non - negative integer $$$ x_i = max ( 0 a_1 \ldots a _ { i-1 } ) $$$ note $$$ i=1 $$$ $$$ x_i = 0 $$$ example alicia array $$$ a = \ { 0 1 2 0 3\ } $$$ $$$ x = \ { 0 0 1 2 2\ } $$$ , calculate array $$$ b_1 b_2 \ldots b_n $$$ : $$$ b_i = a_i - x_i $$$ example alicia array $$$ a = \ { 0 1 2 0 3\ } $$$ $$$ b = \ { 0 - 0 1 - 0 2 - 1 0 - 2 3 - 2\ } = \ { 0 1 1 -2 1\ } $$$ alicia give value $$$ b_1 b_2 \ldots b_n $$$ ask restore value $$$ a_1 a_2 \ldots a_n $$$ help solve problem ? first line contain one integer $$$ n $$$ ( $$$ 3 \leq n \leq 200\,000 $$$ ) – number elements alicia 's array next line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ -1000000000 \leq b_i \leq 1000000000 $$$ ) guarantee give array $$$ b $$$ a solution $$$ a_1 a_2 \ldots a_n $$$ elements follow true : $$$ 0 \leq a_i \leq 1000000000 $$$ print $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) calculate $$$ x $$$ accord statement $$$ b_1 $$$ equal $$$ a_1 - x_1 $$$ $$$ b_2 $$$ equal $$$ a_2 - x_2 $$$ ... $$$ b_n $$$ equal $$$ a_n - x_n $$$ guarantee exist least one solution give test show solution unique first test describe problem statement second test alicia array $$$ a = \ { 1000 1000000000 0\ } $$$ $$$ x = \ { 0 1000 1000000000\ } $$$ $$$ b = \ { 1000 - 0 1000000000 - 1000 0 - 1000000000\ } = \ { 1000 <unknown> <unknown> } $$$","['implementation', 'math']",900.0
1327/E,write integers $$$ 0 $$$ $$$ 10^n - 1 $$$ pad lead zero lengths exactly $$$ n $$$ example $$$ n = 3 $$$ write 000 001 ... 998 999 . a block integer $$$ x $$$ a consecutive segment equal digits extend leave right example integer $$$ <unknown> $$$ three block length $$$ 1 $$$ one block length $$$ 2 $$$ two block length $$$ 3 $$$ integers $$$ i $$$ $$$ 1 $$$ $$$ n $$$ count number block length $$$ i $$$ among write integers since integers may large print modulo $$$ 998244353 $$$ line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) line print $$$ n $$$ integers $$$ i $$$ -th integer equal number block length $$$ i $$$ since integers may large print modulo $$$ 998244353 $$$,"['combinatorics', 'dp', 'math']",1800.0
1327/F,give three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ $$$ m $$$ condition $$$ ( l_1 r_1 x_1 ) ( l_2 r_2 x_2 ) \dots ( l_m r_m x_m ) $$$ calculate number distinct array $$$ a $$$ consist $$$ n $$$ integers : two array $$$ a $$$ $$$ b $$$ consider different exist a position $$$ i $$$ $$$ a_i \neq b_i $$$ number pretty large print modulo $$$ 998244353 $$$ first line contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \le n \le 500000 $$$ $$$ 1 \le k \le 30 $$$ $$$ 0 \le m \le 500000 $$$ ) — length array $$$ a $$$ value number $$$ a $$$ smaller $$$ 2^k $$$ number condition respectively next $$$ m $$$ line contain description a condition $$$ l_i $$$ $$$ r_i $$$ $$$ x_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ $$$ 0 \le x_i < 2^k $$$ ) — border condition segment require bitwise value print a single integer — number distinct array $$$ a $$$ satisfy condition modulo $$$ 998244353 $$$ recall a bitwise operation first example answer follow array : $$$ [ 3 3 7 6 ] $$$ $$$ [ 3 7 7 6 ] $$$ $$$ [ 7 3 7 6 ] $$$,"['bitmasks', 'combinatorics', 'data structures', 'dp', 'two pointers']",2500.0
1327/G,give a string $$$ s $$$ array string $$$ [ t_1 t_2 \dots t_k ] $$$ string $$$ t_i $$$ consist lowercase latin letter a n ; $$$ s $$$ consist lowercase latin letter a n $$$ 14 $$$ question mark string $$$ t_i $$$ cost $$$ c_i $$$ — integer number value string $$$ t $$$ calculate $$$ \sum\limits _ { i = 1 } ^ { k } f ( t t_i ) \cdot c_i $$$ $$$ f ( t t_i ) $$$ number occurences string $$$ t_i $$$ $$$ t $$$ a substring example $$$ f ( \text { <unknown> } \text { aa } ) = 4 $$$ replace question mark $$$ s $$$ pairwise distinct lowercase latin letter a n value $$$ s $$$ maximum possible first line contain one integer $$$ k $$$ ( $$$ 1 \le k \le 1000 $$$ ) — number string array $$$ [ t_1 t_2 \dots t_k ] $$$ $$$ k $$$ line follow contain one string $$$ t_i $$$ ( consist lowercase latin letter a n ) one integer $$$ c_i $$$ ( $$$ 1 \le |t_i| \le 1000 $$$ $$$ -1000000 \le c_i \le 1000000 $$$ ) sum lengths string $$$ t_i $$$ exceed $$$ 1000 $$$ last line contain one string $$$ s $$$ ( $$$ 1 \le |s| \le 400000 $$$ ) consist lowercase latin letter a n question mark number question mark $$$ s $$$ greater $$$ 14 $$$ print one integer — maximum value $$$ s $$$ replace question mark pairwise distinct lowercase latin letter a n,"['bitmasks', 'dp']",2800.0
1328/B,give integer $$$ n $$$ ( $$$ n > 2 $$$ ) let 's write string length $$$ n $$$ contain $$$ n-2 $$$ letter ' a ' two letter ' b ' lexicographical ( alphabetical ) order recall string $$$ s $$$ length $$$ n $$$ lexicographically less string $$$ t $$$ length $$$ n $$$ exist $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) $$$ s_i < t_i $$$ $$$ j $$$ ( $$$ 1 \le j < i $$$ ) $$$ s_j = t_j $$$ lexicographic comparison string implement operator < modern program languages example $$$ n=5 $$$ string ( order matter ) : easy show a list string contain exactly $$$ \frac { n \cdot ( n-1 ) } { 2 } $$$ string give $$$ n $$$ ( $$$ n > 2 $$$ ) $$$ k $$$ ( $$$ 1 \le k \le \frac { n \cdot ( n-1 ) } { 2 } $$$ ) print $$$ k $$$ -th string list input contain one test case first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test $$$ t $$$ test case follow test case write separate line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 3 \le n \le 100000 1 \le k \le \min ( 2\cdot1000000000 \frac { n \cdot ( n-1 ) } { 2 } ) $$$ sum value $$$ n $$$ test case test n't exceed $$$ 100000 $$$ test case print $$$ k $$$ -th string list describe string length $$$ n $$$ string list sort lexicographically ( alphabetically ),"['binary search', 'brute force', 'combinatorics', 'implementation', 'math']",1300.0
1328/D,round carousel consist $$$ n $$$ figure animals figure number $$$ 1 $$$ $$$ n $$$ order carousel move thus $$$ n $$$ -th figure figure number $$$ 1 $$$ follow figure type — type animal correspond figure ( horse tiger ) type animal $$$ i $$$ -th figure equal $$$ t_i $$$ want color figure one color think 's bore carousel contain two different figure ( distinct type animals ) go one right another color color task color figure a way number distinct color use minimum possible figure different type go one right another color color use exactly $$$ k $$$ distinct color color figure denote integers $$$ 1 $$$ $$$ k $$$ input contain one test case first line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 10000 $$$ ) — number test case test $$$ q $$$ test case follow one test case give two line first line test case contain one integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) — number figure carousel figure number $$$ 1 $$$ $$$ n $$$ order carousel move assume $$$ n $$$ -th figure figure $$$ 1 $$$ go second line test case contain $$$ n $$$ integers $$$ t_1 t_2 \dots t_n $$$ ( $$$ 1 \le t_i \le 200000 $$$ ) $$$ t_i $$$ type animal $$$ i $$$ -th figure sum $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ print $$$ q $$$ answer test case print two line first line print one integer $$$ k $$$ — minimum possible number distinct color figure second line print $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \le c_i \le k $$$ ) $$$ c_i $$$ color $$$ i $$$ -th figure several answer print,"['dp', 'graphs', 'greedy', 'math']",1800.0
1332/B,a positive integer call composite represent a product two positive integers greater $$$ 1 $$$ example follow number composite : $$$ 6 $$$ $$$ 4 $$$ $$$ 120 $$$ $$$ 27 $$$ follow number n't : $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 17 $$$ $$$ 97 $$$ alice give a sequence $$$ n $$$ composite number $$$ a_1 a_2 \ldots a_n $$$ want choose integer $$$ m \le 11 $$$ color element one $$$ m $$$ color $$$ 1 $$$ $$$ m $$$ : note equal elements color different color — choose one $$$ m $$$ color indices $$$ 1 $$$ $$$ n $$$ alice show already $$$ a_i \le 1000 $$$ always solve task choose $$$ m \le 11 $$$ help alice find require color note n't minimize maximize number color find solution $$$ m $$$ $$$ 1 $$$ $$$ 11 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case descriptions test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — amount number a sequence $$$ a $$$ second line test case contain $$$ n $$$ composite integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 4 \le a_i \le 1000 $$$ ) guarantee sum $$$ n $$$ test case n't exceed $$$ 10000 $$$ test case print $$$ 2 $$$ line first line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 11 $$$ ) — number use color consider color number $$$ 1 $$$ $$$ m $$$ second line contain color satisfy condition print $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \le c_i \le m $$$ ) $$$ c_i $$$ color $$$ i $$$ -th element multiple solutions print note n't minimize maximize number color find solution $$$ m $$$ $$$ 1 $$$ $$$ 11 $$$ remember color $$$ 1 $$$ $$$ m $$$ use least two elements color coprime ( i.e gcd greater $$$ 1 $$$ ) first test case $$$ \gcd ( <unknown> ) = 2 $$$ $$$ \gcd ( <unknown> ) =3 $$$ $$$ \gcd ( <unknown> ) = 5 $$$ therefore 's valid color elements color note color satisfy alice 's requirement test case second test case one element color color definitely satisfy alice 's requirement,"['brute force', 'greedy', 'math', 'number theory']",1400.0
1333/C,eugene like work array today need help solve one challenge task array $$$ c $$$ a subarray array $$$ b $$$ $$$ c $$$ obtain $$$ b $$$ deletion several ( possibly zero ) elements begin several ( possibly zero ) elements end let 's call a nonempty array good every nonempty subarray array sum elements subarray nonzero example array $$$ [ -1 2 -3 ] $$$ good array $$$ [ -1 ] $$$ $$$ [ -1 2 ] $$$ $$$ [ -1 2 -3 ] $$$ $$$ [ 2 ] $$$ $$$ [ 2 -3 ] $$$ $$$ [ -3 ] $$$ nonzero sum elements however array $$$ [ -1 2 -1 -3 ] $$$ n't good subarray $$$ [ -1 2 -1 ] $$$ sum elements equal $$$ 0 $$$ help eugene calculate number nonempty good subarrays a give array $$$ a $$$ first line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 2 \times 100000 $$$ ) — length array $$$ a $$$ second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) — elements $$$ a $$$ output a single integer — number good subarrays $$$ a $$$ first sample follow subarrays good : $$$ [ 1 ] $$$ $$$ [ 1 2 ] $$$ $$$ [ 2 ] $$$ $$$ [ 2 -3 ] $$$ $$$ [ -3 ] $$$ however subarray $$$ [ 1 2 -3 ] $$$ n't good subarray $$$ [ 1 2 -3 ] $$$ sum elements equal $$$ 0 $$$ second sample three subarrays size 1 good subarrays time subarray $$$ [ 41 -41 41 ] $$$ n't good subarray $$$ [ 41 -41 ] $$$ sum elements equal $$$ 0 $$$,"['binary search', 'data structures', 'implementation', 'two pointers']",1700.0
1333/D,$$$ n $$$ children study school № 41 well - known good mathematicians a break arrange a challenge children arrange a row turn head either leave right children follow : one second several pair neighbor children look simultaneously turn head opposite direction instance one look right neighbor turn leave vice versa second child moreover every second least one pair neighbor children perform action go finish pair neighbor children look give number $$$ n $$$ initial arrangement children number $$$ k $$$ find a way children act want finish process exactly $$$ k $$$ second formally $$$ k $$$ move need output number children turn leave move instance configuration show $$$ k = 2 $$$ children follow step : guarantee solution exist take $$$ n^2 $$$ ` ` headturns '' first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 3000 $$$ $$$ 1 \le k \le 3000000 $$$ ) — number children require number move next line contain a string length $$$ n $$$ consist character l r l mean child look leave r mean child look right solution print a single line number $$$ -1 $$$ otherwise output $$$ k $$$ line line start a number $$$ n_i $$$ ( $$$ 1\le n_i \le \frac { n } { 2 } $$$ ) — number pair children turn move print $$$ n_i $$$ distinct integers — number children turn leave move perform ` ` headturns '' ca n't a pair two neighbor children look many solutions print first sample contain a pair children look one move finish process second sample children ca n't make move a result ca n't end $$$ k > 0 $$$ move third configuration describe statement,"['brute force', 'graphs', 'greedy', 'implementation', 'sortings']",2100.0
1333/F,"kate a set $$$ s $$$ $$$ n $$$ integers $$$ \ { 1 \dots n\ } $$$ think imperfection a subset $$$ m \subseteq s $$$ equal maximum $$$ gcd ( a b ) $$$ pair $$$ ( a b ) $$$ $$$ a $$$ $$$ b $$$ $$$ m $$$ $$$ a \neq b $$$ kate a neat girl $$$ k \in \ { 2 \dots n\ } $$$ want find a subset smallest imperfection among subsets $$$ s $$$ size $$$ k $$$ one subset smallest imperfection size n't need worry kate want find subsets need help find smallest possible imperfection size $$$ k $$$ name $$$ i_k $$$ please help kate find $$$ i_2 $$$ $$$ i_3 $$$ ... $$$ i_n $$$ first line input consist one integer $$$ n $$$ ( $$$ 2\le n \le 500000 $$$ ) — size give set $$$ s $$$ output contain one line include $$$ n - 1 $$$ integers : $$$ i_2 $$$ $$$ i_3 $$$ ... $$$ i_n $$$ first sample : answer 1 $$$ gcd ( 1 2 ) = 1 $$$ second sample : subsets $$$ s $$$ size $$$ 2 3 $$$ imperfection equal 1 . example $$$ \ { 2,3\ } $$$ $$$ \ { 1 2 3\ } $$$","['greedy', 'implementation', 'math', 'number theory', 'sortings', 'two pointers']",2200.0
1336/C,"kaavi mysterious fortune teller deeply believe one 's fate inevitable unavoidable course make live predict others ' future divination kaavi believe magic spell provide great power see future kaavi a string $$$ t $$$ length $$$ m $$$ string prefix $$$ t $$$ magic spell kaavi also a string $$$ s $$$ length $$$ n $$$ empty string $$$ a $$$ divination kaavi need perform a sequence operations two different operations : kaavi perform $$$ n $$$ operations finish divination want know number different operation sequence make $$$ a $$$ a magic spell ( i.e prefix $$$ t $$$ ) assistant help ? answer might huge kaavi need know answer modulo $$$ 998\,244\,353 $$$ two operation sequence consider different different length exist $$$ i $$$ $$$ i $$$ -th operation different a substring a contiguous sequence character within a string a prefix a string $$$ s $$$ a substring $$$ s $$$ occur begin $$$ s $$$ first line contain a string $$$ s $$$ length $$$ n $$$ ( $$$ 1 \leq n \leq 3000 $$$ ) second line contain a string $$$ t $$$ length $$$ m $$$ ( $$$ 1 \leq m \leq n $$$ ) string contain lowercase latin letter output contain one integer — answer modulo $$$ 998\,244\,353 $$$ first test : red ones magic spell first operation kaavi either add first character ` ` a '' front back $$$ a $$$ although result consider different operations answer $$$ <unknown> $$$","['dp', 'strings']",2200.0
1338/A,array $$$ a $$$ length $$$ n $$$ every positive integer $$$ x $$$ go perform follow operation $$$ x $$$ -th second : make $$$ a $$$ nondecreasing fast possible find smallest number $$$ t $$$ make array nondecreasing $$$ t $$$ second array $$$ a $$$ nondecreasing $$$ a _ { 1 } \le a _ { 2 } \le \ldots \le a _ { n } $$$ answer $$$ t $$$ independent test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10^ { 4 } $$$ ) — number test case first line test case contain single integer $$$ n $$$ ( $$$ 1 \le n \le 10^ { 5 } $$$ ) — length array $$$ a $$$ guarantee sum value $$$ n $$$ test case input exceed $$$ 10^ { 5 } $$$ second line test case contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ ( $$$ -10^ { 9 } \le a _ { i } \le 10^ { 9 } $$$ ) test case print minimum number second make $$$ a $$$ nondecreasing first test case select indices $$$ 3 4 $$$ $$$ 1 $$$ -st second $$$ 4 $$$ $$$ 2 $$$ -nd second $$$ a $$$ become $$$ [ 1 7 7 8 ] $$$ possible ways make $$$ a $$$ nondecreasing $$$ 2 $$$ second ca n't faster second test case $$$ a $$$ already nondecreasing answer $$$ 0 $$$ third test case nothing first $$$ 2 $$$ second select index $$$ 2 $$$ $$$ 3 $$$ -rd second $$$ a $$$ become $$$ [ 0 0 ] $$$,"['greedy', 'math']",1500.0
1338/B,unweighted tree $$$ n $$$ vertices assign a positive weight edge follow condition would hold : note put large positive integers ( like $$$ 10^ { ( 10^ { 10 } ) } $$$ ) 's guarantee assignment always exist give constraints let 's define $$$ f $$$ number distinct weight assignment example assignment invalid bitwise xor edge weight vertex $$$ 1 $$$ vertex $$$ 6 $$$ ( $$$ 3 4 5 4 $$$ ) $$$ 0 $$$ minimum maximum possible value $$$ f $$$ give tree ? find print first line contain integer $$$ n $$$ ( $$$ 3 \le n \le 10^ { 5 } $$$ ) — number vertices give tree $$$ i $$$ -th next $$$ n-1 $$$ line contain two integers $$$ a _ { i } $$$ $$$ b _ { i } $$$ ( $$$ 1 \le a _ { i } \lt b _ { i } \le n $$$ ) — mean edge $$$ a _ { i } $$$ $$$ b _ { i } $$$ guarantee give graph form tree $$$ n $$$ vertices print two integers — minimum maximum possible value $$$ f $$$ make valid assignment give tree note 's always possible make assignment give constraints first example possible assignments minimum maximum describe picture course multiple possible assignments minimum maximum second example possible assignments minimum maximum describe picture $$$ f $$$ value valid assignment tree always $$$ 3 $$$ third example possible assignments minimum maximum describe picture course multiple possible assignments minimum maximum,"['bitmasks', 'dfs and similar', 'greedy', 'math', 'trees']",1800.0
1342/F,"give array $$$ a $$$ consist $$$ n $$$ elements may apply several operations ( possibly zero ) operation choose two indices $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i j \le n $$$ ; $$$ i \ne j $$$ ) increase $$$ a_j $$$ $$$ a_i $$$ remove $$$ i $$$ -th element array ( indices elements right decrease $$$ 1 $$$ $$$ n $$$ also decrease $$$ 1 $$$ ) goal make array $$$ a $$$ strictly ascend , condition $$$ a_1 < a_2 < \dots < a_n $$$ hold ( $$$ n $$$ result size array ) calculate minimum number action require make array strictly ascend first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist two line first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 15 $$$ ) — number elements initial array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) guarantee : test case print answer follow : first line print $$$ k $$$ — minimum number operations perform print $$$ k $$$ line contain two indices $$$ i $$$ $$$ j $$$ correspond operation note numeration elements array change remove elements multiple optimal sequence operations print one first test case sequence operations change $$$ a $$$ follow : $$$ [ 2 1 3 5 1 2 4 5 ] \rightarrow [ 2 1 3 5 1 4 7 ] \rightarrow [ 1 3 5 1 6 7 ] \rightarrow [ 2 3 5 6 7 ] $$$","['bitmasks', 'brute force', 'dp']",3000.0
1343/D,give array $$$ a $$$ consist $$$ n $$$ integers ( guarantee $$$ n $$$ even i.e divisible $$$ 2 $$$ ) $$$ a_i $$$ exceed integer $$$ k $$$ task replace minimum number elements ( replacement follow operation : choose index $$$ i $$$ $$$ 1 $$$ $$$ n $$$ replace $$$ a_i $$$ integer range $$$ [ 1 ; k ] $$$ ) satisfy follow condition : answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 2 \cdot 100000 1 \le k \le 200000 $$$ ) — length $$$ a $$$ maximum possible value $$$ a_i $$$ correspondingly <unknown> $$$ n $$$ even ( i.e divisible $$$ 2 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le k $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ guarantee sum $$$ n $$$ ( well sum $$$ k $$$ ) test case exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ $$$ \sum k \le 200000 $$$ ) test case print answer — minimum number elements replace $$$ a $$$ satisfy condition problem statement,"['brute force', 'data structures', 'greedy', 'two pointers']",1700.0
1346/A,<unknown> long since last color revolution ? 5 years ? ! 's totally time make a new one ! general idea follow division $$$ 1 $$$ $$$ n_1 $$$ participants division $$$ 2 $$$ $$$ n_2 $$$ exactly $$$ k $$$ time bigger division $$$ 1 $$$ ( $$$ n_2 = k \cdot n_1 $$$ ) division $$$ 3 $$$ $$$ n_3 = k \cdot n_2 $$$ participants finally division $$$ 4 $$$ $$$ n_4 = k \cdot n_3 $$$ participants $$$ n $$$ participants codeforces total $$$ n_1 + n_2 + n_3 + n_4 $$$ exactly equal $$$ n $$$ know value $$$ n $$$ $$$ k $$$ also know $$$ n $$$ $$$ k $$$ choose a way exist value $$$ n_1 n_2 n_3 $$$ $$$ n_4 $$$ condition satisfy number participants division ( $$$ n_1 n_2 n_3 $$$ $$$ n_4 $$$ ) revolution ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases next $$$ t $$$ line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 4 \le n \le 1000000000 $$$ ; $$$ 1 \le k \le 500 $$$ ) — total number participants codeforces size <unknown> correspond testcase testcase $$$ n $$$ $$$ k $$$ choose a way answer exist testcase print four integers $$$ n_1 n_2 n_3 $$$ $$$ n_4 $$$ $$$ n_2 = k \cdot n_1 $$$ $$$ n_3 = k \cdot n_2 $$$ $$$ n_4 = k \cdot n_3 $$$ $$$ n_1 + n_2 + n_3 + n_4 = n $$$,['math'],1000.0
1346/B,"berland state university ( bsu ) conduct a program boot camp boot camp last $$$ n $$$ days bsu lecturers plan give number lecture days days boot camp already plan excursion days lecture hold days make sure participants n't get tire learn program number lecture day exceed $$$ k_1 $$$ number lecture pair consecutive days exceed $$$ k_2 $$$ calculate maximum number lecture conduct boot camp ? formally find maximum integer $$$ m $$$ possible choose $$$ n $$$ non - negative integers $$$ c_1 $$$ $$$ c_2 $$$ ... $$$ c_n $$$ ( $$$ c_i $$$ number lecture hold day $$$ i $$$ ) : note might non - excursion days without lecture ( i. e. possible $$$ c_i = 0 $$$ even $$$ i $$$ excursion day ) first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 50 $$$ ) — number testcases testcases follow consist two line first line contain three integers $$$ n $$$ $$$ k_1 $$$ $$$ k_2 $$$ ( $$$ 1 \le n \le 5000 $$$ ; $$$ 1 \le k_1 \le k_2 \le 200\,000 $$$ ) second line contain one string $$$ s $$$ consist exactly $$$ n $$$ character character either 0 1 . $$$ s_i = 0 $$$ day $$$ i $$$ excursion day ( lecture day ) ; $$$ s_i = 1 $$$ day $$$ i $$$ excursion day test case print one integer — maximum possible value $$$ m $$$ ( number lecture conduct )",['greedy'],1400.0
1348/E,"phoenix pick berry backyard $$$ n $$$ shrubs shrub $$$ a_i $$$ red berry $$$ b_i $$$ blue berry basket contain $$$ k $$$ berry , phoenix decide basket may contain berry shrub berry color ( red blue ) word berry a basket must shrub or / and color example two shrubs $$$ 5 $$$ red $$$ 2 $$$ blue berry first shrub $$$ 2 $$$ red $$$ 1 $$$ blue berry second shrub phoenix fill $$$ 2 $$$ baskets capacity $$$ 4 $$$ completely : help phoenix determine maximum number baskets fill completely ! first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1\le n k \le 500 $$$ ) — number shrubs basket capacity respectively $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 0 \le a_i b_i \le 1000000000 $$$ ) — number red blue berry $$$ i $$$ -th shrub respectively output one integer — maximum number baskets phoenix fill completely first example describe second example phoenix fill one basket fully use berry first ( ) shrub third example phoenix fill basket completely less $$$ 5 $$$ berry shrub less $$$ 5 $$$ total red berry less $$$ 5 $$$ total blue berry fourth example phoenix put red berry baskets leave extra blue berry behind","['brute force', 'dp', 'greedy', 'math']",2400.0
1349/D,"slime $$$ n $$$ friends a party slime design a game friends play begin game $$$ i $$$ -th player $$$ a_i $$$ biscuits second slime choose a biscuit randomly uniformly among $$$ a_1 + a_2 + \ldots + a_n $$$ biscuits owner biscuit give a random uniform player among $$$ n-1 $$$ players except game stop one person biscuits host party slime want know expect value time game last hold next activity time convenience answer represent a rational number $$$ \frac { p } { q } $$$ coprime $$$ p $$$ $$$ q $$$ need find value $$$ ( p \cdot q^ { -1 } ) \mod 998\,244\,353 $$$ prove $$$ <unknown> 998\,244\,353 \neq 0 $$$ first line contain one integer $$$ n\ ( 2\le n\le 100\,000 ) $$$ : number people play game second line contain $$$ n $$$ non - negative integers $$$ a_1 a_2 \dots a_n\ ( 1\le <unknown> 300\,000 ) $$$ $$$ a_i $$$ represent number biscuits $$$ i $$$ -th person begin print one integer : expect value time game last modulo $$$ 998\,244\,353 $$$ first example first second probability player $$$ 1 $$$ give player $$$ 2 $$$ a biscuit $$$ \frac { 1 } { 2 } $$$ probability player $$$ 2 $$$ give player $$$ 1 $$$ a biscuit $$$ \frac { 1 } { 2 } $$$ anyway game stop exactly $$$ 1 $$$ second one player occupy biscuits $$$ 1 $$$ second answer $$$ 1 $$$",['math'],3200.0
1349/F1,"note differences easy hard versions constraints $$$ n $$$ time limit make hack versions solve slime interest sequence define good positive integer sequence $$$ p $$$ length $$$ n $$$ follow : give integer $$$ n $$$ set good sequence length $$$ n $$$ $$$ s_n $$$ fix integer $$$ k $$$ sequence $$$ p $$$ let $$$ f_p ( k ) $$$ number time $$$ k $$$ appear $$$ p $$$ $$$ k $$$ $$$ 1 $$$ $$$ n $$$ slime want know follow value : $$$ $$$ \left ( \sum _ { p\in s_n } f_p ( k ) \right ) \ \textrm { mod } \ 998\,244\,353 $$$ $$$ first line contain one integer $$$ n\ ( 1\le n\le 5000 ) $$$ print $$$ n $$$ integers $$$ i $$$ -th equal $$$ \left ( \sum _ { p\in s_n } f_p ( i ) \right ) \ \textrm { mod } \ 998\,244\,353 $$$ first example $$$ s=\ { [ 1,1 ] [ 1,2 ] \ } $$$ second example $$$ s=\ { [ 1,1,1 ] [ 1,1,2 ] [ 1,2,1 ] [ 1,2,2 ] [ 2,1,2 ] [ 1,2,3 ] \ } $$$ third example $$$ s=\ { [ 1 ] \ } $$$","['dp', 'math']",3100.0
135/B,little petya much like rectangles especially square recently receive 8 point plane a gift mother point pairwise distinct petya decide split two set contain 4 point point first set lay vertexes square point second set lay vertexes a rectangle point initial 8 belong exactly one set acceptable a rectangle second set also a square several partition petya satisfy help find partition note rectangle square partition non - zero areas side figure parallel coordinate ax though might case give 8 pair integers a pair per line — coordinate point petya absolute value coordinate exceed 104 . guarantee two point coincide print first output line ` ` yes '' ( without quote ) desire partition exist second line output 4 space - separated number — point index input lie vertexes square point number start 1 . number print order third line print index point lie vertexes a rectangle similar format print number pairwise distinct require partition exist first line contain word ` ` '' ( without quote ) output need pay attention third example : figure necessarily parallel coordinate ax,"['brute force', 'geometry', 'math']",1600.0
1351/A,give two integers $$$ a $$$ $$$ b $$$ print $$$ a+b $$$ first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case input $$$ t $$$ test case follow test case give a line two integers $$$ a $$$ $$$ b $$$ ( $$$ -1000 \le a b \le 1000 $$$ ) print $$$ t $$$ integers — require number $$$ a+b $$$,['implementation'],800.0
1352/B,give two positive integers $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) $$$ k $$$ ( $$$ 1 \le k \le 100 $$$ ) represent number $$$ n $$$ sum $$$ k $$$ positive integers parity ( remainder divide $$$ 2 $$$ ) word find $$$ a_1 a_2 \ldots a_k $$$ $$$ a_i > 0 $$$ $$$ n = a_1 + a_2 + \ldots + a_k $$$ either $$$ a_i $$$ even $$$ a_i $$$ odd time a representation exist report first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case input next $$$ t $$$ test case give one per line test case two positive integers $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) $$$ k $$$ ( $$$ 1 \le k \le 100 $$$ ) test case print : letter word yes print case,['math'],1200.0
1353/A,give two integers $$$ n $$$ $$$ m $$$ construct array $$$ a $$$ length $$$ n $$$ consist non - negative integers ( i.e integers greater equal zero ) sum elements array exactly $$$ m $$$ value $$$ \sum\limits _ { i=1 } ^ { n-1 } |a_i - a _ { i+1 } | $$$ maximum possible recall $$$ |x| $$$ absolute value $$$ x $$$ word maximize sum absolute differences adjacent ( consecutive ) elements example array $$$ a= [ 1 3 2 5 5 0 ] $$$ value array $$$ |1 - 3| + |3 - 2| + |2 - 5| + |5 - 5| + |5 - 0| = 2 + 1 + 3 + 0 + 5 = 11 $$$ note example n't show optimal answer show require value array calculate answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 1000000000 $$$ ) — length array sum correspondingly test case print answer — maximum possible value $$$ \sum\limits _ { i=1 } ^ { n-1 } |a_i - a _ { i+1 } | $$$ array $$$ a $$$ consist $$$ n $$$ non - negative integers sum $$$ m $$$ first test case example possible array $$$ [ 100 ] $$$ answer obviously $$$ 0 $$$ second test case example one possible array $$$ [ 2 0 ] $$$ answer $$$ |2 - 0| = 2 $$$ third test case example one possible array $$$ [ 0 2 0 3 0 ] $$$ answer $$$ |0 - 2| + |2 - 0| + |0 - 3| + |3 - 0| = 10 $$$,"['greedy', 'math']",800.0
1353/D,give array $$$ a $$$ length $$$ n $$$ consist zero perform $$$ n $$$ action array : $$$ i $$$ -th action follow sequence operations appear : consider array $$$ a $$$ length $$$ 5 $$$ ( initially $$$ a= [ 0 0 0 0 0 ] $$$ ) change follow : task find array $$$ a $$$ length $$$ n $$$ perform $$$ n $$$ action note answer exist unique answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print answer — array $$$ a $$$ length $$$ n $$$ perform $$$ n $$$ action describe problem statement note answer exist unique,"['data structures', 'sortings']",1600.0
1354/C2,statement problem statement problem c1 difference problem c1 $$$ n $$$ always even c2 $$$ n $$$ always odd give a regular polygon $$$ 2 \cdot n $$$ vertices ( 's convex equal side equal angle ) side length $$$ 1 $$$ let 's name $$$ 2n $$$ -gon task find square minimum size embed $$$ 2n $$$ -gon square embed $$$ 2n $$$ -gon square mean need place $$$ 2n $$$ -gon square way point lie inside a border $$$ 2n $$$ -gon also lie inside a border square rotate $$$ 2n $$$ -gon and/or square first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200 $$$ ) — number test case next $$$ t $$$ line contain descriptions test case — one per line line contain single odd integer $$$ n $$$ ( $$$ 3 \le n \le 199 $$$ ) n't forget need embed $$$ 2n $$$ -gon $$$ n $$$ -gon print $$$ t $$$ real number — one per test case test case print minimum length a side square $$$ 2n $$$ -gon embed answer consider correct absolute relative error n't exceed $$$ 10^ { -6 } $$$,"['binary search', 'brute force', 'geometry', 'math']",2000.0
1354/E,give undirected graph without self - loops multiple edge consist $$$ n $$$ vertices $$$ m $$$ edge also give three integers $$$ n_1 $$$ $$$ n_2 $$$ $$$ n_3 $$$ label vertex one three number 1 2 3 way : multiple valid label print first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 5000 $$$ ; $$$ 0 \le m \le 100000 $$$ ) — number vertices edge graph second line contain three integers $$$ n_1 $$$ $$$ n_2 $$$ $$$ n_3 $$$ ( $$$ 0 \le n_1 n_2 n_3 \le n $$$ ) — number label 1 2 3 respectively 's guarantee $$$ n_1 + n_2 + n_3 = n $$$ next $$$ m $$$ line <unknown> description edge : $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ; $$$ u_i \neq v_i $$$ ) — vertices $$$ i $$$ -th edge connect 's guarantee graph n't contain self - loops multiple edge valid label exist print ` ` yes '' ( without quote ) first line second line print string length $$$ n $$$ consist 1 2 3 . $$$ i $$$ -th letter equal label $$$ i $$$ -th vertex valid label print ` ` '' ( without quote ),"['dfs and similar', 'dp', 'graphs']",2100.0
1355/E,restore wall wall consist $$$ n $$$ pillars bricks height $$$ i $$$ -th pillar initially equal $$$ h _ { i } $$$ height measure number bricks restoration $$$ n $$$ pillars equal heights allow follow operations : create additional pillars ignore pre - existing pillars even height become $$$ 0 $$$ minimal total cost restoration word minimal total cost make pillars equal height ? first line input contain four integers $$$ n $$$ $$$ a $$$ $$$ r $$$ $$$ m $$$ ( $$$ 1 \le n \le 10^ { 5 } $$$ $$$ 0 \le a r m \le 10^ { 4 } $$$ ) — number pillars cost operations second line contain $$$ n $$$ integers $$$ h _ { i } $$$ ( $$$ 0 \le h _ { i } \le 10^ { 9 } $$$ ) — initial heights pillars print one integer — minimal cost restoration,"['binary search', 'greedy', 'math', 'sortings']",2100.0
1358/C,quarantine <unknown> free time create new function ` ` celex-2021 '' developers make a new function gaz - giz infinitely fill infinite table right upper leave corner follow : developers sum function n't sleep either boredom team developers <unknown> function add ability calculate sum arbitrary path one cell another move right formally cell $$$ ( x y ) $$$ one step move cell $$$ ( x+1 y ) $$$ $$$ ( x y+1 ) $$$ another <unknown> update levian start study ` ` celex-2021 '' ( want accountant ! ) fill table gaz - giz function ask calculate quantity possible different amount path a give cell $$$ ( x_1 y_1 ) $$$ another give cell $$$ ( x_2 y_2 $$$ ) move one cell right formally consider paths cell $$$ ( x_1 y_1 ) $$$ cell $$$ ( x_2 y_2 ) $$$ next cell path locate either right previous one calculate number different sum elements paths first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le <unknown> $$$ ) — number test case follow $$$ t $$$ line contain four natural number $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \le x_1 \le x_2 \le 1000000000 $$$ $$$ 1 \le y_1 \le y_2 \le 1000000000 $$$ ) — coordinate start end cells test case a separate line print number possible different sum way start cell end cell first test case two possible sum : $$$ 1 + 2 + 5=8 $$$ $$$ 1 + 3 + 5=9 $$$,['math'],1600.0
1360/D,"polycarp want buy exactly $$$ n $$$ shovel shop sell package shovel store $$$ k $$$ type package : package $$$ i $$$ -th type consist exactly $$$ i $$$ shovel ( $$$ 1 \le i \le k $$$ ) store infinite number package type polycarp want choose one type package buy several ( one ) package type smallest number package polycarp buy get exactly $$$ n $$$ shovel ? example $$$ n=8 $$$ $$$ k=7 $$$ polycarp buy $$$ 2 $$$ package $$$ 4 $$$ shovel help polycarp find minimum number package need buy give : first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case input , $$$ t $$$ test case follow one per line test case consist two positive integers $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) $$$ k $$$ ( $$$ 1 \le k \le 1000000000 $$$ ) — number shovel number type package print $$$ t $$$ answer test case answer a positive integer — minimum number package answer first test case explain statement second test case one way buy $$$ 8 $$$ shovel — $$$ 8 $$$ package one shovel third test case need buy a $$$ 1 $$$ package $$$ 6 $$$ shovel","['math', 'number theory']",1300.0
1361/D,"jam bond johnny 's favorite secret agent a new mission $$$ n $$$ enemy base describe coordinate think point cartesian plane base communicate send a signal ray direct choose point origin opposite direction exception central base lie origin send a signal direction two base want communicate two possible scenarios lie line origin one send a signal directly one otherwise signal send first base central central send second base denote distance two base total euclidean distance a signal send travel bond damage $$$ k $$$ base choose arbitrarily a damage base ca n't send receive direct signal still pass two work base particular jam damage central base signal still send two undamaged base distance remain maximal sum distance pair remain base 007 achieve damage exactly $$$ n - k $$$ ? first line contain two integers $$$ n $$$ $$$ k $$$ $$$ ( 2 \leq k \leq n \leq 5 \cdot 100000 ) $$$ — total number base number base remain respectively next $$$ n $$$ line contain two integers $$$ x $$$ $$$ y $$$ $$$ ( -1000000000 \leq x y \leq 1000000000 ) $$$ $$$ i $$$ -th line contain coordinate $$$ i $$$ -th base assume two point coincide one $$$ ( 0 0 ) $$$ output one number — maximal possible sum distance pair $$$ k $$$ give base answer accept absolute relative error less $$$ 10^ { -6 } $$$ first example optimal solution bond n't destroy base indices $$$ 4 $$$ $$$ 6 $$$ ( mark orange ) : follow picture represent optimal solution second example base destroy : $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ $$$ 6 $$$ ( mark orange ) optimal solution third test visible picture base $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ destroy , destroy base mark orange","['greedy', 'implementation', 'math', 'trees']",2900.0
1363/A,shubham array $$$ a $$$ size $$$ n $$$ want select exactly $$$ x $$$ elements sum odd elements consecutive elements array guarantee distinct tell whether first line input contain a single integer $$$ t $$$ $$$ ( 1\le t \le 100 ) $$$ — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ x $$$ $$$ ( 1 \le x \le n \le 1000 ) $$$ — length array number elements need choose next line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ $$$ ( 1 \le a_i \le 1000 ) $$$ — elements array test case print ` ` yes '' ` ` '' depend whether possible choose $$$ x $$$ elements sum odd may print every letter case want $$$ 1 $$$ st case : must select element $$$ 999 $$$ sum odd $$$ 2 $$$ nd case : must select element $$$ 1000 $$$ overall sum odd $$$ 3 $$$ rd case : select element $$$ 51 $$$ $$$ 4 $$$ th case : must select elements $$$ 50 $$$ $$$ 51 $$$ — overall sum odd $$$ 5 $$$ th case : must select elements — overall sum odd,"['brute force', 'implementation', 'math']",1200.0
1364/C,give array $$$ a $$$ length $$$ n $$$ find another array $$$ b $$$ length $$$ n $$$ : $$$ mex $$$ a set integers smallest non - negative integer n't belong set array n't exist determine first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a_n $$$ ( $$$ 0 \le a_i \le i $$$ ) — elements array $$$ a $$$ 's guarantee $$$ a_i \le a _ { i+1 } $$$ $$$ 1\le i < n $$$ 's array print a single line contain $$$ -1 $$$ otherwise print a single line contain $$$ n $$$ integers $$$ b_1 $$$ $$$ b_2 $$$ $$$ \ldots $$$ $$$ b_n $$$ ( $$$ 0 \le b_i \le 1000000 $$$ ) multiple answer print second test case answer like $$$ [ <unknown> ] $$$ example valid,"['brute force', 'greedy']",1600.0
1364/D,"give a connect undirected graph $$$ n $$$ vertices integer $$$ k $$$ either : independent set a set vertices two connect edge a simple cycle a cycle n't contain vertex twice i a proof input always solve least one problems 's leave exercise reader first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 3 \le k \le n \le 100000 $$$ $$$ n-1 \le m \le 200000 $$$ ) — number vertices edge graph parameter $$$ k $$$ statement next $$$ m $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) mean 's edge vertices $$$ u $$$ $$$ v $$$ 's guarantee graph connect n't contain self - loops multiple edge choose solve first problem first line print $$$ 1 $$$ follow a line contain $$$ \lceil\frac { k } { 2 } \rceil $$$ distinct integers exceed $$$ n $$$ vertices desire independent set , however choose solve second problem first line print $$$ 2 $$$ follow a line contain one integer $$$ c $$$ represent length find cycle follow a line contain $$$ c $$$ distinct integers exceed $$$ n $$$ vertices desire cycle order appear cycle first sample : notice print independent set $$$ \ { <unknown> } $$$ also ok print cycle $$$ 1 - 2 - 3 - 4 $$$ n't length must $$$ 3 $$$ second sample : notice print independent set $$$ \ { 1,3\ } $$$ print cycle $$$ 2 - 1 - 4 $$$ also ok . third sample : fourth sample :","['dfs and similar', 'graphs', 'greedy', 'implementation', 'trees']",2100.0
1365/A,ashish vivek play a game a matrix consist $$$ n $$$ row $$$ m $$$ columns take turn claim cells unclaimed cells represent $$$ 0 $$$ claim cells represent $$$ 1 $$$ initial state matrix give claim cells initial state turn a player must claim a cell a cell may claim unclaimed share a row column already claim cells a player unable make a move lose game end ashish vivek take turn move ashish go first determine winner game play optimally optimal play two players mean players choose best possible strategy achieve best possible outcome first line consist a single integer $$$ t $$$ $$$ ( 1 \le t \le 50 ) $$$ — number test case description test case follow first line test case consist two space - separated integers $$$ n $$$ $$$ m $$$ $$$ ( 1 \le n m \le 50 ) $$$ — number row columns matrix follow $$$ n $$$ line consist $$$ m $$$ integers $$$ j $$$ -th integer $$$ i $$$ -th line denote $$$ a _ { i j } $$$ $$$ ( a _ { i j } \in \ { 0 1\ } ) $$$ test case ashish win game print ` ` ashish '' otherwise print ` ` vivek '' ( without quote ) first case : one possible scenario could : ashish claim cell $$$ ( 1 1 ) $$$ vivek claim cell $$$ ( 2 2 ) $$$ ashish neither claim cell $$$ ( 1 2 ) $$$ cell $$$ ( 2 1 ) $$$ cells $$$ ( 1 1 ) $$$ $$$ ( 2 2 ) $$$ already claim thus ashish lose show matter ashish play case vivek win second case : ashish claim cell $$$ ( 1 1 ) $$$ cell claim first move vivek move leave third case : ashish make a move vivek win fourth case : ashish claim cell $$$ ( 2 3 ) $$$ vivek move leave,"['greedy', 'implementation']",1100.0
1365/C,mysterious disappearance ashish two favourite disciples ishika hriday leave one half a secret message message represent a permutation size $$$ n $$$ let 's call $$$ a $$$ $$$ b $$$ note a permutation $$$ n $$$ elements a sequence number $$$ a_1 a_2 \ldots a_n $$$ every number $$$ 1 $$$ $$$ n $$$ appear exactly message decode arrangement sequence $$$ a $$$ $$$ b $$$ number match pair elements maximum a pair elements $$$ a_i $$$ $$$ b_j $$$ say match : two disciples allow perform follow operation number time : a single cyclic shift leave permutation $$$ c $$$ operation set $$$ c_1 : = c_2 c_2 : = c_3 \ldots c_n : = c_1 $$$ simultaneously likewise a single cyclic shift right permutation $$$ c $$$ operation set $$$ c_1 : = c_n c_2 : = c_1 \ldots c_n : = c _ { n-1 } $$$ simultaneously help ishika hriday find maximum number pair elements match perform operation ( possibly zero ) number time first line input contain a single integer $$$ n $$$ $$$ ( 1 \le n \le 2 \cdot 100000 ) $$$ — size array second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ $$$ ( 1 \le a_i \le n ) $$$ — elements first permutation third line contain $$$ n $$$ integers $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_n $$$ $$$ ( 1 \le b_i \le n ) $$$ — elements second permutation print maximum number match pair elements perform operations ( possibly zero ) time first case : $$$ b $$$ shift right $$$ k = 1 $$$ result permutations $$$ \ { 1 2 3 4 5\ } $$$ $$$ \ { 1 2 3 4 5\ } $$$ second case : operation require possible rotations $$$ a $$$ $$$ b $$$ number match pair wo n't exceed $$$ 1 $$$ third case : $$$ b $$$ shift leave $$$ k = 1 $$$ result permutations $$$ \ { 1 3 2 4\ } $$$ $$$ \ { 2 3 1 4\ } $$$ position $$$ 2 $$$ $$$ 4 $$$ match pair elements possible rotations $$$ a $$$ $$$ b $$$ number match pair wo n't exceed $$$ 2 $$$,"['data structures', 'greedy', 'implementation']",1400.0
1368/D,"<unknown> learn binary number representation come task present give a collection $$$ n $$$ non - negative integers $$$ a_1 \ldots a_n $$$ allow perform follow operation : choose two distinct indices $$$ 1 \leq i j \leq n $$$ operation $$$ a_i = x $$$ $$$ a_j = y $$$ operation $$$ a_i = x~\mathsf { } ~y $$$ $$$ a_j = x~\mathsf { } ~y $$$ $$$ \mathsf { } $$$ $$$ \mathsf { } $$$ bitwise respectively ( refer note section formal description ) operation may perform number time ( possibly zero ) operations do compute $$$ \sum _ { i=1 } ^n a_i^2 $$$ — sum square $$$ a_i $$$ largest sum square achieve ? first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 \ldots a_n $$$ ( $$$ 0 \leq a_i < 2^ { 20 } $$$ ) print a single integer — largest possible sum square achieve several ( possibly zero ) operations first sample operation make thus answer $$$ 123 ^ 2 $$$ second sample obtain collection $$$ 1 1 7 $$$ $$$ 1 ^ 2 + 1 ^ 2 + 7 ^ 2 = 51 $$$ $$$ x $$$ $$$ y $$$ represent binary equal number bits ( possibly lead zero ) bite $$$ x~\mathsf { } ~y $$$ set $$$ 1 $$$ correspond bits $$$ x $$$ $$$ y $$$ set $$$ 1 $$$ similarly bite $$$ x~\mathsf { } ~y $$$ set $$$ 1 $$$ least one correspond bits $$$ x $$$ $$$ y $$$ set $$$ 1 $$$ example $$$ x = 3 $$$ $$$ y = 5 $$$ represent $$$ 011_2 $$$ $$$ 101_2 $$$ ( highest bite first ) , $$$ x~\mathsf { } ~y = 001_2 = 1 $$$ $$$ x~\mathsf { } ~y = <unknown> = 7 $$$","['bitmasks', 'greedy', 'math']",1700.0
1368/E,"arthur own a ski resort a mountain $$$ n $$$ land spot mountain number $$$ 1 $$$ $$$ n $$$ top foot mountain spot connect one - directional ski track track go towards foot mountain direct cycle form track two track leave spot many track may enter spot a skier start ski one spot stop another spot a sequence track lead start spot end end spot unfortunately recently many accidents structure resort allow a skier go dangerous paths reach high speed <unknown> customers , a path call dangerous consist least two track arthur want secure customers close spot a way dangerous paths resort a spot close track enter leave spot become unusable formally close spot a path consist two track arthur n't want close many spot happy find way close $$$ \frac { 4 } { 7 } n $$$ spot remain part safe help find suitable way first line contain a single positive integer $$$ t $$$ — number test case $$$ t $$$ test case description follow first line description contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — number land spot track respectively follow $$$ m $$$ line describe track line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq x < y \leq n $$$ ) — indices start finish spot respective track guarantee two track start spot may track start finish spot coincide guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print a single integer $$$ k $$$ ( $$$ 0 \leq k \leq \frac { 4 } { 7 } n $$$ ) — number spot close next line print $$$ k $$$ distinct integers — indices spot close order several answer may output note n't minimize $$$ k $$$ show a suitable answer always exist first sample case close two spot suitable second sample case close spot $$$ 1 $$$ also suitable","['graphs', 'greedy']",2500.0
1371/E2,"hard version problem difference versions constraints $$$ n $$$ $$$ a_i $$$ make hack versions problem solve first aoi come follow idea competitive program problem : yuzu a girl collect candy originally $$$ x $$$ candy also $$$ n $$$ enemies number integers $$$ 1 $$$ $$$ n $$$ enemy $$$ i $$$ $$$ a_i $$$ candy yuzu go determine a permutation $$$ p $$$ a permutation array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ \ { 2,3,1,5,4\ } $$$ a permutation $$$ \ { 1,2,2\ } $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ \ { 1,3,4\ } $$$ also a permutation ( $$$ n=3 $$$ number $$$ 4 $$$ array ) , $$$ n $$$ duel enemies follow rule : yuzu want win duel many valid permutations $$$ p $$$ exist ? problem easy n't interest akari a friend aoi akari make follow problem idea : let 's define $$$ f ( x ) $$$ number valid permutations integer $$$ x $$$ give $$$ n $$$ $$$ a $$$ a prime number $$$ p \le n $$$ let 's call a positive integer $$$ x $$$ good value $$$ f ( x ) $$$ divisible $$$ p $$$ find good integers $$$ x $$$ task solve problem make akari first line contain two integers $$$ n $$$ $$$ p $$$ $$$ ( 2 \le p \le n \le 100000 ) $$$ guarantee number $$$ p $$$ prime ( exactly two divisors $$$ 1 $$$ $$$ p $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 1 \le a_i \le 1000000000 ) $$$ first line print number good integers $$$ x $$$ second line output good integers $$$ x $$$ ascend order guarantee number good integers $$$ x $$$ exceed $$$ 100000 $$$ first test $$$ p=2 $$$ , good number $$$ 3 $$$ third test positive integers $$$ x $$$ value $$$ f ( x ) $$$ divisible $$$ p = 3 $$$","['binary search', 'combinatorics', 'dp', 'math', 'number theory', 'sortings']",2300.0
1373/A,two rival donut shop first shop sell donuts <unknown> : donut cost $$$ a $$$ dollars second shop sell donuts bulk : box $$$ b $$$ donuts cost $$$ c $$$ dollars want buy $$$ x $$$ donuts shop buy smallest number box total number donuts greater equal $$$ x $$$ want determine two positive integer value : value n't exist value equal $$$ -1 $$$ multiple possible answer print print value less equal $$$ 1000000000 $$$ show give constraints value always exist value exist first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases next $$$ t $$$ line contain three integers $$$ a $$$ $$$ b $$$ $$$ c $$$ ( $$$ 1 \le a \le 1000000000 $$$ $$$ 2 \le b \le 1000000000 $$$ $$$ 1 \le c \le 1000000000 $$$ ) testcase print two positive integers shop print $$$ x $$$ buy $$$ x $$$ donuts shop strictly cheaper buy $$$ x $$$ donuts shop $$$ x $$$ greater $$$ 0 $$$ less equal $$$ 1000000000 $$$ $$$ x $$$ print $$$ -1 $$$ multiple answer print first testcase buy number donuts cheaper second shop example $$$ 3 $$$ $$$ 5 $$$ donuts 'll buy a box $$$ 10 $$$ donuts $$$ 4 $$$ dollars $$$ 3 $$$ $$$ 5 $$$ donuts first shop would cost $$$ 15 $$$ $$$ 25 $$$ dollars respectively however $$$ 20 $$$ donuts 'll buy two box $$$ 8 $$$ dollars total note $$$ 3 $$$ $$$ 5 $$$ also valid answer second shop along many answer second testcase buy number donuts either cheaper first shop price $$$ 8 $$$ donuts cost $$$ 32 $$$ dollars first shop $$$ 40 $$$ dollars second shop ( buy two box ) $$$ 10 $$$ donuts cost $$$ 40 $$$ dollars shop $$$ 10 $$$ a valid answer shop third testcase $$$ 1 $$$ donut cost $$$ 2 $$$ $$$ 3 $$$ dollars respectively $$$ 2 $$$ donuts cost $$$ 4 $$$ $$$ 3 $$$ dollars thus $$$ 1 $$$ a valid answer first shop $$$ 2 $$$ a valid answer second shop fourth testcase $$$ 1000000000 $$$ donuts cost $$$ 10^ { 18 } $$$ dollars first shop $$$ 1000000000 $$$ dollars second shop,"['greedy', 'implementation', 'math']",1000.0
1374/A,give three integers $$$ x y $$$ $$$ n $$$ task find maximum integer $$$ k $$$ $$$ 0 \le k \le n $$$ $$$ k \bmod x = y $$$ $$$ \bmod $$$ modulo operation many program languages use percent operator % implement word give $$$ x y $$$ $$$ n $$$ need find maximum possible integer $$$ 0 $$$ $$$ n $$$ remainder $$$ y $$$ modulo $$$ x $$$ answer $$$ t $$$ independent test case guarantee $$$ k $$$ exist test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 50000 $$$ ) — number test case next $$$ t $$$ line contain test case line test case contain three integers $$$ x y $$$ $$$ n $$$ ( $$$ 2 \le x \le 1000000000 ; ~ 0 \le y < x ; ~ y \le n \le 1000000000 $$$ ) show $$$ k $$$ always exist give constraints test case print answer — maximum non - negative integer $$$ k $$$ $$$ 0 \le k \le n $$$ $$$ k \bmod x = y $$$ guarantee answer always exist first test case example answer $$$ 12339 = <unknown> + 5 $$$ ( thus $$$ 12339 \bmod 7 = 5 $$$ ) obvious greater integer exceed $$$ 12345 $$$ remainder $$$ 5 $$$ modulo $$$ 7 $$$,['math'],800.0
1374/D,give array $$$ a $$$ consist $$$ n $$$ positive integers initially integer $$$ x = 0 $$$ one move one follow two operations : first operation apply $$$ i $$$ $$$ 1 $$$ $$$ n $$$ task find minimum number move require obtain array element divisible $$$ k $$$ ( value $$$ k $$$ give ) answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 2 \cdot 100000 ; 1 \le k \le 1000000000 $$$ ) — length $$$ a $$$ require <unknown> second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print answer — minimum number move require obtain array element divisible $$$ k $$$ consider first test case example : note ca n't add $$$ x $$$ element,"['math', 'sortings', 'two pointers']",1400.0
1379/B,"pasha love send strictly positive integers friends pasha care security therefore want send integer $$$ n $$$ encrypt follow way : pick three integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ l \leq a b c \leq r $$$ compute encrypt value $$$ m = n \cdot a + b - c $$$ unfortunately <unknown> intercept value $$$ l $$$ $$$ r $$$ $$$ m $$$ possible recover original value $$$ a $$$ $$$ b $$$ $$$ c $$$ information ? formally ask find value $$$ a $$$ $$$ b $$$ $$$ c $$$ thatthe first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 20 $$$ ) — number test case follow $$$ t $$$ line describe one test case test case consist three integers $$$ l $$$ $$$ r $$$ $$$ m $$$ ( $$$ 1 \leq l \leq r \leq 500\,000 $$$ $$$ 1 \leq m \leq 10^ { 10 } $$$ ) number answer problem exist test case output three integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ l \leq a b c \leq r $$$ exist a strictly positive integer $$$ n $$$ $$$ n \cdot a + b - c = m $$$ guarantee least one possible solution output possible combination multiple solutions first example $$$ n = 3 $$$ possible $$$ n \cdot 4 + 6 - 5 = 13 = m $$$ possible solutions include : $$$ a = 4 $$$ $$$ b = 5 $$$ $$$ c = 4 $$$ ( $$$ n = 3 $$$ ) ; $$$ a = 5 $$$ $$$ b = 4 $$$ $$$ c = 6 $$$ ( $$$ n = 3 $$$ ) ; $$$ a = 6 $$$ $$$ b = 6 $$$ $$$ c = 5 $$$ ( $$$ n = 2 $$$ ) ; $$$ a = 6 $$$ $$$ b = 5 $$$ $$$ c = 4 $$$ ( $$$ n = 2 $$$ ) second example possible case $$$ n = 1 $$$ : case $$$ n \cdot 2 + 2 - 3 = 1 = m $$$ note $$$ n = 0 $$$ possible since case $$$ n $$$ a strictly positive integer","['binary search', 'brute force', 'math', 'number theory']",1500.0
1379/C,"vladimir would like prepare a present wife : anniversary ! decide buy exactly $$$ n $$$ flower vladimir go a flower shop amaze see $$$ m $$$ type flower sell unlimited supply flower type vladimir want choose flower maximize happiness wife know receive first flower $$$ i $$$ -th type happiness wife increase $$$ a_i $$$ receive consecutive flower type happiness increase $$$ b_i $$$ , among choose flower $$$ x_i > 0 $$$ flower type $$$ i $$$ wife get $$$ a_i + ( x_i - 1 ) \cdot b_i $$$ additional happiness ( flower type $$$ i $$$ get nothing particular type ) please help vladimir choose exactly $$$ n $$$ flower maximize total happiness wife first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10\,000 $$$ ) number test case follow $$$ t $$$ descriptions test case test case description start two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 1000000000 $$$ $$$ 1 \le m \le 100\,000 $$$ ) number flower vladimir need choose number type available flower follow $$$ m $$$ line describe type flower : line contain integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 0 \le a_i b_i \le 1000000000 $$$ ) $$$ i $$$ -th available type flower test case separate a blank line guarantee sum value $$$ m $$$ among test case exceed $$$ 100\,000 $$$ test case output a single integer : maximum total happiness vladimir 's wife choose exactly $$$ n $$$ flower optimally first example case vladimir pick 1 flower first type 3 flower second type case total happiness equal $$$ 5 + ( 1 + 2 \cdot 4 ) = 14 $$$ second example vladimir pick 2 flower first type 2 flower second type 1 flower third type case total happiness equal $$$ ( 5 + 1 \cdot 2 ) + ( 4 + 1 \cdot 2 ) + 3 = 16 $$$","['binary search', 'brute force', 'data structures', 'dfs and similar', 'dp', 'greedy', 'sortings', 'two pointers']",2000.0
138/C,one day natalia walk woods meet a little mushroom gnome gnome tell follow story : everybody know mushroom gnomes ' power lie magic mushroom grow native woods gnomes n tree m magic mushroom woods : i - th tree grow a point a straight line coordinate ai height hi j - th mushroom grow point coordinate bj magical power zj one day wild <unknown> <unknown> enemies mushroom gnomes <unknown> a terrible storm home forest a result tree begin fall crush magic mushroom supreme oracle mushroom gnomes calculate advance probability tree fall leave right stand tree coordinate x height h fall leave mushroom belong right - open interval [ x - h x ) destroy a tree fall right mushroom belong left - open interval ( x x + h ] destroy mushroom hit a single tree survive know tree fall independently ( i.e. events mutually independent besides tree interfere tree fall arbitrary direction ) supreme oracle also able quickly calculate would expectation total power mushroom survive storm calculations ultimately save mushroom gnomes <unknown> death natalia a good olympiad programmer get interest story decide come a way quickly calculate expectation sum survive mushroom ' power first line contain two integers n m ( 1 ≤ n ≤ 105 1 ≤ m ≤ 104 ) — number tree mushroom respectively next n line contain four integers — ai hi li ri ( |ai| ≤ 109 1 ≤ hi ≤ 109 0 ≤ li ri li + ri ≤ 100 ) represent coordinate i - th tree height percentage probabilities tree fall leave right respectively ( remain percentage probability tree stand ) next m line contain two integers bj zj ( <unknown> ≤ 109 1 ≤ zj ≤ 103 ) represent coordinate magical power j - th mushroom respectively arbitrary number tree mushroom grow one point print a real number — expectation total magical power survive mushroom result accept relative absolute accuracy 10 - 4 . believe mushroom coordinate x belong right - open interval [ l r ) l ≤ x < r. similarly mushroom coordinate x belong left - open interval ( l r ] l < x ≤ r. first test mushroom survive probability 50 % depend single tree fall second test mushroom survive neither two tree fall occur probability 50 % × 50 % = 25 % pretest № 12 large test 105 tree one mushroom,"['binary search', 'data structures', 'sortings']",2200.0
138/D,recently roma become happy owner a new game world darkraft game combine elements <unknown> know genres one later stag game roma face difficulties solve a puzzle part roma fight a cunning enemy magician battle take place a rectangular field <unknown> n × m. cell contain one magical character : l r x. initially square field ` ` active '' players roma enemy magician take turn roma make first move a move a player select one active cells depend image character cell one follow action take place : next player make a move ( i.e. cells inactive ) lose roma try defeat computer opponent three days keep lose ask help determine whether guarantee beat opponent hack game first line contain two space - separated integers n m ( 1 ≤ n m ≤ 20 ) next n line contain m character describe play field : j - th character i - th line equal magical character correspond field square first line print ` ` win '' roma win ` ` lose '' impossible win consider opponent pay optimally first test move make one diagonal line square inactive thus guarantee roma lose two move three variants make a move second test : ` ` finish '' main diagonal line square leave mean three move game stop roma win,['dp'],2500.0
138/E,katya recently start invent program task prepare contest like bore simple constraints katya feed ` ` n exceed a thousand '' ` ` sum ai exceed a million '' decide come something a little complicate last problem write katya deal string input a string small latin letter make statement longer strike <unknown> people solve contest katya come follow set k restrictions type ( character restrictions repeat restrictions may contradict ) : however decide simple obvious katya add follow condition : a string meet less l r constraints give list katya like compose difficult mean test take a big string s want add test substrings meet constraints however katya get lose condition ask count number substrings string s meet condition ( occurrence substring count separately ) first line contain a non - empty string s consist small latin letter length string s exceed 105 . second line contain three space - separated integers k l r ( 0 ≤ l ≤ r ≤ k ≤ 500 ) next k line contain katya 's constrictions follow form ` ` ci li ri '' letter ci small latin letter li ri integers ( 0 ≤ li ≤ ri ≤ |s| |s| length string s ) letter ci necessarily different print a single number — number substrings meet constrictions please use % lld specificator read write 64 - bit integers с++ prefer use cout stream % i64d specificator first test count number string contain character ` ` e '' ` ` o '' string follow ( order occurrence initial string leave right ) : ` ` c '' ` ` d '' ' ` ` f '' ` ` r '' ` ` rc '' ` ` c '' ` ` s '' second test achieve fulfil exactly one two identical constrictions answer 0,"['brute force', 'dp', 'two pointers']",2900.0
1380/C,$$$ n $$$ programmers want split several non - empty team skill $$$ i $$$ -th programmer $$$ a_i $$$ want assemble maximum number team a restriction team : number programmers team multiply minimum skill among programmers team must least $$$ x $$$ programmer belong one team programmers may leave without a team calculate maximum number team assemble first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \le n \le 100000 ; 1 \le x \le 1000000000 $$$ ) — number programmers restriction team skill respectively second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ skill $$$ i $$$ -th programmer sum $$$ n $$$ input exceed $$$ 100000 $$$ test case print one integer — maximum number team assemble,"['brute force', 'dp', 'greedy', 'implementation', 'sortings']",1400.0
1383/B,koa koala best friend want play a game game start array $$$ a $$$ length $$$ n $$$ consist non - negative integers koa best friend move turn initially a score equal $$$ 0 $$$ koa start let 's describe a move game : formally : current score player $$$ x $$$ choose element $$$ y $$$ new score $$$ x \oplus y $$$ $$$ \oplus $$$ denote bitwise xor operation note a move element $$$ y $$$ remove $$$ a $$$ end game winner player maximum score players score 's a draw players play optimally find whether koa win lose draw game test contain multiple test case first line contain $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — elements $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print : testcase $$$ 1 $$$ first sample : $$$ a = [ 1 2 2 ] $$$ koa choose $$$ 1 $$$ player choose $$$ 2 $$$ koa choose another $$$ 2 $$$ score koa $$$ 1 \oplus 2 = 3 $$$ score player $$$ 2 $$$ koa win,"['bitmasks', 'dp', 'greedy', 'math']",1900.0
1383/E,koa koala a binary string $$$ s $$$ length $$$ n $$$ koa perform $$$ n-1 $$$ ( possibly zero ) operations follow form : one operation koa select position $$$ i $$$ $$$ i+1 $$$ $$$ i $$$ $$$ 1 \le i < |s| $$$ set $$$ s_i $$$ $$$ max ( s_i s _ { i+1 } ) $$$ koa delete position $$$ i+1 $$$ $$$ s $$$ ( removal remain part concatenate ) note every operation length $$$ s $$$ decrease $$$ 1 $$$ many different binary string koa obtain $$$ n-1 $$$ ( possibly zero ) operations modulo $$$ 1000000000 + 7 $$$ ( $$$ 1000000007 $$$ ) ? line input contain binary string $$$ s $$$ ( $$$ 1 \le |s| \le 1000000 $$$ ) $$$ i $$$ ( $$$ 1 \le i \le |s| $$$ ) $$$ s_i = 0 $$$ $$$ s_i = 1 $$$ a single line print answer problem modulo $$$ 1000000000 + 7 $$$ ( $$$ 1000000007 $$$ ) first sample koa obtain binary string : $$$ 0 $$$ $$$ 00 $$$ $$$ 000 $$$ second sample koa obtain binary string : $$$ 1 $$$ $$$ 01 $$$ $$$ 11 $$$ $$$ 011 $$$ $$$ 101 $$$ $$$ 0101 $$$ example : parentheses denote two position koa select operation,"['combinatorics', 'data structures', 'dp']",2800.0
1384/A,length longest common prefix two string $$$ s = s_1 s_2 \ldots s_n $$$ $$$ t = t_1 t_2 \ldots t_m $$$ define maximum integer $$$ k $$$ ( $$$ 0 \le k \le min ( n m ) $$$ ) $$$ s_1 s_2 \ldots s_k $$$ equal $$$ t_1 t_2 \ldots t_k $$$ koa koala initially $$$ n+1 $$$ string $$$ s_1 s_2 \dots s _ { n+1 } $$$ $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) calculate $$$ a_i $$$ — length longest common prefix $$$ s_i $$$ $$$ s _ { i+1 } $$$ several days later koa find number could n't remember string koa would like find string $$$ s_1 s_2 \dots s _ { n+1 } $$$ would generate number $$$ a_1 a_2 \dots a_n $$$ help ? many answer print show answer always exist give constraints test contain multiple test case first line contain $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number elements list $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 50 $$$ ) — elements $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100 $$$ test case : output $$$ n+1 $$$ line $$$ i $$$ -th line print string $$$ s_i $$$ ( $$$ 1 \le |s_i| \le 200 $$$ ) consist lowercase latin letter length longest common prefix string $$$ s_i $$$ $$$ s _ { i+1 } $$$ equal $$$ a_i $$$ many answer print show answer always exist give constraints $$$ 1 $$$ -st test case one possible answer $$$ s = [ <unknown> ari <unknown> around ari ] $$$ lengths longest common prefix :,"['greedy', 'strings']",1200.0
1385/F,give a tree ( connect graph without cycle ) consist $$$ n $$$ vertices tree unrooted — a connect undirected graph without cycle one move choose exactly $$$ k $$$ leave ( leaf a vertex connect one another vertex ) connect vertex remove edge incident i.e choose leave $$$ u_1 u_2 \dots u_k $$$ edge $$$ ( u_1 v ) $$$ $$$ ( u_2 v ) $$$ $$$ \dots $$$ $$$ ( u_k v ) $$$ remove leave edge task find maximum number move perform remove leave optimally answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 200000 $$$ ; $$$ 1 \le k < n $$$ ) — number vertices tree number leave remove one move respectively next $$$ n-1 $$$ line describe edge $$$ i $$$ -th edge represent two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ ) $$$ x_i $$$ $$$ y_i $$$ vertices $$$ i $$$ -th edge connect guarantee give set edge form a tree guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print answer — maximum number move perform remove leave optimally picture correspond first test case example : remove vertices $$$ 2 $$$ $$$ 5 $$$ $$$ 3 $$$ first move vertices $$$ 1 $$$ $$$ 7 $$$ $$$ 4 $$$ second move picture correspond second test case example : remove vertices $$$ 7 $$$ $$$ 8 $$$ $$$ 9 $$$ first move vertices $$$ 5 $$$ $$$ 6 $$$ $$$ 10 $$$ second move vertices $$$ 1 $$$ $$$ 3 $$$ $$$ 4 $$$ third move picture correspond third test case example : remove vertices $$$ 5 $$$ $$$ 7 $$$ first move vertices $$$ 2 $$$ $$$ 4 $$$ second move vertices $$$ 1 $$$ $$$ 6 $$$ third move,"['data structures', 'greedy', 'implementation', 'trees']",2300.0
1388/A,despite bad reputation captain flint a friendly person ( least friendly animals ) captain flint search worthy sailors join new crew ( solely peaceful purpose ) a sailor consider worthy solve flint 's task recently blue captain flint interest math even define a new class integers let 's define a positive integer $$$ x $$$ nearly prime represent $$$ p \cdot q $$$ $$$ 1 < p < q $$$ $$$ p $$$ $$$ q $$$ prime number example integers $$$ 6 $$$ $$$ 10 $$$ nearly prim ( since $$$ 6 = 6 $$$ $$$ 10 = 10 $$$ ) integers $$$ 1 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 16 $$$ $$$ 17 $$$ $$$ 44 $$$ captain flint guess integer $$$ n $$$ ask : represent sum $$$ 4 $$$ different positive integers least $$$ 3 $$$ nearly prime uncle bogdan easily solve task join crew ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next $$$ t $$$ line contain test case — one per line first line test case contain single integer $$$ n $$$ $$$ ( 1 \le n \le 2 \cdot 100000 ) $$$ — number flint guess test case print : first second test case prove four different positive integers least three nearly prime third test case $$$ <unknown> \cdot 7 + 10 + 6 + 1 $$$ : integers $$$ 14 $$$ $$$ 10 $$$ $$$ 6 $$$ nearly prime fourth test case $$$ <unknown> + 6 + 10 + 15 $$$ : integers $$$ 6 $$$ $$$ 10 $$$ $$$ 15 $$$ nearly prime fifth test case $$$ <unknown> \cdot 3 + 7 + 10 + 21 $$$ : integers $$$ 6 $$$ $$$ 10 $$$ $$$ 21 $$$ nearly prime sixth test case $$$ <unknown> + 10 + 33 + 55 $$$ : integers $$$ 10 $$$ $$$ 33 $$$ $$$ 55 $$$ nearly prime seventh test case $$$ <unknown> \cdot 5 + 21 + 221 + 6 $$$ : integers $$$ 10 $$$ $$$ 21 $$$ $$$ 221 $$$ $$$ 6 $$$ nearly prime,"['brute force', 'greedy', 'math', 'number theory']",800.0
1388/C,uncle bogdan captain flint 's crew a long time sometimes get <unknown> homeland today tell country introduce a happiness index $$$ n $$$ cities $$$ n−1 $$$ undirected roads connect pair cities citizens city reach city travel roads cities number $$$ 1 $$$ $$$ n $$$ city $$$ 1 $$$ a capital word country a tree structure $$$ m $$$ citizens live country a $$$ p_i $$$ people live $$$ i $$$ -th city work capital even citizens return home cities use shortest paths every person mood : somebody leave workplace good mood somebody already bad mood moreover person ruin mood way hometown person bad mood wo n't improve happiness <unknown> instal city monitor happiness person visit city detector $$$ i $$$ -th city calculate a happiness index $$$ h_i $$$ number people good mood minus number people bad mood let 's say simplicity mood a person n't change inside city happiness detector still development a probability a mistake judge a person 's happiness one late even citizens successfully return home government ask uncle bogdan ( best programmer country ) check correctness collect happiness index uncle bogdan successfully solve problem ? formally need check : ` ` possible people return home city $$$ i $$$ happiness index equal exactly $$$ h_i $$$ ` ` first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100000 $$$ ; $$$ 0 \le m \le 1000000000 $$$ ) — number cities citizens second line test case contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p _ { n } $$$ ( $$$ 0 \le p_i \le m $$$ ; $$$ p_1 + p_2 + \ldots + p _ { n } = m $$$ ) $$$ p_i $$$ number people live $$$ i $$$ -th city third line contain $$$ n $$$ integers $$$ h_1 h_2 \ldots h _ { n } $$$ ( $$$ -1000000000 \le h_i \le 1000000000 $$$ ) $$$ h_i $$$ calculate happiness index $$$ i $$$ -th city next $$$ n − 1 $$$ line contain description roads one per line line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ ; $$$ x_i \neq y_i $$$ ) $$$ x_i $$$ $$$ y_i $$$ cities connect $$$ i $$$ -th road 's guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print yes collect data correct — otherwise print character yes case let 's look first test case first sample : first citizens capital let 's describe one possible scenarios : second case first test : people already start bad mood capital — possible scenario first case second test : second case second test : prove way achieve give happiness index case second test,"['dfs and similar', 'greedy', 'math', 'trees']",1800.0
1388/D,captain <unknown> involve another treasure hunt find one strange problem problem may connect treasure 's location may 's captain flint decide leave solve problem crew offer <unknown> high reward : one day problem sound like ... two array $$$ a $$$ $$$ b $$$ length $$$ n $$$ initially $$$ ans $$$ equal $$$ 0 $$$ follow operation define : maximum $$$ ans $$$ get perform operation $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) exactly ? uncle bogdan eager get reward ask help find optimal order position perform operation first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length array $$$ a $$$ $$$ b $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ <unknown> \le a_i \le 1000000 $$$ ) third line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1 \le b_i \le n $$$ $$$ b_i = -1 $$$ ) additional constraint : 's guarantee $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) sequence $$$ b_i b _ { b_i } b _ { b _ { b_i } } \ldots $$$ cyclic word always end $$$ -1 $$$ first line print maximum $$$ ans $$$ get second line print order operations : $$$ n $$$ different integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) $$$ p_i $$$ position choose $$$ i $$$ -th step multiple order print,"['data structures', 'dfs and similar', 'graphs', 'greedy', 'implementation', 'trees']",2000.0
139/B,"buy apartment boris decide paper wall every room boris 's flat n room form a rectangular parallelepiped every room know length width height wall meter ( different room different dimension include height ) boris choose m type wallpaper paper wall room ( necessary use type ) type wallpaper sell roll a fix length width ( length naturally show long unfold roll ) addition type know price one roll type wallpaper type contain strip run along length roll glue strip must locate strictly vertically ( roll rotate even length less width ) besides a roll cut arbitrary manner joint glue piece also vertical addition room paper one type wallpaper piece roll use paper different room , room roll purchase separately also roll use completely buy apartment boris short cash want spend minimum money wallpaper help first line contain a positive integer n ( 1 ≤ n ≤ 500 ) — number room boris 's apartment next n line contain three space - separated positive integers — length width height wall a give room meter respectively next line contain a positive integer m ( 1 ≤ m ≤ 500 ) — number available wallpaper type follow m line contain three space - separated positive integers — length width meter a give wallpaper price one roll respectively number input data exceed 500 . guarantee room paper use type wallpaper print a single number — minimum total cost roll note sample : total length wall ( perimeter ) room 20 m. one roll first type cut piece get three vertical 1 meter wide strip ergo need 7 roll type price equal 700 . a roll second type cut piece get five 2 meter wide strip need 2 roll price <unknown> . one roll third type immediately paper 19 meter 20 use type buy a second roll price 1000","['implementation', 'math']",1600.0
1391/C,"a permutation length $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) consider a permutation $$$ p $$$ length $$$ n $$$ build a graph size $$$ n $$$ use follow : case $$$ j $$$ exist make edge also note make edge correspond indices value indices clarity consider example $$$ n = 4 $$$ $$$ p = [ 3,1,4,2 ] $$$ ; edge graph $$$ ( 1,3 ) ( 2,1 ) ( 2,3 ) ( 4,3 ) $$$ a permutation $$$ p $$$ cyclic graph build use $$$ p $$$ least one simple cycle give $$$ n $$$ find number cyclic permutations length $$$ n $$$ since number may large output modulo $$$ 1000000000 + 7 $$$ please refer note section formal definition a simple <unknown> first line contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 1000000 $$$ ) output a single integer $$$ 0 \leq x < 1000000000 + 7 $$$ number cyclic permutations length $$$ n $$$ modulo $$$ 1000000000 + 7 $$$ $$$ 16 $$$ cyclic permutations $$$ n = 4 $$$ $$$ [ 4,2,1,3 ] $$$ one permutation a cycle length four : $$$ 4 \rightarrow 3 \rightarrow 2 \rightarrow 1 \rightarrow 4 $$$ nod $$$ v_1 $$$ $$$ v_2 $$$ $$$ \ldots $$$ $$$ v_k $$$ form a simple cycle follow condition hold :","['combinatorics', 'dp', 'graphs', 'math']",1500.0
1392/B,stick home ray become extremely bore pass time ask lord omkar use time bend power : infinity clock ! however lord omkar listen mortals solve follow problem : give array $$$ a $$$ $$$ n $$$ integers also give integer $$$ k $$$ lord omkar want $$$ k $$$ operations array define one operation follow : goal predict content array $$$ k $$$ operations please help ray determine final sequence look like ! test contain multiple test case first line contain number case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 2 \cdot 100000 1 \leq k \leq 10^ { 18 } $$$ ) – length array number operations perform second line test case contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } ... a _ { n } $$$ $$$ ( -1000000000 \leq a _ { i } \leq 1000000000 ) $$$ – initial content array guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ case print final version array $$$ a $$$ $$$ k $$$ operations describe first test case array change follow : initially array $$$ [ -199 192 ] $$$ $$$ d = 192 $$$ operation array become $$$ [ <unknown> ( -199 ) <unknown> ] = [ 391 0 ] $$$,"['implementation', 'math']",800.0
1392/F,omkar stand foot <unknown> mountain summit $$$ n $$$ meter away see mountains summit $$$ 1 \leq j \leq n $$$ know height mountain point $$$ j $$$ meter away $$$ h_j $$$ meter turn $$$ j $$$ satisfy $$$ 1 \leq j \leq n - 1 $$$ $$$ h_j < h _ { j + 1 } $$$ ( mean heights strictly increase ) suddenly a landslide occur ! landslide occur follow occur : every minute $$$ h_j + 2 \leq h _ { j + 1 } $$$ one square meter dirt slide position $$$ j + 1 $$$ position $$$ j $$$ $$$ h _ { j + 1 } $$$ decrease $$$ 1 $$$ $$$ h_j $$$ increase $$$ 1 $$$ change occur simultaneously example $$$ h_j + 2 \leq h _ { j + 1 } $$$ $$$ h _ { j + 1 } + 2 \leq h _ { j + 2 } $$$ $$$ j $$$ $$$ h_j $$$ increase $$$ 1 $$$ $$$ h _ { j + 2 } $$$ decrease $$$ 1 $$$ $$$ h _ { j + 1 } $$$ increase decrease $$$ 1 $$$ mean effect $$$ h _ { j + 1 } $$$ unchanged minute landslide end $$$ j $$$ $$$ h_j + 2 \leq h _ { j + 1 } $$$ help omkar figure value $$$ h_1 \dots h_n $$$ landslide end prove give constraints landslide always end finitely many minutes note large amount input recommend code use fast io first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000000 $$$ ) second line contain $$$ n $$$ integers $$$ h_1 h_2 \dots h_n $$$ satisfy $$$ 0 \leq h_1 < h_2 < \dots < h_n \leq 10^ { 12 } $$$ — heights output $$$ n $$$ integers $$$ j $$$ -th integer value $$$ h_j $$$ landslide stop initially mountain heights $$$ 2 6 7 8 $$$ first minute $$$ 2 + 2 \leq 6 $$$ $$$ 2 $$$ increase $$$ 3 $$$ $$$ 6 $$$ decrease $$$ 5 $$$ leave $$$ 3 5 7 8 $$$ second minute $$$ 3 + 2 \leq 5 $$$ $$$ 5 + 2 \leq 7 $$$ $$$ 3 $$$ increase $$$ 4 $$$ $$$ 5 $$$ unchanged $$$ 7 $$$ decrease $$$ 6 $$$ leave $$$ 4 5 6 8 $$$ third minute $$$ 6 + 2 \leq 8 $$$ $$$ 6 $$$ increase $$$ 7 $$$ $$$ 8 $$$ decrease $$$ 7 $$$ leave $$$ 4 5 7 7 $$$ fourth minute $$$ 5 + 2 \leq 7 $$$ $$$ 5 $$$ increase $$$ 6 $$$ $$$ 7 $$$ decrease $$$ 6 $$$ leave $$$ 4 6 6 7 $$$ fifth minute $$$ 4 + 2 \leq 6 $$$ $$$ 4 $$$ increase $$$ 5 $$$ $$$ 6 $$$ decrease $$$ 5 $$$ leave $$$ 5 5 6 7 $$$ sixth minute nothing else change landslide stop answer $$$ 5 5 6 7 $$$,"['binary search', 'data structures', 'greedy', 'math']",2400.0
1393/E2,a harder version problem e larger constraints twilight sparkle receive a new task princess celestia time ask decipher ancient scroll contain important knowledge pony origin hide crucial information evil eye pony elders cast a spell scroll spell add exactly one letter place word cast make path knowledge tangle elders choose word scroll cast a spell twilight sparkle know elders admire order things scroll original scroll contain word lexicographically non - decreasing order ask delete one letter word scroll ( undo spell ) get version original scroll unfortunately may one way recover ancient scroll let important knowledge slip twilight look variants original scroll find require one estimate maximum time twilight may spend work need know number variants look ask find number ! since number big twilight ask find modulo $$$ 1000000000 + 7 $$$ may occur princess celestia send a wrong scroll answer may exist a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ one follow hold : first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) : number word scroll $$$ i $$$ -th next $$$ n $$$ line contain a string consist lowercase english letter : $$$ i $$$ -th word scroll length word least one sum lengths word exceed $$$ 1000000 $$$ print one integer : number ways get a version original scroll modulo $$$ 1000000000 + 7 $$$ notice elders could write empty word ( surely cast a spell hold a length $$$ 1 $$$ ),"['dp', 'implementation', 'strings', 'two pointers']",3200.0
1395/A,boboniu give <unknown> allow follow operation many time want : answer 's possible arrange ball a palindrome several ( possibly zero ) number describe operations first line contain one integer $$$ t $$$ ( $$$ 1\le t\le 100 $$$ ) denote number test case next $$$ t $$$ case first line contain four integers $$$ r $$$ $$$ g $$$ $$$ b $$$ $$$ w $$$ ( $$$ 0\le r g b w\le 1000000000 $$$ ) test case print ` ` yes '' 's possible arrange ball a palindrome several ( possibly zero ) number describe operations otherwise print ` ` '' first test case 're able operation never arrange three ball distinct color a palindrome second test case one operation change $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ one possible palindromes may ` ` <unknown> '' a palindrome a word phrase sequence read backwards forward example ` ` <unknown> '' ` ` b '' ` ` gg '' palindromes ` ` <unknown> '' ` ` <unknown> '' notice empty word phrase sequence palindrome,"['brute force', 'math']",1000.0
1398/C,give array $$$ a_1 a_2 \dots a_n $$$ consist integers $$$ 0 $$$ $$$ 9 $$$ a subarray $$$ a_l a _ { l+1 } a _ { l+2 } \dots a _ { r-1 } a_r $$$ good sum elements subarray equal length subarray ( $$$ \sum\limits _ { i = l } ^ { r } a_i = r - l + 1 $$$ ) example $$$ a = [ 1 2 0 ] $$$ $$$ 3 $$$ good subarrays : $$$ a _ { 1 \dots 1 } = [ 1 ] a _ { 2 \dots 3 } = [ 2 0 ] $$$ $$$ a _ { 1 \dots 3 } = [ 1 2 0 ] $$$ calculate number good subarrays array $$$ a $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length array $$$ a $$$ second line test case contain a string consist $$$ n $$$ decimal digits $$$ i $$$ -th digit equal value $$$ a_i $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print one integer — number good subarrays array $$$ a $$$ first test case consider statement second test case $$$ 6 $$$ good subarrays : $$$ a _ { 1 \dots 1 } $$$ $$$ a _ { 2 \dots 2 } $$$ $$$ a _ { 1 \dots 2 } $$$ $$$ a _ { 4 \dots 4 } $$$ $$$ a _ { 5 \dots 5 } $$$ $$$ a _ { 4 \dots 5 } $$$ third test case one good subarray : $$$ a _ { 2 \dots 6 } $$$,"['data structures', 'dp', 'math']",1600.0
1398/F,alice bob play a game game consist several set set consist several round round either alice bob set end one players $$$ x $$$ round a row example bob five round a row $$$ x = 2 $$$ two set end know alice bob already play $$$ n $$$ round know result round $$$ x $$$ $$$ 1 $$$ $$$ n $$$ calculate maximum possible number set could already finish set last one players win $$$ x $$$ round a row possible last set still finish — case count answer first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — number round second line contain one string $$$ s $$$ length $$$ n $$$ — descriptions round $$$ i $$$ -th element string 0 alice $$$ i $$$ -th round ; 1 bob $$$ i $$$ -th round ? n't know $$$ i $$$ -th round line print $$$ n $$$ integers $$$ i $$$ -th integer equal maximum possible number set could already finish set last one players win $$$ i $$$ round a row let 's consider first test case :,"['binary search', 'data structures', 'dp', 'greedy', 'two pointers']",2500.0
1399/E2,easy hard versions actually different problems advise read statements carefully give a weight root tree vertex $$$ 1 $$$ root tree also edge cost a tree a connect graph without cycle a root tree a special vertex call root a parent a vertex $$$ v $$$ last different $$$ v $$$ vertex path root vertex $$$ v $$$ children vertex $$$ v $$$ vertices $$$ v $$$ parent a vertex a leaf children weight tree a tree edge tree weight weight path sum edge weight path weight path vertex $$$ 0 $$$ make a sequence zero move move select edge divide weight $$$ 2 $$$ round formally one move choose edge $$$ i $$$ divide weight $$$ 2 $$$ round ( $$$ w_i : = \left\lfloor\frac { w_i } { 2 } \right\rfloor $$$ ) edge $$$ i $$$ associate cost $$$ c_i $$$ either $$$ 1 $$$ $$$ 2 $$$ coin move edge $$$ i $$$ cost $$$ c_i $$$ coin task find minimum total cost make sum weight paths root leaf $$$ s $$$ word $$$ w ( i j ) $$$ weight path vertex $$$ i $$$ vertex $$$ j $$$ make $$$ \sum\limits _ { v \in leave } w ( root v ) \le s $$$ $$$ leave $$$ list leave answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ s $$$ ( $$$ 2 \le n \le 100000 ; 1 \le s \le 10^ { 16 } $$$ ) — number vertices tree maximum possible sum weight obtain next $$$ n-1 $$$ line describe edge tree edge $$$ i $$$ describe four integers $$$ v_i $$$ $$$ u_i $$$ $$$ w_i $$$ $$$ c_i $$$ ( $$$ 1 \le v_i u_i \le n ; 1 \le w_i \le 1000000 ; 1 \le c_i \le 2 $$$ ) $$$ v_i $$$ $$$ u_i $$$ vertices edge $$$ i $$$ connect $$$ w_i $$$ weight edge $$$ c_i $$$ cost edge guarantee sum $$$ n $$$ exceed $$$ 100000 $$$ ( $$$ \sum n \le 100000 $$$ ) test case print answer : minimum total cost require make sum weight paths root leaf $$$ s $$$,"['binary search', 'dfs and similar', 'greedy', 'sortings', 'trees', 'two pointers']",2200.0
1401/A,"a point $$$ a $$$ coordinate $$$ x = n $$$ $$$ ox $$$ -axis 'd like find integer point $$$ b $$$ ( also $$$ ox $$$ -axis ) absolute difference distance $$$ o $$$ $$$ b $$$ distance $$$ a $$$ $$$ b $$$ equal $$$ k $$$ since sometimes 's impossible find point $$$ b $$$ , one step increase decrease coordinate $$$ a $$$ $$$ 1 $$$ minimum number step make point $$$ b $$$ exist ? first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 6000 $$$ ) — number test case line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 0 \le n k \le 1000000 $$$ ) — initial position point $$$ a $$$ desirable absolute difference test case print minimum number step make point $$$ b $$$ exist first test case ( picture ) set coordinate $$$ b $$$ $$$ 2 $$$ absolute difference equal $$$ | ( 2 - 0 ) - ( 4 - 2 ) | = 0 $$$ n't move $$$ a $$$ answer $$$ 0 $$$ second test case increase coordinate $$$ a $$$ $$$ 3 $$$ set coordinate $$$ b $$$ $$$ 0 $$$ $$$ 8 $$$ absolute difference equal $$$ |8 - 0| = 8 $$$ answer $$$ 3 $$$",['math'],900.0
1401/B,"give two sequence $$$ a_1 a_2 \dots a_n $$$ $$$ b_1 b_2 \dots b_n $$$ element sequence either $$$ 0 $$$ $$$ 1 $$$ $$$ 2 $$$ number elements $$$ 0 $$$ $$$ 1 $$$ $$$ 2 $$$ sequence $$$ a $$$ $$$ x_1 $$$ $$$ y_1 $$$ $$$ z_1 $$$ respectively number elements $$$ 0 $$$ $$$ 1 $$$ $$$ 2 $$$ sequence $$$ b $$$ $$$ x_2 $$$ $$$ y_2 $$$ $$$ z_2 $$$ respectively rearrange elements sequence $$$ a $$$ $$$ b $$$ however like , let 's define a sequence $$$ c $$$ follow : $$$ c_i = \begin { case } a_i b_i & \mbox { } a_i > b_i \\ 0 & \mbox { } a_i = b_i \\ -a_i b_i & \mbox { } a_i < b_i \end { case } $$$ 'd like make $$$ \sum _ { i=1 } ^n c_i $$$ ( sum elements sequence $$$ c $$$ ) large possible maximum possible sum ? first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist two line first line test case contain three integers $$$ x_1 $$$ $$$ y_1 $$$ $$$ z_1 $$$ ( $$$ 0 \le x_1 y_1 z_1 \le 100000000 $$$ ) — number $$$ 0 $$$ -s $$$ 1 $$$ -s $$$ 2 $$$ -s sequence $$$ a $$$ second line test case also contain three integers $$$ x_2 $$$ $$$ y_2 $$$ $$$ z_2 $$$ ( $$$ 0 \le x_2 y_2 z_2 \le 100000000 $$$ ; $$$ x_1 + y_1 + z_1 = x_2 + y_2 + z_2 > 0 $$$ ) — number $$$ 0 $$$ -s $$$ 1 $$$ -s $$$ 2 $$$ -s sequence $$$ b $$$ test case print maximum possible sum sequence $$$ c $$$ first sample one optimal solutions : $$$ a = \ { 2 0 1 1 0 2 1\ } $$$ $$$ b = \ { 1 0 1 0 2 1 0\ } $$$ $$$ c = \ { 2 0 0 0 0 2 0\ } $$$ second sample one optimal solutions : $$$ a = \ { 0 2 0 0 0\ } $$$ $$$ b = \ { 1 1 0 1 0\ } $$$ $$$ c = \ { 0 2 0 0 0\ } $$$ third sample possible solution : $$$ a = \ { 2\ } $$$ $$$ b = \ { 2\ } $$$ $$$ c = \ { 0\ } $$$","['greedy', 'math']",1100.0
1401/C,give array $$$ a_1 a_2 \dots a_n $$$ $$$ a_i $$$ integers greater $$$ 0 $$$ one operation choose two different indices $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i j \le n $$$ ) $$$ gcd ( a_i a_j ) $$$ equal minimum element whole array $$$ a $$$ swap $$$ a_i $$$ $$$ a_j $$$ $$$ gcd ( x y ) $$$ denote greatest common divisor ( gcd ) integers $$$ x $$$ $$$ y $$$ 'd like make $$$ a $$$ non - decreasing use operation number time ( possibly zero ) determine array $$$ a $$$ non - decreasing $$$ a_1 \le a_2 \le \ldots \le a_n $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length array $$$ a $$$ second line test case contain $$$ n $$$ positive integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — array guarantee sum $$$ n $$$ test case n't exceed $$$ 100000 $$$ test case output ` ` yes '' possible make array $$$ a $$$ non - decreasing use describe operation ` ` '' impossible first third sample array already non - decreasing second sample swap $$$ a_1 $$$ $$$ a_3 $$$ first swap $$$ a_1 $$$ $$$ a_5 $$$ second make array non - decreasing forth sample array non - decreasing use operation,"['math', 'number theory', 'sortings']",1300.0
1402/A,"everybody know <unknown> <unknown> fence whole town 's build $$$ n $$$ fancy section section rectangles stand closely next grind $$$ i $$$ th section integer height $$$ h_i $$$ integer width $$$ w_i $$$ look fancy rectangles fancy fence a rectangle fancy : first line contain $$$ n $$$ ( $$$ 1\leq n \leq 10^ { 5 } $$$ ) – number section second line contain $$$ n $$$ space - separated integers $$$ i $$$ th number $$$ h_i $$$ ( $$$ 1 \leq h_i \leq 10^ { 9 } $$$ ) third line contain $$$ n $$$ space - separated integers $$$ i $$$ th number $$$ w_i $$$ ( $$$ 1 \leq w_i \leq 10^ { 9 } $$$ ) print a single integer number fancy rectangles modulo $$$ 1000000000 + 7 $$$ output range $$$ 0,1,2 \ldots 1000000000 + 6 $$$ fence look like : 5 fancy rectangles shape : 3 fancy rectangles shape : 1 fancy rectangle shape : 2 fancy rectangles shape : 1 fancy rectangle shape :","['data structures', 'dsu', 'implementation', 'math', 'sortings']",1800.0
1402/C,unite federation planets alliance $$$ n $$$ planets index $$$ 1 $$$ $$$ n $$$ planets connect space tunnel a space tunnel a starship fly ways really fast exactly $$$ n-1 $$$ space tunnel travel planet planet federation use tunnel 's well know $$$ d $$$ additional parallel universes exact copy universe planets space tunnel index $$$ 1 $$$ $$$ d $$$ ( universe index $$$ 0 $$$ ) denote planet $$$ x $$$ universe $$$ i $$$ $$$ p_x^i $$$ travel one universe another use dimension portals every $$$ i $$$ ( $$$ 0\leq i \leq d-1 $$$ ) place exactly one portal allow us fly $$$ p _ { a_i } ^i $$$ $$$ p _ { b_i } ^ { i+1 } $$$ planet indices $$$ a_i $$$ $$$ b_i $$$ ( i.e $$$ 1 \leq a_i b_i \leq n $$$ ) portals place starship <unknown> embark <unknown> <unknown> currently orbit around $$$ p_1 ^ 0 $$$ captain ágnes lieutenant gábor decide play follow game : choose alternately a destination ( a planet ) fly planet universe a space tunnel go another universe a portal go aim visit place one go 's visit a planet $$$ p_x^i $$$ never go back ( visit planet $$$ x $$$ another universe ) captain ágnes choose first destination ( gábor ágnes etc . ) somebody ca n't choose a planet his / her turn he / she lose captain ágnes lieutenant gábor clever : know locations tunnel portals play optimally many different placements portals captain ágnes win game ? two placements different index $$$ i $$$ ( $$$ 0\leq i \leq d-1 $$$ ) $$$ i $$$ th portal connect different pair planets two placements ( i.e $$$ a_i $$$ $$$ b_i $$$ differ ) number big interest modulo $$$ 1000000000 + 7 $$$ first line contain two space - separated integers $$$ n $$$ ( $$$ 1\leq n \leq 10^ { 5 } $$$ ) – number planets $$$ d $$$ ( $$$ 1 \leq d \leq 10^ { 18 } $$$ ) – number additional parallel universes next $$$ n-1 $$$ line contain two space - separated integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \leq u v \leq n $$$ ) denote $$$ <unknown> $$$ $$$ <unknown> $$$ connect a space tunnel $$$ i $$$ ( $$$ 0 \leq i \leq d $$$ ) print a single integer number possible placements portals captain ágnes win modulo $$$ 1000000000 + 7 $$$ 1 portal $$$ 9 = 9 $$$ different placements follow 4 placements captain win,"['combinatorics', 'dfs and similar', 'dp', 'graphs', 'trees']",2600.0
1403/A,"upon a time land shamans everyone live sky - high <unknown> shaman a unique identify number $$$ i $$$ $$$ 0 $$$ $$$ n-1 $$$ altitude value $$$ h_i $$$ represent high live grind level distance two altitudes absolute value difference shamans live together peace one steal formula world - famous potion great power cover his / her track thief put a curse land : inhabitants could longer trust ... despite difficult circumstances order good <unknown> gain follow information curse : believe thief whisper formula evil shaman avoid detection visit home one ( respective ) trust friends visit thief whisper formula evil shaman window ( note : trust friend home time fact 's even possible visit 's house – shamans weird ) fortunately whisper travel short distance order know two trust friends visit ( thief evil shaman ) must live close ask help investigation would like test suspicions : thief $$$ x $$$ evil shaman $$$ y $$$ formula whisper day $$$ v $$$ ? smallest distance whisper formula travel ? , minimum distance apartments shamans $$$ x ' $$$ $$$ y ' $$$ ( i.e $$$ \min\left ( <unknown> _ { x ' } - h _ { y ' } <unknown> ) $$$ ) $$$ x ' $$$ a trust friend $$$ x $$$ $$$ y ' $$$ a trust friend $$$ y $$$ day $$$ v $$$ ? share information ask a number question need answer question immediately receive next one interaction begin a line contain $$$ n $$$ $$$ d $$$ $$$ u $$$ $$$ q $$$ $$$ ( 2 \leq n \leq 100000 $$$ $$$ 1 \leq d \leq 500 $$$ $$$ 0 \leq u \leq 200000 $$$ $$$ 1 \leq q \leq 50000 ) $$$ – number shamans maximum number trust friends a shaman give point number days number question next line $$$ n $$$ space separate integers follow $$$ i $$$ th $$$ ( 1\leq i \leq n ) $$$ $$$ h _ { i-1 } $$$ $$$ ( 0\leq h _ { i-1 } \leq 1000000000 ) $$$ altitude shaman $$$ i-1 $$$ next $$$ u $$$ line two integers $$$ i $$$ th ( $$$ 1 \leq i \leq u $$$ ) $$$ a_i $$$ $$$ b_i $$$ $$$ ( 0 \leq a_i b_i < n $$$ $$$ a_i \neq b_i ) $$$ represent a pair shamans start stop trust end day $$$ i-1 $$$ , $$$ a_i $$$ $$$ b_i $$$ trust day $$$ i-1 $$$ trust day $$$ i $$$ vice versa read integers interactor ask $$$ q $$$ question follow interaction happen $$$ q $$$ time : print line forget output end line flush output otherwise get idleness limit exceed , use : example query : evolution friendships :","['binary search', 'data structures', 'graphs', 'sortings', 'two pointers']",2400.0
1404/D,"interactive problem consider a fix positive integer $$$ n $$$ two players first second play a game follow : determine winner game compute sum number choose second sum number a multiple $$$ 2n $$$ second win otherwise first win give integer $$$ n $$$ task decide player wish play win game interaction begin read integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) read print a single line contain either first second denote want play interaction vary depend choose play choose play first print a single line contain $$$ 2n $$$ integers $$$ p_1 p_2 \dots p _ { 2n } $$$ denote number $$$ i $$$ belong $$$ p_i $$$ -th pair $$$ 1\le i \le 2n $$$ thus $$$ 1 \le p_i \le n $$$ every number $$$ 1 $$$ $$$ n $$$ inclusive appear exactly twice choose play second interactor print $$$ 2n $$$ integers $$$ p_1 p_2 \dots p _ { 2n } $$$ denote number $$$ i $$$ belong $$$ p_i $$$ -th pair a response print $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ a single line contain exactly one number pair regardless choose play interactor finish print a single integer : $$$ 0 $$$ answer test case correct ( play first choose adequate number pair play second choose number add a multiple $$$ 2n $$$ ) $$$ -1 $$$ incorrect particular interactor print choose number choose play first lose either case program terminate immediately read number point make invalid interaction interactor print $$$ -1 $$$ finish interaction receive a wrong answer verdict make sure terminate immediately avoid get verdicts print something forget output end line flush output otherwise get idleness limit exceed , use : hack formatto hack use follow format : first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) second line contain $$$ 2n $$$ integers $$$ p_1 p_2 \dots p _ { 2n } $$$ denote number $$$ i $$$ belong $$$ p_i $$$ -th pair solution hack choose play second solution hack choose play first pair n't matter $$$ p_1 p_2 \dots p _ { 2n } $$$ must still form a valid partition $$$ 1 2 \dots 2n $$$ $$$ n $$$ disjoint pair first sample $$$ n = 2 $$$ decide play second judge choose pair $$$ ( 1 2 ) $$$ $$$ ( 3 4 ) $$$ reply number $$$ 1 $$$ $$$ 3 $$$ a valid choice since contain exactly one number pair sum $$$ 1 + 3 = 4 $$$ divisible $$$ 4 $$$ second sample $$$ n = 2 $$$ play first choose pair $$$ ( 2 4 ) $$$ $$$ ( 1 3 ) $$$ judge fail choose a number pair sum divisible $$$ 4 $$$ answer correct note sample test illustration interaction protocol n't necessarily correspond behavior real interactor","['dfs and similar', 'math', 'number theory']",2800.0
1406/A,"give a set integers ( contain equal elements ) split two subsets $$$ a $$$ $$$ b $$$ ( contain equal elements empty ) maximize value $$$ mex ( a ) + mex ( b ) $$$ $$$ mex $$$ a set denote smallest non - negative integer n't exist set example : set splitted two subsets $$$ a $$$ $$$ b $$$ integer number $$$ x $$$ number occurrences $$$ x $$$ set equal sum number occurrences $$$ x $$$ $$$ a $$$ number occurrences $$$ x $$$ $$$ b $$$ input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1\leq t\leq 100 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1\leq n\leq 100 $$$ ) — size set second line testcase contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0\leq a_i\leq 100 $$$ ) — number set test case print maximum value $$$ mex ( a ) + mex ( b ) $$$ first test case $$$ a=\left\ { 0,1,2\right\ } b=\left\ { <unknown> } $$$ a possible choice second test case $$$ a=\left\ { 0,1,2\right\ } <unknown> $$$ a possible choice third test case $$$ a=\left\ { 0,1,2\right\ } b=\left\ { <unknown> } $$$ a possible choice fourth test case $$$ a=\left\ { <unknown> } b=\left\ { <unknown> } $$$ a possible choice","['greedy', 'implementation', 'math']",900.0
1408/B,give a non - decreasing array non - negative integers $$$ a_1 a_2 \ldots a_n $$$ also give a positive integer $$$ k $$$ want find $$$ m $$$ non - decreasing array non - negative integers $$$ b_1 b_2 \ldots b_m $$$ : find minimum possible value $$$ m $$$ report possible $$$ m $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) : number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 100 $$$ $$$ 1 \leq k \leq n $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_1 \leq a_2 \leq \ldots \leq a_n \leq 100 $$$ $$$ a_n > 0 $$$ ) test case print a single integer : minimum possible value $$$ m $$$ $$$ m $$$ print $$$ -1 $$$ first test case possible $$$ m $$$ elements array equal $$$ 0 $$$ case impossible get $$$ a_4 = 1 $$$ sum zero second test case take $$$ b_1 = [ 3 3 3 ] $$$ $$$ 1 $$$ smallest possible value $$$ m $$$ third test case take $$$ b_1 = [ 0 1 1 1 2 2 2 2 2 2 2 ] $$$ $$$ b_2 = [ 0 0 1 1 1 1 1 2 2 2 2 ] $$$ 's easy see $$$ a_i = b _ { 1 i } + b _ { 2 i } $$$ $$$ i $$$ number different elements $$$ b_1 $$$ $$$ b_2 $$$ equal $$$ 3 $$$ ( $$$ 3 $$$ ) prove $$$ 2 $$$ smallest possible value $$$ m $$$,"['greedy', 'math']",1400.0
1411/D,currently xxoc 's rap a string consist zero ones question mark unfortunately haters gon na hate write $$$ x $$$ angry comment every occurrence subsequence 01 $$$ y $$$ angry comment every occurrence subsequence 10 . replace question mark 0 1 a way number angry comment would small possible string $$$ b $$$ a subsequence string $$$ a $$$ obtain remove character $$$ a $$$ two occurrences a subsequence consider distinct set position remain character distinct first line contain string $$$ s $$$ — xxoc 's rap ( $$$ 1 \le |s| \leq 100000 $$$ ) second line contain two integers $$$ x $$$ $$$ y $$$ — number angry comment xxoc recieve every occurrence 01 10 accordingly ( $$$ 0 \leq x y \leq 1000000 $$$ ) output a single integer — minimum number angry comment first example one optimum ways replace 001 . $$$ 2 $$$ subsequences 01 $$$ 0 $$$ subsequences 10 . total number angry comment equal $$$ 4 + 0 = 4 $$$ second example one optimum ways replace 11111 . $$$ 0 $$$ subsequences 01 $$$ 0 $$$ subsequences 10 . total number angry comment equal $$$ 0 + 0 = 0 $$$ third example one optimum ways replace 1100 . $$$ 0 $$$ subsequences 01 $$$ 4 $$$ subsequences 10 . total number angry comment equal $$$ 0 + 28 = 28 $$$ fourth example one optimum ways replace <unknown> . $$$ 8 $$$ subsequences 01 $$$ 8 $$$ subsequences 10 . total number angry comment equal $$$ 40 + 56 = 96 $$$,"['brute force', 'greedy', 'implementation', 'strings']",2100.0
1413/F,"land fire $$$ n $$$ villages $$$ n-1 $$$ bidirectional road a path pair villages roads two type roads : stone ones sand ones since land fire constantly renovate every morning workers choose a single road flip type ( become a stone road a sand road vice versa ) also everyone love ramen 's every morning a ramen <unknown> set middle every stone road end day <unknown> remove follow $$$ m $$$ days another road flip naruto jiraiya choose a simple path — a route start a village end a ( possibly ) village n't contain road twice since naruto jiraiya also love ramen much buy a single cup ramen stone road one eat since n't want offend choose rout eat equal number ramen cup since like travel choose longest possible path every renovation find maximal possible length a path ( number roads ) follow first line contain positive integer $$$ n $$$ ( $$$ 2 \leq n \leq 500\,000 $$$ ) stand number villages land fire follow $$$ ( n-1 ) $$$ line contain a description another road represent three positive integers $$$ u $$$ $$$ v $$$ $$$ t $$$ ( $$$ 1 \leq u v \leq n $$$ $$$ t \in \ { 0,1\ } $$$ ) first two number denote villages connect road third denote initial type road : $$$ 0 $$$ sand one $$$ 1 $$$ stone one roads number $$$ 1 $$$ $$$ ( n-1 ) $$$ order input follow line contain a positive integer $$$ m $$$ ( $$$ 1 \leq m \leq 500\,000 $$$ ) stand number days naruto jiraiya travel follow $$$ m $$$ line contain single integer $$$ i d $$$ ( $$$ 1 \leq i d \leq n-1 $$$ ) stand index road whose type flip morning correspond day guarantee a road path pair villages output $$$ m $$$ line $$$ i $$$ -th print integer denote maximal possible length valid path $$$ i $$$ -th day renovation $$$ 3 $$$ -rd road longest path consist roads $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$ renovation $$$ 4 $$$ -th road one longest paths consist roads $$$ 1 $$$ $$$ 2 $$$ renovation $$$ 1 $$$ -st road one longest paths consist roads $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ renovation $$$ 3 $$$ -rd road longest path consist roads $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$ renovation $$$ 4 $$$ -rd road one longest paths consist roads $$$ 2 $$$ $$$ 4 $$$","['data structures', 'trees']",2800.0
1415/D,"arkady own a non - decreasing array $$$ a_1 a_2 \ldots a_n $$$ jealous beauty want destroy property a so - called xor - gun use one time one step select two consecutive elements array let 's say $$$ x $$$ $$$ y $$$ remove array insert integer $$$ x \oplus y $$$ place $$$ \oplus $$$ denote bitwise xor operation note length array decrease one operation ca n't perform operation length array reach one example array $$$ [ 2 5 6 8 ] $$$ select $$$ 5 $$$ $$$ 6 $$$ replace $$$ 5 \oplus 6 = 3 $$$ array become $$$ [ 2 3 8 ] $$$ want array longer non - decreasing minimum number step need ? array stay non - decreasing matter print $$$ -1 $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — initial length array second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements array guarantee $$$ a_i \le a _ { i + 1 } $$$ $$$ 1 \le i < n $$$ print a single integer — minimum number step need solution print $$$ -1 $$$ first example select $$$ 2 $$$ $$$ 5 $$$ array become $$$ [ 7 6 8 ] $$$ second example obtain array $$$ [ 1 1 ] $$$ $$$ [ 3 3 ] $$$ $$$ [ 0 ] $$$ non - decreasing third example select $$$ 1 $$$ $$$ 2 $$$ array become $$$ [ 3 4 6 20 ] $$$ , example select $$$ 3 $$$ $$$ 4 $$$ array become $$$ [ 7 6 20 ] $$$ longer non - decreasing","['bitmasks', 'brute force']",2000.0
1416/C,give array $$$ a $$$ consist $$$ n $$$ non - negative integers choose a non - negative integer $$$ x $$$ form a new array $$$ b $$$ size $$$ n $$$ accord follow rule : $$$ i $$$ $$$ 1 $$$ $$$ n $$$ $$$ b_i = a_i \oplus x $$$ ( $$$ \oplus $$$ denote operation bitwise xor ) inversion $$$ b $$$ array a pair integers $$$ i $$$ $$$ j $$$ $$$ 1 \le i < j \le n $$$ $$$ b_i > b_j $$$ choose $$$ x $$$ a way number inversions $$$ b $$$ minimize several options $$$ x $$$ — output smallest one first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) — number elements $$$ a $$$ second line contain $$$ n $$$ space - separated integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ output two integers : minimum possible number inversions $$$ b $$$ minimum possible value $$$ x $$$ achieve number inversions first sample optimal leave array choose $$$ x = 0 $$$ second sample selection $$$ x = 14 $$$ result $$$ b $$$ : $$$ [ 4 9 7 4 9 11 11 13 11 ] $$$ $$$ 4 $$$ inversions : third sample selection $$$ x = 8 $$$ result $$$ b $$$ : $$$ [ 0 2 11 ] $$$ inversions,"['bitmasks', 'data structures', 'divide and conquer', 'dp', 'greedy', 'math', 'sortings', 'strings', 'trees']",2000.0
1418/A,play a popular game call <unknown> initially one stick want craft $$$ k $$$ torch one torch craft use one stick one coal hopefully ' ve meet a handsome wander trader two trade offer : one trade use one two trade offer use trade offer number time want order task find minimum number trade need craft least $$$ k $$$ torch answer always exist give constraints answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow line test case contain three integers $$$ x $$$ $$$ y $$$ $$$ k $$$ ( $$$ 2 \le x \le 1000000000 $$$ ; $$$ 1 \le y k \le 1000000000 $$$ ) — number stick buy one stick number stick require buy one coal number torch need respectively test case print answer : minimum number trade need craft least $$$ k $$$ torch answer always exist give constraints,['math'],1000.0
142/B,upon a time kingdom far far away live sir lancelot chief royal general proud men like invite king come watch drill exercise demonstrate fight techniques tactics squad charge time go one day sir lancelot a major argument fairy godmother ( rumor argument occur general speak badly godmother 's fly techniques seem hurt fairy godmother deeply ) result argument godmother put a rather strange curse upon general sound complicate quite harmless : ` ` square distance two soldier equal 5 soldier conflict ! ` ` drill exercise hold a rectangular n × m field split nm square 1 × 1 segment soldier thus square distance soldier stand square ( x1 y1 ) ( x2 y2 ) equal exactly ( x1 - x2 ) 2 + ( y1 - y2 ) 2 . nm squad soldier participate drill exercise fairy godmother 's curse unless course general want soldier fight even worse ... example put a soldier square ( 2 2 ) put soldier square ( 1 4 ) ( 3 4 ) ( 4 1 ) ( 4 3 ) — conflict soldier square ( 2 2 ) task help general give size drill exercise field ask calculate maximum number soldier simultaneously position field two soldier fall fairy godmother 's curse single line contain space - separated integers n m ( 1 ≤ n m ≤ 1000 ) represent size drill exercise field print desire maximum number warriors first sample test sir lancelot place 4 soldier 2 × 4 court follow ( soldier ' locations mark gray circle scheme ) : second sample test place 6 soldier 3 × 4 site follow manner :,"['greedy', 'implementation']",1800.0
1421/B,"pink floyd pull a prank roger water know n't like wall want able walk freely block exit room see a grid roger water a square grid size $$$ n\times n $$$ want traverse grid upper leave ( $$$ 1,1 $$$ ) corner lower right corner ( $$$ n n $$$ ) water move a square square adjacent a side long still grid also except cells ( $$$ 1,1 $$$ ) ( $$$ n n $$$ ) every cell a value $$$ 0 $$$ $$$ 1 $$$ start traversal pick either a $$$ 0 $$$ a $$$ 1 $$$ able go cells value equal digit choose start finish cells ( $$$ 1,1 $$$ ) ( $$$ n n $$$ ) <unknown> rule may go regardless pick digit cell ( $$$ 1,1 $$$ ) take value letter 's ' cell ( $$$ n n $$$ ) take value letter ' f ' example first example test case go ( $$$ 1 1 $$$ ) ( $$$ n n $$$ ) use zero path : ( $$$ 1 1 $$$ ) ( $$$ 2 1 $$$ ) ( $$$ 2 2 $$$ ) ( $$$ 2 3 $$$ ) ( $$$ 3 3 $$$ ) ( $$$ 3 4 $$$ ) ( $$$ 4 4 $$$ ) rest band ( pink floyd ) want water able traversal look invert two cells grid ( $$$ 0 $$$ $$$ 1 $$$ vice versa ) afraid quick enough ask help choose cells note invert cells $$$ ( 1 1 ) $$$ $$$ ( n n ) $$$ show always exist a solution give constraints also note water pick digit traversal band change grid must able reach ( $$$ n n $$$ ) matter digit pick test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 50 $$$ ) description test case follow first line test case contain one integers $$$ n $$$ ( $$$ 3 \le n \le 200 $$$ ) follow $$$ n $$$ line test case contain binary grid square ( $$$ 1 1 $$$ ) color 's ' square ( $$$ n n $$$ ) color ' f ' sum value $$$ n $$$ n't exceed $$$ 200 $$$ test case output first line integer $$$ c $$$ ( $$$ 0 \le c \le 2 $$$ ) — number invert cells $$$ i $$$ -th follow $$$ c $$$ line print coordinate $$$ i $$$ -th cell invert may invert cell twice note invert cells $$$ ( 1 1 ) $$$ $$$ ( n n ) $$$ first test case invert cell get follow grid :",['implementation'],1100.0
1421/E,play yet another strategy game man recruit $$$ n $$$ <unknown> heroes whose power represent array $$$ a $$$ unfortunately mighty heroes create capable want decide something order accomplish goal pick two consecutive heroes power $$$ a_i $$$ $$$ a _ { i+1 } $$$ remove insert a hero power $$$ - ( a_i+a _ { i+1 } ) $$$ back position example array contain elements $$$ [ 5 6 7 8 ] $$$ pick $$$ 6 $$$ $$$ 7 $$$ get $$$ [ 5 - ( 6 + 7 ) 8 ] = [ 5 -13 8 ] $$$ perform operation $$$ n-1 $$$ time man end one hero want power big possible 's largest possible power achieve ? first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) — power heroes print largest possible power achieve $$$ n-1 $$$ operations suitable list operations first sample : $$$ [ 5 6 7 8 ] \rightarrow [ -11 7 8 ] \rightarrow [ -11 -15 ] \rightarrow [ 26 ] $$$,"['brute force', 'dp', 'implementation']",2700.0
1422/C,sometimes easy come agreement a bargain right sasha vova ca n't come agreement : sasha name a price high possible vova want remove many digits price possible detail sasha name integer price $$$ n $$$ vova remove a non - empty substring ( consecutive ) digits price remain digits close gap result integer price example sasha name $$$ <unknown> $$$ vova remove substring $$$ <unknown> $$$ result $$$ 121 $$$ allow result contain lead zero vova remove digits price consider $$$ 0 $$$ sasha want come constraints vova ca n't remove digits need arguments support constraints start want compute sum possible result price vova 's move help sasha compute sum since answer large print modulo $$$ 1000000000 + 7 $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \le n < 10^ { 100000 } $$$ ) line print require sum modulo $$$ 1000000000 + 7 $$$ consider first example vova choose remove $$$ 1 $$$ $$$ 0 $$$ $$$ 7 $$$ $$$ 10 $$$ $$$ 07 $$$ $$$ 107 $$$ result $$$ 07 $$$ $$$ 17 $$$ $$$ 10 $$$ $$$ 7 $$$ $$$ 1 $$$ $$$ 0 $$$ sum $$$ 42 $$$,"['combinatorics', 'dp', 'math']",1700.0
1423/K,number world two different number friends a lot common also one unique perk precisely two different number $$$ a $$$ $$$ b $$$ friends $$$ gcd ( a b ) $$$ $$$ \frac { a } { gcd ( a b ) } $$$ $$$ \frac { b } { gcd ( a b ) } $$$ form side a triangle three number $$$ a $$$ $$$ b $$$ $$$ c $$$ form side a triangle $$$ a + b > c $$$ $$$ b + c > a $$$ $$$ c + a > b $$$ a group number a number lonely n't friends group give a group number contain number $$$ 1 2 3 ... n $$$ many number group lonely ? first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000000 ) $$$ - number test case next line $$$ t $$$ number $$$ n_i $$$ $$$ ( 1 \leq n_i \leq 1000000 ) $$$ - mean case $$$ i $$$ solve number $$$ 1 2 3 ... n_i $$$ test case print answer separate line : number lonely number group $$$ 1 2 3 ... n_i $$$ first test case $$$ 1 $$$ number therefore lonely second test case $$$ n=5 $$$ number $$$ 1 $$$ $$$ 3 $$$ $$$ 5 $$$ lonely third test case $$$ n=10 $$$ number $$$ 1 $$$ $$$ 5 $$$ $$$ 7 $$$ lonely,"['binary search', 'math', 'number theory', 'two pointers']",1600.0
1425/C,mr . chanek national chess tournament get a huge chessboard size $$$ n \times m $$$ bore play <unknown> chess mr . chanek define a function $$$ f ( x y ) $$$ denote minimum number move move a knight square $$$ ( 1 1 ) $$$ square $$$ ( x y ) $$$ turn find $$$ f ( x y ) $$$ simple mr . chanek define : $$$ g ( x y ) = \sum _ { i = x } ^ { n } \sum _ { j = y } ^ { m } f ( i j ) $$$ give x y task find $$$ g ( x y ) $$$ a knight move square $$$ ( a b ) $$$ square $$$ ( a ' b ' ) $$$ $$$ |a - a'| > 0 $$$ $$$ |b - b'| > 0 $$$ $$$ |a - a'| + |b - b'| = 3 $$$ course knight leave chessboard first line contain integer $$$ t $$$ $$$ ( 1 \le t \le 100 ) $$$ number test case test case contain a line four integers $$$ x $$$ $$$ y $$$ $$$ n $$$ $$$ m $$$ $$$ ( 3 \leq x \leq n \leq 1000000000 3 \leq y \leq m \leq 1000000000 ) $$$ test case print a line value $$$ g ( x y ) $$$ modulo $$$ 1000000000 + 7 $$$,['math'],3100.0
1425/D,"mr . chanek ninja one day task a mission handle mad snake attack a site , mr . chanek already arrive hill destination right hill mission area divide a grid size $$$ 1000 \times 1000 $$$ square $$$ n $$$ mad snake site i'th mad snake locate square $$$ ( x_i y_i ) $$$ a danger level $$$ b_i $$$ mr . chanek go use shadow clone <unknown> rasengan learn lord seventh complete mission attack strategy follow : mr . chanek curious sum score every possible attack strategy ? number huge mr . chanek need output modulo $$$ 1000000000 + 7 $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ r $$$ $$$ ( 1 \le m \le n \le 2 \cdot 1000 0 \le r < 1000 ) $$$ number mad snake number clone radius rasengan next $$$ n $$$ line contain three integers $$$ x_i $$$ $$$ y_i $$$ dan $$$ b_i $$$ $$$ ( 1 \le x_i y_i \le 1000 1 \le b_i \le 1000000 ) $$$ guarantee two mad snake occupy square a line integer denote sum score every possible attack strategy illustration six possible attack strategies circle denote choose mad snake blue square denote region rasengan : total score attack : $$$ 3.600 + 3.600 + <unknown> + 3.600 + <unknown> + <unknown> = <unknown> $$$","['combinatorics', 'dp', 'math']",2300.0
1425/E,mr . chanek currently participate a science fair popular town find excite puzzle fair want solve $$$ n $$$ atoms number $$$ 1 $$$ $$$ n $$$ atoms especially <unknown> initially atom normal state atom excite excite atom $$$ i $$$ require $$$ d_i $$$ energy atom $$$ i $$$ excite give $$$ a_i $$$ energy excite number atoms ( include zero ) atoms also form a peculiar one - way bond $$$ i $$$ $$$ ( 1 \le i < n ) $$$ atom $$$ i $$$ excite atom $$$ e_i $$$ also excite cost initially $$$ e_i $$$ = $$$ i+1 $$$ note atom $$$ n $$$ form a bond atom mr . chanek must change exactly $$$ k $$$ bond exactly $$$ k $$$ time mr . chanek choose atom $$$ i $$$ $$$ ( 1 \le i < n ) $$$ change $$$ e_i $$$ a different value $$$ i $$$ current $$$ e_i $$$ note atom 's bond remain unchanged change help mr . chanek determine maximum energy achieve ! note : must first change exactly $$$ k $$$ bond start excite atoms first line contain two integers $$$ n $$$ $$$ k $$$ $$$ ( 4 \le n \le 100000 0 \le k < n ) $$$ number atoms number bond must change second line contain $$$ n $$$ integers $$$ a_i $$$ $$$ ( 1 \le a_i \le 1000000 ) $$$ denote energy give atom $$$ i $$$ excite state third line contain $$$ n $$$ integers $$$ d_i $$$ $$$ ( 1 \le d_i \le 1000000 ) $$$ denote energy need excite atom $$$ i $$$ a line integer denote maximum number energy mr . chanek get optimal solution change $$$ <unknown> $$$ 1 excite atom 5 energy 1 . cause atoms 1 2 3 4 5 excite total energy gain mr . chanek ( 5 + 6 + 7 + 8 + 10 ) - 1 = 35 . another possible way change $$$ <unknown> $$$ 1 excite atom 3 ( excite atom 1 2 3 ) excite atom 4 ( excite atom 4 5 6 ) total energy gain mr . chanek ( 5 + 6 + 7 + 8 + 10 + 2 ) - ( 6 + 7 ) = 25 optimal,"['greedy', 'implementation']",2200.0
1428/E,rabbit singapore zoo fee zookeeper buy $$$ n $$$ carrots lengths $$$ a_1 a_2 a_3 \ldots a_n $$$ however rabbit fertile multiply quickly zookeeper $$$ k $$$ rabbit enough carrots fee solve problem zookeeper decide cut carrots $$$ k $$$ piece reason result carrot lengths must positive integers big carrots difficult rabbit handle eat time need eat a carrot size $$$ x $$$ $$$ x^2 $$$ help zookeeper split carrots minimize sum time take rabbit eat carrots first line contain two integers $$$ n $$$ $$$ k $$$ $$$ ( 1 \leq n \leq k \leq 100000 ) $$$ : initial number carrots number rabbit next line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 1 \leq a_i \leq 1000000 ) $$$ : lengths carrots guarantee sum $$$ a_i $$$ least $$$ k $$$ output one integer : minimum sum time take rabbit eat carrots first test optimal size carrots $$$ \ { <unknown> } $$$ time take $$$ 1 ^ 2 + 1 ^ 2 + 1 ^ 2 + 2 ^ 2 + 2 ^ 2 + 2 ^ <unknown> $$$ second test optimal size carrots $$$ \ { <unknown> } $$$ time take $$$ 4 ^ 2 + 5 ^ 2 + 5 ^ 2 + 5 ^ <unknown> $$$,"['binary search', 'data structures', 'greedy', 'math', 'sortings']",2200.0
1431/J,give array integers $$$ a $$$ size $$$ n $$$ array non - decreasing i. e. $$$ a_1 \le a_2 \le \dots \le a_n $$$ find array integers $$$ b $$$ size $$$ 2n - 1 $$$ : calculate number array meet condition modulo $$$ 998244353 $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 17 $$$ ) — size array $$$ a $$$ second line contain $$$ n $$$ integers ( $$$ 0 \le a_i \le 2^ { 60 } - 1 ; a_i \le a _ { i+1 } $$$ ) — elements array $$$ a $$$ print a single integer — number array meet condition modulo $$$ 998244353 $$$,['dp'],3400.0
1433/F,give a matrix $$$ a $$$ size $$$ n \times m $$$ consist integers choose $$$ \left\lfloor\frac { m } { 2 } \right\rfloor $$$ elements row task choose elements a way sum divisible $$$ k $$$ sum maximum word choose a half ( round ) elements row find maximum sum elements divisible $$$ k $$$ note choose zero elements ( sum set $$$ 0 $$$ ) first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n m k \le 70 $$$ ) — number row matrix number columns matrix value $$$ k $$$ next $$$ n $$$ line contain $$$ m $$$ elements $$$ j $$$ -th element $$$ i $$$ -th row $$$ a _ { i j } $$$ ( $$$ 1 \le a _ { i j } \le 70 $$$ ) print one integer — maximum sum divisible $$$ k $$$ obtain first example optimal answer $$$ 2 $$$ $$$ 4 $$$ first row $$$ 5 $$$ $$$ 2 $$$ second row $$$ 7 $$$ $$$ 4 $$$ third row total sum $$$ 2 + 4 + 5 + 2 + 7 + 4 = 24 $$$,['dp'],2100.0
1436/C,andrey think truly a successful developer reality n't know binary search algorithm recently read literature andrey understand algorithm allow quickly find a certain number $$$ x $$$ array array $$$ a $$$ index zero integer $$$ x $$$ pseudocode algorithm follow : note elements array index zero division do integers ( round ) andrey read algorithm work array sort however find statement <unknown> certainly exist unsorted array algorithm find $$$ x $$$ ! andrey want write a letter book author must consider permutations size $$$ n $$$ algorithm find $$$ x $$$ a permutation size $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order help andrey find number permutations size $$$ n $$$ contain $$$ x $$$ position $$$ pos $$$ give implementation binary search algorithm find $$$ x $$$ ( return true ) result may extremely large print remainder division $$$ 1000000000 + 7 $$$ line input contain integers $$$ n $$$ $$$ x $$$ $$$ pos $$$ ( $$$ 1 \le x \le n \le 1000 $$$ $$$ 0 \le pos \le n - 1 $$$ ) — require length permutation number search require position number respectively print a single number — remainder division number valid permutations $$$ 1000000000 + 7 $$$ possible permutations first test case : $$$ ( 2 3 1 4 ) $$$ $$$ ( 2 4 1 3 ) $$$ $$$ ( 3 2 1 4 ) $$$ $$$ ( 3 4 1 2 ) $$$ $$$ ( 4 2 1 3 ) $$$ $$$ ( 4 3 1 2 ) $$$,"['binary search', 'combinatorics']",1500.0
1439/E,"let 's consider a $$$ ( 1000000000 + 1 ) \times ( 1000000000 + 1 ) $$$ field row number integers $$$ 0 $$$ $$$ 1000000000 $$$ columns number integers $$$ 0 $$$ $$$ 1000000000 $$$ let 's define $$$ ( x y ) $$$ cell locate $$$ x $$$ -th row $$$ y $$$ -th column let 's call a cell $$$ ( x y ) $$$ good $$$ x \ & y = 0 $$$ $$$ \ & $$$ bitwise operation let 's build a graph vertices good cells field make edge pair adjacent side good cells prove graph a tree — connect graph without cycle let 's hang tree vertex $$$ ( 0 0 ) $$$ a root tree root $$$ ( 0 0 ) $$$ two players play game initially good cells black others white player turn choose a black good cell a subset ancestors ( possibly empty ) invert color ( white black vice versa ) player ca n't move ( good cells white ) lose prove game always finite initially cells white give $$$ m $$$ pair cells pair color cells a simple path black note invert color paint black sohrab mashtali go play game sohrab first player mashtali second mashtali want win decide cheat make follow operation multiple time game start : choose a cell invert color vertices path root tree <unknown> watch wonder : ` ` minimum number operations mashtali a win strategy ? ` ` find answer question initial paint tree prove least one possible way cheat always exist first line contain one integer $$$ m $$$ ( $$$ 1 \leq m \leq 100000 $$$ ) next $$$ m $$$ line contain four integers $$$ x _ { 1 } $$$ $$$ y _ { 1 } $$$ $$$ x _ { 2 } $$$ $$$ y _ { 2 } $$$ ( $$$ 0 \leq x_i y_i \leq 1000000000 $$$ $$$ x_i \ & y_i = 0 $$$ ) color cells path vertices $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ black print a single integer — minimum number cheat operations second player first test make one cheat operation root tree , second player win use a symmetric strategy second test make cheat operations cells $$$ ( 0 2 ) ( 0 0 ) ( 3 4 ) $$$ third test second player already win strategy n't need make cheat operations","['bitmasks', 'data structures', 'trees']",3500.0
1443/E,a permutation a sequence integers $$$ 1 $$$ $$$ n $$$ length $$$ n $$$ contain number exactly example $$$ [ 1 ] $$$ $$$ [ 4 3 5 1 2 ] $$$ $$$ [ 3 2 1 ] $$$ — permutations $$$ [ 1 1 ] $$$ $$$ [ 4 3 1 ] $$$ $$$ [ 2 3 4 ] $$$ — permutation $$$ a $$$ lexicographically smaller permutation $$$ b $$$ ( length $$$ n $$$ ) first index $$$ i $$$ differ $$$ a [ i ] < b [ i ] $$$ example permutation $$$ [ 1 3 2 4 ] $$$ lexicographically smaller permutation $$$ [ 1 3 4 2 ] $$$ first two elements equal third element first permutation smaller second next permutation a permutation $$$ a $$$ length $$$ n $$$ — lexicographically smallest permutation $$$ b $$$ length $$$ n $$$ lexicographically larger $$$ a $$$ example : give number $$$ n $$$ — length initial permutation initial permutation form $$$ a = [ 1 2 \ldots n ] $$$ word $$$ a [ i ] = i $$$ ( $$$ 1 \le i \le n $$$ ) need process $$$ q $$$ query two type : query $$$ 1 $$$ -st type output require sum first line contain two integers $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) $$$ n $$$ — length initial permutation $$$ q $$$ — number query next $$$ q $$$ line contain a single query $$$ 1 $$$ -st $$$ 2 $$$ -nd type $$$ 1 $$$ -st type query consist three integers $$$ 1 $$$ $$$ l $$$ $$$ r $$$ $$$ ( 1 \le l \le r \le n ) $$$ $$$ 2 $$$ -nd type query consist two integers $$$ 2 $$$ $$$ x $$$ $$$ ( 1 \le x \le 100000 ) $$$ guarantee request $$$ 2 $$$ -nd type possible process query $$$ 1 $$$ -st type output a separate line one integer — require sum initially permutation form $$$ [ 1 2 3 4 ] $$$ query process follow :,"['brute force', 'math', 'two pointers']",2400.0
1447/B,give a rectangular grid $$$ n $$$ row $$$ m $$$ columns cell locate $$$ i $$$ -th row top $$$ j $$$ -th column leave a value $$$ a _ { ij } $$$ write perform follow operation number time ( possibly zero ) : note use a cell different operations interest $$$ x $$$ sum number grid maximum $$$ x $$$ achieve operations ? test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n $$$ $$$ m \le 10 $$$ ) follow $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th element $$$ i $$$ -th line $$$ a _ { ij } $$$ ( $$$ <unknown> a _ { ij } \le 100 $$$ ) testcase print one integer $$$ x $$$ maximum possible sum value grid apply operation many time want first test case always least one $$$ -1 $$$ answer $$$ 2 $$$ second test case use operation six time elements adjacent horizontally get number non - negative answer : $$$ 2\times 1 + <unknown> + 3\times 3 + 2\times 4 + 1\times 5 = 30 $$$,"['greedy', 'math']",1000.0
1451/A,ridbit start integer $$$ n $$$ one move perform one follow operations : a proper divisor a divisor a number exclude example $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$ $$$ 5 $$$ $$$ 10 $$$ proper divisors $$$ 20 $$$ $$$ 20 $$$ minimum number move ridbit require make reduce $$$ n $$$ $$$ 1 $$$ ? first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000000000 $$$ ) test case output minimum number move require reduce $$$ n $$$ $$$ 1 $$$ test case example $$$ n $$$ may reduce $$$ 1 $$$ use follow operations sequence $$$ 1 $$$ $$$ 2 \xrightarrow { } 1 $$$ $$$ 3 \xrightarrow { } 2 \xrightarrow { } 1 $$$ $$$ 4 \xrightarrow { } 2 \xrightarrow { } 1 $$$ $$$ 6 \xrightarrow { } 2 \xrightarrow { } 1 $$$ $$$ 9 \xrightarrow { } 3 \xrightarrow { } <unknown> { } 1 $$$,"['greedy', 'math']",800.0
1451/B,"hr0d1y $$$ q $$$ query a binary string $$$ s $$$ length $$$ n $$$ a binary string a string contain character ' 0 ' ' 1 ' a query describe a pair integers $$$ l_i $$$ $$$ r_i $$$ $$$ ( 1 \leq l_i \lt r_i \leq n ) $$$ query determine whether exist a good subsequence $$$ s $$$ equal substring $$$ s [ <unknown> r_i ] $$$ help hr0d1y answer query ? first line input contain a single integer $$$ t $$$ ( $$$ 1\leq t \leq 100 $$$ ) — number test case description test case follow first line contain two integers $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) $$$ q $$$ ( $$$ 1\leq q \leq 100 $$$ ) — length string number query second line contain string $$$ s $$$ $$$ i $$$ -th next $$$ q $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \leq l_i \lt r_i \leq n $$$ ) test case output $$$ q $$$ line $$$ i $$$ -th line output test case contain ` ` yes '' exist a good subsequence equal substring $$$ s [ l_i ... r_i ] $$$ ` ` '' otherwise may print letter case ( upper lower ) first test case ,","['dp', 'greedy', 'implementation', 'strings']",900.0
1453/A,"gildong 's town a train system $$$ 100 $$$ train travel bottom end top end $$$ 100 $$$ train travel leave end right end train start side number $$$ 1 $$$ $$$ 100 $$$ respectively train speed let 's take a look picture train system represent coordinate a 2d plane $$$ i $$$ -th train start bottom end initially $$$ ( i,0 ) $$$ $$$ ( i t ) $$$ $$$ t $$$ minutes $$$ i $$$ -th train start leave end initially $$$ ( 0 i ) $$$ $$$ ( t i ) $$$ $$$ t $$$ minutes train arrive destinations $$$ 101 $$$ minutes however gildong find train schedule depart a specific time simultaneously dangerous time $$$ n $$$ train schedule depart bottom end $$$ m $$$ train schedule depart leave end two train $$$ ( x y ) $$$ time $$$ x $$$ $$$ y $$$ crash therefore ask find minimum number train cancel prevent crash test contain one test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) test case contain three line first line test case consist two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100 $$$ ) — number train schedule depart bottom end number train schedule depart leave end respectively second line test case contain $$$ n $$$ integers integer a train number schedule start bottom end number give strictly increase order $$$ 1 $$$ $$$ 100 $$$ inclusive third line test case contain $$$ m $$$ integers integer a train number schedule start leave end number give strictly increase order $$$ 1 $$$ $$$ 100 $$$ inclusive test case print a single integer : minimum number train cancel order prevent crash first case show crash current schedule follow therefore answer zero second case $$$ t=4 $$$ a crash see picture prove cancel one train remain train crash therefore answer one",['implementation'],800.0
1453/E,"gildong play dog badugi 're a park $$$ n $$$ intersections $$$ n-1 $$$ bidirectional roads $$$ 1 $$$ meter length connect two intersections intersections number $$$ 1 $$$ $$$ n $$$ every $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le n $$$ ) possible get $$$ b $$$ -th intersection $$$ a $$$ -th intersection use set roads gildong put one snack every intersection park gildong give badugi a mission eat snack badugi start $$$ 1 $$$ -st intersection move follow rule : unfortunately gildong n't know value $$$ k $$$ , want find minimum value $$$ k $$$ make possible badugi complete mission badugi move optimally test contain one test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) first line test case contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number intersections park next $$$ n-1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) mean a road intersection $$$ u $$$ $$$ v $$$ roads bidirectional distinct guarantee : test case print one integer — minimum possible value $$$ k $$$ badugi complete mission first case badugi complete mission $$$ k=2 $$$ move follow : second case possible sequence move make $$$ 1 $$$ – $$$ 2 $$$ – $$$ 3 $$$ – $$$ 4 $$$ – $$$ 1 $$$ since distance $$$ 4 $$$ -th intersection $$$ 1 $$$ -st intersection $$$ 3 $$$ $$$ k $$$ need least $$$ 3 $$$ badugi complete mission third case badugi make move follow : $$$ 1 $$$ – $$$ 5 $$$ – $$$ 6 $$$ – $$$ 7 $$$ – $$$ 8 $$$ – $$$ 2 $$$ – $$$ 3 $$$ – $$$ 4 $$$ – $$$ 1 $$$ show possible sequence move badugi complete mission $$$ k=3 $$$","['binary search', 'dfs and similar', 'dp', 'greedy', 'trees']",2300.0
1454/C,give a sequence $$$ a $$$ initially consist $$$ n $$$ integers want transform sequence elements equal ( i. e. contain several occurrences element ) achieve choose integer $$$ x $$$ occur least $$$ a $$$ perform follow operation number time ( possibly zero ) : choose segment $$$ [ l r ] $$$ sequence remove one exception : allow choose a segment contain $$$ x $$$ formally choose contiguous subsequence $$$ [ a_l a _ { l + 1 } \dots a_r ] $$$ $$$ a_i \ne x $$$ $$$ l \le i \le r $$$ remove removal number elements right remove segment change : element $$$ ( r+1 ) $$$ -th $$$ l $$$ -th element $$$ ( r+2 ) $$$ -th $$$ ( l+1 ) $$$ -th ( i. e. remain sequence collapse ) note change $$$ x $$$ choose example suppose $$$ n = 6 $$$ $$$ a = [ 1 3 2 4 1 2 ] $$$ one ways transform two operations choose $$$ x = 1 $$$ : note choose $$$ x $$$ operation also note remove occurrence $$$ x $$$ task find minimum number operations require transform sequence a way describe answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print answer — minimum number operations require transform give sequence a way describe problem statement prove always possible perform a finite sequence operations sequence transform require way,"['greedy', 'implementation']",1200.0
1454/E,"give undirected graph consist $$$ n $$$ vertices $$$ n $$$ edge guarantee give graph connect ( i. e. possible reach vertex vertex ) self - loops multiple edge graph task calculate number simple paths length least $$$ 1 $$$ give graph note paths differ direction consider ( i. e. calculate number undirected paths ) example paths $$$ [ 1 2 3 ] $$$ $$$ [ 3 2 1 ] $$$ consider answer $$$ t $$$ independent test case recall a path graph a sequence vertices $$$ v_1 v_2 \ldots v_k $$$ pair adjacent ( consecutive ) vertices sequence connect edge length path number edge a simple path a path vertices distinct first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) — number vertices ( number edge ) graph next $$$ n $$$ line test case describe edge : edge $$$ i $$$ give a pair vertices $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) $$$ u_i $$$ $$$ v_i $$$ vertices $$$ i $$$ -th edge connect pair vertices $$$ ( u v ) $$$ one edge $$$ u $$$ $$$ v $$$ edge vertex , self - loops multiple edge graph graph undirected i. e. edge bidirectional graph connect i. e. possible reach vertex vertex move along edge graph guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print one integer : number simple paths length least $$$ 1 $$$ give graph note paths differ direction consider ( i. e. calculate number undirected paths ) consider second test case example look like : $$$ 11 $$$ different simple paths :","['combinatorics', 'dfs and similar', 'graphs', 'trees']",2000.0
1455/C,alice bob play ping - <unknown> simplify rule game player serve ball commence a play server strike ball receiver make a return hit ball back thereafter server receiver must alternately make a return one n't make a return one n't make a return lose play winner play commence next play alice start first play alice $$$ x $$$ stamina bob $$$ y $$$ hit ball ( serve return ) player spend $$$ 1 $$$ stamina n't stamina ca n't return ball ( lose play ) ca n't serve ball ( case player serve ball instead ) players run stamina game sometimes 's strategically optimal return ball lose current play save stamina contrary server commence a play hit ball stamina leave alice bob play optimally want firstly maximize number win secondly minimize number win opponent calculate result number alice 's bob 's win first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le 1000000 $$$ ) — alice 's bob 's initial stamina test case print two integers — result number alice 's bob 's win play optimally first test case alice serve ball spend $$$ 1 $$$ stamina bob return ball also spend $$$ 1 $$$ stamina alice ca n't return ball since stamina leave lose play run stamina game $$$ 0 $$$ alice 's win $$$ 1 $$$ bob 's win second test case alice serve ball spend $$$ 1 $$$ stamina bob decide return ball — lose play save stamina alice winner last play serve ball next play spend $$$ 1 $$$ stamina time bob return ball spend $$$ 1 $$$ stamina alice n't stamina leave ca n't return ball lose play run stamina game $$$ 1 $$$ alice 's $$$ 1 $$$ bob 's win third test case alice serve ball spend $$$ 1 $$$ stamina bob return ball spend $$$ 1 $$$ stamina alice run stamina ca n't return ball lose play bob a winner serve ball next $$$ 6 $$$ play time alice ca n't return ball lose play game $$$ 0 $$$ alice 's $$$ 7 $$$ bob 's win,['math'],1100.0
1458/C,give a square matrix size $$$ n $$$ every row every column matrix a permutation $$$ 1 $$$ $$$ 2 $$$ $$$ \ldots $$$ $$$ n $$$ let $$$ a _ { i j } $$$ element intersection $$$ i $$$ -th row $$$ j $$$ -th column every $$$ 1 \leq i j \leq n $$$ row number $$$ 1 \ldots n $$$ top bottom columns number $$$ 1 \ldots n $$$ leave right six type operations : one see sequence operations every row every column matrix still a permutation $$$ 1 2 \ldots n $$$ give initial matrix description process $$$ m $$$ operations output final matrix first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case $$$ t $$$ test case descriptions follow first line test case description contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 1000 1 \leq m \leq 100000 $$$ ) — size matrix number operations next $$$ n $$$ line contain $$$ n $$$ integers separate single space — description matrix $$$ a $$$ ( $$$ 1 \leq a _ { i j } \leq n $$$ ) last line description contain a string $$$ m $$$ character describe operations order accord format sum $$$ n $$$ exceed $$$ 1000 $$$ sum $$$ m $$$ exceed $$$ 100000 $$$ test case print $$$ n $$$ line $$$ n $$$ integers — final matrix $$$ m $$$ operations line break sample test case answer clarity n't print,['math'],2700.0
1458/F,give a tree $$$ n $$$ vertices number $$$ 1 \ldots n $$$ a tree a connect simple graph without cycle let $$$ \mathrm { dist } ( u v ) $$$ number edge unique simple path connect vertices $$$ u $$$ $$$ v $$$ let $$$ \mathrm { diam } ( l r ) = \max \mathrm { dist } ( u v ) $$$ pair $$$ u v $$$ $$$ l \leq u v \leq r $$$ compute $$$ \sum _ { 1 \leq l \leq r \leq n } \mathrm { diam } ( l r ) $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — number vertices tree next $$$ n - 1 $$$ line describe tree edge line contain two integers $$$ u v $$$ ( $$$ 1 \leq u v \leq n $$$ ) — endpoint indices respective tree edge guarantee edge list indeed describe a tree print a single integer — $$$ \sum _ { 1 \leq l \leq r \leq n } \mathrm { diam } ( l r ) $$$,"['data structures', 'trees']",3500.0
146/B,petya love lucky number much everybody know lucky number positive integers whose decimal record contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 petya call a mask a positive integer n number obtain successive write lucky digits number n leave right example mask number <unknown> number 7744 mask 7 7 mask <unknown> 47 . obviously mask number always a lucky number petya two number — arbitrary integer a a lucky number b. help find minimum number c ( c > a ) mask number c equal b. line contain two integers a b ( 1 ≤ a b ≤ 105 ) guarantee number b lucky line print a single number — number c seek petya,"['brute force', 'implementation']",1300.0
1461/B,holiday come really soon rick realize 's time think buy a traditional spruce tree rick n't want real tree get hurt decide find $$$ n \times m $$$ matrix consist ` ` * '' ` ` . ` ` find every spruce first let 's define a spruce matrix a set matrix cells call a spruce height $$$ k $$$ origin point $$$ ( x y ) $$$ : examples correct incorrect spruce tree : rick want know many spruce $$$ n \times m $$$ matrix contain help rick solve problem test contain one test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 500 $$$ ) — matrix size next $$$ n $$$ line test case contain $$$ m $$$ character $$$ c _ { i j } $$$ — matrix content guarantee $$$ c _ { i j } $$$ either a ` ` . '' ` ` * '' guarantee sum $$$ n \cdot m $$$ test case exceed $$$ 500 ^ 2 $$$ ( $$$ \sum n \cdot m \le 500 ^ 2 $$$ ) test case print single integer — total number spruce matrix first test case first spruce height $$$ 2 $$$ origin point $$$ ( 1 2 ) $$$ second spruce height $$$ 1 $$$ origin point $$$ ( 1 2 ) $$$ third spruce height $$$ 1 $$$ origin point $$$ ( 2 1 ) $$$ fourth spruce height $$$ 1 $$$ origin point $$$ ( 2 2 ) $$$ fifth spruce height $$$ 1 $$$ origin point $$$ ( 2 3 ) $$$ second test case first spruce height $$$ 1 $$$ origin point $$$ ( 1 2 ) $$$ second spruce height $$$ 1 $$$ origin point $$$ ( 2 1 ) $$$ third spruce height $$$ 1 $$$ origin point $$$ ( 2 2 ) $$$,"['brute force', 'dp', 'implementation']",1400.0
1461/E,recent years john successfully settle new job office john n't like <unknown> sit around code compile immediately find interest distraction point distraction maintain a water level water cooler use zebras originally cooler contain exactly $$$ k $$$ liters water john decide amount water must always least $$$ l $$$ liters water $$$ r $$$ liters john stay office exactly $$$ t $$$ days know day exactly $$$ x $$$ liters water use colleagues begin day add exactly $$$ y $$$ liters water cooler point time amount water cooler must range $$$ [ l r ] $$$ john want find whether able maintain water level necessary level $$$ t $$$ days help answer question ! first line input contain six integers $$$ k $$$ $$$ l $$$ $$$ r $$$ $$$ t $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \le l \le k \le r \le 10^ { 18 } ; 1 \le t \le 10^ { 18 } ; 1 \le x \le 1000000 ; 1 \le y \le 10^ { 18 } $$$ ) — initial water level require range number days daily water usage exact amount water add respectively print ` ` yes '' john maintain water level $$$ t $$$ days ` ` '' otherwise first example john ca n't increase amount water begin first day since would exceed limit $$$ r $$$ first day cooler contain $$$ 2 $$$ liters water next day john add $$$ 4 $$$ liters cooler lose $$$ 6 $$$ liters leave john $$$ 0 $$$ liters outside range $$$ [ 1 10 ] $$$ second example first day john leave $$$ 2 $$$ liters water begin next day add $$$ 5 $$$ liters $$$ 6 $$$ liters get use leave john $$$ 1 $$$ liter water range $$$ [ 1 10 ] $$$ third example first day john leave $$$ 7 $$$ liters second day — $$$ 5 $$$ liters fourth — $$$ 1 $$$ liter begin fifth day john add $$$ 9 $$$ liters lose $$$ 2 $$$ liters mean fifth day $$$ 8 $$$ liters leave day water level decrease $$$ 2 $$$ liters eighth day john $$$ 2 $$$ liters ninth day — $$$ 0 $$$ liters $$$ 0 $$$ outside range $$$ [ 1 10 ] $$$ answer ` ` '' fourth example first day john leave $$$ 15 $$$ liters water begin second day add $$$ 7 $$$ liters lose $$$ 5 $$$ second day leave $$$ 17 $$$ liters begin third day add $$$ 7 $$$ liters water lose $$$ 5 $$$ third day leave $$$ 19 $$$ liters $$$ 19 $$$ range $$$ [ 15 25 ] $$$ answer ` ` yes '',"['brute force', 'graphs', 'greedy', 'implementation', 'math']",2200.0
1462/B,polycarp a string $$$ s [ 1 \dots n ] $$$ length $$$ n $$$ consist decimal digits polycarp perform follow operation string $$$ s $$$ ( i.e perform operation $$$ 0 $$$ $$$ 1 $$$ time ) : example string $$$ s = $$$ ` ` <unknown> '' polycarp turn string : polycarp like string ` ` 2020 '' much wonder possible turn string $$$ s $$$ a string ` ` 2020 '' one operation ? note perform zero operations first line contain a positive integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case test $$$ t $$$ test case follow first line test case contain integer $$$ n $$$ ( $$$ 4 \leq n \leq 200 $$$ ) — length string $$$ s $$$ next line contain a string $$$ s $$$ length $$$ n $$$ consist decimal digits allow string $$$ s $$$ start digit 0 . test case output a separate line : may print every letter ` ` yes '' ` ` '' case want ( example string yes yes yes yes recognize positive answer ) first test case polycarp could choose $$$ i=3 $$$ $$$ <unknown> $$$ second test case polycarp could choose $$$ i=2 $$$ $$$ j=5 $$$ third test case polycarp perform operations string,"['dp', 'implementation', 'strings']",800.0
1463/E,"ivan a program teacher academic year plan give $$$ n $$$ lecture $$$ n $$$ different topics topic use exactly one lecture ivan want choose topic explain $$$ 1 $$$ -st $$$ 2 $$$ -nd ... $$$ n $$$ -th lecture — formally want choose permutation integers $$$ 1 $$$ $$$ n $$$ ( let 's call permutation $$$ q $$$ ) $$$ q_i $$$ index topic ivan explain $$$ i $$$ -th lecture topic ( except exactly one ) exist a prerequisite topic ( topic $$$ i $$$ prerequisite topic $$$ p_i $$$ ) ivan give a lecture a topic give a lecture prerequisite topic exist least one valid order topics accord prerequisite constraints order topics correctly help students understand lecture better ivan $$$ k $$$ special pair topics $$$ ( x_i y_i ) $$$ know students understand $$$ y_i $$$ -th topic better lecture conduct right lecture $$$ x_i $$$ -th topic ivan want satisfy constraints every pair , every $$$ i \in [ 1 k ] $$$ exist $$$ j \in [ 1 n - 1 ] $$$ $$$ q_j = x_i $$$ $$$ q _ { j + 1 } = y_i $$$ ivan want know exist order topics satisfy constraints least one exist find first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 300000 $$$ $$$ 1 \le k \le n - 1 $$$ ) — number topics number special pair topics respectively second line contain $$$ n $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_n $$$ ( $$$ 0 \le p_i \le n $$$ ) $$$ p_i $$$ prerequisite topic topic $$$ i $$$ ( $$$ p_i = 0 $$$ $$$ i $$$ -th topic prerequisite topics ) exactly one integers $$$ 0 $$$ least one order topics every $$$ i $$$ $$$ p_i $$$ -th topic place $$$ i $$$ -th topic exist $$$ k $$$ line follow $$$ i $$$ -th line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ ; $$$ x_i \ne y_i $$$ ) — topics $$$ i $$$ -th special pair value $$$ x_i $$$ pairwise distinct ; similarly <unknown> $$$ y_i $$$ pairwise distinct order topics meet constraints print $$$ 0 $$$ otherwise print $$$ n $$$ pairwise distinct integers $$$ q_1 $$$ $$$ q_2 $$$ ... $$$ q_n $$$ ( $$$ 1 \le q_i \le n $$$ ) — order topics meet constraints multiple answer print","['dfs and similar', 'dsu', 'graphs', 'implementation', 'sortings', 'trees']",2400.0
1463/F,let 's call set positive integers $$$ s $$$ correct follow two condition meet : give value $$$ n $$$ $$$ x $$$ $$$ y $$$ find maximum size correct set a single line contain three integers $$$ n $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \le n \le 1000000000 $$$ ; $$$ 1 \le x y \le 22 $$$ ) print one integer — maximum size correct set,"['bitmasks', 'dp', 'math']",3100.0
1466/E,"a know pan apollo n't battle title <unknown> musician a <unknown> later also challenge math ( rather fast calculations ) task get solve follow : let $$$ x_1 x_2 \ldots x_n $$$ sequence $$$ n $$$ non - negative integers find value : $$$ $$$ \sum _ { i=1 } ^n \sum _ { j=1 } ^n \sum _ { k=1 } ^n ( x_i \ \ & \ x_j ) \cdot ( x_j \ | \ x_k ) $$$ $$$ $$$ \ & $$$ denote bitwise $$$ | $$$ denote bitwise pan apollo could solve a second ? convenience find answer modulo $$$ 1000000000 + 7 $$$ first line input contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1\,000 $$$ ) denote number test case $$$ t $$$ test case follow first line test case consist a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 500000 $$$ ) length sequence second one contain $$$ n $$$ non - negative integers $$$ x_1 x_2 \ldots x_n $$$ ( $$$ 0 \leq x_i < 2^ { 60 } $$$ ) elements sequence sum $$$ n $$$ test case exceed $$$ 500000 $$$ print $$$ t $$$ line $$$ i $$$ -th line contain answer $$$ i $$$ -th text case","['bitmasks', 'brute force', 'math']",1800.0
1466/F,may know euclid a mathematician well turn <unknown> know want play a mean trick euclid send appropriate nightmare bad dream euclid a set $$$ s $$$ $$$ n $$$ $$$ m $$$ -dimensional vectors $$$ \mathbb { z } _ 2 $$$ field perform vector addition word vectors $$$ m $$$ coordinate one equal either $$$ 0 $$$ $$$ 1 $$$ vector addition define follow : let $$$ u+v = w $$$ $$$ w_i = ( u_i + v_i ) \bmod 2 $$$ euclid sum subset $$$ s $$$ archive another $$$ m $$$ -dimensional vector $$$ \mathbb { z } _ 2 $$$ particular sum together empty subset ; a case result vector coordinate equal $$$ 0 $$$ let $$$ t $$$ set vectors write a sum vectors $$$ s $$$ euclid wonder size $$$ t $$$ whether use a subset $$$ s ' $$$ $$$ s $$$ obtain vectors $$$ t $$$ usually case scenarios wake figure far things look rather <unknown> philosopher hope notice vectors $$$ s $$$ $$$ 2 $$$ coordinate equal $$$ 1 $$$ help euclid calculate $$$ |t| $$$ number $$$ m $$$ -dimensional vectors $$$ \mathbb { z } _ 2 $$$ write a sum vectors $$$ s $$$ quite large calculate modulo $$$ 1000000000 + 7 $$$ also find $$$ s ' $$$ smallest subset $$$ s $$$ vectors $$$ t $$$ write a sum vectors $$$ s ' $$$ case multiple set a minimal number elements output lexicographically smallest one respect order elements give input consider set $$$ a $$$ $$$ b $$$ $$$ |a| = |b| $$$ let $$$ a_1 a_2 \dots a _ { |a| } $$$ $$$ b_1 b_2 \dots b _ { |b| } $$$ increase array indices elements $$$ a $$$ $$$ b $$$ correspondingly $$$ a $$$ lexicographically smaller $$$ b $$$ iff exist $$$ i $$$ $$$ a_j = b_j $$$ $$$ j < i $$$ $$$ a_i < b_i $$$ first line input two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 500000 $$$ ) denote number vectors $$$ s $$$ number dimension next $$$ n $$$ line contain description vectors $$$ s $$$ integer $$$ k $$$ ( $$$ 1 \leq k \leq 2 $$$ ) follow $$$ k $$$ distinct integers $$$ x_1 \dots x_k $$$ ( $$$ 1 \leq x_i \leq m $$$ ) encode $$$ m $$$ -dimensional vector $$$ 1 $$$ s coordinate $$$ x_1 \dots x_k $$$ $$$ 0 $$$ s rest among $$$ n $$$ vectors two first line output two integers : remainder modulo $$$ 1000000000 + 7 $$$ $$$ |t| $$$ $$$ |s'| $$$ second line output $$$ |s'| $$$ number indices elements $$$ s ' $$$ ascend order elements $$$ s $$$ number $$$ 1 $$$ order give input first example give three vectors : turn represent vectors $$$ 2 $$$ -dimensional space use vectors : hence $$$ t = \ { 00 01 10 11\ } $$$ choose two three vectors $$$ s $$$ still able obtain vectors $$$ t $$$ a case choose two vectors appear first input since obtain vectors $$$ t $$$ use a single vector $$$ s $$$ $$$ |s'| = 2 $$$ $$$ s ' = \ { 10 01\ } $$$ ( indices $$$ 1 $$$ $$$ 2 $$$ ) set $$$ \ { 1 2 \ } $$$ lexicographically smallest represent vectors $$$ t $$$ use vectors $$$ s ' $$$ show :,"['bitmasks', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'math', 'sortings']",2100.0
1467/B,give a sequence $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ let us call index $$$ j $$$ ( $$$ 2 \le j \le { { n-1 } } $$$ ) a hill $$$ a_j > a _ { { j+1 } } $$$ $$$ a_j > a _ { { j-1 } } $$$ ; let us call a valley $$$ a_j < a _ { { j+1 } } $$$ $$$ a_j < a _ { { j-1 } } $$$ let us define intimidation value a sequence sum number hill number valleys sequence change exactly one integer sequence number want let sequence remain unchanged minimum intimidation value achieve ? first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 3\cdot100000 $$$ ) second line test case contain $$$ n $$$ space - separated integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 3\cdot100000 $$$ test case print a single integer — minimum intimidation value achieve first test case change $$$ a_2 $$$ $$$ 2 $$$ result hill valleys second test case best answer leave array third test case change $$$ a_3 $$$ $$$ 6 $$$ result one valley ( index $$$ 5 $$$ ) fourth test case change $$$ a_3 $$$ $$$ 6 $$$ result hill valleys,"['brute force', 'implementation']",1700.0
1467/C,"give three bag bag contain a non - empty multiset number perform a number operations bag one operation choose two non - empty bag choose one number bag let 's say choose number $$$ a $$$ first bag number $$$ b $$$ second bag , remove $$$ b $$$ second bag replace $$$ a $$$ $$$ a - b $$$ first bag note multiple occurrences number shall remove / replace exactly one occurrence perform operations a way exactly one number remain exactly one bag ( two bag empty ) show always apply operations receive a configuration end among configurations find one maximum number leave end first line input contain three space - separated integers $$$ n_1 $$$ $$$ n_2 $$$ $$$ n_3 $$$ ( $$$ 1 \le n_1 n_2 n_3 \le 3\cdot100000 $$$ $$$ 1 \le <unknown> \le 3\cdot100000 $$$ ) — number number three bag $$$ i $$$ -th next three line contain $$$ n_i $$$ space - separated integers $$$ a _ { { i,1 } } $$$ $$$ a _ { { i,2 } } $$$ ... $$$ a _ { { i { { n_i } } } } $$$ ( $$$ 1 \le a _ { { i j } } \le 1000000000 $$$ ) — number $$$ i $$$ -th bag print a single integer — maximum number achieve end first example input let us perform follow operations : $$$ [ 1 2 ] [ 6 3 4 5 ] [ 5 ] $$$ $$$ [ -5 2 ] [ 3 4 5 ] [ 5 ] $$$ ( apply operation $$$ ( 1 6 ) $$$ ) $$$ [ -10 2 ] [ 3 4 ] [ 5 ] $$$ ( apply operation $$$ ( -5 5 ) $$$ ) $$$ [ 2 ] [ 3 4 ] [ 15 ] $$$ ( apply operation $$$ ( 5 -10 ) $$$ ) $$$ [ -1 ] [ 4 ] [ 15 ] $$$ ( apply operation $$$ ( 2 3 ) $$$ ) $$$ [ -5 ] [ ] [ 15 ] $$$ ( apply operation $$$ ( -1 4 ) $$$ ) $$$ [ ] [ ] [ 20 ] $$$ ( apply operation $$$ ( 15 -5 ) $$$ ) verify achieve a bigger number hence answer $$$ 20 $$$",['greedy'],1900.0
1467/E,give a tree $$$ n $$$ vertices vertex $$$ i $$$ a value $$$ a_i $$$ associate let us root tree vertex $$$ v $$$ vertex $$$ v $$$ call a distinctive root follow hold : paths start $$$ v $$$ end node value encounter distinct two different paths may value common a single path must distinct value find number distinctive root tree first line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 2\cdot100000 $$$ ) — number vertices tree next line contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) follow $$$ n-1 $$$ line contain two space - separated integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u $$$ $$$ v \le n $$$ ) denote edge $$$ u $$$ $$$ v $$$ guarantee edge form a tree print a single integer — number distinctive root tree first example $$$ 1 $$$ $$$ 2 $$$ $$$ 5 $$$ distinctive root,"['data structures', 'dfs and similar', 'dp', 'trees']",2500.0
1468/A,let 's call a sequence $$$ b_1 b_2 b_3 \dots b _ { k - 1 } b_k $$$ almost increase $$$ $$$ \min ( b_1 b_2 ) \le \min ( b_2 b_3 ) \le \dots \le \min ( b _ { k - 1 } b_k ) $$$ $$$ particular sequence two elements almost increase give a sequence integers $$$ a_1 a_2 \dots a_n $$$ calculate length longest almost increase subsequence 'll give $$$ t $$$ test case solve test case independently reminder : a subsequence a sequence derive another sequence delete elements without change order remain elements first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number independent test case first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 500000 $$$ ) — length sequence $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — sequence 's guarantee total sum $$$ n $$$ test case n't exceed $$$ 500000 $$$ test case print one integer — length longest almost increase subsequence first test case one optimal answer subsequence $$$ 1 2 7 2 2 3 $$$ second third test case whole sequence $$$ a $$$ already almost increase,"['data structures', 'dp', 'greedy']",2200.0
1468/C,monocarp polycarp work waiters berpizza a pizzeria locate near center bertown since waiters job serve customers choose serve first differently start work day customers berpizza come one one a customer come pizzeria sit wait monocarp polycarp serve monocarp work berpizza two weeks whenever serve a customer simply choose one come berpizza first serve customer hand polycarp experience waiter berpizza know customers go spend a lot money pizzeria ( n't ) soon see customer polycarp estimate amount money customer spend serve a customer choose one expect leave money berpizza ( case several customers choose one come first among ) obviously customer serve twice monocarp polycarp choose customer serve among n't serve yet number customers get really high become difficult monocarp polycarp choose customer go serve task write a program make choices formally program able process three type query : query type $$$ 2 $$$ $$$ 3 $$$ report number customer serve ( customers number order come pizzeria start $$$ 1 $$$ ) first line contain one integer $$$ q $$$ ( $$$ 2 \le q \le 500000 $$$ ) — number query $$$ q $$$ line follow describe a query one follow format : query type $$$ 2 $$$ $$$ 3 $$$ ask exist least one customer n't serve yet least one query type $$$ 2 $$$ $$$ 3 $$$ input query type $$$ 2 $$$ $$$ 3 $$$ print one integer — number customer serve event customers number order come pizzeria start $$$ 1 $$$,"['data structures', 'implementation']",1400.0
1468/G,hobbits frodo sam carry one ring mordor order spot orcs decide go mountains mountain relief represent a polyline $$$ n $$$ point $$$ ( x_i y_i ) $$$ number $$$ 1 $$$ $$$ n $$$ ( $$$ x_i < x _ { i + 1 } $$$ $$$ 1 \le i \le n - 1 $$$ ) hobbits start journey point $$$ ( x_1 y_1 ) $$$ reach point $$$ ( x_n y_n ) $$$ complete mission problem a tower eye sauron watch tower locate point $$$ ( x_n y_n ) $$$ height $$$ h $$$ eye locate point $$$ ( x_n y_n + h ) $$$ order complete mission successfully hobbits wear cloak time sauron eye see i. e. a direct line eye hobbits intersect relief hobbits low height consider negligibly small still positive a direct line sauron eye hobbits touch relief eye see hobbits like wear cloak wear spot eye task calculate total distance hobbits walk wear cloak first line input contain two integers $$$ n $$$ $$$ h $$$ ( $$$ 2 \le n \le 200000 $$$ ; $$$ 1 \le h \le 10000 $$$ ) — number vertices polyline tower height next $$$ n $$$ line contain two integers $$$ x_i y_i $$$ ( $$$ 0 \le x_i \le 400000 $$$ ; $$$ 0 \le y_i \le 10000 $$$ ) — coordinate polyline vertices guarantee $$$ x_i < x _ { i + 1 } $$$ $$$ 1 \le i \le n - 1 $$$ print one real number — total distance hobbits walk wear cloak answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ — formally answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \dfrac { |a - b| } { \max ( 1 b ) } \le 10^ { -6 } $$$,"['binary search', 'geometry']",2500.0
1468/H,let 's denote median a sequence $$$ s $$$ odd length value middle $$$ s $$$ sort $$$ s $$$ non - decreasing order example let $$$ s = [ 1 2 5 7 2 3 12 ] $$$ sort get sequence $$$ [ 1 2 2 \underline { 3 } 5 7 12 ] $$$ median equal $$$ 3 $$$ a sequence $$$ n $$$ integers $$$ [ 1 2 \dots n ] $$$ odd integer $$$ k $$$ one step choose $$$ k $$$ elements sequence erase choose elements except median elements go continuously ( gap allow ) example a sequence $$$ [ 1 2 3 4 5 6 7 ] $$$ ( i.e $$$ n=7 $$$ ) $$$ k = 3 $$$ follow options first step possible : zero step get a sequence $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_m $$$ several step ? 'll give $$$ t $$$ test case solve test case independently first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 3 \le n \le 200000 $$$ ; $$$ 3 \le k \le n $$$ ; $$$ k $$$ odd ; $$$ 1 \le m < n $$$ ) — length sequence number elements choose step length sequence 'd like get second line test case contain $$$ m $$$ integers $$$ b_1 b_2 \dots b_m $$$ ( $$$ 1 \le b_1 < b_2 < \dots < b_m \le n $$$ ) — sequence 'd like get give ascend order 's guarantee total sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print yes obtain sequence $$$ b $$$ otherwise may print letter case ( example yes yes yes yes recognize positive answer ) first test case sequence $$$ [ 1 2 3 ] $$$ since $$$ k = 3 $$$ one way choose $$$ k $$$ elements — 's choose elements $$$ [ 1 \underline { 2 } 3 ] $$$ median $$$ 2 $$$ 's erase choose elements except median 'll get sequence $$$ [ 2 ] $$$ word way get sequence $$$ b = [ 1 ] $$$ result second test case sequence $$$ [ 1 2 3 4 5 6 7 ] $$$ one optimal strategies follow : fourth test case sequence $$$ [ 1 2 3 4 5 6 7 8 9 10 11 12 13 ] $$$ choose $$$ k=7 $$$ elements $$$ [ 2 4 6 \underline { 7 } 8 10 13 ] $$$ erase except median get sequence $$$ b $$$,"['greedy', 'math']",2200.0
1469/B,monocarp a sequence $$$ a $$$ consist $$$ n + m $$$ integers $$$ a_1 a_2 \dots a _ { n + m } $$$ paint elements two color red blue ; $$$ n $$$ elements paint red $$$ m $$$ elements paint blue paint elements write two sequence $$$ r_1 r_2 \dots r_n $$$ $$$ b_1 b_2 \dots b_m $$$ sequence $$$ r $$$ consist red elements $$$ a $$$ order appear $$$ a $$$ ; similarly sequence $$$ b $$$ consist blue elements $$$ a $$$ order appear $$$ a $$$ well unfortunately original sequence lose monocarp sequence $$$ r $$$ $$$ b $$$ want restore original sequence case multiple ways restore want choose a way restore maximize value $$$ $$$ f ( a ) = \max ( 0 a_1 ( a_1 + a_2 ) ( a_1 + a_2 + a_3 ) \dots ( a_1 + a_2 + a_3 + \dots + a _ { n + m } ) ) $$$ $$$ help monocarp calculate maximum possible value $$$ f ( a ) $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case follow test case consist four line first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) second line contain $$$ n $$$ integers $$$ r_1 r_2 \dots r_n $$$ ( $$$ -100 \le r_i \le 100 $$$ ) third line contain one integer $$$ m $$$ ( $$$ 1 \le m \le 100 $$$ ) fourth line contain $$$ m $$$ integers $$$ b_1 b_2 \dots b_m $$$ ( $$$ -100 \le b_i \le 100 $$$ ) test case print one integer — maximum possible value $$$ f ( a ) $$$ explanations sample test case red elements mark bold first test case one possible sequence $$$ a $$$ $$$ [ \mathbf { 6 } 2 \mathbf { -5 } 3 \mathbf { 7 } \mathbf { -3 } -4 ] $$$ second test case one possible sequence $$$ a $$$ $$$ [ 10 \mathbf { 1 } -3 \mathbf { 1 } 2 2 ] $$$ third test case one possible sequence $$$ a $$$ $$$ [ \mathbf { -1 } -1 -2 -3 \mathbf { -2 } -4 -5 \mathbf { -3 } \mathbf { -4 } \mathbf { -5 } ] $$$ fourth test case one possible sequence $$$ a $$$ $$$ [ 0 \mathbf { 0 } ] $$$,"['dp', 'greedy']",1000.0
1469/C,want build a fence consist $$$ n $$$ equal section section a width equal $$$ 1 $$$ height equal $$$ k $$$ place section one line side side unfortunately grind beneath fence flat simplicity think grind level $$$ i $$$ -th section equal $$$ h_i $$$ follow several rule build fence : possible build a fence meet rule ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 200000 $$$ ; $$$ 2 \le k \le 100000000 $$$ ) — number section fence height section second line test case contain $$$ n $$$ integers $$$ h_1 h_2 \dots h_n $$$ ( $$$ 0 \le h_i \le 100000000 $$$ ) $$$ h_i $$$ grind level beneath $$$ i $$$ -th section 's guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print yes 's possible build fence meet rule otherwise print may print letter case ( example yes yes yes yes recognize positive answer ) first test case one possible fence show picture second test case accord second rule build section correspond grind level since $$$ k = 3 $$$ $$$ h_1 = 0 $$$ $$$ h_2 = 2 $$$ first rule also fulfil third test case accord second rule build first section height $$$ 3 $$$ third section height $$$ 2 $$$ accord first rule second section height least $$$ 2 $$$ ( a common side first section ) accord third rule second section build height $$$ h_2 + k - 1 = 1 $$$,"['dp', 'greedy', 'implementation', 'two pointers']",1600.0
1469/F,// decide drop legend power sockets feel free come : ^ ) define a chain : give $$$ n $$$ chain lengths $$$ l_1 l_2 \dots l_n $$$ plan build a tree use distance two vertices tree number edge shortest path least $$$ k $$$ white vertices result tree value tree distance root $$$ k $$$ -th closest white vertex 's minimum value tree obtain ? way build a tree least $$$ k $$$ white vertices print -1 . first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 2 \le k \le 1000000000 $$$ ) — number chain minimum number white vertices a tree a value second line contain $$$ n $$$ integers $$$ l_1 l_2 \dots l_n $$$ ( $$$ 3 \le l_i \le 200000 $$$ ) — lengths chain print a single integer way build a tree least $$$ k $$$ white vertices print -1 . otherwise print minimum value tree allow use chain 's optimal use chain length $$$ 4 $$$ second example,"['binary search', 'data structures', 'greedy']",2600.0
1472/F,every year santa claus give gift children however country traditions process take place different ways example berland need solve new year 's puzzle polycarp get follow problem : give a grid strip size $$$ 2 \times n $$$ cells block need check possible tile free cells use $$$ 2 \times 1 $$$ $$$ 1 \times 2 $$$ tile ( dominoes ) example $$$ n = 5 $$$ strip look like ( black cells block ) : tile example use two vertical two horizontal tile picture ( different tile mark different color ) $$$ n = 3 $$$ strip look like : impossible tile free cells polycarp easily solve task receive new year 's gift solve ? first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case $$$ t $$$ test case follow test case precede empty line first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 1000000000 $$$ $$$ 1 \le m \le 200000 $$$ ) — length strip number block cells next $$$ m $$$ line contain two integers $$$ r_i c_i $$$ ( $$$ 1 \le r_i \le 2 1 \le c_i \le n $$$ ) — number row columns block cells guarantee block cells different i.e $$$ ( r_i c_i ) \ne ( r_j c_j ) i \ne j $$$ guarantee sum $$$ m $$$ test case exceed $$$ 200000 $$$ test case print a separate line : output ` ` yes '' ` ` '' case ( example string yes yes yes yes recognize positive ) first two test case explain statement third test case strip look like :,"['brute force', 'dp', 'greedy', 'sortings']",2100.0
1473/C,a sequence $$$ a $$$ $$$ n $$$ elements $$$ 1 2 3 \dots k - 1 k k - 1 k - 2 \dots k - ( n - k ) $$$ ( $$$ k \le n < 2k $$$ ) let 's call inversion $$$ a $$$ a pair indices $$$ i < j $$$ $$$ a [ i ] > a [ j ] $$$ suppose permutation $$$ p $$$ size $$$ k $$$ build a sequence $$$ b $$$ size $$$ n $$$ follow manner : $$$ b [ i ] = p [ a [ i ] ] $$$ goal find permutation $$$ p $$$ total number inversions $$$ b $$$ n't exceed total number inversions $$$ a $$$ $$$ b $$$ lexicographically maximum small reminder : sequence $$$ k $$$ integers call a permutation contain integers $$$ 1 $$$ $$$ k $$$ exactly another small reminder : a sequence $$$ s $$$ lexicographically smaller another sequence $$$ t $$$ either $$$ s $$$ a prefix $$$ t $$$ first $$$ i $$$ $$$ s_i \ne t_i $$$ $$$ s_i < t_i $$$ hold ( first position sequence different $$$ s $$$ smaller number $$$ t $$$ ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ k \le n < 2k $$$ ; $$$ 1 \le k \le 100000 $$$ ) — length sequence $$$ a $$$ maximum 's guarantee total sum $$$ k $$$ test case n't exceed $$$ 100000 $$$ test case print $$$ k $$$ integers — permutation $$$ p $$$ maximize $$$ b $$$ lexicographically without increase total number inversions prove $$$ p $$$ exist unique first test case sequence $$$ a = [ 1 ] $$$ one permutation $$$ p = [ 1 ] $$$ second test case sequence $$$ a = [ 1 2 ] $$$ inversion $$$ a $$$ one permutation $$$ p = [ 1 2 ] $$$ n't increase number inversions third test case $$$ a = [ 1 2 1 ] $$$ $$$ 1 $$$ inversion use $$$ p = [ 2 1 ] $$$ $$$ b = [ p [ a [ 1 ] ] p [ a [ 2 ] ] p [ a [ 3 ] ] ] = [ 2 1 2 ] $$$ also $$$ 1 $$$ inversion fourth test case $$$ a = [ 1 2 3 2 ] $$$ since $$$ p = [ 1 3 2 ] $$$ $$$ b = [ 1 3 2 3 ] $$$ $$$ a $$$ $$$ b $$$ $$$ 1 $$$ inversion $$$ b $$$ lexicographically maximum,['math'],1500.0
1475/A,give integer $$$ n $$$ check $$$ n $$$ odd divisor greater one ( exist a number $$$ x $$$ ( $$$ x > 1 $$$ ) $$$ n $$$ divisible $$$ x $$$ $$$ x $$$ odd ) example $$$ n=6 $$$ $$$ x=3 $$$ $$$ n=4 $$$ a number exist first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow test case contain one integer $$$ n $$$ ( $$$ 2 \le n \le 10^ { 14 } $$$ ) please note input test case wo n't fit $$$ 32 $$$ -bit integer type use least $$$ 64 $$$ -bit integer type program language test case output a separate line : output ` ` yes '' ` ` '' case ( example string yes yes yes yes recognize positive ),"['math', 'number theory']",900.0
1475/G,polycarp find street array $$$ a $$$ $$$ n $$$ elements polycarp invent criterion beauty array call array $$$ a $$$ beautiful least one follow condition must meet different pair indices $$$ i \ne j $$$ : example : ugly array upset polycarp want remove elements array $$$ a $$$ become beautiful help polycarp determine smallest number elements remove make array $$$ a $$$ beautiful first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 10 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — length array $$$ a $$$ second line test case contain $$$ n $$$ number $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 200000 $$$ ) — elements array $$$ a $$$ test case output one integer — minimum number elements must remove make array $$$ a $$$ beautiful first test case remove $$$ 7 $$$ $$$ 14 $$$ make array $$$ a $$$ beautiful second test case array $$$ a $$$ already beautiful third test case remove one elements $$$ 45 $$$ $$$ 18 $$$ make array $$$ a $$$ beautiful fourth test case array $$$ a $$$ beautiful,"['dp', 'math', 'number theory', 'sortings']",1900.0
1477/A,"$$$ n $$$ distinct integers $$$ x_1 x_2 \ldots x_n $$$ write board nezzar perform follow operation multiple time , nezzar wonder possible favorite number $$$ k $$$ board apply operation multiple time first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case first line test case contain two integers $$$ n k $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ -10^ { 18 } \le k \le 10^ { 18 } $$$ ) second line test case contain $$$ n $$$ distinct integers $$$ x_1 x_2 \ldots x_n $$$ ( $$$ -10^ { 18 } \le x_i \le 10^ { 18 } $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print ` ` yes '' a single line possible $$$ k $$$ board otherwise print ` ` '' print letter case ( upper lower ) first test case number $$$ 1 $$$ already board second test case nezzar could perform follow operations write $$$ k=0 $$$ board : third test case impossible number $$$ k = -1 $$$ board","['math', 'number theory']",1800.0
1479/B1,"difference two versions version ask maximal possible answer homer like array a lot today paint array $$$ a_1 a_2 \dots a_n $$$ two kinds color white black a paint assignment $$$ a_1 a_2 \dots a_n $$$ describe array $$$ b_1 b_2 \dots b_n $$$ $$$ b_i $$$ indicate color $$$ a_i $$$ ( $$$ 0 $$$ white $$$ 1 $$$ black ) accord a paint assignment $$$ b_1 b_2 \dots b_n $$$ array $$$ a $$$ split two new array $$$ a^ { ( 0 ) } $$$ $$$ a^ { ( 1 ) } $$$ $$$ a^ { ( 0 ) } $$$ sub - sequence white elements $$$ a $$$ $$$ a^ { ( 1 ) } $$$ sub - sequence black elements $$$ a $$$ example $$$ a = [ 1,2,3,4,5,6 ] $$$ $$$ b = [ 0,1,0,1,0,0 ] $$$ $$$ a^ { ( 0 ) } = [ 1,3,5,6 ] $$$ $$$ a^ { ( 1 ) } = [ 2,4 ] $$$ number segment array $$$ c_1 c_2 \dots c_k $$$ denote $$$ \mathit { seg } ( c ) $$$ number elements merge adjacent elements value $$$ c $$$ example number segment $$$ [ 1,1,2,2,3,3,3,2 ] $$$ $$$ 4 $$$ array become $$$ [ 1,2,3,2 ] $$$ merge adjacent elements value especially number segment empty array $$$ 0 $$$ homer want find a paint assignment $$$ b $$$ accord number segment $$$ a^ { ( 0 ) } $$$ $$$ a^ { ( 1 ) } $$$ i.e $$$ \mathit { seg } ( a^ { ( 0 ) } ) + \mathit { seg } ( a^ { ( 1 ) } ) $$$ large possible find number first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) output a single integer indicate maximal possible total number segment first example choose $$$ a^ { ( 0 ) } = [ 1,2,3,3 ] $$$ $$$ a^ { ( 1 ) } = [ 1,2,3 ] $$$ $$$ \mathit { seg } ( a^ { ( 0 ) } ) = \mathit { seg } ( a^ { ( 1 ) } ) = 3 $$$ answer $$$ 3 + 3 = 6 $$$ second example choose $$$ a^ { ( 0 ) } = [ 1,2,3,4,5,6,7 ] $$$ $$$ a^ { ( 1 ) } $$$ empty see $$$ \mathit { seg } ( a^ { ( 0 ) } ) = 7 $$$ $$$ \mathit { seg } ( a^ { ( 1 ) } ) = 0 $$$ answer $$$ 7 + 0 = 7 $$$","['data structures', 'dp', 'greedy', 'implementation']",1900.0
1479/B2,"difference two versions version ask minimal possible answer homer like array a lot today paint array $$$ a_1 a_2 \dots a_n $$$ two kinds color white black a paint assignment $$$ a_1 a_2 \dots a_n $$$ describe array $$$ b_1 b_2 \dots b_n $$$ $$$ b_i $$$ indicate color $$$ a_i $$$ ( $$$ 0 $$$ white $$$ 1 $$$ black ) accord a paint assignment $$$ b_1 b_2 \dots b_n $$$ array $$$ a $$$ split two new array $$$ a^ { ( 0 ) } $$$ $$$ a^ { ( 1 ) } $$$ $$$ a^ { ( 0 ) } $$$ sub - sequence white elements $$$ a $$$ $$$ a^ { ( 1 ) } $$$ sub - sequence black elements $$$ a $$$ example $$$ a = [ 1,2,3,4,5,6 ] $$$ $$$ b = [ 0,1,0,1,0,0 ] $$$ $$$ a^ { ( 0 ) } = [ 1,3,5,6 ] $$$ $$$ a^ { ( 1 ) } = [ 2,4 ] $$$ number segment array $$$ c_1 c_2 \dots c_k $$$ denote $$$ \mathit { seg } ( c ) $$$ number elements merge adjacent elements value $$$ c $$$ example number segment $$$ [ 1,1,2,2,3,3,3,2 ] $$$ $$$ 4 $$$ array become $$$ [ 1,2,3,2 ] $$$ merge adjacent elements value especially number segment empty array $$$ 0 $$$ homer want find a paint assignment $$$ b $$$ accord number segment $$$ a^ { ( 0 ) } $$$ $$$ a^ { ( 1 ) } $$$ i.e $$$ \mathit { seg } ( a^ { ( 0 ) } ) + \mathit { seg } ( a^ { ( 1 ) } ) $$$ small possible find number first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) output a single integer indicate minimal possible total number segment first example choose $$$ a^ { ( 0 ) } = [ 1,1,2,2 ] $$$ $$$ a^ { ( 1 ) } = [ 2,3 ] $$$ $$$ \mathit { seg } ( a^ { ( 0 ) } ) = \mathit { seg } ( a^ { ( 1 ) } ) = 2 $$$ answer $$$ 2 + 2 = 4 $$$ second example choose $$$ a^ { ( 0 ) } = [ 1,1,1,1 ] $$$ $$$ a^ { ( 1 ) } = [ 2,2,2 ] $$$ $$$ \mathit { seg } ( a^ { ( 0 ) } ) = \mathit { seg } ( a^ { ( 1 ) } ) = 1 $$$ answer $$$ 1 + 1 = 2 $$$","['data structures', 'dp', 'greedy', 'implementation']",2100.0
148/A,« one dragon two dragon three dragon » — princess count trouble fall asleep get bore count <unknown> nine however count dragons bore well entertain best could tonight imagine dragons steal fight every k - th dragon get punch face a fry pan every l - th dragon get tail shut balcony door every m - th dragon get paw <unknown> <unknown> <unknown> finally threaten every n - th dragon call mom withdraw panic many imaginary dragons suffer moral physical damage tonight princess count a total d dragons ? input data contain integer number k l m n d number a separate line ( 1 ≤ k l m n ≤ 10 1 ≤ d ≤ 105 ) output number damage dragons first case every first dragon get punch a fry pan dragons suffer reason well pan alone would enough second case dragons 1 7 11 13 17 19 23 escape <unknown>,"['implementation', 'math']",800.0
148/B,princess go escape dragon 's cave need plan carefully princess run vp miles per hour dragon fly vd miles per hour dragon discover escape t hours chase princess immediately look like 's chance success princess notice dragon greedy smart delay princess decide borrow a couple bijous treasury dragon overtake princess drop one bijou distract case stop pick item return cave spend f hours <unknown> things treasury resume chase begin princess go run straight distance cave king 's castle 's aim c miles many bijous need take treasury able reach castle ? dragon overtake princess exactly moment reach castle assume reach castle dragon reach n't need extra bijou hold input data contain integers vp vd t f c one per line ( 1 ≤ vp vd ≤ 100 1 ≤ t f ≤ 10 1 ≤ c ≤ 1000 ) output minimal number bijous require escape succeed first case one hour escape dragon discover princess 1 mile away cave two hours dragon overtake princess 2 miles away cave need drop first bijou return cave fix treasury take dragon two hours ; meanwhile princess 4 miles away cave next time dragon overtake princess 8 miles away cave need second bijou reach castle without trouble second case similar first one second time dragon overtake princess reach castle wo n't need second bijou,"['implementation', 'math']",1500.0
148/C,"« next please » — princess call cast estimate glance next groom princess intend choose worthy groom , richest one whenever see a groom rich previous ones say a measure « oh ... » whenever groom richer previous ones add together exclaim « wow ! » ( « oh ... » case ) sight first groom princess stay calm say nothing fortune groom describe integer 1 50000 . know day princess saw n groom say « oh ... » exactly a time exclaim « wow ! » exactly b time task output a sequence n integers t1 t2 ... tn ti describe fortune i - th groom several sequence possible output sequence exist would satisfy requirements output a single number -1 . line input data contain three integer number n a b ( 1 ≤ n ≤ 100 0 ≤ a b ≤ 15 n > a + b ) separate single space output sequence integers t1 t2 ... tn ti ( 1 ≤ ti ≤ 50000 ) fortune i - th groom satisfy give constraints sequence exist would satisfy requirements output a single number -1 . let 's a closer look answer first sample test",['greedy'],1700.0
148/E,<unknown> princess usually smash <unknown> porcelain every furious shriek accompany one item smash collection porcelain arrange neatly n shelve within shelf items place one row one access outermost items — leftmost rightmost item ones middle shelf item take next item side shelf access ( see example ) item take ca n't return shelve give value items task find maximal damage princess ' tantrum m shriek inflict collection porcelain first line input data contain two integers n ( 1 ≤ n ≤ 100 ) m ( 1 ≤ m ≤ 10000 ) next n line contain value items shelve : first number give number items shelf ( integer 1 100 inclusive ) follow value items ( integers 1 100 inclusive ) order appear shelf ( first number correspond leftmost item last one — rightmost one ) total number items guarantee least m. output maximal total value a tantrum m shriek first case two shelve three items maximize total value items choose one take two items leave side first shelf one item right side second shelf second case one shelf three items take — two leave side one right side,['dp'],1900.0
1480/B,"great hero guard country homer live hero attack power $$$ a $$$ initial health value $$$ b $$$ $$$ n $$$ monsters front hero $$$ i $$$ -th monster attack power $$$ a_i $$$ initial health value $$$ b_i $$$ hero a monster say live health value positive ( greater equal $$$ 1 $$$ ) ; say dead health value non - positive ( less equal $$$ 0 $$$ ) order protect people country hero fight monsters either hero dead monsters dead note hero fight monster safety people country please tell whether great hero kill monsters ( even great hero dead kill last monster ) test contain multiple test case first line contain $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case description test case follow first line test case contain three integers $$$ a $$$ ( $$$ 1 \leq a \leq 1000000 $$$ ) $$$ b $$$ ( $$$ 1 \leq b \leq 1000000 $$$ ) $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — attack power great hero initial health value great hero number monsters second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000 $$$ ) $$$ a_i $$$ denote attack power $$$ i $$$ -th monster third line test case contain $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ 1 \leq b_i \leq 1000000 $$$ ) $$$ b_i $$$ denote initial health value $$$ i $$$ -th monster guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print answer : ` ` yes '' ( without quote ) great hero kill monsters otherwise print ` ` '' ( without quote ) first example : $$$ 6 $$$ fight hero monster , monster dead health value hero become $$$ 17 - 6 \times 2 = 5 > 0 $$$ answer ` ` yes '' moreover hero still live second example : monsters dead health value hero become $$$ <unknown> $$$ regardless order fight answer ` ` yes '' third example : a possible order fight $$$ 1 $$$ -st $$$ 2 $$$ -nd $$$ 3 $$$ -rd $$$ 4 $$$ -th monsters fight health value hero become $$$ <unknown> $$$ unfortunately hero dead monsters also dead answer ` ` yes '' fourth example : hero become dead monster still live health value $$$ 1000 - 999 = 1 $$$ answer ` ` ''","['greedy', 'implementation', 'sortings']",900.0
1481/B,"reach destination want build a new colony new planet since planet many mountains colony must build a flat surface decide <unknown> mountains use boulders ( still dream make sense ) give array $$$ h_1 h_2 \dots h_n $$$ $$$ h_i $$$ height $$$ i $$$ -th mountain $$$ k $$$ — number boulders start throw boulders top first mountain one one roll follow ( let 's assume height current mountain $$$ h_i $$$ ) : want find position $$$ k $$$ -th boulder determine fall waste collection system first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case test case consist two line first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100 $$$ ; $$$ 1 \le k \le 1000000000 $$$ ) — number mountains number boulders second line contain $$$ n $$$ integers $$$ h_1 h_2 \dots h_n $$$ ( $$$ 1 \le h_i \le 100 $$$ ) — height mountains guarantee sum $$$ n $$$ test case exceed $$$ 100 $$$ test case print $$$ -1 $$$ $$$ k $$$ -th boulder fall collection system otherwise print position $$$ k $$$ -th boulder let 's simulate first case : position boulder stop follow : $$$ [ 2,3,2 ] $$$ second case $$$ 7 $$$ boulders stop right first mountain rise height $$$ 1 $$$ $$$ 8 $$$ third case similar first one 'll throw $$$ 5 $$$ boulders first three roll way first test case , mountain heights equal $$$ [ 4 3 3 3 ] $$$ 's two boulders fall collection system fourth case first boulders fall straight collection system","['brute force', 'greedy', 'implementation']",1100.0
1481/E,one day want read something go bookshelf grab book saw messy bookshelf decide clean first $$$ n $$$ book stand a row shelf $$$ i $$$ -th book color $$$ a_i $$$ 'd like rearrange book make shelf look beautiful shelf consider beautiful book color next one operation take one book position shelf move right end shelf minimum number operations need make shelf beautiful ? first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) — number book second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — book color output minimum number operations make shelf beautiful first example bookshelf $$$ [ 1 2 2 1 3 ] $$$ example : second example move first book end bookshelf get $$$ [ <unknown> ] $$$,"['data structures', 'dp', 'greedy']",2500.0
1482/E,alice visit new york city make trip fun alice take photos city skyline give set photos a present bob however want find set photos maximum beauty need help $$$ n $$$ build city $$$ i $$$ -th positive height $$$ h_i $$$ $$$ n $$$ build heights city different addition build a beauty value $$$ b_i $$$ note beauty positive negative ugly build city a set photos consist one photos build skyline photo include one build skyline form a contiguous segment indices build need exactly one photo mean a build appear photo a build appear one photo set picture valid beauty a photo equivalent beauty $$$ b_i $$$ shortest build total beauty a set photos sum beauty photos help alice find maximum beauty a valid set photos first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) number build skyline second line contain $$$ n $$$ distinct integers $$$ h_1 h_2 \ldots h_n $$$ ( $$$ 1 \le h_i \le n $$$ ) $$$ i $$$ -th number represent height build $$$ i $$$ third line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ -1000000000 \le b_i \le 1000000000 $$$ ) $$$ i $$$ -th number represent beauty build $$$ i $$$ print one number represent maximum beauty alice achieve a valid set photos skyline first example alice achieve maximum beauty take five photos one contain one build second example alice achieve a maximum beauty $$$ 10 $$$ take four picture : three contain one build build $$$ 1 $$$ $$$ 2 $$$ $$$ 5 $$$ photo beauty $$$ -3 $$$ $$$ 4 $$$ $$$ 7 $$$ respectively another photo contain build $$$ 3 $$$ $$$ 4 $$$ beauty $$$ 2 $$$ third example alice take one picture whole city fourth example alice take follow picture achieve maximum beauty : photos one build build $$$ 1 $$$ $$$ 2 $$$ $$$ 8 $$$ $$$ 9 $$$ $$$ 10 $$$ a single photo build $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ $$$ 6 $$$ $$$ 7 $$$,"['data structures', 'divide and conquer', 'dp']",2100.0
1485/E,give $$$ n - 1 $$$ integers $$$ a_2 \dots a_n $$$ a tree $$$ n $$$ vertices root vertex $$$ 1 $$$ leave distance $$$ d $$$ root recall a tree a connect undirected graph without cycle distance two vertices number edge simple path non - root vertices degree $$$ 1 $$$ leave vertices $$$ s $$$ $$$ f $$$ connect edge distance $$$ f $$$ root greater distance $$$ s $$$ root $$$ f $$$ call a child $$$ s $$$ initially a red coin a blue coin vertex $$$ 1 $$$ let $$$ r $$$ vertex red coin let $$$ b $$$ vertex blue coin make $$$ d $$$ move a move consist three step : note $$$ r $$$ $$$ b $$$ equal time number write root move gain $$$ <unknown> - <unknown> $$$ point 's maximum number point gain $$$ d $$$ move ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 200000 $$$ ) — number vertices tree second line test case contain $$$ n-1 $$$ integers $$$ v_2 v_3 \dots v_n $$$ ( $$$ 1 \leq v_i \leq n $$$ $$$ v_i \neq i $$$ ) — $$$ i $$$ -th indicate edge vertices $$$ i $$$ $$$ v_i $$$ guarantee edge form a tree third line test case contain $$$ n-1 $$$ integers $$$ a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — number write vertices guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print a single integer : maximum number point gain $$$ d $$$ move first test case optimal solution : total number point $$$ |7 - 2| + |6 - 9| + |3 - 9| = 14 $$$ second test case optimal solution : total number point $$$ <unknown> - <unknown> + <unknown> - <unknown> + |5 - <unknown> = 45 $$$,"['dfs and similar', 'dp', 'greedy', 'trees']",2500.0
1486/B,friends live $$$ n $$$ house house locate a 2d plane a point integer coordinate might different house locate point mayor city ask place build <unknown> exhibition find number place ( point integer coordinate ) summary distance house exhibition minimal exhibition build point house distance two point $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ $$$ |x_1 - x_2| + |y_1 - y_2| $$$ $$$ |x| $$$ absolute value $$$ x $$$ first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000 ) $$$ — number test case first line test case contain a single integer $$$ n $$$ $$$ ( 1 \leq n \leq 1000 ) $$$ next $$$ n $$$ line describe position house $$$ ( x_i y_i ) $$$ $$$ ( 0 \leq x_i y_i \leq 1000000000 ) $$$ 's guarantee sum $$$ n $$$ exceed $$$ 1000 $$$ test case output a single integer - number different position exhibition exhibition build point house image example test case blue dot stand house green — possible position exhibition first test case second test case third test case fourth test case fifth test case sixth test case house locate $$$ ( 0 0 ) $$$,"['binary search', 'geometry', 'shortest paths', 'sortings']",1500.0
1487/B,suppose live two cat : a b. $$$ n $$$ nap spot cat usually sleep cat like sleep also like spot change nap spot hour cyclically : cat b much younger a strict hierarchy : a b n't lie together word cat 'd like go spot $$$ x $$$ a take place b move next place order ( $$$ x < n $$$ $$$ x + 1 $$$ $$$ x = n $$$ $$$ 1 $$$ ) cat b follow order wo n't return skip spot $$$ x $$$ a free move spot $$$ x + 2 $$$ calculate cat b hour $$$ k $$$ ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 1000000000 $$$ ; $$$ 1 \le k \le 1000000000 $$$ ) — number spot hour $$$ k $$$ test case print one integer — index spot cat b sleep hour $$$ k $$$ first second test case $$$ n = 2 $$$ : sixth test case :,"['math', 'number theory']",1200.0
1487/C,"a big football championship occur soon ! $$$ n $$$ team compete pair team play exactly one game two possible outcomes a game : score a team number point gain game play interest a hypothetical situation team get score end championship a simple example situation game result tie want minimize number tie well task describe a situation ( choose result game ) team get score number tie minimum possible first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case test case follow test case describe one line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — number team test case print $$$ \frac { n ( n - 1 ) } { 2 } $$$ integers describe result game follow order : first integer correspond match team $$$ 1 $$$ team $$$ 2 $$$ second — team $$$ 1 $$$ team $$$ 3 $$$ $$$ 1 $$$ $$$ 4 $$$ ... $$$ 1 $$$ $$$ n $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 2 $$$ $$$ 4 $$$ ... $$$ 2 $$$ $$$ n $$$ , game team $$$ n - 1 $$$ team $$$ n $$$ integer correspond game team $$$ x $$$ team $$$ y $$$ $$$ 1 $$$ $$$ x $$$ win $$$ -1 $$$ $$$ y $$$ win $$$ 0 $$$ game result a tie team get score number tie minimum possible multiple optimal answer print show always exist a way make team score first test case example team get $$$ 1 $$$ point since game a tie second test case example team $$$ 1 $$$ defeat team $$$ 2 $$$ ( team $$$ 1 $$$ get $$$ 3 $$$ point ) team $$$ 1 $$$ lose team $$$ 3 $$$ ( team $$$ 3 $$$ get $$$ 3 $$$ point ) team $$$ 2 $$$ win team $$$ 3 $$$ ( team $$$ 2 $$$ get $$$ 3 $$$ point )","['brute force', 'dfs and similar', 'graphs', 'greedy', 'implementation', 'math']",1500.0
1487/G,$$$ c_1 $$$ letter ' a ' $$$ c_2 $$$ letter ' b ' ... $$$ c _ { 26 } $$$ letter ' z ' want build a beautiful string length $$$ n $$$ ( obviously use $$$ i $$$ -th letter $$$ c_i $$$ time ) $$$ c_i $$$ greater $$$ \frac { n } { 3 } $$$ a string call beautiful palindromic contiguous substrings odd length greater $$$ 1 $$$ example string ` ` abacaba '' beautiful several palindromic substrings odd length greater $$$ 1 $$$ ( example ` ` aca '' ) another example : string ` ` abcaa '' beautiful calculate number different string build print answer modulo $$$ 998244353 $$$ first line contain one integer $$$ n $$$ ( $$$ 3 \le n \le 400 $$$ ) second line contain $$$ 26 $$$ integers $$$ c_1 $$$ $$$ c_2 $$$ ... $$$ c _ { 26 } $$$ ( $$$ \frac { n } { 3 } < c_i \le n $$$ ) print one integer — number string build take modulo $$$ 998244353 $$$,"['combinatorics', 'dp', 'math']",2700.0
1488/H,"give integer $$$ n $$$ a sequence $$$ a $$$ $$$ n-1 $$$ integers element either $$$ 0 $$$ $$$ 1 $$$ ask build a string length $$$ n $$$ : ask $$$ q $$$ query form : query print number different string satisfy give constraints modulo $$$ 998\,244\,353 $$$ first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \le n \le 100000 $$$ ; $$$ 1 \le q \le 100000 $$$ ) — length string number query second line contain $$$ n-1 $$$ integers $$$ a_1 a_2 \dots a _ { n-1 } $$$ ( $$$ a_i \in \ { 0 1\ } $$$ ) — constraints suffix string next $$$ q $$$ line contain a query : integer $$$ i $$$ ( $$$ 1 \le i \le n - 1 $$$ ) — flip value $$$ a_i $$$ ( $$$ a_i=0 $$$ set $$$ a_i $$$ $$$ 1 $$$ vice versa ) query print number different string satisfy give constraints modulo $$$ 998\,244\,353 $$$ $$$ i $$$ -th suffix a string a continuous substring start $$$ i $$$ -th position end last position a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ one follow hold : two string $$$ a $$$ $$$ b $$$ length $$$ n $$$ differ exist a position $$$ i $$$ $$$ a_i \neq b_i $$$","['combinatorics', 'data structures']",2800.0
1490/B,"give a number $$$ n $$$ ( divisible $$$ 3 $$$ ) array $$$ a [ 1 \dots n ] $$$ one move increase array elements one formally choose index $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) replace $$$ a_i $$$ $$$ a_i + 1 $$$ choose index $$$ i $$$ multiple time different move let 's denote $$$ c_0 $$$ $$$ c_1 $$$ $$$ c_2 $$$ number number array $$$ a $$$ remainder $$$ 0 $$$ $$$ 1 $$$ $$$ 2 $$$ divide number $$$ 3 $$$ respectively let 's say array $$$ a $$$ balance remainder $$$ c_0 $$$ $$$ c_1 $$$ $$$ c_2 $$$ equal example $$$ n = 6 $$$ $$$ a = [ 0 2 5 5 4 8 ] $$$ follow sequence move possible : find minimum number move need make array $$$ a $$$ balance remainder first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 3 \le n \le 30000 $$$ ) — length array $$$ a $$$ guarantee number $$$ n $$$ divisible $$$ 3 $$$ next line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 100 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 150\,000 $$$ test case output one integer — minimum number move must make $$$ a $$$ array make balance remainder first test case explain statements second test case need make one move $$$ i=2 $$$ third test case need make three move : fourth test case value $$$ c_0 $$$ $$$ c_1 $$$ $$$ c_2 $$$ initially equal array $$$ a $$$ already balance remainder","['brute force', 'math']",1000.0
1490/G,polycarp <unknown> attic find old <unknown> drive a round disc insert drive $$$ n $$$ integers write polycarp write number disk $$$ a $$$ array turn drive work accord follow algorithm : polycarp want learn operation drive absolutely free time ask $$$ m $$$ question answer $$$ i $$$ -th need find many second drive work give $$$ x_i $$$ input please note case drive work infinitely example $$$ n=3 m=3 $$$ $$$ a= [ 1 -3 4 ] $$$ $$$ x= [ 1 5 2 ] $$$ answer question follow : first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow first line test case consist two positive integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200000 $$$ ) — number number disk number ask question second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) third line test case contain $$$ m $$$ positive integers $$$ x_1 x_2 \ldots x_m $$$ ( $$$ 1 \le x \le 1000000000 $$$ ) guarantee sum $$$ n $$$ $$$ m $$$ test case exceed $$$ 200000 $$$ print $$$ m $$$ number a separate line test case $$$ i $$$ -th number :,"['binary search', 'data structures', 'math']",1900.0
1491/B,"a graph $$$ n $$$ row $$$ 1000000 + 2 $$$ columns row number $$$ 1 $$$ $$$ n $$$ columns $$$ 0 $$$ $$$ 1000000 + 1 $$$ : let 's denote node row $$$ i $$$ column $$$ j $$$ $$$ ( i j ) $$$ initially $$$ i $$$ $$$ i $$$ -th row exactly one obstacle — node $$$ ( i a_i ) $$$ want move obstacles reach node $$$ ( n 1000000 + 1 ) $$$ node $$$ ( 1 0 ) $$$ move edge graph ( ca n't pass obstacles ) move one obstacle adjacent edge free node cost $$$ u $$$ $$$ v $$$ coin : refer picture a better understand need calculate minimal number coin need spend able reach node $$$ ( n 1000000 + 1 ) $$$ node $$$ ( 1 0 ) $$$ move edge graph without pass obstacles first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain three integers $$$ n $$$ $$$ u $$$ $$$ v $$$ ( $$$ 2 \le n \le 100 $$$ $$$ 1 \le u v \le 1000000000 $$$ ) — number row graph number coin need move vertically horizontally respectively second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) — $$$ a_i $$$ represent obstacle $$$ i $$$ -th row node $$$ ( i a_i ) $$$ 's guarantee sum $$$ n $$$ test case n't exceed $$$ 20000 $$$ test case output a single integer — minimal number coin need spend able reach node $$$ ( n 1000000 + 1 ) $$$ node $$$ ( 1 0 ) $$$ move edge graph without pass obstacles show constraints problem always a way make a trip possible first sample two obstacles $$$ ( 1 2 ) $$$ $$$ ( 2,2 ) $$$ move obstacle $$$ ( 2 2 ) $$$ $$$ ( 2 3 ) $$$ $$$ ( 1 3 ) $$$ total cost $$$ u+v = 7 $$$ coin second sample two obstacles $$$ ( 1 3 ) $$$ $$$ ( 2,2 ) $$$ move obstacle $$$ ( 1 3 ) $$$ $$$ ( 2 3 ) $$$ cost $$$ u = 3 $$$ coin","['brute force', 'math']",1200.0
1492/C,classmate like bore respect intellect two string : $$$ s $$$ length $$$ n $$$ $$$ t $$$ length $$$ m $$$ a sequence $$$ p_1 p_2 \ldots p_m $$$ $$$ 1 \leq p_1 < p_2 < \ldots < p_m \leq n $$$ call beautiful $$$ s _ { p_i } = t_i $$$ $$$ i $$$ $$$ 1 $$$ $$$ m $$$ width a sequence define $$$ \max\limits _ { 1 \le i < m } \left ( p _ { i + 1 } - <unknown> ) $$$ please help classmate identify beautiful sequence maximum width classmate promise give string $$$ s $$$ $$$ t $$$ least one beautiful sequence first input line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq m \leq n \leq 200000 $$$ ) — lengths string $$$ s $$$ $$$ t $$$ follow line contain a single string $$$ s $$$ length $$$ n $$$ consist lowercase letter latin alphabet last line contain a single string $$$ t $$$ length $$$ m $$$ consist lowercase letter latin alphabet guarantee least one beautiful sequence give string output one integer — maximum width a beautiful sequence first example two beautiful sequence width $$$ 3 $$$ : $$$ \ { 1 2 5\ } $$$ $$$ \ { 1 4 5\ } $$$ second example beautiful sequence maximum width $$$ \ { 1 5\ } $$$ third example exactly one beautiful sequence — $$$ \ { 1 2 3 4 5\ } $$$ fourth example exactly one beautiful sequence — $$$ \ { 1 2\ } $$$,"['binary search', 'data structures', 'dp', 'greedy', 'two pointers']",1500.0
1493/B,time planet lapituletti go way go earth a day last $$$ h $$$ hours hour last $$$ m $$$ minutes inhabitants planet use digital clock similar earth ones clock display time a format hh : mm ( number hours decimal display first ( colon ) follow number minutes decimal ; number minutes hours write lead zero need form a two - digit number ) hours number $$$ 0 $$$ $$$ h-1 $$$ minutes number $$$ 0 $$$ $$$ m-1 $$$ 's digits display clock please note digit $$$ 1 $$$ place middle position a standard mirror use planet lapituletti inhabitants often look reflection digital clock mirror feel happy see reflect clock a valid time ( mean see valid digits reflection time see normal clock moment a day ) image clock mirror reflect a vertical axis reflection a valid time reflection a valid time $$$ <unknown> $$$ $$$ m = 60 $$$ however example $$$ h=10 $$$ $$$ <unknown> $$$ reflection a valid time inhabitant planet lapituletti begin look a mirror image clock time moment $$$ s $$$ want know nearest future time moment ( possibly happen next day ) reflect clock time valid show $$$ h $$$ $$$ m $$$ $$$ s $$$ a moment exist reflect time correct moment inhabitant begin look clock moment consider nearest ask solve problem several test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case next $$$ 2 \cdot t $$$ line contain description test case description test case consist two line first line a test case contain two integers $$$ h $$$ $$$ m $$$ ( $$$ 1 \le h m \le 100 $$$ ) second line contain start time $$$ s $$$ describe format hh : mm test case output a separate line nearest moment format hh : mm reflect time correct second test case hard show reflection 23:59 incorrect reflection moment 00:00 next day correct,"['brute force', 'implementation']",1300.0
1494/F,"give undirected connect graph consist $$$ n $$$ vertices $$$ m $$$ edge goal destroy edge give graph may choose vertex start one begin walk along edge walk along edge destroy obviously walk along edge destroy perform mode shift operation walk operation perform vertex ( perform traverse edge ) mode shift edge go delete follow way : first edge mode shift destroy second one destroy third one destroy fourth one destroy , switch back original mode n't perform operation n't want destroy edge give graph ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 3000 $$$ ; $$$ n - 1 \le m \le \min ( \frac { n ( n-1 ) } { 2 } 3000 $$$ ) ) — <unknown> vertices number edge graph $$$ m $$$ line follow contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ ; $$$ x_i \ne y_i $$$ ) — endpoints $$$ i $$$ -th edge edge form a connect undirected graph without multiple edge 's impossible destroy edge print 0 . otherwise print sequence action follow first print $$$ k $$$ — number action ( $$$ k \le 2 m + 2 $$$ ) , print sequence consist $$$ k $$$ integers first integer index start vertex , next integers either index next vertex traversal $$$ -1 $$$ use mode shift allow use mode shift multiple answer print","['brute force', 'dfs and similar', 'graphs', 'implementation']",2900.0
1497/A,give integer $$$ n $$$ array $$$ a_1 a_2 \ldots a_n $$$ reorder elements array $$$ a $$$ way sum $$$ \textbf { mex } $$$ prefix ( $$$ i $$$ -th prefix $$$ a_1 a_2 \ldots a_i $$$ ) maximize formally find array $$$ b_1 b_2 \ldots b_n $$$ set elements array $$$ a $$$ $$$ b $$$ equal ( equivalent array $$$ b $$$ find array $$$ a $$$ reorder elements ) $$$ \sum\limits _ { i=1 } ^ { n } \textbf { mex } ( b_1 b_2 \ldots b_i ) $$$ maximize $$$ \textbf { mex } $$$ a set nonnegative integers minimal nonnegative integer set example $$$ \textbf { mex } ( \ { 1 2 3\ } ) = 0 $$$ $$$ \textbf { mex } ( \ { 0 1 2 4 5\ } ) = 3 $$$ first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 100 ) $$$ — number test case first line test case contain a single integer $$$ n $$$ $$$ ( 1 \le n \le 100 ) $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 0 \le a_i \le 100 ) $$$ test case print array $$$ b_1 b_2 \ldots b_n $$$ — optimal reorder $$$ a_1 a_2 \ldots a_n $$$ sum $$$ \textbf { mex } $$$ prefix maximize exist multiple optimal answer find first test case answer $$$ \textbf { mex } $$$ prefix :,"['brute force', 'data structures', 'greedy', 'sortings']",800.0
1497/D,please note non - standard memory limit $$$ n $$$ problems number integers $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th problem complexity $$$ c_i = 2^i $$$ tag $$$ tag_i $$$ score $$$ s_i $$$ solve problem $$$ i $$$ 's allow solve problem $$$ j $$$ $$$ \text { iq } < |c_i - c_j| $$$ $$$ tag_i \neq <unknown> $$$ solve $$$ \text { iq } $$$ change become $$$ \text { iq } = |c_i - c_j| $$$ gain $$$ |s_i - <unknown> $$$ point problem first solve problems order many time want initially $$$ \text { iq } = 0 $$$ find maximum number point earn first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 100 ) $$$ — number test case first line test case contain integer $$$ n $$$ $$$ ( 1 \le n \le 5000 ) $$$ — number problems second line test case contain $$$ n $$$ integers $$$ <unknown> <unknown> \ldots <unknown> $$$ $$$ ( 1 \le tag_i \le n ) $$$ — tag problems third line test case contain $$$ n $$$ integers $$$ s_1 s_2 \ldots s_n $$$ $$$ ( 1 \le s_i \le 1000000000 ) $$$ — score problems 's guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ test case print a single integer — maximum number point earn first test case optimal sequence solve problems follow : second test case optimal sequence solve problems follow : third test case optimal sequence solve problems follow :,"['bitmasks', 'dp', 'graphs', 'number theory']",2500.0
1499/A,"a board represent a grid $$$ 2 \times n $$$ cells first $$$ k_1 $$$ cells first row first $$$ k_2 $$$ cells second row color white cells color black $$$ w $$$ white dominoes ( $$$ 2 \times 1 $$$ tile cells color white ) $$$ b $$$ black dominoes ( $$$ 2 \times 1 $$$ tile cells color black ) place a white domino board board 's cells white occupy domino way place a black domino cells black occupy domino place $$$ w + b $$$ dominoes board place dominoes horizontally vertically ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 3000 $$$ ) — number test case first line test case contain three integers $$$ n $$$ $$$ k_1 $$$ $$$ k_2 $$$ ( $$$ 1 \le n \le 1000 $$$ ; $$$ 0 \le k_1 k_2 \le n $$$ ) second line test case contain two integers $$$ w $$$ $$$ b $$$ ( $$$ 0 \le w b \le n $$$ ) test case print yes 's possible place $$$ w + b $$$ dominoes board otherwise may print every letter case want ( example string yes yes yes yes recognize positive answer ) first test case $$$ n = 1 $$$ $$$ k_1 = 0 $$$ $$$ k_2 = 1 $$$ mean $$$ 2 \times 1 $$$ board black cell $$$ ( 1 1 ) $$$ white cell $$$ ( 2 1 ) $$$ , ca n't place white domino since one white cell second test case board size $$$ 2 \times 1 $$$ cell white since $$$ w = 0 $$$ $$$ b = 0 $$$ place $$$ 0 + 0 = 0 $$$ dominoes board third test case board $$$ 2 \times 3 $$$ fully color black ( since $$$ k_1 = k_2 = 0 $$$ ) ca n't place white domino fourth test case cells $$$ ( 1 1 ) $$$ $$$ ( 1 2 ) $$$ $$$ ( 1 3 ) $$$ $$$ ( 2 1 ) $$$ white cells black place $$$ 2 $$$ white dominoes position $$$ ( ( 1 1 ) ( 2 1 ) ) $$$ $$$ ( ( 1 2 ) ( 1 3 ) ) $$$ $$$ 2 $$$ black dominoes position $$$ ( ( 1 4 ) ( 2 4 ) ) $$$ $$$ ( ( 2 2 ) ( 2 3 ) ) $$$","['combinatorics', 'math']",800.0
1499/C,let 's say stand $$$ xy $$$ <unknown> point $$$ ( 0 0 ) $$$ want reach point $$$ ( n n ) $$$ move two directions : word path follow structure : n't like change direction much make $$$ n - 1 $$$ direction change a result path a polygonal chain $$$ ( 0 0 ) $$$ $$$ ( n n ) $$$ consist $$$ n $$$ line segment segment positive integer length vertical horizontal segment alternate paths equal $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ $$$ c_i $$$ cost $$$ i $$$ -th segment use cost define cost path sum lengths segment path multiply cost i. e. path consist $$$ k $$$ segment ( $$$ k \le n $$$ ) cost path equal $$$ \sum\limits _ { i=1 } ^ { k } { c_i \cdot <unknown> } $$$ ( segment number $$$ 1 $$$ $$$ k $$$ order path ) find path minimum cost print cost first line contain single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain single integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \le c_i \le 1000000000 $$$ ) — cost segment 's guarantee total sum $$$ n $$$ n't exceed $$$ 100000 $$$ test case print minimum possible cost path $$$ ( 0 0 ) $$$ $$$ ( n n ) $$$ consist $$$ n $$$ alternate segment first test case reach $$$ ( 2 2 ) $$$ need make least one turn path consist exactly $$$ 2 $$$ segment : one horizontal length $$$ 2 $$$ one vertical length $$$ 2 $$$ cost path equal $$$ 2 \cdot c_1 + 2 \cdot c_2 = 26 + 176 = 202 $$$ second test case one optimal paths consist $$$ 3 $$$ segment : first segment length $$$ 1 $$$ second segment length $$$ 3 $$$ third segment length $$$ 2 $$$ cost path $$$ 2 + 9 + 2 = 13 $$$ third test case one optimal paths consist $$$ 4 $$$ segment : first segment length $$$ 1 $$$ second one — $$$ 1 $$$ third one — $$$ 4 $$$ fourth one — $$$ 4 $$$ cost path $$$ 4 + 3 + 8 + 4 = 19 $$$,"['brute force', 'data structures', 'greedy', 'math']",1500.0
15/D,area map a rectangular matrix n × m cell matrix contain average height a correspond area part peter work a company build several cities within area cities occupy a rectangle a × b cells map start construction work a particular place peter need remove excess grind construction site a new city build choose a cell minimum height within site remove excess grind cells site minimum level let 's consider lower grind level h2 h1 ( h1 ≤ h2 ) need remove h2 - h1 grind units let 's call a site 's position optimal amount grind remove site minimal compare possible position peter construct cities accord follow algorithm : optimum site 's position choose uppermost one position unique choose leftmost one build a city site peter repeat process <unknown> build least one city sure carry construction work occupy cells would please help peter place cities accord algorithm ? first line contain four space - separated integers : map size n m city size a b ( 1 ≤ a ≤ n ≤ 1000 1 ≤ b ≤ m ≤ 1000 ) follow n line contain m non - negative space - separated number describe height matrix number n't exceed 109 . first line output k — amount construct cities follow k line output 3 space - separated number — row number column number upper - left corner a subsequent construction site amount grind remove output sit order build,"['data structures', 'implementation', 'sortings']",2500.0
150/A,ca n't possibly imagine cold friends winter nvodsk ! two play follow game warm : initially a piece paper integer q. a move a player write integer number a non - trivial divisor last write number run number circle around hotel let us remind a number 's divisor call non - trivial different one divide number first person ca n't make a move win continue lie warm bed three blanket one keep run determine player win consider players play optimally first player win print win first move first line contain integer q ( 1 ≤ q ≤ 1013 ) please use % lld specificator read write 64 - bit integers с++ prefer use cin cout stream % i64d specificator first line print number win player ( 1 2 ) first player win second line contain another integer — first move ( first player ca n't even make first move print 0 ) multiple solutions print number 6 two non - trivial divisors : 2 3 . impossible make a move number 2 3 write win thus number 6 lose number a player make a move write number 6 number 30 ; 6 know a lose number thus move bring us victory,"['math', 'number theory']",1400.0
150/B,case somebody miss : winter totally cold nvodsk ! cold one get funny thoughts example let 's say string length exactly n base alphabet size m. substring length equal k a palindrome many string exist ? task find quantity modulo 1000000007 ( 109 + 7 ) careful n't miss a string two ! let us remind a string a palindrome read way either direction leave right right leave first line contain three integers : n m k ( 1 ≤ n m k ≤ 2000 ) print a single integer — number string describe type modulo 1000000007 ( 109 + 7 ) first sample one string valid : ` ` a '' ( let 's denote letter alphabet ` ` a '' ) second sample ( denote alphabet letter ` ` a '' ` ` b '' ) follow string valid : ` ` aaaaa '' ` ` bbbbb '',"['combinatorics', 'dfs and similar', 'graphs', 'math']",1600.0
1500/B,"vasya a ceo a big construction company big boss a spacious richly <unknown> office two crystal chandeliers stay motivate vasya need color light office change every day 's order chandeliers change color cyclically example : red – brown – yellow – red – brown – yellow many chandeliers differ color set order color person responsible light make a critical mistake — buy two different chandeliers since chandeliers different days color days — different course look poor annoy vasya a result $$$ k $$$ -th time chandeliers light different color vasya become angry probably fire person buy chandeliers task calculate day happen ( count day chandeliers instal ) think vasya work every day without weekend days first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n m \le 500\,000 $$$ ; $$$ 1 \le k \le 10^ { 12 } $$$ ) — number color first second chandeliers many time color differ anger vasya second line contain $$$ n $$$ different integers $$$ a_i $$$ ( $$$ 1 \le a_i \le 2 \cdot \max ( n m ) $$$ ) describe first chandelier 's sequence color third line contain $$$ m $$$ different integers $$$ b_j $$$ ( $$$ 1 \le b_i \le 2 \cdot \max ( n m ) $$$ ) describe second chandelier 's sequence color $$$ i $$$ -th day first chandelier a color $$$ a_x $$$ $$$ x = ( ( i - 1 ) \mod n ) + 1 ) $$$ second one a color $$$ b_y $$$ $$$ y = ( ( i - 1 ) \mod m ) + 1 ) $$$ 's guarantee sequence $$$ a $$$ differ sequence $$$ b $$$ days color chandeliers differ print single integer — index day vasya become angry first example chandeliers different color days $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 5 $$$ 's answer $$$ 5 $$$","['binary search', 'brute force', 'math', 'number theory']",2200.0
1505/B,many people aware dmca – digital millennium <unknown> act another recently propose dmca – digital millennium calculation act – much less know problem need find a root a number accord new dmca law input contain a single integer $$$ a $$$ ( $$$ 1 \le a \le 1000000 $$$ ) output result – integer number,"['implementation', 'number theory']",1600.0
1508/C,a teacher <unknown> <unknown> often need help students problems various subject today ask a program task go follow give undirected complete graph $$$ n $$$ nod edge pre - assigned a positive weight rest n't need assign unassigned edge non - negative weight result fully - assigned complete graph xor sum weight would equal $$$ 0 $$$ define ugliness a fully - assigned complete graph weight minimum span tree weight a span tree equal sum weight edge need assign weight ugliness result graph small possible a reminder undirected complete graph $$$ n $$$ nod contain edge $$$ ( u v ) $$$ $$$ 1 \le u < v \le n $$$ ; a graph $$$ \frac { n ( n-1 ) } { 2 } $$$ edge sure solve problem ask solve first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 0 \le m \le \min ( 2 \cdot 100000 \frac { n ( n-1 ) } { 2 } - 1 ) $$$ ) — number nod number pre - assigned edge input give least one unassigned edge $$$ i $$$ -th follow $$$ m $$$ line contain three integers $$$ u_i $$$ $$$ v_i $$$ $$$ w_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u \ne v $$$ $$$ 1 \le w_i < 2^ { 30 } $$$ ) represent edge $$$ u_i $$$ $$$ v_i $$$ pre - assigned weight $$$ w_i $$$ edge appear input print one line one integer — minimum ugliness among weight assignments xor sum equal $$$ 0 $$$ follow image showcases first test case black weight pre - assigned statement red weight assign us minimum span tree denote blue edge,"['bitmasks', 'brute force', 'data structures', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'trees']",2500.0
1509/B,"student council a share document file every day members student council write sequence tmt ( short <unknown> <unknown> <unknown> ) however one day members somehow enter sequence document time create a <unknown> mess therefore <unknown> <unknown> 's task figure whether document malfunction specifically give a string length $$$ n $$$ whose character either t m want figure possible partition number disjoint subsequences equal tmt , character string belong exactly one subsequences a string $$$ a $$$ a subsequence a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 3 \le n < 100000 $$$ ) number character string enter document guarantee $$$ n $$$ divisible $$$ 3 $$$ second line test case contain a string length $$$ n $$$ consist character t m. guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print a single line contain yes describe partition exist a single line contain otherwise first test case string already a sequence equal tmt third test case may partition string subsequences <unknown> bolded non - bolded subsequences equal tmt",['greedy'],1100.0
151/A,winter cold nvodsk ! a group n friends decide buy k bottle a <unknown> drink call ` ` take - it - light '' warm a bite bottle l milliliters drink also buy c lime cut d slice find p grams salt make a toast friend need nl milliliters drink a slice lime np grams salt friends want make many toast provide drink amount many toast friend make ? first line contain positive integers n k l c d p nl np exceed 1000 less 1 . number separate exactly one space print a single integer — number toast friend make a comment first sample : overall friends 4 * 5 = 20 milliliters drink enough make 20 / 3 = 6 toast lime enough 10 * 8 = 80 toast salt enough 100 / 1 = 100 toast however 3 friends group answer min ( 6 80 100 ) / 3 = 2,"['implementation', 'math']",800.0
1510/J,"joseph really like culture japan last year learn japanese traditional clothe visual arts try find secret japanese game call nonogram one - dimensional version game a row $$$ n $$$ empty cells fill a pen a description a solution call a profile — a sequence positive integers denote lengths consecutive set fill cells example profile $$$ [ 4 3 1 ] $$$ mean set four three one fill cell order least one empty cell successive set a suitable solution $$$ n = 12 $$$ $$$ p = [ 4 3 1 ] $$$ a wrong solution : first four fill cells consecutive a wrong solution : least one empty cell last fill cell joseph find number $$$ n $$$ profile $$$ p $$$ lot ways fill cells satisfy profile process solve a nonogram consist $$$ n $$$ cells a profile $$$ p $$$ already create a mask $$$ p $$$ — fill cells must fill every solution nonogram mask $$$ n = 12 $$$ $$$ p = [ 4 3 1 ] $$$ : fill cells fill every solution a break lose source profile $$$ p $$$ $$$ n $$$ mask $$$ m $$$ help joseph find profile $$$ p ' $$$ mask $$$ m $$$ say profile joseph make a mistake line contain a string $$$ m $$$ — mask source profile $$$ p $$$ length $$$ m $$$ $$$ n $$$ ( $$$ 1 \le n \le 100\,000 $$$ ) string $$$ m $$$ consist symbols # _ — denote fill empty cells respectively profile mask $$$ m $$$ output number $$$ -1 $$$ otherwise first line output integer $$$ k $$$ — number integers profile $$$ p ' $$$ second line output $$$ k $$$ integers profile $$$ p ' $$$",['math'],2700.0
1513/A,"a sequence $$$ n $$$ integers call a permutation contain integers $$$ 1 $$$ $$$ n $$$ exactly give two integers $$$ n $$$ $$$ k $$$ construct a permutation $$$ a $$$ number $$$ 1 $$$ $$$ n $$$ exactly $$$ k $$$ peak index $$$ i $$$ array $$$ a $$$ size $$$ n $$$ say a peak $$$ 1 < i < n $$$ $$$ a_i \gt a _ { i-1 } $$$ $$$ a_i \gt a _ { i+1 } $$$ permutation possible print $$$ -1 $$$ first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case $$$ t $$$ line follow contain two space - separated integers $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) $$$ k $$$ ( $$$ 0 \leq k \leq n $$$ ) — length array require number peak output $$$ t $$$ line test case permutation give length number peak print $$$ -1 $$$ otherwise print a line contain $$$ n $$$ space - separated integers form a permutation number $$$ 1 $$$ $$$ n $$$ contain exactly $$$ k $$$ peak multiple answer print second test case example array $$$ a = [ <unknown> ] $$$ , indices $$$ i=2 $$$ $$$ i=4 $$$ peak array $$$ ( a _ { 2 } \gt a _ { 1 } $$$ $$$ a _ { 2 } \gt a _ { 3 } ) $$$ $$$ ( a _ { 4 } \gt a _ { 3 } $$$ $$$ a _ { 4 } \gt a _ { 5 } ) $$$",['implementation'],800.0
1515/H,"phoenix love play bits — specifically use bitwise operations , xor $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ perform $$$ q $$$ follow query : query phoenix give $$$ l $$$ $$$ r $$$ $$$ x $$$ note consider value number indices first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 1 \le q \le 100000 $$$ ) — number integers number query respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i < 2^ { 20 } $$$ ) — integers phoenix start next $$$ q $$$ line contain query query first integer line $$$ t $$$ ( $$$ 1 \le t \le 4 $$$ ) — type query $$$ t \in \ { 1 2 3\ } $$$ three integers $$$ l_i $$$ $$$ r_i $$$ $$$ x_i $$$ follow ( $$$ 0 \le l_i r_i x_i < 2^ { 20 } $$$ ; $$$ l_i \le r_i $$$ ) otherwise $$$ t=4 $$$ two integers $$$ l_i $$$ $$$ r_i $$$ follow ( $$$ 0 \le l_i \le r_i < 2^ { 20 } $$$ ) guarantee least one query $$$ t=4 $$$ print answer query $$$ t=4 $$$ first example :","['bitmasks', 'brute force', 'data structures', 'sortings']",3500.0
1519/B,a $$$ n \times m $$$ grid stand cell $$$ ( 1 1 ) $$$ goal finish cell $$$ ( n m ) $$$ move neighbor cells right word suppose stand cell $$$ ( x y ) $$$ : reach cell $$$ ( n m ) $$$ spend exactly $$$ k $$$ burl ? first line contain single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n m \le 100 $$$ ; $$$ 0 \le k \le 10000 $$$ ) — size grid exact amount money need spend test case reach cell $$$ ( n m ) $$$ spend exactly $$$ k $$$ burl print yes otherwise print may print every letter case want ( example string yes yes yes yes recognize positive answer ) first test case already final cell spend $$$ 0 $$$ burl second third fourth test case two paths $$$ ( 1 1 ) $$$ $$$ ( 2 2 ) $$$ : $$$ ( 1 1 ) $$$ $$$ \rightarrow $$$ $$$ ( 1 2 ) $$$ $$$ \rightarrow $$$ $$$ ( 2 2 ) $$$ $$$ ( 1 1 ) $$$ $$$ \rightarrow $$$ $$$ ( 2 1 ) $$$ $$$ \rightarrow $$$ $$$ ( 2 2 ) $$$ cost $$$ 1 + 2 = 3 $$$ burl 's amount money spend fifth test case way $$$ ( 1 1 ) $$$ $$$ ( 1 4 ) $$$ cost $$$ 1 + 1 + 1 = 3 $$$ burl,"['dp', 'math']",800.0
1520/D,give array $$$ a $$$ $$$ n $$$ integers count number pair indices $$$ ( i j ) $$$ $$$ i < j $$$ $$$ a_j - a_i = j - i $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output number pair indices $$$ ( i j ) $$$ $$$ i < j $$$ $$$ a_j - a_i = j - i $$$,"['data structures', 'math']",1200.0
1521/D,"nastia unweighted tree $$$ n $$$ vertices want play ! girl perform follow operation tree long need : minimum number operations nastia need get a bamboo a tree ? a bamboo a tree node a degree greater $$$ 2 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10\,000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — number vertices tree next $$$ n - 1 $$$ line test case describe edge tree form $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ $$$ a_i \neq b_i $$$ ) 's guarantee give graph a tree sum $$$ n $$$ one test n't exceed $$$ 200000 $$$ test case first line print a single integer $$$ k $$$ — minimum number operations require obtain a bamboo initial tree next $$$ k $$$ line print $$$ 4 $$$ integers $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \le x_1 y_1 x_2 y _ { 2 } \le n $$$ $$$ x_1 \neq y_1 $$$ $$$ x_2 \neq y_2 $$$ ) — way remove edge $$$ ( x_1 y_1 ) $$$ add undirected edge $$$ ( x_2 y_2 ) $$$ note edge $$$ ( x_1 y_1 ) $$$ must present graph moment remove note graph <unknown> a certain operation consider first test case example :","['data structures', 'dfs and similar', 'dp', 'dsu', 'greedy', 'implementation', 'trees']",2500.0
1523/D,william host a party $$$ n $$$ trader friends start a discussion various currencies trade 's issue : trader friends like every currency like currencies others william 's friend $$$ i $$$ know whether like currency $$$ j $$$ $$$ m $$$ currencies total also know a trader may like $$$ p $$$ currencies friends need common topic discussions need find largest cardinality ( possibly empty ) subset currencies least $$$ \lceil \frac { n } { 2 } \rceil $$$ friends ( round ) like currency subset first line contain three integers $$$ n m $$$ $$$ p $$$ $$$ ( 1 \le n \le 2 \cdot 100000 1 \le p \le m \le 60 1 \le p \le 15 ) $$$ number trader friends number currencies maximum number currencies friend like next $$$ n $$$ line contain $$$ m $$$ character $$$ j $$$ -th character $$$ i $$$ -th line $$$ 1 $$$ friend $$$ i $$$ like currency $$$ j $$$ $$$ 0 $$$ otherwise guarantee number ones line exceed $$$ p $$$ print a string length $$$ m $$$ define subset currencies maximum size like least half friends currencies belong subset must signify character $$$ 1 $$$ multiple answer print first sample test case first currency like least $$$ \lceil \frac { 3 } { 2 } \rceil = 2 $$$ friends therefore 's easy demonstrate a better answer find second sample test case answer include $$$ 2 $$$ currencies like friends $$$ 1 $$$ $$$ 2 $$$ $$$ 5 $$$ test case currencies like least half friends use achieve a larger subset size,"['bitmasks', 'brute force', 'dp']",2400.0
1527/D,give a tree $$$ n $$$ nod numerate $$$ 0 $$$ $$$ n-1 $$$ $$$ k $$$ $$$ 0 $$$ $$$ n $$$ inclusive count number unordered pair $$$ ( u v ) $$$ $$$ u \neq v $$$ mex node label shortest path $$$ u $$$ $$$ v $$$ ( include end point ) $$$ k $$$ mex a sequence integers smallest non - negative integer belong sequence first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 2 \cdot 10^ { 5 } $$$ ) next $$$ n-1 $$$ line test case describe tree construct line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 0 \le u v \le n-1 $$$ ) denote edge $$$ u $$$ $$$ v $$$ ( $$$ u \neq v $$$ ) guarantee give edge form a tree also guarantee sum $$$ n $$$ test case exceed $$$ 2 \cdot 10^ { 5 } $$$ test case print $$$ n+1 $$$ integers : number paths tree mex node label path $$$ k $$$ $$$ k $$$ $$$ 0 $$$ $$$ n $$$,"['combinatorics', 'dfs and similar', 'implementation', 'math', 'trees']",2400.0
1529/A,eshag array $$$ a $$$ consist $$$ n $$$ integers eshag perform follow operation number time : choose subsequence $$$ a $$$ delete every element strictly larger $$$ avg $$$ $$$ avg $$$ average number choose subsequence example $$$ a = [ 1 4 3 2 4 ] $$$ eshag apply operation subsequence contain $$$ a_1 $$$ $$$ a_2 $$$ $$$ a_4 $$$ $$$ a_5 $$$ delete $$$ 4 $$$ elements larger $$$ \frac { <unknown> } { 4 } = \frac { 11 } { 4 } $$$ operation array $$$ a $$$ become $$$ a = [ 1 3 2 ] $$$ task find maximum number elements eshag delete array $$$ a $$$ apply operation describe number ( maybe zero ) time a sequence $$$ b $$$ a subsequence array $$$ c $$$ $$$ b $$$ obtain $$$ c $$$ deletion several ( possibly zero ) elements first line contain integer $$$ t $$$ $$$ ( 1\le t\le 100 ) $$$ — number test case description test case follow first line test case contain integer $$$ n $$$ $$$ ( 1\le n\le 100 ) $$$ — length array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 1\le a_i \le 100 ) $$$ — elements array $$$ a $$$ test case print a single integer — maximum number elements eshag delete array $$$ a $$$ consider first test case initially $$$ a = [ 1 1 1 2 2 3 ] $$$ first operation eshag choose subsequence contain $$$ a_1 $$$ $$$ a_5 $$$ $$$ a_6 $$$ average equal $$$ \frac { a_1 + a_5 + a_6 } { 3 } = \frac { 6 } { 3 } = 2 $$$ $$$ a_6 $$$ delete $$$ a = [ 1 1 1 2 2 ] $$$ second operation eshag choose subsequence contain whole array $$$ a $$$ average elements equal $$$ \frac { 7 } { 5 } $$$ $$$ a_4 $$$ $$$ a_5 $$$ delete $$$ a = [ 1 1 1 ] $$$ second test case eshag ca n't delete element,"['greedy', 'math']",800.0
1529/B,a sequence $$$ ( b_1 b_2 \ldots b_k ) $$$ call strange absolute difference pair elements greater equal maximum element sequence formally speak 's strange every pair $$$ ( i j ) $$$ $$$ 1 \le i < j \le k $$$ $$$ |a_i - <unknown> max $$$ $$$ max $$$ largest element sequence particular sequence length $$$ 1 $$$ strange example sequence $$$ ( <unknown> -1 -1 -1 ) $$$ $$$ ( -1 0 1 ) $$$ strange $$$ ( 3 0 1 ) $$$ $$$ |0 - 1| < 3 $$$ sifid array $$$ a $$$ $$$ n $$$ integers sifid like everything big among strange subsequences $$$ a $$$ want find length longest one help ? a sequence $$$ c $$$ a subsequence array $$$ d $$$ $$$ c $$$ obtain $$$ d $$$ deletion several ( possibly zero ) elements first line contain integer $$$ t $$$ $$$ ( 1\le t\le 10000 ) $$$ — number test case description test case follow first line test case contain integer $$$ n $$$ $$$ ( 1\le n\le 100000 ) $$$ — length array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( -1000000000\le a_i \le 1000000000 ) $$$ — elements array $$$ a $$$ guarantee sum $$$ n $$$ test case n't exceed $$$ 100000 $$$ test case output a single integer — length longest strange subsequence $$$ a $$$ first test case one longest strange subsequences $$$ ( a_1 a_2 a_3 a_4 ) $$$ second test case one longest strange subsequences $$$ ( a_1 a_3 a_4 a_5 a_7 ) $$$ third test case one longest strange subsequences $$$ ( a_1 a_3 a_4 a_5 ) $$$ fourth test case one longest strange subsequences $$$ ( a_2 ) $$$ fifth test case one longest strange subsequences $$$ ( a_1 a_2 a_4 ) $$$,"['greedy', 'math', 'sortings']",1100.0
1530/F,"get ready vk fest 2021 prepare a table $$$ n $$$ row $$$ n $$$ columns fill cell table event relate festival could either happen : example whether win a prize festival whether rain forecast algorithms use vk already estimate probability event happen event row $$$ i $$$ column $$$ j $$$ happen probability $$$ a _ { i j } \cdot 10^ { -4 } $$$ events mutually independent let 's call table win exist a line $$$ n $$$ events happen line could horizontal line ( cells $$$ ( i 1 ) ( i 2 ) \ldots ( i n ) $$$ $$$ i $$$ ) vertical line ( cells $$$ ( 1 j ) ( 2 j ) \ldots ( n j ) $$$ $$$ j $$$ ) main diagonal ( cells $$$ ( 1 1 ) ( 2 2 ) \ldots ( n n ) $$$ ) <unknown> ( cells $$$ ( 1 n ) ( 2 n - 1 ) \ldots ( n 1 ) $$$ ) find probability table win output modulo $$$ 31\,607 $$$ ( see output section ) first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 21 $$$ ) — dimension table $$$ i $$$ -th next $$$ n $$$ line contain $$$ n $$$ integers $$$ a _ { i 1 } a _ { i 2 } \ldots a _ { i n } $$$ ( $$$ 0 < a _ { i j } < 10000 $$$ ) probability event cell $$$ ( i j ) $$$ happen $$$ a _ { i j } \cdot 10^ { -4 } $$$ print probability table win modulo $$$ 31\,607 $$$ formally let $$$ m = 31\,607 $$$ show answer express irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \not \equiv 0 \pmod { m } $$$ output integer equal $$$ p \cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \le x < m $$$ $$$ x \cdot q \equiv p \pmod { m } $$$ first example two events form a line table win two events happen probability $$$ \frac { 11 } { 16 } $$$ $$$ <unknown> \equiv 11 \pmod { 31\,607 } $$$","['bitmasks', 'combinatorics', 'dp', 'math']",2600.0
1537/B,"riley a bad boy time a yo - yo master , decide use yo - yo skills annoy friend anton anton 's room represent a grid $$$ n $$$ row $$$ m $$$ columns let $$$ ( i j ) $$$ denote cell row $$$ i $$$ column $$$ j $$$ anton currently stand position $$$ ( i j ) $$$ room annoy anton riley decide throw exactly two yo - yos cells room ( cell ) anton n't like yo - yos throw floor pick return back initial position distance travel anton shortest path go position yo - yos return back $$$ ( i j ) $$$ travel adjacent side cells , cell $$$ ( x y ) $$$ travel cells $$$ ( x + 1 y ) $$$ $$$ ( x - 1 y ) $$$ $$$ ( x y + 1 ) $$$ $$$ ( x y - 1 ) $$$ one step ( a cell coordinate exist ) riley wonder throw two yo - yos distance travel anton maximize busy ask tell first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case $$$ t $$$ test case follow line test case contain four integers $$$ n $$$ $$$ m $$$ $$$ i $$$ $$$ j $$$ ( $$$ 1 \leq n m \leq 1000000000 $$$ $$$ 1\le i\le n $$$ $$$ 1\le j\le m $$$ ) — dimension room cell anton currently stand test case print four integers $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \leq x_1 x_2 \leq n $$$ $$$ 1\le y_1 y_2\le m $$$ ) — coordinate two yo - yos throw throw coordinate $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ multiple answer may print a visualization first test case","['greedy', 'math']",900.0
1537/E2,hard version problem difference constraints $$$ n $$$ $$$ k $$$ make hack versions problem solve a string $$$ s $$$ two type operations : use operation number time ( possibly none ) task find lexicographically smallest string length exactly $$$ k $$$ obtain operations string $$$ s $$$ a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ one follow hold : first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n k \leq 5\cdot 100000 $$$ ) — length original string $$$ s $$$ length desire string second line contain string $$$ s $$$ consist $$$ n $$$ lowercase english letter print lexicographically smallest string length $$$ k $$$ obtain operations string $$$ s $$$ first test optimal make one duplication : ` ` dbcadabc '' $$$ \to $$$ ` ` dbcadabcdbcadabc '' second test optimal delete last $$$ 3 $$$ character duplicate string $$$ 3 $$$ time delete last $$$ 3 $$$ character make string length $$$ k $$$ ` ` abcd '' $$$ \to $$$ ` ` abc '' $$$ \to $$$ ` ` ab '' $$$ \to $$$ ` ` a '' $$$ \to $$$ ` ` aa '' $$$ \to $$$ ` ` aaaa '' $$$ \to $$$ ` ` aaaaaaaa '' $$$ \to $$$ ` ` aaaaaaa '' $$$ \to $$$ ` ` aaaaaa '' $$$ \to $$$ ` ` aaaaa '',"['binary search', 'data structures', 'greedy', 'strings', 'two pointers']",2200.0
1538/E,polycarp come a new program language two type statements : variable name string consist lowercase letter english alphabet exceed $$$ 5 $$$ character result program number occurrences string haha string write variable last statement polycarp tire invent language ask implement task — give program statements calculate number occurrences string haha last assign variable first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — number statements program variable name string guarantee consist lowercase letter english alphabet exceed $$$ 5 $$$ character follow $$$ n $$$ line describe statements format describe guarantee program correct set input data output number occurrences haha substring string write variable last statement first test case result value d <unknown>,"['data structures', 'implementation', 'strings']",2100.0
1539/B,"petya write a sad love song share vasya song a string consist lowercase english letter vasya make $$$ q $$$ question song question a subsegment song start $$$ l $$$ -th letter $$$ r $$$ -th letter vasya consider a substring make character segment repeat letter subsegment $$$ k $$$ time $$$ k $$$ index correspond letter alphabet example question substring ` ` <unknown> '' vasya repeat letter ' a ' letter ' b ' twice letter ' c '' three time result string ` ` <unknown> '' length $$$ 10 $$$ vasya interest length result string help petya find length string obtain vasya first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1\leq n\leq 100\,000 $$$ $$$ 1\leq q \leq 100\,000 $$$ ) — length song number question second line contain one string $$$ s $$$ — song consist $$$ n $$$ lowercase letter english letter vasya 's question contain next $$$ q $$$ line line contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l \leq r \leq n $$$ ) — bound question print $$$ q $$$ line : question print length string obtain vasya first example vasya interest three question first question vasya consider substring ` ` aba '' transform ` ` abba '' answer equal $$$ 4 $$$ second question vasya consider ` ` baca '' transform ` ` <unknown> '' answer $$$ 7 $$$ third question vasya consider string ` ` abacaba '' transform ` ` <unknown> '' length $$$ 11 $$$","['dp', 'implementation', 'strings']",800.0
1539/F,"vasya array $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ vasya think number array strange reason calculate strange $$$ i $$$ -th number vasya create follow algorithm choose a subsegment $$$ a_l a _ { l+1 } \ldots a_r $$$ $$$ 1 \le l \le i \le r \le n $$$ sort elements increase order head ( arrange equal elements arbitrary ) find center segment center a segment element position $$$ ( l + r ) / 2 $$$ length segment odd position $$$ ( l + r + 1 ) / 2 $$$ otherwise vasya find element position $$$ i $$$ sort calculate distance current position center subsegment ( distance elements indices $$$ j $$$ $$$ k $$$ $$$ |j - k| $$$ ) strangeness number position $$$ i $$$ maximum distance among suitable choices $$$ l $$$ $$$ r $$$ vasya want calculate strangeness number array help first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200\,000 $$$ ) — size array second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — vasya 's array print a single line $$$ n $$$ number $$$ i $$$ -th must equal strangeness $$$ i $$$ -th element array first example :","['data structures', 'greedy', 'sortings']",2600.0
154/D,"king flatland organize a knight ' tournament ! winner get half kingdom favor princess legendary beauty wisdom final test applicants ' courage strength a fence tournament tournament hold follow rule : participants fight one one winner ( rather survivor ) transfer next round battle participants stand specify point ox axis integer coordinate make move turn first participant move first naturally a move first participant transfer point x integer point interval [ x + a ; x + b ] second participant transfer a move integer point interval [ x - b ; x - a ] , options players ' move symmetric ( note number a b require positive a ≤ 0 ≤ b stay one place a correct move ) time participants locate arbitrarily relative , allow ` ` jump '' enemy direction a participant win use move transfer point opponent course princess already choose a husband want make sweetheart win tournament already reach tournament finals face last battle princess ask tournament manager arrange tournament finalists a way sweetheart win tournament consider players play optimally however initial location participants already announce pull string determine participant first one second know participant secure victory ? alas princess learn military affairs ... therefore ask determine battle end consider opponents play optimally also first player win task determine win move first line contain four space - separated integers — x1 x2 a b ( x1 ≠ x2 a ≤ b - 109 ≤ x1 x2 a b ≤ 109 ) — coordinate point first second participant start number determine players ' move correspondingly first line print outcome battle ` ` first '' ( without quote ) players play optimally first player win print ` ` second '' ( without quote ) second player win print ` ` draw '' ( without quote ) nobody able secure victory first player win print next line single integer x — coordinate point first player transfer win indicate move valid , meet follow condition : x1 + a ≤ x ≤ x1 + b. several win move print first participant ca n't secure victory print anything first sample first player win one move second sample first participant must go point 1 second participant immediately go win third sample change position n't profitable either participant nobody win",['math'],2400.0
1540/E,note memory limit unusual $$$ n $$$ chefs number $$$ 1 2 \ldots n $$$ must prepare dish a king chef $$$ i $$$ skill $$$ i $$$ initially a dish tastiness $$$ a_i $$$ $$$ |a_i| \leq i $$$ chef a list chefs allow copy stop chefs learn bad habit king make sure chef $$$ i $$$ copy chefs larger skill a sequence days pass chefs work dish day two stag a chef change tastiness dish chefs work maximize tastiness dish order please king finally give $$$ q $$$ query query one two type note query type $$$ 1 $$$ independent query specifically query type $$$ 1 $$$ a scenario change initial tastiness $$$ a_i $$$ dish future query note query type $$$ 2 $$$ cumulative change initial tastiness $$$ a_i $$$ a dish see note example query first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 300 $$$ ) — number chefs second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -i \le a_i \le i $$$ ) next $$$ n $$$ line begin a integer $$$ c_i $$$ ( $$$ 0 \le c_i < n $$$ ) denote number chefs $$$ i $$$ -th chef copy number follow $$$ c_i $$$ distinct integers $$$ d $$$ ( $$$ i < d \le n $$$ ) signify chef $$$ i $$$ allow copy chef $$$ d $$$ stage $$$ 2 $$$ day next line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query next $$$ q $$$ line contain a query one two type : guarantee least one query first type query first type print a single integer — answer query set chefs chef allow copy : follow a description sample first query type $$$ 1 $$$ initial tastiness value $$$ [ 1 0 -2 -2 4 ] $$$ final result first day show : answer $$$ 1 $$$ -st query $$$ 21 + 0 - 2 + 18 + 20 = 57 $$$ $$$ 5 $$$ -th query ( $$$ 3 $$$ -rd type $$$ 1 $$$ ) initial tastiness value $$$ [ 1 0 0 1 4 ] $$$ day 1 day 2 answer $$$ 5 $$$ -th query $$$ 12 + 108 + <unknown> $$$ show step describe chefs move optimally,['math'],3500.0
1542/E1,"easy version problem difference easy version hard version constraints $$$ n $$$ make hack versions solve a permutation $$$ 1 2 \ldots n $$$ a sequence $$$ n $$$ integers integer $$$ 1 $$$ $$$ n $$$ appear exactly example $$$ [ 2,3,1,4 ] $$$ a permutation $$$ 1 2 3 4 $$$ $$$ [ 1,4,2,2 ] $$$ n't $$$ 2 $$$ appear twice recall number inversions a permutation $$$ a_1 a_2 \ldots a_n $$$ number pair indices $$$ ( i j ) $$$ $$$ i < j $$$ $$$ a_i > a_j $$$ let $$$ p $$$ $$$ q $$$ two permutations $$$ 1 2 \ldots n $$$ find number permutation pair $$$ ( p q ) $$$ satisfy follow condition : print number pair modulo $$$ mod $$$ note $$$ mod $$$ may a prime line contain two integers $$$ n $$$ $$$ mod $$$ ( $$$ 1\le n\le 50 $$$ $$$ 1\le mod\le 1000000000 $$$ ) print one integer answer modulo $$$ mod $$$ follow valid pair $$$ ( p q ) $$$ $$$ n=4 $$$","['combinatorics', 'dp', 'math']",2400.0
1543/B,"highway 201 busy street rockport traffic cars cause a lot <unknown> race especially a lot track pass highway divide $$$ n $$$ sub - <unknown> give array $$$ a $$$ $$$ a_i $$$ represent number traffic cars $$$ i $$$ -th sub - track define inconvenience track $$$ \sum\limits _ { i=1 } ^ { n } \sum\limits _ { j = i+1 } ^ { n } \lvert a_i - <unknown> $$$ $$$ |x| $$$ absolute value $$$ x $$$ perform follow operation ( possibly zero ) number time : choose a traffic car move current sub - track sub - track find minimum inconvenience achieve first line input contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 10\,000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1\leq n\leq 2\cdot 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0\leq a_i\leq 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case print a single line contain a single integer : minimum inconvenience achieve apply give operation ( possibly zero ) number time first test case move a car $$$ 3 $$$ -rd sub - track $$$ 1 $$$ -st sub - track obtain $$$ 0 $$$ inconvenience second test case move car wo n't decrease inconvenience track","['combinatorics', 'greedy', 'math']",900.0
1543/C,"defeat a blacklist rival get a chance draw $$$ 1 $$$ reward slip $$$ x $$$ hide valid slip initially $$$ x=3 $$$ hide valid slip cash slip <unknown> strike release marker pink slip rival 's car initially probability draw a random guess $$$ c $$$ $$$ m $$$ $$$ p $$$ respectively also a <unknown> factor $$$ v $$$ play number rival race long n't draw a pink slip assume win race get a chance draw a reward slip draw draw one $$$ x $$$ valid items respective probabilities suppose draw a particular item probability draw draw $$$ a $$$ , example need cars rival , need find expect number race must play order draw a pink slip first line input contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 10 $$$ ) — number test case first line test case contain four real number $$$ c $$$ $$$ m $$$ $$$ p $$$ $$$ v $$$ ( $$$ 0 < c m p < 1 $$$ $$$ <unknown> $$$ $$$ <unknown> v\leq <unknown> $$$ ) additionally guarantee $$$ c $$$ $$$ m $$$ $$$ p $$$ $$$ v $$$ $$$ 4 $$$ decimal place test case output a single line contain a single real number — expect number race must play order draw a pink slip answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -6 } $$$ first test case possible draw sequence : second test case possible draw sequence : expect number race equal $$$ 1\cdot 0.4 + 2\cdot <unknown> + 3\cdot <unknown> + 2\cdot 0.1 + 3\cdot 0.1 = <unknown> $$$","['bitmasks', 'brute force', 'dfs and similar', 'implementation', 'math']",1900.0
1543/D1,"easy version problem difference $$$ k=2 $$$ make hack versions problem solve interactive problem every decimal number a base $$$ k $$$ equivalent individual digits a base $$$ k $$$ number call $$$ k $$$ -its let 's define $$$ k $$$ -itwise xor two $$$ k $$$ -its $$$ a $$$ $$$ b $$$ $$$ ( a + b ) \bmod k $$$ $$$ k $$$ -itwise xor two base $$$ k $$$ number equal new number form take $$$ k $$$ -itwise xor correspond $$$ k $$$ -its $$$ k $$$ -itwise xor two decimal number $$$ a $$$ $$$ b $$$ denote $$$ a\oplus _ { k } b $$$ equal decimal representation $$$ k $$$ -itwise xor base $$$ k $$$ representations $$$ a $$$ $$$ b $$$ number use statement decimal unless specify $$$ k = 2 $$$ ( always true version ) $$$ k $$$ -itwise xor bitwise xor hack criminal database rockport police department ( rpd ) also know rap sheet order access require a password n't know quite sure lie $$$ 0 $$$ $$$ n-1 $$$ inclusive , decide guess luckily try $$$ n $$$ time without block system system adaptive time make incorrect guess change password specifically password guess $$$ x $$$ guess a different number $$$ y $$$ system change password a number $$$ z $$$ $$$ x\oplus _ { k } z = y $$$ guess password break system first line input contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 10\,000 $$$ ) denote number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ ( $$$ 1\leq n\leq 2\cdot 100000 $$$ ) $$$ k $$$ ( $$$ k=2 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case first read two integers $$$ n $$$ $$$ k $$$ may ask $$$ n $$$ query query print a single integer $$$ y $$$ ( $$$ 0\leq y\leq 2\cdot 10000000 $$$ ) let current password $$$ x $$$ , read integer $$$ r $$$ $$$ x = y $$$ read $$$ r=1 $$$ test case solve must continue solve remain test case else read $$$ r=0 $$$ moment password change a number $$$ z $$$ $$$ x\oplus _ { k } z = y $$$ print a query forget output end line flush output otherwise get idleness limit exceed verdict , use : ask invalid query exceed $$$ n $$$ query read $$$ r=-1 $$$ receive wrong answer verdict make sure exit immediately avoid unexpected verdicts note interactor adaptive , original password fix begin may depend query guarantee moment least one initial password answer query consistent hack : use hack use follow format test : first line contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 10\,000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ ( $$$ 1\leq n\leq 2\cdot 100000 $$$ ) $$$ k $$$ ( $$$ k=2 $$$ ) denote number query base respectively optimal original password automatically decide adaptive interactor must ensure sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ example test case hide password $$$ 2 $$$ first query $$$ 3 $$$ equal current password , $$$ 0 $$$ return password change $$$ 1 $$$ since $$$ 2\oplus_2 1=3 $$$ second query $$$ 4 $$$ equal current password , $$$ 0 $$$ return password change $$$ 5 $$$ since $$$ 1\oplus_2 5=4 $$$ third query $$$ 5 $$$ equal current password , $$$ 1 $$$ return job do note initial password take sake explanation submit interactor might behave differently adaptive","['bitmasks', 'math']",1700.0
1543/E,finally defeat razor want street racer sergeant cross send full police force a deadly <unknown> fortunately find a hide spot fear cross force eventually find increase chance survival want tune repaint <unknown> m3 <unknown> car imagine a permute $$$ n $$$ -dimensional hypercube a simple $$$ n $$$ -dimensional hypercube undirected unweighted graph build recursively follow : a permute $$$ n $$$ -dimensional hypercube form permute vertex number a simple $$$ n $$$ -dimensional hypercube arbitrary manner examples a simple permute $$$ 3 $$$ -dimensional hypercubes give : note a permute $$$ n $$$ -dimensional hypercube follow properties : let 's denote permutation use generate permute $$$ n $$$ -dimensional hypercube represent car a simple $$$ n $$$ -dimensional hypercube $$$ p $$$ mess <unknown> car want find permutation restore car anything go wrong job n't do yet $$$ n $$$ different colour number $$$ 0 $$$ $$$ n-1 $$$ want colour vertices permute $$$ n $$$ -dimensional hypercube a way every vertex $$$ u $$$ satisfy $$$ 0\leq u < 2^n $$$ every colour $$$ c $$$ satisfy $$$ 0\leq c < n $$$ least one vertex $$$ v $$$ adjacent $$$ u $$$ a colour $$$ c $$$ word every vertex must possible reach a vertex colour move adjacent vertex give permute $$$ n $$$ -dimensional hypercube find valid permutation $$$ p $$$ colour first line input contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq <unknown> $$$ ) — number test case test case first line contain a single integer $$$ n $$$ ( $$$ 1\leq n\leq 16 $$$ ) next $$$ n\cdot 2^ { n-1 } $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 0\leq u v < 2^n $$$ ) denote edge vertices number $$$ u $$$ $$$ v $$$ guarantee graph describe input a permute $$$ n $$$ -dimensional hypercube additionally guarantee sum $$$ 2^n $$$ test case exceed $$$ 2^ { 16 } = <unknown> $$$ test case print two line first line output permutation $$$ p $$$ length $$$ 2^n $$$ use transform a simple $$$ n $$$ -dimensional hypercube permute $$$ n $$$ -dimensional hypercube give input two permute hypercubes consider set edge multiple answer output second line print colour way colour vertices satisfy condition output $$$ -1 $$$ otherwise output a single line contain $$$ 2^n $$$ space separate integers $$$ i $$$ -th integer must colour vertex number $$$ ( i-1 ) $$$ permute $$$ n $$$ -dimensional hypercube multiple answer output colour permute hypercube first test case show : colour permute hypercube second test case show : permute hypercube third test case give problem statement however show exist way colour cube <unknown> condition note permutations like $$$ [ 0 5 7 3 1 2 4 6 ] $$$ $$$ [ 0 1 5 2 7 4 3 6 ] $$$ also give permute hypercube,"['bitmasks', 'divide and conquer', 'graphs', 'greedy', 'math']",2700.0
1545/C,"cirno prepare $$$ n $$$ array length $$$ n $$$ array a permutation $$$ n $$$ integers $$$ 1 $$$ $$$ n $$$ array special : $$$ 1 \leq i \leq n $$$ take $$$ i $$$ -th element array form another array length $$$ n $$$ elements resultant array also a permutation $$$ n $$$ integers $$$ 1 $$$ $$$ n $$$ word put $$$ n $$$ array form a matrix $$$ n $$$ row $$$ n $$$ columns matrix a latin square afterwards cirno add additional $$$ n $$$ array array a permutation $$$ n $$$ integers $$$ 1 $$$ $$$ n $$$ $$$ 1 \leq i \leq n $$$ exist least one position $$$ 1 \leq k \leq n $$$ $$$ i $$$ -th array $$$ ( n + i ) $$$ -th array $$$ k $$$ -th element array notice array index $$$ n + 1 $$$ $$$ 2n $$$ n't form a latin square also cirno make sure $$$ 2n $$$ array two array completely equal i. e. pair indices $$$ 1 \leq i < j \leq 2n $$$ exist least one position $$$ 1 \leq k \leq n $$$ $$$ k $$$ -th elements $$$ i $$$ -th $$$ j $$$ -th array different finally cirno arbitrarily change order $$$ 2n $$$ array aquamoon call a subset $$$ 2n $$$ array size $$$ n $$$ good array a latin square aquamoon want know many good subsets exist number may particularly large find modulo $$$ 998\,244\,353 $$$ also want find good subset help ? input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 5 \leq n \leq 500 $$$ ) $$$ 2n $$$ line follow $$$ i $$$ -th line contain $$$ n $$$ integers represent $$$ i $$$ -th array guarantee sum $$$ n $$$ test case exceed $$$ 500 $$$ test case print two line first line print number good subsets modulo $$$ 998\,244\,353 $$$ second line print $$$ n $$$ indices $$$ 1 $$$ $$$ 2n $$$ — indices $$$ n $$$ array form a good subset ( print order ) several possible answer — print first test case number good subsets $$$ 1 $$$ subset set array indices $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ $$$ 6 $$$ $$$ 7 $$$ second test case number good subsets $$$ 2 $$$ $$$ 1 $$$ $$$ 3 $$$ $$$ 5 $$$ $$$ 6 $$$ $$$ 10 $$$ $$$ 2 $$$ $$$ 4 $$$ $$$ 7 $$$ $$$ 8 $$$ $$$ 9 $$$","['brute force', 'combinatorics', 'graphs']",2800.0
1545/E2,note differences easy hard versions constraints $$$ n $$$ time limit make hack versions solve aquamoon know foresight ghost want curse tourists a pedestrian street unfortunately time ghost hide a barrier could n't enter barrier a short time destroy therefore do save unfortunate person street ghost pedestrian street represent a one - dimensional coordinate system one person hang pedestrian street time $$$ 0 $$$ coordinate $$$ x $$$ move a speed $$$ 1 $$$ unit per second particular time $$$ i $$$ person coordinate $$$ x+i $$$ ghost go cast $$$ n $$$ curse street $$$ i $$$ -th curse last time $$$ tl_i-1 + 10^ { -18 } $$$ time $$$ tr_i+1 - 10^ { -18 } $$$ ( exclusively ) kill people coordinate $$$ l_i-1 + 10^ { -18 } $$$ $$$ r_i+1 - 10^ { -18 } $$$ ( exclusively ) formally mean person whose coordinate $$$ ( l_i-1 + 10^ { -18 } r_i+1 - 10^ { -18 } ) $$$ time range $$$ ( tl_i-1 + 10^ { -18 } tr_i+1 - 10^ { -18 } ) $$$ die save person street aquamoon stop time moment $$$ t $$$ move person current coordinate $$$ x $$$ coordinate $$$ y $$$ ( $$$ t $$$ $$$ x $$$ $$$ y $$$ necessarily integers ) movement cost aquamoon $$$ |x - y| $$$ energy movement continuous exist curse area point $$$ x $$$ $$$ y $$$ time $$$ t $$$ person die aquamoon want know minimum amount energy need spend order save person street $$$ n $$$ curse good program friend help ? first line contain a single integer $$$ n $$$ ( $$$ 1\le n\le 200000 $$$ ) — number curse next line contain a single integer $$$ x $$$ ( $$$ 1\le x\le 1000000 $$$ ) — initial coordinate person follow $$$ n $$$ line contain four integers $$$ tl_i $$$ $$$ tr_i $$$ $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1\le tl_i\le tr_i\le 1000000 $$$ $$$ 1\le l_i\le r_i\le 1000000 $$$ ) print a single integer — minimum energy aquamoon need spend round nearest integer ( case two nearest integers round answer highest ),"['data structures', 'dp']",3500.0
1546/B,aquamoon $$$ n $$$ string length $$$ m $$$ $$$ n $$$ odd number aquamoon go cirno try pair $$$ n $$$ string together make $$$ \frac { n-1 } { 2 } $$$ pair find exactly one string without pair ! rage disrupt pair string pair select position ( least $$$ 1 $$$ $$$ m $$$ ) swap letter two string pair select position example $$$ m = 6 $$$ two string ` ` abcdef '' ` ` <unknown> '' one pair cirno select position $$$ 2 $$$ $$$ 3 $$$ $$$ 6 $$$ swap ' b ' ' y ' ' c ' ' z ' ' f ' ' m ' result string ` ` <unknown> '' ` ` <unknown> '' cirno steal away string without pair shuffle remain string arbitrary order aquamoon find remain $$$ n-1 $$$ string complete <unknown> also remember initial $$$ n $$$ string want know string steal good program help ? problem make interactive mean solution read input give interactor interactor give full input begin print answer solve problem like solve usual non - interactive problem wo n't interaction process thing forget flush output buffer print answer otherwise get ` ` idleness limit exceed '' verdict refer interactive problems guide detail information flush output buffer input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ 1 \leq m \leq 100000 $$$ ) — number string length string respectively next $$$ n $$$ line contain a string length $$$ m $$$ describe original $$$ n $$$ string string consist lowercase latin letter next $$$ n-1 $$$ line contain a string length $$$ m $$$ describe string cirno exchange reorder guarantee $$$ n $$$ odd sum $$$ n \cdot m $$$ test case exceed $$$ 100000 $$$ hack format : first line contain a single integer $$$ t $$$ $$$ t $$$ test case follow follow format : first line contain two integers $$$ n $$$ $$$ m $$$ follow $$$ n $$$ line contain $$$ n $$$ string length $$$ m $$$ describe original string follow $$$ \frac { n-1 } { 2 } $$$ line describe pair contain follow order : index first string $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) index second string $$$ j $$$ ( $$$ 1 \leq j \leq n $$$ $$$ i \neq j $$$ ) number exchange position $$$ k $$$ ( $$$ 1 \leq k \leq m $$$ ) list $$$ k $$$ position exchange ( $$$ k $$$ distinct indices $$$ 1 $$$ $$$ m $$$ order ) final line contain a permutation integers $$$ 1 $$$ $$$ n $$$ describe way string reorder string place order indices place permutation steal string index ignore test case print a single line steal string first test case ` ` aaaaa '' ` ` bbbbb '' exchange position ` ` <unknown> '' steal string second test case ` ` aaaa '' ` ` bbbb '' exchange two first position ` ` cccc '' steal string first test hack format :,['math'],1200.0
1547/F,give array positive integers $$$ a = [ a_0 a_1 \dots a _ { n - 1 } ] $$$ ( $$$ n \ge 2 $$$ ) one step array $$$ a $$$ replace another array length $$$ n $$$ element greatest common divisor ( gcd ) two neighbor elements ( element right neighbor ; consider right neighbor $$$ ( n - 1 ) $$$ -th element $$$ 0 $$$ -th element ) formally speak a new array $$$ b = [ b_0 b_1 \dots b _ { n - 1 } ] $$$ build array $$$ a = [ a_0 a_1 \dots a _ { n - 1 } ] $$$ $$$ b_i $$$ $$$ = \gcd ( a_i a _ { ( i + 1 ) \mod n } ) $$$ $$$ \gcd ( x y ) $$$ greatest common divisor $$$ x $$$ $$$ y $$$ $$$ x \mod y $$$ remainder $$$ x $$$ divide $$$ y $$$ one step array $$$ b $$$ build array $$$ a $$$ replace $$$ b $$$ ( assignment $$$ a $$$ : = $$$ b $$$ take place ) example $$$ a = [ 16 24 10 5 ] $$$ $$$ b = [ \gcd ( 16 24 ) $$$ $$$ \gcd ( 24 10 ) $$$ $$$ \gcd ( 10 5 ) $$$ $$$ \gcd ( 5 16 ) ] $$$ $$$ = [ 8 2 5 1 ] $$$ thus one step array $$$ a = [ 16 24 10 5 ] $$$ equal $$$ [ 8 2 5 1 ] $$$ a give array $$$ a $$$ find minimum number step value $$$ a_i $$$ become equal ( $$$ a_0 = a_1 = \dots = a _ { n - 1 } $$$ ) original array $$$ a $$$ consist identical elements consider number step equal $$$ 0 $$$ first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) $$$ t $$$ test case follow test case contain two line first line contain integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — length sequence $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_0 a_1 \dots a _ { n - 1 } $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ print $$$ t $$$ number — answer test case,"['binary search', 'brute force', 'data structures', 'divide and conquer', 'number theory', 'two pointers']",1900.0
1548/D1,easy version problem difference hard version version coordinate even $$$ n $$$ fence - posts distinct coordinate a plane guarantee three fence post lie line infinite number cow plane one every point integer coordinate gregor a member illuminati want build a triangular fence connect $$$ 3 $$$ distinct exist fence post a cow strictly inside fence say enclose odd number enclose cow area fence integer fence say interest find number interest fence first line contain integer $$$ n $$$ ( $$$ 3 \le n \le 6000 $$$ ) number fence post gregor choose form vertices a fence next $$$ n $$$ line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 0 \le x y \le 10000000 $$$ $$$ x $$$ $$$ y $$$ even ) $$$ ( x y ) $$$ coordinate a fence post fence post lie distinct coordinate three fence post line print a single integer number interest fence two fence consider different construct a different set three fence post first example $$$ 1 $$$ fence fence interest since area $$$ 4 $$$ $$$ 1 $$$ enclose cow mark red second example $$$ 3 $$$ interest fence,"['bitmasks', 'geometry', 'math', 'number theory']",2300.0
1548/E,two painters amin benj repaint gregor 's live room ceiling ! ceiling model $$$ n \times m $$$ grid $$$ i $$$ $$$ 1 $$$ $$$ n $$$ inclusive painter amin apply $$$ a_i $$$ layer paint entire $$$ i $$$ -th row $$$ j $$$ $$$ 1 $$$ $$$ m $$$ inclusive painter benj apply $$$ b_j $$$ layer paint entire $$$ j $$$ -th column therefore cell $$$ ( i j ) $$$ end $$$ a_i+b_j $$$ layer paint gregor consider cell $$$ ( i j ) $$$ badly paint $$$ a_i+b_j \le x $$$ define a badly paint region a maximal connect component badly paint cells i. e. a connect component badly paint cells adjacent component cells badly paint two cells consider adjacent share a side gregor <unknown> state finish ceiling want know number badly paint regions first line contain three integers $$$ n $$$ $$$ m $$$ $$$ x $$$ ( $$$ 1 \le n m \le 2\cdot 100000 $$$ $$$ 1 \le x \le 2\cdot 100000 $$$ ) — dimension gregor 's ceiling maximum number paint layer a badly paint cell second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 2\cdot 100000 $$$ ) number paint layer amin apply row third line contain $$$ m $$$ integers $$$ b_1 b_2 \ldots b_m $$$ ( $$$ 1 \le b_j \le 2\cdot 100000 $$$ ) number paint layer benj apply column print a single integer number badly paint regions diagram represent first example number leave row represent list $$$ a $$$ number column represent list $$$ b $$$ number inside cell represent number paint layer cell color cells correspond badly paint cells red blue cells respectively form $$$ 2 $$$ badly paint regions,"['data structures', 'divide and conquer', 'graphs', 'greedy', 'math']",3400.0
155/A,vasya adore sport program ca n't write program love watch contest ' progress vasya even a favorite coder vasya pay special attention one day vasya decide collect result contest favorite coder participate track progress coolness contest coder participate write a single non - negative number — number point favorite coder earn contest vasya write point contest order contest run ( naturally two contest run simultaneously ) vasya consider a coder 's performance a contest amaze two situations : break either best worst performance record first amaze contest coder earn strictly point earn past contest second amaze contest coder earn strictly less point earn past contest a coder 's first contest n't consider amaze want count number amaze performances coder throughout whole history participate contest list earn point turn long vasya ca n't code ... 's ask help first line contain single integer n ( 1 ≤ n ≤ 1000 ) — number contest coder participate next line contain n space - separated non - negative integer number — point coder earn point give chronological order point exceed 10000 . print single number — number amaze performances coder whole history participate contest first sample performances number 2 3 amaze second sample performances number 2 4 9 10 amaze,['brute force'],800.0
1550/F,infinite pond represent a number line $$$ n $$$ rock pond number $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th rock locate integer coordinate $$$ a_i $$$ coordinate rock pairwise distinct rock number increase order coordinate $$$ a_1 < a_2 < \dots < a_n $$$ a robot frog sit rock number $$$ s $$$ frog <unknown> a base jump distance parameter $$$ d $$$ also a set jump distance range jump distance range set integer $$$ k $$$ frog jump rock rock a distance $$$ d - k $$$ $$$ d + k $$$ inclusive direction distance two rock absolute difference coordinate assign a task implement a feature frog give two integers $$$ i $$$ $$$ k $$$ determine frog reach a rock number $$$ i $$$ a rock number $$$ s $$$ perform a sequence jump jump distance range set $$$ k $$$ sequence arbitrarily long empty give $$$ q $$$ testcases feature $$$ j $$$ -th testcase consist two integers $$$ i $$$ $$$ k $$$ print ` ` yes '' $$$ i $$$ -th rock reachable ` ` '' otherwise output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ' yes '' ' recognize a positive answer ) first line contain four integers $$$ n $$$ $$$ q $$$ $$$ s $$$ $$$ d $$$ ( $$$ 1 \le n q \le 200000 $$$ ; $$$ 1 \le s \le n $$$ ; $$$ 1 \le d \le 1000000 $$$ ) — number rock number testcases start rock base jump distance parameter second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) — coordinate rock coordinate rock pairwise distinct rock number increase order distance land $$$ a_1 < a_2 < \dots < a_n $$$ next $$$ q $$$ line contain two integers $$$ i $$$ $$$ k $$$ ( $$$ 1 \le i \le n $$$ ; $$$ 1 \le k \le 1000000 $$$ ) — parameters testcase testcases print answer a sequence jump a rock number $$$ s $$$ a rock number $$$ i $$$ jump distance range set $$$ k $$$ print ` ` yes '' otherwise print ` ` '' explanation first example : first testcase destination rock start rock thus jump require reach second testcase frog jump distance range $$$ [ 5 - 2 ; 5 + 2 ] $$$ thus reach rock number $$$ 5 $$$ ( jump $$$ 7 $$$ right ) rock number $$$ 3 $$$ ( jump $$$ 3 $$$ leave ) rock number $$$ 3 $$$ reach rock number $$$ 2 $$$ ( jump $$$ 5 $$$ leave ) rock number $$$ 2 $$$ reach rock number $$$ 1 $$$ ( jump $$$ 4 $$$ leave ) however way reach rock number $$$ 7 $$$ third testcase frog jump distance range $$$ [ 5 - 3 ; 5 + 3 ] $$$ thus reach rock number $$$ 7 $$$ jump rock $$$ 5 $$$ first $$$ 7 $$$ afterwards fourth testcase show explanation second testcase,"['binary search', 'data structures', 'divide and conquer', 'dp', 'dsu', 'graphs', 'shortest paths']",2700.0
1551/F,a tree undirected connect graph without cycle give a tree $$$ n $$$ vertices find number ways choose exactly $$$ k $$$ vertices tree ( i. e. a $$$ k $$$ <unknown> subset vertices ) pairwise distance select vertices equal ( word exist integer $$$ c $$$ $$$ u v $$$ ( $$$ u \ne v $$$ $$$ u v $$$ select vertices ) $$$ d _ { u v } = c $$$ $$$ d _ { u v } $$$ distance $$$ u $$$ $$$ v $$$ ) since answer may large need output modulo $$$ 1000000000 + 7 $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) — number test case $$$ t $$$ test case follow test case precede empty line test case consist several line first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le k \le n \le 100 $$$ ) — number vertices tree number vertices select respectively $$$ n - 1 $$$ line follow contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ ) describe a pair vertices connect edge guarantee give graph a tree loop multiple edge test case output a separate line a single integer — number ways select exactly $$$ k $$$ vertices pair select vertices distance vertices pair equal modulo $$$ 1000000000 + 7 $$$ ( word print remainder divide $$$ 1000000007 $$$ ),"['brute force', 'combinatorics', 'dfs and similar', 'dp', 'trees']",2200.0
1552/C,a circle lie $$$ 2n $$$ distinct point follow property : however choose $$$ 3 $$$ chord connect $$$ 3 $$$ disjoint pair point point strictly inside circle belong $$$ 3 $$$ chord point number $$$ 1 \ 2 \ \dots \ 2n $$$ clockwise order initially $$$ k $$$ chord connect $$$ k $$$ pair point a way $$$ 2k $$$ endpoints chord distinct want draw $$$ n - k $$$ additional chord connect remain $$$ 2 ( n - k ) $$$ point ( point must endpoint exactly one chord ) end let $$$ x $$$ total number intersections among $$$ n $$$ chord compute maximum value $$$ x $$$ attain choose $$$ n - k $$$ chord optimally note exact position $$$ 2n $$$ point relevant long property state first paragraph hold first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100 $$$ $$$ 0 \le k \le n $$$ ) — half number point number chord initially draw $$$ k $$$ line follow $$$ i $$$ -th contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i \ y_i \le 2n $$$ $$$ x_i \ne y_i $$$ ) — endpoints $$$ i $$$ -th chord guarantee $$$ 2k $$$ number $$$ x_1 \ y_1 \ x_2 \ y_2 \ \dots \ x_k \ y_k $$$ distinct test case output maximum number intersections obtain draw $$$ n - k $$$ additional chord first test case three ways draw $$$ 2 $$$ additional chord show ( black chord ones initially draw red chord new ones ) : see third way give maximum number intersections namely $$$ 4 $$$ second test case chord draw course one chord present intersections third test case make one intersection draw chord $$$ 1 - 3 $$$ $$$ 2 - 4 $$$ show :,"['combinatorics', 'geometry', 'greedy', 'sortings']",1800.0
1552/I,"organizer famous ` ` <unknown> music festival '' $$$ n $$$ singers perform festival identify integers $$$ 1 $$$ $$$ 2 $$$ $$$ \dots $$$ $$$ n $$$ must choose order go perform stage $$$ m $$$ friends a set favourite singers precisely $$$ 1\le i\le m $$$ $$$ i $$$ -th friend like singers $$$ s _ { i,1 } \ s _ { i 2 } \ \dots \ s _ { i q_i } $$$ a friend happy singers like perform consecutively ( arbitrary order ) order singers valid make friends happy compute number valid order modulo $$$ 998\,244\,353 $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1\le n \ m\le 100 $$$ ) — number singers number friends correspondingly $$$ i $$$ -th next $$$ m $$$ line contain integer $$$ q_i $$$ ( $$$ 1\le q_i\le n $$$ ) — number favorite singers $$$ i $$$ -th friend – follow $$$ q_i $$$ integers $$$ s _ { i,1 } \ s _ { i 2 } \ \dots \ s _ { i q_i } $$$ ( $$$ 1\le s _ { i,1 } < s _ { i,2 } < \cdots < s _ { i q_i } \le n $$$ ) — index favorite singers print number valid order singers modulo $$$ 998\,244\,353 $$$ explanation first sample : $$$ 3 $$$ singers $$$ 1 $$$ friend friend like two singers $$$ 1 $$$ $$$ 3 $$$ thus $$$ 4 $$$ valid order : explanation second sample : $$$ 5 $$$ singers $$$ 5 $$$ friends one show order valid explanation third sample : $$$ 100 $$$ singers $$$ 1 $$$ friend friend like singer $$$ 50 $$$ hence $$$ 100 ! $$$ possible order valid explanation fourth sample : $$$ 5 $$$ singers $$$ 1 $$$ friend friend like singers hence $$$ 5 ! = 120 $$$ possible order valid","['dfs and similar', 'math']",3400.0
1554/D,give integer $$$ n $$$ find string $$$ s $$$ length $$$ n $$$ consist english lowercase letter non - empty substring $$$ s $$$ occur $$$ s $$$ odd number time multiple string output show string always exist give constraints a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) guarantee sum $$$ n $$$ test case n't exceed $$$ 300000 $$$ test case print a single line contain string $$$ s $$$ multiple string output show string always exist give constraints first test case substring ` ` abc '' occur exactly third test case substring ` ` <unknown> '' occur odd number time particular ` ` b '' occur $$$ 5 $$$ time ` ` a '' ` ` bb '' occur $$$ 3 $$$ time remain substrings occur exactly,"['greedy', 'strings']",1800.0
1555/A,pizzaforces petya 's favorite pizzeria pizzaforces make sell pizzas three size : small pizzas consist $$$ 6 $$$ slice medium ones consist $$$ 8 $$$ slice large pizzas consist $$$ 10 $$$ slice bake take $$$ 15 $$$ $$$ 20 $$$ $$$ 25 $$$ minutes respectively petya 's birthday today $$$ n $$$ friends come decide make order favorite pizzeria petya want order much pizza friends get least one slice pizza cook time order total bake time pizzas order task determine minimum number minutes need make pizzas contain least $$$ n $$$ slice total example : first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases testcase consist a single line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 10^ { 16 } $$$ ) — number petya 's friends testcase print one integer — minimum number minutes need bake pizzas contain least $$$ n $$$ slice total,"['brute force', 'math']",900.0
1556/C,william a favorite bracket sequence since favorite sequence quite big provide a sequence positive integers $$$ c_1 c_2 \dots c_n $$$ $$$ c_i $$$ number consecutive bracket ` ` ( ` ` $$$ i $$$ odd number number consecutive bracket ` ` ) '' $$$ i $$$ even number example a bracket sequence ` ` ( ( ( ) ) ( ) ) ) '' a correspond sequence number $$$ [ 3 2 1 3 ] $$$ need find total number continuous subsequences ( subsegments ) $$$ [ l r ] $$$ ( $$$ l \le r $$$ ) original bracket sequence regular bracket sequence a bracket sequence call regular possible obtain correct arithmetic expression insert character ` ` + '' ` ` 1 '' sequence example sequence ` ` ( ( ) ) ( ) '' ` ` ( ) '' ` ` ( ( ) ( ( ) ) ) '' regular ` ` ) ( ` ` ` ` ( ( ) '' ` ` ( ( ) ) ) ( ` ` first line contain a single integer $$$ n $$$ $$$ ( 1 \le n \le 1000 ) $$$ size compress sequence second line contain a sequence integers $$$ c_1 c_2 \dots c_n $$$ $$$ ( 1 \le c_i \le 1000000000 ) $$$ compress sequence output a single integer — total number subsegments original bracket sequence regular bracket sequence prove answer fit sign 64 - bit integer data type first example a sequence ( ( ( ( ) ( ( ) ) ) ( describe bracket sequence contain $$$ 5 $$$ subsegments form regular bracket sequence : second example a sequence ( ) ) ) ( ( ) ( ( ) ) ) ) describe third example a sequence ( ) ( ) ( ( ) ) describe,"['brute force', 'implementation']",1800.0
1557/A,"ezzat array $$$ n $$$ integers ( maybe negative ) want split two non - empty subsequences $$$ a $$$ $$$ b $$$ every element array belong exactly one subsequence value $$$ f ( a ) + f ( b ) $$$ maximum possible value $$$ f ( x ) $$$ average subsequence $$$ x $$$ a sequence $$$ x $$$ a subsequence a sequence $$$ y $$$ $$$ x $$$ obtain $$$ y $$$ deletion several ( possibly zero ) elements average a subsequence sum number subsequence divide size subsequence example average $$$ [ 1,5,6 ] $$$ $$$ ( 1 + 5 + 6 ) <unknown> = <unknown> = 4 $$$ $$$ f ( [ 1,5,6 ] ) = 4 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case consist two line first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 3\cdot100000 $$$ test case print a single value — maximum value ezzat achieve answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -6 } $$$ first test case array $$$ [ 3 1 2 ] $$$ possible ways split array : second test case array $$$ [ -7 -6 -6 ] $$$ possible ways split array :","['brute force', 'math', 'sortings']",800.0
1558/F,a permutation : array $$$ a = [ a_1 a_2 \ldots a_n ] $$$ distinct integers $$$ 1 $$$ $$$ n $$$ length permutation $$$ n $$$ odd consider follow algorithm sort permutation increase order a helper procedure algorithm $$$ f ( i ) $$$ take a single argument $$$ i $$$ ( $$$ 1 \le i \le n-1 $$$ ) follow $$$ a_i > a _ { i+1 } $$$ value $$$ a_i $$$ $$$ a _ { i+1 } $$$ exchange otherwise permutation n't change algorithm consist iterations number consecutive integers start $$$ 1 $$$ $$$ i $$$ -th iteration algorithm follow : prove a finite number iterations permutation sort increase order many iterations happen first time ? test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 200000 - 1 $$$ ; $$$ n $$$ odd ) — length permutation second line contain $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — permutation guarantee sum $$$ n $$$ test case exceed $$$ 200000 - 1 $$$ test case print number iterations permutation become sort increase order first time give permutation already sort print $$$ 0 $$$ first test case permutation change follow : second test case permutation change follow : third test case permutation already sort answer $$$ 0 $$$,"['data structures', 'sortings']",3300.0
1559/E,"mocha want <unknown> $$$ n $$$ star see zhijiang brightness $$$ i $$$ -th star $$$ a_i $$$ mocha consider $$$ n $$$ star form a constellation use $$$ ( a_1 a_2 \ldots a_n ) $$$ show state a state call mathematical follow three condition satisfy : $$$ \gcd ( a_1 a_2 \ldots a_n ) $$$ denote greatest common divisor ( gcd ) integers $$$ a_1 a_2 \ldots a_n $$$ mocha wonder many different mathematical state constellation exist answer may large must find modulo $$$ 998\,244\,353 $$$ two state $$$ ( a_1 a_2 \ldots a_n ) $$$ $$$ ( b_1 b_2 \ldots b_n ) $$$ consider different exist $$$ i $$$ ( $$$ 1\le i\le n $$$ ) $$$ a_i \ne b_i $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 50 $$$ $$$ 1 \le m \le 100000 $$$ ) — number star upper bind sum brightness star next $$$ n $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le m $$$ ) — range brightness $$$ i $$$ -th star print a single integer — number different mathematical state constellation modulo $$$ 998\,244\,353 $$$ first example $$$ 4 $$$ different mathematical state constellation :","['combinatorics', 'dp', 'math', 'number theory']",2200.0
1560/A,"polycarp n't like integers divisible $$$ 3 $$$ end digit $$$ 3 $$$ decimal representation integers meet condition dislike polycarp , polycarp start write positive ( greater $$$ 0 $$$ ) integers like : $$$ 1 2 4 5 7 8 10 11 14 16 \dots $$$ output $$$ k $$$ -th element sequence ( elements number $$$ 1 $$$ ) first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case $$$ t $$$ test case follow test case consist one line contain one integer $$$ k $$$ ( $$$ 1 \le k \le 1000 $$$ ) test case output a separate line one integer $$$ x $$$ — $$$ k $$$ -th element sequence write polycarp",['implementation'],800.0
1561/A,a permutation : array $$$ a = [ a_1 a_2 \ldots a_n ] $$$ distinct integers $$$ 1 $$$ $$$ n $$$ length permutation $$$ n $$$ odd consider follow algorithm sort permutation increase order a helper procedure algorithm $$$ f ( i ) $$$ take a single argument $$$ i $$$ ( $$$ 1 \le i \le n-1 $$$ ) follow $$$ a_i > a _ { i+1 } $$$ value $$$ a_i $$$ $$$ a _ { i+1 } $$$ exchange otherwise permutation n't change algorithm consist iterations number consecutive integers start $$$ 1 $$$ $$$ i $$$ -th iteration algorithm follow : prove a finite number iterations permutation sort increase order many iterations happen first time ? test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 999 $$$ ; $$$ n $$$ odd ) — length permutation second line contain $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — permutation guarantee sum $$$ n $$$ test case exceed $$$ 999 $$$ test case print number iterations permutation become sort increase order first time give permutation already sort print $$$ 0 $$$ first test case permutation change follow : second test case permutation change follow : third test case permutation already sort answer $$$ 0 $$$,"['brute force', 'implementation', 'sortings']",800.0
1562/C,` ` i tell one ? ! '' mage <unknown> ` ` throw one one crack doom watch mordor fall ! '' somewhere a parallel middle - earth saruman catch frodo find $$$ n $$$ ring $$$ i $$$ -th ring either gold silver convenience saruman write a binary string $$$ s $$$ $$$ n $$$ character $$$ i $$$ -th character 0 $$$ i $$$ -th ring gold 1 silver saruman a magic function $$$ f $$$ take a binary string return a number obtain convert string a binary number convert binary number a decimal number example $$$ f ( 001010 ) = 10 f ( 111 ) = 7 f ( <unknown> ) = 221 $$$ saruman however think order ring play important role want find $$$ 2 $$$ pair integers $$$ ( l_1 r_1 ) ( l_2 r_2 ) $$$ : substring $$$ s [ l : r ] $$$ denote $$$ s_ls _ { l+1 } \ldots s _ { r-1 } s_r $$$ $$$ \lfloor x \rfloor $$$ denote round number nearest integer help saruman solve problem ! guarantee constraints problem least one solution exist test contain multiple test case first line contain one positive integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) denote number test case description test case follow first line test case contain one positive integer $$$ n $$$ ( $$$ 2 \le n \le 20000 $$$ ) — length string second line test case contain a non - empty binary string length $$$ n $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ every test case print four integers $$$ l_1 $$$ $$$ r_1 $$$ $$$ l_2 $$$ $$$ r_2 $$$ denote begin first substring end first substring begin second substring end second substring respectively multiple solutions print first testcase $$$ f ( t ) = f ( 1111 ) = 15 $$$ $$$ f ( w ) = f ( 101 ) = 5 $$$ second testcase $$$ f ( t ) = f ( <unknown> ) = 455 $$$ $$$ f ( w ) = f ( 000111 ) = 7 $$$ third testcase $$$ f ( t ) = f ( 0000 ) = 0 $$$ $$$ f ( w ) = f ( 1000 ) = 8 $$$ fourth testcase $$$ f ( t ) = f ( 11011 ) = 27 $$$ $$$ f ( w ) = f ( 011 ) = 3 $$$ fifth testcase $$$ f ( t ) = f ( <unknown> ) = 15 $$$ $$$ f ( w ) = f ( 011 ) = 3 $$$,['math'],1500.0
1566/B,a binary string a string consist character $$$ 0 $$$ $$$ 1 $$$ let $$$ \operatorname { mex } $$$ a binary string smallest digit among $$$ 0 $$$ $$$ 1 $$$ $$$ 2 $$$ occur string example $$$ \operatorname { mex } $$$ $$$ 001011 $$$ $$$ 2 $$$ $$$ 0 $$$ $$$ 1 $$$ occur string least $$$ \operatorname { mex } $$$ $$$ 1111 $$$ $$$ 0 $$$ $$$ 0 $$$ $$$ 2 $$$ occur string $$$ 0 < 2 $$$ a binary string $$$ s $$$ give cut number substrings character exactly one substring possible cut string a single substring — whole string a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end minimal sum $$$ \operatorname { mex } $$$ substrings piece ? input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow test case contain a single binary string $$$ s $$$ ( $$$ 1 \le |s| \le 100000 $$$ ) 's guarantee sum lengths $$$ s $$$ test case exceed $$$ 100000 $$$ test case print a single integer — minimal sum $$$ \operatorname { mex } $$$ substrings possible get cut $$$ s $$$ optimally first test case minimal sum $$$ \operatorname { mex } ( 0 ) + \operatorname { mex } ( 1 ) = 1 + 0 = 1 $$$ second test case minimal sum $$$ \operatorname { mex } ( 1111 ) = 0 $$$ third test case minimal sum $$$ \operatorname { mex } ( 01100 ) = 2 $$$,"['bitmasks', 'dp', 'greedy']",800.0
1566/D2,hard version problem difference version $$$ 1 \le n \le 300 $$$ cinema seat represent table $$$ n $$$ row $$$ m $$$ columns row number integers $$$ 1 $$$ $$$ n $$$ seat row number consecutive integers leave right : $$$ k $$$ -th row $$$ m ( k - 1 ) + 1 $$$ $$$ m k $$$ row $$$ 1 \le k \le n $$$ $$$ nm $$$ people want go cinema watch a new film number integers $$$ 1 $$$ $$$ nm $$$ give exactly one seat person know cinema lower seat index better see everything happen screen $$$ i $$$ -th person level sight $$$ a_i $$$ let 's define $$$ s_i $$$ seat index give $$$ i $$$ -th person want give better place people lower sight level two people $$$ i $$$ $$$ j $$$ $$$ a_i < a_j $$$ satisfy $$$ s_i < s_j $$$ give seat people start come seat order $$$ 1 $$$ $$$ nm $$$ person enter hall sit seat get place person go seat 's row start move first seat row leave right move place free occupy people already seat inconvenience person equal number occupy seat go let 's consider example : $$$ m = 5 $$$ person seat $$$ 4 $$$ first row seat $$$ 1 $$$ $$$ 3 $$$ $$$ 5 $$$ first row already occupy seat $$$ 2 $$$ $$$ 4 $$$ free inconvenience person $$$ 2 $$$ go occupy seat $$$ 1 $$$ $$$ 3 $$$ find minimal total inconvenience ( sum inconvenience people ) possible give place people ( condition satisfy ) input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 300 $$$ ) — number row place row respectively second line test case contain $$$ n \cdot m $$$ integers $$$ a_1 a_2 \ldots a _ { n \cdot m } $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ sight level $$$ i $$$ -th person 's guarantee sum $$$ n \cdot m $$$ test case exceed $$$ 100000 $$$ test case print a single integer — minimal total inconvenience achieve first test case a single way give seat : first person sit first place second person — second total inconvenience $$$ 1 $$$ second test case optimal seat look like : third test case optimal seat look like : number a cell person 's index sit place,"['data structures', 'greedy', 'implementation', 'sortings', 'two pointers']",1600.0
1566/H,"interactive problem give two integers $$$ c $$$ $$$ n $$$ jury a randomly generate set $$$ a $$$ distinct positive integers greater $$$ c $$$ ( generate possible set equal probability ) size $$$ a $$$ equal $$$ n $$$ task guess set $$$ a $$$ order guess ask $$$ \lceil 0.65 \cdot c \rceil $$$ query query choose a single integer $$$ 1 \le x \le c $$$ answer query give bitwise xor sum $$$ y $$$ $$$ y \in a $$$ $$$ gcd ( x y ) = 1 $$$ ( i.e $$$ x $$$ $$$ y $$$ coprime ) $$$ y $$$ xor sum equal $$$ 0 $$$ ask query begin receive answer query , wo n't possibility ask query find set $$$ a ' $$$ $$$ <unknown> = n $$$ $$$ a ' $$$ $$$ a $$$ answer $$$ c $$$ possible query firstly give two integers $$$ c $$$ $$$ n $$$ ( $$$ 100 \le c \le 1000000 $$$ $$$ 0 \le n \le c $$$ ) first line print integer $$$ q $$$ $$$ ( 0 \le q \le \lceil 0.65 \cdot c \rceil ) $$$ — number query want ask line print $$$ q $$$ integers $$$ x_1 x_2 \ldots x_q $$$ $$$ ( 1 \le x_i \le c ) $$$ — query query read $$$ q $$$ integers $$$ i $$$ -th answer describe query $$$ x = x_i $$$ print $$$ n $$$ distinct integers $$$ a'_1 a'_2 \ldots a'_n $$$ — set $$$ a ' $$$ find different set $$$ a ' $$$ answer possible query print ask $$$ \lceil 0.65 \cdot c \rceil $$$ query query invalid interactor terminate immediately program receive verdict wrong answer print query answer forget output end line flush output buffer otherwise get idleness limit exceed verdict flush use : hacksyou make hack problem sample make understand interaction protocol solution test sample sample $$$ a = \ { 1 4 5 6 8 10\ } $$$ $$$ 7 $$$ query make $$$ 7 \le \lceil 0.65 \cdot 10 \rceil = 7 $$$ query limit exceed answer query :","['dp', 'math', 'number theory']",3200.0
1569/A,give a string $$$ s $$$ consist $$$ n $$$ letter letter either ' a ' ' b ' letter string number $$$ 1 $$$ $$$ n $$$ $$$ s [ l ; r ] $$$ a continuous substring letter index $$$ l $$$ $$$ r $$$ string inclusive a string call balance number letter ' a ' equal number letter ' b ' example string ` ` baba '' ` ` <unknown> '' balance string ` ` aaab '' ` ` b '' find non - empty balance substring $$$ s [ l ; r ] $$$ string $$$ s $$$ print $$$ l $$$ $$$ r $$$ ( $$$ 1 \le l \le r \le n $$$ ) substring print $$$ -1 $$$ $$$ -1 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases descriptions $$$ t $$$ testcases follow first line testcase contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — length string second line testcase contain a string $$$ s $$$ consist $$$ n $$$ letter letter either ' a ' ' b ' testcase print two integers exist a non - empty balance substring $$$ s [ l ; r ] $$$ print $$$ l $$$ $$$ r $$$ ( $$$ 1 \le l \le r \le n $$$ ) otherwise print $$$ -1 $$$ $$$ -1 $$$ first testcase non - empty balance <unknown> second third testcases multiple balance substrings include entire string ` ` <unknown> '' substring ` ` baba '',['implementation'],800.0
157/A,sherlock holmes dr . <unknown> play game a checker board n × n size game put number board 's square tricky rule n't know however game square board contain exactly one number understand need count number win square determine particular square win follow calculate sum number square share column ( include give square ) separately calculate sum number square share row ( include give square ) a square consider win sum column number strictly greater sum row number instance let game end like show picture purple cell win sum column number equal 8 + 3 + 6 + 7 = 24 sum row number equal 9 + 5 + 3 + 2 = 19 24 > 19 . first line contain integer n ( 1 ≤ n ≤ 30 ) follow n line contain n space - separated integers j - th number i - th line represent number square belong j - th column i - th row board number board integers 1 100 . print single number — number win square first example two upper square win third example three leave square middle row win :,['brute force'],800.0
1571/C,let 's say two string $$$ s $$$ $$$ t $$$ rhyme string length least $$$ k $$$ last $$$ k $$$ character equal example $$$ k = 3 $$$ string abcd <unknown> rhyme string ab ab n't rhyme string aaaa aaaaa rhyme string abcd <unknown> n't rhyme $$$ n $$$ pair string $$$ ( s_i t_i ) $$$ pair string know rhyme find possible non - negative integer value $$$ k $$$ pair rhyme rhyme pair must rhyme n't rhyme test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number string pair next $$$ n $$$ line contain descriptions pair — one per line $$$ i $$$ -th line contain space - separated string $$$ s_i $$$ $$$ t_i $$$ marker $$$ r_i $$$ string non - empty consist lowercase latin letter length $$$ 200000 $$$ marker $$$ r_i $$$ equal $$$ 1 $$$ string rhyme $$$ 0 $$$ must rhyme 's guarantee test case least one pair $$$ r_i $$$ equal $$$ 1 $$$ total length string test case n't exceed $$$ 400000 $$$ test case firstly print integer $$$ m $$$ — number possible non - negative integer value $$$ k $$$ pair rhyme rhyme pair must rhyme n't rhyme next print value $$$ k $$$ ( without repetitions ) print order first test case $$$ k $$$ least $$$ 1 $$$ kotlin heroes n't rhyme second test case $$$ k = 2 $$$ join kotlin rhyme episode eight n't rhyme,['implementation'],1800.0
1571/F,kotlinforces a web <unknown> host program competitions staff kotlinforces ask schedule $$$ n $$$ program competitions next $$$ m $$$ days competition hold multiple stag ; regulations $$$ i $$$ -th competition state competition consist exactly $$$ k_i $$$ stag stage start second one schedule exactly $$$ t_i $$$ days previous stage word first stage $$$ i $$$ -th competition schedule day $$$ x $$$ second stage schedule day $$$ <unknown> $$$ third stage — day $$$ <unknown> $$$ ... $$$ k_i $$$ -th stage ( last one ) — day $$$ <unknown> ( <unknown> ) t_i $$$ $$$ n $$$ competitions schedule a way start finish next $$$ m $$$ days $$$ m $$$ days one stage one competition hold ( two stag different competitions schedule day ) possible schedule $$$ n $$$ competitions meet constraints ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 5000 $$$ ) — number competitions number days respectively $$$ n $$$ line follow describe a competition schedule $$$ i $$$ -th line contain two integers $$$ k_i $$$ $$$ t_i $$$ ( $$$ 2 \le k_i \le 5000 $$$ ; $$$ 1 \le t_i \le 2 $$$ ) — parameters $$$ i $$$ -th competition impossible schedule $$$ n $$$ competitions next $$$ m $$$ days one stage day print -1 . otherwise print $$$ n $$$ integers $$$ i $$$ -th integer represent day first stage $$$ i $$$ -th competition schedule ; days number $$$ 1 $$$ $$$ m $$$ multiple answer print,['dp'],2000.0
1572/C,give a $$$ 1 $$$ $$$ n $$$ pixel image $$$ i $$$ -th pixel image color $$$ a_i $$$ color number pixels color $$$ 20 $$$ perform follow operation work like bucket tool paint program image : compute minimum number operations need make pixels image color test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 3\cdot1000 $$$ ) — number pixels image second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — color pixels image note : color number pixels color $$$ 20 $$$ guarantee sum $$$ n $$$ test case exceed $$$ 3\cdot1000 $$$ test case print one integer : minimum number operations need make pixels image color first example optimal solution apply operation third pixel change color $$$ 2 $$$ apply operation pixel color $$$ 2 $$$ change color color pixels connect $$$ 1 $$$ sequence operations : $$$ [ 1 2 3 2 1 ] \to [ 1 2 2 2 1 ] \to [ 1 1 1 1 1 ] $$$ second example either change $$$ 1 $$$ s $$$ 2 $$$ s one operation change $$$ 2 $$$ s $$$ 1 $$$ s also one operation third example one possible way make pixels color apply operation first third fourth pixel time change color $$$ 2 $$$,"['dp', 'greedy']",2700.0
1572/D,currently $$$ n $$$ hot topics number $$$ 0 $$$ $$$ n-1 $$$ local bridge club $$$ 2^n $$$ players number $$$ 0 $$$ $$$ 2^n-1 $$$ player hold a different set view $$$ n $$$ topics specifically $$$ i $$$ -th player hold a positive view $$$ j $$$ -th topic $$$ i\ \ & \ 2^j > 0 $$$ a negative view otherwise $$$ \ & $$$ denote bitwise operation go organize a bridge tournament capable accommodate $$$ k $$$ pair players ( bridge play team two people ) select team arbitrarily player one team one catch : two players pair disagree $$$ 2 $$$ $$$ n $$$ topics would argue much play know $$$ i $$$ -th player pay $$$ a_i $$$ dollars play tournament compute maximum amount money earn pair players club optimally first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 20 $$$ $$$ 1 \le k \le 200 $$$ ) — number hot topics number pair players tournament accommodate second line contain $$$ 2^n $$$ integers $$$ a_0 a_1 \dots a _ { 2^n-1 } $$$ ( $$$ 0 \le a_i \le 1000000 $$$ ) — amount money players pay play tournament print one integer : maximum amount money earn pair players club optimally condition first example best pair together $$$ 0 $$$ -th player $$$ 2 $$$ -nd player result earn $$$ 8 + 5 = 13 $$$ dollars although pair $$$ 0 $$$ -th player $$$ 5 $$$ -th player would give us $$$ 8 + 10 = 18 $$$ dollars two players disagree $$$ 2 $$$ $$$ 3 $$$ hot topics second example pair $$$ 0 $$$ -th player $$$ 1 $$$ -st player pair $$$ 2 $$$ -nd player $$$ 3 $$$ -rd player result earn $$$ 7 + 4 + 5 + 7 = 23 $$$ dollars,"['graphs', 'greedy']",2800.0
1578/K,"kingdom islands consist $$$ p $$$ islands king rule whole kingdom island rule one several jarls rule total $$$ n $$$ jarls <unknown> island kingdom strong traditions jarls rule island support never conflict <unknown> strength cultural conflict people inhabit different islands thus two jarls rule different islands conflict however recent years bring a change traditional relations jarls knowledge exactly $$$ k $$$ pair jarls relationships two jarls pair different traditional , two jarls pair know rule island jarls conflict rule different islands overcome cultural disagreement conflict anymore a true responsible king worry whether kingdom close a major conflict order estimate current situation would like find largest possible group jarls every two jarls group conflict first line input consist two integers $$$ p $$$ $$$ n $$$ ( $$$ 1 \le p \le n \le 100000 $$$ ; $$$ 1 \le p \le 10000 $$$ ) second line consist $$$ n $$$ integers $$$ s_1 s_2 \ldots s_n $$$ ( $$$ 1 \le s_i \le p $$$ ) integer $$$ s_i $$$ denote $$$ i $$$ -th jarl rule island number $$$ s_i $$$ guarantee island rule least one jarl third line consist a single integer $$$ k $$$ ( $$$ 0 \le k \le 20 $$$ ) $$$ k $$$ line follow $$$ j $$$ -th line consist two distinct integers $$$ a_j $$$ $$$ b_j $$$ ( $$$ 1 \le a_j < b_j \le n $$$ ) denote relation $$$ a_j $$$ -th jarl $$$ b_j $$$ -th jarl differ traditional guarantee pair jarls appear twice list first line print a single integer $$$ q $$$ $$$ 1 $$$ $$$ n $$$ — largest possible number jarls a pairwise conflict group second line print $$$ q $$$ distinct integers $$$ 1 $$$ $$$ n $$$ — number jarls group number jarls print order conflict graph last sample testcase give circle represent island","['brute force', 'graphs', 'implementation']",2800.0
1579/C,casimir a rectangular piece paper a checker field size $$$ n \times m $$$ initially cells field white let us denote cell coordinate $$$ i $$$ vertically $$$ j $$$ horizontally $$$ ( i j ) $$$ upper leave cell refer $$$ ( 1 1 ) $$$ lower right cell $$$ ( n m ) $$$ casimir draw tick different size field a tick size $$$ d $$$ ( $$$ d > 0 $$$ ) center cell $$$ ( i j ) $$$ draw follow : already paint cell remain black paint find example $$$ 4 \times 9 $$$ box two tick size $$$ 2 $$$ $$$ 3 $$$ give a description a checker field size $$$ n \times m $$$ casimir claim field come draw ( possibly $$$ 0 $$$ ) tick tick could different size size tick least $$$ k $$$ ( $$$ d \ge k $$$ tick ) determine whether field indeed obtain draw ( possibly none ) tick size $$$ d \ge k $$$ first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case follow line contain descriptions test case first line test case description contain integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 10 $$$ ; $$$ 1 \le m \le 19 $$$ ) — field size minimum size tick casimir draw follow $$$ n $$$ line describe field : line consist $$$ m $$$ character either ' . ' correspond cell yet paint ' * ' otherwise print $$$ t $$$ line line contain answer correspond test case answer a test case yes give field obtain draw tick least give size otherwise may print every letter case want ( example string yes yes yes yes recognize positive answer ) first sample test case consist two asterisk neither independent tick since tick size $$$ 0 $$$ n't exist second sample test case already describe statement ( check picture statement ) field obtain draw tick size $$$ 2 $$$ $$$ 3 $$$ show figure field third sample test case correspond three tick size $$$ 1 $$$ center cells mark $$$ \color { blue } { \text { blue } } $$$ $$$ \color { red } { \text { red } } $$$ $$$ \color { green } { \text { green } } $$$ color : * . * * $$$ \color { blue } { \textbf { * } } $$$ * * $$$ \color { green } { \textbf { * } } \color { red } { \textbf { * } } $$$ ..... field fourth sample test case could obtain draw two tick size $$$ 1 $$$ $$$ 2 $$$ vertices mark $$$ \color { blue } { \text { blue } } $$$ $$$ \color { red } { \text { red } } $$$ color respectively : ..... * ... * . * . * . $$$ \color { red } { \textbf { * } } $$$ * . $$$ \color { blue } { \textbf { * } } $$$ field fifth sample test case obtain $$$ k = 2 $$$ last asterisk fourth row top coordinate $$$ ( 4 5 ) $$$ a part a tick size $$$ 1 $$$ field sixth sample test case obtain top leave asterisk $$$ ( 1 1 ) $$$ ca n't independent tick since size tick must positive part a tick center cell last row since separate a gap ( a point ' . ' ) $$$ ( 2 2 ) $$$ seventh sample test case similarly field obtain describe process asterisk coordinate $$$ ( 1 2 ) $$$ ( second cell first row ) $$$ ( 3 1 ) $$$ $$$ ( 3 3 ) $$$ ( leftmost rightmost cells bottom ) part tick,"['greedy', 'implementation']",1500.0
1579/E1,"fact problems e1 e2 much common probably think two separate problems a permutation $$$ p $$$ size $$$ n $$$ give a permutation size $$$ n $$$ array size $$$ n $$$ integer $$$ 1 $$$ $$$ n $$$ occur exactly example $$$ [ 1 4 3 2 ] $$$ $$$ [ 4 2 1 3 ] $$$ correct permutations $$$ [ 1 2 4 ] $$$ $$$ [ 1 2 2 ] $$$ let us consider empty deque ( double - ended queue ) a deque a data structure support add elements begin end , elements $$$ [ 1 5 2 ] $$$ currently deque add element $$$ 4 $$$ begin produce sequence $$$ [ \color { red } { 4 } 1 5 2 ] $$$ add element end produce $$$ [ 1 5 2 \color { red } { 4 } ] $$$ elements permutation sequentially add initially empty deque start $$$ p_1 $$$ finish $$$ p_n $$$ add element deque may choose whether add begin end example consider a permutation $$$ p = [ 3 1 2 4 ] $$$ one possible sequence action look like : $$$ \quad $$$ 1.add $$$ 3 $$$ end deque : deque a sequence $$$ [ \color { red } { 3 } ] $$$ ; $$$ \quad $$$ 2.add $$$ 1 $$$ begin deque : deque a sequence $$$ [ \color { red } { 1 } 3 ] $$$ ; $$$ \quad $$$ 3.add $$$ 2 $$$ end deque : deque a sequence $$$ [ 1 3 \color { red } { 2 } ] $$$ ; $$$ \quad $$$ 4.add $$$ 4 $$$ end deque : deque a sequence $$$ [ 1 3 2 \color { red } { 4 } ] $$$ ; find lexicographically smallest possible sequence elements deque entire permutation process a sequence $$$ [ x_1 x_2 \ldots x_n ] $$$ lexicographically smaller sequence $$$ [ y_1 y_2 \ldots y_n ] $$$ exist $$$ i \leq n $$$ $$$ x_1 = y_1 $$$ $$$ x_2 = y_2 $$$ $$$ \ldots $$$ $$$ x _ { i - 1 } = y _ { i - 1 } $$$ $$$ x_i < y_i $$$ word sequence $$$ x $$$ $$$ y $$$ ( possibly empty ) match prefix next element sequence $$$ x $$$ strictly smaller correspond element sequence $$$ y $$$ example sequence $$$ [ 1 3 2 4 ] $$$ smaller sequence $$$ [ 1 3 4 2 ] $$$ two match elements $$$ [ 1 3 ] $$$ start first sequence element $$$ 2 $$$ smaller correspond element $$$ 4 $$$ second sequence first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case next $$$ 2 t $$$ line contain descriptions test case first line test case description contain integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — permutation size second line description contain $$$ n $$$ space - separated integers $$$ p_i $$$ ( $$$ 1 \le p_i \le n $$$ ; $$$ p_i $$$ unique ) — elements permutation guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ print $$$ t $$$ line line contain answer correspond test case answer a test case contain $$$ n $$$ space - separated integer number — elements lexicographically smallest permutation possible find deque execute describe algorithm one ways get a lexicographically smallest permutation $$$ [ 1 3 2 4 ] $$$ permutation $$$ [ 3 1 2 4 ] $$$ ( first sample test case ) describe problem statement","['greedy', 'math']",1000.0
1579/E2,"fact problems e1 e2 much common probably think two separate problems give integer array $$$ a [ 1 \ldots n ] = [ a_1 a_2 \ldots a_n ] $$$ let us consider empty deque ( double - ended queue ) a deque a data structure support add elements begin end , elements $$$ [ 3 4 4 ] $$$ currently deque add element $$$ 1 $$$ begin produce sequence $$$ [ \color { red } { 1 } 3 4 4 ] $$$ add element end produce $$$ [ 3 4 4 \color { red } { 1 } ] $$$ elements array sequentially add initially empty deque start $$$ a_1 $$$ finish $$$ a_n $$$ add element deque may choose whether add begin end example consider array $$$ a = [ 3 7 5 5 ] $$$ one possible sequence action look like : $$$ \quad $$$ 1.add $$$ 3 $$$ begin deque : deque a sequence $$$ [ \color { red } { 3 } ] $$$ ; $$$ \quad $$$ 2.add $$$ 7 $$$ end deque : deque a sequence $$$ [ 3 \color { red } { 7 } ] $$$ ; $$$ \quad $$$ 3.add $$$ 5 $$$ end deque : deque a sequence $$$ [ 3 7 \color { red } { 5 } ] $$$ ; $$$ \quad $$$ 4.add $$$ 5 $$$ begin deque : deque a sequence $$$ [ \color { red } { 5 } 3 7 5 ] $$$ ; find minimal possible number inversions deque whole array process inversion sequence $$$ d $$$ a pair indices $$$ ( i j ) $$$ $$$ i < j $$$ $$$ d_i > d_j $$$ example array $$$ d = [ 5 3 7 5 ] $$$ exactly two inversions — $$$ ( 1 2 ) $$$ $$$ ( 3 4 ) $$$ since $$$ d_1 = 5 > 3 = d_2 $$$ $$$ d_3 = 7 > 5 = d_4 $$$ first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case next $$$ 2 t $$$ line contain descriptions test case first line test case description contain integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — array size second line description contain $$$ n $$$ space - separated integers $$$ a_i $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) — elements array guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ print $$$ t $$$ line line contain answer correspond test case answer a test case a single integer — minimal possible number inversions deque execute describe algorithm one ways get sequence $$$ [ 5 3 7 5 ] $$$ deque contain two inversions initial array $$$ [ 3 7 5 5 ] $$$ ( first sample test case ) describe problem statement also example could get answer two inversions simply put element original array end deque case original sequence $$$ [ 3 7 5 5 ] $$$ also contain exactly two inversions deque <unknown> - is","['data structures', 'greedy']",1700.0
158/B,lessons n group schoolchildren go outside decide visit polycarpus celebrate birthday know i - th group consist si friends ( 1 ≤ si ≤ 4 ) want go polycarpus together decide get taxi car carry four passengers minimum number cars children need members group ride taxi ( one taxi take one group ) ? first line contain integer n ( 1 ≤ n ≤ 105 ) — number group schoolchildren second line contain a sequence integers s1 s2 ... sn ( 1 ≤ si ≤ 4 ) integers separate a space si number children i - th group print single number — minimum number <unknown> necessary drive children polycarpus first test sort children four cars like : ways sort group four cars,"['greedy', 'implementation']",1100.0
1580/C,kawasiro nitori excellent engineer thus appoint help maintain train $$$ n $$$ model train nitori 's department one train model moment begin train follow $$$ m $$$ days one train add one train remove a train model $$$ i $$$ add day $$$ t $$$ work $$$ x_i $$$ days ( day $$$ t $$$ inclusive ) maintenance $$$ y_i $$$ days work $$$ x_i $$$ days remove order make management easier nitori want help calculate many train maintenance day a day a train remove count maintenance first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200000 $$$ ) $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ x_i y_i $$$ ( $$$ 1 \le x_i y_i \le 1000000000 $$$ ) next $$$ m $$$ line contain two integers $$$ op $$$ $$$ k $$$ ( $$$ 1 \le k \le n $$$ $$$ op = 1 $$$ $$$ op = 2 $$$ ) $$$ <unknown> $$$ mean day 's a train model $$$ k $$$ add otherwise train model $$$ k $$$ remove guarantee a train model $$$ x $$$ add train model department a train model $$$ x $$$ remove a train department print $$$ m $$$ line $$$ i $$$ -th line contain one integers denote number train maintenance $$$ i $$$ -th day consider first example : first day : nitori add a train model $$$ 3 $$$ a train model $$$ 3 $$$ run train maintenance second day : nitori add a train model $$$ 1 $$$ a train model $$$ 1 $$$ run a train model $$$ 3 $$$ maintenance third day : nitori remove a train model $$$ 1 $$$ situation first day fourth day : nitori remove a train model $$$ 3 $$$ train,"['brute force', 'data structures', 'implementation']",2200.0
1582/B,"luntik come a morning stroll find array $$$ a $$$ length $$$ n $$$ calculate sum $$$ s $$$ elements array ( $$$ s= \sum _ { i=1 } ^ { n } a_i $$$ ) luntik call a subsequence array $$$ a $$$ nearly full sum number subsequence equal $$$ <unknown> $$$ luntik really want know number nearly full subsequences array $$$ a $$$ need come home ask solve problem ! a sequence $$$ x $$$ a subsequence a sequence $$$ y $$$ $$$ x $$$ obtain $$$ y $$$ deletion several ( possibly zero ) elements first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next $$$ 2 \cdot t $$$ line contain descriptions test case description test case consist two line first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 60 $$$ ) — length array second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — elements array $$$ a $$$ test case print number nearly full subsequences array first test case $$$ s=1 + 2 + 3 + 4 + 5=15 $$$ $$$ ( 2,3,4,5 ) $$$ a nearly full subsequence among subsequences sum equal $$$ 2 + 3 + 4 + <unknown> - 1 $$$ second test case nearly full subsequences third test case $$$ s=1 + 0=1 $$$ nearly full subsequences $$$ ( 0 ) $$$ $$$ ( ) $$$ ( sum empty subsequence $$$ 0 $$$ )","['combinatorics', 'math']",900.0
1582/C,grandma capa decide knit a scarf ask grandpa sher make a pattern a pattern a string consist lowercase english letter grandpa sher write a string $$$ s $$$ length $$$ n $$$ grandma capa want knit a beautiful scarf opinion a beautiful scarf knit a string a palindrome want change pattern write grandpa sher avoid offend choose one lowercase english letter erase ( choice possibly none ) occurrences letter string $$$ s $$$ also want minimize number erase symbols pattern please help find minimum number symbols erase make string $$$ s $$$ a palindrome tell 's impossible notice erase symbols equal one letter choose a string a palindrome leave right right leave example string ' kek ' ' abacaba ' ' r ' ' papicipap ' palindromes string ' abb ' ' iq ' first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case next $$$ 2 \cdot t $$$ line contain description test case description test case consist two line first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length string second line test case contain string $$$ s $$$ consist $$$ n $$$ lowercase english letter guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print minimum number erase symbols require make string a palindrome possible $$$ -1 $$$ impossible first test case choose a letter ' a ' erase first last occurrences get a string ' <unknown> ' a palindrome also choose a letter ' b ' erase occurrences get a string ' <unknown> ' a palindrome well second test case show impossible choose a letter erase occurrences get a palindrome third test case n't erase symbols string already a palindrome,"['brute force', 'data structures', 'greedy', 'strings', 'two pointers']",1200.0
1583/H,"omkar host tour country omkarland ! $$$ n $$$ cities omkarland , rather curiously exactly $$$ n-1 $$$ bidirectional roads connect cities guarantee reach city city road network every city enjoyment value $$$ e $$$ road a capacity $$$ c $$$ denote maximum number vehicles associate toll $$$ t $$$ however toll system omkarland interest <unknown> : a vehicle travel multiple roads a single journey pay highest toll single road travel ( word pay $$$ \max t $$$ roads travel . ) a vehicle traverse roads pay $$$ 0 $$$ toll omkar decide host $$$ q $$$ tour group tour group consist $$$ v $$$ vehicles start city $$$ x $$$ ( keep mind a tour group $$$ v $$$ vehicles travel roads capacity $$$ \geq v $$$ . ) tour organizer omkar want group much fun possibly also must reimburse group toll pay thus tour group omkar want know two things : first enjoyment value city $$$ y $$$ maximum enjoyment value tour group reach start city second much per vehicle omkar pay reimburse entire group trip $$$ x $$$ $$$ y $$$ ? ( trip $$$ x $$$ $$$ y $$$ always shortest path $$$ x $$$ $$$ y $$$ ) case multiple reachable cities maximum enjoyment value omkar let tour group choose one want go therefore prepare possible scenarios want know amount money per vehicle need guarantee reimburse group regardless city choose first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \leq n \leq 200000 $$$ $$$ 1 \leq q \leq 200000 $$$ ) represent number cities number group respectively next line contain $$$ n $$$ integers $$$ e_1 e_2 \ldots e_n $$$ ( $$$ 1 \leq e_i \leq 1000000000 $$$ ) $$$ e_i $$$ represent enjoyment value city $$$ i $$$ next $$$ n-1 $$$ line contain four integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ t $$$ ( $$$ 1 \leq a b \leq n $$$ $$$ 1 \leq c \leq 1000000000 $$$ $$$ 1 \leq t \leq 1000000000 $$$ ) represent road city $$$ a $$$ city $$$ b $$$ capacity $$$ c $$$ toll $$$ t $$$ next $$$ q $$$ line contain two integers $$$ v $$$ $$$ x $$$ ( $$$ 1 \leq v \leq 1000000000 $$$ $$$ 1 \leq x \leq n $$$ ) represent number vehicles tour group start city respectively output $$$ q $$$ line $$$ i $$$ -th line contain two integers : highest possible enjoyment value a city reachable $$$ i $$$ -th tour group amount money per vehicle omkar need guarantee reimburse $$$ i $$$ -th tour group a map first sample show nod unbolded number represent indices bolded number represent enjoyment value edge unbolded number represent capacities bolded number represent toll first query a tour group size $$$ 1 $$$ start city $$$ 3 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ thus largest enjoyment value reach $$$ 3 $$$ tour group choose go city $$$ 4 $$$ omkar pay $$$ 8 $$$ per vehicle maximum second query a tour group size $$$ 9 $$$ start city $$$ 5 $$$ reach city $$$ 5 $$$ thus largest reachable enjoyment value still $$$ 3 $$$ omkar pay $$$ 0 $$$ per vehicle third query a tour group size $$$ 6 $$$ start city $$$ 2 $$$ reach cities $$$ 2 $$$ $$$ 4 $$$ largest reachable enjoyment value $$$ 3 $$$ tour group choose go city $$$ 4 $$$ omkar pay $$$ 2 $$$ per vehicle maximum a map second sample show : first query a tour group size $$$ 5 $$$ start city $$$ 1 $$$ reach city $$$ 1 $$$ thus maximum enjoyment value $$$ 1 $$$ cost omkar pay $$$ 0 $$$ per vehicle second query a tour group size $$$ 4 $$$ start city $$$ 1 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ thus maximum enjoyment value $$$ 2 $$$ omkar pay $$$ 1 $$$ per vehicle third query a tour group size $$$ 3 $$$ start city $$$ 1 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ thus maximum enjoyment value $$$ 3 $$$ omkar pay $$$ 1 $$$ per vehicle fourth query a tour group size $$$ 2 $$$ start city $$$ 1 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ thus maximum enjoyment value $$$ 4 $$$ omkar pay $$$ 1 $$$ per vehicle fifth query a tour group size $$$ 1 $$$ start city $$$ 1 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ thus maximum enjoyment value $$$ 5 $$$ omkar pay $$$ 1 $$$ per vehicle","['data structures', 'divide and conquer', 'sortings', 'trees']",3300.0
1584/F,give $$$ n $$$ string $$$ s_1 s_2 \ldots s_n $$$ consist lowercase uppercase english letter addition 's guarantee character occur string twice find longest common subsequence string a string $$$ t $$$ a subsequence a string $$$ s $$$ $$$ t $$$ obtain $$$ s $$$ deletion several ( possibly zero ) symbols test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 5 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 10 $$$ ) — number string next $$$ n $$$ line contain correspond string $$$ s_i $$$ $$$ s_i $$$ non - empty consist uppercase lowercase english letter character appear twice string test case print answer two line : first line print length longest common subsequence second line print longest common subsequence multiple subsequences print first test case longest common subsequence ` ` a '' common subsequences length $$$ 2 $$$ second test case set character string n't intersect non - empty string ca n't a common subsequence,"['bitmasks', 'dp', 'graphs', 'greedy', 'strings']",2600.0
1585/A,petya get interest flower petya a busy person sometimes forget water give $$$ n $$$ days petya 's live determine happen flower end flower grow follow : begin $$$ 1 $$$ -st day flower $$$ 1 $$$ centimeter tall height $$$ n $$$ days ? test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ a_i = 0 $$$ $$$ a_i = 1 $$$ ) $$$ a_i = 1 $$$ flower water $$$ i $$$ -th day otherwise water test case print a single integer $$$ k $$$ — flower 's height $$$ n $$$ days $$$ -1 $$$ flower die,['implementation'],800.0
1585/C,a total $$$ n $$$ depots locate a number line depot $$$ i $$$ lie point $$$ x_i $$$ $$$ 1 \le i \le n $$$ a salesman $$$ n $$$ bag goods attempt deliver one bag $$$ n $$$ depots $$$ n $$$ bag initially origin $$$ 0 $$$ carry $$$ k $$$ bag a time must collect require number goods origin deliver respective depots return origin collect next batch goods calculate minimum distance need cover deliver bag goods depots return origin deliver bag test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le <unknown> $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 200000 $$$ ) second line test case contain $$$ n $$$ integers $$$ x_1 x_2 \ldots x_n $$$ ( $$$ -1000000000 \le x_i \le 1000000000 $$$ ) possible depots share position guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a single integer denote minimum distance need cover deliver bag goods depots first test case carry one bag a time thus follow a solution sequence give a minimum travel distance : $$$ 0 \to 2 \to 0 \to 4 \to 0 \to 3 \to 0 \to 1 \to 0 \to 5 $$$ $$$ 0 $$$ mean go origin grab one bag positive integer mean deliver bag a depot coordinate give a total distance $$$ 25 $$$ units must note sequence give distance second test case follow follow sequence among multiple sequence travel minimum distance : $$$ 0 \to 6 \to 8 \to 7 \to 0 \to 5 \to 4 \to 3 \to 0 \to ( -5 ) \to ( -10 ) \to ( -15 ) $$$ distance $$$ 41 $$$ show $$$ 41 $$$ optimal distance test case,['greedy'],1300.0
1592/F1,difference versions cost operations solution one version wo n't work another ! alice a grid size $$$ n \times m $$$ initially cells color white cell intersection $$$ i $$$ -th row $$$ j $$$ -th column denote $$$ ( i j ) $$$ alice follow operations grid : choose subrectangle contain cell $$$ ( 1 1 ) $$$ flip color cells ( flip mean change color white black black white ) operation cost $$$ 1 $$$ coin choose subrectangle contain cell $$$ ( n 1 ) $$$ flip color cells operation cost $$$ 2 $$$ coin choose subrectangle contain cell $$$ ( 1 m ) $$$ flip color cells operation cost $$$ 4 $$$ coin choose subrectangle contain cell $$$ ( n m ) $$$ flip color cells operation cost $$$ 3 $$$ coin a reminder subrectangle a set cells $$$ ( x y ) $$$ $$$ x_1 \le x \le x_2 $$$ $$$ y_1 \le y \le y_2 $$$ $$$ 1 \le x_1 \le x_2 \le n $$$ $$$ 1 \le y_1 \le y_2 \le m $$$ alice want obtain favorite color operations 's smallest number coin would spend ? show 's always possible transform initial grid first line input contain $$$ 2 $$$ integers $$$ n m $$$ ( $$$ 1 \le n m \le 500 $$$ ) — dimension grid $$$ i $$$ -th next $$$ n $$$ line contain a string $$$ s_i $$$ length $$$ m $$$ consist letter w b. $$$ j $$$ -th character string $$$ s_i $$$ w cell $$$ ( i j ) $$$ color white favorite color alice b 's color black output smallest number coin alice would spend achieve favorite color first sample 's optimal apply fourth operation rectangle contain cells $$$ ( 2 2 ) ( 2 3 ) ( 3 2 ) ( 3 3 ) $$$ would cost $$$ 3 $$$ coin,['greedy'],2600.0
1593/C,one cat $$$ k $$$ mice one hole a coordinate line cat locate point $$$ 0 $$$ hole locate point $$$ n $$$ mice locate cat hole : $$$ i $$$ -th mouse locate point $$$ x_i $$$ ( $$$ 0 < x_i < n $$$ ) point many mice locate one second follow happen first exactly one mouse move right $$$ 1 $$$ mouse reach hole hide ( i.e mouse move point eat cat ) ( mouse finish move ) cat move right $$$ 1 $$$ new cat 's position mice locate cat eat ( able move ) action perform mouse n't hide n't eat word first move make a mouse mouse reach hole 's save cat make a move cat eat mice locate point cat reach ( cat reach hole eat nobody ) second select a mouse make a move maximum number mice reach hole without eat ? first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow test case consist two line first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 1000000000 $$$ $$$ 1 \le k \le 400000 $$$ ) second line contain $$$ k $$$ integers $$$ x_1 x_2 \dots x_k $$$ ( $$$ 1 \le x_i < n $$$ ) — initial coordinate mice guarantee sum $$$ k $$$ give input n't exceed $$$ 400000 $$$ test case output a separate line integer $$$ m $$$ ( $$$ m \ge 0 $$$ ) — maximum number mice reach hole without eat,"['binary search', 'greedy', 'greedy']",1000.0
1598/B,"$$$ n $$$ students attend first meet berland su program course ( $$$ n $$$ even ) students divide two group group attend exactly one lesson week one five work days ( monday tuesday wednesday thursday friday ) days choose group must different furthermore group contain number students student fill a survey tell days week convenient attend a lesson , task determine possible choose two different week days schedule lessons group ( first group attend lesson first choose day second group attend lesson second choose day ) divide students two group group equal size student choose lesson day group convenient first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases descriptions $$$ t $$$ testcases follow first line testcase contain one integer $$$ n $$$ ( $$$ 2 \le n \le 1\,000 $$$ ) — number students $$$ i $$$ -th next $$$ n $$$ line contain $$$ 5 $$$ integers $$$ 0 $$$ $$$ 1 $$$ $$$ j $$$ -th integer $$$ 1 $$$ $$$ i $$$ -th student attend lessons $$$ j $$$ -th day week $$$ j $$$ -th integer $$$ 0 $$$ $$$ i $$$ -th student attend lessons $$$ j $$$ -th day week additional constraints input : student least one days week convenient total number students testcases n't exceed $$$ 100000 $$$ testcase print answer 's possible divide students two group equal size choose different days group student attend lesson choose day group print ` ` yes '' ( without quote ) otherwise print ` ` '' ( without quote ) first testcase a way meet constraints example first group consist first third students attend lessons thursday ( fourth day ) ; second group consist second fourth students attend lessons tuesday ( second day ) second testcase impossible divide students group attend lessons different days","['brute force', 'implementation']",1000.0
1598/F,a bracket sequence a string contain character ` ` ( ` ` ` ` ) '' a regular bracket sequence ( shortly rbs ) a bracket sequence transform a correct arithmetic expression insert character ` ` 1 '' ` ` + '' original character sequence example : let 's denote concatenation two string $$$ x $$$ $$$ y $$$ $$$ x+y $$$ example ` ` ( ) ( ) '' $$$ + $$$ ` ` ) ( ` ` $$$ = $$$ ` ` ( ) ( ) ) ( ` ` give $$$ n $$$ bracket sequence $$$ s_1 s_2 \dots s_n $$$ rearrange order ( rearrange string character ) task rearrange string a way string $$$ s_1 + s_2 + \dots + s_n $$$ many non - empty prefix rbs possible first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 20 $$$ ) $$$ n $$$ line follow $$$ i $$$ -th contain $$$ s_i $$$ — a bracket sequence ( a string consist character ` ` ( ` ` and/or ` ` ) '' sequence $$$ s_i $$$ non - empty total length exceed $$$ 400000 $$$ print one integer — maximum number non - empty prefix rbs string $$$ s_1 + s_2 + \dots + s_n $$$ string $$$ s_1 s_2 \dots s_n $$$ rearrange arbitrarily first example concatenate string follow : ` ` ( ` ` $$$ + $$$ ` ` ) '' $$$ = $$$ ` ` ( ) '' result string one prefix rbs : ` ` ( ) '' second example concatenate string follow : ` ` ( ` ` $$$ + $$$ ` ` ) '' $$$ + $$$ ` ` ( ) ( ) ( ) ) '' $$$ + $$$ ` ` ( ` ` $$$ = $$$ ` ` ( ) ( ) ( ) ( ) ) ( ` ` result string four prefix rbs : ` ` ( ) '' ` ` ( ) ( ) '' ` ` ( ) ( ) ( ) '' ` ` ( ) ( ) ( ) ( ) '' third fourth examples contain one string order fix,"['binary search', 'bitmasks', 'brute force', 'data structures', 'dp']",2400.0
16/D,"main server <unknown> company receive a log one top - secret process name ca n't reveal log write follow format : « [ date : time ] : message » « [ date : time ] » value exist 10 line file encode a complicate manner one programmer — alex — manage decode code complicate alex need four weeks decode right decode process finish file delete file deletion alex notice save record format « [ time ] : message » , information date lose however line add log chronological order 's difficult say record could appear one day possible also find minimum amount days log write , make mistake alex find minimum amount days cover log note alex n't find minimum amount days begin end log find minimum amount date record could do ( see sample test 2 clarifications ) remind process make 10 record a minute consider a midnight belong come day first input line contain number n ( 1 ≤ n ≤ 100 ) follow n line contain record format « [ time ] : message » time give format « hh : mm <unknown> . » hh two - digit number 01 12 use mm two - digit number 00 59 use x either character « a » character « p » a message a non - empty sequence latin letter and/or space n't start end a space length message n't exceed 20 . output one number — minimum amount days cover log formally 12 - hour time format describe :","['implementation', 'strings']",1900.0
160/B,"probably personal experience rid public transportation buy ticket a person buy a ticket ( traditionally even number digits ) usually check whether ticket lucky let us remind a ticket lucky sum digits first half match sum digits second half course every ticket lucky far ! moreover sometimes one look a ticket enough say right away ticket lucky , let 's consider follow unluckiness criterion definitely determine unlucky ticket 'll say a ticket definitely unlucky digit first half correspond digit second half digit first half strictly less correspond digit second one digit first half strictly correspond digit second one digit use exactly comparisons word bijective correspondence digits first second half ticket either digit first half turn strictly less correspond digit second half digit first half turn strictly correspond digit second half example ticket <unknown> meet follow unluckiness criterion consider lucky ( seek correspondence 2 > 1 4 > 2 ) ticket <unknown> also meet criterion ( seek correspondence 0 < 3 1 < 5 ) ticket <unknown> meet criterion a ticket hand contain 2n digits task check whether meet unluckiness criterion first line contain integer n ( 1 ≤ n ≤ 100 ) second line contain a string consist 2n digits define ticket first line print ` ` yes '' ticket meet unluckiness criterion otherwise print ` ` '' ( without quote )","['greedy', 'sortings']",1100.0
1602/A,give a string $$$ s $$$ need find two non - empty string $$$ a $$$ $$$ b $$$ follow condition satisfy : give string $$$ s $$$ print valid $$$ a $$$ $$$ b $$$ reminder : a string $$$ a $$$ ( $$$ b $$$ ) a subsequence a string $$$ s $$$ $$$ a $$$ ( $$$ b $$$ ) obtain $$$ s $$$ deletion several ( possibly zero ) elements example ` ` dores '' ` ` cf '' ` ` '' subsequences ` ` codeforces '' ` ` decor '' ` ` fork '' a string $$$ x $$$ lexicographically smaller a string $$$ y $$$ one follow hold : test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) description test case follow first line test case contain one string $$$ s $$$ ( $$$ 2 \le |s| \le 100 $$$ $$$ |s| $$$ mean length $$$ s $$$ ) string $$$ s $$$ consist lowercase latin letter test case print string $$$ a $$$ $$$ b $$$ satisfy give condition multiple answer print first test case two choices : either $$$ a = $$$ f $$$ b = $$$ c $$$ a = $$$ c $$$ b = $$$ f. $$$ a = $$$ c lexicographically smaller $$$ a = $$$ f. second test case a character string third test case prove b lexicographically smallest subsequence $$$ s $$$ second string two variants ; one give,['implementation'],800.0
1602/B,"black gift a divine array $$$ a $$$ consist $$$ n $$$ ( $$$ 1 \le n \le 2000 $$$ ) integers position $$$ a $$$ initial value shout a curse array become angry start <unknown> transformation transformation consist infinite step array $$$ a $$$ change $$$ i $$$ -th step follow way : every position $$$ j $$$ $$$ a_j $$$ become equal number occurrences $$$ a_j $$$ $$$ a $$$ start step example help understand process better : initial array two $$$ 2 $$$ -s three $$$ 1 $$$ -s one $$$ 4 $$$ one $$$ 3 $$$ first step element become equal number occurrences initial array : twos change $$$ 2 $$$ ones change $$$ 3 $$$ four change $$$ 1 $$$ three change $$$ 1 $$$ transformation step continue forever process $$$ q $$$ query : query black curious know value $$$ a_x $$$ $$$ k $$$ -th step transformation test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 2000 $$$ ) — size array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — initial value array $$$ a $$$ third line test case contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 100\,000 $$$ ) — number query next $$$ q $$$ line contain information query — one query per line $$$ i $$$ -th line contain two integers $$$ x_i $$$ $$$ k_i $$$ ( $$$ 1 \le x_i \le n $$$ ; $$$ 0 \le k_i \le 1000000000 $$$ ) mean black ask value $$$ a _ { x_i } $$$ $$$ k_i $$$ -th step transformation $$$ k_i = 0 $$$ mean black interest value initial array guarantee sum $$$ n $$$ test case n't exceed $$$ 2000 $$$ sum $$$ q $$$ test case n't exceed $$$ 100\,000 $$$ test case print $$$ q $$$ answer $$$ i $$$ -th value $$$ a _ { x_i } $$$ $$$ k_i $$$ -th step transformation show answer query unique first test case describe ih statement see : second test case initial array : $$$ 1 $$$ $$$ 1 $$$ $$$ 1 $$$ -st step : $$$ 2 $$$ $$$ 2 $$$ $$$ 2 $$$ -nd step : $$$ 2 $$$ $$$ 2 $$$ ...... see :",['implementation'],1100.0
1603/E,"a sequence integers $$$ b_1 b_2 \ldots b_m $$$ call good $$$ max ( b_1 b_2 \ldots b_m ) \cdot min ( b_1 b_2 \ldots b_m ) \ge b_1 + b_2 + \ldots + b_m $$$ a sequence integers $$$ a_1 a_2 \ldots a_n $$$ call perfect every non - empty subsequence $$$ a $$$ good youkn0wwho two integers $$$ n $$$ $$$ m $$$ $$$ m $$$ prime help find number modulo $$$ m $$$ perfect sequence $$$ a_1 a_2 \ldots a_n $$$ $$$ 1 \le a_i \le n + 1 $$$ integer $$$ i $$$ $$$ 1 $$$ $$$ n $$$ a sequence $$$ d $$$ a subsequence a sequence $$$ c $$$ $$$ d $$$ obtain $$$ c $$$ deletion several ( possibly zero ) elements first line input contain two space - separated integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 200 $$$ ; $$$ 100000000 \le m \le 1000000000 $$$ ) guarantee $$$ m $$$ prime print a single integer — number perfect sequence modulo $$$ m $$$ first test case perfect sequence $$$ [ 2 2 ] $$$ $$$ [ 2 3 ] $$$ $$$ [ 3 2 ] $$$ $$$ [ 3 3 ] $$$ second test case perfect sequence $$$ [ 3 4 3 5 ] $$$ $$$ [ 4 5 4 4 ] $$$ $$$ [ 4 5 5 5 ] $$$ etc one example a sequence perfect $$$ [ 2 3 3 4 ] $$$ , example subsequence $$$ [ 2 3 4 ] $$$ good $$$ 8 < 2 + 3 + 4 $$$","['combinatorics', 'dp', 'math']",3200.0
1603/F,"october 18 2017 . shohag a <unknown> soul make a strong determination pursue competitive program seriously heart find fascinate fast forward 4 years happy take road create a contest codeforces find astound problem idea solve help solve final problem round give three integers $$$ n $$$ $$$ k $$$ $$$ x $$$ find number modulo $$$ 998\,244\,353 $$$ integer sequence $$$ a_1 a_2 \ldots a_n $$$ follow condition satisfy : a sequence $$$ b $$$ a subsequence a sequence $$$ c $$$ $$$ b $$$ obtain $$$ c $$$ deletion several ( possibly zero ) elements first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case first line test case contain three space - separated integers $$$ n $$$ $$$ k $$$ $$$ x $$$ ( $$$ 1 \le n \le 1000000000 $$$ $$$ 0 \le k \le 10000000 $$$ $$$ 0 \le x \lt 2^ { \operatorname { min } ( 20 k ) } $$$ ) guarantee sum $$$ k $$$ test case exceed $$$ <unknown> $$$ test case print a single integer — answer problem first test case valid sequence $$$ [ 1 2 ] $$$ $$$ [ 1 3 ] $$$ $$$ [ 2 1 ] $$$ $$$ [ 2 3 ] $$$ $$$ [ 3 1 ] $$$ $$$ [ 3 2 ] $$$ second test case valid sequence $$$ [ 0 0 ] $$$","['combinatorics', 'dp', 'implementation', 'math']",2700.0
1605/B,ashish a binary string $$$ s $$$ length $$$ n $$$ want sort non - decreasing order perform follow operation : find minimum number operations require sort string non - decreasing order prove always possible sort give binary string $$$ n $$$ operations first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 1000 ) $$$ — number test case description test case follow first line test case contain integer $$$ n $$$ $$$ ( 1 \le n \le 1000 ) $$$ — length binary string $$$ s $$$ second line test case contain a binary string $$$ s $$$ length $$$ n $$$ contain $$$ 0 $$$ s $$$ 1 $$$ s. guarantee sum $$$ n $$$ test case exceed $$$ 1000 $$$ test case output follow : first test case binary string already sort non - decreasing order second test case perform follow operation : $$$ \underline { 1 } $$$ $$$ 0 $$$ $$$ \underline { 1 } $$$ $$$ \underline { 0 } $$$ $$$ \underline { 0 } $$$ $$$ \rightarrow $$$ $$$ \underline { 0 } $$$ $$$ 0 $$$ $$$ \underline { 0 } $$$ $$$ \underline { 1 } $$$ $$$ \underline { 1 } $$$ third test case perform follow operation : $$$ 0 $$$ $$$ 0 $$$ $$$ \underline { 1 } $$$ $$$ 0 $$$ $$$ \underline { 0 } $$$ $$$ \underline { 0 } $$$ $$$ \rightarrow $$$ $$$ 0 $$$ $$$ 0 $$$ $$$ \underline { 0 } $$$ $$$ 0 $$$ $$$ \underline { 0 } $$$ $$$ \underline { 1 } $$$,"['greedy', 'sortings']",1000.0
1605/F,integer array $$$ a $$$ length $$$ n $$$ say a palindorme ( $$$ a _ { 1 } $$$ $$$ | $$$ $$$ a _ { 2 } $$$ $$$ | $$$ $$$ \ldots $$$ $$$ | $$$ $$$ a _ { i } ) = ( a _ { { n - i + 1 } } $$$ $$$ | $$$ $$$ \ldots $$$ $$$ | $$$ $$$ a _ { { n - 1 } } $$$ $$$ | $$$ $$$ a _ { n } ) $$$ $$$ 1 \leq i \leq n $$$ $$$ | $$$ denote bitwise operation integer array $$$ a $$$ length $$$ n $$$ consider good elements rearrange form a palindorme formally array $$$ a $$$ good exist a permutation $$$ p_1 p_2 \ldots p_n $$$ ( array integer $$$ 1 $$$ $$$ n $$$ appear exactly ) $$$ a _ { p_1 } a _ { p_2 } \ldots a _ { p_n } $$$ a palindorme find number good array length $$$ n $$$ consist integers range $$$ [ 0 2^ { k } - 1 ] $$$ print modulo prime $$$ m $$$ two array $$$ a_1 a_2 \ldots a_n $$$ $$$ b_1 b_2 \ldots b_n $$$ consider different exist $$$ i $$$ $$$ ( 1 \leq i \leq n ) $$$ $$$ a_i \ne b_i $$$ first line input contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \leq n k \leq 80 $$$ $$$ 100000000 \lt m \lt 1000000000 $$$ ) guarantee $$$ m $$$ prime print a single integer — number good array modulo $$$ m $$$ first sample possible array $$$ [ 0 ] $$$ $$$ [ 1 ] $$$ good second sample examples good array : note $$$ [ 1 1 0 ] $$$ $$$ [ 1 0 1 ] $$$ $$$ [ 0 1 1 ] $$$ good array consider different accord definition statement third sample example a good array $$$ [ 1 0 1 4 2 5 4 ] $$$ rearrange array $$$ b = [ 1 5 0 2 4 4 1 ] $$$ a palindorme : $$$ \mathrm { } ( l r ) $$$ denote $$$ b _ { l } $$$ $$$ | $$$ $$$ b _ { l+1 } $$$ $$$ | $$$ $$$ \ldots $$$ $$$ | $$$ $$$ b _ { r } $$$,"['combinatorics', 'dp']",2900.0
1607/A,give a keyboard consist $$$ 26 $$$ key key arrange sequentially one row a certain order key correspond a unique lowercase latin letter type word $$$ s $$$ keyboard also consist lowercase latin letter type a word need type letter consecutively one one type letter must position hand exactly correspond key press move hand key take time equal absolute value difference position key ( key number leave right ) time spend press key place hand first letter word example consider a keyboard letter ' a ' ' z ' arrange consecutive alphabetical order letter ' h ' ' e ' ' l ' ' o ' position $$$ 8 $$$ $$$ 5 $$$ $$$ 12 $$$ $$$ 15 $$$ respectively therefore take $$$ |5 - 8| + |12 - 5| + |12 - 12| + <unknown> - 12| = 13 $$$ units time type word ` ` hello '' determine long take print word $$$ s $$$ first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case next $$$ 2 t $$$ line contain descriptions test case first line a description contain a keyboard — a string length $$$ 26 $$$ consist lowercase latin letter letter ' a ' ' z ' appear exactly keyboard second line description contain word $$$ s $$$ word a length $$$ 1 $$$ $$$ 50 $$$ letter inclusive consist lowercase latin letter print $$$ t $$$ line line contain answer correspond test case answer test case minimal time take type word $$$ s $$$ give keyboard,"['implementation', 'strings']",800.0
1609/A,william array $$$ n $$$ number $$$ a_1 a_2 \dots a_n $$$ perform follow sequence operations number time : help william find maximal sum array elements get perform sequence operations describe test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain integer $$$ n $$$ $$$ ( 1 \le n \le 15 ) $$$ number elements william 's array second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ $$$ ( 1 \le a_i < 16 ) $$$ content william 's array test case output maximal sum array elements perform optimal sequence operations first example test case optimal sequence would : final answer $$$ 48 + 1 + 1 = 50 $$$ third example test case way change sum elements answer $$$ 10 $$$,"['greedy', 'implementation', 'math', 'number theory']",900.0
1609/C,"perform complex market analysis william encounter follow problem : a give array $$$ a $$$ size $$$ n $$$ a natural number $$$ e $$$ calculate number pair natural number $$$ ( i k ) $$$ satisfy follow condition : a prime number ( a prime ) a natural number greater 1 a product two smaller natural number test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10\,000 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ e $$$ $$$ ( 1 \le e \le n \le 2 \cdot 100000 ) $$$ number items array number $$$ e $$$ respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ $$$ ( 1 \le a_i \le 1000000 ) $$$ content array guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output answer follow format : output one line contain number pair number $$$ ( i k ) $$$ satisfy condition first example test case two pair satisfy condition : second example test case pair satisfy condition third example test case four pair satisfy condition : fourth example test case pair satisfy condition fifth example test case five pair satisfy condition : sixth example test case pair satisfy condition","['binary search', 'dp', 'implementation', 'number theory', 'two pointers']",1400.0
161/D,a tree a connect graph n't contain cycle distance two vertices a tree length ( edge ) shortest path vertices give a tree n vertices a positive number k. find number distinct pair vertices a distance exactly k note pair ( v u ) ( u v ) consider pair first line contain two integers n k ( 1 ≤ n ≤ 50000 1 ≤ k ≤ 500 ) — number vertices require distance vertices next n - 1 line describe edge ` ` ai bi '' ( without quote ) ( 1 ≤ ai bi ≤ n ai ≠ bi ) ai bi vertices connect i - th edge give edge different print a single integer — number distinct pair tree 's vertices a distance exactly k please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first sample pair vertexes distance 2 ( 1 3 ) ( 1 5 ) ( 3 5 ) ( 2 4 ),"['dfs and similar', 'dp', 'trees']",1800.0
1612/D,give a pair integers $$$ ( a b ) $$$ integer $$$ x $$$ change pair two different ways : pair $$$ ( a b ) $$$ call $$$ x $$$ -magic $$$ x $$$ obtainable either $$$ a $$$ $$$ b $$$ use give operations ( i.e pair $$$ ( a b ) $$$ $$$ x $$$ -magic $$$ a = x $$$ $$$ b = x $$$ number operations apply ) apply operations number time ( even zero ) task find pair $$$ ( a b ) $$$ $$$ x $$$ -magic answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case next $$$ t $$$ line describe test case line test case contain three integers $$$ a $$$ $$$ b $$$ $$$ x $$$ ( $$$ 1 \le a b x \le 10^ { 18 } $$$ ) $$$ i $$$ -th test case print yes correspond pair $$$ ( a b ) $$$ $$$ x $$$ -magic otherwise,"['math', 'number theory']",1600.0
1614/D1,easy version problem difference maximum value $$$ a_i $$$ kostomuksha divan find array $$$ a $$$ consist positive integers want reorder elements $$$ a $$$ maximize value follow function : $$$ $$$ \sum _ { i=1 } ^n \operatorname { gcd } ( a_1 \ a_2 \ \dots \ a_i ) $$$ $$$ $$$ \operatorname { gcd } ( x_1 x_2 \ldots x_k ) $$$ denote greatest common divisor integers $$$ x_1 x_2 \ldots x_k $$$ $$$ \operatorname { gcd } ( x ) = x $$$ integer $$$ x $$$ reorder elements array mean change order elements array arbitrary leave initial order course divan solve problem however find interest decide share first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — size array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a _ { 1 } \ a _ { 2 } \ \dots \ a _ { n } $$$ ( $$$ 1 \le a _ { i } \le 5000000 $$$ ) — array $$$ a $$$ output maximum value function get reorder elements array $$$ a $$$ first example 's optimal rearrange elements give array follow order : $$$ [ 6 \ 2 \ 2 \ 2 \ 3 \ 1 ] $$$ : $$$ $$$ \operatorname { gcd } ( a_1 ) + \operatorname { gcd } ( a_1 \ a_2 ) + \operatorname { gcd } ( a_1 \ a_2 \ a_3 ) + \operatorname { gcd } ( a_1 \ a_2 \ a_3 \ a_4 ) + \operatorname { gcd } ( a_1 \ a_2 \ a_3 \ a_4 \ a_5 ) + \operatorname { gcd } ( a_1 \ a_2 \ a_3 \ a_4 \ a_5 \ a_6 ) = 6 + 2 + 2 + 2 + 1 + 1 = 14 $$$ $$$ show impossible get a better answer second example 's optimal rearrange elements a give array follow order : $$$ [ 100 \ 10 \ 10 \ 5 \ 1 \ 3 \ 3 \ 7 \ 42 \ 54 ] $$$,"['dp', 'number theory']",2100.0
1614/E,"divan 's new cottage finally complete ! however a thorough inspection turn workers instal insulation incorrectly temperature house directly depend temperature outside precisely temperature house $$$ p $$$ morning street temperature $$$ t $$$ next morning temperature house change accord follow rule : divan a busy businessman sometimes home long periods know temperature hire find work $$$ n $$$ days begin $$$ i $$$ -th day temperature outside $$$ t_i $$$ first give , $$$ i $$$ -th day receive $$$ k_i $$$ query query ask follow : ` ` temperature house $$$ x_i $$$ morning first day would temperature house next morning ( day $$$ i $$$ ) ? ` ` please answer businessman 's query first line input contain number $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — number days follow a description $$$ n $$$ days follow format first line description contain integer $$$ t_i $$$ ( $$$ 0 \leq t_i \leq 1000000000 $$$ ) — temperature day second line contain a non - negative integer $$$ k_i $$$ ( $$$ 0 \le k_i \le 200000 $$$ ) — number query day third line contain $$$ k $$$ integers $$$ x'_i $$$ ( $$$ 0 \leq x ' _ { i } \leq 1000000000 $$$ ) — encrypt version divan 's query let $$$ lastans = 0 $$$ initially divan 's actual query give $$$ x_i = ( x'_i + lastans ) \bmod ( 1000000000 + 1 ) $$$ $$$ a \bmod b $$$ reminder $$$ a $$$ divide $$$ b $$$ answer query set $$$ lastans $$$ answer guarantee total number query ( sum $$$ k_i $$$ ) exceed $$$ 200000 $$$ query output a single integer — temperature house day $$$ i $$$ let 's look first four query example input temperature $$$ 50 $$$ first day $$$ 50 $$$ second day $$$ 0 $$$ third day note $$$ lastans = 0 $$$ initially","['binary search', 'data structures']",2600.0
1615/A,$$$ n $$$ block tower a row tower $$$ i $$$ a height $$$ a_i $$$ 're part a build crew want make build look nice possible a single day perform follow operation : think ugliness build height difference tallest shortest build formally ugliness define $$$ \max ( a ) -\min ( a ) $$$ 's minimum possible ugliness achieve number days ? first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case $$$ t $$$ case follow first line test case contain one integer $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) — number build second line test case contain $$$ n $$$ space separate integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 10000000 $$$ ) — heights build test case output a single integer — minimum possible ugliness build first test case ugliness already $$$ 0 $$$ second test case one operation $$$ i = 1 $$$ $$$ j = 3 $$$ new heights $$$ [ 2 2 2 2 ] $$$ ugliness $$$ 0 $$$ third test case may three operations :,"['greedy', 'math']",800.0
1615/C,"$$$ n $$$ candle a <unknown> <unknown> candle initially light describe candle light a binary string $$$ s $$$ $$$ i $$$ -th candle light $$$ s_i=1 $$$ initially candle light describe a string $$$ a $$$ operation select a candle currently light , candle select remain light every candle change ( light become unlit unlit become light ) would like make candle look string $$$ b $$$ task determine possible , find minimum number operations require first line contain integer $$$ t $$$ ( $$$ 1\le t\le 10000 $$$ ) — number test case $$$ t $$$ case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1\le n\le 100000 $$$ ) — number candle second line contain a string $$$ a $$$ length $$$ n $$$ consist symbols 0 1 — initial pattern light third line contain a string $$$ b $$$ length $$$ n $$$ consist symbols 0 1 — desire pattern light guarantee sum $$$ n $$$ exceed $$$ 100000 $$$ test case output minimum number operations require transform $$$ a $$$ $$$ b $$$ $$$ -1 $$$ 's impossible first test case two string already equal n't perform operations second test case perform a single operation select second candle transform $$$ 01 $$$ $$$ 11 $$$ third test case 's impossible perform operations light candle select fourth test case perform follow operations transform $$$ a $$$ $$$ b $$$ : fifth test case perform follow operations transform $$$ a $$$ $$$ b $$$ :","['brute force', 'graphs', 'greedy', 'math']",1600.0
1615/D,"' t night christmas santa 's frantically set new christmas tree ! $$$ n $$$ nod tree connect $$$ n-1 $$$ edge edge tree 's a set christmas light represent integer binary representation $$$ m $$$ elves come admire tree elf assign two nod $$$ a $$$ $$$ b $$$ elf look light simple path two nod , elf 's favorite number become bitwise xor value light edge path however north pole recover a nasty bout flu , santa forget configurations light put tree already leave north pole ! fortunately elves come rescue one tell santa pair nod assign $$$ ( a_i b_i ) $$$ well parity number set bits favorite number word remember whether number $$$ 1 $$$ 's favorite number write binary odd even help santa determine 's possible memories consistent , remember tree look like maybe 'll go history ! first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 20000 $$$ ) — number test case $$$ t $$$ case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 200000 $$$ ; $$$ 1 \leq m \leq 200000 $$$ ) — size tree number elves respectively next $$$ n-1 $$$ line test case contain three integers $$$ x $$$ $$$ y $$$ $$$ v $$$ ( $$$ 1 \leq x y \leq n $$$ ; $$$ -1 \leq v < 2^ { 30 } $$$ ) — mean 's edge nod $$$ x $$$ $$$ y $$$ next $$$ m $$$ line test case contain three integers $$$ a $$$ $$$ b $$$ $$$ p $$$ ( $$$ 1 \leq a b \leq n $$$ ; $$$ a \neq b $$$ ; $$$ 0 \leq p \leq 1 $$$ ) — nod elf assign parity number set bits elf 's favorite number guarantee sum $$$ n $$$ sum $$$ m $$$ n't exceed $$$ 200000 $$$ guarantee give edge form a tree test case first print either yes ( case ) whether 's a tree consistent santa 's memory answer yes print $$$ n-1 $$$ line contain three integers : $$$ x $$$ $$$ y $$$ $$$ v $$$ ( $$$ 1 \le x y \le n $$$ ; $$$ 0 \le v < 2^ { 30 } $$$ ) — edge integer edge set edge must input value edge specify earlier change print edge order multiple answer print first test case image statement one possible answer assign value edge $$$ ( 1 2 ) $$$ $$$ 5 $$$ value edge $$$ ( 2 5 ) $$$ $$$ 3 $$$ correct : note possible answer","['bitmasks', 'dfs and similar', 'dsu', 'graphs', 'trees']",2200.0
1616/D,"give array integers $$$ a_1 a_2 \ldots a_n $$$ integer $$$ x $$$ need select maximum number elements array every subsegment $$$ a_l a _ { l + 1 } \ldots a_r $$$ contain strictly one element $$$ ( l < r ) $$$ either : first line input contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 10 $$$ ) : number test case descriptions $$$ t $$$ test case follow three line per test case first line give one integer $$$ n $$$ ( $$$ 1 \leq n \leq 50\,000 $$$ ) : number integers array second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -100\,000 \leq a_i \leq 100\,000 $$$ ) third line contain one integer $$$ x $$$ ( $$$ -100\,000 \leq x \leq 100\,000 $$$ ) test case print one integer : maximum number elements select first example one valid way select elements $$$ [ \underline { 1 } 2 \underline { 3 } \underline { 4 } \underline { 5 } ] $$$ subsegments satisfy least one criteria example subsegment $$$ l = 1 $$$ $$$ r = 2 $$$ element $$$ 2 $$$ select satisfy first criterion subsegment $$$ l = 3 $$$ $$$ r = 5 $$$ $$$ 3 + 4 + 5 = 12 \ge 6 $$$ satisfy second criterion ca n't select elements case $$$ l = 1 $$$ $$$ r = 2 $$$ elements select $$$ a_1 + a_2 = 3 < 4 $$$ thus maximum number select elements $$$ 4 $$$ second example one valid solution $$$ [ \underline { 2 } \underline { 4 } 2 \underline { 4 } \underline { 2 } \underline { 4 } 2 \underline { 4 } \underline { 2 } \underline { 4 } ] $$$ third example one valid solution $$$ [ \underline { -10 } -5 \underline { -10 } ] $$$ fourth example one valid solution $$$ [ \underline { 9 } \underline { 9 } -3 ] $$$","['dp', 'greedy', 'math']",2000.0
1617/B,give a positive integer $$$ n $$$ find three distinct positive integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ a + b + c = n $$$ $$$ \operatorname { gcd } ( a b ) = c $$$ $$$ \operatorname { gcd } ( x y ) $$$ denote greatest common divisor ( gcd ) integers $$$ x $$$ $$$ y $$$ input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 10 \le n \le 1000000000 $$$ ) test case output three distinct positive integers $$$ a $$$ $$$ b $$$ $$$ c $$$ satisfy requirements multiple solutions print show answer always exist first test case $$$ 6 + 9 + 3 = 18 $$$ $$$ \operatorname { gcd } ( 6 9 ) = 3 $$$ second test case $$$ 21 + 39 + 3 = 63 $$$ $$$ \operatorname { gcd } ( 21 39 ) = 3 $$$ third test case $$$ 29 + 43 + 1 = 73 $$$ $$$ \operatorname { gcd } ( 29 43 ) = 1 $$$,"['brute force', 'math', 'number theory']",900.0
1617/E,christmas come icy receive a box chocolates grandparents ! box contain $$$ n $$$ chocolates $$$ i $$$ -th chocolate a non - negative integer type $$$ a_i $$$ icy believe good things come pair unfortunately type chocolates distinct ( $$$ a_i $$$ distinct ) icy want make least one pair chocolates type a result ask grandparents perform chocolate exchange perform chocolate exchange icy choose two chocolates indices $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ $$$ x \ne y $$$ ) a chocolate exchange icy 's grandparents choose a non - negative integer $$$ k $$$ $$$ 2^k \ge a_x $$$ change type chocolate $$$ x $$$ $$$ a_x $$$ $$$ 2^k - a_x $$$ ( perform $$$ a_x : = 2^k - a_x $$$ ) chocolate exchange stop $$$ a_x = a_y $$$ note pair equal chocolate type stop procedure icy 's grandparents smart would choose sequence chocolate exchange minimize number exchange need since icy like cause trouble want maximize minimum number exchange need choose $$$ x $$$ $$$ y $$$ appropriately wonder optimal pair $$$ ( x y ) $$$ minimum number exchange need maximize across possible choices $$$ ( x y ) $$$ since icy good math hop help solve problem first line input contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number chocolates second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) guarantee $$$ a_i $$$ distinct output three integers $$$ x $$$ $$$ y $$$ $$$ m $$$ $$$ x $$$ $$$ y $$$ indices optimal chocolates perform exchange output must satisfy $$$ 1 \le x y \le n $$$ $$$ x \ne y $$$ $$$ m $$$ number exchange need obtain $$$ a_x = a_y $$$ show $$$ m \le 1000000000 $$$ pair chocolates multiple solutions output first test case minimum number exchange need exchange a chocolate type $$$ 6 $$$ a chocolate type $$$ 9 $$$ $$$ 5 $$$ sequence exchange follow : $$$ 6 \rightarrow 2 \rightarrow 0 \rightarrow 1 \rightarrow 7 \rightarrow 9 $$$ second test case minimum number exchange need exchange a chocolate type $$$ 4 $$$ a chocolate type $$$ 8 $$$ $$$ 2 $$$ sequence exchange follow : $$$ 4 \rightarrow 0 \rightarrow 8 $$$,"['dfs and similar', 'dp', 'graphs', 'implementation', 'math', 'number theory', 'shortest paths', 'trees']",2700.0
1618/D,give array $$$ a $$$ $$$ n $$$ integers another integer $$$ k $$$ $$$ 2k \le n $$$ perform exactly $$$ k $$$ operations array one operation choose two elements array ( let $$$ a_i $$$ $$$ a_j $$$ ; equal different position array must ) remove array add $$$ \lfloor \frac { a_i } { a_j } \rfloor $$$ score $$$ \lfloor \frac { x } { y } \rfloor $$$ maximum integer exceed $$$ \frac { x } { y } $$$ initially score $$$ 0 $$$ perform exactly $$$ k $$$ operations add remain elements array score calculate minimum possible score get first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case test case consist two line first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100 $$$ ; $$$ 0 \le k \le \lfloor \frac { n } { 2 } \rfloor $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 200000 $$$ ) print one integer — minimum possible score get let 's consider example test first test case one way obtain a score $$$ 2 $$$ follow one : second test case matter operations choose result score $$$ 16 $$$ third test case one way obtain a score $$$ 0 $$$ follow one : fourth test case operations perform score sum elements array : $$$ 4 + 2 = 6 $$$,"['dp', 'greedy', 'math']",1300.0
1618/G,monocarp play a computer game ( yet ! ) game a unique trade mechanics trade a character monocarp choose one items possess trade item character possess item integer price monocarp 's choose item price $$$ x $$$ trade item ( exactly one item ) price greater $$$ x+k $$$ monocarp initially $$$ n $$$ items price $$$ i $$$ -th item $$$ a_i $$$ character monocarp trade $$$ m $$$ items price $$$ i $$$ -th item $$$ b_i $$$ monocarp trade character many time want ( possibly even zero time ) time exchange one items one character 's items accord aforementioned constraints note monocarp get item exchange trade another item ( since item belong ) vice versa : monocarp trade one items another item get item back trade something answer $$$ q $$$ query query consist one integer value $$$ k $$$ ask calculate maximum possible total cost items monocarp sequence trade assume trade item cost $$$ x $$$ item cost greater $$$ x+k $$$ trade note query independent : trade actually occur monocarp want calculate maximum total cost get first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \le n m q \le 200000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — price items monocarp third line contain $$$ m $$$ integers $$$ b_1 b_2 \dots b_m $$$ ( $$$ 1 \le b_i \le 1000000000 $$$ ) — price items character fourth line contain $$$ q $$$ integers $$$ i $$$ -th integer value $$$ k $$$ $$$ i $$$ -th query ( $$$ 0 \le k \le 1000000000 $$$ ) query print one integer — maximum possible total cost items monocarp sequence trade give value $$$ k $$$ query,"['data structures', 'dsu', 'greedy', 'sortings']",2200.0
1619/E,dmitry array $$$ n $$$ non - negative integers $$$ a_1 a_2 \dots a_n $$$ one operation dmitry choose index $$$ j $$$ ( $$$ 1 \le j \le n $$$ ) increase value element $$$ a_j $$$ $$$ 1 $$$ choose index $$$ j $$$ multiple time $$$ i $$$ $$$ 0 $$$ $$$ n $$$ determine whether dmitry make $$$ \mathrm { mex } $$$ array equal exactly $$$ i $$$ possible determine minimum number operations $$$ \mathrm { mex } $$$ array equal minimum non - negative integer array example $$$ \mathrm { mex } $$$ array $$$ [ 3 1 0 ] $$$ equal $$$ 2 $$$ array $$$ [ 3 3 1 4 ] $$$ equal $$$ 0 $$$ first line input data contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case input descriptions test case follow first line description test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length array $$$ a $$$ second line description test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le n $$$ ) — elements array $$$ a $$$ guarantee sum value $$$ n $$$ test case test exceed $$$ 2\cdot100000 $$$ test case output $$$ n + 1 $$$ integer — $$$ i $$$ -th number equal minimum number operations make array $$$ \mathrm { mex } $$$ equal $$$ i $$$ ( $$$ 0 \le i \le n $$$ ) -1 do first set example input $$$ n=3 $$$ :,"['data structures', 'dp', 'greedy', 'implementation', 'math', 'sortings']",1700.0
1620/B,"a rectangle opposite corner $$$ ( 0 0 ) $$$ $$$ ( w h ) $$$ side parallel ax draw a plane give a list lattice point point lie a side a rectangle corner also least two point every side a rectangle task choose three point a way : print double area triangle show double area triangle form lattice point always integer first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain two integers $$$ w $$$ $$$ h $$$ ( $$$ 3 \le w h \le 1000000 $$$ ) — coordinate corner a rectangle next two line contain description point two horizontal side first integer $$$ k $$$ ( $$$ 2 \le k \le 200000 $$$ ) — number point , $$$ k $$$ integers $$$ x_1 < x_2 < \dots < x_k $$$ ( $$$ 0 < x_i < w $$$ ) — $$$ x $$$ coordinate point ascend order $$$ y $$$ coordinate first line $$$ 0 $$$ second line $$$ h $$$ next two line contain description point two vertical side first integer $$$ k $$$ ( $$$ 2 \le k \le 200000 $$$ ) — number point , $$$ k $$$ integers $$$ y_1 < y_2 < \dots < y_k $$$ ( $$$ 0 < y_i < h $$$ ) — $$$ y $$$ coordinate point ascend order $$$ x $$$ coordinate first line $$$ 0 $$$ second line $$$ w $$$ total number point side testcases n't exceed $$$ 200000 $$$ testcase print a single integer — double maximum area a triangle form three point exactly two belong side point first testcase example : largest triangle form point $$$ ( 0 1 ) $$$ $$$ ( 0 6 ) $$$ $$$ ( 5 4 ) $$$ — area $$$ \frac { 25 } { 2 } $$$ thus double area $$$ 25 $$$ two point side : $$$ ( 0 1 ) $$$ $$$ ( 0 6 ) $$$","['geometry', 'greedy', 'math']",1000.0
1620/C,give integer $$$ k $$$ a string $$$ s $$$ consist character ' a ' ( a lowercase latin letter ) ' * ' ( asterisk ) asterisk replace several ( $$$ 0 $$$ $$$ k $$$ inclusive ) lowercase latin letter ' b ' different asterisk replace different count letter ' b ' result replacement call a ba - string two string $$$ a $$$ $$$ b $$$ different either different lengths exist a position $$$ i $$$ $$$ a_i \neq b_i $$$ a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ one follow hold : consider different ba - strings find $$$ x $$$ -th lexicographically smallest first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 2000 $$$ ) — number testcases first line testcase contain three integers $$$ n $$$ $$$ k $$$ $$$ x $$$ ( $$$ 1 \le n \le 2000 $$$ ; $$$ 0 \le k \le 2000 $$$ ; $$$ 1 \le x \le 10^ { 18 } $$$ ) $$$ n $$$ length string $$$ s $$$ second line testcase a string $$$ s $$$ consist $$$ n $$$ character either ' a ' ( a lowercase latin letter ) ' * ' ( asterisk ) sum $$$ n $$$ testcases n't exceed $$$ 2000 $$$ testcase $$$ x $$$ n't exceed total number different ba - strings string $$$ s $$$ contain least one character ' a ' testcase print a single string consist character ' b ' ' a ' ( lowercase latin letter ) — $$$ x $$$ -th lexicographically smallest ba - string first testcase example ba - strings order lexicographically : second testcase example ba - strings order lexicographically : note string ` ` aba '' count even though two ways replace asterisk character ' b ' get,"['brute force', 'dp', 'greedy', 'implementation', 'math']",1800.0
1620/D,"one day early morning decide buy a bag chip nearby store store chip $$$ n $$$ different flavor a bag $$$ i $$$ -th flavor cost $$$ a_i $$$ burl store may run flavor 'll decide one buy arrive two major flaw plan : coin heavy 'd like take least possible number coin total 's wonder : minimum total number coin take buy a bag chip flavor exact change ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number flavor store second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — cost one bag flavor test case print one integer — minimum number coin need buy one bag flavor 'll choose exact change first test case , example take $$$ <unknown> $$$ coin value $$$ 3 $$$ $$$ 1 $$$ coin value $$$ 2 $$$ , $$$ 1337 = <unknown> + 2 $$$ second test case , example take $$$ 2 $$$ coin value $$$ 3 $$$ $$$ 2 $$$ coin value $$$ 2 $$$ pay either exactly $$$ 8 = 6 + 2 $$$ $$$ 10 = 6 + 4 $$$ third test case 's enough take $$$ 1 $$$ coin value $$$ 3 $$$ $$$ 2 $$$ coin value $$$ 1 $$$","['brute force', 'greedy']",2000.0
1621/C,"interactive problem jury a permutation $$$ p $$$ length $$$ n $$$ want guess , jury create another permutation $$$ q $$$ length $$$ n $$$ initially $$$ q $$$ identity permutation ( $$$ q_i = i $$$ $$$ i $$$ ) ask query get $$$ q_i $$$ $$$ i $$$ want query jury change $$$ q $$$ follow way : make $$$ 2n $$$ query order <unknown> $$$ p $$$ first line input contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case interaction test case start read single integer $$$ n $$$ ( $$$ 1 \leq n \leq 10000 $$$ ) — length permutations $$$ p $$$ $$$ q $$$ get value $$$ q_i $$$ output query format $$$ ? $$$ $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) receive value $$$ q_i $$$ make $$$ 2n $$$ query incorrect query receive $$$ 0 $$$ exit immediately get wrong answer verdict ready determine $$$ p $$$ output $$$ p $$$ format $$$ ! $$$ $$$ p_1 $$$ $$$ p_2 $$$ $$$ \ldots $$$ $$$ p_n $$$ go next test case exit last test case print permutation count one $$$ 2n $$$ query print a query forget output end line flush output otherwise get idleness limit exceed , use : guarantee sum $$$ n $$$ test case n't exceed $$$ 10000 $$$ interactor adaptive problem hack : hack use follow format : first line contain single integer $$$ t $$$ — number test case first line test case contain single integer $$$ n $$$ — length permutations $$$ p $$$ $$$ q $$$ second line test case contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ — hide permutation test case first test case hide permutation $$$ p = [ 4 2 1 3 ] $$$ first query $$$ q = [ 1 2 3 4 ] $$$ answer query $$$ q_3 = 3 $$$ second query $$$ q = [ 4 2 1 3 ] $$$ answer query $$$ q_2 = 2 $$$ third query $$$ q = [ 3 2 4 1 ] $$$ answer query $$$ q_4 = 1 $$$ second test case hide permutation $$$ p = [ 1 3 4 2 ] $$$ empty string give better readability empty line test system","['dfs and similar', 'math']",1700.0
1621/E,"decide open a new school already find $$$ n $$$ teachers $$$ m $$$ group students $$$ i $$$ -th group students consist $$$ k_i \geq 2 $$$ students know age teacher student age teachers $$$ a_1 a_2 \ldots a_n $$$ age students $$$ i $$$ -th group $$$ b _ { i 1 } b _ { i 2 } \ldots b _ { i k_i } $$$ start lessons assign teacher group students assignment satisfy follow requirements : average set $$$ x_1 x_2 \ldots x_k $$$ $$$ k $$$ integers $$$ \frac { x_1 + x_2 + \ldots + x_k } { k } $$$ recently hear one students refuse study school , size one group decrease $$$ 1 $$$ group remain unchanged n't know refuse study student determine start lessons case refusal note guarantee possible start lessons refusal first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq m \leq n \leq 100000 $$$ ) — number teachers number group students second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 100000 $$$ ) — age teachers next $$$ 2 m $$$ line contain descriptions group first line description group contain a single integer $$$ k_i $$$ ( $$$ 2 \leq k_i \leq 100000 $$$ ) — number students group second line description group contain $$$ k_i $$$ integers $$$ b _ { i 1 } b _ { i 2 } \ldots b _ { i k_i } $$$ ( $$$ 1 \leq b _ { i j } \leq 100000 $$$ ) — age students group guarantee total sum $$$ n $$$ test case n't exceed $$$ 100000 $$$ total sum $$$ k_1 + k_2 + \ldots + k_m $$$ test case n't exceed $$$ 200000 $$$ test case output string symbols $$$ 0 $$$ $$$ 1 $$$ length $$$ k_1 + k_2 + \ldots + k_m $$$ $$$ i $$$ -th symbol string equal $$$ 1 $$$ possible start lessons case $$$ i $$$ -th student refuse equal $$$ 0 $$$ otherwise students number integers $$$ 1 $$$ $$$ k_1 + k_2 + \ldots + k_m $$$ order appear input thus students $$$ 1 $$$ -st group number integers $$$ 1 $$$ $$$ 2 $$$ $$$ \ldots $$$ $$$ k_1 $$$ students $$$ 2 $$$ -nd group number integers $$$ k_1 + 1 $$$ $$$ k_1 + 2 $$$ $$$ \ldots $$$ $$$ k_1 + k_2 $$$ first test case one group students average age $$$ \frac { 25 + 16 + 37 } { 3 } = 26 $$$ one teacher age $$$ 30 $$$ exist one assignment allow start lessons student age $$$ 16 $$$ refuse study average age students group become $$$ \frac { 25 + 37 } { 2 } = 31 $$$ wo n't assignment allow start lessons second test case impossible start lessons initially however $$$ 3 $$$ -rd student age $$$ 111 $$$ refuse study average age group become $$$ \frac { 4 + 5 } { 2 } = 4.5 $$$ $$$ \frac { 11 + 11 } { 2 } = 11 $$$ correspondingly possible <unknown> first group first teacher second group third teacher","['binary search', 'data structures', 'dp', 'greedy', 'implementation', 'sortings']",2300.0
1621/F,dasha $$$ 10^ { 100 } $$$ coin recently find a binary string $$$ s $$$ length $$$ n $$$ operations allow change string ( operation number time ) : turn operations dasha follow rule : please calculate maximum profit dasha get operations follow rule first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case first line test case contain four integers $$$ n $$$ $$$ a $$$ $$$ b $$$ $$$ c $$$ ( $$$ 1 \leq n \leq 100000 1 \leq a b c \leq 1000000000 $$$ ) second line test case contain a binary string $$$ s $$$ length $$$ n $$$ guarantee total sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print answer first test case one optimal sequence operations 01101 $$$ \rightarrow $$$ 0101 $$$ \rightarrow $$$ 011 $$$ \rightarrow $$$ 01 . sequence operations consist operations $$$ 2 $$$ $$$ 3 $$$ $$$ 2 $$$ order satisfy rule give profit $$$ 3 $$$ show impossible achieve higher profit test case answer $$$ 3 $$$ second test case one optimal sequence operations 110001 $$$ \rightarrow $$$ 11001 $$$ \rightarrow $$$ 1001 $$$ \rightarrow $$$ 101 . third test case one optimal sequence operations <unknown> $$$ \rightarrow $$$ 01110 $$$ \rightarrow $$$ 1110 $$$ \rightarrow $$$ 110 $$$ \rightarrow $$$ 11 $$$ \rightarrow $$$ 1,"['data structures', 'greedy', 'implementation']",2700.0
1621/H,railway network one city consist $$$ n $$$ station connect $$$ n-1 $$$ roads station roads form a tree station $$$ 1 $$$ a city center road know time train spend pass road assume train n't spend time stop let 's define $$$ dist ( v ) $$$ time train spend get station $$$ v $$$ station $$$ 1 $$$ railway network splitted zone name first $$$ k $$$ capital latin letter zone $$$ i $$$ -th station $$$ z_i $$$ city center zone a. station guarantee first station road station city center either zone zone lexicographically smaller name road completely own zone distant end city center tourist arrive airport soon go city center 's trip station $$$ v $$$ station $$$ 1 $$$ <unknown> : tourist always select way buy ticket pay fin minimize total cost trip let $$$ f ( v ) $$$ cost station $$$ v $$$ unfortunately tourist n't know current value $$$ pass_i $$$ $$$ fine_i $$$ different zone forget location airport ask query $$$ 3 $$$ type : first line contain single integer $$$ n $$$ ( $$$ 2 \leq n \leq 200000 $$$ ) — number station next $$$ n - 1 $$$ line contain three integers $$$ v_i $$$ $$$ u_i $$$ $$$ t_i $$$ ( $$$ 1 \leq v_i u_i \leq n 1 \leq t_i \leq 1000000000 $$$ ) — end $$$ i $$$ -th road time take a train pass road guarantee roads form a tree next line contain single integer $$$ k $$$ ( $$$ 1 \leq k \leq 26 $$$ ) — number zone next line contain $$$ n $$$ symbols $$$ <unknown> \ldots <unknown> $$$ — $$$ z_i $$$ name zone $$$ i $$$ -th station guarantee condition second paragraph satisfy next line contain $$$ k $$$ integers $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ \ldots $$$ $$$ <unknown> $$$ ( $$$ 1 \leq pass_i \leq 1000000000 $$$ ) — initial cost ticket next line contain $$$ k $$$ integers $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ \ldots $$$ $$$ <unknown> $$$ ( $$$ 1 \leq fine_i \leq 1000000000 $$$ ) — initial fin next line contain single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000000000 $$$ ) — time gap scan control system next line contain single integer $$$ q $$$ ( $$$ 1 \leq q \leq 200000 $$$ ) — number query next $$$ q $$$ line contain query describe statement guarantee query first second type $$$ i $$$ a correct name zone ( one first $$$ k $$$ capital latin letter ) $$$ 1 \leq c \leq 1000000000 $$$ query third type $$$ 1 \leq u \leq n $$$ query third type print answer note fine cheaper pass first query airport locate near station $$$ 2 $$$ near station $$$ 4 $$$ trip tourist always stay zone a. already pass zone answer $$$ 0 $$$ second query cost pass zone a become $$$ 10 $$$ third query airport locate near station $$$ 3 $$$ optimal solution buy pass zone a. first $$$ 3 $$$ second trip tourist zone b. move zone a scan $$$ 4 $$$ -th $$$ 8 $$$ -th second ride since a pass zone wo n't pay fin forth query fine zone a become $$$ 3 $$$ fifth query airport locate near station $$$ 7 $$$ $$$ f ( 7 ) = 6 $$$ sixth query airport locate near station $$$ 6 $$$ near station $$$ 8 $$$ since $$$ f ( 6 ) = 9 $$$ $$$ f ( 8 ) = 6 $$$ answer $$$ 6 $$$,"['dfs and similar', 'graphs', 'shortest paths', 'trees']",3500.0
1622/C,"give integer array $$$ a_1 a_2 \dots a_n $$$ integer $$$ k $$$ one step minimum number step need make sum array $$$ \sum\limits _ { i=1 } ^ { n } { a_i } \le k $$$ ? ( allow make value array negative ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 1 \le k \le 10^ { 15 } $$$ ) — size array $$$ a $$$ upper bind sum second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — array 's guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print one integer — minimum number step make $$$ \sum\limits _ { i=1 } ^ { n } { a_i } \le k $$$ first test case decrease $$$ a_1 $$$ $$$ 10 $$$ time get sum lower equal $$$ k = 10 $$$ second test case sum array $$$ a $$$ already less equal $$$ 69 $$$ n't need change third test case , example : fourth test case , example :","['binary search', 'brute force', 'greedy', 'sortings']",1600.0
1622/D,give a binary string ( i. e. a string consist character 0 and/or 1 ) $$$ s $$$ length $$$ n $$$ perform follow operation string $$$ s $$$ : choose a substring ( a contiguous subsequence ) $$$ s $$$ exactly $$$ k $$$ character 1 shuffle ( reorder character substring wish ) calculate number different string obtain $$$ s $$$ perform operation first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 5000 $$$ ; $$$ 0 \le k \le n $$$ ) second line contain string $$$ s $$$ length $$$ n $$$ consist character 0 and/or 1 . print one integer — number different string obtain $$$ s $$$ perform describe operation since answer large output modulo $$$ 998244353 $$$ string obtain first example : second example $$$ k = 0 $$$ choose substrings consist 0 character reorder n't change string string obtain 10010,"['combinatorics', 'math', 'two pointers']",2000.0
1623/A,"a robot cleaner place floor a rectangle room surround wall floor consist $$$ n $$$ row $$$ m $$$ columns row floor number $$$ 1 $$$ $$$ n $$$ top bottom columns floor number $$$ 1 $$$ $$$ m $$$ leave right cell intersection $$$ r $$$ -th row $$$ c $$$ -th column denote $$$ ( r c ) $$$ initial position robot $$$ ( r_b c_b ) $$$ one second robot move $$$ dr $$$ row $$$ dc $$$ columns , one second robot move cell $$$ ( r c ) $$$ $$$ ( r + dr c + dc ) $$$ initially $$$ dr = 1 $$$ $$$ dc = 1 $$$ a vertical wall ( leave right wall ) movement direction $$$ dc $$$ reflect movement new value $$$ dc $$$ $$$ -dc $$$ a horizontal wall ( upper lower wall ) $$$ dr $$$ reflect movement new value $$$ dr $$$ $$$ -dr $$$ second ( include moment robot start move ) robot clean every cell lie row column position one dirty cell $$$ ( r_d c_d ) $$$ job robot clean dirty cell give floor size $$$ n $$$ $$$ m $$$ robot 's initial position $$$ ( r_b c_b ) $$$ dirty cell 's position $$$ ( r_d c_d ) $$$ find time robot job test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow a test case consist one line contain six integers $$$ n $$$ $$$ m $$$ $$$ r_b $$$ $$$ c_b $$$ $$$ r_d $$$ $$$ c_d $$$ ( $$$ 1 \le n m \le 100 $$$ $$$ 1 \le r_b r_d \le n $$$ $$$ 1 \le c_b c_d \le m $$$ ) — size room initial position robot position dirt cell test case print integer — time robot clean dirty cell show robot always clean dirty cell eventually first example floor size $$$ <unknown> 10 $$$ initial position robot $$$ ( 6 1 ) $$$ position dirty cell $$$ ( 2 8 ) $$$ see illustration example problem statement second example floor initial position robot $$$ ( 9 9 ) $$$ position dirty cell $$$ ( 1 1 ) $$$ example robot go straight dirty cell clean third example floor size $$$ 9 \times 8 $$$ initial position robot $$$ ( 5 6 ) $$$ position dirty cell $$$ ( 2 1 ) $$$ fourth example floor size $$$ 6 \times 9 $$$ initial position robot $$$ ( 2 2 ) $$$ position dirty cell $$$ ( 5 8 ) $$$ last example robot already stand column dirty cell clean cell right away","['brute force', 'implementation', 'math']",800.0
1623/C,$$$ n $$$ heap stone $$$ i $$$ -th heap $$$ h_i $$$ stone want change number stone heap perform follow process : maximum number stone smallest heap process ? test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 2\cdot 100000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) second line test case contain $$$ n $$$ integers $$$ h_1 h_2 h_3 \ldots h_n $$$ ( $$$ 1 \le h_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print maximum number stone smallest heap contain first test case initial heap size $$$ [ 1 2 10 100 ] $$$ move stone follow second test case last heap $$$ 1 $$$ increase size third test case better move stone last test case final achievable configuration heap $$$ [ 3 5 3 4 3 3 ] $$$,"['binary search', 'greedy']",1600.0
1624/A,polycarp get array integers $$$ a [ 1 \dots n ] $$$ a gift want perform a certain number operations ( possibly zero ) elements array become ( become $$$ a_1 = a_2=\dots = a_n $$$ ) example let $$$ a= [ <unknown> ] $$$ perform follow operation : select indices 1 2 4 increase elements array indices $$$ 1 $$$ a result one operation get a new state array $$$ a= [ <unknown> ] $$$ minimum number operations take elements array become equal ( become $$$ a_1 = a_2=\dots = a_n $$$ ) ? first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test follow descriptions input test case first line description test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — array $$$ a $$$ second line description test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements array $$$ a $$$ test case print one integer — minimum number operations make elements array $$$ a $$$ equal first test case : sequence $$$ 3 $$$ operations application elements become equal second test case : third test case :,['math'],800.0
1625/D,"binary spiders species spiders live mar spiders weave web defend enemies weave a web spiders join pair first spider pair $$$ x $$$ legs second spider $$$ y $$$ legs weave a web durability $$$ x \oplus y $$$ , $$$ \oplus $$$ mean bitwise xor binary spiders live large group observe a group $$$ n $$$ spiders $$$ i $$$ -th spider $$$ a_i $$$ legs group threaten spiders become defenders defenders choose follow way first must least two defenders second pair defenders must able weave a web durability least $$$ k $$$ third must much defenders possible scientists research behaviour binary spiders a long time a hypothesis always choose defenders optimal way satisfy condition need verify hypothesis group spiders , need understand many spiders must become defenders a binary spider decide use a computer solve problem first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 3\cdot100000 $$$ $$$ 0 \le k \le 2^ { 30 } - 1 $$$ ) amount spiders group minimal allow durability a web second line contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 0 \le a_i \le 2^ { 30 } -1 $$$ ) — number legs $$$ i $$$ -th spider first line print a single integer $$$ \ell $$$ ( $$$ 2 \le \ell \le n $$$ ) maximum possible amount defenders second line print $$$ \ell $$$ integers $$$ b_i $$$ separate a single space ( $$$ 1 \le b_i \le n $$$ ) — indices spiders become defenders exist one way choose defenders print unfortunately may appear 's impossible choose defenders case print a single integer $$$ -1 $$$ consider examples first example group spiders illustrate picture : choose two - legged ten - legged $$$ 16 $$$ <unknown> spiders 's hard see pair may weave a web enough durability $$$ 2 \oplus 10 = 8 \ge 8 $$$ $$$ 2 \oplus 16 = 18 \ge 8 $$$ $$$ 10 \oplus 16 = 26 \ge 8 $$$ way also choose example spiders indices $$$ 3 $$$ $$$ 4 $$$ $$$ 6 $$$ second example pair spiders weave web durability $$$ 1024 $$$ answer $$$ -1 $$$","['bitmasks', 'data structures', 'implementation', 'math', 'sortings', 'trees']",2300.0
1626/D,monocarp plan host a <unknown> arts tournament three divisions base weight : lightweight middleweight heavyweight winner division determine a single elimination system particular imply number participants division a power two additionally division a non - zero amount participants $$$ n $$$ participants register tournament far $$$ i $$$ -th weigh $$$ a_i $$$ split participants divisions monocarp go establish two integer weight boundaries $$$ x $$$ $$$ y $$$ ( $$$ x < y $$$ ) participants weigh strictly less $$$ x $$$ consider lightweight participants weigh greater equal $$$ y $$$ consider heavyweight remain participants consider middleweight 's possible distribution n't make number participants division a power two also lead empty divisions fix issue monocarp invite arbitrary number participants division note monocarp ca n't kick $$$ n $$$ participants already register tournament however want invite little extra participants possible help monocarp choose $$$ x $$$ $$$ y $$$ a way total amount extra participants require small possible output amount first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number register participants second line testcase contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — weight register participants sum $$$ n $$$ testcases n't exceed $$$ 200000 $$$ testcase print a single integer — smallest number extra participants monocarp require invite choose weight boundaries $$$ x $$$ $$$ y $$$ first testcase example monocarp choose $$$ x=2 $$$ $$$ y=3 $$$ lightweight middleweight heavyweight divisions $$$ 2 $$$ $$$ 1 $$$ $$$ 1 $$$ participants respectively power two extra participants require second testcase example regardless choice $$$ x $$$ $$$ y $$$ one division $$$ 1 $$$ participant rest $$$ 0 $$$ thus monocarp invite $$$ 1 $$$ participant remain divisions third testcase example monocarp choose $$$ x=1 $$$ $$$ y=2 $$$ lightweight middleweight heavyweight divisions $$$ 0 $$$ $$$ 3 $$$ $$$ 3 $$$ participants respectively extra participant need division fourth testcase example monocarp choose $$$ x=8 $$$ $$$ <unknown> $$$ lightweight middleweight heavyweight divisions $$$ 8 $$$ $$$ 0 $$$ $$$ 0 $$$ participants respectively middleweight heavyweight division need extra participant,"['binary search', 'brute force', 'greedy', 'math']",2100.0
1627/A,"a grid $$$ n $$$ row $$$ m $$$ columns cells color black rest cells color white one operation select black cell exactly one follow : give two integers $$$ r $$$ $$$ c $$$ find minimum number operations require make cell row $$$ r $$$ column $$$ c $$$ black determine impossible input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case description test case follow first line test case contain four integers $$$ n $$$ $$$ m $$$ $$$ r $$$ $$$ c $$$ ( $$$ 1 \leq n m \leq 50 $$$ ; $$$ 1 \leq r \leq n $$$ ; $$$ 1 \leq c \leq m $$$ ) — number row number columns grid row column cell need turn black respectively $$$ n $$$ line follow contain $$$ m $$$ character character either ' b ' ' w ' — a black a white cell respectively test case impossible make cell row $$$ r $$$ column $$$ c $$$ black output $$$ -1 $$$ otherwise output a single integer — minimum number operations require make cell row $$$ r $$$ column $$$ c $$$ black first test case picture take black cell row $$$ 1 $$$ column $$$ 2 $$$ make cells row black therefore cell row $$$ 1 $$$ column $$$ 4 $$$ become black second test case cell row $$$ 2 $$$ column $$$ 1 $$$ already black third test case impossible make cell row $$$ 2 $$$ column $$$ 2 $$$ black fourth test case picture take black cell row $$$ 2 $$$ column $$$ 2 $$$ make column black , take black cell row $$$ 1 $$$ column $$$ 2 $$$ make row black therefore cell row $$$ 1 $$$ column $$$ 1 $$$ become black",['implementation'],800.0
1627/E,major ram chase <unknown> enemy raghav ram must reach top build escape via helicopter build however fire ram must choose optimal path reach top build lose minimum amount health build consist $$$ n $$$ floor $$$ m $$$ room let $$$ ( i j ) $$$ represent $$$ j $$$ -th room $$$ i $$$ -th floor additionally $$$ k $$$ ladder instal $$$ i $$$ -th ladder allow ram travel $$$ ( a_i b_i ) $$$ $$$ ( c_i d_i ) $$$ direction ram also gain $$$ h_i $$$ health point use ladder $$$ i $$$ guarantee $$$ a_i < c_i $$$ ladder ram $$$ i $$$ -th floor move either leave right travel across floor however treacherous ram travel $$$ ( i j ) $$$ $$$ ( i k ) $$$ lose $$$ |j - k| \cdot x_i $$$ health point ram enter build $$$ ( 1 1 ) $$$ helicopter wait $$$ ( n m ) $$$ minimum amount health ram lose take optimal path ? note answer may negative ( case gain health ) output ` ` escape '' matter path ram take escape clutch raghav first line input contain $$$ t $$$ ( $$$ 1 \leq t \leq 50000 $$$ ) — number test case first line test case consist $$$ 3 $$$ integers $$$ n m k $$$ ( $$$ 2 \leq n m \leq 100000 $$$ ; $$$ 1 \leq k \leq 100000 $$$ ) — number floor number room floor number ladder respectively second line a test case consist $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ 1 \leq x_i \leq 1000000 $$$ ) next $$$ k $$$ line describe ladder ladder $$$ i $$$ denote $$$ a_i b_i c_i d_i h_i $$$ ( $$$ 1 \leq a_i < c_i \leq n $$$ ; $$$ 1 \leq b_i d_i \leq m $$$ ; $$$ 1 \leq h_i \leq 1000000 $$$ ) — room connect health point gain use guarantee $$$ a_i < c_i $$$ ladder one ladder 2 room build sum $$$ n $$$ sum $$$ m $$$ sum $$$ k $$$ test case exceed $$$ 100000 $$$ output minimum health ram lose optimal path $$$ ( 1 1 ) $$$ $$$ ( n m ) $$$ ram escape clutch raghav regardless path take output ` ` escape '' ( uppercase without quote ) figure first test case statement $$$ 2 $$$ possible paths $$$ ( n m ) $$$ : second test case path $$$ ( n m ) $$$ third case case ram travel $$$ ( 1 3 ) $$$ take ladder $$$ ( 5 3 ) $$$ lose $$$ 10 $$$ health point gain $$$ h_1 = 100 $$$ health point therefore total loss $$$ 10 - <unknown> $$$ ( negative imply gain health path ),"['data structures', 'dp', 'implementation', 'shortest paths', 'two pointers']",2200.0
1628/E,mihai live a town meteor storm a common problem 's annoy mihai buy groceries sometimes get hit meteors n't fun therefore ask find dangerous way buy groceries trick go town $$$ n $$$ build number $$$ 1 $$$ $$$ n $$$ build roads exactly $$$ 1 $$$ simple path build build road a certain meteor danger level build grocery store mihai care open ones course initially grocery store close give $$$ q $$$ query three type : first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \le n q \le 3\cdot 100000 $$$ ) follow $$$ n - 1 $$$ line $$$ i $$$ -th contain integers $$$ u_i $$$ $$$ v_i $$$ $$$ w_i $$$ ( $$$ 1 \le u_i v_i \le n \enspace 1 \le w_i \le 1000000000 $$$ ) mean two way road build $$$ u_i $$$ $$$ v_i $$$ meteor danger level $$$ w_i $$$ guarantee give edge form a tree follow $$$ q $$$ line $$$ j $$$ -th begin integer $$$ t_j $$$ ( $$$ 1 \le t_j \le 3 $$$ ) mean $$$ j $$$ -th query $$$ t_j $$$ -th type $$$ t_j $$$ $$$ 1 $$$ $$$ 2 $$$ rest line contain integers $$$ l_j $$$ $$$ r_j $$$ ( $$$ 1 \le l_j \le r_j \le n $$$ ) $$$ t_j $$$ $$$ 3 $$$ rest line contain integer $$$ x_j $$$ ( $$$ 1 \le x_j \le n $$$ ) query $$$ 3 $$$ rd type ( $$$ t_j = 3 $$$ ) output maximum meteor danger level edge simple path $$$ x_j $$$ open store $$$ -1 $$$ edge illustration town give sample input first query open store obviously edge simple path $$$ 1 $$$ open store answer $$$ -1 $$$ second third query set open store $$$ \ { 1\ } $$$ simple path $$$ 1 $$$ $$$ 1 $$$ edge answer $$$ 3 $$$ rd query $$$ -1 $$$ fourth query open store fifth sixth query set open store $$$ \ { 5 6\ } $$$ sixth query two paths $$$ x_j = 4 $$$ open grocery store : $$$ 4 $$$ $$$ 5 $$$ $$$ 4 $$$ $$$ 6 $$$ biggest meteor danger find edge $$$ 4 $$$ $$$ 6 $$$ answer $$$ 6 $$$ th query $$$ 4 $$$ path mark red illustration rest query set open store $$$ \ { 5\ } $$$ eighth query path $$$ x_j = 4 $$$ open store $$$ 4 $$$ $$$ 5 $$$ maximum weight path $$$ 3 $$$ path mark green illustration ninth query path $$$ x_j = 1 $$$ open store $$$ 1 $$$ $$$ 5 $$$ maximum weight path $$$ 5 $$$ path mark blue illustration,"['binary search', 'data structures', 'dsu', 'trees']",3100.0
1629/B,consider array $$$ a $$$ compose integers range $$$ [ l r ] $$$ example $$$ l = 3 $$$ $$$ r = 7 $$$ $$$ a = [ 3 4 5 6 7 ] $$$ give $$$ l $$$ $$$ r $$$ $$$ k $$$ possible $$$ \gcd ( a ) $$$ greater $$$ 1 $$$ follow operation $$$ k $$$ time ? $$$ \gcd ( b ) $$$ denote greatest common divisor ( gcd ) integers $$$ b $$$ first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case description test case follow input test case consist a single line contain $$$ 3 $$$ non - negative integers $$$ l $$$ $$$ r $$$ $$$ k $$$ ( $$$ 1 \leq l \leq r \leq 1000000000 \enspace 0 \leq k \leq r - l $$$ ) test case print ` ` yes '' possible gcd correspond array greater $$$ 1 $$$ perform $$$ k $$$ operations ` ` '' otherwise ( case insensitive ) first test case $$$ a = [ 1 ] $$$ answer ` ` '' since element array $$$ 1 $$$ second test case array $$$ a = [ 3 4 5 ] $$$ $$$ 1 $$$ operation first operation array change : $$$ [ 3 20 ] $$$ $$$ [ 4 15 ] $$$ $$$ [ 5 12 ] $$$ greatest common divisor equal $$$ 1 $$$ answer ` ` '' third test case $$$ a = [ 13 ] $$$ answer ` ` yes '' since element array $$$ 13 $$$ fourth test case $$$ a = [ 4 ] $$$ answer ` ` yes '' since element array $$$ 4 $$$,"['greedy', 'math', 'number theory']",800.0
1631/A,"give two array $$$ a $$$ $$$ b $$$ $$$ n $$$ positive integers apply follow operation number time : find minimum possible value $$$ \max ( a_1 a_2 \ldots a_n ) \cdot \max ( b_1 b_2 \ldots b_n ) $$$ get apply operation number time ( possibly zero ) input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1\le n\le 100 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 10\,000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element array $$$ a $$$ third line test case contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1 \le b_i \le 10\,000 $$$ ) $$$ b_i $$$ $$$ i $$$ -th element array $$$ b $$$ test case print a single integer minimum possible value $$$ \max ( a_1 a_2 \ldots a_n ) \cdot \max ( b_1 b_2 \ldots b_n ) $$$ get apply operation number time first test apply operations indices $$$ 2 $$$ $$$ 6 $$$ $$$ a = [ 1 4 6 5 1 5 ] $$$ $$$ b = [ 3 2 3 2 2 2 ] $$$ $$$ \max ( 1 4 6 5 1 5 ) \cdot \max ( 3 2 3 2 2 2 ) = 18 = 18 $$$ second test matter apply operations $$$ a = [ 3 3 3 ] $$$ $$$ b = [ 3 3 3 ] $$$ always hold answer $$$ \max ( 3 3 3 ) \cdot \max ( 3 3 3 ) = 9 = 9 $$$ third test apply operation index $$$ 1 $$$ $$$ a = [ 2 2 ] $$$ $$$ b = [ 1 1 ] $$$ answer $$$ \max ( 2 2 ) \cdot \max ( 1 1 ) = 2 = 2 $$$",['greedy'],800.0
1632/C,"igor 11th grade tomorrow write informatics test <unknown> teacher school pavel <unknown> igor know test conduct : first teacher give student two positive integers $$$ a $$$ $$$ b $$$ ( $$$ a < b $$$ ) , student apply follow operations number time : get full mark test student tell teacher minimum require number operations make $$$ a $$$ $$$ b $$$ equal igor already know number teacher give help figure minimum number operations need make $$$ a $$$ equal $$$ b $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow line test case contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a < b \le 1000000 $$$ ) guarantee sum $$$ b $$$ test case exceed $$$ 1000000 $$$ test case print one integer — minimum require number operations make $$$ a $$$ $$$ b $$$ equal first test case optimal apply third operation second test case optimal apply first operation three time third test case optimal apply second operation third operation","['binary search', 'bitmasks', 'brute force', 'dp', 'math']",1600.0
1635/C,"give array $$$ a $$$ $$$ n $$$ elements perform follow operation $$$ n $$$ time : select three indices $$$ x y z $$$ $$$ ( 1 \leq x < y < z \leq n ) $$$ replace $$$ a_x $$$ $$$ a_y - a_z $$$ operation $$$ <unknown> $$$ need less $$$ 10^ { 18 } $$$ goal make result array non - decreasing multiple solutions output impossible achieve report well test contain multiple test case first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10000 ) $$$ — number test case $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 3 \leq n \leq 2 \cdot 100000 ) $$$ — size array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( -1000000000 \leq a_i \leq 1000000000 ) $$$ elements $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print $$$ -1 $$$ a single line solution otherwise first line print a single integer $$$ m $$$ $$$ ( 0 \leq m \leq n ) $$$ — number operations perform $$$ i $$$ -th follow $$$ m $$$ line contain three integers $$$ x y z $$$ $$$ ( 1 \leq x < y < z \leq n ) $$$ — description $$$ i $$$ -th operation multiple solutions output note n't minimize number operations task first example array become $$$ [ -6 <unknown> -1,2 ] $$$ first operation $$$ [ -6 -4 -3 -1,2 ] $$$ second operation second example impossible make array sort sequence operations third example array already sort n't need perform operations",['greedy'],1200.0
1635/E,$$$ n $$$ cars a coordinate axis $$$ ox $$$ car locate integer point initially two cars locate point also car orient either leave right move constant positive speed direction moment formally describe $$$ i $$$ -th car a letter integer : orientation $$$ ori_i $$$ location $$$ x_i $$$ $$$ ori_i = l $$$ $$$ x_i $$$ decrease a constant rate respect time similarly $$$ ori_i = r $$$ $$$ x_i $$$ increase a constant rate respect time call two cars irrelevant never end point regardless speed word wo n't share coordinate moment call two cars destine always end point regardless speed word must share coordinate moment unfortunately lose information cars remember $$$ m $$$ relationships two type relationships : $$$ 1 $$$ $$$ i $$$ $$$ j $$$ — $$$ i $$$ -th car $$$ j $$$ -th car irrelevant $$$ 2 $$$ $$$ i $$$ $$$ j $$$ — $$$ i $$$ -th car $$$ j $$$ -th car destine restore orientations locations cars satisfy relationships report impossible multiple solutions output note two cars share coordinate intersect moment continue movement directions first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 2 \leq n \leq 2 \cdot 100000 ; 1 \leq m \leq min ( 2 \cdot 100000 \frac { n ( n-1 ) } { 2 } ) $$$ — number cars number restrictions respectively next $$$ m $$$ line contain three integers $$$ type $$$ $$$ i $$$ $$$ j $$$ $$$ ( 1 \leq type \leq 2 ; 1 \leq i j \leq n ; <unknown> ) $$$ $$$ type $$$ = $$$ 1 $$$ $$$ i $$$ -th car $$$ j $$$ -th car irrelevant otherwise $$$ i $$$ -th car $$$ j $$$ -th car destine guarantee pair cars $$$ 1 $$$ relationship first line print either ` ` yes '' ` ` '' ( case ) whether possible restore orientations locations cars satisfy relationships answer ` ` yes '' print $$$ n $$$ line contain a symbol integer : $$$ ori_i $$$ $$$ x_i $$$ $$$ ( ori_i \in \ { l r\ } ; -1000000000 \leq x_i \leq 1000000000 ) $$$ — represent information $$$ i $$$ -th car orientation leave $$$ ori_i $$$ = $$$ l $$$ otherwise $$$ ori_i $$$ = $$$ r $$$ $$$ x_i $$$ $$$ i $$$ -th car locate note $$$ x_i $$$ distinct prove exist a solution must a solution satisfy constraints $$$ x_i $$$,"['dfs and similar', 'dsu', 'graphs', 'greedy', 'sortings']",2200.0
1637/G,"vitaly give maxim $$$ n $$$ number $$$ 1 2 \ldots n $$$ $$$ 16 $$$ -th birthday maxim tire play board game celebration decide play number one step maxim choose two number $$$ x $$$ $$$ y $$$ number throw away add two number $$$ x + y $$$ $$$ |x - y| $$$ instead want number equal several step sum number minimal help maxim find a solution maxim 's friends n't want wait long number step solution exceed $$$ 20n $$$ guarantee give constraints a solution exist exist a solution make number equal minimize sum spend $$$ 20n $$$ move first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 25\,000 $$$ ) — number test case test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 50000 $$$ ) — number integers give maxim guarantee total sum $$$ n $$$ n't exceed $$$ 50000 $$$ test case print $$$ -1 $$$ 's impossible make number equal otherwise print a single integer $$$ s $$$ ( $$$ 0 \le s \le 20n $$$ ) — number step print $$$ s $$$ line $$$ i $$$ -th line must contain two integers $$$ x_i $$$ $$$ y_i $$$ — number maxim choose $$$ i $$$ -th step number must become equal operations n't forget need make number equal also minimize sum guarantee give constraints a solution exist exist a solution make number equal minimize sum spend $$$ 20n $$$ move","['greedy', 'math']",3000.0
1638/C,"give a permutation $$$ p_1 p_2 \dots p_n $$$ , undirected graph construct follow way : add edge vertices $$$ i $$$ $$$ j $$$ $$$ i < j $$$ $$$ p_i > p_j $$$ task count number connect components graph two vertices $$$ u $$$ $$$ v $$$ belong connect component least one path along edge connect $$$ u $$$ $$$ v $$$ a permutation array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length permutation second line test case contain $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) — elements permutation guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print one integer $$$ k $$$ — number connect components separate test case depict image color square represent elements permutation one permutation color represent connect component number distinct color answer","['data structures', 'dsu', 'graphs', 'math']",1300.0
164/D,give n point plane need delete exactly k ( k < n ) diameter set remain n - k point small possible diameter a set point maximum pairwise distance point set diameter a one point set equal zero first input line contain a pair integers n k ( 2 ≤ n ≤ 1000 1 ≤ k ≤ 30 k < n ) — number point plane number point delete correspondingly next n line describe point one per line description consist a pair integers xi yi ( 0 ≤ xi yi ≤ 32000 ) — coordinate i - th point give point coincide print k different space - separated integers 1 n — number point delete point number order give input 1 n. print number order multiple solutions print,"['binary search', 'brute force']",3100.0
1641/A,"a sequence positive integers call great a positive integer $$$ x $$$ split pair a way pair first number multiply $$$ x $$$ equal second number formally a sequence $$$ a $$$ size $$$ n $$$ great a positive integer $$$ x $$$ $$$ n $$$ even exist a permutation $$$ p $$$ size $$$ n $$$ $$$ i $$$ ( $$$ 1 \le i \le \frac { n } { 2 } $$$ ) $$$ a _ { p _ { 2i-1 } } \cdot x = a _ { p _ { 2i } } $$$ sam a sequence $$$ a $$$ a positive integer $$$ x $$$ help make sequence great : find minimum possible number positive integers add sequence $$$ a $$$ make great number $$$ x $$$ test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 20\,000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 2 \le x \le 1000000 $$$ ) next line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print a single integer — minimum number integers add end $$$ a $$$ make a great sequence number $$$ x $$$ first test case sam get lucky sequence already great number $$$ 4 $$$ divide pair : $$$ ( 1 4 ) $$$ $$$ ( 4 16 ) $$$ thus add $$$ 0 $$$ number second test case add number $$$ 1 $$$ $$$ 14 $$$ sequence divide $$$ 8 $$$ integers pair : $$$ ( 1 2 ) $$$ $$$ ( 1 2 ) $$$ $$$ ( 2 4 ) $$$ $$$ ( 7 14 ) $$$ impossible add less $$$ 2 $$$ integers fix sequence","['brute force', 'greedy', 'sortings']",1200.0
1644/B,let 's call a permutation $$$ p $$$ length $$$ n $$$ anti - fibonacci condition $$$ p _ { i-2 } + p _ { i-1 } \ne p_i $$$ hold $$$ i $$$ ( $$$ 3 \le i \le n $$$ ) recall permutation array length $$$ n $$$ contain integer $$$ 1 $$$ $$$ n $$$ exactly task a give number $$$ n $$$ print $$$ n $$$ distinct anti - fibonacci permutations length $$$ n $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 48 $$$ ) — number test case single line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 50 $$$ ) test case print $$$ n $$$ line line contain anti - fibonacci permutation length $$$ n $$$ test case print permutation multiple answer print show always possible find $$$ n $$$ different anti - fibonacci permutations size $$$ n $$$ constraints problem,"['brute force', 'implementation']",800.0
1644/C,give array $$$ a_1 a_2 \dots a_n $$$ consist $$$ n $$$ integers also give integer value $$$ x $$$ let $$$ f ( k ) $$$ maximum sum a contiguous subarray $$$ a $$$ apply follow operation : add $$$ x $$$ elements exactly $$$ k $$$ distinct position empty subarray also consider sum $$$ 0 $$$ note subarray n't include increase elements calculate maximum value $$$ f ( k ) $$$ $$$ k $$$ $$$ 0 $$$ $$$ n $$$ independently first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) — number testcases first line testcase contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \le n \le 5000 $$$ ; $$$ 0 \le x \le 100000 $$$ ) — number elements array value add second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ -100000 \le a_i \le 100000 $$$ ) sum $$$ n $$$ testcases n't exceed $$$ 5000 $$$ testcase print $$$ n + 1 $$$ integers — maximum value $$$ f ( k ) $$$ $$$ k $$$ $$$ 0 $$$ $$$ n $$$ independently first testcase n't matter elements add $$$ x $$$ subarray maximum sum always entire array increase $$$ k $$$ elements $$$ x $$$ $$$ k \cdot x $$$ add sum second testcase :,"['brute force', 'dp', 'greedy', 'implementation']",1400.0
1646/E,a rectangular board size $$$ n\times m $$$ ( $$$ n $$$ row $$$ m $$$ columns ) $$$ n $$$ row number $$$ 1 $$$ $$$ n $$$ top bottom $$$ m $$$ columns number $$$ 1 $$$ $$$ m $$$ leave right cell intersection row $$$ i $$$ column $$$ j $$$ contain number $$$ <unknown> $$$ ( $$$ i $$$ raise power $$$ j $$$ ) example $$$ n=3 $$$ $$$ m=3 $$$ board follow : find number distinct integers write board line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1\le n m\le 1000000 $$$ ) — number row columns board print one integer number distinct integers board statement show board first test case case $$$ 7 $$$ distinct integers : $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 8 $$$ $$$ 9 $$$ $$$ 27 $$$ second test case board follow : $$$ 5 $$$ distinct number : $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$ $$$ 8 $$$ $$$ 16 $$$ third test case board follow : $$$ 6 $$$ distinct number : $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 9 $$$ $$$ 16 $$$,"['brute force', 'dp', 'math', 'number theory']",2200.0
1647/D,madoka go enroll ` ` <unknown> <unknown> '' stumble upon a difficult task entrance computer science exam : notice a beautiful number must good give a good number $$$ x $$$ determine whether represent least two different ways a product several ( possibly one ) beautiful number two ways different set number use different solve problem madoka help enroll best school russia ! first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case come description test case consist two integers $$$ x $$$ $$$ d $$$ separate a space ( $$$ 2 \leq x d \leq 1000000000 $$$ ) guarantee $$$ x $$$ a multiple $$$ d $$$ set input data output ` ` '' number represent least two ways otherwise output ` ` yes '' output letter case ( example ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ) first example $$$ 6 $$$ represent $$$ 6 $$$ $$$ 6 $$$ $$$ 6 $$$ $$$ 3 $$$ $$$ 1 $$$ a good number divisible $$$ 2 $$$ one way second example $$$ 12 $$$ represent $$$ 12 $$$ $$$ 12 $$$ $$$ 12 $$$ $$$ 6 \cdot 2 $$$ first option suitable second is — $$$ 12 $$$ beautiful number ( $$$ 12 = 12 $$$ ) third fourth also suitable $$$ 3 $$$ good number third example $$$ 36 $$$ represent $$$ 36 $$$ $$$ 36 $$$ therefore decompose least two ways,"['dp', 'math', 'number theory']",1900.0
1648/B,give array $$$ a $$$ $$$ n $$$ positive integers number $$$ 1 $$$ $$$ n $$$ let 's call array integral two necessarily different number $$$ x $$$ $$$ y $$$ array $$$ x \ge y $$$ number $$$ \left \lfloor \frac { x } { y } \right \rfloor $$$ ( $$$ x $$$ divide $$$ y $$$ round ) also array guarantee number $$$ a $$$ exceed $$$ c $$$ task check whether array integral input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ c $$$ ( $$$ 1 \le n \le 1000000 $$$ $$$ 1 \le c \le 1000000 $$$ ) — size $$$ a $$$ limit number array second line test case contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le c $$$ ) — array $$$ a $$$ let $$$ n $$$ sum $$$ n $$$ test case $$$ c $$$ sum $$$ c $$$ test case guarantee $$$ n \le 1000000 $$$ $$$ c \le 1000000 $$$ test case print yes array integral otherwise first test case easy see array integral : thus condition meet array integral second test case enough see $$$ \left \lfloor \frac { 7 } { 3 } \right \rfloor = \left \lfloor <unknown> { 1 } { 3 } \right \rfloor = 2 $$$ number $$$ a $$$ 's integral third test case $$$ \left \lfloor \frac { 2 } { 2 } \right \rfloor = 1 $$$ $$$ 2 $$$ array 's integral,"['brute force', 'data structures', 'math']",1800.0
1648/C,"look kitchen fridge little boy tyler notice magnets symbols align a string $$$ s $$$ tyler like string especially lexicographically smaller another string $$$ t $$$ play magnets fridge wonder many distinct string compose letter string $$$ s $$$ rearrange result string lexicographically smaller string $$$ t $$$ ? tyler young ca n't answer question alphabet tyler use large convenience already replace letter $$$ s $$$ $$$ t $$$ integers keep different letter replace different integers call a string $$$ x $$$ lexicographically smaller a string $$$ y $$$ one follow condition fulfil : answer large print modulo $$$ 998\,244\,353 $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200\,000 $$$ ) — lengths string $$$ s $$$ $$$ t $$$ respectively second line contain $$$ n $$$ integers $$$ s_1 s_2 s_3 \ldots s_n $$$ ( $$$ 1 \le s_i \le 200\,000 $$$ ) — letter string $$$ s $$$ third line contain $$$ m $$$ integers $$$ t_1 t_2 t_3 \ldots t_m $$$ ( $$$ 1 \le t_i \le 200\,000 $$$ ) — letter string $$$ t $$$ print a single number — number string lexicographically smaller $$$ t $$$ obtain rearrange letter $$$ s $$$ modulo $$$ 998\,244\,353 $$$ first example string interest $$$ [ 1\ 2\ 2 ] $$$ $$$ [ 2\ 1\ 2 ] $$$ string $$$ [ 2\ 2\ 1 ] $$$ lexicographically larger string $$$ [ 2\ 1\ 2\ 1 ] $$$ n't count second example string count except $$$ [ 4\ 3\ 2\ 1 ] $$$ answer $$$ 4 ! - 1 = 23 $$$ third example string $$$ [ 1\ 1\ 1\ 2 ] $$$ count","['combinatorics', 'data structures', 'implementation']",1900.0
1648/F,"order make capital berland a attractive place tourists great king come follow plan : choose two streets city call avenues certainly avenues <unknown> extremely important historical place attract tourists world capital berland represent a graph vertices crossroads edge streets connect two crossroads total $$$ n $$$ vertices $$$ m $$$ edge graph move directions along street get crossroad move along streets street connect two different crossroads two streets connect pair crossroads order reduce flow ordinary citizens move along great avenues decide introduce a toll avenue directions need pay $$$ 1 $$$ <unknown> one passage along avenue n't pay rest streets analysts collect a sample $$$ k $$$ citizens $$$ i $$$ -th need go work crossroad $$$ a_i $$$ crossroad $$$ b_i $$$ two avenues choose citizen go work along path minimal cost order earn much money possible decide choose two streets two avenues total number tugriks pay $$$ k $$$ citizens maximize help king : accord give scheme city a sample citizens find two streets make avenues many tugriks citizens pay accord choice test consist multiple test case first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 3 \leq n \leq 500\,000 $$$ $$$ n - 1 \leq m \leq 500\,000 $$$ $$$ m \le \frac { n ( n - 1 ) } { 2 } $$$ ) — number crossroads streets respectively next $$$ m $$$ line contain description streets $$$ i $$$ -th line contain two integers $$$ s_i $$$ $$$ f_i $$$ ( $$$ 1 \leq s_i f_i \leq n $$$ $$$ s_i \neq f_i $$$ ) — index crossroads connect $$$ i $$$ -th street guarantee two streets connect pair crossroads get crossroad move along streets next line contain a single integer $$$ k $$$ ( $$$ 1 \leq k \leq 500\,000 $$$ ) — amount citizens sample next $$$ k $$$ line contain description citizens $$$ i $$$ -th line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a_i b_i \leq n $$$ $$$ a_i \neq b_i $$$ ) — $$$ i $$$ -th citizen go work crossroad $$$ a_i $$$ crossroad $$$ b_i $$$ let $$$ m $$$ sum $$$ m $$$ test case $$$ k $$$ sum $$$ k $$$ test case guarantee $$$ m k \le 500\,000 $$$ test case print answer problem first line print total amount tugriks pay citizens second line print two integers $$$ x_1 $$$ $$$ y_1 $$$ — number crossroads connect first avenue third line print two integers $$$ x_2 $$$ $$$ y_2 $$$ — number crossroads connect second avenue number crossroads connect avenue print order print streets among $$$ m $$$ streets city choose streets different","['data structures', 'dfs and similar', 'graphs']",3500.0
1649/A,play a popular computer game next level consist $$$ n $$$ consecutive locations number $$$ 1 $$$ $$$ n $$$ contain either land water know first last locations contain land complete level move first location last also become inside a location water die move locations land jump adjacent locations free well jump location land $$$ i $$$ location land $$$ i + x $$$ spend $$$ x $$$ coin ( $$$ x \geq 0 $$$ ) task spend minimum possible number coin move first location last one note always possible since first last locations land locations several test case input data first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case follow test case description first line test case contain one integer $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) — number locations second line test case contain a sequence integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 1 $$$ ) $$$ a_i = 1 $$$ mean $$$ i $$$ -th location location land $$$ a_i = 0 $$$ mean $$$ i $$$ -th location location water guarantee $$$ a_1 = 1 $$$ $$$ a_n = 1 $$$ test case print a single integer — answer problem first test case enough make one free jump first location second one also last one answer $$$ 0 $$$ second test case way move first location last one jump cost $$$ 4 $$$ coin third test case jump first location third $$$ 2 $$$ coin jump fourth location free answer $$$ 2 $$$ show optimal way,['implementation'],800.0
1651/B,recently friend discover one special operation integer array $$$ a $$$ : play operation a come next conclusion : statement sound fishy want find a counterexample a give integer $$$ n $$$ find counterexample prove wrong ? word find array $$$ a $$$ consist $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) pair indices $$$ ( i j ) $$$ perform operation wo n't decrease total sum ( increase change sum ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 1000 $$$ ) — length array $$$ a $$$ test case counterexample array $$$ a $$$ size $$$ n $$$ print otherwise print yes follow array $$$ a $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) multiple <unknown> print first test case possible pair indices $$$ ( 1 2 ) $$$ $$$ ( 2 1 ) $$$ perform operation indices $$$ ( 1 2 ) $$$ ( $$$ ( 2 1 ) $$$ ) 'll get $$$ a_1 = a_2 = |1 - <unknown> = 336 $$$ array $$$ [ 336 336 ] $$$ case total sum increase array $$$ a $$$ a counterexample,['greedy'],800.0
1651/F,"monocarp play a tower defense game a level game represent ox axis lattice point $$$ 1 $$$ $$$ n $$$ contain a tower tower $$$ i $$$ -th point $$$ c_i $$$ mana capacity $$$ r_i $$$ mana regeneration rate begin $$$ 0 $$$ -th second tower full mana , end second $$$ i $$$ -th tower $$$ x $$$ mana become $$$ \mathit { min } ( x + r_i c_i ) $$$ mana next second $$$ q $$$ monsters spawn a level $$$ j $$$ -th monster spawn point $$$ 1 $$$ begin $$$ t_j $$$ -th second $$$ h_j $$$ health every monster move $$$ 1 $$$ point per second direction increase coordinate a monster pass tower tower deal $$$ \mathit { min } ( h m ) $$$ damage $$$ h $$$ current health monster $$$ m $$$ current mana amount tower amount get subtract monster 's health tower 's mana unfortunately sometimes monsters pass $$$ n $$$ tower remain alive monocarp want know total health monsters pass tower first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number tower $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ c_i $$$ $$$ r_i $$$ ( $$$ 1 \le r_i \le c_i \le 1000000000 $$$ ) — mana capacity mana regeneration rate $$$ i $$$ -th tower next line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number monsters $$$ j $$$ -th next $$$ q $$$ line contain two integers $$$ t_j $$$ $$$ h_j $$$ ( $$$ 0 \le t_j \le 200000 $$$ ; $$$ 1 \le h_j \le 10^ { 12 } $$$ ) — time $$$ j $$$ -th monster spawn health monsters list increase order spawn time $$$ t_j < t _ { j+1 } $$$ $$$ 1 \le j \le <unknown> $$$ print a single integer — total health monsters pass tower","['binary search', 'brute force', 'data structures']",3000.0
1656/A,give array $$$ a_1 a_2 \ldots a_n $$$ positive integers a good pair a pair indices $$$ ( i j ) $$$ $$$ 1 \leq i j \leq n $$$ $$$ 1 \leq k \leq n $$$ follow equality hold : $$$ $$$ |a_i - <unknown> + <unknown> - a_j| = |a_i - a_j| $$$ $$$ $$$ |x| $$$ denote absolute value $$$ x $$$ find a good pair note $$$ i $$$ equal $$$ j $$$ input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element array sum $$$ n $$$ test case $$$ 200000 $$$ test case print a single line two space - separated indices $$$ i $$$ $$$ j $$$ form a good pair array case $$$ i = j $$$ allow show a pair always exist multiple good pair print first case $$$ i = 2 $$$ $$$ j = 3 $$$ equality hold true $$$ k $$$ :,"['math', 'sortings']",800.0
1657/B,give four integers $$$ n $$$ $$$ b $$$ $$$ x $$$ $$$ y $$$ build a sequence $$$ a_0 a_1 a_2 \dots a_n $$$ $$$ a_0 = 0 $$$ $$$ i \ge 1 $$$ choose : goal build a sequence $$$ a $$$ $$$ a_i \le b $$$ $$$ i $$$ $$$ \sum\limits _ { i=0 } ^ { n } { a_i } $$$ maximum possible first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case next $$$ t $$$ case follow first line test case contain four integers $$$ n $$$ $$$ b $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 1 \le b x y \le 1000000000 $$$ ) 's guarantee total sum $$$ n $$$ n't exceed $$$ 200000 $$$ test case print one integer — maximum possible $$$ \sum\limits _ { i=0 } ^ { n } { a_i } $$$ first test case optimal sequence $$$ a $$$ $$$ [ 0 1 2 3 4 5 ] $$$ second test case optimal sequence $$$ a $$$ $$$ [ 0 1000000000 0 1000000000 0 1000000000 0 1000000000 ] $$$ third test case optimal sequence $$$ a $$$ $$$ [ 0 -3 -6 1 -2 ] $$$,['greedy'],800.0
1657/C,give a bracket sequence consist $$$ n $$$ character ' ( ' and/or ) ' perform several operations one operation choose shortest prefix string ( amount first character string ) good remove string prefix consider good one follow two condition satisfy : a bracket sequence call regular possible obtain a correct arithmetic expression insert character ' + ' ' 1 ' sequence example sequence ( ( ) ) ( ) ( ) ( ( ) ( ( ) ) ) regular ) ( ( ( ) ( ( ) ) ) ( bracket sequence call palindrome read back forth example bracket sequence ) ) ( ( ) ( ( ) palindromes bracket sequence ( ) ) ( ) ) ( palindromes stop perform operations 's possible find a good prefix task find number operations perform give string number remain character string answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case next $$$ 2 t $$$ line describe test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) — length bracket sequence second line test case contain $$$ n $$$ character ' ( ' and/or ' ) ' — bracket sequence guarantee sum $$$ n $$$ test case exceed $$$ 500000 $$$ ( $$$ \sum n \le 500000 $$$ ) test case print two integers $$$ c $$$ $$$ r $$$ — number operations perform give bracket sequence number character remain string perform operations,"['greedy', 'implementation']",1200.0
1658/D1,easy version problem difference constraints versions color red make hack versions problem solve marin gojou play hide - and - seek array gojou initially perform follow step : marin give value $$$ l r $$$ final array $$$ a $$$ need find secret integer $$$ x $$$ win help ? note may multiple possible $$$ x $$$ gojou could choose marin find possible $$$ x $$$ could result final value $$$ a $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case first line test case contain two integers $$$ l $$$ $$$ r $$$ ( $$$ \color { red } { \boldsymbol { 0 } \boldsymbol { = } \boldsymbol { l } } \le r < 2^ { 17 } $$$ ) second line contain $$$ r - l + 1 $$$ integers $$$ a_1 a_2 \ldots a _ { r - l+1 } $$$ ( $$$ 0 \le a_i < 2^ { 17 } $$$ ) guarantee $$$ a $$$ generate use step perform gojou guarantee sum $$$ r - l + 1 $$$ test case exceed $$$ 2^ { 17 } $$$ test case print integer $$$ x $$$ multiple answer print first test case original array $$$ [ 3 2 1 0 ] $$$ second test case original array $$$ [ 0 3 2 1 ] $$$ third test case original array $$$ [ 2 1 0 ] $$$,"['bitmasks', 'math']",1600.0
1659/B,give a binary string length $$$ n $$$ exactly $$$ k $$$ move one move must select a single bite state bits except bite get flip ( $$$ 0 $$$ become $$$ 1 $$$ $$$ 1 $$$ become $$$ 0 $$$ ) need output lexicographically largest string get use $$$ k $$$ move also output number time select bite multiple ways may output a binary string $$$ a $$$ lexicographically larger a binary string $$$ b $$$ length follow hold : first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case two line first line two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 200000 $$$ ; $$$ 0 \leq k \leq 1000000000 $$$ ) second line a binary string length $$$ n $$$ character either $$$ 0 $$$ $$$ 1 $$$ sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output two line first line contain lexicographically largest string obtain second line contain $$$ n $$$ integers $$$ f_1 f_2 \ldots f_n $$$ $$$ f_i $$$ number time $$$ i $$$ -th bite select sum integers must equal $$$ k $$$ explanation first testcase step show binary string change a move,"['bitmasks', 'greedy', 'strings']",1300.0
1659/E,"undirected connect graph $$$ n $$$ vertices $$$ m $$$ weight edge a walk vertex $$$ u $$$ vertex $$$ v $$$ define a sequence vertices $$$ p_1 p_2 \ldots p_k $$$ ( necessarily distinct ) start $$$ u $$$ end $$$ v $$$ $$$ p_i $$$ $$$ p _ { i+1 } $$$ connect edge $$$ 1 \leq i < k $$$ define length a walk follow : take order sequence edge write weight array , write bitwise every nonempty prefix array length walk mex value formally let us $$$ [ w_1 w_2 \ldots w _ { k-1 } ] $$$ $$$ w_i $$$ weight edge $$$ p_i $$$ $$$ p _ { i+1 } $$$ length walk give $$$ \mathrm { mex } ( \ { w_1 \ w_1\ & w_2 \ \ldots \ w_1\ & <unknown> & \ldots\ & w _ { k-1 } \ } ) $$$ $$$ \ & $$$ denote bitwise operation must process $$$ q $$$ query form u v. query find minimum possible length a walk $$$ u $$$ $$$ v $$$ mex ( minimum exclude ) a set smallest non - negative integer belong set instance : first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 100000 $$$ ; $$$ n-1 \leq m \leq \min { \left ( \frac { n ( n-1 ) } { 2 } , 100000\right ) } $$$ ) next $$$ m $$$ line contain three integers $$$ a $$$ $$$ b $$$ $$$ w $$$ ( $$$ 1 \leq a b \leq n $$$ $$$ a \neq b $$$ ; $$$ 0 \leq w < 2^ { 30 } $$$ ) indicate undirected edge vertex $$$ a $$$ vertex $$$ b $$$ weight $$$ w $$$ input contain self - loops duplicate edge provide graph connect next line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 100000 $$$ ) next $$$ q $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \leq u v \leq n $$$ $$$ u \neq v $$$ ) description query query print one line contain a single integer — answer query follow explanation first example one possible walk first query : $$$ $$$ 1 \overset { 5 } { \rightarrow } 3 \overset { 3 } { \rightarrow } 2 \overset { 1 } { \rightarrow } 1 \overset { 5 } { \rightarrow } 3 \overset { 1 } { \rightarrow } 4 \overset { 2 } { \rightarrow } 5 $$$ $$$ array weight $$$ w= [ <unknown> ] $$$ take bitwise every prefix array get set $$$ \ { <unknown> } $$$ mex set $$$ 2 $$$ get a walk a smaller length ( define statement )","['bitmasks', 'brute force', 'dfs and similar', 'dsu', 'graphs']",2200.0
1666/C,give three point a plane choose segment plane parallel coordinate ax three point become connect total length choose segment minimal possible two point $$$ a $$$ $$$ b $$$ consider connect a sequence point $$$ p_0 = a p_1 \ldots p_k = b $$$ point $$$ p_i $$$ $$$ p _ { i+1 } $$$ lie segment input consist three line describe three point line contain two integers $$$ x $$$ $$$ y $$$ separate a space — coordinate point ( $$$ -1000000000 \le x y \le 1000000000 $$$ ) point pairwise distinct first line output $$$ n $$$ — number segment 100 . next $$$ n $$$ line contain descriptions segment output four integers $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ a line — coordinate endpoints correspond segment ( $$$ -1000000000 \le x_1 y_1 x_2 y_2 \le 1000000000 $$$ ) segment either horizontal vertical guarantee solution give constraints exist point segment example show,"['brute force', 'geometry']",1800.0
1666/F,"little fiona a collection $$$ n $$$ block various size $$$ a_1 a_2 \ldots a_n $$$ $$$ n $$$ even block equal size would like put block one onto another form a fancy stack let $$$ b_1 b_2 \ldots b_n $$$ size block stack top bottom since fiona use block $$$ b_1 b_2 \ldots b_n $$$ must a permutation $$$ a_1 a_2 \ldots a_n $$$ fiona think stack fancy follow condition satisfy : two stack consider different correspond sequence $$$ b_1 b_2 \ldots b_n $$$ differ least one position fiona want know many different fancy stack build block since large number scare fiona find number modulo $$$ 998\,244\,353 $$$ input contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 2500 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ — number block fiona 's disposal ( $$$ 2 \le n \le 5000 $$$ ; $$$ n $$$ even ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ — size block non - decreasing order ( $$$ 1 \le a_1 \le a_2 \le <unknown> \le a_n \le n $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ test case print number ways build a fancy stack modulo $$$ 998\,244\,353 $$$","['combinatorics', 'dp', 'implementation']",2200.0
1667/B,give array $$$ a $$$ consist $$$ n $$$ integers divide $$$ a $$$ continuous non - empty subarrays ( $$$ 2^ { n-1 } $$$ ways ) let $$$ s = <unknown> _ { l+1 } + <unknown> $$$ value a subarray $$$ a_l a _ { l+1 } \ldots a_r $$$ : input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 500000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 500000 $$$ test case print a single integer — maximum sum value get optimal parition test case $$$ 1 $$$ : one optimal partition $$$ [ 1 2 ] $$$ $$$ [ -3 ] $$$ $$$ 1 + 2 > 0 $$$ value $$$ [ 1 2 ] $$$ $$$ 2 $$$ $$$ -3 < 0 $$$ value $$$ [ -3 ] $$$ $$$ -1 $$$ $$$ 2 + ( -1 ) = 1 $$$ test case $$$ 2 $$$ : optimal partition $$$ [ 0 -2 3 ] $$$ $$$ [ -4 ] $$$ sum value $$$ 3 + ( -1 ) = 2 $$$,"['data structures', 'dp']",2100.0
1669/E,give $$$ n $$$ string length $$$ 2 $$$ consist lowercase latin alphabet letter ' a ' ' k ' output number pair indices $$$ ( i j ) $$$ $$$ i < j $$$ $$$ i $$$ -th string $$$ j $$$ -th string differ exactly one position word count number pair $$$ ( i j ) $$$ ( $$$ i < j $$$ ) $$$ i $$$ -th string $$$ j $$$ -th string exactly one position $$$ p $$$ ( $$$ 1 \leq p \leq 2 $$$ ) $$$ { s _ { i } } _ { p } \neq { s _ { j } } _ { p } $$$ answer may fit 32 - bit integer type use 64 - bit integers like long long c++ avoid integer overflow first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number string follow $$$ n $$$ line $$$ i $$$ -th contain a single string $$$ s_i $$$ length $$$ 2 $$$ consist lowercase latin letter ' a ' ' k ' guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print a single integer — number pair $$$ ( i j ) $$$ ( $$$ i < j $$$ ) $$$ i $$$ -th string $$$ j $$$ -th string exactly one position $$$ p $$$ ( $$$ 1 \leq p \leq 2 $$$ ) $$$ { s _ { i } } _ { p } \neq { s _ { j } } _ { p } $$$ please note answer test case wo n't fit 32 - bit integer type use least 64 - bit integer type program language ( like long long c++ ) first test case pair differ exactly one position : ( ` ` ab '' ` ` cb '' ) ( ` ` ab '' ` ` db '' ) ( ` ` ab '' ` ` aa '' ) ( ` ` cb '' ` ` db '' ) ( ` ` cb '' ` ` cc '' ) second test case pair differ exactly one position : ( ` ` aa '' ` ` ac '' ) ( ` ` aa '' ` ` ca '' ) ( ` ` cc '' ` ` ac '' ) ( ` ` cc '' ` ` ca '' ) ( ` ` ac '' ` ` aa '' ) ( ` ` ca '' ` ` aa '' ) third test case pair satisfy condition,"['data structures', 'math', 'strings']",1200.0
167/C,"country live wizards love play number blackboard two number write — a b. order number important let 's consider a ≤ b sake <unknown> players cast one two spell turn : a > b similar move possible least one number equal zero a player ca n't make a move take a remainder modulo zero consider somewhat <unknown> far bore subtract a zero player make a move lose perform well magic <unknown> need learn quickly determine player win wizards play optimally : one move first one move second first line contain a single integer t — number input data set ( 1 ≤ t ≤ 104 ) next t line contain two integers a b ( 0 ≤ a b ≤ 1018 ) number separate a space please use % lld specificator read write 64 - bit integers с++ prefer use cin cout stream % i64d specificator t input set print ` ` first '' ( without quote ) player move first win print ` ` second '' ( without quote ) player move second win print answer different data set different line order give input first sample first player go ( <unknown> ) , a single move second player ( 1,10 ) take 10 modulo 1 win second sample first player two move ( 1,10 ) ( <unknown> ) move second player win third sample first player move fourth sample first player win one move take 30 modulo 10",['math'],2300.0
1670/A,one day prof . slim decide leave kingdom guc join kingdom giu give easy online assessment solve join giu citizens guc happy sad see prof leave decide hack system change online assessment a harder one stay guc a long argument decide change follow problem give array $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ a _ { i } \neq 0 $$$ check make array sort use follow operation number time ( possibly zero ) array sort elements arrange a non - decreasing order prof . slim saw problem still easy n't worth time decide give solve first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 10^ { 5 } $$$ ) — length array $$$ a $$$ next line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \le a _ { i } \le 1000000000 $$$ $$$ a _ { i } \neq 0 $$$ ) separate space describe elements array $$$ a $$$ guarantee sum $$$ n $$$ test case n't exceed $$$ 100000 $$$ test case print ` ` yes '' array sort non - decreasing order otherwise print ` ` '' print letter case ( upper lower ) first test case way make array sort use operation number time second test case array already sort third test case swap sign $$$ 1 $$$ -st element sign $$$ 5 $$$ -th element sign $$$ 3 $$$ -rd element sign $$$ 6 $$$ -th element way array sort fourth test case way make array sort use operation number time,"['greedy', 'implementation', 'sortings']",800.0
1670/D,<unknown> <unknown> infinite hexagonal grid picture control <unknown> <unknown> hosssam love equilateral triangles want create $$$ n $$$ equilateral triangles grid add straight line triangles must empty inside ( word straight line hexagon edge pass triangles ) allow add straight line parallel edge hexagons give $$$ n $$$ minimum number line need add create least $$$ n $$$ equilateral triangles describe ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case $$$ t $$$ test case follow test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 10^ { 9 } $$$ ) — require number equilateral triangles test case print minimum number line need $$$ n $$$ equilateral triangles first second test case 2 line need add first line equilateral triangles create matter add add second line two triangles create third test case minimum need 3 line show,"['binary search', 'brute force', 'geometry', 'greedy', 'implementation', 'math']",1700.0
1671/C,"turbulent time come decide buy sugar advance $$$ n $$$ shop around sell sugar : $$$ i $$$ -th shop sell one pack sugar $$$ a_i $$$ coin one pack one customer day order buy several pack need visit several shop another problem price increase day : first day cost $$$ a_i $$$ second day cost $$$ a_i + 1 $$$ third day — $$$ a_i + 2 $$$ shop $$$ i $$$ contrary everyday budget $$$ x $$$ coin word day go buy many pack possible total cost exceed $$$ x $$$ note n't spend amount coin a day ca n't use coin next days eventually cost pack exceed $$$ x $$$ wo n't able buy even a single pack , many pack able buy till moment total ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next $$$ t $$$ case follow first line test case contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 1 \le x \le 1000000000 $$$ ) — number shop everyday budget second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — initial cost one pack shop 's guarantee total sum $$$ n $$$ n't exceed $$$ 200000 $$$ test case print one integer — total number pack able buy price exceed everyday budget first test case second test case price high even first day ca n't buy anything third test case buy one pack day one fourth test case buy $$$ 2 $$$ pack first $$$ 500 $$$ days day $$$ 501 $$$ price $$$ [ 501 501 ] $$$ buy $$$ 1 $$$ pack next $$$ 500 $$$ days day $$$ 1001 $$$ price $$$ [ 1001 1001 ] $$$ ca n't buy anymore total buy $$$ 1000 + 500 = 1500 $$$ pack","['binary search', 'brute force', 'greedy', 'math']",1200.0
1671/D,give a sequence $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ also give $$$ x $$$ integers $$$ 1 2 \dots x $$$ ask insert extra integers sequence $$$ a $$$ integer insert begin sequence end sequence elements sequence score result sequence $$$ a ' $$$ sum absolute differences adjacent elements $$$ \left ( \sum \limits _ { i=1 } ^ { <unknown> } <unknown> - a ' _ { i+1 } |\right ) $$$ smallest possible score result sequence $$$ a ' $$$ ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \le n x \le 200000 $$$ ) — length sequence number extra integers second line testcase contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 200000 $$$ ) sum $$$ n $$$ testcases n't exceed $$$ 200000 $$$ testcase print a single integer — smallest sum absolute differences adjacent elements sequence insert extra integers sequence smallest score example underline elements extra integers note exist sequence smallest score,"['brute force', 'greedy']",1600.0
1672/B,let 's call a string good length least $$$ 2 $$$ character $$$ \texttt { a } $$$ except last character $$$ \texttt { b } $$$ good string $$$ \texttt { ab } \texttt { aab } \texttt { aaab } \ldots $$$ note $$$ \texttt { b } $$$ a good string give initially empty string $$$ s_1 $$$ perform follow operation number time : give a string $$$ s_2 $$$ turn $$$ s_1 $$$ $$$ s_2 $$$ number operations ? test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case contain a single string $$$ s_2 $$$ ( $$$ 1 \leq |s_2| \leq 200000 $$$ ) guarantee $$$ s_2 $$$ consist character $$$ \texttt { a } $$$ $$$ \texttt { b } $$$ guarantee sum $$$ |s_2| $$$ test case exceed $$$ 200000 $$$ test case print ` ` yes '' ( without quote ) turn $$$ s_1 $$$ $$$ s_2 $$$ number operations ` ` '' ( without quote ) otherwise output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first test case transform $$$ s_1 $$$ : $$$ \varnothing \to \color { red } { \texttt { aab } } \to \texttt { a } \color { red } { \texttt { ab } } \texttt { ab } $$$ third test case transform $$$ s_1 $$$ : $$$ \varnothing \to \color { red } { \texttt { <unknown> } } $$$ second fourth test case show impossible turn $$$ s_1 $$$ $$$ s_2 $$$,['implementation'],800.0
1674/A,give two integers $$$ x $$$ $$$ y $$$ want choose two strictly positive ( greater zero ) integers $$$ a $$$ $$$ b $$$ apply follow operation $$$ x $$$ exactly $$$ a $$$ time : replace $$$ x $$$ $$$ b \cdot x $$$ want find two positive integers $$$ a $$$ $$$ b $$$ $$$ x $$$ become equal $$$ y $$$ process multiple possible pair choose pair report example : first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist one line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le 100 $$$ ) possible choose a pair positive integers $$$ a $$$ $$$ b $$$ $$$ x $$$ become $$$ y $$$ aforementioned process print two integers integers print less $$$ 1 $$$ greater $$$ 1000000000 $$$ ( show answer exist a pair integers $$$ a $$$ $$$ b $$$ meet constraints ) multiple pair print impossible choose a pair integers $$$ a $$$ $$$ b $$$ $$$ x $$$ become $$$ y $$$ print integer $$$ 0 $$$ twice,['math'],800.0
1675/A,pet store sale : polycarp $$$ x $$$ dog $$$ y $$$ cat possible able buy food animals store ? dog cat receive one pack suitable food first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case input $$$ t $$$ line give contain a description one test case description consist five integers $$$ a b c x $$$ $$$ y $$$ ( $$$ 0 \le a b c x y \le 100000000 $$$ ) test case a separate line output : output yes case ( example string yes yes yes yes recognize a positive response ),"['greedy', 'math']",800.0
1675/D,"give a root tree consist $$$ n $$$ vertices vertices number $$$ 1 $$$ $$$ n $$$ vertex root a tree a tree a connect undirected graph without cycle a root tree a tree a select vertex call root tree specify array parent $$$ p $$$ contain $$$ n $$$ number : $$$ p_i $$$ a parent vertex index $$$ i $$$ parent a vertex $$$ u $$$ a vertex next vertex shortest path $$$ u $$$ root example simple path $$$ 5 $$$ $$$ 3 $$$ ( root ) next vertex would $$$ 1 $$$ parent $$$ 5 $$$ $$$ 1 $$$ root parent , value $$$ p_i $$$ $$$ i $$$ ( root vertex $$$ p_i = i $$$ ) find a set paths : example $$$ n=5 $$$ $$$ p= [ 3 1 3 3 1 ] $$$ tree divide three paths : first line input data contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test test case consist two line first contain integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) number vertices tree second line contain $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) guarantee $$$ p $$$ array encode root tree guarantee sum value $$$ n $$$ test case test exceed $$$ 200000 $$$ test case first line output integer $$$ m $$$ — minimum number non - intersecting lead paths cover vertices tree print $$$ m $$$ pair line contain path descriptions first print length path second — sequence vertices specify path order top bottom output paths order several answer output","['graphs', 'implementation', 'trees']",1300.0
1677/A,"tokitsukaze a permutation $$$ p $$$ length $$$ n $$$ recall a permutation $$$ p $$$ length $$$ n $$$ a sequence $$$ p_1 p_2 \ldots p_n $$$ consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ ( $$$ 1 \leq p_i \leq n $$$ ) want know many different indices tuples $$$ [ a b c d ] $$$ ( $$$ 1 \leq a < b < c < d \leq n $$$ ) permutation satisfy follow two inequalities : note two tuples $$$ [ a_1 b_1 c_1 d_1 ] $$$ $$$ [ a_2 b_2 c_2 d_2 ] $$$ consider different $$$ a_1 \ne a_2 $$$ $$$ b_1 \ne b_2 $$$ $$$ c_1 \ne c_2 $$$ $$$ d_1 \ne d_2 $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case test case consist two line first line contain a single integer $$$ n $$$ ( $$$ 4 \leq n \leq 5000 $$$ ) — length permutation $$$ p $$$ second line contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \leq p_i \leq n $$$ ) — permutation $$$ p $$$ guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ test case print a single integer — number different $$$ [ a b c d ] $$$ tuples first test case $$$ 3 $$$ different $$$ [ a b c d ] $$$ tuples $$$ p_1 = 5 $$$ $$$ p_2 = 3 $$$ $$$ p_3 = 6 $$$ $$$ p_4 = 1 $$$ $$$ p_1 < p_3 $$$ $$$ p_2 > p_4 $$$ satisfy inequality one $$$ [ a b c d ] $$$ tuples $$$ [ 1,2,3,4 ] $$$ similarly two tuples $$$ [ <unknown> ] $$$ $$$ [ <unknown> ] $$$","['brute force', 'data structures', 'dp']",1600.0
1677/B,"tokitsukaze arrange a meet $$$ n $$$ row $$$ m $$$ columns seat meet hall exactly $$$ n \cdot m $$$ students attend meet include several naughty students several serious students students numerate $$$ 1 $$$ $$$ n\cdot m $$$ students enter meet hall order $$$ i $$$ -th student enter meet hall sit $$$ 1 $$$ -st column $$$ 1 $$$ -st row students already seat move back one seat specifically student sit $$$ j $$$ -th ( $$$ 1\leq j \leq m-1 $$$ ) column $$$ i $$$ -th row move $$$ ( j+1 ) $$$ -th column $$$ i $$$ -th row student sit $$$ m $$$ -th column $$$ i $$$ -th row move $$$ 1 $$$ -st column $$$ ( i+1 ) $$$ -th row example a meet hall $$$ 2 $$$ row $$$ 2 $$$ columns seat show : $$$ 4 $$$ students enter meet hall order represent a binary string ` ` 1100 '' ' 0 ' represent naughty students ' 1 ' represent serious students change seat meet hall follow : denote a row a column good least one serious student row column please predict number good row columns $$$ i $$$ -th student enter meet hall $$$ i $$$ first contain a single positive integer $$$ t $$$ ( $$$ 1 \leq t \leq 10\,000 $$$ ) — number test case test case first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 1000000 $$$ ; $$$ 1 \leq n \cdot m \leq 1000000 $$$ ) denote $$$ n $$$ row $$$ m $$$ columns seat meet hall second line contain a binary string $$$ s $$$ length $$$ n \cdot m $$$ consist zero ones $$$ s_i $$$ equal ' 0 ' represent $$$ i $$$ -th student a naughty student $$$ s_i $$$ equal ' 1 ' represent $$$ i $$$ -th student a serious student guarantee sum $$$ n \cdot m $$$ test case exceed $$$ 1000000 $$$ test case print a single line $$$ n \cdot m $$$ integers — number good row columns $$$ i $$$ -th student enter meet hall first test case show statement $$$ 1 $$$ -st student enter meet hall $$$ 2 $$$ good row columns : $$$ 1 $$$ -st row $$$ 1 $$$ -st column $$$ 2 $$$ -nd student enter meet hall $$$ 3 $$$ good row columns : $$$ 1 $$$ -st row $$$ 1 $$$ -st column $$$ 2 $$$ -nd column $$$ 3 $$$ -rd student enter meet hall $$$ 4 $$$ row columns good $$$ 4 $$$ -th student enter meet hall $$$ 3 $$$ good row columns : $$$ 2 $$$ -nd row $$$ 1 $$$ -st column $$$ 2 $$$ -nd column","['data structures', 'implementation', 'math']",1700.0
1679/C,"a square chessboard size $$$ n \times n $$$ row number top bottom number $$$ 1 $$$ $$$ n $$$ columns — leave right number $$$ 1 $$$ $$$ n $$$ , cell denote pair integers $$$ ( x y ) $$$ ( $$$ 1 \le x y \le n $$$ ) $$$ x $$$ a row number $$$ y $$$ a column number perform $$$ q $$$ query three type : subrectangle a set cells $$$ ( x y ) $$$ cell two condition satisfy : $$$ x_1 \le x \le x_2 $$$ $$$ y_1 \le y \le y_2 $$$ recall cell $$$ ( a b ) $$$ attack a rook place cell $$$ ( c d ) $$$ either $$$ a = c $$$ $$$ b = d $$$ particular cell contain a rook attack rook first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 1 \le q \le 200000 $$$ ) — size chessboard number query respectively follow $$$ q $$$ line contain description a query description begin integer $$$ t $$$ ( $$$ t \in \ { 1 2 3\ } $$$ ) denote type a query : 's guarantee among $$$ q $$$ query least one query third type print answer query third type a separate line print ` ` yes '' ( without quote ) cell subrectangle attack least one rook otherwise print ` ` '' ( without quote ) consider example first two query board look like follow picture ( letter $$$ r $$$ denote cells rook locate subrectangle query third type highlight green ) : chessboard perform third fourth query : chessboard perform fifth sixth query : chessboard perform seventh eighth query : chessboard perform last two query :","['data structures', 'implementation']",1400.0
168/B,"let 's dive one interest areas magic — write spell learn excite challenge science troublesome learn magic word get know basic rule write spell spell consist several line line whose first non - space character character ` ` # '' amplify line responsible spell power remain line common determine effect spell come across text spell spell long understand mean want make short possible without change mean way shorten a spell know removal space line break know come texts spell space carry mean amplify line remove space line newlines also matter unless two separate line amplify thus two consecutive line amplify need join one ( i.e concatenate second line first one ) remove space amplify line concatenate amplify line anything forbid note empty line must process like others : must join adjacent non - <unknown> line preserve output surround amplify line side ( i.e line one amplify line one amplify ) instructions remove unnecessary character follow ( oh yes a newline a character ) input contain text spell reduce remove extra character print result output input contain multiple line character line cod 32 127 ( inclusive ) please note line may begin end one space size input exceed <unknown> ( = 220 ) bytes newlines include size windows operate system use test computer a newline a sequence character cod # 13 # 10 guarantee line input a newline particular input end a newline note newline end line begin next one guarantee input contain least one character a newline recommend organize input - output line line case newlines process correctly language mean print text spell extra character delete please note output line follow a newline please careful : answer validate compare jury 's answer byte - by - byte , space newlines matter first sample amplify line line 1 7 . line 2 6 concatenate space delete second sample amplify line line 1 3 . line concatenate","['implementation', 'strings']",1700.0
1681/E,find a map a <unknown> shape labyrinth map a grid consist $$$ n $$$ row $$$ n $$$ columns row grid number $$$ 1 $$$ $$$ n $$$ bottom top columns grid number $$$ 1 $$$ $$$ n $$$ leave right labyrinth $$$ n $$$ layer first layer bottom leave corner ( cell $$$ ( 1 1 ) $$$ ) second layer consist cells grid adjacent first layer a side a corner third layer consist cells grid adjacent second layer a side a corner   labyrinth $$$ 5 $$$ layer example shape follow : layer separate one another wall however doors wall layer ( except layer $$$ n $$$ ) exactly two doors next layer one door place top wall layer another door place right wall layer layer $$$ 1 $$$ $$$ n-1 $$$ give position two doors doors pass directions : either layer $$$ i $$$ layer $$$ i+1 $$$ layer $$$ i+1 $$$ layer $$$ i $$$ stand cell move adjacent a side cell a wall n't block move ( e.g ca n't move a cell another layer door cells ) $$$ m $$$ query sort : 's minimum number move one make go cell $$$ ( x_1 y_1 ) $$$ cell $$$ ( x_2 y_2 ) $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — number layer labyrinth $$$ i $$$ -th next $$$ n-1 $$$ line contain four integers $$$ d _ { 1 x } d _ { 1 y } d _ { 2 x } $$$ $$$ d _ { 2 y } $$$ ( $$$ 1 \le d _ { 1 x } d _ { 1 y } d _ { 2 x } d _ { 2 y } \le n $$$ ) — coordinate doors cells $$$ i $$$ -th layer first cell adjacent top wall $$$ i $$$ -th layer a side — side door second cell adjacent right wall $$$ i $$$ -th layer a side — side door next line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 200000 $$$ ) — number query $$$ j $$$ -th next $$$ m $$$ line contain four integers $$$ x_1 y_1 x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \le x_1 y_1 x_2 y_2 \le n $$$ ) — coordinate cells $$$ j $$$ -th query query print a single integer — minimum number move one make go cell $$$ ( x_1 y_1 ) $$$ cell $$$ ( x_2 y_2 ) $$$ map labyrinth second example doors mark red,"['data structures', 'dp', 'shortest paths']",2600.0
1681/F,give a tree consist $$$ n $$$ vertices edge integer value write let $$$ f ( v u ) $$$ number value appear exactly edge a simple path vertices $$$ v $$$ $$$ u $$$ calculate sum $$$ f ( v u ) $$$ pair vertices $$$ v $$$ $$$ u $$$ $$$ 1 \le v < u \le n $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 500000 $$$ ) — number vertices tree next $$$ n-1 $$$ line contain three integers $$$ v u $$$ $$$ x $$$ ( $$$ 1 \le v u x \le n $$$ ) — description edge : vertices connect value write give edge form a tree print a single integer — sum $$$ f ( v u ) $$$ pair vertices $$$ v $$$ $$$ u $$$ $$$ v < u $$$,"['data structures', 'dfs and similar', 'divide and conquer', 'dp', 'dsu', 'trees']",2300.0
1682/F,give two integer array $$$ a $$$ $$$ b $$$ ( $$$ b_i \neq 0 $$$ $$$ |b_i| \leq 1000000000 $$$ ) array $$$ a $$$ sort non - decreasing order cost a subarray $$$ a [ l : r ] $$$ define follow : $$$ \sum\limits _ { j = l } ^ { r } b_j \neq 0 $$$ cost define otherwise : give $$$ q $$$ query form two integers $$$ l $$$ $$$ r $$$ compute cost subarray $$$ a [ l : r ] $$$ query modulo $$$ 1000000000 + 7 $$$ n't know minimum cost maximum flow mean read first line input contain two integers $$$ n $$$ $$$ q $$$ $$$ ( 2 \leq n \leq 2\cdot 100000 1 \leq q \leq 2\cdot100000 ) $$$ — length array $$$ a $$$ $$$ b $$$ number query next line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_1 \le a_2 \ldots \le a_n \leq 1000000000 ) $$$ — array $$$ a $$$ guarantee $$$ a $$$ sort non - decreasing order next line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ $$$ ( -1000000000\leq b_i \leq 1000000000 b_i \neq 0 ) $$$ — array $$$ b $$$ $$$ i $$$ -th next $$$ q $$$ line contain two integers $$$ l_i r_i $$$ $$$ ( 1\leq l_i \leq r_i \leq n ) $$$ guarantee $$$ \sum\limits _ { j = l_i } ^ { r_i } b_j = 0 $$$ query $$$ l_i $$$ $$$ r_i $$$ — print cost subarray $$$ a [ l_i : r_i ] $$$ modulo $$$ 1000000000 + 7 $$$ first query maximum possible flow $$$ 1 $$$ i.e one unit source $$$ 2 $$$ one unit $$$ 2 $$$ $$$ 3 $$$ one unit $$$ 3 $$$ sink cost flow $$$ 0 + |2 - 4| \cdot 1 + 0 = 2 $$$ second query maximum possible flow $$$ 1 $$$ i.e source $$$ 7 $$$ $$$ 7 $$$ $$$ 6 $$$ $$$ 6 $$$ sink a cost $$$ 0 \cdot |10 - 10| \cdot 1 + 0 = 0 $$$ third query flow network show leave capacity write edge cost write bracket image right show flow edge optimal configuration fourth query flow network look – minimum cost maximum flow achieve configuration – maximum flow network 4 minimum cost flow 15,"['data structures', 'graphs', 'greedy', 'sortings', 'two pointers']",2700.0
1684/E,give array $$$ a $$$ $$$ n $$$ non - negative integers one operation change number array non - negative integer let 's define cost array $$$ \operatorname { diff } ( a ) - \operatorname { mex } ( a ) $$$ $$$ \operatorname { mex } $$$ a set non - negative integers smallest non - negative integer present set $$$ \operatorname { diff } $$$ number different number array example $$$ \operatorname { mex } ( \ { 1 2 3\ } ) = 0 $$$ $$$ \operatorname { mex } ( \ { 0 1 2 4 5\ } ) = 3 $$$ find minimal cost array $$$ a $$$ allow make $$$ k $$$ operations input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 0 \le k \le 100000 $$$ ) — length array $$$ a $$$ number operations allow make second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — elements array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output a single integer — minimal cost possible get make $$$ k $$$ operations first test case operations need minimize value $$$ \operatorname { diff } - \operatorname { mex } $$$ second test case possible replace $$$ 5 $$$ $$$ 1 $$$ array $$$ a $$$ $$$ [ 0 \ 2 \ 4 \ 1 ] $$$ $$$ \operatorname { diff } = 4 $$$ $$$ \operatorname { mex } = \operatorname { mex } ( \ { 0 1 2 4\ } ) = 3 $$$ answer $$$ 1 $$$ third test case one possible array $$$ a $$$ $$$ [ 4 \ 13 \ 0 \ 0 \ 13 \ 1 \ 2 ] $$$ $$$ \operatorname { diff } = 5 $$$ $$$ \operatorname { mex } = 3 $$$ fourth test case one possible array $$$ a $$$ $$$ [ 1 \ 2 \ 3 \ 0 \ 0 \ 0 ] $$$,"['binary search', 'brute force', 'data structures', 'greedy', 'two pointers']",2100.0
1687/A,"marisa come pick mushroom enchant forest enchant forest represent $$$ n $$$ point $$$ x $$$ -axis number $$$ 1 $$$ $$$ n $$$ marisa start friend patchouli use magic detect initial number mushroom point represent $$$ a_1 a_2 \ldots a_n $$$ marisa start point forest minute $$$ 0 $$$ minute follow happen order : note collect mushroom minute $$$ 0 $$$ , marisa want know maximum number mushroom pick $$$ k $$$ minutes test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 20 ^ 5 $$$ $$$ 1\le k \le 1000000000 $$$ ) — number position mushroom time marisa respectively second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — initial number mushroom point $$$ 1,2 \ldots n $$$ guarantee sum $$$ n $$$ test case exceed $$$ 20 ^ 5 $$$ test case print maximum number mushroom marisa pick $$$ k $$$ minutes test case 1 : marisa start $$$ x=2 $$$ first minute move $$$ x=1 $$$ collect $$$ 5 $$$ mushroom number mushroom $$$ [ <unknown> ] $$$ second minute move $$$ x=2 $$$ collect $$$ 7 $$$ mushroom number mushroom $$$ [ <unknown> ] $$$ $$$ 2 $$$ minutes marisa collect $$$ 12 $$$ mushroom show impossible collect $$$ 12 $$$ mushroom test case 2 : one possible move path : $$$ 2 \rightarrow 3 \rightarrow 2 \rightarrow 1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 5 $$$ show impossible collect $$$ 37 $$$ mushroom","['brute force', 'greedy']",1600.0
1687/F,"<unknown> <unknown> permute $$$ n $$$ number : $$$ 1 2 \ldots n $$$ think permutation $$$ p $$$ beautiful $$$ <unknown> _ { i=1 } ^ { n-1 } [ <unknown> = p _ { i+1 } ] $$$ $$$ [ x ] $$$ equal $$$ 1 $$$ $$$ x $$$ hold $$$ 0 $$$ otherwise $$$ <unknown> [ 0 n-1 ] $$$ want know number beautiful permutations length $$$ n $$$ satisfy $$$ <unknown> _ { i=1 } ^ { n-1 } [ p_i < p _ { i+1 } ] $$$ one line contain two intergers $$$ n $$$ ( $$$ 1 \leq n \leq 250\,000 $$$ ) $$$ s $$$ ( $$$ 0 \leq s < n $$$ ) print one line $$$ n $$$ intergers $$$ i $$$ -th integers represent answer $$$ k = i-1 $$$ modulo $$$ 998244353 $$$ let $$$ f ( p ) = \sum\limits _ { i=1 } ^ { n-1 } [ p_i < p _ { i+1 } ] $$$ testcase 1 : $$$ [ 2,1 ] $$$ beautiful permutation $$$ f ( [ 2,1 ] ) = 0 $$$ testcase 2 : beautiful permutations : $$$ [ 1,2,4,3 ] $$$ $$$ [ 1,3,4,2 ] $$$ $$$ [ 1,4,2,3 ] $$$ $$$ [ 2,1,3,4 ] $$$ $$$ [ 2,3,1,4 ] $$$ $$$ [ 3,1,2,4 ] $$$ $$$ [ 3,4,2,1 ] $$$ $$$ [ <unknown> ] $$$ $$$ [ 4,3,1,2 ] $$$ first six satisfy $$$ f ( p ) = 2 $$$ others satisfy $$$ f ( p ) = 1 $$$",['math'],3500.0
1689/B,"monocarp a little boy live byteland love program recently find a permutation length $$$ n $$$ come a mystic permutation a new permutation differ old one position formally old permutation $$$ p_1 p_2 \ldots p_n $$$ new one $$$ q_1 q_2 \ldots q_n $$$ must hold $$$ $$$ <unknown> q_1 <unknown> q_2 \ldots <unknown> q_n $$$ $$$ monocarp afraid lexicographically large permutations please help find lexicographically minimal mystic permutation ? several test case input data first line contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 200 $$$ ) — number test case follow test case description first line test case contain a positive integer $$$ n $$$ ( $$$ 1\leq n\leq 1000 $$$ ) — length permutation second line test case contain $$$ n $$$ distinct positive integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \leq p_i \leq n $$$ ) 's guarantee $$$ p $$$ a permutation i. e. $$$ p_i \neq p_j $$$ $$$ i \neq j $$$ guarantee sum $$$ n $$$ exceed $$$ 1000 $$$ test case test case output $$$ n $$$ positive integers — lexicographically minimal mystic permutations a permutation exist output $$$ -1 $$$ instead first test case possible permutations mystic $$$ [ 2,3,1 ] $$$ $$$ [ 3,1,2 ] $$$ lexicographically smaller two $$$ [ 2,3,1 ] $$$ second test case $$$ [ 1,2,3,4,5 ] $$$ lexicographically minimal permutation also mystic third test case possible mystic permutations $$$ [ 1,2,4,3 ] $$$ $$$ [ 1,4,2,3 ] $$$ $$$ [ 1,4,3,2 ] $$$ $$$ [ 3,1,4,2 ] $$$ $$$ [ 3,2,4,1 ] $$$ $$$ [ 3,4,2,1 ] $$$ $$$ [ 4,1,2,3 ] $$$ $$$ [ <unknown> ] $$$ $$$ [ <unknown> ] $$$ smallest one $$$ [ 1,2,4,3 ] $$$","['data structures', 'greedy']",900.0
1690/E,a batch $$$ n $$$ goods ( $$$ n $$$ — even number ) bring store $$$ i $$$ -th weight $$$ a_i $$$ sell goods must pack package pack follow do : cost a package weight $$$ x $$$ always $$$ \left \lfloor\frac { x } { k } \right\rfloor $$$ burl ( round ) $$$ k $$$ — a fix give value pack goods package revenue sale maximize word make $$$ \frac { n } { 2 } $$$ pair give goods sum value $$$ \left \lfloor\frac { x_i } { k } \right \rfloor $$$ $$$ x_i $$$ weight package number $$$ i $$$ ( $$$ 1 \le i \le \frac { n } { 2 } $$$ ) maximal example let $$$ n = 6 k = 3 $$$ weight goods $$$ a = [ 3 2 7 1 4 8 ] $$$ let 's pack follow package pack total cost pack would $$$ 5 + 2 + 1 = 8 $$$ burl first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — the number test case test descriptions test case follow first line test case contain two integers $$$ n $$$ ( $$$ 2 \le n \le 2\cdot100000 $$$ ) $$$ k $$$ ( $$$ 1 \le k \le 1000 $$$ ) number $$$ n $$$ — even second line test case contain exactly $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ test case print a separate line a single number — maximum possible total cost package first test case analyze statement second test case get a total value equal $$$ 4 $$$ put first second goods first package third fourth goods second package third test case cost item $$$ 0 $$$ total cost also $$$ 0 $$$,"['binary search', 'greedy', 'math', 'two pointers']",1500.0
1690/G,$$$ n $$$ independent carriages rail carriages number leave right $$$ 1 $$$ $$$ n $$$ carriages connect carriages move leave carriage number $$$ 1 $$$ move ahead $$$ i $$$ -th carriage engine accelerate carriage $$$ a_i $$$ km / h carriage go faster carriage front see example explanation carriages start move leave time naturally form train call train — consecutive move carriages speed example $$$ n=5 $$$ carriages array $$$ a = [ 10 13 5 2 6 ] $$$ final speed carriages $$$ [ 10 10 5 2 2 ] $$$ respectively $$$ 3 $$$ train form also message say engine corrupt : message arrive sequentially process next message take account change previous message message determine number form train first line input data contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — the number input test case follow descriptions test case first line test case empty second line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100000 $$$ ) — the number carriages number message slow carriage respectively third line contain $$$ n $$$ integers : $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — number $$$ a_i $$$ mean carriage number $$$ i $$$ reach a speed $$$ a_i $$$ km / h next $$$ m $$$ line contain two integers $$$ k_j $$$ $$$ d_j $$$ ( $$$ 1 \le k_j \le n $$$ $$$ 0 \le d_j \le a _ { k_j } $$$ ) — <unknown> message speed carriage number $$$ k_j $$$ decrease $$$ d_j $$$ word a change maximum speed $$$ a _ { k_j } = a _ { k_j } - d_j $$$ note time speed carriage non - negative word $$$ a_i \ge s_i $$$ $$$ s_i $$$ — is sum $$$ d_j $$$ $$$ k_j = i $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ similarly guarantee sum $$$ m $$$ test case exceed $$$ 100000 $$$ print $$$ t $$$ line line print answer correspond test case test case print $$$ m $$$ number : number train form message first test case : second test case :,"['binary search', 'data structures', 'greedy', 'sortings']",2000.0
1693/A,array length $$$ n $$$ initially element equal $$$ 0 $$$ a pointer locate first element follow two kinds operations number time ( possibly zero ) order : one additional rule do pointer first element give array $$$ a $$$ determine whether 's possible obtain $$$ a $$$ operations first line contain a single integer $$$ t $$$ $$$ ( 1\le t\le 1000 ) $$$ — number test case description test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 1\le n\le 2 \cdot 100000 ) $$$ — size array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) — elements array guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print ` ` yes '' ( without quote ) 's possible obtain $$$ a $$$ operations ` ` '' ( without quote ) otherwise output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first test case obtain array operations pointer wo n't first element one way obtain array second test case show $$$ \langle \underline { 0 } 0 0 0\rangle \to \langle 1 \underline { 0 } 0 0 \rangle \to \langle \underline { 1 } -1 0 0\rangle \to \langle 2 \underline { -1 } 0 0\rangle \to \langle 2 0 \underline { 0 } 0\rangle \to \langle 2 \underline { 0 } -1 0\rangle \to \langle \underline { 2 } -1 -1 0\rangle $$$,['greedy'],1300.0
1694/A,define score binary string $$$ t $$$ absolute difference number zero ones ( example $$$ t= $$$ <unknown> contain $$$ 4 $$$ zero $$$ 2 $$$ ones score $$$ t $$$ $$$ |4 - 2| = 2 $$$ ) define creepiness binary string $$$ s $$$ maximum score among prefix ( example creepiness $$$ s= $$$ <unknown> equal $$$ 2 $$$ score prefix $$$ s [ 1 \ldots 4 ] $$$ $$$ 2 $$$ rest prefix a score $$$ 2 $$$ less ) give two integers $$$ a $$$ $$$ b $$$ construct a binary string consist $$$ a $$$ zero $$$ b $$$ ones minimum possible creepiness first line contain a single integer $$$ t $$$ $$$ ( 1\le t\le 1000 ) $$$ — number test case description test case follow line test case contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le 100 $$$ ) — number zero ones correspondingly test case print a binary string consist $$$ a $$$ zero $$$ b $$$ ones minimum possible creepiness multiple answer print first test case score $$$ s [ 1 \ldots 1 ] $$$ $$$ 1 $$$ score $$$ s [ 1 \ldots 2 ] $$$ $$$ 0 $$$ second test case minimum possible creepiness $$$ 1 $$$ one answer 101 . third test case minimum possible creepiness $$$ 3 $$$ one answer <unknown>,"['greedy', 'implementation']",800.0
1694/B,let 's call a binary string $$$ t $$$ length $$$ m $$$ index $$$ 1 $$$ $$$ m $$$ paranoid obtain a string length $$$ 1 $$$ perform follow two kinds operations $$$ m-1 $$$ time order : example $$$ t = $$$ 001 select substring $$$ [ <unknown> ] $$$ perform first operation obtain $$$ t = $$$ 01 . give a binary string $$$ s $$$ length $$$ n $$$ index $$$ 1 $$$ $$$ n $$$ find number pair integers $$$ ( l r ) $$$ $$$ 1 \le l \le r \le n $$$ $$$ s [ l \ldots r ] $$$ ( substring $$$ s $$$ $$$ l $$$ $$$ r $$$ ) a paranoid string first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — size $$$ s $$$ second line test case contain a binary string $$$ s $$$ $$$ n $$$ character $$$ s_1s_2 \ldots s_n $$$ ( $$$ s_i = $$$ 0 $$$ s_i = $$$ 1 $$$ 1 \le i \le n $$$ ) guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case output number pair integers $$$ ( l r ) $$$ $$$ 1 \le l \le r \le n $$$ $$$ s [ l \ldots r ] $$$ ( substring $$$ s $$$ $$$ l $$$ $$$ r $$$ ) a paranoid string first sample $$$ s $$$ already length $$$ 1 $$$ n't need operations second sample substrings $$$ s $$$ paranoid entire string 's enough perform first operation third sample substrings $$$ s $$$ paranoid except $$$ [ <unknown> ] $$$ ca n't perform operations $$$ [ s_1s_2s_3 ] $$$ ( entire string ),['greedy'],1200.0
1696/B,"a collection integers $$$ s $$$ define $$$ \operatorname { mex } ( s ) $$$ smallest non - negative integer appear $$$ s $$$ nit cleaver decide destroy universe powerful thanos destroy universe snap finger several time universe represent a 1 - indexed array $$$ a $$$ length $$$ n $$$ nit snap finger follow operation array : say universe destroy $$$ 1\le i\le n $$$ $$$ a_i=0 $$$ hold find minimum number time nit need snap finger destroy universe , find minimum number operations nit need perform make elements array equal $$$ 0 $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1\le n\le 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a_n $$$ ( $$$ 0\le a_i\le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case print one integer — answer problem first test case $$$ 0 $$$ operations elements array already equal $$$ 0 $$$ second test case one optimal way operation $$$ l=2 $$$ $$$ r=5 $$$ third test case one optimal way operation twice respectively $$$ l=4 $$$ $$$ r=4 $$$ $$$ l=2 $$$ $$$ r=6 $$$ fourth test case one optimal way operation $$$ l=1 $$$ $$$ r=1 $$$",['greedy'],900.0
1697/C,give two string $$$ s $$$ $$$ t $$$ length $$$ n $$$ character string ' a ' ' b ' ' c ' one move perform one follow action : allow perform arbitrary amount move ( possibly zero ) change string $$$ s $$$ make equal string $$$ t $$$ ? first line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 10000 $$$ ) — number testcases first line testcase contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length string $$$ s $$$ $$$ t $$$ second line contain string $$$ s $$$ length $$$ n $$$ character ' a ' ' b ' ' c ' third line contain string $$$ t $$$ length $$$ n $$$ character ' a ' ' b ' ' c ' sum $$$ n $$$ testcases n't exceed $$$ 100000 $$$ testcase print ` ` yes '' change string $$$ s $$$ make equal string $$$ t $$$ perform arbitrary amount move ( possibly zero ) otherwise print ` ` '',"['binary search', 'data structures', 'greedy', 'implementation', 'strings', 'two pointers']",1400.0
1697/F,ask build array $$$ a $$$ consist $$$ n $$$ integers element $$$ 1 $$$ $$$ k $$$ array non - decreasing ( $$$ a_i \le a _ { i+1 } $$$ $$$ i $$$ $$$ 1 $$$ $$$ n-1 $$$ ) also give additional constraints constraint one three follow type : build non - decreasing array satisfy constraints report array exist first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain three integers $$$ n m $$$ $$$ k $$$ ( $$$ 2 \le n \le 20000 $$$ ; $$$ 0 \le m \le 20000 $$$ ; $$$ 2 \le k \le 10 $$$ ) $$$ i $$$ -th next $$$ m $$$ line contain a description a constraint constraint one three follow type : sum $$$ n $$$ testcases n't exceed $$$ 20000 $$$ sum $$$ m $$$ testcases n't exceed $$$ 20000 $$$ testcase determine exist a non - decreasing array satisfy condition array print -1 . otherwise print valid array — $$$ n $$$ integers $$$ 1 $$$ $$$ k $$$,"['graphs', 'implementation']",2800.0
1698/A,array $$$ a $$$ $$$ n-1 $$$ integers let $$$ x $$$ bitwise xor elements array number $$$ x $$$ add end array $$$ a $$$ ( length $$$ n $$$ ) elements shuffle give newly form array $$$ a $$$ $$$ x $$$ ? multiple possible value $$$ x $$$ output input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) — number integers result array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 127 $$$ ) — elements newly form array $$$ a $$$ additional constraint input : array $$$ a $$$ make process describe statement ; value $$$ x $$$ exist test case output a single integer — value $$$ x $$$ describe statement multiple possible value $$$ x $$$ output first test case one possible array $$$ a $$$ $$$ a= [ 2 5 4 ] $$$ $$$ x = 2 \oplus 5 \oplus 4 = 3 $$$ ( $$$ \oplus $$$ denote bitwise xor ) new array $$$ [ 2 5 4 3 ] $$$ afterwards array shuffle form $$$ [ 4 3 2 5 ] $$$ second test case one possible array $$$ a $$$ $$$ a= [ 1 10 6 10 ] $$$ $$$ x = 1 \oplus 10 \oplus 6 \oplus 10 = 7 $$$ new array $$$ [ 1 10 6 10 7 ] $$$ afterwards array shuffle form $$$ [ 6 1 10 7 10 ] $$$ third test case elements array equal $$$ 6 $$$ $$$ x=6 $$$ fourth test case one possible array $$$ a $$$ $$$ a= [ 100 100 ] $$$ $$$ x = 100 \oplus 100 = 0 $$$ new array $$$ [ 100 100 0 ] $$$ afterwards array shuffle form $$$ [ 100 100 0 ] $$$ ( note shuffle array remain . ),"['bitmasks', 'brute force']",800.0
1698/B,"$$$ n $$$ pile sand $$$ i $$$ -th pile $$$ a_i $$$ block sand $$$ i $$$ -th pile call tall $$$ 1 < i < n $$$ $$$ a_i > a _ { i-1 } + a _ { i+1 } $$$ , a pile tall sand two neighbour combine ( note pile end array tall ) give integer $$$ k $$$ operation consist pick $$$ k $$$ consecutive pile sand add one unit sand formally pick $$$ 1 \leq l r \leq n $$$ $$$ r - l+1 = k $$$ $$$ l \leq i \leq r $$$ update $$$ a_i <unknown> a_i+1 $$$ maximum number pile simultaneously tall ( possibly zero ) operations ? input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 3 \leq n \leq 200000 $$$ ; $$$ 1 \leq k \leq n $$$ ) — number pile sand size operation respectively second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — size pile guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a single integer — maximum number pile simultaneously tall ( possibly zero ) operations first test case perform follow three operations : second test case operation increase pile $$$ 1 $$$ unit number tall pile always $$$ 0 $$$ third test case increase pile $$$ 1 $$$ unit sand show maximum number tall pile $$$ 1 $$$","['greedy', 'implementation']",800.0
1699/A,give a positive integer $$$ n $$$ task find three integers $$$ a $$$ $$$ b $$$ $$$ c $$$ ( $$$ 0 \le a b c \le 1000000000 $$$ ) $$$ ( a\oplus b ) + ( b\oplus c ) + ( a\oplus c ) = n $$$ determine integers $$$ a \oplus b $$$ denote bitwise xor $$$ a $$$ $$$ b $$$ example $$$ 2 \oplus 4 = 6 $$$ $$$ 3 \oplus 1=2 $$$ test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow line contain descriptions test case line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) test case print three integers $$$ a $$$ $$$ b $$$ $$$ c $$$ ( $$$ 0 \le a b c \le 1000000000 $$$ ) $$$ ( a\oplus b ) + ( b\oplus c ) + ( a\oplus c ) = n $$$ integers exist print $$$ -1 $$$ first test case $$$ a=3 $$$ $$$ b=3 $$$ $$$ c=1 $$$ $$$ ( 3 \oplus 3 ) + ( 3 \oplus 1 ) + ( 3 \oplus 1 ) = 0 + 2 + 2=4 $$$ second test case solutions third test case $$$ ( 2 \oplus 4 ) + ( 4 \oplus 6 ) + ( 2 \oplus 6 ) = 6 + 2 + <unknown> $$$,['math'],800.0
1699/C,"give a permutation $$$ a_1 a_2 \ldots a_n $$$ integers $$$ 0 $$$ $$$ n - 1 $$$ task find many permutations $$$ b_1 b_2 \ldots b_n $$$ similar permutation $$$ a $$$ two permutations $$$ a $$$ $$$ b $$$ size $$$ n $$$ consider similar intervals $$$ [ l r ] $$$ ( $$$ 1 \le l \le r \le n $$$ ) follow condition satisfy : $$$ $$$ \operatorname { mex } ( [ a_l a _ { l+1 } \ldots a_r ] ) = \operatorname { mex } ( [ b_l b _ { l+1 } \ldots b_r ] ) $$$ $$$ $$$ \operatorname { mex } $$$ a collection integers $$$ c_1 c_2 \ldots c_k $$$ define smallest non - negative integer $$$ x $$$ occur collection $$$ c $$$ example $$$ \operatorname { mex } ( [ 1,2,3,4,5 ] ) = 0 $$$ $$$ \operatorname { mex } ( [ <unknown> ] ) =3 $$$ since total number permutations large print remainder modulo $$$ 1000000000 + 7 $$$ problem a permutation size $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 0 $$$ $$$ n-1 $$$ arbitrary order example $$$ [ <unknown> ] $$$ a permutation $$$ [ 0,1,1 ] $$$ since $$$ 1 $$$ appear twice array $$$ [ 0,1,3 ] $$$ also a permutation since $$$ n=3 $$$ a $$$ 3 $$$ array test contain multiple test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow line contain descriptions test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — size permutation $$$ a $$$ second line test case contain $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \lt n $$$ ) — elements permutation $$$ a $$$ guarantee sum $$$ n $$$ across test case exceed $$$ 100000 $$$ test case print a single integer number permutations similar permutation $$$ a $$$ take modulo $$$ 1000000000 + 7 $$$ first test case permutations similar $$$ a= [ 4,0,3,2,1 ] $$$ $$$ [ 4,0,3,2,1 ] $$$ $$$ [ <unknown> ] $$$ second third test case give permutations similar fourth test case $$$ 4 $$$ permutations similar $$$ a= [ <unknown> ] $$$ :","['combinatorics', 'math']",1700.0
17/B,nick 's company employ n people nick need build a tree hierarchy « supervisor - <unknown> » relations company ( say employee except one exactly one supervisor ) m applications write follow form : « employee ai ready become a supervisor employee bi extra cost ci » qualification qj employee know application follow true : qai > qbi would help nick calculate minimum cost a hierarchy find impossible build first input line contain integer n ( 1 ≤ n ≤ 1000 ) — amount employees company follow line contain n space - separated number qj ( 0 ≤ qj ≤ 106 ) — employees ' <unknown> follow line contain number m ( 0 ≤ m ≤ 10000 ) — amount receive applications follow m line contain applications form three space - separated number : ai bi ci ( 1 ≤ ai bi ≤ n 0 ≤ ci ≤ 106 ) different applications similar i.e come one employee offer become a supervisor person a different cost application qai > qbi output line — minimum cost build a hierarchy -1 impossible build first sample one possible ways build a hierarchy take applications index 1 2 4 give 11 minimum total cost second sample impossible build require hierarchy answer -1,"['dfs and similar', 'dsu', 'greedy', 'shortest paths']",1500.0
1700/B,"a daily walk alina notice a long number write grind alina want find positive number length without lead zero sum two number a palindrome recall a number call a palindrome read right leave leave right example number $$$ 121 66 <unknown> $$$ palindromes $$$ 103 239 <unknown> $$$ palindromes alina understand a valid number always exist help find one ! first line input data contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case next descriptions $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100\,000 $$$ ) — length number write grind second line contain positive $$$ n $$$ -digit integer without lead zero — number guarantee sum value $$$ n $$$ test case exceed $$$ 100\,000 $$$ $$$ t $$$ test case print answer — a positive $$$ n $$$ -digit integer without lead zero sum input integer number a palindrome show least one number satisfy constraints exist multiple solutions output first test case $$$ 99 + 32 = 131 $$$ a palindrome note another answer $$$ 12 $$$ $$$ 99 + 12 = 111 $$$ also a palindrome second test case $$$ 1023 + <unknown> = <unknown> $$$ third test case $$$ <unknown> + <unknown> = <unknown> $$$","['implementation', 'math']",1100.0
1702/G2,a hard version problem difference easy a hard version number query polycarp grow a tree $$$ n $$$ vertices remind a tree $$$ n $$$ vertices undirected connect graph $$$ n $$$ vertices $$$ n-1 $$$ edge contain cycle call a set vertices passable a path tree pass vertex set without pass edge twice path visit vertices ( set ) word a set vertices call passable a simple path pass vertices set ( possibly ) example a tree set $$$ \ { 3 2 5\ } $$$ $$$ \ { 1 5 4\ } $$$ $$$ \ { 1 4\ } $$$ passable $$$ \ { 1 3 5\ } $$$ $$$ \ { 1 2 3 4 5\ } $$$ polycarp ask answer $$$ q $$$ query query a set vertices query need determine whether correspond set vertices passable first line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number vertices follow $$$ n - 1 $$$ line a description tree .. line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) — indices vertices connect edge follow line contain single integer $$$ q $$$ ( $$$ 1 \le q \le 100000 $$$ ) — number query follow $$$ 2 \cdot q $$$ line contain descriptions set first line description contain integer $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) — size set second line description contain $$$ k $$$ distinct integers $$$ p_1 p_2 \dots p_k $$$ ( $$$ 1 \le p_i \le n $$$ ) — indices vertices set guarantee sum $$$ k $$$ value query exceed $$$ 200000 $$$ output $$$ q $$$ line contain answer correspond query answer output ` ` yes '' set passable ` ` '' otherwise output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ),"['data structures', 'dfs and similar', 'trees']",2000.0
1704/A,"aquamoon two binary sequence $$$ a $$$ $$$ b $$$ contain $$$ 0 $$$ $$$ 1 $$$ aquamoon perform follow two operations number time ( $$$ a_1 $$$ first element $$$ a $$$ $$$ a_2 $$$ second element $$$ a $$$ ) : note a removal first element $$$ a $$$ former $$$ a_2 $$$ become first element $$$ a $$$ former $$$ a_3 $$$ become second element $$$ a $$$ length $$$ a $$$ reduce one determine aquamoon make $$$ a $$$ equal $$$ b $$$ use operations first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 2\,000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 50 $$$ $$$ m \leq n $$$ ) — lengths $$$ a $$$ $$$ b $$$ respectively second line test case contain a string $$$ a $$$ length $$$ n $$$ consist $$$ 0 $$$ $$$ 1 $$$ third line test case contain a string $$$ b $$$ length $$$ m $$$ consist $$$ 0 $$$ $$$ 1 $$$ test case output ` ` yes '' aquamoon change $$$ a $$$ $$$ b $$$ use options ; otherwise output ` ` '' may print letter case ( example ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ) first test case use operation 2 four time make $$$ a $$$ equal $$$ b $$$ second test case use operation 1 four time make $$$ a $$$ equal $$$ b $$$ third test case prove matter use operations impossible make $$$ a $$$ equal $$$ b $$$ fourth test case prove matter use operations impossible make $$$ a $$$ equal $$$ b $$$ fifth test case use operation 2 three time make $$$ a $$$ become $$$ 10101 $$$ first element $$$ a $$$ equal first element $$$ b $$$ prove matter operate second fifth elements $$$ a $$$ ca n't $$$ b $$$",['greedy'],800.0
1705/C,one night mark realize essay due tomorrow n't write anything yet mark decide randomly copy - paste substrings prompt make essay formally prompt a string $$$ s $$$ initial length $$$ n $$$ mark perform copy - pasting operation $$$ c $$$ time operation describe two integers $$$ l $$$ $$$ r $$$ mean mark append letter $$$ s_l s _ { l+1 } \ldots s_r $$$ end string $$$ s $$$ note length $$$ s $$$ increase operation course mark need able see write copy mark ask $$$ q $$$ query : give integer $$$ k $$$ determine $$$ k $$$ -th letter final string $$$ s $$$ first line contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 1000 $$$ ) — number test case first line test case contain three integers $$$ n $$$ $$$ c $$$ $$$ q $$$ ( $$$ 1\leq n\leq 2\cdot 100000 $$$ $$$ 1\leq c\leq 40 $$$ $$$ 1\leq q\leq 10000 $$$ ) — length initial string $$$ s $$$ number copy - pasting operations number query respectively second line test case contain a single string $$$ s $$$ length $$$ n $$$ guarantee $$$ s $$$ contain lowercase english letter follow $$$ c $$$ line describe copy - pasting operation line contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1\leq l\leq r\leq 10^ { 18 } $$$ ) also guarantee $$$ r $$$ exceed current length $$$ s $$$ last $$$ q $$$ line test case describe query line contain a single integer $$$ k $$$ ( $$$ 1\leq k\leq 10^ { 18 } $$$ ) also guarantee $$$ k $$$ exceed final length $$$ s $$$ guarantee sum $$$ n $$$ $$$ q $$$ across test case exceed $$$ 2\cdot 100000 $$$ $$$ 10000 $$$ respectively query print $$$ k $$$ -th letter final string $$$ s $$$ first test case copy - paste process follow second test case copy - paste process follow,"['brute force', 'implementation']",1400.0
1705/D,mark purchase a rack $$$ n $$$ lightbulbs state lightbulbs describe binary string $$$ s = s_1s_2\dots s_n $$$ $$$ s_i=\texttt { 1 } $$$ mean $$$ i $$$ -th lightbulb turn $$$ s_i=\texttt { 0 } $$$ mean $$$ i $$$ -th lightbulb turn unfortunately lightbulbs break operation perform change state lightbulbs follow : mark want state lightbulbs another binary string $$$ t $$$ help mark determine minimum number operations first line input contain a single integer $$$ q $$$ ( $$$ 1\leq q\leq 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 3\leq n\leq 2\cdot 100000 $$$ ) — number lightbulbs second line test case contain a binary string $$$ s $$$ length $$$ n $$$ — initial state lightbulbs third line test case contain a binary string $$$ t $$$ length $$$ n $$$ — final state lightbulbs guarantee sum $$$ n $$$ across test case exceed $$$ 2\cdot 100000 $$$ test case print a line contain minimum number operations mark need perform transform $$$ s $$$ $$$ t $$$ sequence operations print $$$ -1 $$$ first test case one sequence operations achieve minimum number operations follow third test case even though first digits $$$ s $$$ $$$ t $$$ last digits $$$ s $$$ $$$ t $$$ show sequence operations satisfy condition fourth test case one sequence achieve minimum number operations follow :,"['combinatorics', 'greedy', 'math', 'sortings']",1800.0
1709/B,beta test new secret <unknown> update update add quest game ! simply world map represent array length $$$ n $$$ $$$ i $$$ -th column world height $$$ a_i $$$ $$$ m $$$ quest test $$$ j $$$ -th represent two integers $$$ s_j $$$ $$$ t_j $$$ quest go column $$$ s_j $$$ column $$$ t_j $$$ start quest appear column $$$ s_j $$$ one move go column $$$ x $$$ column $$$ x-1 $$$ column $$$ x+1 $$$ version <unknown> boot allow fly since a beta version bug allow fly go infinite fly duration move column height $$$ p $$$ column height $$$ q $$$ get amount fall damage height $$$ p $$$ greater height $$$ q $$$ get $$$ p - q $$$ fall damage otherwise fly get $$$ 0 $$$ damage give quest determine minimum amount fall damage get quest first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 100000 ; 1 \le m \le 100000 $$$ ) — number columns world number quest test respectively second line input contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ height $$$ i $$$ -th column world next $$$ m $$$ line describe quest $$$ j $$$ -th contain two integers $$$ s_j $$$ $$$ t_j $$$ ( $$$ 1 \le s_j t_j \le n ; s_j \ne t_j $$$ ) mean move column $$$ s_j $$$ column $$$ t_j $$$ $$$ j $$$ -th quest note $$$ s_j $$$ greater $$$ t_j $$$ print $$$ m $$$ integers $$$ j $$$ -th minimum amount fall damage get $$$ j $$$ -th quest completion,"['data structures', 'dp', 'implementation']",900.0
1709/D,a grid consist $$$ n $$$ row $$$ m $$$ columns row number $$$ 1 $$$ $$$ n $$$ bottom top columns number $$$ 1 $$$ $$$ m $$$ leave right $$$ i $$$ -th column bottom $$$ a_i $$$ cells block ( cells row $$$ 1 2 \dots a_i $$$ ) remain $$$ n - a_i $$$ cells unblock a robot travel across grid send command — move right leave a robot attempt move a block cell outside grid explode however robot break — execute receive command $$$ k $$$ time tell move example move $$$ k $$$ time ( $$$ k $$$ cells ) ca n't send command robot execute current one ask $$$ q $$$ query robot query a start cell a finish cell a value $$$ k $$$ send robot arbitrary number command ( possibly zero ) reach finish cell start cell give execute command $$$ k $$$ time ? robot must stop finish cell visit finish cell still execute command n't count first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 1000000000 $$$ ; $$$ 1 \le m \le 200000 $$$ ) — number row columns grid second line contain $$$ m $$$ integers $$$ a_1 a_2 \dots a_m $$$ ( $$$ 0 \le a_i \le n $$$ ) — number block cells bottom $$$ i $$$ -th column third line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query next $$$ q $$$ line contain five integers $$$ x_s y_s x_f y_f $$$ $$$ k $$$ ( $$$ a [ y_s ] < x_s \le n $$$ ; $$$ 1 \le y_s \le m $$$ ; $$$ a [ y_f ] < x_f \le n $$$ ; $$$ 1 \le y_f \le m $$$ ; $$$ 1 \le k \le 1000000000 $$$ ) — row column start cell row column finish cell number time command execute start finish cell query unblock query print ` ` yes '' send robot arbitrary number command ( possibly zero ) reach finish cell start cell give execute command $$$ k $$$ time otherwise print ` ` '',"['binary search', 'data structures', 'greedy', 'math']",1700.0
1709/F,give three integers $$$ n $$$ $$$ k $$$ $$$ f $$$ consider binary string ( i. e. string consist character $$$ 0 $$$ and/or $$$ 1 $$$ ) length $$$ 1 $$$ $$$ n $$$ every string $$$ s $$$ need choose integer $$$ c_s $$$ $$$ 0 $$$ $$$ k $$$ a multiset binary string length exactly $$$ n $$$ consider beautiful every binary string $$$ s $$$ length $$$ 1 $$$ $$$ n $$$ number string multiset $$$ s $$$ prefix exceed $$$ c_s $$$ example let $$$ n = 2 $$$ $$$ c _ { 0 } = 3 $$$ $$$ c _ { 00 } = 1 $$$ $$$ c _ { 01 } = 2 $$$ $$$ c _ { 1 } = 1 $$$ $$$ c _ { 10 } = 2 $$$ $$$ c _ { 11 } = 3 $$$ multiset string $$$ \ { 11 01 00 01\ } $$$ beautiful since : problem calculate number ways choose integer $$$ c_s $$$ every binary string $$$ s $$$ length $$$ 1 $$$ $$$ n $$$ a way maximum possible size a beautiful multiset exactly $$$ f $$$ line input contain three integers $$$ n $$$ $$$ k $$$ $$$ f $$$ ( $$$ 1 \le n \le 15 $$$ ; $$$ 1 \le k f \le 200000 $$$ ) print one integer — number ways choose integer $$$ c_s $$$ every binary string $$$ s $$$ length $$$ 1 $$$ $$$ n $$$ a way maximum possible size a beautiful multiset exactly $$$ f $$$ since huge print modulo $$$ 998244353 $$$ first example three ways choose integers $$$ c_s $$$ :,"['bitmasks', 'brute force', 'dp', 'graphs', 'math', 'trees']",2500.0
171/D,` ` problem rubbish ! statement 5 test case problemsetter take <unknown> problem ! '' — people complain comment one round codeforces even ... wait checker problem <unknown> 's a <unknown> line input contain integer 1 5 inclusive test problem different content test case n't need equal index line output contain integer 1 3 inclusive problem sample since test case,['brute force'],1300.0
171/F,<unknown> ucyhf yi q fhycu dkcruh <unknown> <unknown> yi q <unknown> fhycu dkcruh <unknown> <unknown> yi je <unknown> jxu <unknown> <unknown> <unknown> <unknown> ev q iydwbu <unknown> d ( 1 ≤ d ≤ <unknown> ) — jxu <unknown> - <unknown> <unknown> ev jxu ucyhf je <unknown> q iydwbu dkcruh,"['brute force', 'implementation', 'number theory']",1600.0
1710/A,a picture represent $$$ n\times m $$$ grid ( $$$ n $$$ row $$$ m $$$ columns ) $$$ n \cdot m $$$ cells color one color $$$ k $$$ pigment different color a limit amount pigment precisely color $$$ a_i $$$ cells $$$ i $$$ -th pigment a picture consider beautiful cell least $$$ 3 $$$ toroidal neighbor color two cells consider toroidal neighbor <unknown> share edge word integers $$$ 1 \leq x_1 x_2 \leq n $$$ $$$ 1 \leq y_1 y_2 \leq m $$$ cell $$$ x_1 $$$ -th row $$$ y_1 $$$ -th column a toroidal neighbor cell $$$ x_2 $$$ -th row $$$ y_2 $$$ -th column one follow two condition hold : notice cell exactly $$$ 4 $$$ toroidal neighbor example $$$ n=3 $$$ $$$ m=4 $$$ toroidal neighbor cell $$$ ( 1 2 ) $$$ ( cell first row second column ) : $$$ ( 3 2 ) $$$ $$$ ( 2 2 ) $$$ $$$ ( 1 3 ) $$$ $$$ ( 1 1 ) $$$ show gray image : possible color cells pigment provide create a beautiful picture ? test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) description test case follow first line test case contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 3 \leq n m \leq 1000000000 $$$ $$$ 1 \leq k \leq 100000 $$$ ) — number row columns picture number pigment next line contain $$$ k $$$ integers $$$ a_1 a_2 \dots a_k $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — $$$ a_i $$$ maximum number cells color $$$ i $$$ -th pigment guarantee sum $$$ k $$$ test case exceed $$$ 100000 $$$ test case print ` ` yes '' ( without quote ) possible color a beautiful picture otherwise print ` ` '' ( without quote ) first test case one possible solution follow : third test case color cells pigment $$$ 1 $$$,"['greedy', 'math']",1500.0
1712/A,"give a permutation $$$ p_1 p_2 \ldots p_n $$$ length $$$ n $$$ a positive integer $$$ k \le n $$$ one operation choose two indices $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i < j \le n $$$ ) swap $$$ p_i $$$ $$$ p_j $$$ find minimum number operations need make sum $$$ p_1 + p_2 + \ldots + p_k $$$ small possible a permutation array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 100 $$$ ) second line test case contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) guarantee give number form a permutation length $$$ n $$$ test case print one integer — minimum number operations need make sum $$$ p_1 + p_2 + \ldots + p_k $$$ small possible first test case value $$$ p_1 + p_2 + \ldots + p_k $$$ initially equal $$$ 2 $$$ smallest possible value $$$ 1 $$$ achieve swap $$$ p_1 $$$ $$$ p_3 $$$ result permutation $$$ [ 1 3 2 ] $$$ second test case sum already small possible answer $$$ 0 $$$","['greedy', 'implementation']",800.0
1712/D,"array $$$ n $$$ positive integers $$$ a_1 a_2 \ldots a_n $$$ fell sky along a positive integer $$$ k \le n $$$ apply follow operation $$$ k $$$ time : build a complete undirected weight graph $$$ n $$$ vertices number integers $$$ 1 $$$ $$$ n $$$ edge $$$ ( l r ) $$$ ( $$$ 1 \le l < r \le n $$$ ) weight $$$ \min ( a _ { l } a _ { l+1 } \ldots a _ { r } ) $$$ find maximum possible diameter result graph perform $$$ k $$$ operations diameter a graph equal $$$ \max\limits _ { 1 \le u < v \le n } { \operatorname { d } ( u v ) } $$$ $$$ \operatorname { d } ( u v ) $$$ length shortest path vertex $$$ u $$$ vertex $$$ v $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 100000 $$$ $$$ 1 \le k \le n $$$ ) second line test case contain $$$ n $$$ positive integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print one integer — maximum possible diameter graph perform $$$ k $$$ operations first test case one optimal array $$$ [ 2,4,5 ] $$$ graph build array : $$$ \operatorname { d } ( 1 2 ) = \operatorname { d } ( 1 3 ) = 2 $$$ $$$ \operatorname { d } ( 2 3 ) = 4 $$$ diameter equal $$$ \max ( <unknown> ) = 4 $$$","['binary search', 'data structures', 'greedy', 'shortest paths']",2000.0
1713/C,"a $$$ \mathbf { 0 } $$$ -indexed array $$$ a $$$ size $$$ n $$$ call good valid indices $$$ i $$$ ( $$$ 0 \le i \le n-1 $$$ ) $$$ a_i + i $$$ a perfect square $$$ ^\dagger $$$ give integer $$$ n $$$ find a permutation $$$ ^\ddagger $$$ $$$ p $$$ $$$ [ 0,1,2 \ldots n-1 ] $$$ good determine permutation exist $$$ ^\dagger $$$ integer $$$ x $$$ say a perfect square exist integer $$$ y $$$ $$$ x = y^2 $$$ $$$ ^\ddagger $$$ array $$$ b $$$ a permutation array $$$ a $$$ $$$ b $$$ consist elements $$$ a $$$ arbitrary order example $$$ [ <unknown> ] $$$ a permutation $$$ [ <unknown> ] $$$ $$$ [ 1,2,2 ] $$$ a permutation $$$ [ 1,2,3 ] $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length permutation $$$ p $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output $$$ n $$$ distinct integers $$$ p_0 p_1 \dots p _ { n-1 } $$$ ( $$$ 0 \le p_i \le n-1 $$$ ) — permutation $$$ p $$$ — answer exist $$$ -1 $$$ otherwise first test case $$$ n=3 $$$ array $$$ p = [ 1 0 2 ] $$$ good since $$$ 1 + 0 = 1 ^ 2 $$$ $$$ 0 + 1 = 1 ^ 2 $$$ $$$ 2 + 2 = 2 ^ 2 $$$ second test case $$$ n=4 $$$ array $$$ p = [ 0 3 2 1 ] $$$ good since $$$ 0 + 0 = 0 ^ 2 $$$ $$$ 3 + 1 = 2 ^ 2 $$$ $$$ 2 + 2 = 2 ^ 2 $$$ $$$ 1 + 3 = 2 ^ 2 $$$","['dp', 'math']",1200.0
1714/A,vlad like everyone else love sleep much every day vlad $$$ n $$$ things a certain time things alarm clock set $$$ i $$$ -th trigger $$$ h_i $$$ hours $$$ m_i $$$ minutes every day ( $$$ 0 \le h_i < 24 0 \le m_i < 60 $$$ ) vlad use $$$ 24 $$$ <unknown> time format $$$ <unknown> m=59 $$$ come $$$ <unknown> m=0 $$$ $$$ <unknown> m=59 $$$ come $$$ h=0 m=0 $$$ time vlad go bed $$$ h $$$ hours $$$ m $$$ minutes ( $$$ 0 \le h < 24 0 \le m < 60 $$$ ) ask answer : much able sleep next alarm clock alarm clock ring time go bed sleep a period time length $$$ 0 $$$ first line input data contain integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case test first line case contain three integers $$$ n $$$ $$$ h $$$ $$$ m $$$ ( $$$ 1 \le n \le 10 0 \le h < 24 0 \le m < 60 $$$ ) — number alarm time vlad go bed follow $$$ n $$$ line contain two number $$$ h_i $$$ $$$ m_i $$$ ( $$$ 0 \le h_i < 24 0 \le m_i < 60 $$$ ) — time $$$ i $$$ alarm acceptable two alarm trigger time number describe time contain lead zero output $$$ t $$$ line contain answer correspond test case answer output two number — number hours minutes vlad sleep respectively alarm clock ring time go bed answer 0 0,"['implementation', 'math']",900.0
1715/C,stanley decide buy a new desktop pc make company ` ` <unknown> '' solve <unknown> website need solve follow task awesomeness array minimum number block consecutive identical number array could split example awesomeness array give array $$$ a $$$ length $$$ n $$$ $$$ m $$$ query two integers $$$ i $$$ $$$ x $$$ a query $$$ i $$$ $$$ x $$$ mean $$$ i $$$ -th element array $$$ a $$$ equal $$$ x $$$ query print sum awesomeness value among subsegments array $$$ a $$$ word query need calculate $$$ $$$ \sum\limits _ { l = 1 } ^n \sum\limits _ { r = l } ^n g ( l r ) $$$ $$$ $$$ g ( l r ) $$$ awesomeness array $$$ b = [ a_l a _ { l + 1 } \ldots a_r ] $$$ first line give two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — array $$$ a $$$ next $$$ m $$$ line give descriptions query line contain two integers $$$ i $$$ $$$ x $$$ ( $$$ 1 \leq i \leq n $$$ $$$ 1 \leq x \leq 1000000000 $$$ ) print answer query a new line first query $$$ a $$$ equal $$$ [ 1 2 2 4 5 ] $$$ answer $$$ 29 $$$ split subsegments follow way :,"['combinatorics', 'data structures', 'implementation', 'math']",1700.0
1715/D,<unknown> integer array $$$ a $$$ length $$$ n $$$ tell size $$$ n $$$ $$$ q $$$ statements three integers $$$ i j x $$$ mean $$$ a_i \mid a_j = x $$$ $$$ | $$$ denote bitwise operation find lexicographically smallest array $$$ a $$$ satisfy statements array $$$ a $$$ lexicographically smaller array $$$ b $$$ length follow hold : first line give two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 0 \le q \le 200000 $$$ ) next $$$ q $$$ line give three integers $$$ i $$$ $$$ j $$$ $$$ x $$$ ( $$$ 1 \le i j \le n $$$ $$$ 0 \le x < 2^ { 30 } $$$ ) — statements guarantee $$$ q $$$ statements hold least one array a single line print $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i < 2^ { 30 } $$$ ) — array $$$ a $$$ first sample array satisfy statements :,"['bitmasks', 'graphs', 'greedy']",1900.0
1716/A,stand point $$$ 0 $$$ a coordinate line goal reach point $$$ n $$$ one minute move $$$ 2 $$$ $$$ 3 $$$ leave right ( i. e. current coordinate $$$ x $$$ become $$$ x-3 $$$ $$$ x-2 $$$ $$$ x+2 $$$ $$$ x+3 $$$ ) note new coordinate become negative task find minimum number minutes require get point $$$ 0 $$$ point $$$ n $$$ answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ line describe test case follow $$$ i $$$ -th line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) — goal $$$ i $$$ -th test case test case print one integer — minimum number minutes require get point $$$ 0 $$$ point $$$ n $$$ correspond test case,"['greedy', 'math']",800.0
1717/B,madoka decide participate underground sport program competition exactly one task : a square table size $$$ n \times n $$$ $$$ n $$$ a multiple $$$ k $$$ call good character ' . ' ' x ' write well subtable size $$$ 1 \times k $$$ $$$ k \times 1 $$$ least one character ' x ' word among $$$ k $$$ consecutive vertical horizontal cells must least one contain character ' x ' output good table minimum possible number character ' x ' also symbol ' x ' write cell $$$ ( r c ) $$$ row number $$$ 1 $$$ $$$ n $$$ top bottom columns number $$$ 1 $$$ $$$ n $$$ leave right input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain four integers $$$ n $$$ $$$ k $$$ $$$ r $$$ $$$ c $$$ ( $$$ 1 \le n \le 500 1 \le k \le n 1 \le r c \le n $$$ ) — size table integer $$$ k $$$ coordinate cell must contain character ' x ' guarantee $$$ n $$$ a multiple $$$ k $$$ guarantee sum $$$ n $$$ test case exceed $$$ 500 $$$ test case output $$$ n $$$ line consist $$$ n $$$ character ' . ' ' x ' — desire table several answer output anyone let 's analyze first test case follow table print correct answer : note follow table invalid cell $$$ ( 3 2 ) $$$ contain character ' x ' : second test case correct table :,['implementation'],1100.0
1717/F,"oh first exam madoka get hard problem : give integer $$$ n $$$ $$$ m $$$ pair integers ( $$$ v_i u_i $$$ ) also array $$$ b_1 b_2 \ldots b_n $$$ initially fill zero index $$$ i $$$ $$$ 1 \leq i \leq m $$$ perform either $$$ b _ { v_i } : = b _ { v_i } - 1 $$$ $$$ b _ { u_i } : = b _ { u_i } + 1 $$$ $$$ b _ { v_i } : = b _ { v_i } + 1 $$$ $$$ b _ { u_i } : = b _ { u_i } - 1 $$$ note exactly one operations perform every $$$ i $$$ also array $$$ s $$$ length $$$ n $$$ consist $$$ 0 $$$ $$$ 1 $$$ array $$$ a_1 a_2 \ldots a_n $$$ guarantee $$$ s_i = 0 $$$ hold $$$ a_i = 0 $$$ help madoka determine whenever possible perform operations way every $$$ i $$$ $$$ s_i = 1 $$$ hold $$$ a_i = b_i $$$ possible also provide madoka a way perform operations first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 10000 1 \leq m \leq 10000 $$$ ) — length array $$$ a $$$ number pair integers second line contain $$$ n $$$ integers $$$ s_1 s_2 \ldots s_n $$$ ( $$$ 0 \le s_i \le 1 $$$ ) — elements array $$$ s $$$ third line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ |a_i| \leq m $$$ ) — elements array $$$ a $$$ guarantee $$$ s_i = 0 $$$ hold $$$ a_i = 0 $$$ $$$ i $$$ -th follow $$$ m $$$ line contain two integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \leq v_i u_i \leq n v_i \ne u_i $$$ ) — index elements array $$$ b $$$ operation perform also guarantee two indices $$$ i $$$ $$$ j $$$ $$$ 1 \le i < j \le m $$$ $$$ ( v_i u_i ) = ( v_j u_j ) $$$ $$$ ( v_i u_i ) = ( u_j v_j ) $$$ first line print ` ` yes '' possible perform operations require way ` ` '' otherwise may print letter case ( example ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive answer ) case print ` ` yes '' print $$$ m $$$ pair integers pair $$$ ( v_i u_i ) $$$ perform $$$ b _ { v_i } : = b _ { v_i } - 1 $$$ $$$ b _ { u_i } : = b _ { u_i } + 1 $$$ print $$$ ( v_i u_i ) $$$ otherwise print $$$ ( u_i v_i ) $$$ multiple ways get correct answer print print pair order first example array $$$ b $$$ change follow : $$$ [ 0,0,0,0,0 ] \rightarrow [ <unknown> ] \rightarrow [ <unknown> ] \rightarrow [ <unknown> ] \rightarrow [ <unknown> ] \rightarrow [ <unknown> -1 ] $$$ $$$ a_i = b_i $$$ indices $$$ i $$$ $$$ 1 $$$ $$$ 5 $$$ second example enough us $$$ b_2 = 1 $$$ end since $$$ s_2 = 1 $$$ third example operations perform require","['graphs', 'implementation']",2500.0
1718/B,school buryatia $$$ 1 $$$ class everyone tell theory fibonacci string ` ` a block a subsegment a string letter bound leave right end string letter letter block a string call a fibonacci string divide block lengths order appear string form fibonacci sequence ( $$$ f_0 = f_1 = 1 $$$ $$$ f_i = f _ { i-2 } + f _ { i-1 } $$$ ) start <unknown> member sequence a string call semi - fibonacci possible reorder letter get a fibonacci string ` ` burenka decide enter buryat state university entrance exam give a difficult task give a string consist letter buryat alphabet ( contain exactly $$$ k $$$ letter ) ask give string semi - fibonacci string long instead string give number appearances letter ( $$$ c_i $$$ $$$ i $$$ -th letter ) string unfortunately burenka longer remember theory fibonacci string without help pass exam first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case follow a description input data set first line test case contain one integer $$$ k $$$ ( $$$ 1 \leq k \leq 100 $$$ ) — number letter alphabet second line test case contain $$$ k $$$ integers $$$ c_1 c_2 \ldots c_k $$$ ( $$$ 1 \leq c_i \leq 1000000000 $$$ ) — number occurrences letter string test case print string ` ` yes '' correspond string semi - fibonacci ` ` '' print ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ) first test case a one - character string semi - fibonacci a fibonacci string second test case a string two different character fibonacci third test case string ` ` abb '' ( let first alphabet letter a second letter b ) a semi - fibonacci string since permutation letter ( ` ` abb '' ` ` bab '' ` ` bba '' ) a fibonacci string fourth test case two permutations letter string ` ` <unknown> '' ( first letter a second letter b third letter c ) fibonacci string — ` ` <unknown> '' ` ` <unknown> '',"['greedy', 'implementation', 'math', 'number theory']",2000.0
1718/E,"burenka two picture $$$ a $$$ $$$ b $$$ table size $$$ n \times m $$$ cell paint a color — a number $$$ 0 $$$ $$$ 200000 $$$ repeat color row column two paint except color $$$ 0 $$$ burenka want get a picture $$$ b $$$ picture $$$ a $$$ achieve goal burenka perform one $$$ 2 $$$ operations : swap two row $$$ a $$$ two columns tell burenka fulfill want , tell sequence action row number $$$ 1 $$$ $$$ n $$$ top bottom columns number $$$ 1 $$$ $$$ m $$$ leave right first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \cdot m \leq 200000 $$$ ) — size table $$$ i $$$ -th next $$$ n $$$ line contain $$$ m $$$ integers $$$ a _ { i 1 } a _ { i 2 } \ldots a _ { i m } $$$ ( $$$ 0 \leq a _ { i j } \leq 200000 $$$ ) — color $$$ i $$$ -th row picture $$$ a $$$ guarantee identical color row column except color $$$ 0 $$$ $$$ i $$$ -th follow $$$ n $$$ line contain $$$ m $$$ integers $$$ b _ { i 1 } b _ { i 2 } \ldots b _ { i m } $$$ ( $$$ 0 \leq b _ { i j } \leq 200000 $$$ ) — color $$$ i $$$ -th row picture $$$ b $$$ guarantee identical color row column except color $$$ 0 $$$ first line print number $$$ -1 $$$ impossible achieve burenka want otherwise print number action solution $$$ k $$$ ( $$$ 0 \le k \le 200000 $$$ ) prove a solution exist exist a solution $$$ k \le 200000 $$$ next $$$ k $$$ line print operations first print type operation ( $$$ 1 $$$ — swap row $$$ 2 $$$ — columns ) print two indices row columns operation apply note n't minimize number operations","['graphs', 'implementation', 'math']",3500.0
172/B,polycarpus recently get interest sequence pseudorandom number learn many program languages generate sequence a similar way : ( i ≥ 1 ) a b m constants fix give realization pseudorandom number generator r0 so - called randseed ( value set program use function like randseed ( r ) <unknown> ( n ) ) denote operation take remainder division example a = 2 b = 6 m = 12 r0 = 11 generate sequence : 4 2 10 2 10 2 10 2 10 2 10 .... polycarpus realize sequence sooner later form a cycle cycle may occur begin exist a preperiod a period example show a preperiod equal 1 a period equal 2 . task find period a sequence define give value a b m r0 formally find minimum positive integer t exist positive integer k i ≥ k : ri = ri + t. single line input contain four integers a b m r0 ( 1 ≤ m ≤ 105 0 ≤ a b ≤ 1000 0 ≤ r0 < m ) separate single space print a single integer — period sequence first sample describe second sample sequence ( start first element ) : 0 3 4 1 0 3 4 1 0 ... third sample sequence ( start first element ) : 33 24 78 78 78 78 .,"['implementation', 'number theory']",1200.0
1720/A,burenka come <unknown> kindergarten quite strange kid receive two fraction ( $$$ \frac { a } { b } $$$ $$$ \frac { c } { d } $$$ ) integer numerators denominators children command play fraction burenka a clever kid notice clap multiply numerator denominator one two fraction integer choice ( ca n't multiply denominators $$$ 0 $$$ ) want know minimal number clap make fraction equal ( value ) please help find require number clap ! first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case follow descriptions test case line test case contain four integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ ( $$$ 0 \leq a c \leq 1000000000 $$$ $$$ 1 \leq b d \leq 1000000000 $$$ ) — numerators denominators fraction give burenka initially test case print a single integer — minimal number clap burenka need make fraction equal first case burenka multiply $$$ c $$$ $$$ 2 $$$ fraction equal second case fraction already equal third case burenka multiply $$$ a $$$ $$$ 4 $$$ $$$ b $$$ $$$ 3 $$$ fraction equal ( $$$ \frac { 1 \cdot 4 } { 2 \cdot 3 } = \frac { 2 } { 3 } $$$ ),"['math', 'number theory']",900.0
1720/D2,hard version problem difference version $$$ a_i \le 1000000000 $$$ give array $$$ n $$$ integers $$$ a_0 a_1 a_2 \ldots a _ { n - 1 } $$$ bryap want find longest beautiful subsequence array array $$$ b = [ b_0 b_1 \ldots b _ { m-1 } ] $$$ $$$ 0 \le b_0 < b_1 < \ldots < b _ { m - 1 } < n $$$ a subsequence length $$$ m $$$ array $$$ a $$$ subsequence $$$ b = [ b_0 b_1 \ldots b _ { m-1 } ] $$$ length $$$ m $$$ call beautiful follow condition hold : $$$ a \oplus b $$$ denote bitwise xor $$$ a $$$ $$$ b $$$ example $$$ 2 \oplus 4 = 6 $$$ $$$ 3 \oplus 1=2 $$$ bryap a simple person want know length longest subsequence help bryap find answer question first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 300000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_0 a_1 ... a _ { n-1 } $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) — elements array guarantee sum $$$ n $$$ test case exceed $$$ 300000 $$$ test case print a single integer — length longest beautiful subsequence first test case pick whole array a beautiful subsequence $$$ 1 \oplus 1 < 2 \oplus 0 $$$ second test case pick elements index $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$ ( $$$ 0 $$$ indexation ) elements hold : $$$ 2 \oplus 2 < 4 \oplus 1 $$$ $$$ 4 \oplus 4 < 1 \oplus 2 $$$,"['bitmasks', 'data structures', 'dp', 'strings', 'trees']",2400.0
1721/B,robot place top leave corner a grid consist $$$ n $$$ row $$$ m $$$ columns a cell $$$ ( 1 1 ) $$$ one step move a cell adjacent a side current one : robot ca n't move outside grid cell $$$ ( s_x s_y ) $$$ contain a deadly laser robot come cell distance less equal $$$ d $$$ laser get evaporate distance two cells $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ $$$ |x_1 - x_2| + |y_1 - y_2| $$$ print smallest number step robot take reach cell $$$ ( n m ) $$$ without get evaporate move outside grid 's possible reach cell $$$ ( n m ) $$$ print -1 . laser neither start cell end cell start cell always distance greater $$$ d $$$ laser first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases line testcase contain five integers $$$ n m s_x s_y d $$$ ( $$$ 2 \le n m \le 1000 $$$ ; $$$ 1 \le s_x \le n $$$ ; $$$ 1 \le s_y \le m $$$ ; $$$ 0 \le d \le n + m $$$ ) — size grid cell contain laser evaporate distance laser laser neither start cell end cell ( $$$ ( s_x s_y ) \neq ( 1 1 ) $$$ $$$ ( s_x s_y ) \neq ( n m ) $$$ ) start cell $$$ ( 1 1 ) $$$ always distance greater $$$ d $$$ laser ( $$$ |s_x - 1| + |s_y - 1| > d $$$ ) testcase print a single integer 's possible reach cell $$$ ( n m ) $$$ $$$ ( 1 1 ) $$$ without get evaporate move outside grid print smallest amount step take robot reach otherwise print -1,['implementation'],1000.0
1725/E,"country dengkleknesia $$$ n $$$ factories number $$$ 1 $$$ $$$ n $$$ factory $$$ i $$$ electrical coefficient $$$ a_i $$$ also $$$ n-1 $$$ power line $$$ j $$$ -th power line connect factory $$$ u_j $$$ factory $$$ v_j $$$ guarantee factory dengkleknesia connect factories dengkleknesia one power line word collection factories form a tree pair different factories dengkleknesia use one exist power line transfer electricity however power line need turn first electricity pass define $$$ f ( x y z ) $$$ minimum number power line need turn factory $$$ x $$$ make electrical transfer factory $$$ y $$$ factory $$$ z $$$ also define $$$ g ( x y z ) $$$ number distinct prime factor $$$ \text { gcd } ( a_x a_y a_z ) $$$ measure electrical efficiency must find sum $$$ f ( x y z ) \times g ( x y z ) $$$ combinations $$$ ( x y z ) $$$ $$$ 1 \leq x < y < z \leq n $$$ answer large need output answer modulo $$$ 998\,244\,353 $$$ note : $$$ \text { gcd } ( k_1 k_2 k_3 ) $$$ greatest common divisor $$$ k_1 $$$ $$$ k_2 $$$ $$$ k_3 $$$ biggest integer simultaneously divide $$$ k_1 $$$ $$$ k_2 $$$ $$$ k_3 $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number factories dengkleknesia second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq 200000 $$$ ) — electrical coefficients factories $$$ j $$$ -th next $$$ n-1 $$$ line contain two integers $$$ u_j $$$ $$$ v_j $$$ ( $$$ 1 \le u_j v_j \le n $$$ ) — a power line connect cities $$$ u_j $$$ $$$ v_j $$$ collection factories form a tree integer represent sum $$$ f ( x y z ) \times g ( x y z ) $$$ combinations $$$ ( x y z ) $$$ $$$ 1 \leq x < y < z \leq n $$$ modulo $$$ 998\,244\,353 $$$ first example $$$ ( x y z ) $$$ possible $$$ ( 1 2 3 ) $$$ $$$ \text { gcd } ( a_1 a_2 a_3 ) = \text { gcd } ( 1 2 3 ) = 1 $$$ $$$ 0 $$$ distinct prime factor therefore $$$ f ( x y z ) \times g ( x y z ) = 2 \times 0 = 0 $$$ second example triple $$$ ( x y z ) $$$ satisfy condition follow : electrical efficiency $$$ 2 + 2 + 6 + 2 = 12 $$$","['combinatorics', 'data structures', 'dp', 'math', 'number theory', 'trees']",2500.0
1726/C,last summer <unknown> gift <unknown> - <unknown> a balance bracket sequence $$$ s $$$ length $$$ 2 n $$$ topshe bore summer vacation hence decide draw undirected graph $$$ 2 n $$$ vertices use balance bracket sequence $$$ s $$$ two distinct vertices $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i < j \le 2 n $$$ ) topshe draw edge ( undirected unweighted ) two nod subsegment $$$ s [ i \ldots j ] $$$ form a balance bracket sequence determine number connect components topshe 's graph see note section definitions underline term test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number open bracket string $$$ s $$$ second line test case contain a string $$$ s $$$ length $$$ 2 n $$$ — a balance bracket sequence consist $$$ n $$$ open bracket ` ` ( ` ` $$$ n $$$ close bracket ` ` ) '' guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output a single integer — number connect components topshe 's graph sample explanation : first test case graph construct bracket sequence ( ) a graph contain nod $$$ 1 $$$ $$$ 2 $$$ connect a single edge second test case graph construct bracket sequence ( ) ( ( ) ) would follow ( contain two connect components ) : definition underline term :,"['data structures', 'dsu', 'graphs', 'greedy']",1300.0
1728/B,let 's define value permutation $$$ p $$$ $$$ n $$$ integers $$$ 1 $$$ $$$ 2 $$$ ... $$$ n $$$ ( a permutation array element $$$ 1 $$$ $$$ n $$$ occur exactly ) follow : example $$$ p = [ 4 5 1 2 3 6 ] $$$ value $$$ x $$$ change follow : $$$ 0 4 9 0 2 5 11 $$$ value permutation $$$ 11 $$$ give integer $$$ n $$$ find a permutation $$$ p $$$ size $$$ n $$$ maximum possible value among permutations size $$$ n $$$ several permutations print first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 97 $$$ ) — number test case line test case contain one integer $$$ n $$$ ( $$$ 4 \le n \le 100 $$$ ) test case print $$$ n $$$ integers — permutation $$$ p $$$ size $$$ n $$$ maximum possible value among permutations size $$$ n $$$,['greedy'],800.0
1728/C,let 's define $$$ f ( x ) $$$ a positive integer $$$ x $$$ length <unknown> representation $$$ x $$$ without lead zero i like call a digital logarithm similar a digital root familiar give two array $$$ a $$$ $$$ b $$$ contain $$$ n $$$ positive integers one operation follow : two array consider similar rearrange elements equal ( e. g. $$$ a_i = b_i $$$ $$$ i $$$ $$$ 1 $$$ $$$ n $$$ ) 's smallest number operations require make $$$ a $$$ $$$ b $$$ similar ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements array second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i < 1000000000 $$$ ) third line contain $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ 1 \le b_j < 1000000000 $$$ ) sum $$$ n $$$ testcases n't exceed $$$ 200000 $$$ testcase print smallest number operations require make $$$ a $$$ $$$ b $$$ similar first testcase apply digital logarithm $$$ b_1 $$$ twice second testcase array already similar third testcase first apply digital logarithm $$$ a_1 $$$ $$$ b_2 $$$,"['data structures', 'greedy', 'sortings']",1400.0
1729/B,polycarp a string $$$ s $$$ consist lowercase latin letter encode use follow algorithm go letter string $$$ s $$$ leave right letter polycarp consider number alphabet : example string $$$ s $$$ code polycarp encode string follow : thus code string code <unknown> . give a string $$$ t $$$ result encode string $$$ s $$$ task decode ( get original string $$$ s $$$ $$$ t $$$ ) first line input contain integer $$$ q $$$ ( $$$ 1 \le q \le 10000 $$$ ) — number test case input descriptions test case follow first line description test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — length give code second line description test case contain a string $$$ t $$$ length $$$ n $$$ — give code guarantee exist a string lowercase latin letter a result encode string $$$ t $$$ obtain test case output require string $$$ s $$$ — string give string $$$ t $$$ result encode guarantee a string always exist show a string always unique first test case explain second test case answer aj indeed number letter a equal $$$ 1 $$$ 1 append code number letter j $$$ 10 $$$ 100 append code result code 1100 . zero third test case mean number letter less $$$ 10 $$$ encode one digit original string abacaba fourth test case string $$$ s $$$ equal letter l number $$$ 12 $$$ encode 120 . indeed <unknown>,"['greedy', 'strings']",800.0
1729/D,"a group $$$ n $$$ friends decide go a restaurant friends plan order meals $$$ x_i $$$ burl a total $$$ y_i $$$ burl ( $$$ 1 \le i \le n $$$ ) friends decide split visit restaurant several days day group least two friends go restaurant friends visit restaurant ( group intersect ) group must satisfy condition total budget group must less amount burl friends group go spend restaurant word sum $$$ x_i $$$ value group must exceed sum $$$ y_i $$$ value group maximum number days friends visit restaurant ? example let $$$ n = 6 $$$ friends $$$ x $$$ = [ $$$ 8 3 9 2 4 5 $$$ ] $$$ y $$$ = [ $$$ 5 3 1 4 5 10 $$$ ] : show able form group group least two friends group pay bill , maximum number group friends split $$$ 2 $$$ friends visit restaurant a maximum two days note $$$ 3 $$$ -rd friend visit restaurant output maximum number days friends visit restaurant give $$$ n $$$ $$$ x $$$ $$$ y $$$ first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test descriptions test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — number friends second line test case contain exactly $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ 1 \le x_i \le 1000000000 $$$ ) value $$$ x_i $$$ correspond number burl friend number $$$ i $$$ plan spend restaurant third line test case contain exactly $$$ n $$$ integers $$$ y_1 y_2 \dots y_n $$$ ( $$$ 1 \le y_i \le 1000000000 $$$ ) value $$$ y_i $$$ correspond number burl friend number $$$ i $$$ guarantee sum $$$ n $$$ value test case exceed $$$ 100000 $$$ test case print maximum number days visit restaurant friends form even one group visit restaurant print 0 . first test case explain problem statement second test case friends form least one group two people third test case one way visit restaurant one day go a group three friends ( $$$ 1 + 3 + 10 \ge 2 + 3 + 7 $$$ ) note option split two group","['greedy', 'sortings', 'two pointers']",1200.0
1730/C,a string $$$ s $$$ consist digits $$$ 0 $$$ $$$ 9 $$$ inclusive perform follow operation ( possibly zero ) number time : lexicographically smallest string get perform operations ? a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ length follow hold : first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case follow test case consist a single line contain one string $$$ s $$$ ( $$$ 1 \le |s| \le 200000 $$$ ) — string consist digits please note $$$ s $$$ a string consist digits lead zero allow guarantee sum lengths $$$ s $$$ test case exceed $$$ 200000 $$$ print a single string — minimum string possible obtain first test case : nothing need do second third test case,"['data structures', 'greedy', 'math', 'sortings']",1200.0
1731/F,"suppose integer array $$$ a_1 a_2 \dots a_n $$$ let $$$ \operatorname { lsl } ( i ) $$$ number indices $$$ j $$$ ( $$$ 1 \le j < i $$$ ) $$$ a_j < a_i $$$ analogically let $$$ \operatorname { grr } ( i ) $$$ number indices $$$ j $$$ ( $$$ i < j \le n $$$ ) $$$ a_j > a_i $$$ let 's name position $$$ i $$$ good array $$$ a $$$ $$$ \operatorname { lsl } ( i ) < \operatorname { grr } ( i ) $$$ finally let 's define a function $$$ f $$$ array $$$ a $$$ $$$ f ( a ) $$$ sum $$$ a_i $$$ $$$ i $$$ good $$$ a $$$ give two integers $$$ n $$$ $$$ k $$$ find sum $$$ f ( a ) $$$ array $$$ a $$$ size $$$ n $$$ $$$ 1 \leq a_i \leq k $$$ $$$ 1 \leq i \leq n $$$ modulo $$$ 998\,244\,353 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 50 $$$ ; $$$ 2 \leq k < 998\,244\,353 $$$ ) output a single integer — sum $$$ f $$$ array $$$ a $$$ size $$$ n $$$ modulo $$$ 998\,244\,353 $$$ first test case : add value get $$$ 28 $$$ answer","['brute force', 'combinatorics', 'dp', 'math']",2500.0
1732/C2,"hard version problem difference version $$$ q = n $$$ give array integers $$$ a_1 a_2 \ldots a_n $$$ cost a subsegment array $$$ [ l r ] $$$ $$$ 1 \leq l \leq r \leq n $$$ value $$$ f ( l r ) = \operatorname { sum } ( l r ) - \operatorname { xor } ( l r ) $$$ $$$ \operatorname { sum } ( l r ) = a_l + a _ { l+1 } + \ldots + a_r $$$ $$$ \operatorname { xor } ( l r ) = a_l \oplus a _ { l+1 } \oplus \ldots \oplus a_r $$$ ( $$$ \oplus $$$ stand bitwise xor ) $$$ q $$$ query query give a pair number $$$ l_i $$$ $$$ r_i $$$ $$$ 1 \leq l_i \leq r_i \leq n $$$ need find subsegment $$$ [ l r ] $$$ $$$ l_i \leq l \leq r \leq r_i $$$ maximum value $$$ f ( l r ) $$$ several answer among need find a subsegment minimum length , minimum value $$$ r - l + 1 $$$ test consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ q = n $$$ ) — length array number query second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) — array elements $$$ i $$$ -th next $$$ q $$$ line test case contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \leq l_i \leq r_i \leq n $$$ ) — boundaries need find segment guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ guarantee $$$ l_1 = 1 $$$ $$$ r_1 = n $$$ test case print $$$ q $$$ pair number $$$ l_i \leq l \leq r \leq r_i $$$ value $$$ f ( l r ) $$$ maximum among length $$$ r - l + 1 $$$ minimum several correct answer print test case first query consider first test case $$$ f ( 1 1 ) = 0 - 0 = 0 $$$ second test case $$$ f ( 1 1 ) = 5 - 5 = 0 $$$ $$$ f ( 2 2 ) = 10 - 10 = 0 $$$ note $$$ f ( 1 2 ) = ( 10 + 5 ) - ( 10 \oplus 5 ) = 0 $$$ need find a subsegment minimum length among maximum value $$$ f ( l r ) $$$ , segment $$$ [ 1 1 ] $$$ $$$ [ 2 2 ] $$$ correct answer fourth test case $$$ f ( 2 3 ) = ( 12 + 8 ) - ( 12 \oplus 8 ) = 16 $$$ two correct answer fifth test case since $$$ f ( 2 3 ) = f ( 3 4 ) $$$ lengths equal","['binary search', 'bitmasks', 'brute force', 'greedy', 'implementation', 'two pointers']",2100.0
1732/D1,easy version problem difference version ` ` remove '' query initially a set contain one element — $$$ 0 $$$ need handle $$$ q $$$ query follow type : problem define $$$ k\text { -mex } $$$ a set integers smallest non - negative integer $$$ x $$$ divisible $$$ k $$$ contain set first line contain integer $$$ q $$$ ( $$$ 1 \leq q \leq 200000 $$$ ) — number query follow $$$ q $$$ line describe query addition query integer $$$ x $$$ give format + $$$ x $$$ ( $$$ 1 \leq x \leq 10^ { 18 } $$$ ) guarantee $$$ x $$$ contain set a search query $$$ k\text { -mex } $$$ give format ? $$$ k $$$ ( $$$ 1 \leq k \leq 10^ { 18 } $$$ ) guarantee least one query type ? query type ? output a single integer — $$$ k\text { -mex } $$$ set first example : first second query set contain elements $$$ \ { 0 1 2\ } $$$ smallest non - negative number divisible $$$ 1 $$$ contain set $$$ 3 $$$ fourth query set contain elements $$$ \ { 0 1 2 4\ } $$$ smallest non - negative number divisible $$$ 2 $$$ contain set $$$ 6 $$$ second example :,"['brute force', 'data structures', 'implementation', 'number theory']",1500.0
1732/D2,hard version problem difference version remove query initially a set contain one element — $$$ 0 $$$ need handle $$$ q $$$ query follow type : problem define $$$ k\text { -mex } $$$ a set integers smallest non - negative integer $$$ x $$$ divisible $$$ k $$$ contain set first line contain integer $$$ q $$$ ( $$$ 1 \leq q \leq 200000 $$$ ) — number query follow $$$ q $$$ line describe query addition query integer $$$ x $$$ give format + $$$ x $$$ ( $$$ 1 \leq x \leq 10^ { 18 } $$$ ) guarantee $$$ x $$$ contain set a remove query integer $$$ x $$$ give format - $$$ x $$$ ( $$$ 1 \leq x \leq 10^ { 18 } $$$ ) guarantee $$$ x $$$ contain set a search query $$$ k\text { -mex } $$$ give format ? $$$ k $$$ ( $$$ 1 \leq k \leq 10^ { 18 } $$$ ) guarantee least one query type ? query type ? output a single integer — $$$ k\text { -mex } $$$ set first example : first second query set contain elements $$$ \ { 0 1 2\ } $$$ smallest non - negative number divisible $$$ 1 $$$ set $$$ 3 $$$ fourth query set contain elements $$$ \ { 0 1 2 4\ } $$$ smallest non - negative number divisible $$$ 2 $$$ set $$$ 6 $$$ second example :,"['brute force', 'data structures', 'number theory']",2400.0
1734/D,"play a game call slime escape game take place a number line initially $$$ n $$$ slim positive integers $$$ i $$$ $$$ 1 \le i \le n $$$ $$$ i $$$ -th slime locate position $$$ i $$$ health $$$ a_i $$$ control slime position $$$ k $$$ two escape locate position $$$ 0 $$$ $$$ n+1 $$$ goal reach one two escape perform number game move one game move move slime leave right one position however another slime new position must absorb absorb a slime health slime would increase health absorb slime absorb slime would remove game note slim might negative health health would decrease absorb slim lose game immediately slime negative health moment game reach one two escape perform number game move without ever lose game ? test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 20\,000 $$$ ) — number test case description test case follow first line test case contain two positive integers $$$ n $$$ $$$ k $$$ ( $$$ 3 \leq n \leq 200\,000 $$$ $$$ 1 \leq k \leq n $$$ ) — number slim position slime second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \leq a_i \leq 1000000000 $$$ ) — health slim guarantee health slime non - negative ( $$$ a_k \geq 0 $$$ ) slim non - zero health ( $$$ a_i \ne 0 $$$ $$$ i \ne k $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200\,000 $$$ test case print ` ` yes '' ( without quote ) escape without lose ` ` '' ( without quote ) otherwise first test case control slime position $$$ 4 $$$ health $$$ 6 $$$ one way escape absorb slim position $$$ 5 $$$ $$$ 6 $$$ $$$ 7 $$$ slime escape $$$ 0 $$$ health position $$$ 8 $$$ second test case control slime $$$ 232 $$$ health position $$$ 1 $$$ since slime already locate next escape position $$$ 0 $$$ move without absorb slime third test case show slime would always a negative health reach one two escape fourth test case control slime position $$$ 4 $$$ health $$$ 6 $$$ follow describe a possible sequence move win : since slime maintain non - negative health time ,","['data structures', 'dp', 'greedy', 'two pointers']",1800.0
1736/A,give two array $$$ a $$$ $$$ b $$$ $$$ n $$$ elements element either $$$ 0 $$$ $$$ 1 $$$ make operations $$$ 2 $$$ kinds find minimum number operations require make $$$ a $$$ equal $$$ b $$$ test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 400 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) — length array $$$ a $$$ $$$ b $$$ second line test case contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ a_i $$$ $$$ 0 $$$ $$$ 1 $$$ ) represent array $$$ a $$$ third line test case contain $$$ n $$$ space - separated integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ b_i $$$ $$$ 0 $$$ $$$ 1 $$$ ) represent array $$$ b $$$ test case print minimum number operations require make $$$ a $$$ equal $$$ b $$$ first case need one operation : change $$$ a_1 $$$ $$$ 1 - a_i $$$ $$$ a = [ 0 0 ] $$$ equal $$$ b $$$ second case optimal way rearrange $$$ a $$$ get array $$$ [ 0 1 11 $$$ $$$ a = [ 0 0 1 ] $$$ equal $$$ b $$$ second case one optimal ways would first change $$$ a_3 $$$ $$$ 1 - a_3 $$$ rearrange $$$ a $$$ third case operation need fourth case optimal way rearrange $$$ a $$$ get array $$$ [ 0 1 1 0 ] $$$,"['brute force', 'greedy', 'sortings']",800.0
1737/G,dtl engineer love party weekend ela ! unfortunately n't know dance yet therefore decide take a dance class $$$ n $$$ students dance class include ela final project $$$ n $$$ students participate a choreography describe $$$ n $$$ students position positive side $$$ ox $$$ -axis $$$ i $$$ -th dancer locate $$$ a_i > 0 $$$ dancers change position dance ( 'll call movable dancers ) others stay place a choreography ( 'll call immovable dancers ) distinguish dancers use a binary string $$$ s $$$ length $$$ n $$$ : $$$ s_i $$$ equal ' 1 ' $$$ i $$$ -th dancer movable otherwise $$$ i $$$ -th dancer immovable let 's call ` ` positive energy value '' choreography $$$ d > 0 $$$ dancers perform ` ` movements '' base value minute dance begin movable dancer smallest $$$ x $$$ -coordinate start move right initiate a ` ` movement '' begin movement dancer 's energy level initiate equally positive energy value choreography $$$ d $$$ time move $$$ y $$$ $$$ y+1 $$$ energy level decrease $$$ 1 $$$ point dancer might meet fellow dancers coordinate happen energy level dancer increase $$$ 1 $$$ a dancer stop move right energy level reach $$$ 0 $$$ n't share a position another dancer dancers well - <unknown> ` ` movement '' end next minute begin show understand choreography ela answer $$$ q $$$ query consist two integers $$$ k $$$ $$$ m $$$ answer query coordinate $$$ m $$$ -th dancer type leave $$$ k $$$ -th minute choreography begin word denote $$$ x _ { k 1 } x _ { k 2 } \dots x _ { k n } $$$ sort coordinate dancers $$$ k $$$ -th minute begin need print $$$ x _ { k m } $$$ first line contain three integers $$$ n $$$ $$$ d $$$ $$$ q $$$ ( $$$ 1 \le n \le 100000 $$$ ; $$$ 1 \le d \le 1000000000 $$$ ; $$$ 1 \le q \le 100000 $$$ ) — number dancers positive energy value choreography number query second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_1 < a_2 < \dots < a_n \le 1000000000 $$$ ) — coordinate dancer third line contain a binary string $$$ s $$$ length $$$ n $$$ — movability dancer character either ' 0 ' ' 1 ' guarantee $$$ s $$$ contain least one character ' 1 ' $$$ q $$$ line follow $$$ i $$$ -th contain two integers $$$ k_i $$$ $$$ m_i $$$ ( $$$ 1 \le k_i \le 1000000000 $$$ $$$ 1 \le m_i \le n $$$ ) — content query output $$$ q $$$ line contain a single integer — answer correspond query let 's consider first example test case first minute $$$ 1 $$$ lowest coordinate movable dancers energy level initiate $$$ 3 $$$ follow happen : end first minute sort coordinate dancers become $$$ [ 3 5 6 7 ] $$$ respective movability ' 0111 ' second minute $$$ 5 $$$ lowest coordinate movable dancers energy level initiate $$$ 3 $$$ follow happen : end second minute sort coordinate dancers become $$$ [ 3 6 7 10 ] $$$ respective movability ' 0111 ',"['binary search', 'data structures']",3500.0
1738/B,suppose $$$ a_1 a_2 \dots a_n $$$ a sort integer sequence length $$$ n $$$ $$$ a_1 \leq a_2 \leq \dots \leq a_n $$$ every $$$ 1 \leq i \leq n $$$ prefix sum $$$ s_i $$$ first $$$ i $$$ term $$$ a_1 a_2 \dots a_i $$$ define $$$ $$$ s_i = \sum _ { k=1 } ^i a_k = a_1 + a_2 + \dots + a_i $$$ $$$ give last $$$ k $$$ term prefix sum $$$ s _ { n - k+1 } \dots s _ { n-1 } s _ { n } $$$ task determine whether possible formally give $$$ k $$$ integers $$$ s _ { n - k+1 } \dots s _ { n-1 } s _ { n } $$$ task check whether a sequence $$$ a_1 a_2 \dots a_n $$$ test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case follow line contain description test case first line test case contain two integers $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) $$$ k $$$ ( $$$ 1 \leq k \leq n $$$ ) indicate length sequence $$$ a $$$ number term prefix sum respectively second line test case contain $$$ k $$$ integers $$$ s _ { n - k+1 } \dots s _ { n-1 } s _ { n } $$$ ( $$$ -1000000000 \leq s_i \leq 1000000000 $$$ every $$$ n - k+1 \leq i \leq n $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output ` ` yes '' ( without quote ) possible ` ` '' ( without quote ) otherwise output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first test case sequence $$$ a = [ 1 1 1 1 1 ] $$$ second test case choose example $$$ a = [ -3 -2 -1 0 1 2 3 ] $$$ third test case prefix sum define sequence $$$ a = [ 2 1 1 ] $$$ sort fourth test case show sequence give prefix sum,"['greedy', 'math', 'sortings']",1200.0
1738/H,task maintain a queue consist lowercase english letter follow : initially queue empty operation ask count number distinct palindromic substrings string obtain concatenate letter front back queue especially number distinct palindromic substrings empty string $$$ 0 $$$ a string $$$ s [ 1 .. n ] $$$ length $$$ n $$$ palindromic $$$ s [ i ] = s [ n - i+1 ] $$$ every $$$ 1 \leq i \leq n $$$ string $$$ s [ l .. r ] $$$ a substring string $$$ s [ 1 .. n ] $$$ every $$$ 1 \leq l \leq r \leq n $$$ two string $$$ s [ 1 .. n ] $$$ $$$ t [ 1 .. m ] $$$ distinct least one follow hold first line integer $$$ q $$$ ( $$$ 1 \leq q \leq 1000000 $$$ ) indicate number operations $$$ q $$$ line follow follow line contain one operations follow guarantee ` ` pop '' operation perform queue empty operation print number distinct palindromic substrings string present queue let $$$ s_k $$$ string present queue $$$ k $$$ -th operation let $$$ c_k $$$ number distinct palindromic substrings $$$ s_k $$$ follow table show detail example worth point,"['data structures', 'strings']",3300.0
174/A,a group n merry programmers celebrate <unknown> floyd 's birthday <unknown> get <unknown> task pour ber - cola everybody pour amount ber - cola everybody really important word drink 's volume n mug must polycarpus already begin process partially empty ber - cola bottle first mug a1 milliliters drink second one a2 milliliters bottle b milliliters leave polycarpus plan pour mug main equation fulfil write a program would determine volume drink polycarpus need add mug ensure follow two condition fulfil simultaneously : first line contain a pair integers n b ( 2 ≤ n ≤ 100 1 ≤ b ≤ 100 ) n total number friends group b current volume drink bottle second line contain a sequence integers a1 a2 ... ( 0 ≤ ai ≤ 100 ) ai current volume drink i - th mug print a single number ` ` -1 '' ( without quote ) solution otherwise print n float number c1 c2 ... cn ci volume drink add i - th mug print number less 6 digits decimal point print ci a single line polycarpus prove a solution exist unique russian <unknown> instal default test computer make sure solution use point separate integer part a real number decimal a comma,['math'],1100.0
1740/B,pak chanek $$$ n $$$ two - dimensional slice cheese $$$ i $$$ -th slice cheese represent a rectangle dimension $$$ a_i \times b_i $$$ want arrange two - dimensional plane : note arrange order ( leftmost slice cheese necessarily first slice cheese ) also note rotate slice cheese way long condition still hold find minimum possible perimeter construct shape test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 20000 $$$ ) — number test case follow line contain description test case first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — number slice cheese pak chanek $$$ i $$$ -th next $$$ n $$$ line test case contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a_i b_i \leq 1000000000 $$$ ) — dimension $$$ i $$$ -th slice cheese guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a line contain integer represent minimum possible perimeter construct shape first test case a way get minimum possible perimeter arrange slice cheese follow calculate perimeter construct shape $$$ 2 + 5 + 1 + 1 + 1 + 1 + 3 + 1 + 5 + 1 + 2 + <unknown> $$$ show get a smaller perimeter consider follow invalid arrangement even though perimeter shape $$$ 24 $$$ satisfy condition problem bottom edge $$$ 1 \times 1 $$$ slice cheese a segment x - axis second test case a way get minimum possible perimeter arrange slice cheese follow calculate perimeter construct shape $$$ 2 + 2 + 2 + 3 + 2 + 3 + 2 + 2 + 2 + <unknown> $$$ show get a smaller perimeter,"['geometry', 'greedy', 'sortings']",800.0
1741/A,"two t - shirt size give : $$$ a $$$ $$$ b $$$ t - shirt size either a string m a string consist several ( possibly zero ) character x one character s l. example string m xxl s <unknown> could size t - shirts string xm , sx size letter m stand medium s small l large letter x refer degree size ( extra ) example xxl extra - extra - large ( bigger xl smaller xxxl ) need compare two give size t - shirts $$$ a $$$ $$$ b $$$ t - shirts compare follow : example : first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist one line $$$ a $$$ $$$ b $$$ t - shirt size write lengths string correspond t - shirt size exceed $$$ 50 $$$ guarantee size correct test case print a separate line result compare $$$ a $$$ $$$ b $$$ t - shirt size ( line ` ` < ` ` ` ` > '' ` ` = '' without quote )","['implementation', 'implementation', 'strings']",800.0
1741/B,"a sequence $$$ n $$$ number call permutation contain number $$$ 1 $$$ $$$ n $$$ exactly example sequence $$$ [ 3 1 4 2 ] $$$ [ $$$ 1 $$$ ] $$$ [ 2,1 ] $$$ permutations $$$ [ 1,2,1 ] $$$ $$$ [ 0,1 ] $$$ $$$ [ 1,3,4 ] $$$ a give number $$$ n $$$ need make a permutation $$$ p $$$ two requirements satisfy time : let 's call permutation satisfy requirements funny example let $$$ n = 4 $$$ [ $$$ 4 3 1 2 $$$ ] a funny permutation since : a give positive integer $$$ n $$$ output funny permutation length $$$ n $$$ output -1 funny permutation length $$$ n $$$ exist first line input data contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow test case consist f single line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print a separate line : first test case explain problem statement second test case possible make require permutation : permutations $$$ [ 1 2 3 ] $$$ $$$ [ 1 3 2 ] $$$ $$$ [ 2 1 3 ] $$$ $$$ [ 3 2 1 ] $$$ fix point $$$ [ 2 3 1 ] $$$ $$$ [ 3 1 2 ] $$$ first condition meet position",['math'],800.0
1741/F,dmitry $$$ n $$$ segment different color coordinate axis $$$ ox $$$ segment characterize three integers $$$ l_i $$$ $$$ r_i $$$ $$$ c_i $$$ ( $$$ 1 \le l_i \le r_i \le 1000000000 1 \le c_i \le n $$$ ) $$$ l_i $$$ $$$ r_i $$$ coordinate end $$$ i $$$ -th segment $$$ c_i $$$ color dmitry like find minimum distance segment however consider pair segment color uninteresting therefore want know segment distance segment nearest differently color segment distance two segment minimum distance a point first segment a point second segment particular segment intersect distance equal $$$ 0 $$$ example dmitry $$$ 5 $$$ segment : first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test descriptions test case follow first line description test case contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number segment next $$$ n $$$ line contain descriptions segment segment describe three integers $$$ l_i $$$ $$$ r_i $$$ $$$ c_i $$$ ( $$$ 1 \le l_i \le r_i \le 1000000000 1 \le c_i \le n $$$ ) — coordinate leave right end $$$ i $$$ -th segment well color segment guarantee least $$$ 2 $$$ segment different color guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case a separate line print $$$ n $$$ integers $$$ i $$$ -th number equal distance $$$ i $$$ -th segment nearest segment a different color first test case first sample one segment color $$$ 2 $$$ segment color $$$ 1 $$$ therefore segment color $$$ 1 $$$ answer equal distance $$$ 3 $$$ rd segment $$$ 3 $$$ rd one answer equal minimum distance segment color $$$ 1 $$$ second test case first sample $$$ 2 $$$ segment answer equal distance third test case first sample segment intersect least one end a segment a different color answer equal $$$ 0 $$$ fourth test case first sample describe problem statement fifth test case first sample one segment lie completely inside answer $$$ 0 $$$ sixth test case first sample segment point different color,"['binary search', 'data structures', 'math', 'sortings']",2000.0
1742/B,"give array $$$ a $$$ $$$ n $$$ positive integers determine rearrange elements make array strictly increase word determine possible rearrange elements $$$ a_1 < a_2 < \dots < a_n $$$ hold first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — elements array test case output ` ` yes '' ( without quote ) array satisfy condition ` ` '' ( without quote ) otherwise output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ) first test case rearrangement keep array $$$ [ 1,1,1,1 ] $$$ strictly increase second test case make array $$$ [ <unknown> ] $$$","['greedy', 'implementation', 'sortings']",800.0
1744/E1,easy version problem difference easy a hard version constraints $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ give $$$ 4 $$$ positive integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ $$$ a < c $$$ $$$ b < d $$$ find pair number $$$ x $$$ $$$ y $$$ satisfy follow condition : note require $$$ x $$$ $$$ y $$$ may exist first line input contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10 $$$ ) number test case descriptions test case follow line test case contain four integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ ( $$$ 1 \leq a < c \leq 100000 $$$ $$$ 1 \leq b < d \leq 100000 $$$ ) test case print a pair number $$$ a < x \leq c $$$ $$$ b < y \leq d $$$ $$$ x \cdot y $$$ divisible $$$ a \cdot b $$$ multiple answer print pair number print -1 -1,"['brute force', 'math', 'number theory']",1500.0
1744/E2,hard version problem difference easy a hard version constraints $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ give $$$ 4 $$$ positive integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ $$$ a < c $$$ $$$ b < d $$$ find pair number $$$ x $$$ $$$ y $$$ satisfy follow condition : note require $$$ x $$$ $$$ y $$$ may exist first line input contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10 $$$ ) number test case descriptions test case follow line test case contain four integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ ( $$$ 1 \leq a < c \leq 1000000000 $$$ $$$ 1 \leq b < d \leq 1000000000 $$$ ) test case print a pair number $$$ a < x \leq c $$$ $$$ b < y \leq d $$$ $$$ x \cdot y $$$ divisible $$$ a \cdot b $$$ multiple answer print pair number print -1 -1,"['brute force', 'math', 'number theory']",1900.0
1746/C,give a permutation $$$ a $$$ size $$$ n $$$ perform $$$ n $$$ operations $$$ i $$$ -th operation choose a non - empty suffix $$$ a $$$ increase elements $$$ i $$$ perform operations minimize number inversions final array ? note perform operations suffix number time want a permutation size $$$ n $$$ array size $$$ n $$$ integer $$$ 1 $$$ $$$ n $$$ occur exactly array a suffix several consecutive elements array include last element array inversion array $$$ a $$$ a pair indices $$$ ( i j ) $$$ $$$ i > j $$$ $$$ a _ { i } < a _ { j } $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — size array second line contain $$$ n $$$ distinct integers $$$ a _ { 1 } a _ { 2 } \dots a _ { n } $$$ ( $$$ 1 \le a_i \le n $$$ ) initial permutation $$$ a $$$ 's guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print $$$ n $$$ integers $$$ x _ { 1 } x _ { 2 } \ldots x _ { n } $$$ ( $$$ 1 \le x _ { i } \le n $$$ $$$ 1 \le i \le n $$$ ) indicate $$$ i $$$ -th operation must apply suffix start index $$$ x _ { i } $$$ multiple answer print first test case one optimal solutions increase whole array operation ( choose suffix start index $$$ 1 $$$ ) final array $$$ [ 11 12 13 14 ] $$$ contain $$$ 0 $$$ inversions second test case $$$ a $$$ equal $$$ [ 2 4 3 5 6 ] $$$ $$$ [ 2 4 3 7 8 ] $$$ $$$ [ 2 4 6 10 11 ] $$$ $$$ [ 2 8 10 14 15 ] $$$ $$$ [ 7 13 15 19 20 ] $$$ first second third fourth fifth operations respectively final array $$$ a $$$ zero inversions,"['greedy', 'implementation', 'math']",1300.0
1746/E2,"difference problem hard version maximum number question interactive problem a hide integer $$$ 1 \le x \le n $$$ find order find ask $$$ \mathbf { 53 } $$$ question question choose a non - empty integer set $$$ s $$$ ask $$$ x $$$ belong $$$ s $$$ question $$$ x $$$ belong $$$ s $$$ 'll receive ` ` yes '' otherwise ` ` '' problem answer necessarily true ( joke ) 's guarantee two consecutive question least one answer correctly additionally question make $$$ 2 $$$ guess answer $$$ x $$$ time make a guess guess $$$ x $$$ correctly receive ` ` : ) '' program terminate otherwise 'll receive ` ` : ( ` ` a part joke fix value $$$ x $$$ begin instead change throughout interaction long previous responses valid describe note answer guess always answer correctly ask a question a guess least one two question answer correctly normal line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) maximum possible value $$$ x $$$ question want ask a set $$$ s $$$ first print character ' ? ' print size $$$ s $$$ print elements $$$ s $$$ one one element integer $$$ 1 $$$ $$$ n $$$ elements must distinct question read a string ` ` yes '' ` ` '' explain statement make $$$ 53 $$$ question want guess $$$ x $$$ first print character ' ! ' print guess guess read ` ` : ) '' ` ` : ( ` ` guess $$$ x $$$ correctly answer ` ` : ) '' program terminate immediately otherwise 'll receive ` ` : ( ` ` make $$$ 2 $$$ guess print a query forget output end line flush output otherwise get idleness limit exceed , use : hack allow problem answer first question correct $$$ x $$$ would equal $$$ 6 $$$ see first guess $$$ 6 $$$ answer answer first question joke know answer least one two question correct since answer first question joke answer second question correct understand $$$ x $$$ equal $$$ 1 2 3 $$$ $$$ 4 $$$ also know $$$ x $$$ equal $$$ 6 $$$ either hence $$$ x $$$ equal $$$ 5 $$$",['dp'],3200.0
1747/A,give array $$$ a $$$ consist $$$ n $$$ integers want distribute $$$ n $$$ integers two group $$$ s_1 $$$ $$$ s_2 $$$ ( group empty ) follow condition satisfy : $$$ sum ( s_1 ) $$$ denote sum number group $$$ s_1 $$$ $$$ sum ( s_2 ) $$$ denote sum number group $$$ s_2 $$$ determine maximum possible value $$$ |sum ( s_1 ) | - |sum ( s_2 ) | $$$ input consist multiple test case first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 2 \cdot 10000 ) $$$ — number test case description test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 1 \leq n \leq 100000 ) $$$ — length array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( -1000000000 \leq a_i \leq 1000000000 ) $$$ — elements array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case output a single integer — maximum possible value $$$ |sum ( s_1 ) | - |sum ( s_2 ) | $$$ first testcase distribute $$$ s_1 = \ { 10\ } $$$ $$$ s_2 = \ { <unknown> } $$$ value $$$ <unknown> - <unknown> = 0 $$$ second testcase distribute $$$ s_1 = \ { 0 11 -1\ } $$$ $$$ s_2 = \ { <unknown> } $$$ value $$$ |0 + 11 - 1| - <unknown> = 10 - 2 = 8 $$$ third testcase distribute $$$ s_1 = \ { 2 3 2\ } $$$ $$$ s_2 = \ { \ } $$$ value $$$ |2 + 3 + 2| - |0| = 7 $$$ fourth testcase distribute $$$ s_1 = \ { -9 -4 0\ } $$$ $$$ s_2 = \ { 2 0\ } $$$ value $$$ <unknown> - 4 + 0| - |2 + 0| = 13 - 2 = 11 $$$,['greedy'],800.0
1748/B,a non - empty digit string diverse number occurrences character n't exceed number distinct character example : give a string $$$ s $$$ length $$$ n $$$ consist digits $$$ 0 $$$ $$$ 9 $$$ find many $$$ \frac { n ( n+1 ) } { 2 } $$$ substrings diverse a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end note diverse string appear $$$ s $$$ multiple time occurrence count independently example two diverse substrings ` ` 77 '' equal ` ` 7 '' answer string ` ` 77 '' $$$ 2 $$$ test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length string $$$ s $$$ second line test case contain a string $$$ s $$$ length $$$ n $$$ guarantee character $$$ s $$$ digits $$$ 0 $$$ $$$ 9 $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print one integer — number diverse substrings give string $$$ s $$$ first test case diverse substring ` ` 7 '' second test case diverse substring ` ` 7 '' appear twice answer $$$ 2 $$$ third test case diverse substrings ` ` 0 '' ( $$$ 2 $$$ time ) ` ` 01 '' ` ` 010 '' ` ` 1 '' ( $$$ 2 $$$ time ) ` ` 10 '' ( $$$ 2 $$$ time ) ` ` 101 '' ` ` 1010 '' fourth test case diverse substrings ` ` 0 '' ( $$$ 3 $$$ time ) ` ` 01 '' ` ` 011 '' ` ` 0110 '' ` ` 1 '' ( $$$ 2 $$$ time ) ` ` 10 '' ` ` 100 '' ` ` 110 '' ` ` 1100 '' fifth test case diverse substrings ` ` 3 '' ` ` 39 '' ` ` <unknown> '' ` ` 6 '' ` ` 9 '' ( $$$ 4 $$$ time ) ` ` 96 '' ` ` <unknown> '' sixth test case $$$ 15 $$$ non - empty substrings ` ` <unknown> '' diverse,"['brute force', 'implementation', 'strings']",1400.0
1749/A,'s a chessboard size $$$ n \times n $$$ $$$ m $$$ rook place a way : a rook attack cells row column possible move exactly one rook ( choose one move ) a different cell two rook still attack ? a rook move cell row column rook stand path first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 2000 $$$ ) — number testcases first line testcase contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 8 $$$ ) — size chessboard number rook $$$ i $$$ -th next $$$ m $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ ) — position $$$ i $$$ -th rook : $$$ x_i $$$ row $$$ y_i $$$ column two rook occupy cell two rook attack testcase print ` ` yes '' 's possible move exactly one rook a different cell two rook still attack otherwise print ` ` '' first testcase rook opposite corner a $$$ 2 \times 2 $$$ board a move a neighbour corner move mean get attack another rook second testcase 's a single rook a middle a $$$ 3 \times 3 $$$ board $$$ 4 $$$ valid move every move fine 's rook attack,"['greedy', 'implementation']",800.0
1749/D,consider array $$$ a $$$ length $$$ n $$$ elements number $$$ 1 $$$ $$$ n $$$ possible remove $$$ i $$$ -th element $$$ a $$$ $$$ gcd ( a_i i ) = 1 $$$ $$$ gcd $$$ denote greatest common divisor element remove elements right shift leave one position array $$$ b $$$ $$$ n $$$ integers $$$ 1 \le b_i \le n - i + 1 $$$ a removal sequence array $$$ a $$$ possible remove elements $$$ a $$$ remove $$$ b_1 $$$ -th element $$$ b_2 $$$ -th ... $$$ b_n $$$ -th element example let $$$ a = [ 42 314 ] $$$ : array ambiguous least two removal sequence example array $$$ [ 1 2 5 ] $$$ ambiguous : removal sequence $$$ [ 3 1 1 ] $$$ $$$ [ 1 2 1 ] $$$ array $$$ [ 42 314 ] $$$ ambiguous : removal sequence $$$ [ 1 1 ] $$$ give two integers $$$ n $$$ $$$ m $$$ calculate number ambiguous array $$$ a $$$ length $$$ a $$$ $$$ 1 $$$ $$$ n $$$ $$$ a_i $$$ integer $$$ 1 $$$ $$$ m $$$ line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 300000 $$$ ; $$$ 1 \le m \le 10^ { 12 } $$$ ) print one integer — number ambiguous array $$$ a $$$ length $$$ a $$$ $$$ 1 $$$ $$$ n $$$ $$$ a_i $$$ integer $$$ 1 $$$ $$$ m $$$ since answer large print modulo $$$ 998244353 $$$,"['combinatorics', 'dp', 'math', 'number theory']",1900.0
175/D,vasya play plane tank tank describe follow attribute : gun damage describe a segment [ l r ] l r integer number potential gun damage x choose equal probability among integer number segment [ l r ] shoot pierce armor enemy 's tank enemy lose x hit point number hit point become non - positive enemy tank consider destroy possible shoot pierce armor a tank case number hit point n't change probability armor pierce consider shoot tank attribute depend players ' behavior victory near one enemy tank leave vasya ready battle — one battle good evil inevitable ! two enemies saw fire a shoot moment ... last battle begin ! help vasya determine probability win battle destroy enemy tank ? tank destroy ( simultaneous shots ) vasya consider a winner assume player fire a shoot gun recharge tank infinite number ammo first line contain five integer number separate space describe vasya 's tank : number hit point hp ( 10 ≤ hp ≤ 200 ) interval two shots dt ( 1 ≤ dt ≤ 30 ) gun damage segment l r ( 10 ≤ l ≤ r ≤ 100 ) probability enemy 's tank armor pierce p ( 0 ≤ p ≤ 100 ) ( percents ) second line describe tank vasya 's enemy format print number absolute relative error 10 - 4 — probability vasya 's victory first example tank destroy second shoot probability destroy enemy tank 1 . second example vasya 's enemy tank fire second shoot vasya 's tank time third shoot order destroy vasya 's tank necessary fire two shots damage 50 . probability event = otherwise vasya win third example vasya 's enemy tank fire three shots probability armor pierce 0.5 . order destroy vasya 's tank necessary least 2 3 shots pierce armor vasya 's tank probability event 0.5,"['brute force', 'dp', 'math']",2400.0
1750/A,"give a permutation $$$ a_1 a_2 \ldots a_n $$$ size $$$ n $$$ integer $$$ 1 $$$ $$$ n $$$ appear exactly follow operation number time ( possibly zero ) : determine whether make array $$$ a $$$ sort non - descending order test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 10 $$$ ) — length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ $$$ a_i \neq a_j $$$ $$$ i \neq j $$$ ) — elements array $$$ a $$$ test case output ` ` yes '' ( without quote ) array sort non - descending order ` ` '' ( without quote ) otherwise output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first test case $$$ [ 1,2,3 ] $$$ already sort non - descending order second test case choose $$$ i = 1 j = 2 k = 3 $$$ since $$$ a_1 \le a_3 $$$ swap $$$ a_2 $$$ $$$ a_3 $$$ array become $$$ [ 1,2,3 ] $$$ sort non - descending order seventh test case follow operations successively : third fourth fifth sixth test case show array sort non - descending order","['implementation', 'math']",800.0
1750/D,"give two integers $$$ n $$$ $$$ m $$$ array $$$ a $$$ $$$ n $$$ integers $$$ 1 \le i \le n $$$ hold $$$ 1 \le a_i \le m $$$ task count number different array $$$ b $$$ length $$$ n $$$ : $$$ \gcd ( a_1 a_2 \dots a_i ) $$$ denote greatest common divisor ( gcd ) integers $$$ a_1 a_2 \ldots a_i $$$ since number large print modulo $$$ 998\,244\,353 $$$ test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le m \le 1000000000 $$$ ) — length array $$$ a $$$ maximum possible value element second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le m $$$ ) — elements array $$$ a $$$ guarantee sum $$$ n $$$ across test case n't exceed $$$ 200000 $$$ test case print a single integer — number different array satisfy condition since number large print modulo $$$ 998\,244\,353 $$$ first test case possible array $$$ b $$$ : second test case array satisfy demand $$$ [ 1,1 ] $$$ third test case prove array exist","['combinatorics', 'math', 'number theory']",1800.0
1750/H,"give a binary string $$$ s $$$ length $$$ n $$$ define a maximal substring a substring extend keep elements equal example string $$$ <unknown> $$$ three maximal substrings : $$$ 11 $$$ $$$ 000 $$$ $$$ 111 $$$ one operation select two maximal adjacent substrings since maximal adjacent 's easy see elements must different value let $$$ a $$$ length sequence ones $$$ b $$$ length sequence zero follow : example $$$ <unknown> $$$ make $$$ <unknown> $$$ $$$ 0011 $$$ make $$$ 1111 $$$ call a string good turn $$$ 1111 ... 1111 $$$ use aforementioned operation number time ( possibly zero ) find number good substrings among $$$ \frac { n ( n+1 ) } { 2 } $$$ non - empty substrings $$$ s $$$ test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case description test case follow first line test case contain $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length string $$$ s $$$ second line test case contain binary string $$$ s $$$ length $$$ n $$$ guarantee sum $$$ n $$$ across test case n't exceed $$$ 200000 $$$ test case print a single integer — number good substrings let 's define a substring index $$$ l $$$ index $$$ r $$$ $$$ [ l r ] $$$ first test case good substrings : second test case substrings good except $$$ [ 2,2 ] $$$ third test case substrings good","['data structures', 'dp']",3500.0
1759/E,"$$$ n $$$ astronauts work space station astronaut number $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) power $$$ a_i $$$ evil humanoid make way space station power humanoid equal $$$ h $$$ also humanoid take two green <unknown> one blue serum one second a humanoid three action : astronaut power $$$ a_i $$$ absorb astronaut disappear power humanoid increase $$$ \lfloor \frac { a_i } { 2 } \rfloor $$$ , integer part $$$ \frac { a_i } { 2 } $$$ example a humanoid absorb astronaut power $$$ 4 $$$ power increase $$$ 2 $$$ a humanoid absorb astronaut power $$$ 7 $$$ power increase $$$ 3 $$$ use green serum serum disappear power humanoid double increase $$$ 2 $$$ time use blue serum serum disappear power humanoid triple increase $$$ 3 $$$ time humanoid wonder maximum number astronauts able absorb act optimally first line test contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain integers $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number astronauts $$$ h $$$ ( $$$ 1 \le h \le 1000000 $$$ ) — initial power humanoid second line test case contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 1 \le a_i \le 100000000 $$$ ) — power astronauts guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case a separate line print maximum number astronauts a humanoid absorb first case proceed follow :","['brute force', 'dp', 'sortings']",1500.0
1759/F,a positive number $$$ x $$$ length $$$ n $$$ base $$$ p $$$ ( $$$ 2 \le p \le 1000000000 $$$ ) write blackboard number $$$ x $$$ give a sequence $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i < p $$$ ) — digits $$$ x $$$ order leave right ( significant least significant ) dmitry fond digits number system want see least one operation : example $$$ p=5 $$$ $$$ <unknown> $$$ task determine minimum number operations require make digits $$$ 0 $$$ $$$ p-1 $$$ appear board least first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 2000 $$$ ) — number test case descriptions input test case follow first line description test case contain two integers $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) $$$ p $$$ ( $$$ 2 \le p \le 1000000000 $$$ ) — length number base number system second line description test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i < p $$$ ) — digits $$$ x $$$ number system base $$$ p $$$ guarantee number $$$ x $$$ contain lead zero ( $$$ a_1 > 0 $$$ ) test case print a single integer — minimum number operations require dmitry get digits board $$$ 0 $$$ $$$ p-1 $$$ show always require a finite number operations,"['binary search', 'data structures', 'greedy', 'math', 'number theory']",1800.0
1759/G,"a sequence $$$ n $$$ number call permutation contain number $$$ 1 $$$ $$$ n $$$ exactly example sequence [ $$$ 3 1 4 2 $$$ ] [ $$$ 1 $$$ ] [ $$$ 2,1 $$$ ] permutations [ $$$ 1,2,1 $$$ ] [ $$$ 0,1 $$$ ] [ $$$ 1,3,4 $$$ ] — a permutation $$$ p $$$ even length $$$ n $$$ make array $$$ b $$$ length $$$ \frac { n } { 2 } $$$ : example $$$ p $$$ = [ $$$ 2 4 3 1 5 6 $$$ ] : a give array $$$ b $$$ find lexicographically minimal permutation $$$ p $$$ make give array $$$ b $$$ $$$ b $$$ = [ $$$ <unknown> $$$ ] lexicographically minimal permutation make $$$ p $$$ = [ $$$ <unknown> $$$ ] since : a permutation $$$ x_1 x_2 \dots x_n $$$ lexicographically smaller a permutation $$$ y_1 y_2 \dots y_n $$$ exist $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) $$$ x_1 = y_1 x_2 = y_2 \dots x _ { i-1 } = y _ { i-1 } $$$ $$$ x_i < y_i $$$ first line input data contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain one even integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) second line test case contain exactly $$$ \frac { n } { 2 } $$$ integers $$$ b_i $$$ ( $$$ 1 \le b_i \le n $$$ ) — elements array $$$ b $$$ guarantee sum $$$ n $$$ value test case exceed $$$ 200000 $$$ test case print a separate line : first test case parse problem statement","['binary search', 'data structures', 'greedy', 'math']",1900.0
176/B,let 's consider one interest word game game transform one word another special operations let 's say word w let 's split word two non - empty part x y w = xy a split operation transform word w = xy word u = yx example a split operation transform word ` ` <unknown> '' word ` ` <unknown> '' give two word start end count many ways transform word start word end apply exactly k split operations consecutively word start two ways consider different sequence apply operations differ two operation sequence different exist number i ( 1 ≤ i ≤ k ) i - th operation first sequence word split part x y i - th operation second sequence word split part a b additionally x ≠ a hold first line contain a non - empty word start second line contain a non - empty word end word consist lowercase latin letter number letter word start equal number letter word end least 2 n't exceed 1000 letter third line contain integer k ( 0 ≤ k ≤ 105 ) — require number operations print a single number — answer problem number rather large print modulo 1000000007 ( 109 + 7 ) seek way first sample : ab → a|b → ba → <unknown> → <unknown> second sample two seek ways :,['dp'],1700.0
176/E,"time help a team researchers island pacific ocean research culture ancient tribes use inhabit island many years ago overall ' ve dig n villages pair villages connect roads people could go roads directions overall exactly n - 1 roads village one could get one tribes peaceful many war a result war villages destroy completely peaceful years villages restore moment time people use roads belong shortest way two villages exist give moment word people use minimum subset roads a way possible get exist village exist one note throughout island 's whole history exist exactly n - 1 roads find researchers never roads researchers think observe total sum use roads ’ lengths different moments time help better understand tribes ' culture answer several historical question give full history tribes ' existence task determine total length use roads moments time first line contain integer n ( 1 ≤ n ≤ 105 ) — number villages next n - 1 line describe roads i - th line contain three integers ai bi ci ( 1 ≤ ai bi ≤ n ai ≠ bi 1 ≤ ci ≤ 109 1 ≤ i < n ) — number villages connect i - th road road 's length number line separate a space next line contain integer q ( 1 ≤ q ≤ 105 ) — number query follow q query one per line order time query belong one three type : guarantee query contradict , wo n't query destroy non - existing villages restore already exist ones guarantee least one query type ` ` ? ` ` also guarantee one get village one give roads initial moment time village consider exist query type ` ` ? '' print total length use roads a single line print answer query order give input please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier","['data structures', 'dfs and similar', 'trees']",3100.0
1760/G,"give a weight tree $$$ n $$$ vertices recall a tree a connect graph without cycle a weight tree a tree edge a certain weight tree undirected n't a root since tree bore decide challenge play a game give tree a move travel a node one neighbor ( another node a direct edge ) start a variable $$$ x $$$ initially equal $$$ 0 $$$ pass edge $$$ i $$$ $$$ x $$$ change value $$$ x ~\mathsf { xor } ~ w_i $$$ ( $$$ w_i $$$ weight $$$ i $$$ -th edge ) task go vertex $$$ a $$$ vertex $$$ b $$$ allow enter node $$$ b $$$ travel value $$$ x $$$ become $$$ 0 $$$ word travel node $$$ b $$$ use edge $$$ i $$$ $$$ x ~\mathsf { xor } ~ w_i = 0 $$$ enter node $$$ b $$$ game end win additionally teleport point time vertex except vertex $$$ b $$$ teleport vertex even $$$ a $$$ answer ` ` yes '' reach vertex $$$ b $$$ $$$ a $$$ ` ` '' otherwise note $$$ \mathsf { xor } $$$ represent bitwise xor operation first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain three integers $$$ n $$$ $$$ a $$$ $$$ b $$$ ( $$$ 2 \leq n \leq 100000 $$$ ) ( $$$ 1 \leq a b \leq n ; a \ne b $$$ ) — number vertices start desire end node respectively next $$$ n-1 $$$ line denote edge tree edge $$$ i $$$ denote three integers $$$ u_i $$$ $$$ v_i $$$ $$$ w_i $$$ — label vertices connect ( $$$ 1 \leq u_i v_i \leq n ; u_i \ne v_i ; 1 \leq w_i \leq 1000000000 $$$ ) weight respective edge guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output ` ` yes '' reach vertex $$$ b $$$ ` ` '' otherwise first test case travel node $$$ 1 $$$ node $$$ 3 $$$ $$$ x $$$ change $$$ 0 $$$ $$$ 1 $$$ travel node $$$ 3 $$$ node $$$ 2 $$$ $$$ x $$$ become equal $$$ 3 $$$ , teleport node $$$ 3 $$$ travel node $$$ 3 $$$ node $$$ 4 $$$ reach node $$$ b $$$ since $$$ x $$$ become equal $$$ 0 $$$ end answer ` ` yes '' second test case move since ca n't teleport node $$$ b $$$ move travel node $$$ 2 $$$ impossible since $$$ x $$$ would n't equal $$$ 0 $$$ reach answer ` ` ''","['bitmasks', 'dfs and similar', 'graphs']",1700.0
1761/D,"let $$$ f ( x y ) $$$ number carry $$$ x+y $$$ binary ( i. e. $$$ f ( x y ) = g ( x ) + g ( y ) -g ( x+y ) $$$ $$$ g ( x ) $$$ number ones binary representation $$$ x $$$ ) give two integers $$$ n $$$ $$$ k $$$ find number order pair $$$ ( a b ) $$$ $$$ 0 \leq a b < 2^n $$$ $$$ f ( a b ) $$$ equal $$$ k $$$ note $$$ a\ne b $$$ $$$ ( a b ) $$$ $$$ ( b a ) $$$ consider two different pair number may large output modulo $$$ 1000000000 + 7 $$$ line test contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 0\leq k < n\leq 1000000 $$$ ) output a single integer — answer modulo $$$ 1000000000 + 7 $$$ examples understand carry : $$$ $$$ \begin { align } & \begin { array } { r } 1 _ { \ \ } 1 _ { \ \ } 1\\ + \ _ { 1 } 1 _ { \ \ } 0 _ { \ \ } 0\\ \hline \ 1 _ { \ \ } 0 _ { \ \ } 1 _ { \ \ } 1 \end { array } & \begin { array } { r } \ 1 _ { \ \ } 0 _ { \ \ } 1\\ + \ _ { \ \ } 0 _ { \ \ } 0 _ { 1 } 1\\ \hline \ 0 _ { \ \ } 1 _ { \ \ } 1 _ { \ \ } 0 \end { array } & & \begin { array } { r } \ 1 _ { \ \ } 0 _ { \ \ } 1\\ + \ _ { 1 } 0 _ { 1 } 1 _ { 1 } 1\\ \hline \ 1 _ { \ \ } 0 _ { \ \ } 0 _ { \ \ } 0 \end { array } \end { align } $$$ $$$ $$$ f ( 7,4 ) = 1 $$$ $$$ f ( 5,1 ) = 1 $$$ $$$ f ( 5,3 ) =3 $$$ first test case pair meet constraints $$$ ( 1,1 ) ( 1,5 ) ( 2,2 ) ( 2,3 ) ( 3,2 ) ( 4,4 ) ( 4,5 ) ( 4,6 ) ( 4,7 ) ( 5,1 ) ( <unknown> ) ( 5,6 ) ( 6,4 ) ( 6,5 ) ( 7,4 ) $$$","['combinatorics', 'math']",2100.0
1761/F1,easy version problem difference two versions constraint $$$ n $$$ make hack versions problem solve let 's call array $$$ a $$$ odd length $$$ 2m+1 $$$ ( $$$ m \ge 1 $$$ ) bad element $$$ a _ { m+1 } $$$ equal median array word array bad sort element $$$ m+1 $$$ -st position remain let 's call a permutation $$$ p $$$ integers $$$ 1 $$$ $$$ n $$$ anti - median every subarray odd length $$$ \ge 3 $$$ bad already give value elements permutation find number ways set unknown value obtain anti - median permutation number large find modulo $$$ 1000000000 + 7 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 2 \le n \le 1000 ) $$$ — length permutation second line test case contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i = -1 $$$ ) — elements permutation $$$ p_i \neq -1 $$$ 's give else 's unknown 's guarantee $$$ i \neq j $$$ hold $$$ p_i \neq -1 p_j \neq -1 $$$ $$$ p_i \neq p_j $$$ guarantee sum $$$ n^2 $$$ test case exceed $$$ 1000000 $$$ test case output a single integer — number ways set unknown value obtain anti - median permutation modulo $$$ 1000000000 + 7 $$$ first test case $$$ [ 1 2 ] $$$ $$$ [ 2 1 ] $$$ anti - median second test case permutations $$$ [ 1 3 2 ] [ 2 1 3 ] [ 2 3 1 ] [ 3 1 2 ] $$$ anti - median remain two permutations $$$ [ 1 2 3 ] $$$ $$$ [ 3 2 1 ] $$$ bad array median $$$ 2 $$$ middle third test case $$$ [ 1 2 3 4 ] $$$ n't anti - median contain bad subarray $$$ [ 1 2 3 ] $$$ fourth test case anti - median array get $$$ [ 5 6 3 4 1 2 ] $$$,"['dp', 'math']",3100.0
1764/A,"doremy $$$ n $$$ bucket paint represent array $$$ a $$$ length $$$ n $$$ bucket $$$ i $$$ contain paint color $$$ a_i $$$ let $$$ c ( l r ) $$$ number distinct elements subarray $$$ [ a_l a _ { l+1 } \ldots a_r ] $$$ choose $$$ 2 $$$ integers $$$ l $$$ $$$ r $$$ $$$ l \leq r $$$ $$$ r - l - c ( l r ) $$$ maximize input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) guarantee sum $$$ n $$$ exceed $$$ 100000 $$$ test case output $$$ l $$$ $$$ r $$$ $$$ l \leq r $$$ $$$ r - l - c ( l r ) $$$ maximize multiple solutions may output first test case $$$ a= [ <unknown> ] $$$ show choose $$$ l=2 $$$ $$$ r=4 $$$ maximize value $$$ r - l - c ( l r ) $$$ $$$ 0 $$$ second test case $$$ a= [ 1,2,3,4,5 ] $$$ show choose $$$ l=1 $$$ $$$ r=5 $$$ maximize value $$$ r - l - c ( l r ) $$$ $$$ -1 $$$ choose $$$ l=3 $$$ $$$ r=3 $$$ also acceptable",['greedy'],800.0
1764/B,` ` everybody ! doremy 's perfect math class start ! come best want much iq ! '' today 's math class doremy teach everyone subtraction give a quiz prove pay attention class give a set $$$ s $$$ contain positive integers may perform follow operation ( possibly zero ) number time : need tell doremy maximum possible number integers $$$ s $$$ operations perform optimally prove number finite input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 10000 $$$ ) — number test case description test case follow first line contain integer $$$ n $$$ ( $$$ 2 \le n\le 100000 $$$ ) — size set $$$ s $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1\le a_1 < a_2 < \cdots < a_n \le 1000000000 $$$ ) — positive integers $$$ s $$$ guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case need output maximum possible number integers $$$ s $$$ prove value finite first test case $$$ x $$$ $$$ y $$$ exist maximum possible number integers $$$ s $$$ $$$ 2 $$$ second test case perform operations number integers $$$ s $$$ $$$ 5 $$$ prove sequence operations allow $$$ s $$$ contain $$$ 5 $$$ integers,"['math', 'number theory']",900.0
1764/E,"doremy two array $$$ a $$$ $$$ b $$$ $$$ n $$$ integers integer $$$ k $$$ initially a number line integers color choose a permutation $$$ p $$$ $$$ [ 1,2 \ldots n ] $$$ perform $$$ n $$$ move $$$ i $$$ -th move follow : determine integer $$$ k $$$ color color $$$ 1 $$$ input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 10000 $$$ ) — number test case description test case follow first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 1 \le k \le 1000000000 $$$ ) follow $$$ n $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output ` ` yes '' ( without quote ) point $$$ k $$$ color color $$$ 1 $$$ otherwise output ` ` '' ( without quote ) output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first test case impossible color point $$$ 16 $$$ color $$$ 1 $$$ second test case $$$ p= [ 2,1,3,4 ] $$$ one possible choice detail show third test case $$$ p= [ 2,1,4,3 ] $$$ one possible choice fourth test case $$$ p= [ 2,3,4,1 ] $$$ one possible choice","['dp', 'greedy', 'sortings']",2400.0
1764/H,doremy $$$ n $$$ bucket paint represent array $$$ a $$$ length $$$ n $$$ bucket $$$ i $$$ contain paint color $$$ a_i $$$ initially $$$ a_i = i $$$ doremy $$$ m $$$ segment $$$ [ l_i r_i ] $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) segment describe operation operation $$$ i $$$ perform follow : doremy also select integer $$$ k $$$ want know integer $$$ x $$$ $$$ 0 $$$ $$$ m-1 $$$ number distinct color array perform operations $$$ x \bmod m +1 ( x+1 ) \bmod m + 1 \ldots ( x+k-1 ) \bmod m +1 $$$ help calculate value ? note $$$ x $$$ individually start initial array perform give $$$ k $$$ operations give order first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1\le n m\le 2\cdot 100000 $$$ $$$ 1 \le k \le m $$$ ) — length array $$$ a $$$ total number operations integer doremy select $$$ i $$$ -th line follow $$$ m $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1\le l_i\le r_i\le n $$$ ) — bound $$$ i $$$ -th segment output $$$ m $$$ integers $$$ ( x+1 ) $$$ -th integer number distinct color array start initial array perform operations $$$ x \bmod m +1 ( x+1 ) \bmod m + 1 \ldots ( x+k-1 ) \bmod m +1 $$$ first test case picture show result array value $$$ <unknown> $$$ respectively,['data structures'],3400.0
1765/F,"monocarp plan open a chemistry lab first month 's go distribute solutions a certain acid first sign contract a local chemistry factory contract provide monocarp unlimited supply solution acid factory provide $$$ n $$$ contract options number $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th solution a concentration $$$ <unknown> % $$$ contract cost $$$ w_i $$$ burl monocarp able sell $$$ c_i $$$ burl per liter monocarp expect $$$ k $$$ customers first month customer buy a liter a $$$ y\ % $$$ <unknown> $$$ y $$$ a real number choose uniformly random $$$ 0 $$$ $$$ 100 $$$ independently customer formally probability number $$$ y $$$ less equal $$$ t $$$ $$$ p ( y \le t ) = \frac { t } { 100 } $$$ monocarp mix solution sign contract factory ratio formally contract $$$ m $$$ solutions <unknown> $$$ x_1 x_2 \dots x_m $$$ , solutions pick volumes $$$ a_1 a_2 \dots a_m $$$ $$$ \sum \limits _ { i=1 } ^ { m } a_i = 1 $$$ ( exactly $$$ 1 $$$ since customer want exactly one liter a certain solution ) concentration result solution $$$ \sum \limits _ { i=1 } ^ { m } x_i \cdot a_i $$$ price result solution $$$ \sum \limits _ { i=1 } ^ { m } c_i \cdot a_i $$$ monocarp obtain a solution concentration $$$ y\ % $$$ maximize price ( cost customer ) otherwise customer leave without buy anything price consider equal $$$ 0 $$$ monocarp want sign contract a factory ( possibly none ) expect profit maximize — expect total price sell solutions $$$ k $$$ customers minus total cost sign contract factory print maximum expect profit monocarp achieve first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 5000 $$$ ; $$$ 1 \le k \le 100000 $$$ ) — number contract factory provide number customers $$$ i $$$ -th next $$$ n $$$ line contain three integers $$$ x_i w_i $$$ $$$ c_i $$$ ( $$$ 0 \le x_i \le 100 $$$ ; $$$ 1 \le w_i \le 1000000000 $$$ ; $$$ 1 \le c_i \le 100000 $$$ ) — concentration solution cost contract cost per liter customer $$$ i $$$ -th contract print a single real number — maximum expect profit monocarp achieve answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -6 } $$$","['dp', 'geometry']",2200.0
1765/K,give a square grid $$$ n $$$ row $$$ n $$$ columns cell a non - negative integer write a chip initially place top leave cell ( cell coordinate $$$ ( 1 1 ) $$$ ) need move chip bottom right cell ( cell coordinate $$$ ( n n ) $$$ ) one step move chip neighbor cell : total score count sum number cells visit maximum possible score achieve ? first line contain single integer $$$ n $$$ ( $$$ 2 \le n \le 200 $$$ ) — number row columns grid next $$$ n $$$ line contain description row grid $$$ i $$$ -th line contain $$$ n $$$ integers $$$ a _ { i 1 } a _ { i 2 } \dots a _ { i n } $$$ ( $$$ 0 \le a _ { i j } \le 1000000000 $$$ ) $$$ a _ { i j } $$$ number write cell $$$ ( i j ) $$$ print one integer — maximum possible score achieve,"['greedy', 'math']",1500.0
1765/L,$$$ n $$$ employees bersoft company number $$$ 1 $$$ $$$ n $$$ employee work days week rest days give list work days week employee regular days holiday regular days employees work current day week list holiday one work provide a list days holiday days number $$$ 1 $$$ onwards day $$$ 1 $$$ monday company receive $$$ k $$$ project offer complete project number $$$ 1 $$$ $$$ k $$$ order decrease priority project consist multiple part $$$ i $$$ -th part must complete $$$ a_i $$$ -th employee part must complete order ( i. e. $$$ ( i+1 ) $$$ -st part start $$$ i $$$ -th part complete ) part take correspond employee a day complete project work simultaneously however one employee complete a part one project a single day a choice project complete a part always go project highest priority ( lowest index ) project output day project complete first line contain three integers $$$ n m $$$ $$$ k $$$ ( $$$ 1 \le n m k \le 200000 $$$ ) — number employees number holiday number project $$$ i $$$ -th next $$$ n $$$ line contain list work days $$$ i $$$ -th employee first a single integer $$$ t $$$ ( $$$ 1 \le t \le 7 $$$ ) — number work days $$$ t $$$ days week increase order possible days : ` ` monday '' ` ` tuesday '' ` ` wednesday '' ` ` thursday '' ` ` friday '' ` ` saturday '' ` ` sunday '' next line contain $$$ m $$$ integers $$$ h_1 h_2 \dots h_m $$$ ( $$$ 1 \le h_1 < h_2 < \dots < h_m \le 1000000000 $$$ ) — list holiday $$$ j $$$ -th next $$$ k $$$ line contain a description $$$ j $$$ -th project start integer $$$ p $$$ ( $$$ 1 \le p \le 200000 $$$ ) — number part project $$$ p $$$ integers $$$ a_1 a_2 \dots a_p $$$ ( $$$ 1 \le a_x \le n $$$ ) follow $$$ p_i $$$ index employee must complete $$$ i $$$ -th part total number part project n't exceed $$$ 200000 $$$ print $$$ k $$$ integers — $$$ j $$$ -th value equal day $$$ j $$$ -th project complete,"['brute force', 'data structures', 'implementation']",2400.0
1766/B,want type string $$$ s $$$ consist $$$ n $$$ lowercase latin letter use favorite text editor notepad # notepad # support two kinds operations : type string $$$ s $$$ strictly less $$$ n $$$ operations ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length string $$$ s $$$ second line contain a string $$$ s $$$ consist $$$ n $$$ lowercase latin letter sum $$$ n $$$ n't exceed $$$ 200000 $$$ testcases testcase print ` ` yes '' type string $$$ s $$$ strictly less $$$ n $$$ operations otherwise print ` ` '' first testcase start type ` ` <unknown> '' ( $$$ 5 $$$ operations ) copy ` ` o '' ( $$$ 1 $$$ operation ) already type part finish type ` ` rces '' ( $$$ 4 $$$ operations ) $$$ 10 $$$ operations strictly less $$$ n $$$ exist ways type ` ` codeforces '' however matter ca n't less $$$ n $$$ operations second testcase type ` ` <unknown> '' ( $$$ 5 $$$ operations ) copy ` ` aba '' ( $$$ 1 $$$ operation ) finish string $$$ 6 $$$ operations,['implementation'],1000.0
1766/C,"sir monocarp <unknown> plan paint wall wall represent a grid consist $$$ 2 $$$ row $$$ m $$$ columns initially wall completely white monocarp want paint a black picture wall particular want cell $$$ ( i j ) $$$ ( $$$ j $$$ -th cell $$$ i $$$ -th row ) color black $$$ c _ { i j } = $$$ ' b ' leave white $$$ c _ { i j } = $$$ ' w ' additionally want column least one black cell , $$$ j $$$ follow constraint satisfy : $$$ c _ { 1 j } $$$ $$$ c _ { 2 j } $$$ equal ' b ' order picture turn smooth monocarp want place a paint brush cell $$$ ( x_1 y_1 ) $$$ move along path $$$ ( x_1 y_1 ) ( x_2 y_2 ) \dots ( x_k y_k ) $$$ : determine monocarp paint wall first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 200000 $$$ ) — number columns wall $$$ i $$$ -th next two line contain a string $$$ c_i $$$ consist $$$ m $$$ character character either ' b ' ' w ' $$$ c _ { i j } $$$ ' b ' cell $$$ ( i j ) $$$ color black ' w ' cell $$$ ( i j ) $$$ leave white additionally $$$ j $$$ follow constraint satisfy : $$$ c _ { 1 j } $$$ $$$ c _ { 2 j } $$$ equal ' b ' sum $$$ m $$$ testcases n't exceed $$$ 200000 $$$ testcase print ` ` yes '' monocarp paint a wall otherwise print ` ` '' first testcase monocarp follow a path $$$ ( 2 1 ) $$$ $$$ ( 2 2 ) $$$ $$$ ( 1 2 ) $$$ $$$ ( 1 3 ) $$$ brush black cells appear path exactly white cells appear path second testcase monocarp follow a path $$$ ( 1 1 ) $$$ $$$ ( 2 1 ) $$$ third testcase :","['dp', 'implementation']",1300.0
1767/A,"give a non - degenerate triangle ( a non - degenerate triangle a triangle positive area ) vertices triangle coordinate $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ $$$ ( x_3 y_3 ) $$$ want draw a straight line cut triangle two non - degenerate triangles furthermore line draw either horizontal vertical draw line meet constraints ? suitable ways draw line : however ways draw line suitable ( first line cut triangle a triangle a <unknown> ; second line n't cut triangle ; third line neither horizontal vertical ) : first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist four line first empty $$$ i $$$ -th next three line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le 100000000 $$$ ) — coordinate $$$ i $$$ -th vertex triangle additional constraint input : test case triangle form three vertices positive area ( i. e. non - degenerate ) test case print yes possible cut triangle accord statement otherwise may print letter case ( yes yes yes recognize positive answer , recognize negative answer )",['implementation'],800.0
1767/C,give integer $$$ n $$$ calculate number binary ( consist character 0 and/or 1 ) string $$$ s $$$ meet follow constraints every pair integers $$$ ( i j ) $$$ $$$ 1 \le i \le j \le n $$$ integer $$$ a _ { i j } $$$ give impose follow constraint string $$$ s_i s _ { i+1 } s _ { i+2 } \dots s_j $$$ : count number binary string $$$ s $$$ length $$$ n $$$ meet aforementioned constraints since answer large print modulo $$$ 998244353 $$$ first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) $$$ n $$$ line follow $$$ i $$$ -th contain $$$ n - i+1 $$$ integers $$$ a _ { i i } a _ { i i+1 } a _ { i i+2 } \dots a _ { i n } $$$ ( $$$ 0 \le a _ { i j } \le 2 $$$ ) print one integer — number string meet constraints take modulo $$$ 998244353 $$$ first example string meet constraints 001 010 011 100 101 110 . second example string meet constraints 001 110,"['data structures', 'dp']",2100.0
1768/F,give array positive integers $$$ a_1 a_2 \ldots a_n $$$ length $$$ n $$$ one operation jump index $$$ i $$$ index $$$ j $$$ ( $$$ 1 \le i \le j \le n $$$ ) pay $$$ \min ( a_i a _ { i + 1 } \ldots a_j ) \cdot ( j - i ) ^2 $$$ eris $$$ k $$$ $$$ 1 $$$ $$$ n $$$ find minimum number eris need get index $$$ 1 $$$ index $$$ k $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 400000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) output $$$ n $$$ integers — $$$ k $$$ -th integer minimum number eris need reach index $$$ k $$$ start index $$$ 1 $$$ first example : fourth example $$$ 1 $$$ $$$ 4 $$$ : $$$ 1 \rightarrow 3 \rightarrow 4 $$$ — cost $$$ \min ( 1 4 4 ) \cdot ( 3 - 1 ) ^ 2 + \min ( 4 4 ) \cdot ( 4 - 3 ) ^ 2 = 4 + 4 = 8 $$$,"['dp', 'greedy']",2900.0
1769/C1,в этой версии задачи $$$ n \le 50 $$$ и $$$ a_i \le 100 $$$ вика за время работы в компании vk уже сделала $$$ n $$$ коммитов в системе контроля версий $$$ i $$$ -й коммит был сделан в $$$ a_i $$$ -й день работы вики в компании в некоторые дни вика могла сделать несколько коммитов а в другие — не сделать ни одного вику интересуют такие отрезки подряд идущих дней что в каждый из этих дней у неё есть хотя бы один коммит чем длиннее будет самый длинный такой отрезок тем более продуктивным сотрудником она будет себя ощущать недавно вика нашла способ подкрутить время любого коммита вперёд но не более чем на сутки таким образом $$$ i $$$ -й коммит теперь может быть « сделан » либо в $$$ a_i $$$ -й либо в $$$ ( a_i + 1 ) $$$ -й день время каждого коммита можно подкрутить независимо от других — в частности можно как оставить всем коммитам исходное время так и перенести все коммиты ровно на день вперёд найдите длину самого длинного возможного отрезка подряд идущих дней в каждый из которых у вики в профиле будет отображаться хотя бы один коммит после возможной подкрутки времени некоторых коммитов каждый тест состоит из нескольких наборов входных данных в первой строке находится одно целое число $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — количество наборов входных данных далее следует описание наборов входных данных первая строка каждого набора входных данных содержит одно целое число $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — число коммитов вторая строка содержит $$$ n $$$ целых чисел $$$ a_1 a_2 \ldots a_n $$$ в неубывающем порядке ( $$$ 1 \le a_1 \le a_2 \le \ldots \le a_n \le 100 $$$ ) — номера дней в которые были сделаны коммиты для каждого набора входных данных выведите одно целое число — максимальную возможную длину отрезка дней в каждый из которых у вики в профиле будет отображаться хотя бы один коммит после возможной подкрутки времени некоторых коммитов вперёд не более чем на сутки в первом наборе входных данных можно поменять дату коммита в день $$$ 3 $$$ на день $$$ 4 $$$ дату коммита в день $$$ 4 $$$ — на день $$$ 5 $$$ а дату любого из коммитов в день $$$ 6 $$$ — на день $$$ 7 $$$ тогда в каждый из дней $$$ 4 $$$ $$$ 5 $$$ $$$ 6 $$$ $$$ 7 $$$ и $$$ 8 $$$ в профиле вики будет отображаться хотя бы один коммит и наибольший отрезок из подряд идущих дней с коммитами — $$$ [ 4 ; 8 ] $$$ — будет иметь длину $$$ 5 $$$ во втором наборе входных данных можно либо оставить все коммиты как есть либо перенести каждый коммит на день вперёд в любом случае длина отрезка дней составит $$$ 6 $$$ в третьем наборе входных данных вика сделала много коммитов но все в один и тот же день с номером $$$ 10 $$$ в лучшем случае отрезок дней достигнет длины $$$ 2 $$$ — если какие - то коммиты оставить на день $$$ 10 $$$ а другие перенести на день $$$ 11 $$$,"['brute force', 'dp', 'greedy']",1200.0
1772/F,start a black - and - white picture represent $$$ n \times m $$$ matrix elements either $$$ 0 $$$ $$$ 1 $$$ row number $$$ 1 $$$ $$$ n $$$ columns number $$$ 1 $$$ $$$ m $$$ several operations perform picture ( possibly zero ) one two kinds : note order operations could arbitrary necessarily alternate present outcome : $$$ k $$$ copy make additionally give initial picture however $$$ k+1 $$$ picture shuffle restore sequence operations multiple answer print test construct real sequence operations i. e. least one answer always exist first line contain three integers $$$ n m $$$ $$$ k $$$ ( $$$ 3 \le n m \le 30 $$$ ; $$$ 0 \le k \le 100 $$$ ) — number row columns picture number copy make respectively $$$ k+1 $$$ picture follow — $$$ k $$$ copy initial picture order arbitrary picture consist $$$ n $$$ line consist $$$ m $$$ character character either $$$ 0 $$$ $$$ 1 $$$ empty line picture first line print a single integer — index initial picture picture number $$$ 1 $$$ $$$ k+1 $$$ order appear input second line print a single integer $$$ q $$$ — number operations next $$$ q $$$ line contain operation operations list order apply operation one two type : index $$$ 1 $$$ $$$ k+1 $$$ appear output exactly — one index initial picture remain $$$ k $$$ arguments operations second kind multiple answer print test construct real sequence operations i. e. least one answer always exist,"['dfs and similar', 'graphs', 'implementation', 'sortings']",2000.0
1773/E,"emma love play block several cubic block size number distinct integers write assemble tower block stack vertically a configuration game a set tower assemble block emma perform two kinds operations a configuration tower : emma want stack block a single tower block come order sort number — block minimal number top block maximal number bottom emma want little split combine operations possible task find minimal number operations make output many split combine need first line input file contain integer $$$ n $$$ ( $$$ 1 \le n \le 10\,000 $$$ ) — number tower initial configuration next $$$ n $$$ line describe tower tower $$$ i $$$ describe a line start number $$$ k_i $$$ ( $$$ k_i \ge 1 $$$ ; $$$ <unknown> { k_i } \le 10\,000 $$$ ) — number block tower follow $$$ k_i $$$ number $$$ b _ { i j } $$$ ( $$$ 1 \le b _ { i j } \le 1000000000 $$$ ) — number write block $$$ i $$$ -th tower list top bottom block number list input different output a line two integers $$$ s $$$ $$$ c $$$ — number split combine operations emma make get a single tower block sort number total number operations minimize example need follow operations ( 1 split 2 combine ) <unknown> <unknown> 2nd onto <unknown> 1st onto 2nd","['greedy', 'sortings']",1400.0
1774/C,"little09 friends play a game $$$ n $$$ players temperature value player $$$ i $$$ $$$ i $$$ type environment express $$$ 0 $$$ $$$ 1 $$$ two players fight a specific environment type $$$ 0 $$$ player a lower temperature value environment always win ; $$$ 1 $$$ player a higher temperature value environment always win type $$$ n-1 $$$ environments form a binary string $$$ s $$$ a length $$$ n-1 $$$ $$$ x $$$ players participate game a total $$$ x-1 $$$ battle type $$$ x-1 $$$ environments first $$$ x-1 $$$ character $$$ s $$$ one player leave tournament choose two remain players fight player lose eliminate tournament type environment battle $$$ i $$$ $$$ s_i $$$ $$$ x $$$ $$$ 2 $$$ $$$ n $$$ answer follow question : players whose temperature value exceed $$$ x $$$ participate game many players a chance win ? test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\le t \le 1000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2\leq n\leq 2\cdot 100000 $$$ ) — number players second line test case contain a binary string $$$ s $$$ a length $$$ n-1 $$$ guarantee sum $$$ n $$$ test case exceed $$$ 3\cdot 100000 $$$ test case output $$$ n-1 $$$ integers — $$$ x $$$ $$$ 2 $$$ $$$ n $$$ output number players a chance win first test case $$$ x=2 $$$ $$$ x=3 $$$ player whose temperature value $$$ 1 $$$ winner $$$ x=4 $$$ player whose temperature value $$$ 2,3,4 $$$ winner","['dp', 'greedy']",1300.0
1774/D,chthollynotaseniorious receive a special gift aquamoon : $$$ n $$$ binary array length $$$ m $$$ aquamoon tell one operation choose two array position $$$ pos $$$ $$$ 1 $$$ $$$ m $$$ swap elements position $$$ pos $$$ array fascinate game want find minimum number operations need make number $$$ 1 $$$ s array invite participate interest game please try find ! possible please output specific exchange step format describe output section otherwise please output $$$ -1 $$$ first line input contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 2\cdot 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 100000 $$$ $$$ 2 \leq m \leq 100000 $$$ ) $$$ i $$$ -th follow $$$ n $$$ line contain $$$ m $$$ integers $$$ a _ { i 1 } a _ { i 2 } \ldots a _ { i m } $$$ $$$ ( 0 \le a _ { i j } \le 1 ) $$$ — elements $$$ i $$$ -th array guarantee sum $$$ n \cdot m $$$ test case exceed $$$ 1000000 $$$ test case objective achievable output $$$ -1 $$$ otherwise first line output $$$ k $$$ $$$ ( 0 \le k \le mn ) $$$ — minimum number operations require $$$ i $$$ -th follow $$$ k $$$ line contain $$$ 3 $$$ integers $$$ x_i y_i z_i $$$ $$$ ( 1 \le x_i y_i \le n 1 \le z_i \le m ) $$$ describe operation swap $$$ a _ { x_i z_i } a _ { y_i z_i } $$$ : swap $$$ z_i $$$ -th number $$$ x_i $$$ -th $$$ y_i $$$ -th array first test case 's enough a single operation : swap first element second first row array become $$$ [ 0 1 1 0 ] [ 1 0 1 0 ] [ 1 0 0 1 ] $$$ contain exactly two $$$ 1 $$$ s,"['brute force', 'greedy', 'implementation', 'two pointers']",1600.0
1775/A1,easy version problem difference versions string longer easy version hack versions problem pass kazimir kazimirovich a martian gardener a huge orchard binary balance apple tree recently casimir decide get three capybaras gardener even come name write a piece paper name capybara a non - empty line consist letter ` ` a '' ` ` b '' denote name capybaras line $$$ a $$$ $$$ b $$$ $$$ c $$$ casimir write nonempty line $$$ a $$$ $$$ b $$$ $$$ c $$$ a row without space example capybara 's name ` ` aba '' ` ` ab '' ` ` bb '' string gardener write would look like ` ` abaabbb '' gardener remember interest property : either string $$$ b $$$ lexicographically smaller string $$$ a $$$ $$$ c $$$ time string $$$ b $$$ lexicographically greater string $$$ a $$$ $$$ c $$$ time word either $$$ a \le b $$$ $$$ c \le b $$$ satisfy $$$ b \le a $$$ $$$ b \le c $$$ satisfy ( possibly condition simultaneously ) $$$ \le $$$ denote lexicographic ` ` less equal '' string thus $$$ a \le b $$$ mean string must either equal string $$$ a $$$ must stand earlier dictionary string $$$ b $$$ a detail explanation operation see ` ` note '' section today gardener look note realize recover name write without space longer sure recover original string $$$ a $$$ $$$ b $$$ $$$ c $$$ want find triplet name satisfy property test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) description test case follow line a test case contain string $$$ s $$$ ( $$$ 3 \le |s| \le 100 $$$ ) — name capybaras write together string consist english letter ' a ' ' b ' guarantee sum string lengths test case exceed $$$ 500 $$$ test case print three string $$$ a $$$ $$$ b $$$ $$$ c $$$ a single line separate space — name capybaras write without space result a line $$$ s $$$ either $$$ a \le b $$$ $$$ c \le b $$$ $$$ b \le a $$$ $$$ b \le c $$$ must satisfy several ways restore name print name recover print ` ` : ( ` ` ( without quote ) a string $$$ x $$$ lexicographically smaller a string $$$ y $$$ one follow hold : let 's move examples first test case one possible ways split line $$$ s $$$ three line — ` ` b '' ` ` bb '' ` ` a '' third test case see split satisfy two condition ( i. e. $$$ a \le b $$$ $$$ c \le b $$$ $$$ b \le a $$$ $$$ b \le c $$$ true simultaneously ),"['brute force', 'implementation']",800.0
1775/F,"know martian scientists actively engage space research one highest priorities pluto order study planet detail decide build a laboratory pluto know lab build $$$ n $$$ square block equal size convenience assume pluto 's surface a plane divide vertical horizontal line unit square square either occupy a lab block $$$ n $$$ square occupy since block square four wall a wall adjacent another block consider inside otherwise — outside pluto famous extremely cold temperatures outside wall lab must <unknown> one unit insulation per exterior wall would require thus greater total length outside wall lab ( i. e. perimeter ) insulation need consider lab layout figure show lab consist $$$ n = 33 $$$ block block a total $$$ 24 $$$ outside wall i. e. $$$ 24 $$$ units insulation need build lab optimally i. e. minimize amount insulation hand may many optimal options scientists may interest number ways build lab use minimum amount insulation modulo a prime number $$$ m $$$ two ways consider overlap without turn thus a lab plan rotate $$$ 90^ { \circ } $$$ a new plan consider a separate way help scientists explore pluto need write a program solve difficult problems first line contain two integers $$$ t $$$ $$$ u $$$ ( $$$ 1 \le t \le 2\cdot 100000 $$$ $$$ 1 \le u \le 2 $$$ ) — number test case test type $$$ u=1 $$$ need find way build lab optimal way $$$ u=2 $$$ need calculate number ways $$$ u=2 $$$ follow line input a prime integer $$$ m $$$ ( $$$ 100000000 \le m \le 1000000000 + 9 $$$ ) modulo need calculate number ways follow $$$ t $$$ line input contain a description a test case consist one integer $$$ n $$$ ( $$$ 1 \le n \le 4\cdot 100000 $$$ ) — number block lab consist guarantee $$$ u=1 $$$ sum $$$ n $$$ test case exceed $$$ <unknown> $$$ test case output answer format separate a newline output format depend $$$ u $$$ input data $$$ u=1 $$$ first line need print two integers $$$ h $$$ $$$ w $$$ — the height width area lab build , follow $$$ h $$$ line must output a line $$$ s_i $$$ consist $$$ w $$$ character ` ` # '' ` ` . ` ` $$$ j $$$ -th character row $$$ s_i $$$ ` ` # '' correspond square must contain a block laboratory otherwise consider empty thus get a matrix symbols condition must also meet first last row matrix well first last columns must least one character ` ` # '' otherwise could output lab layout smaller $$$ h $$$ $$$ w $$$ many options build optimal lab print $$$ u=2 $$$ need print two integers $$$ p $$$ $$$ c $$$ — number outside wall optimal lab remainder number ways prime modulo $$$ m $$$ consider second example $$$ n=1 $$$ way build a lab place a single block case perimeter equal four $$$ n=2 $$$ must place two block side side do either vertically horizontally two ways easy see lab six outside wall case $$$ n=7 $$$ $$$ 22 $$$ optimal plan show picture","['dp', 'greedy', 'math']",2500.0
1776/E,"isona a train station station two platforms $$$ m $$$ parallel railways view infinite straight line railway identify integer $$$ 1 $$$ $$$ m $$$ railway $$$ 1 $$$ closest first platform railway $$$ m $$$ farthest a $$$ 1 $$$ meter distance consecutive railways well platform closest railway isona stand inner border first platform realize forget validate ticket ! a validate machine second platform exactly opposite current position ( thus distance isona validate machine $$$ m + 1 $$$ meter ) $$$ s $$$ second leave validate ticket bridge designate cross railways far validate machine therefore isona ( brave a little bite careless ) cross railways run a straight line perpendicular railways isona run forward ( backward ) stay still run maximum speed need $$$ v $$$ second traverse $$$ 1 $$$ meter run speed less equal maximum speed one problem : $$$ n $$$ train program transit railways $$$ i $$$ -th train use railway $$$ r_i $$$ start cross straight line isona validate machine $$$ a_i $$$ second end $$$ b_i $$$ second course isona cross a railway a train pass formally every $$$ i = 1 \ 2 \ \dots \ n $$$ isona allow railway $$$ r_i $$$ time $$$ t $$$ $$$ a_i < t < b_i $$$ ( allow cross time $$$ a_i $$$ $$$ b_i $$$ ) follow picture summarize situation picture $$$ m = 4 $$$ railways two train visible ; train go railway $$$ 3 $$$ currently cross line isona validate machine isona a really good runner get tire every time change run speed minimum number speed change perform get validate machine platform within $$$ s $$$ second ? note begin isona run start run anytime instant start run ( i.e speed become positive ) count a speed change first line input contain four integers $$$ n $$$ $$$ m $$$ $$$ s $$$ $$$ v $$$ ( $$$ 1 \leq n \leq 500 $$$ $$$ 1 \leq m \leq 10 $$$ $$$ 1 \leq s v \leq 1000000000 $$$ ) — number train number railways maximum time second isona spend cross railways number second need traverse $$$ 1 $$$ meter maximum speed next $$$ n $$$ line contain three integers $$$ a_i $$$ $$$ b_i $$$ $$$ r_i $$$ ( $$$ 1 \leq a_i < b_i \leq 1000000000 $$$ $$$ 1 \leq r_i \leq m $$$ ) — start end time $$$ i $$$ -th train cross straight line isona validate machine railway use guarantee two train $$$ i $$$ $$$ j $$$ go railway ( i.e $$$ r_i = r_j $$$ ) least $$$ 1 $$$ second ( either $$$ a_j \ge b_i + 1 $$$ $$$ a_i \ge b_j + 1 $$$ ) print minimum number speed change isona perform get validate machine time impossible print $$$ -1 $$$ first sample isona start run time $$$ t=0 $$$ maximum speed ( $$$ 1 $$$ m / s ) cross railway a train traverse arrive platform time $$$ 4 = s - 1 $$$ without change speed second sample a possible solution $$$ 2 $$$ speed change follow : first $$$ 2 $$$ second isona go maximum speed ( $$$ 0.5 $$$ m / s ) slow $$$ 0.25 $$$ m / s $$$ 4 $$$ second reach second railway point go maximum speed reach platform third sample isona wait $$$ 2 $$$ second start run run $$$ 5 $$$ second maximum speed ( $$$ 0.5 $$$ m / s ) , wait $$$ 1 $$$ second run ( run $$$ 0 $$$ m / s ) finally run maximum speed last $$$ 5 $$$ second overall change speed twice","['data structures', 'dp']",3500.0
1776/L,grandparents ' house play old video game a strange console controller two button button a number write initially score $$$ 0 $$$ game compose $$$ n $$$ round $$$ 1\le i\le n $$$ $$$ i $$$ -th round work follow screen a symbol $$$ s_i $$$ appear either $$$ \texttt { + } $$$ ( plus ) $$$ \texttt { - } $$$ ( minus ) must press one two button controller suppose press a button number $$$ x $$$ write : score increase $$$ x $$$ symbol $$$ \texttt { + } $$$ decrease $$$ x $$$ symbol $$$ \texttt { - } $$$ press button round end play $$$ n $$$ round win score $$$ 0 $$$ years grandparents buy many different controllers $$$ q $$$ two button $$$ j $$$ -th controller number $$$ a_j $$$ $$$ b_j $$$ write controller must compute whether win game play controller first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 2\cdot 100000 $$$ ) — number round second line contain a string $$$ s $$$ length $$$ n $$$ — $$$ s_i $$$ symbol appear screen $$$ i $$$ -th round guarantee $$$ s $$$ contain character $$$ \texttt { + } $$$ $$$ \texttt { - } $$$ third line contain integer $$$ q $$$ ( $$$ 1 \le q \le 100000 $$$ ) — number controllers follow $$$ q $$$ line contain two integers $$$ a_j $$$ $$$ b_j $$$ ( $$$ 1 \le a_j b_j \le 1000000000 $$$ ) — number button controller $$$ j $$$ output $$$ q $$$ line line $$$ j $$$ print $$$ \texttt { yes } $$$ game <unknown> use controller $$$ j $$$ otherwise print $$$ \texttt { } $$$ first sample one possible way get score $$$ 0 $$$ use first controller press button <unknown> $$$ 1 $$$ round $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$ $$$ 5 $$$ $$$ 6 $$$ $$$ 8 $$$ press button number $$$ 2 $$$ round $$$ 3 $$$ $$$ 7 $$$ possible show way get a score $$$ 0 $$$ use second controller,"['binary search', 'math']",1500.0
1777/B,"a permutation length $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) $$$ n ! = n \cdot ( n-1 ) \cdot ( n - 2 ) \cdot \ldots \cdot 1 $$$ different permutations length $$$ n $$$ give a permutation $$$ p $$$ $$$ n $$$ number create array $$$ a $$$ consist $$$ 2n $$$ number equal $$$ p $$$ concatenate reverse define beauty $$$ p $$$ number inversions $$$ a $$$ number inversions array $$$ a $$$ number pair indices $$$ i $$$ $$$ j $$$ $$$ i < j $$$ $$$ a_i > a_j $$$ example permutation $$$ p = [ 1 2 ] $$$ $$$ a $$$ would $$$ [ 1 2 2 1 ] $$$ inversions $$$ a $$$ $$$ ( 2 4 ) $$$ $$$ ( 3 4 ) $$$ ( assume 1 - based index ) hence beauty $$$ p $$$ $$$ 2 $$$ task find sum beauties $$$ n ! $$$ permutations size $$$ n $$$ print remainder get divide value $$$ 1\,000\,000\,007 $$$ ( $$$ 1000000000 + 7 $$$ ) test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow test case one line — integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print one integer — sum beauties permutations size $$$ n $$$ modulo $$$ 1\,000\,000\,007 $$$ ( $$$ 1000000000 + 7 $$$ ) first test case example $$$ p = [ 1 ] $$$ permutation $$$ a = [ 1 1 ] $$$ $$$ 0 $$$ inversions second test case example permutations $$$ [ 1 2 ] $$$ $$$ [ 2 1 ] $$$ respective $$$ a $$$ array $$$ [ 1 2 2 1 ] $$$ $$$ [ 2 1 1 2 ] $$$ $$$ 2 $$$ inversions","['combinatorics', 'greedy', 'math']",900.0
1777/E,give a weight direct graph $$$ n $$$ nod $$$ m $$$ direct edge $$$ i $$$ -th edge a weight $$$ w_i $$$ ( $$$ 1 \le i \le m $$$ ) need reverse edge graph least one node graph every node reachable cost reversals equal maximum weight reverse edge edge reversal require assume cost $$$ 0 $$$ guarantee self - loop duplicate edge exist find minimum cost require complete task solution print a single integer $$$ -1 $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow test case begin a line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 1 \le m \le 200000 $$$ ) — number nod graph number edge graph next $$$ m $$$ line test case contain $$$ 3 $$$ integers — $$$ u $$$ $$$ v $$$ $$$ w $$$ ( $$$ 1 \le u v \le n $$$ $$$ 1 \le w \le 1000000000 $$$ ) indicate edge $$$ u $$$ $$$ v $$$ a weight $$$ w $$$ guarantee edge connect a vertex pair edge share origin destination simultaneously guarantee sum $$$ n $$$ sum $$$ m $$$ test case exceed $$$ 200000 $$$ test case output minimum cost solution print $$$ -1 $$$ first test case edge exist $$$ 1 $$$ $$$ 2 $$$ nod reachable ( $$$ 1 $$$ ) second test case nod reachable node matter edge reverse answer $$$ -1 $$$ third test case reverse $$$ 4 $$$ -th $$$ 5 $$$ -th edge allow nod reachable $$$ 1 $$$ choose $$$ 5 $$$ -th edge weight smaller,"['binary search', 'dfs and similar', 'graphs', 'trees']",2200.0
1778/C,"a string $$$ a $$$ a string $$$ b $$$ string length $$$ n $$$ $$$ 10 $$$ different character string $$$ a $$$ also a set $$$ q $$$ initially set $$$ q $$$ empty apply follow operation string $$$ a $$$ number time : example let string $$$ a $$$ ` ` $$$ \tt { <unknown> } $$$ ` ` follow operations : apply number operations $$$ a $$$ end set $$$ q $$$ contain $$$ k $$$ different character constraint maximize number integer pair $$$ ( l r ) $$$ ( $$$ 1\leq l\leq r \leq n $$$ ) $$$ a [ l r ] = b [ l r ] $$$ , $$$ s [ l r ] $$$ mean substring string $$$ s $$$ start index $$$ l $$$ ( inclusively ) end index $$$ r $$$ ( inclusively ) test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1\leq n \leq 100000 $$$ $$$ 0\leq k\leq 10 $$$ ) — length two string limit different character set $$$ q $$$ second line contain string $$$ a $$$ length $$$ n $$$ $$$ 10 $$$ different character string $$$ a $$$ last line contain string $$$ b $$$ length $$$ n $$$ string $$$ a $$$ $$$ b $$$ contain lowercase english letter sum $$$ n $$$ test case n't exceed $$$ 100000 $$$ test case print a single integer a line maximum number pair $$$ ( l r ) $$$ satisfy constraints first case select index $$$ i = 3 $$$ replace character $$$ c = \tt { d } $$$ possible pair $$$ ( l r ) $$$ valid second case ca n't perform operation $$$ 3 $$$ valid pair $$$ ( l r ) $$$ : third case choose index $$$ 2 $$$ index $$$ 3 $$$ replace character $$$ \tt { c } $$$ $$$ \tt { d } $$$ respectively final set $$$ q $$$ $$$ \ { \tt { b } \ } $$$ size $$$ 1 $$$ satisfy value $$$ k $$$ possible pair $$$ ( l r ) $$$ valid","['bitmasks', 'brute force', 'strings']",1600.0
1779/F,misha ban play chess good since accuse cheat engine therefore retire decide become a <unknown> one day take a walk a park misha come across a root tree nod number $$$ 1 $$$ $$$ n $$$ root tree node $$$ 1 $$$ $$$ 1\le i\le n $$$ node $$$ i $$$ contain $$$ a_i $$$ stone misha recently learn a new spell <unknown> class want test a spell consist : misha perform $$$ 2n $$$ spell want remove stone tree formally want $$$ a_i=0 $$$ hold $$$ 1\leq i \leq n $$$ help perform spell ? a tree $$$ n $$$ nod a connect acyclic graph contain $$$ n-1 $$$ edge subtree node $$$ i $$$ set nod $$$ j $$$ $$$ i $$$ lie simple path $$$ 1 $$$ ( root ) $$$ j $$$ consider $$$ i $$$ contain subtree first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 2\cdot 100000 $$$ ) — size <unknown> second line contain array integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 31 $$$ ) describe number stone node initially third line contain array integers $$$ p_2 p_3 \ldots p_n $$$ ( $$$ 1 \leq p_i \leq i-1 $$$ ) $$$ p_i $$$ mean edge connect $$$ p_i $$$ $$$ i $$$ a valid sequence spell output $$$ -1 $$$ otherwise output a single integer $$$ q $$$ ( $$$ 0 \leq q \leq 2n $$$ ) first line — number perform spell second line output a sequence integers $$$ v_1 v_2 \ldots <unknown> $$$ ( $$$ 1 \leq v_i \leq n $$$ ) — $$$ i $$$ -th spell perform subtree node $$$ v_i $$$ please note order matter multiple solutions exist output n't minimize number operations please refer follow picture explanation third test first $$$ 4 $$$ spell show since last $$$ 2 $$$ nothing first picture represent tree initially number stone node write green change apply current spell highlight red,"['bitmasks', 'dp', 'trees']",2500.0
178/A3,smart beaver abbyy begin develop a new educational game children rule game fairly simple describe play field a sequence n non - negative integers ai number 1 n. goal game make number a1 a2 ... ak ( i.e prefix sequence ) equal zero fix k ( k < n ) do smallest possible number move one move choose integer i ( 1 ≤ i ≤ n ) ai > 0 integer t ( t ≥ 0 ) i + 2 t ≤ n. value i t select value ai decrease 1 value ai + 2 t increase 1 . example let n = 4 a = ( 1 0 1 2 ) possible make move i = 3 t = 0 get a = ( 1 0 0 3 ) make move i = 1 t = 1 get a = ( 0 0 2 2 ) ( possible move i = 1 t = 0 ) give n initial sequence ai task calculate minimum number move need make first k elements original sequence equal zero possible k ( 1 ≤ k < n ) first input line contain a single integer n. second line contain n integers ai ( 0 ≤ ai ≤ 104 ) separate single space input limitations get 20 point : input limitations get 50 point : input limitations get 100 point : print exactly n - 1 line : k - th output line must contain minimum number move need make first k elements original sequence ai equal zero please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier,['greedy'],1100.0
1780/F,"one day kira find $$$ n $$$ friends morioh decide gather around a table a peaceful conversation height friend $$$ i $$$ equal $$$ a_i $$$ happen height friends unique unfortunately $$$ 3 $$$ chair kira 's house obviously possible seat friends ! , kira invite $$$ 3 $$$ friends everything simple ! heights lowest tallest invite friends coprime friends play trick greatly anger kira kira become interest many ways choose $$$ 3 $$$ friends n't play trick ? two ways consider different a friend invite one way , formally kira invite friends $$$ i $$$ $$$ j $$$ $$$ k $$$ follow true : $$$ \gcd ( \min ( a_i a_j a_k ) \max ( a_i a_j a_k ) ) = 1 $$$ $$$ \gcd ( x y ) $$$ denote greatest common divisor ( gcd ) number $$$ x $$$ $$$ y $$$ kira strong computer science ask count number ways <unknown> friends first line contain number $$$ n $$$ ( $$$ 3 \le n \le 3\cdot100000 $$$ ) — number kira 's friends next line contain $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 3\cdot100000 $$$ ) — heights kira 's friends a single line output number ways invite three friends first example one way suitable : invite friends $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 1 < 2 < 3 $$$ number $$$ 1 $$$ $$$ 3 $$$ coprime","['bitmasks', 'brute force', 'combinatorics', 'data structures', 'dp', 'number theory', 'sortings']",2300.0
1783/A,array $$$ a $$$ call ugly contain least one element equal sum elements array ugly beautiful example : give array $$$ a $$$ $$$ 1 \le a_1 \le a_2 \le \dots \le a_n \le 100 $$$ reorder elements $$$ a $$$ a way result array beautiful note allow insert new elements erase exist ones change order elements $$$ a $$$ allow keep array $$$ a $$$ unchanged beautiful first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 2000 $$$ ) — number test case test case consist two line first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 50 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_1 \le a_2 \le \dots \le a_n \le 100 $$$ ) test case print answer follow :,"['math', 'sortings']",800.0
1783/E,"monocarp polycarp play a computer game game feature $$$ n $$$ boss play kill number $$$ 1 $$$ $$$ n $$$ fight boss follow way : monocarp kill $$$ i $$$ -th boss $$$ a_i $$$ -th attempt polycarp kill $$$ i $$$ -th boss $$$ b_i $$$ -th attempt one kill $$$ i $$$ -th boss move $$$ ( i+1 ) $$$ -st boss attempt counter reset one kill $$$ n $$$ -th boss game end find value $$$ k $$$ $$$ 1 $$$ $$$ n $$$ monocarp kill boss first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number boss second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — index attempt monocarp kill boss third line contain $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ 1 \le b_i \le n $$$ ) — index attempt polycarp kill boss sum $$$ n $$$ testcases n't exceed $$$ 200000 $$$ testcase print two line first line contain a single integer $$$ \mathit { cnt } $$$ — number value $$$ k $$$ $$$ 1 $$$ $$$ n $$$ monocarp kill boss second line contain $$$ \mathit { cnt } $$$ distinct integers — value $$$ k $$$ consider last testcase example let $$$ k = 1 $$$ first monocarp make one attempt kill first boss 's successful since $$$ a_1 = 1 $$$ , monocarp make one attempt kill second boss 's unsuccessful since $$$ a_2 > 1 $$$ , polycarp make attempt 's also unsuccessful since $$$ b_2 > 1 $$$ , monocarp make another attempt 's still unsuccessful since $$$ a_2 > 2 $$$ go polycarp finally kill boss third attempt monocarp n't kill boss thus $$$ k = 1 $$$ n't answer let $$$ k = 2 $$$ monocarp still kill first boss first attempt , make two unsuccessful attempt second boss , polycarp make two unsuccessful attempt , monocarp make two attempt kill boss fourth attempt third boss similar first two unsuccessful attempt monocarp , two unsuccessful attempt polycarp , monocarp two attempt even first one successful since $$$ a_3 = 3 $$$ fourth boss also kill monocarp thus $$$ k = 2 $$$ answer","['brute force', 'data structures', 'math', 'number theory']",2300.0
1784/A,easy version problem version need find answer version hack allow a computer game fight $$$ n $$$ monsters monster number $$$ i $$$ $$$ a_i $$$ health point $$$ a_i $$$ integers a monster alive least $$$ 1 $$$ health point cast spell two type : deal $$$ 1 $$$ damage a monster reduce health $$$ 1 $$$ spell type 1 cast number time a spell type 2 cast game smallest number time need cast spell type 1 kill monsters ? test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow test case consist two line first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number monsters second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — monsters ' health point guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print a single integer — smallest number time need cast spell type 1 kill monsters first test case initial health point monsters $$$ [ 3 1 2 ] $$$ enough cast a spell type 2 : since possible use spell type 1 answer $$$ 0 $$$ second test case initial health point monsters $$$ [ 4 1 5 4 1 1 ] $$$ one optimal action sequence : spell type 1 cast $$$ 4 $$$ time total show smallest possible number,"['brute force', 'greedy']",1000.0
1788/E,give array $$$ a_1 a_2 \ldots a_n $$$ $$$ n $$$ integers consider $$$ s $$$ a set segment satisfy follow condition length segment $$$ [ x y ] $$$ define $$$ y - x+1 $$$ $$$ f ( s ) $$$ define sum lengths every element $$$ s $$$ a formal way $$$ f ( s ) = \sum _ { [ x y ] \in s } ( y - x + 1 ) $$$ note $$$ s $$$ empty $$$ f ( s ) $$$ $$$ 0 $$$ maximum $$$ f ( s ) $$$ among possible $$$ s $$$ ? first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) next line follow $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \leq a_i \leq 1000000000 $$$ ) print a single integer maximum $$$ f ( s ) $$$ among every possible $$$ s $$$ first example $$$ s=\ { [ 1 2 ] [ 4 5 ] \ } $$$ a possible $$$ s $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ s=\ { [ 1 4 ] \ } $$$ also a possible solution since exist $$$ s $$$ satisfy $$$ f ( s ) > 4 $$$ answer $$$ 4 $$$ second example $$$ s=\ { [ 1 9 ] \ } $$$ set satisfy $$$ f ( s ) = 9 $$$ since every possible $$$ s $$$ satisfy $$$ f ( s ) \leq 9 $$$ answer $$$ 9 $$$ third example $$$ s $$$ empty set answer $$$ 0 $$$,"['data structures', 'dfs and similar', 'dp']",2200.0
1788/F,"give a tree $$$ n $$$ vertices vertices number $$$ 1 $$$ $$$ n $$$ need assign a weight edge let weight $$$ i $$$ -th edge $$$ a_i $$$ ( $$$ 1 \leq i \leq n-1 $$$ ) weight edge integer $$$ 0 $$$ $$$ 2^ { 30 } -1 $$$ inclusive give $$$ q $$$ condition condition consist three integers $$$ u $$$ $$$ v $$$ $$$ x $$$ mean bitwise xor edge shortest path $$$ u $$$ $$$ v $$$ $$$ x $$$ find exist $$$ a_1 a_2 \ldots a _ { n-1 } $$$ satisfy give condition yes print a solution $$$ a_1 \oplus a_2 \oplus \ldots \oplus a _ { n-1 } $$$ smallest , $$$ \oplus $$$ denote bitwise xor operation multiple solutions $$$ a_1 \oplus a_2 \oplus \ldots \oplus a _ { n-1 } $$$ smallest print first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \le n \le 2.5 \cdot 100000 $$$ $$$ 0 \le q \le 2.5 \cdot 100000 $$$ ) $$$ i $$$ -th follow $$$ n-1 $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \neq y_i $$$ ) mean $$$ i $$$ -th edge connect vertices $$$ x_i $$$ $$$ y_i $$$ tree guarantee give edge form a tree follow $$$ q $$$ line contain information condition line contain three integers $$$ u $$$ $$$ v $$$ $$$ x $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ $$$ 0 \le x \le 2^ { 30 } -1 $$$ ) mean bitwise xor edge shortest path $$$ u $$$ $$$ v $$$ $$$ x $$$ exist $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a _ { n-1 } $$$ satisfy give condition print ` ` '' otherwise print ` ` yes '' first line print $$$ n-1 $$$ integers next line $$$ i $$$ -th integer weight $$$ i $$$ -th edge multiple solutions satisfy give condition print a solution $$$ a_1 \oplus a_2 \oplus \ldots \oplus a _ { n-1 } $$$ smallest multiple solutions $$$ a_1 \oplus a_2 \oplus \ldots \oplus a _ { n-1 } $$$ smallest print print ` ` yes '' ` ` '' print letter case ( either upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses first example exist a set edge weight satisfy give condition second example two give condition $$$ a_1 \oplus a_2 \oplus <unknown> $$$ $$$ a_4 \oplus a_5=7 $$$ multiple solutions example $$$ ( a_1 a_2 a_3 a_4 a_5 ) = ( 1 2 1 4 3 ) $$$ third example two give condition $$$ a_1 \oplus a_2 \oplus a_3=3 $$$ $$$ a_1 \oplus a_4 \oplus <unknown> $$$ multiple solutions satisfy give condition $$$ ( a_1 a_2 a_3 a_4 a_5 ) = ( 1 1 3 4 0 ) $$$ satisfy give condition bitwise xor edge weight $$$ 7 $$$ smallest $$$ a_1 \oplus a_2 \oplus \ldots \oplus a _ { n-1 } $$$ answer","['bitmasks', 'dfs and similar', 'dsu', 'graphs', 'greedy', 'implementation', 'trees']",2500.0
1789/D,serval two $$$ n $$$ -bit binary integer number $$$ a $$$ $$$ b $$$ want share number toxel since toxel like number $$$ b $$$ serval decide change $$$ a $$$ $$$ b $$$ ( possibly zero ) operations operation serval choose positive integer $$$ k $$$ $$$ 1 $$$ $$$ n $$$ change $$$ a $$$ one follow number : word operation move every bite $$$ a $$$ leave right $$$ k $$$ position overflow bits remove miss bits pad $$$ 0 $$$ bitwise xor shift result original $$$ a $$$ assign back $$$ a $$$ serval much time want perform $$$ n $$$ operations change $$$ a $$$ $$$ b $$$ please help find operation sequence determine impossible change $$$ a $$$ $$$ b $$$ $$$ n $$$ operations need minimize number operations problem $$$ x\oplus y $$$ denote bitwise xor operation $$$ x $$$ $$$ y $$$ $$$ <unknown> k $$$ $$$ <unknown> k $$$ denote logical leave shift logical right shift test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1\le <unknown> { 3 } $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1\le <unknown> { 3 } $$$ ) — number bits number $$$ a $$$ $$$ b $$$ second third line test case contain a binary string length $$$ n $$$ represent $$$ a $$$ $$$ b $$$ respectively string contain character 0 1 . guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot10^ { 3 } $$$ test case impossible change $$$ a $$$ $$$ b $$$ $$$ n $$$ operations print a single integer $$$ -1 $$$ otherwise first line print number operations $$$ m $$$ ( $$$ 0\le m\le n $$$ ) $$$ m > 0 $$$ second line print $$$ m $$$ integers $$$ k _ { 1 } k _ { 2 } \dots k _ { m } $$$ represent operations $$$ 1\le k _ { i } \le n $$$ mean logical leave shift $$$ a $$$ $$$ k _ { i } $$$ position $$$ -n\le k _ { i } <unknown> $$$ mean logical right shift $$$ a $$$ $$$ -k _ { i } $$$ position multiple solutions print first test case : first operation change $$$ a $$$ $$$ \require { cancel } <unknown> { 001 } <unknown> { 000 } = 11111 $$$ second operation change $$$ a $$$ $$$ \require { cancel } <unknown> { 00 } <unknown> { 11 } = 11000 $$$ bits <unknown> overflow bits remove bits underline pad bits second test case $$$ a $$$ already equal $$$ b $$$ operations need third test case show $$$ a $$$ change $$$ b $$$,"['bitmasks', 'brute force', 'implementation']",2200.0
1790/A,march 14 day number $$$ \pi $$$ celebrate world a important mathematical constant equal ratio circumference a circle diameter polycarp tell school number $$$ \pi $$$ <unknown> therefore infinite number digits decimal notation want prepare day number $$$ \pi $$$ memorize number accurately possible polycarp write digits manage remember example polycarp remember $$$ \pi $$$ $$$ <unknown> $$$ write 31415 . polycarp a hurry could make a mistake decide check many first digits number $$$ \pi $$$ polycarp actually remember correctly first line input data contain single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test test case describe a single string digits $$$ n $$$ write polycarp string $$$ n $$$ contain $$$ 30 $$$ digits output $$$ t $$$ integers answer correspond test case many first digits number $$$ \pi $$$ polycarp remember correctly,"['implementation', 'math', 'strings']",800.0
1790/C,"a sequence $$$ n $$$ number call permutation contain integers $$$ 1 $$$ $$$ n $$$ exactly example sequence [ $$$ 3 1 4 2 $$$ ] [ $$$ 1 $$$ ] [ $$$ 2,1 $$$ ] permutations [ $$$ 1,2,1 $$$ ] [ $$$ 0,1 $$$ ] [ $$$ 1,3,4 $$$ ] — kristina a permutation $$$ p $$$ $$$ n $$$ elements write whiteboard $$$ n $$$ time a way : example suppose kristina a permutation $$$ p $$$ = $$$ [ 4,2,1,3 ] $$$ length $$$ 4 $$$ follow : know $$$ n $$$ sequence write whiteboard know order write give arbitrary order reconstruct original permutation example know sequence $$$ [ 4 2 1 ] $$$ $$$ [ 4 2 3 ] $$$ $$$ [ 2 1 3 ] $$$ $$$ [ 4 1 3 ] $$$ original permutation $$$ p $$$ = $$$ [ 4 2 1 3 ] $$$ first line input data contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 3 \le n \le 100 $$$ ) follow $$$ n $$$ line contain exactly $$$ n-1 $$$ integers describe one sequence write whiteboard guarantee sequence could obtain permutation $$$ p $$$ sum $$$ n^2 $$$ input set exceed $$$ 200000 $$$ test case output a separate line a permutation $$$ p $$$ give $$$ n $$$ sequence could obtain guarantee answer exist one word test case require permutation sure exist first test case describe problem statement second test case sequence write correct order","['brute force', 'implementation', 'math']",1000.0
1790/D,matryoshka a wooden toy form a paint doll inside put a similar doll a smaller size a set nest dolls contain one nest dolls size consecutive positive integers thus a set nest dolls describe two number : $$$ s $$$ — size a smallest nest doll a set $$$ m $$$ — number dolls a set word set contain size $$$ s s + 1 \dots s + m - 1 $$$ integer $$$ s $$$ $$$ m $$$ ( $$$ s m > 0 $$$ ) one set nest dolls recently find someone mix set one record a sequence doll size — integers $$$ a_1 a_2 \dots a_n $$$ remember many set want find minimum number set could initially example a give sequence $$$ a= [ 2 2 3 4 3 1 ] $$$ initially could $$$ 2 $$$ set : accord a give sequence size nest dolls $$$ a_1 a_2 \dots a_n $$$ determine minimum number nest dolls make sequence set completely use nest dolls use element a give sequence must correspond exactly one doll set first line input data contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — total number matryoshkas set second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — size matryoshkas guarantee sum value $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ test case print one integer $$$ k $$$ — minimum possible number matryoshkas set first test case describe problem statement second test case matryoshkas could part set minimum size $$$ <unknown> $$$ third test case matryoshka represent a separate set,"['data structures', 'greedy', 'sortings']",1200.0
1790/F,"timofey come a famous summer school find a tree $$$ n $$$ vertices a tree a connect undirected graph without cycle every vertex tree except $$$ c_0 $$$ color white vertex $$$ c_0 $$$ color black timofey want color vertices tree black , perform $$$ n - 1 $$$ operations $$$ i $$$ -th operation select vertex $$$ c_i $$$ currently white paint black let 's call positivity tree minimum distance pair different black vertices distance vertices $$$ v $$$ $$$ u $$$ number edge path $$$ v $$$ $$$ u $$$ operation timofey want know positivity current tree first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain integers $$$ n c_0 $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 1 \le c_0 \le n $$$ ) — number vertices tree index initial black vertex second line testcase contain $$$ n - 1 $$$ unique integers $$$ c_1 c_2 \dots c _ { n-1 } $$$ ( $$$ 1 \le c_i \le n $$$ $$$ c_i \ne c_0 $$$ ) $$$ c_i $$$ vertex color black $$$ i $$$ -th operation next $$$ n - 1 $$$ row testcase contain integers $$$ v_i u_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ ) — edge tree guarantee sum $$$ n $$$ testcases exceed $$$ 200000 $$$ testcase print $$$ n - 1 $$$ integer a separate line integer index $$$ i $$$ must equal positivity tree obtain first $$$ i $$$ operations first testcase second operation tree look like : distance vertices $$$ 1 $$$ $$$ 6 $$$ $$$ 3 $$$ distance vertices $$$ 4 $$$ $$$ 6 $$$ $$$ 3 $$$ distance vertices $$$ 1 $$$ $$$ 4 $$$ $$$ 2 $$$ positivity tree equal minimum distance equal $$$ 2 $$$ third testcase fourth operation tree look like : positivity tree $$$ 2 $$$","['brute force', 'dfs and similar', 'divide and conquer', 'graphs', 'greedy', 'math', 'shortest paths', 'trees']",2100.0
1791/A,give a lowercase latin character ( letter ) check appear string $$$ \texttt { codeforces } $$$ first line input contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 26 $$$ ) — number test case line test case contain a character $$$ c $$$ — a single lowercase latin character ( letter ) test case output ` ` yes '' ( without quote ) $$$ c $$$ satisfy condition ` ` '' ( without quote ) otherwise output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ),"['implementation', 'strings']",800.0
1791/D,let 's denote $$$ f ( x ) $$$ function a string $$$ x $$$ number distinct character string contain example $$$ f ( \texttt { abc } ) = 3 $$$ $$$ f ( \texttt { bbbbb } ) = 1 $$$ $$$ f ( \texttt { <unknown> } ) = 3 $$$ give a string $$$ s $$$ split two non - empty string $$$ a $$$ $$$ b $$$ $$$ f ( a ) + f ( b ) $$$ maximum possible word find maximum possible value $$$ f ( a ) + f ( b ) $$$ $$$ a + b = s $$$ ( concatenation string $$$ a $$$ string $$$ b $$$ equal string $$$ s $$$ ) input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 2\cdot100000 $$$ ) — length string $$$ s $$$ second line contain string $$$ s $$$ consist lowercase english letter guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ test case output a single integer — maximum possible value $$$ f ( a ) + f ( b ) $$$ $$$ a + b = s $$$ first test case one valid way split $$$ \texttt { aa } $$$ two non - empty string $$$ \texttt { a } $$$ $$$ \texttt { a } $$$ $$$ f ( \texttt { a } ) + f ( \texttt { a } ) = 1 + 1 = 2 $$$ second test case split $$$ \texttt { <unknown> } $$$ $$$ \texttt { abc } $$$ $$$ \texttt { abcd } $$$ get answer $$$ f ( \texttt { abc } ) + f ( \texttt { abcd } ) = 3 + 4 = 7 $$$ maximum possible third test case n't matter split string answer always $$$ 2 $$$,"['brute force', 'greedy', 'strings']",1000.0
1791/E,"give array $$$ a $$$ consist $$$ n $$$ elements find maximum possible sum array perform follow operation number time : input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case descriptions test case follow first line test case contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 2\cdot100000 $$$ ) — length array follow line contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ -1000000000 \leq a_i \leq 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ test case output maximum possible sum array perform describe operation number time first test case perform operation first two elements change array $$$ [ -1 -1 -1 ] $$$ $$$ [ 1 1 -1 ] $$$ prove array obtain maximum possible sum $$$ 1 + 1 + ( -1 ) = 1 $$$ second test case perform operation $$$ -5 $$$ $$$ 0 $$$ change array $$$ [ 1 5 -5 0 2 ] $$$ $$$ [ 1 5 - ( -5 ) <unknown> 2 ] = [ 1 5 5 0 2 ] $$$ maximum sum since elements non - negative , answer $$$ 1 + 5 + 5 + 0 + 2 = 13 $$$ third test case array already contain positive number perform operations unnecessary answer sum whole array $$$ 1 + 2 + 3 = 6 $$$","['dp', 'greedy', 'sortings']",1100.0
1792/C,give a permutation $$$ p $$$ length $$$ n $$$ ( a permutation length $$$ n $$$ array length $$$ n $$$ integer $$$ 1 $$$ $$$ n $$$ occur exactly ) perform follow operation number time ( possibly zero ) : example $$$ p = [ 1 5 4 2 3 ] $$$ want apply operation elements $$$ 3 $$$ $$$ 5 $$$ first step operation permutation become $$$ p = [ 1 4 2 ] $$$ ; insert elements become $$$ p = [ 3 1 4 2 5 ] $$$ task calculate minimum number operations describe sort permutation $$$ p $$$ ascend order ( i. e. transform $$$ p $$$ $$$ p_1 < p_2 < \dots < p_n $$$ ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements permutation second line test case contain $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ — give permutation $$$ p $$$ sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case output a single integer — minimum number operations describe sort array $$$ p $$$ ascend order first example proceed follow :,"['binary search', 'brute force', 'greedy', 'math', 'two pointers']",1500.0
1795/A,"two tower consist block two color : red blue tower represent string character b and/or r denote order block bottom top b correspond a blue block r correspond a red block perform follow operation number time : choose a tower least two block move top block top tower pair tower beautiful pair touch block color ; i. e. red block stand top another red block blue block stand top another blue block check possible perform number operations ( possibly zero ) make pair tower beautiful first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case consist three line : test case print yes possible perform several ( possibly zero ) operations a way pair tower become beautiful ; otherwise print may print letter case ( yes yes yes recognize positive answer , recognize negative answer ) first test case move top block first tower second tower ( see third picture ) second test case move top block second tower first tower $$$ 6 $$$ time third test case pair tower already beautiful","['brute force', 'implementation', 'strings']",800.0
1795/E,"play yet another game kill monsters use magic spell $$$ n $$$ cells row number $$$ 1 $$$ $$$ n $$$ initially $$$ i $$$ -th cell contain $$$ i $$$ -th monster $$$ h_i $$$ health a basic spell cost $$$ 1 $$$ mp deal $$$ 1 $$$ damage monster choose cast number time also a special scroll ` ` explosion '' spell use want finish kill monsters explosion 's firstly cast basic spell several time ( possibly zero ) , cast one ` ` explosion '' ` ` explosion '' spell work ? firstly choose power spell : pour $$$ x $$$ mp ` ` explosion '' deal $$$ x $$$ damage secondly choose monster $$$ i $$$ target spell 's happen next : goal kill remain monsters ` ` chain '' explosions 's need a basic spell decrease $$$ h_i $$$ monsters even kill beforehand ( monsters die current health $$$ h_i $$$ become less equal zero ) note monsters n't move cells , example monsters $$$ i $$$ $$$ i + 2 $$$ never become neighbor minimum total mp need kill monsters way want ? total mp count sum number basic spell cast power $$$ x $$$ explosion scroll ' ve choose first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain single integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) — number cells row i. e. number monsters second line test case contain $$$ n $$$ integers $$$ h_1 h_2 \dots h_n $$$ ( $$$ 1 \le h_i \le 1000000 $$$ ) — initial health monsters 's guarantee sum $$$ n $$$ test case n't exceed $$$ 300000 $$$ test case print one integer — minimum total mp need kill monsters finish explosion first test case , example use basic spell monsters $$$ 1 $$$ $$$ 2 $$$ ( per monster ) kill , cast ` ` explosion '' power $$$ x = 1 $$$ monster $$$ 3 $$$ kill total mp need $$$ 2 + 1 = 3 $$$ second test case 's optimal cast basic spell $$$ 4 $$$ time onto monster $$$ 1 $$$ kill , cast ` ` explosion '' power $$$ x = 2 $$$ onto monster $$$ 3 $$$ die create explosion power $$$ 1 $$$ kill monsters $$$ 2 $$$ $$$ 4 $$$ total mp need $$$ 4 + 2 = 6 $$$ third test case cast ` ` explosion '' power $$$ 15 $$$ onto monster $$$ 3 $$$ explosion $$$ 3 $$$ -rd monster ( power $$$ 14 $$$ ) kill monsters $$$ 2 $$$ $$$ 4 $$$ secondary explosion monster $$$ 2 $$$ ( power $$$ 9 $$$ ) kill monster $$$ 1 $$$","['binary search', 'data structures', 'dp', 'greedy', 'math']",2200.0
1795/G,give a simple undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge vertices number $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th vertex a value $$$ a_i $$$ write remove vertices graph allow remove vertex $$$ i $$$ degree equal $$$ a_i $$$ a vertex remove edge incident also remove thus decrease degree adjacent non - removed vertices a valid sequence removals a permutation $$$ p_1 p_2 \dots p_n $$$ $$$ ( 1 \le p_i \le n ) $$$ $$$ i $$$ -th vertex remove $$$ p_i $$$ every removal allow a pair $$$ ( x y ) $$$ vertices nice exist two valid sequence removals $$$ x $$$ remove $$$ y $$$ one $$$ y $$$ remove $$$ x $$$ one count number nice pair $$$ ( x y ) $$$ $$$ x < y $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100000 $$$ ; $$$ 0 \le m \le \min ( 100000 \frac { n \cdot ( n - 1 ) } { 2 } ) $$$ ) — number vertices number edge graph second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le n - 1 $$$ ) — degree requirements removal next $$$ m $$$ line contain two integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le n $$$ ; $$$ v \neq u $$$ ) — description edge graph n't contain self - loops multiple edge sum $$$ n $$$ testcases n't exceed $$$ 100000 $$$ sum $$$ m $$$ testcases n't exceed $$$ 100000 $$$ additional constraint input : always exist least one valid sequence removals testcase print a single integer — number nice pair vertices,"['bitmasks', 'dfs and similar', 'graphs']",2700.0
1796/D,give array $$$ a_1 a_2 \dots a_n $$$ consist $$$ n $$$ integers also give two integers $$$ k $$$ $$$ x $$$ perform follow operation exactly : add $$$ x $$$ elements exactly $$$ k $$$ distinct position subtract $$$ x $$$ others example $$$ a = [ 2 -1 2 3 ] $$$ $$$ k = 1 $$$ $$$ x = 2 $$$ pick first element operation array $$$ a = [ 4 -3 0 1 ] $$$ let $$$ f ( a ) $$$ maximum possible sum a subarray $$$ a $$$ subarray $$$ a $$$ a contiguous part array $$$ a $$$ i. e. array $$$ a_i a _ { i + 1 } \dots a_j $$$ $$$ 1 \le i \le j \le n $$$ empty subarray also consider sum $$$ 0 $$$ let array $$$ a ' $$$ array $$$ a $$$ apply aforementioned operation apply operation a way $$$ f ( a ' ) $$$ maximum possible print maximum possible value $$$ f ( a ' ) $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain three integers $$$ n $$$ $$$ k $$$ $$$ x $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 0 \le k \le \min ( 20 n ) $$$ ; $$$ -1000000000 \le x \le 1000000000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print one integer — maximum possible value $$$ f ( a ' ) $$$,"['data structures', 'dp', 'greedy', 'two pointers']",2000.0
1797/B,"li hua a pattern size $$$ n\times n $$$ cell either blue red perform exactly $$$ k $$$ operations operation choose a cell change color red blue blue red cell choose many time want possible make pattern match rotation $$$ 180^ { \circ } $$$ ? suppose li hua please solve problem first line contain single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain two integers $$$ n k $$$ ( $$$ 1\le n\le <unknown> k \le 1000000000 $$$ ) — size pattern number operations next $$$ n $$$ line contain $$$ n $$$ integers $$$ a _ { i j } $$$ ( $$$ a _ { i j } \in\ { 0,1\ } $$$ ) — initial color cell $$$ 0 $$$ blue $$$ 1 $$$ red 's guarantee sum $$$ n $$$ test case exceed $$$ 1000 $$$ set input print ` ` yes '' 's possible make pattern match rotation $$$ 180^ { \circ } $$$ apply exactly $$$ k $$$ operations ` ` '' otherwise output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses test case 1 ca n't perform operation pattern rotation right test case 2 perform operations $$$ ( 2,1 ) ( 3,2 ) ( 3,4 ) $$$ pattern operations middle pattern rotation right",['greedy'],1100.0
1797/F,"li hua a tree $$$ n $$$ vertices $$$ n-1 $$$ edge vertices number $$$ 1 $$$ $$$ n $$$ a pair vertices $$$ ( u v ) $$$ ( $$$ u < v $$$ ) consider cute exactly one follow two statements true : $$$ m $$$ operations operation decide integer $$$ k_j $$$ insert a vertex number $$$ n+j $$$ tree connect vertex number $$$ k_j $$$ want calculate number cute pair operations operation suppose li hua please solve problem first line contain single integer $$$ n $$$ ( $$$ 2\le n\le 2\cdot 100000 $$$ ) — number vertices tree next $$$ n-1 $$$ line contain edge tree $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1\le u_i v_i\le n $$$ ; $$$ u_i\ne v_i $$$ ) — correspond edge give edge form a tree next line contain single integer $$$ m $$$ ( $$$ 1\le m\le 2\cdot 100000 $$$ ) — number operations next $$$ m $$$ line contain operations — one operation per line $$$ j $$$ -th operation contain one integer $$$ k_j $$$ ( $$$ 1\le k_j < n+j $$$ ) — a vertex print $$$ m+1 $$$ integers — number cute pair operations operation initial tree show follow picture : $$$ 11 $$$ cute pair — $$$ ( 1,5 ) ( 2,3 ) ( 2,4 ) ( <unknown> ) ( 2,7 ) ( 3,4 ) ( 3,6 ) ( 3,7 ) ( 4,5 ) ( 5,7 ) ( <unknown> ) $$$ similarly count cute pair operation result $$$ 15 $$$ $$$ 19 $$$","['data structures', 'dfs and similar', 'divide and conquer', 'dsu', 'trees']",3000.0
1798/C,"store sell $$$ n $$$ type candy number $$$ 1 $$$ $$$ n $$$ one candy type $$$ i $$$ cost $$$ b_i $$$ coin total $$$ a_i $$$ candy type $$$ i $$$ store need pack available candy pack pack contain one type candy formally type candy $$$ i $$$ need choose integer $$$ d_i $$$ denote number type $$$ i $$$ candy one pack $$$ a_i $$$ divide without remainder $$$ d_i $$$ cost one pack candy type $$$ i $$$ equal $$$ b_i \cdot d_i $$$ let 's denote cost $$$ c_i $$$ , $$$ c_i = b_i \cdot d_i $$$ package pack place shelf consider cost pack place shelf order $$$ c_1 c_2 \ldots c_n $$$ price tag use describe cost pack one price tag describe cost pack $$$ l $$$ $$$ r $$$ inclusive $$$ c_l = c _ { l+1 } = \ldots = c_r $$$ pack $$$ 1 $$$ $$$ n $$$ must describe least one price tag example $$$ c_1 \ldots c_n = [ 4 4 2 4 4 ] $$$ describe pack a $$$ 3 $$$ price tag enough first price tag describe pack $$$ 1 2 $$$ second : $$$ 3 $$$ third : $$$ 4 5 $$$ give integers $$$ a_1 b_1 a_2 b_2 \ldots a_n b_n $$$ task choose integers $$$ d_i $$$ $$$ a_i $$$ divisible $$$ d_i $$$ $$$ i $$$ require number price tag describe value $$$ c_1 c_2 \ldots c_n $$$ minimum possible a better understand statement look illustration first test case first test : let 's repeat mean notation use problem : $$$ a_i $$$ — number candy type $$$ i $$$ available store $$$ b_i $$$ — cost one candy type $$$ i $$$ $$$ d_i $$$ — number candy type $$$ i $$$ one pack $$$ c_i $$$ — cost one pack candy type $$$ i $$$ express formula $$$ c_i = b_i \cdot d_i $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100\,000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200\,000 $$$ ) — number type candy next $$$ n $$$ line test case contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ $$$ 1 \le b_i \le 10\,000 $$$ ) — number candy cost one candy type $$$ i $$$ respectively guarantee sum $$$ n $$$ test case exceed $$$ 200\,000 $$$ test case output minimum number price tag require describe cost pack candy store first test case choose $$$ d_1 = 4 $$$ $$$ d_2 = 6 $$$ $$$ d_3 = 7 $$$ $$$ d_4 = 5 $$$ cost pack equal $$$ [ 12 12 35 35 ] $$$ $$$ 2 $$$ price tag enough describe first price tag $$$ c_1 c_2 $$$ second price tag $$$ c_3 c_4 $$$ show correct choice $$$ d_i $$$ least $$$ 2 $$$ price tag need describe pack also note example illustrate a picture statement second test case $$$ d_1 = 4 $$$ $$$ d_2 = 2 $$$ $$$ d_3 = 10 $$$ cost pack equal $$$ 20 $$$ thus $$$ 1 $$$ price tag enough describe pack note $$$ a_i $$$ divisible $$$ d_i $$$ $$$ i $$$ necessary condition third test case difficult understand one price tag use describe $$$ 2 $$$ nd $$$ 3 $$$ rd $$$ 4 $$$ th pack additionally a price tag pack $$$ 1 $$$ pack $$$ 5 $$$ total : $$$ 3 $$$ price tag","['greedy', 'math', 'number theory']",1700.0
1799/E,"give $$$ n \times m $$$ grid cells fill empty a city a maximal ( inclusion ) set fill cells possible get cell set cell set move adjacent ( side ) cells without move cells set word a city a connect component fill cells edge adjacent ( side ) cells initially two cities grid want change empty cells fill cells follow satisfy : manhattan distance two cells $$$ ( a b ) $$$ $$$ ( c d ) $$$ equal $$$ |a - c| + |b - d| $$$ find a way add fill cells satisfy condition minimize total number fill cells input consist multiple test case first line contain a single integer $$$ t $$$ number test case ( $$$ 1 \le t \le 5000 $$$ ) first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 50 $$$ $$$ nm \geq 3 $$$ ) next $$$ n $$$ line describe grid $$$ i $$$ -th line contain a string $$$ s_i $$$ length $$$ m $$$ $$$ s _ { i j } $$$ ' # ' cell position $$$ ( i j ) $$$ fill ' . ' empty guarantee exactly two cities initial grid guarantee sum $$$ n\cdot m $$$ test case exceed $$$ 25\,000 $$$ test case output $$$ n $$$ line contain a string length $$$ m $$$ describe grid create format input multiple possible answer minimum number fill cells print first test case add a single fill cell two cities connect verify second condition satisfy second test case also connect cities a single fill cell satisfy second condition third test case note fill 3 cells top leave cities would connect second condition would satisfy cells $$$ ( 4 2 ) $$$ $$$ ( 2 4 ) $$$","['dfs and similar', 'dsu', 'geometry', 'greedy', 'implementation', 'math']",2300.0
1800/C1,easy version problem differ hard one constraints $$$ n $$$ $$$ t $$$ a deck $$$ n $$$ card characterize power two type card : follow deck : task use action gather army maximum possible total power first line input data contain single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 5000 $$$ ) — number card deck second line test case contain $$$ n $$$ integers $$$ s_1 s_2 \dots s_n $$$ ( $$$ 0 \le s_i \le 1000000000 $$$ ) — card power top - down order guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ output $$$ t $$$ number answer correspond test case — maximum possible total power army achieve first sample take bonuses $$$ 1 $$$ $$$ 2 $$$ hero card receive $$$ 3 $$$ power take bonuses one remain unused second sample hero 's card top deck power rest power $$$ 2 $$$ $$$ 3 $$$ bonuses get $$$ 6 $$$ total power fourth sample take bonuses $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 5 $$$ skip bonus $$$ 6 $$$ hero $$$ 4 $$$ enhance a bonus $$$ 3 $$$ $$$ 5 $$$ hero $$$ 7 $$$ a bonus $$$ 5 $$$ $$$ 4 $$$ $$$ 4 + 5=9 $$$,"['data structures', 'greedy']",1000.0
1800/E1,easy version problem version $$$ k $$$ always $$$ 3 $$$ chief wizard wizengamot catch evil wizard drahyrt evil wizard return want revenge chief wizard steal spell $$$ s $$$ student harry spell — a $$$ n $$$ -length string lowercase latin letter drahyrt want replace spell unforgivable curse — string $$$ t $$$ drahyrt use ancient magic swap letter a distance $$$ k $$$ $$$ k+1 $$$ spell many time want version problem swap letter a distance $$$ 3 $$$ $$$ 4 $$$ word drahyrt change letter position $$$ i $$$ $$$ j $$$ spell $$$ s $$$ $$$ |i - <unknown> $$$ $$$ |i - <unknown> $$$ example $$$ s = $$$ ` ` talant '' $$$ t = $$$ ` ` atltna '' drahyrt act follow : give spell $$$ s $$$ $$$ t $$$ drahyrt change spell $$$ s $$$ $$$ t $$$ ? first line input give a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test descriptions test case follow first line contain two integers $$$ n k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ k = 3 $$$ ) — length spell number $$$ k $$$ drahyrt change letter a spell a distance $$$ k $$$ $$$ k+1 $$$ second line give spell $$$ s $$$ — a string length $$$ n $$$ consist lowercase latin letter third line give spell $$$ t $$$ — a string length $$$ n $$$ consist lowercase latin letter guarantee sum $$$ n $$$ value test case exceed $$$ 200000 $$$ note limit sum $$$ k $$$ value test case test case output a separate line ` ` yes '' drahyrt change spell $$$ s $$$ $$$ t $$$ ` ` '' otherwise output answer case ( example line ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive answer ) first example explain condition second example proceed follow : third example show impossible get string $$$ t $$$ string $$$ s $$$ swap letter a distance $$$ 3 $$$ $$$ 4 $$$ fourth example example follow sequence transformations appropriate : fifth example show impossible get string $$$ s $$$ string $$$ t $$$ sixth example enough swap two outermost letter,"['brute force', 'dsu', 'graphs', 'greedy', 'strings']",1400.0
1801/B,"$$$ n $$$ departments mall exactly two store convenience number departments integers $$$ 1 $$$ $$$ n $$$ know gift first store $$$ i $$$ department cost $$$ a_i $$$ rubles second store $$$ i $$$ department — $$$ b_i $$$ rubles enter mall sasha visit $$$ n $$$ departments mall department enter exactly one store sasha get $$$ i $$$ -th department perform exactly one two action : sasha go buy least one gift friend moreover want pick gift a way price difference expensive gift buy friends small possible one offend formally : let $$$ m_1 $$$ maximum price a gift buy first friend $$$ m_2 $$$ maximum price a gift buy second friend sasha want choose gift a way minimize value $$$ \lvert m_1 - m_2 \rvert $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1\,000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 500\,000 $$$ ) — number departments mall follow $$$ n $$$ line test case contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 0 \le a_i b_i \le 1000000000 $$$ ) — price gift first second store $$$ i $$$ department respectively guarantee sum $$$ n $$$ test case exceed $$$ 500\,000 $$$ print one integer — minimum price difference expensive gift buy friends first test case sasha two possible options : buy a gift first friend first department second friend — second department vice versa first case $$$ m_1 = m_2 = 1 $$$ second case — $$$ m_1 = m_2 = 2 $$$ case answer $$$ 0 $$$ second test case buy gift first friend $$$ 2 $$$ $$$ 4 $$$ $$$ 5 $$$ departments second friend — $$$ 1 $$$ $$$ 3 $$$ departments $$$ m_1 = \max ( 2 4 2 ) = 4 $$$ $$$ m_2 = \max ( 5 3 ) = 5 $$$ answer $$$ \lvert 4 - 5 \rvert = 1 $$$","['data structures', 'greedy', 'sortings']",1800.0
1801/C,"vitya a friend masha really want invite festival favorite band perform however order a friend agree must first evaluate release novelties vitya know masha listen a track cooler previous ones get 1 unit impression unfortunately albums listen <unknown> without change songs place help vitya find order albums masha 's impression turn much possible definitely go festival test consist multiple test case first line contain a single integer t ( $$$ 1 \le t \le 200\,000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200\,000 $$$ ) — number albums album descriptions follow album description consist two line : first line contain a single integer $$$ k_i $$$ ( $$$ 1 \le k_i \le 200\,000 $$$ ) — number track $$$ i $$$ th album follow line contain $$$ k_i $$$ integers $$$ a _ { i 1 } \ a _ { i 2 } \ a _ { i 3 } \ \ldots \ a _ { i k_i } $$$ ( $$$ 1 \le a _ { i j } \le 200\,000 $$$ ) — coolness track $$$ i $$$ album denote $$$ \sum k_i $$$ sum $$$ k_i $$$ guarantee $$$ \sum k_i \le 200\,000 $$$ test case print singular number — maximum impression masha get first test example optimal order listen 4th 2nd 3rd 1st albums case masha listen track follow order : 1 ; 7 ; 8 6 ; 4 9 4 6 8 receive 4 units impression second test example must first listen 1st 4th order 2nd 3rd case masha get maximum impression every song 1st 4th albums nothing 2nd 3rd","['binary search', 'data structures', 'dp', 'greedy', 'sortings']",1900.0
1804/D,annie amateur photographer like take picture giant residential build night take a picture a huge rectangular build see a table $$$ n \times m $$$ windows mean build $$$ n $$$ floor floor exactly $$$ m $$$ windows window either dark bright mean light turn room behind <unknown> know apartment build either one - bedroom two - bedroom one - bedroom apartment exactly one window represent picture two - bedroom apartment exactly two consecutive windows floor moreover value $$$ m $$$ guarantee divisible $$$ 4 $$$ know floor exactly $$$ \frac { m } { 4 } $$$ two - bedroom apartments exactly $$$ \frac { m } { 2 } $$$ one - bedroom apartments actual layout apartments unknown different floor annie consider apartment occupy least one windows bright wonder minimum maximum possible number occupy apartments judge give picture ? formally floor come particular apartments layout exactly $$$ \frac { m } { 4 } $$$ two - bedroom apartments ( two consecutive windows ) $$$ \frac { m } { 2 } $$$ one - bedroom apartments ( single window ) count total number apartments least one bright window minimum maximum possible number get ? first line input contain two positive integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \cdot m \leq 500000 $$$ ) — number floor build number windows per floor respectively guarantee $$$ m $$$ divisible $$$ 4 $$$ follow $$$ n $$$ line contain $$$ m $$$ character $$$ j $$$ -th character $$$ i $$$ -th line ` ` 0 '' $$$ j $$$ -th window $$$ i $$$ -th floor dark ` ` 1 '' window bright print two integers minimum possible number occupy apartments maximum possible number occupy apartments assume floor individual layout $$$ \frac { m } { 4 } $$$ two - bedroom $$$ \frac { m } { 2 } $$$ one - bedroom apartments first example floor consist one two - bedroom apartment two one - bedroom apartments follow apartment layout achieve minimum possible number occupy apartments equal $$$ 7 $$$ follow apartment layout achieve maximum possible number occupy apartments equal $$$ 10 $$$,"['brute force', 'dp', 'greedy', 'implementation']",2000.0
1804/H,"lara a safe lock a circle - shaped code lock consist a rotate arrow a static circumference around arrow input screen input button circumference lock split $$$ k $$$ equal section number $$$ 1 $$$ $$$ k $$$ clockwise order arrow always point one section section mark one first $$$ k $$$ letter english alphabet two section mark letter due lock limitations safe 's password a string length $$$ n $$$ consist first $$$ k $$$ letter english alphabet lara enter password rotate lock 's arrow press input button initially lock 's arrow point section $$$ 1 $$$ input screen empty one second one follow action lara recently find safe re - <unknown> take first $$$ k $$$ letter english alphabet assign sectors order like want re - arrange letter a way minimize number second take input password compute minimum number second number ways assign letter minimum number second achieve two ways assign letter sectors consider distinct exist least one sector $$$ i $$$ assign different letter first line input contain two integers $$$ k $$$ $$$ n $$$ ( $$$ 2 \leq k \leq 16 $$$ $$$ 2 \leq n \leq 100\,000 $$$ ) — number sectors lock 's circumference length lara 's password respectively second line input contain a string length $$$ n $$$ consist first $$$ k $$$ lowercase letter english alphabet string password first line print minimum possible number second take lara enter password open safe assign letter sectors optimally second line print number ways assign letter optimally initial state optimal arrangements first example show figure initial state optimal arrangements second example show figure initial state optimal arrangements third example show figure","['bitmasks', 'dp']",3300.0
1806/B,"give array $$$ a $$$ length $$$ n $$$ score $$$ a $$$ mex $$$ ^ { \dagger } $$$ $$$ [ a_1+a_2 a_2+a_3 \ldots a _ { n-1 } + a_n ] $$$ find minimum score $$$ a $$$ allow rearrange elements $$$ a $$$ order note require construct array $$$ a $$$ achieve minimum score $$$ ^ { \dagger } $$$ mex ( minimum exclude ) array smallest non - negative integer belong array instance : first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2\le n\le 2\cdot100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 2\cdot 100000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case output minimum score $$$ a $$$ rearrange elements $$$ a $$$ order first test case optimal rearrange $$$ a $$$ $$$ [ 0,0 ] $$$ score array mex $$$ [ 0 + 0 ] = [ 0 ] $$$ $$$ 1 $$$ second test case optimal rearrange $$$ a $$$ $$$ [ 0,1,0 ] $$$ score array mex $$$ [ 0 + 1,1 + 0 ] = [ 1,1 ] $$$ $$$ 0 $$$",['greedy'],900.0
1806/F2,"hard version problem difference two versions constraint $$$ m $$$ make hack versions problem solve give array $$$ a $$$ length $$$ n $$$ two integers $$$ m $$$ $$$ k $$$ element $$$ a $$$ satisfy $$$ 1\le a_i \le m $$$ one operation choose two indices $$$ i $$$ $$$ j $$$ $$$ 1 \le i < j \le |a| $$$ append $$$ \gcd ( a_i a_j ) $$$ back array delete $$$ a_i $$$ $$$ a_j $$$ array note length array decrease one operation find maximum possible sum array perform exactly $$$ k $$$ operations first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 100000 $$$ ) — number test case description test case follow first line test case contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \le n \le 1000000 $$$ ; $$$ 1\le m \le <unknown> 10^ { 18 } $$$ ; $$$ 1 \le k \le n-1 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le m $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 1000000 $$$ test case output maximum possible sum array perform $$$ k $$$ operations optimally first test case best way choose $$$ i=1 $$$ $$$ j=3 $$$ first operation final sequence $$$ [ 7,4 ] $$$","['greedy', 'math', 'sortings']",2900.0
1808/D,petya friend robot petya++ a common friend — <unknown> petr # sometimes petr # come friends a cup tea tell interest problems today petr # tell follow problem a palindrome a sequence read leave right right leave example $$$ [ 38 12 8 12 38 ] $$$ $$$ [ 1 ] $$$ $$$ [ 3 8 8 3 ] $$$ palindromes let 's call palindromicity a sequence $$$ a_1 a_2 \dots a_n $$$ minimum count elements need replace make sequence a palindrome example palindromicity sequence $$$ [ 38 12 8 38 38 ] $$$ $$$ 1 $$$ since sufficient replace number $$$ 38 $$$ fourth position number $$$ 12 $$$ palindromicity sequence $$$ [ 3 3 5 5 5 ] $$$ two since replace first two threes fives result sequence $$$ [ 5 5 5 5 5 ] $$$ a palindrome give a sequence $$$ a $$$ length $$$ n $$$ odd integer $$$ k $$$ need find sum palindromicity subarrays length $$$ k $$$ i. e. sum palindromicity value sequence $$$ a_i a _ { i+1 } \dots a _ { i+k-1 } $$$ $$$ i $$$ $$$ 1 $$$ $$$ n - k+1 $$$ students quickly solve problem ? first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le k \le n $$$ $$$ k $$$ odd ) — length sequence length subarrays necessary determine whether palindromes second line input contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 200000 $$$ ) — sequence output a single integer — total palindromicity subarrays length $$$ k $$$ first example palindromicity subarray $$$ [ 1 2 8 2 5 ] $$$ $$$ 1 $$$ palindromicity string $$$ [ 2 8 2 5 2 ] $$$ also $$$ 1 $$$ palindromicity string $$$ [ 8 2 5 2 8 ] $$$ $$$ 0 $$$ palindromicity string $$$ [ 2 5 2 8 6 ] $$$ $$$ 2 $$$ total palindromicity $$$ 1 + 1 + 0 + 2 = 4 $$$ second example substring length $$$ 9 $$$ coincide entire string palindromicity $$$ 0 $$$ answer also $$$ 0 $$$,"['binary search', 'brute force', 'data structures', 'two pointers']",2100.0
181/A,berland capital shake three bold crimes commit <unknown> a notorious criminal gang berland capital 's map represent n × m rectangular table cell table map represent district capital capital 's main detective polycarpus take a map mark district first three robberies commit asterisk deduction tell polycarpus fourth robbery commit district four rob district form vertices rectangle parallel side map polycarpus good deduction 's <unknown> math ask find district fourth robbery commit first line contain two space - separated integers n m ( 2 ≤ n m ≤ 100 ) — number row columns table correspondingly next n line contain m character — description capital 's map character either a ` ` . '' ( dot ) ` ` * '' ( asterisk ) a character equal ` ` * '' correspond district rob otherwise equal ` ` . ` ` guarantee map exactly three character ` ` * '' always find fourth district meet problem requirements print two integers — number row number column city district fourth one rob row number start one top bottom columns number start one leave right,"['brute force', 'geometry', 'implementation']",800.0
1810/A,"a sequence $$$ m $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { m } $$$ good exist least one $$$ i $$$ ( $$$ 1 \le i \le m $$$ ) $$$ a _ { i } = i $$$ example $$$ [ 3,2,3 ] $$$ a good sequence since $$$ a _ { 2 } = 2 $$$ $$$ a _ { 3 } = 3 $$$ $$$ [ 3,1,1 ] $$$ a good sequence since $$$ i $$$ $$$ a _ { i } = i $$$ a sequence $$$ a $$$ beautiful exist least one subsequence $$$ a $$$ satisfy subsequence good example $$$ [ <unknown> ] $$$ a beautiful sequence since subsequence $$$ [ 4,2 ] $$$ good $$$ [ <unknown> ] $$$ a beautiful sequence a sequence $$$ b $$$ a subsequence a sequence $$$ a $$$ $$$ b $$$ obtain $$$ a $$$ deletion several ( possibly zero ) elements give a sequence check whether beautiful test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case description follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — length give sequence second line test case contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ ( $$$ 1 \le a _ { i } \le 1000000000 $$$ ) represent sequence test case output ` ` yes '' ` ` '' ( without quote ) one line represent whether give sequence beautiful output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses first test case good subsequence $$$ b= [ 3,2 ] $$$ $$$ b _ { 2 } = 2 $$$ second test case good subsequence $$$ b= [ 2,4,3 ] $$$ $$$ b _ { 3 } = 3 $$$ fourth test case good subsequence $$$ b= [ 1 ] $$$ $$$ b _ { 1 } = 1 $$$ fifth test case good subsequence $$$ b= [ 2,2 ] $$$ $$$ b _ { 2 } = 2 $$$","['brute force', 'greedy']",800.0
1810/C,"integer array $$$ a $$$ length $$$ n $$$ two kinds operations make want make final array a permutation positive length please output minimum cost note make array empty operations final array must contain least one integer a permutation length $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description follow first line test case contain three integers $$$ n $$$ $$$ c $$$ $$$ d $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 1 \le c d \le 1000000000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ ( $$$ 1 \le a _ { i } \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output one line minimum cost make final array a permutation first test case array already a permutation 's need operations second test case remove number $$$ 5 $$$ $$$ 6 $$$ get permutation $$$ [ 1,2,3 ] $$$ cost $$$ 2 $$$ note also get a permutation insert a number $$$ 4 $$$ cost $$$ 5 $$$ third test case remove number except first number $$$ 1 $$$ cost $$$ 8 $$$ final array $$$ [ 1 ] $$$ a permutation length $$$ 1 $$$ fourth test case remove number except $$$ 2 $$$ insert a number $$$ 1 $$$ first position cost $$$ 4 + <unknown> $$$ final array $$$ [ 1,2 ] $$$ a permutation length $$$ 2 $$$","['brute force', 'greedy', 'sortings']",1300.0
1811/D,girl umka love travel participate math olympiads one day fly plane next olympiad boredom explore a huge checker sheet paper denote $$$ n $$$ -th fibonacci number $$$ f_n = \begin { case } 1 & n = 0 ; \\ 1 & n = 1 ; \\ f _ { n-2 } + f _ { n-1 } & n \ge 2 \end { case } $$$ a checker rectangle a height $$$ f_n $$$ a width $$$ f _ { n+1 } $$$ call a fibonacci rectangle order $$$ n $$$ umka a fibonacci rectangle order $$$ n $$$ someone color a cell intersection row $$$ x $$$ column $$$ y $$$ necessary cut rectangle exactly $$$ n+1 $$$ square way <unknown> umka able cut rectangle way ? first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 200000 $$$ ) — number test case test case integers $$$ n $$$ $$$ x $$$ $$$ y $$$ give ( $$$ 1 \le n \le 44 $$$ $$$ 1 \le x \le f_n $$$ $$$ 1 \le y \le f _ { n+1 } $$$ ) — order fibonacci rectangle coordinate color cell test case print ` ` yes '' answer positive ` ` '' otherwise print ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ),"['implementation', 'math']",1600.0
1811/E,japan number $$$ 4 $$$ read like death bob decide build a live sequence live sequence $$$ a $$$ contain natural number contain digit $$$ 4 $$$ $$$ a = [ 1 2 3 5 6 7 8 9 10 11 12 13 15 16 \ldots ] $$$ example number $$$ <unknown> $$$ part sequence $$$ a $$$ number $$$ 4321 $$$ $$$ <unknown> $$$ part sequence $$$ a $$$ bob realize know quickly search a particular number position $$$ k $$$ sequence ask help example bob want find number position $$$ k = 4 $$$ ( index $$$ 1 $$$ ) need answer $$$ a_k = 5 $$$ first line input data contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case line test case a single integer $$$ k $$$ ( $$$ 1 \le k \le 10^ { 12 } $$$ ) — position bob interest test case print a separate line number $$$ a_k $$$ index $$$ 1 $$$,"['binary search', 'dp', 'math', 'number theory']",1500.0
1814/B,a robot place a cell $$$ ( 0 0 ) $$$ infinite grid robot <unknown> length legs initially legs length $$$ 1 $$$ let robot currently cell $$$ ( x y ) $$$ legs length $$$ m $$$ one move perform one follow three action : 's smallest number move robot make reach a cell $$$ ( a b ) $$$ ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case line test case contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le 1000000000 $$$ ) — end cell test case print a single integer — smallest number move robot require make reach a cell $$$ ( a b ) $$$ a cell $$$ ( 0 0 ) $$$ first testcase robot first jump $$$ ( 0 1 ) $$$ $$$ ( 1 1 ) $$$ ever increase length legs able jump past $$$ ( 1 1 ) $$$ second testcase robot jump $$$ ( 1 0 ) $$$ increase length length $$$ 2 $$$ jump three time reach $$$ ( 1 6 ) $$$ third testcase robot increase length legs three time make $$$ 4 $$$ jump $$$ ( 0 4 ) $$$ jump twice reach $$$ ( 8 4 ) $$$,"['brute force', 'math']",1700.0
1815/A,thank ian mary gift array $$$ a $$$ length $$$ n $$$ ian make look smart want make array non - decreasing order follow finitely many time : choose two adjacent elements $$$ a_i $$$ $$$ a _ { i+1 } $$$ ( $$$ 1\le i\le n-1 $$$ ) increase $$$ 1 $$$ decrease $$$ 1 $$$ note elements array become negative a smart person notice array ian make become non - decreasing order ! therefore decide write a program determine possible make array non - decreasing order first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case consist a single integer $$$ n $$$ ( $$$ 2\le n\le 3\cdot100000 $$$ ) — number elements array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1\le a_i\le 1000000000 $$$ ) — elements array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 3\cdot100000 $$$ test case output ` ` yes '' exist a sequence operations make array non - decreasing else output ` ` '' may print letter case ( example ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive answer ) first test case increase $$$ a_2 $$$ $$$ a_3 $$$ $$$ 1 $$$ array $$$ [ 1 4 3 ] $$$ decrease $$$ a_1 $$$ $$$ a_2 $$$ $$$ 1 $$$ array $$$ [ 0 3 3 ] $$$ sort non - decreasing order answer ` ` yes '' second test case matter ian perform operations $$$ a_1 $$$ always larger $$$ a_2 $$$ answer ` ` '' ian pretend smart third test case array already non - decreasing order ian need anything,"['greedy', 'math']",1300.0
1815/B,"interactive problem a hide permutation $$$ p_1 p_2 \dots p_n $$$ consider undirected graph $$$ n $$$ nod edge make two type query : note make type query order within $$$ 2n $$$ query ( include type $$$ 1 $$$ type $$$ 2 $$$ ) guess two possible permutations least one $$$ p_1 p_2 \dots p_n $$$ get accept least one permutations correct allow guess permutation twice a permutation length $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 1000 $$$ ) — length permutation guarantee sum $$$ n $$$ test case exceed $$$ 1000 $$$ interaction test case begin read integer $$$ n $$$ , make $$$ 2n $$$ query : point interaction want guess two permutations output ` ` ! $$$ p _ { 1,1 } $$$ $$$ p _ { 1,2 } $$$ $$$ \dots $$$ $$$ p _ { 1 n } $$$ $$$ p _ { 2,1 } $$$ $$$ p _ { 2,2 } $$$ $$$ \dots $$$ $$$ p _ { 2 n } $$$ ` ` note output two permutations line exclamation mark need separate two permutations read $$$ 1 $$$ $$$ -2 $$$ read $$$ 1 $$$ answer correct otherwise incorrect program must terminate immediately receive a wrong answer verdict , move next test case terminate program none note report answer count a query note even output a correct permutation second permutation a permutation arbitrary array point continue interaction read integer $$$ -2 $$$ get arbitrary verdict solution continue read a close stream print a query answer forget output end line flush output otherwise get idleness limit exceed , use : interactor non - adaptive mean permutations fix interaction start hacksto make a hack use follow format first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 1000 $$$ ) — length permutation second line test case contain $$$ n $$$ distinct integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) — hide permutation sum $$$ n $$$ test case exceed $$$ 1000 $$$ first test case $$$ n=6 $$$ hide permutation $$$ p = [ 1,4,2,5,3,6 ] $$$ firstly make a type $$$ 1 $$$ query $$$ x=12 2 3 $$$ respectively add four edge graph total : since query valid interactor return $$$ 1 $$$ , query number edge shortest path node $$$ p_1 = 1 $$$ $$$ p_3 = 2 $$$ equal $$$ 1 $$$ , make a type $$$ 1 $$$ query $$$ x=5 $$$ add four edge graph total : since query valid interactor return $$$ 1 $$$ , query number edge shortest path node $$$ p_1 = 1 $$$ $$$ p_5 = 3 $$$ equal $$$ 2 $$$ , query number edge shortest path node $$$ p_4 = 5 $$$ $$$ p_5 = 3 $$$ a path n't exist therefore interactor return $$$ -1 $$$ afterwards due magic two possible permutations $$$ p $$$ determine : first permutation $$$ [ 1,4,2,5,3,6 ] $$$ second permutation $$$ [ 1,2,3,4,5,6 ] $$$ since first permutation equal hide permutation test case solve correctly total $$$ 7 $$$ query use within limit $$$ 12 = 12 $$$ query since answer correct interactor return $$$ 1 $$$ second test case $$$ n=2 $$$ hide permutation $$$ p = [ 2,1 ] $$$ since $$$ 2 ! = 2 $$$ possible permutations query need sufficient output two permutations $$$ [ 1,2 ] $$$ $$$ [ 2,1 ] $$$ total $$$ 0 $$$ query use within limit $$$ 4 = 4 $$$ query since answer correct interactor return $$$ 1 $$$","['brute force', 'graphs', 'implementation', 'shortest paths', 'trees']",2000.0
1815/E,"bosco study behaviour particles decide investigate peculiar behaviour so - called ` ` four - one - two '' particle follow : a line length $$$ n+1 $$$ topmost point position $$$ 0 $$$ bottommost position $$$ n+1 $$$ particle initially ( time $$$ t=0 $$$ ) position $$$ 0 $$$ head downwards particle move speed $$$ 1 $$$ unit per second $$$ n $$$ oscillators position $$$ 1,2 \ldots n $$$ oscillator describe a binary string initial state oscillator first character binary string particle hit oscillator particle reverse direction current state $$$ \texttt { 1 } $$$ continue move direction current state $$$ \texttt { 0 } $$$ oscillator move next state ( next state last state define first state ) additionally particle always reverse direction position $$$ 0 $$$ $$$ n+1 $$$ time $$$ t > 0 $$$ bosco would like know cycle length movement particle cycle length define minimum value $$$ c $$$ time $$$ t \ge 0 $$$ position particle time $$$ t $$$ position particle time $$$ <unknown> $$$ prove value $$$ c $$$ always exist realise answer might large ask output answer modulo $$$ 998244353 $$$ first line contain integer $$$ n $$$ ( $$$ 1\le <unknown> $$$ ) — number oscillators $$$ i $$$ -th next $$$ n $$$ line contain a binary string $$$ s_i $$$ ( $$$ <unknown> $$$ ) — binary string contain character $$$ \texttt { 0 } $$$ $$$ \texttt { 1 } $$$ describe oscillator position $$$ i $$$ guarantee sum $$$ |s_i| $$$ exceed $$$ 1000000 $$$ output a single integer integer — cycle length movement particle modulo $$$ 998244353 $$$ first sample oscillator position $$$ 1 $$$ always state $$$ \texttt { 0 } $$$ time moments $$$ <unknown> $$$ position particle $$$ <unknown> $$$ respectively position repeat $$$ <unknown> $$$ animation second sample : a <unknown> animation","['dp', 'math', 'number theory', 'strings']",3100.0
1817/A,"a sequence almost - increasing contain three consecutive elements $$$ x y z $$$ $$$ <unknown> <unknown> z $$$ give array $$$ a_1 a_2 \dots a_n $$$ $$$ q $$$ query query consist two integers $$$ 1\le l\le r\le n $$$ query find length longest almost - increasing subsequence subarray $$$ a_l a _ { l+1 } \dots a_r $$$ a subsequence a sequence derive give sequence delete zero elements without change order remain elements first line input contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \leq n q \leq 200\,000 $$$ ) — length array $$$ a $$$ number query second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — value array $$$ a $$$ next $$$ q $$$ line contain description a query line contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l \leq r \leq n $$$ ) — query subarray $$$ a_l a _ { l+1 } \dots a_r $$$ $$$ q $$$ query print a line contain length longest almost - increasing subsequence subarray $$$ a_l a _ { l+1 } \dots a_r $$$ first query subarray $$$ a_1 a_2 a_3 = [ 1,2,4 ] $$$ whole subarray almost - increasing answer $$$ 3 $$$ second query subarray $$$ a_1 a_2 a_3 a_4 = [ 1,2,4,3 ] $$$ whole subarray a almost - increasing three consecutive elements $$$ x \geq y \geq z $$$ answer $$$ 4 $$$ third query subarray $$$ a_2 a_3 a_4 a_5 = [ 2 4 3 3 ] $$$ whole subarray almost - increasing last three elements satisfy $$$ 4 \geq 3 \geq 3 $$$ almost - increasing subsequence length $$$ 3 $$$ find ( example take $$$ a_2 a_3 a_5 = [ 2,4,3 ] $$$ ) answer $$$ 3 $$$","['binary search', 'data structures', 'greedy']",1500.0
1817/C,a polynomial $$$ a ( x ) $$$ degree $$$ d $$$ expression form $$$ a ( x ) = a_0 + a_1 x + a_2 x^2 + \dots + a_d x^d $$$ $$$ a_i $$$ integers $$$ a_d \neq 0 $$$ two polynomials $$$ a ( x ) $$$ $$$ b ( x ) $$$ call similar integer $$$ s $$$ integer $$$ x $$$ hold $$$ $$$ b ( x ) \equiv a ( x+s ) \pmod { 1000000000 + 7 } $$$ $$$ two similar polynomials $$$ a ( x ) $$$ $$$ b ( x ) $$$ degree $$$ d $$$ 're give value point $$$ <unknown> \dots d $$$ modulo $$$ 1000000000 + 7 $$$ find a value $$$ s $$$ $$$ b ( x ) \equiv a ( x+s ) \pmod { 1000000000 + 7 } $$$ integers $$$ x $$$ first line contain a single integer $$$ d $$$ ( $$$ 1 \le d \le <unknown> $$$ ) second line contain $$$ d+1 $$$ integers $$$ a ( 0 ) a ( 1 ) \ldots a ( d ) $$$ ( $$$ 0 \le a ( i ) < 1000000000 + 7 $$$ ) — value polynomial $$$ a ( x ) $$$ third line contain $$$ d+1 $$$ integers $$$ b ( 0 ) b ( 1 ) \ldots b ( d ) $$$ ( $$$ 0 \le b ( i ) < 1000000000 + 7 $$$ ) — value polynomial $$$ b ( x ) $$$ guarantee $$$ a ( x ) $$$ $$$ b ( x ) $$$ similar lead coefficients ( i.e. coefficients front $$$ x^d $$$ ) $$$ a ( x ) $$$ $$$ b ( x ) $$$ divisible $$$ 1000000000 + 7 $$$ print a single integer $$$ s $$$ ( $$$ 0 \leq s < 1000000000 + 7 $$$ ) $$$ b ( x ) \equiv a ( x+s ) \pmod { 1000000000 + 7 } $$$ integers $$$ x $$$ multiple solutions print first example $$$ a ( x ) \equiv x-1 \pmod { 1000000000 + 7 } $$$ $$$ b ( x ) \equiv x+2 \pmod { 1000000000 + 7 } $$$ 're similar $$$ $$$ b ( x ) \equiv a ( x+3 ) \pmod { 1000000000 + 7 } $$$ $$$ second example $$$ a ( x ) \equiv ( x+1 ) ^2 \pmod { 1000000000 + 7 } $$$ $$$ b ( x ) \equiv ( <unknown> ) ^2 \pmod { 1000000000 + 7 } $$$ hence $$$ $$$ b ( x ) \equiv a ( <unknown> ) \pmod { 1000000000 + 7 } $$$ $$$,"['combinatorics', 'math']",2400.0
1819/A,"know problem require use complex data structure consider constructive offer solve one problems give array $$$ a $$$ $$$ n $$$ non - negative integers allow perform follow operation exactly : choose non - empty subsegment $$$ a_l a _ { l+1 } \ldots a_r $$$ array $$$ a $$$ a non - negative integer $$$ k $$$ assign value $$$ k $$$ elements array choose subsegment task find whether $$$ \operatorname { mex } ( a ) $$$ increase exactly one perform operation word operation $$$ \operatorname { mex } ( a ) = m $$$ hold operation must hold $$$ \operatorname { mex } ( a ) = m + 1 $$$ recall $$$ \operatorname { mex } $$$ a set integers $$$ c_1 c_2 \ldots c_k $$$ define smallest non - negative integer $$$ x $$$ occur set $$$ c $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 50\,000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200\,000 $$$ ) — number elements array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — elements array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200\,000 $$$ test case print ` ` yes '' increase $$$ \operatorname { mex } ( a ) $$$ exactly one perform operation statement exactly otherwise print ` ` '' output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses first test case $$$ \operatorname { mex } ( a ) = 0 $$$ set elements $$$ a $$$ $$$ 0 $$$ $$$ \operatorname { mex } $$$ result array $$$ 1 $$$ thus increase one second test case $$$ \operatorname { mex } ( a ) = 1 $$$ assign a value $$$ 1 $$$ elements $$$ a $$$ a subsegment $$$ 2 $$$ $$$ 3 $$$ get array $$$ [ 0 1 1 0 ] $$$ $$$ \operatorname { mex } $$$ $$$ 2 $$$ thus increase one compare original show third fourth test case impossible perform operation value $$$ \operatorname { mex } ( a ) $$$ increase exactly one","['brute force', 'greedy']",1300.0
1819/C,fox yae climb tree sacred sakura a tree a connect undirected graph contain cycle fox use magical power move around tree yae jump vertex $$$ v $$$ another vertex $$$ u $$$ distance vertices exceed $$$ 2 $$$ word one jump yae jump vertex $$$ v $$$ vertex $$$ u $$$ vertices $$$ v $$$ $$$ u $$$ connect edge exist vertex $$$ w $$$ vertices $$$ v $$$ $$$ w $$$ connect edge also vertices $$$ u $$$ $$$ w $$$ connect edge yae able get sakura petal wonder a cyclic route tree $$$ v_1 v_2 \ldots v_n $$$ : help fox determine require traversal exist first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — the number vertices tree follow $$$ n - 1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) — vertices connect edge guarantee edge form a tree first line print ` ` yes '' ( without quote ) require route tree exist ` ` '' ( without quote ) otherwise require tree traversal exist second line print $$$ n $$$ integers different integers $$$ v_1 v_2 \ldots v_n $$$ ( $$$ 1 \le v_i \le n $$$ ) — vertices tree traversal order several correct traversals output tree first example show bold arrows indicate fox 's route second example sequence three different vertices a correct route fox jump vertex vertex tree third example show show require route,"['dp', 'implementation', 'math', 'trees']",2400.0
1819/D,"schoolboy misha get tire sport program decide quit everything go magical forest sell magic apples friend danya come magical forest visit misha surprise find misha find a lot friends former sport programmers , like misha shop sell magic apples support friends change live <unknown> decide buy entire assortment buy process work follow : total $$$ n $$$ stall number integers $$$ 1 $$$ $$$ n $$$ $$$ m $$$ kinds magic apples number integers $$$ 1 $$$ $$$ m $$$ shop sell number kinds apples danya visit shop order increase number start first one upon enter shop buy one magic apple kind sell shop put backpack however magical apples would n't magical right point two apples type end together backpack apples magically disappear <unknown> disappearance happen danya put apples backpack leave shop upon return home danya realize somewhere forest manage lose backpack unfortunately shop danya forget assortment apples remember shop kinds magical apples sell want know maximum number apples could backpack purchase best test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200000 $$$ ) — the number test case description test case follow first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 200000 $$$ ) — the number stall kinds apples follow $$$ n $$$ line describe assortment next stall format describe line start integer $$$ k_i $$$ ( $$$ 0 \le k_i \le 200000 $$$ ) follow $$$ k_i $$$ different integers $$$ a _ { ij } $$$ ( $$$ 1 \le a _ { ij } \le m $$$ ) — the kinds apples sell $$$ i $$$ -th stall $$$ k_i = 0 $$$ danya remember assortment shop set apple kinds anything ( include empty ) guarantee sum $$$ k_i $$$ test case exceed $$$ 200000 $$$ sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a single integer — maximum number apples could <unknown> 's backpack visit shop best first test case danya remember shop process deterministic take two apples first shop two second put backpack disappear end $$$ 2 $$$ apples leave take third shop second test case third shop empty visit fourth shop apples disappear case apples disappear third shop fourth shop dan take one apple answer $$$ 1 $$$ third test case first shop may sell kinds apples second shop may sell nothing $$$ 5 $$$ apples leave end","['brute force', 'data structures', 'dp', 'two pointers']",2800.0
182/A,"vasya <unknown> behind university get battlefield joke ! 's simply play computer game field a flat platform n trench dig trench segment a plane parallel coordinate ax two trench intersect a huge enemy laser far away vasya laser charge a second shoot continuously b second , charge a second shoot continuously b second vasya know number a b. also know laser shoot vasya must trench laser charge vasya safely move around field main thing time hide trench shoot vasya reach trench exactly moment laser start shoot believe vasya manage hide coincidentally length trench meter numerically exceed b. initially vasya point a. need get point b. vasya move speed 1 meter per second either direction get trench point get trench take time also possible move trench without leave minimum time vasya need get point a point b initial time laser start charge ? vasya get point a point b print -1 . vasya reach point b moment laser begin shoot believe vasya manage reach point b. first line contain two space - separated integers : a b ( 1 ≤ a b ≤ 1000 ) — duration charge duration shoot second second line contain four space - separated integers : ax ay bx ( - 104 ≤ ax ay bx ≤ 104 ) — coordinate point а b. guarantee point a b belong trench third line contain a single integer : n ( 1 ≤ n ≤ 1000 ) — number trench follow n line contain four space - separated integers : x1 y1 x2 y2 ( - 104 ≤ xi yi ≤ 104 ) — coordinate end correspond trench coordinate give meter guarantee trench either x1 = x2 y1 = y2 two trench intersect length trench meter n't exceed b numerically vasya get point a point b print minimum time need otherwise print number -1 . answer consider correct absolute relative error exceed 10 - 4","['geometry', 'graphs', 'implementation', 'shortest paths']",2200.0
1821/B,monocarp array $$$ a $$$ consist $$$ n $$$ integers decide choose two integers $$$ l $$$ $$$ r $$$ $$$ 1 \le l \le r \le n $$$ sort subarray $$$ a [ l .. r ] $$$ ( subarray $$$ a [ l .. r ] $$$ part array $$$ a $$$ contain elements $$$ a_l a _ { l+1 } a _ { l+2 } \dots a _ { r-1 } a_r $$$ ) non - descending order sort subarray monocarp obtain a new array denote $$$ a ' $$$ example $$$ a = [ 6 7 3 4 4 6 5 ] $$$ monocarp choose $$$ l = 2 r = 5 $$$ $$$ a ' = [ 6 3 4 4 7 6 5 ] $$$ give array $$$ a $$$ $$$ a ' $$$ find integers $$$ l $$$ $$$ r $$$ monocarp could choose multiple pair value $$$ ( l r ) $$$ find one correspond longest subarray first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist three line : additional constraints input : test case print two integers — value $$$ l $$$ $$$ r $$$ ( $$$ 1 \le l \le r \le n $$$ ) multiple answer print value correspond longest subarray still multiple answer print,"['brute force', 'greedy']",1100.0
1821/E,a regular bracket sequence a bracket sequence transform a correct arithmetic expression insert character ` ` 1 '' ` ` + '' original character sequence example : give a regular bracket sequence one move remove a pair adjacent bracket leave one open bracket right one a close bracket concatenate result part without change order cost move number bracket right right bracket pair cost regular bracket sequence smallest total cost move require make sequence empty actually remove bracket instead give a regular bracket sequence integer $$$ k $$$ perform follow operation $$$ k $$$ time : operations perform bracket sequence regular smallest possible cost result regular bracket sequence ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain a single integer $$$ k $$$ ( $$$ 0 \le k \le 5 $$$ ) — maximum number operations perform second line contain a non - empty regular bracket sequence consist character ' ( ' ' ) ' total length regular bracket sequence testcases n't exceed $$$ 200000 $$$ testcase print a single integer — smallest possible cost regular bracket sequence perform $$$ k $$$ operations,"['brute force', 'dp', 'greedy', 'sortings', 'strings']",2100.0
1823/D,"a palindrome a string read backwards forward example string abcba palindrome string abca let $$$ p ( t ) $$$ number unique palindromic substrings string $$$ t $$$ i. e. number substrings $$$ t [ l \dots r ] $$$ palindromes even substring occur $$$ t $$$ several time 's count exactly ( whole string $$$ t $$$ also count a substring $$$ t $$$ ) example string $$$ t $$$ $$$ = $$$ abcbbcabcb $$$ p ( t ) = 6 $$$ unique palindromic substrings : a b c bb bcb <unknown> , let 's define $$$ p ( s m ) = p ( t ) $$$ $$$ t = s [ 1 \dots m ] $$$ word $$$ p ( s m ) $$$ number palindromic substrings prefix $$$ s $$$ length $$$ m $$$ example $$$ p ( $$$ abcbbcabcb $$$ 5 ) $$$ $$$ = $$$ $$$ p ( $$$ <unknown> $$$ ) = 5 $$$ give integer $$$ n $$$ $$$ k $$$ ` ` condition '' ( $$$ k \le 20 $$$ ) let 's say string $$$ s $$$ consist $$$ n $$$ lowercase latin letter good $$$ k $$$ condition satisfy time a condition a pair $$$ ( x_i c_i ) $$$ follow mean : look note need clarifications test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 3 \le n \le 200000 $$$ ; $$$ 1 \le k \le 20 $$$ ) — length good string $$$ s $$$ number condition second line test case contain $$$ k $$$ integers $$$ x_1 x_2 \dots x_k $$$ ( $$$ 3 \le x_1 < x_2 < \dots < x_k = n $$$ ) $$$ x_i $$$ length prefix $$$ i $$$ -th condition third line test case contain $$$ k $$$ integers $$$ c_1 c_2 \dots c_k $$$ ( $$$ 3 \le c_1 \le c_2 \le \dots \le c_k \le \min { \left ( 1000000000 \frac { ( n + 1 ) n } { 2 } \right ) } $$$ ) $$$ c_i $$$ number palindromic substrings $$$ i $$$ -th condition guarantee sum $$$ n $$$ test case exceed $$$ 20 ^ 5 $$$ test case good string $$$ s $$$ length $$$ n $$$ satisfy condition print otherwise print yes a string $$$ s $$$ length $$$ n $$$ consist lowercase latin letter satisfy condition multiple answer print first test case string $$$ s $$$ $$$ = $$$ abcbbcabcb satisfy $$$ k = 2 $$$ condition : second test case string <unknown> satisfy $$$ k = 1 $$$ condition : third test case string <unknown> satisfy $$$ k = 2 $$$ condition : fourth test case string <unknown> satisfy $$$ k = 2 $$$ condition : fifth test case prove string length $$$ 4 $$$ $$$ 5 $$$ palindromic substrings sixth test case string <unknown> satisfy $$$ k = 3 $$$ condition :","['math', 'strings']",1900.0
1824/A,$$$ n $$$ people take part a show <unknown> sit row seat number $$$ 1 $$$ $$$ m $$$ leave right $$$ n $$$ people come sit order person occupy a seat one three ways : want know maximum number people take a seat let people show order ? test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100000 $$$ ) — number people number seat second line test case contain $$$ n $$$ integers $$$ x_1 x_2 \ldots x_n $$$ ( $$$ -2 \le x_i \le m $$$ $$$ x_i \ne 0 $$$ ) $$$ i $$$ -th describe way $$$ i $$$ -th person occupy a seat : guarantee sum $$$ n $$$ sum $$$ m $$$ test case n't exceed $$$ 100000 $$$ test case output a single integer — maximum number people occupy a seat first test case people want occupy $$$ 5 $$$ seat $$$ 1 $$$ people occupy seat second test case let people order $$$ 1 2 3 4 $$$ last person take a seat third test case let people show order : let third person : – – – 3 – – – let fourth person : – – – 34 – – let fifth person : – – – <unknown> – let first person : – – 1345 – let second person : – <unknown> – thus $$$ 5 $$$ people take seat fifth test case let people show order : let fourth person : – – – – 4 – let third person : – – – 34 – let sixth person 'll leave show take third seat third way sit $$$ 4 $$$ seat 's already take : – – – 34 – let fifth person : – – <unknown> – let first person : – <unknown> – let second person <unknown> – thus $$$ 5 $$$ people take seat seventh test case let people show order : let third person <unknown> fourth person <unknown> – – – – – let fifth person <unknown> – – – – let sixth person <unknown> – – – let first person <unknown> second person leave show occupy first way $$$ 1 $$$ seat <unknown> $$$ 5 $$$ people take seat,"['greedy', 'implementation']",1400.0
1825/A,luotianyi give a palindrome $$$ ^ { \dagger } $$$ string $$$ s $$$ want find length longest non - empty subsequence $$$ ^ { \ddagger } $$$ $$$ s $$$ a palindrome string subsequence output $$$ -1 $$$ instead $$$ ^ { \dagger } $$$ a palindrome a string read backward forward example string ` ` z '' ` ` aaa '' ` ` aba '' ` ` abccba '' palindromes string ` ` codeforces '' ` ` reality '' ` ` ab '' $$$ ^ { \ddagger } $$$ a string $$$ a $$$ a subsequence a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character $$$ b $$$ example string ` ` a '' ` ` aaa '' ` ` bab '' subsequences string ` ` abaab '' string ` ` codeforces '' ` ` bbb '' ` ` h '' test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case description test case follow first line test case contain a single string $$$ s $$$ ( $$$ 1 \le |s| \le 50 $$$ ) consist lowercase english letter — string luotianyi give 's guarantee $$$ s $$$ a palindrome string test case output a single integer — length longest non - empty subsequence a palindrome string subsequence output $$$ -1 $$$ first test case ` ` abcaba '' a subsequence ` ` abacaba '' delete third letter ` ` abacaba '' get ` ` abcaba '' ` ` abcaba '' a palindrome string prove ` ` abcaba '' example longest subsequences ` ` abacaba '' n't palindrome answer $$$ 6 $$$ second test case get ` ` a '' ` ` aa '' palindrome string answer $$$ -1 $$$,"['greedy', 'strings']",800.0
1825/B,"luotianyi give array $$$ b $$$ $$$ n \cdot m $$$ integers ask construct a table $$$ a $$$ size $$$ n \times m $$$ fill $$$ n \cdot m $$$ number element array must use exactly also ask maximize follow value : mean consider $$$ n \cdot m $$$ <unknown> upper leave corner $$$ ( 1,1 ) $$$ bottom right corner $$$ ( i j ) $$$ ( $$$ 1 \le i \le n $$$ $$$ 1 \le j \le m $$$ ) subtable calculate difference maximum minimum elements sum differences maximize result sum help find maximal possible value n't need reconstruct table test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n m \le 100 $$$ ) — number row columns table second line test case contain $$$ n \cdot m $$$ integers $$$ b_1 b_2 \ldots b _ { n\cdot m } $$$ ( $$$ -100000 \le b _ { i } \le 100000 $$$ ) — number put table note integers array $$$ b $$$ negative guarantee sum $$$ n \cdot m $$$ test case n't exceed $$$ 2\cdot 100000 $$$ test case output a single integer — maximal value obtain first test case table <unknown> subtable bottom right corner $$$ ( 1 1 ) $$$ difference maximal minimal elements $$$ 4 - 4 = 0 $$$ subtable bottom right corner $$$ ( 1 2 ) $$$ difference maximal minimal elements $$$ 4 - 1 = 3 $$$ subtable bottom right corner $$$ ( 2 1 ) $$$ difference maximal minimal elements $$$ 4 - 1 = 3 $$$ subtable bottom right corner $$$ ( 2 2 ) $$$ difference maximal minimal elements $$$ 4 - 1 = 3 $$$ maximum possible value $$$ 0 + 3 + 3 + 3=9 $$$ second test case elements equal differences $$$ 0 $$$ answer $$$ 0 $$$","['greedy', 'math']",1000.0
1826/F,"interactive problem $$$ n $$$ distinct hide point real coordinate a two - dimensional euclidean plane one query ask line $$$ ax + + c = 0 $$$ get projections $$$ n $$$ point line order give projections exact please read interaction section clarity use minimum number query guess $$$ n $$$ point output order minimality mean minimum number query require solve possible test case $$$ n $$$ point hide point fix advance change throughout interaction word interactor adaptive a projection point $$$ a $$$ line $$$ ax + + c = 0 $$$ point line closest $$$ a $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 50 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 25 $$$ ) — number hide point test case guarantee pair hide point $$$ x $$$ coordinate differ least $$$ 1 $$$ analogously $$$ y $$$ coordinate pair also differ least $$$ 1 $$$ coordinate $$$ x $$$ $$$ y $$$ hide point exceed $$$ 100 $$$ absolute value query a line $$$ ax + + c = 0 $$$ print ` ` ? a b c '' a b c real number $$$ 100 $$$ absolute value less precision issue number $$$ a $$$ $$$ b $$$ must satisfy condition $$$ |a| + |b| \geq 0.1 $$$ $$$ |a| $$$ absolute value $$$ a $$$ answer query get $$$ n $$$ point form ` ` x_1 y_1 ... x_n y_n '' point $$$ ( x_i y_i ) $$$ projections line $$$ ax + + c = 0 $$$ guarantee print point $$$ 10^ { -4 } $$$ away real projection point every coordinate print 9 decimal place see interaction example clarity ask many query get wrong answer output answer print ` ` ! x_1 y_1 ... x_n y_n '' $$$ ( x_i y_i ) $$$ coordinate hide point could output hide point order answer would consider correct print point $$$ 10^ { -3 } $$$ away correspond hide point print answer n't count a query print a query answer forget output end line flush output otherwise get idleness limit exceed , use : hacksto make a hack use follow test format first line output a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 50 $$$ ) — number test case description test case follow first line test case output a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 25 $$$ ) next $$$ n $$$ line output two rational number number line $$$ i $$$ correspond $$$ x_i $$$ $$$ y_i $$$ respectively print point must comply constraints input section sample hide point $$$ ( 1 3 ) $$$ $$$ ( 2.5 0.5 ) $$$ a picture describe first query : a picture describe second query :","['geometry', 'math']",2800.0
1827/F,"give a permutation $$$ a_1 a_2 \ldots a_n $$$ first $$$ n $$$ positive integers a subarray $$$ [ l r ] $$$ call copium rearrange become a sequence consecutive integers formally $$$ $$$ \max ( a_l a _ { l+1 } \ldots a_r ) -\min ( a_l a _ { l+1 } \ldots a_r ) = r - l $$$ $$$ $$$ k $$$ range $$$ [ 0 n ] $$$ print maximum number copium subarrays $$$ a $$$ ways rearrange last $$$ n - k $$$ elements $$$ a $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1\le n\le 2\cdot 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) guarantee give number form a permutation length $$$ n $$$ guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case print $$$ n+1 $$$ integers answer $$$ k $$$ range $$$ [ 0 n ] $$$ first test case answer permutations $$$ k $$$ $$$ [ 1,2,3,4,5 ] $$$ $$$ [ 5,4,3,2,1 ] $$$ $$$ [ <unknown> ] $$$ $$$ [ <unknown> ] $$$ $$$ [ 5,2,1,4,3 ] $$$ $$$ [ 5,2,1,4,3 ] $$$ second test case answer permutations $$$ k $$$ $$$ [ 1,2,3,4 ] $$$ $$$ [ 2,1,3,4 ] $$$ $$$ [ 2,1,3,4 ] $$$ $$$ [ 2,1,4,3 ] $$$ $$$ [ 2,1,4,3 ] $$$","['data structures', 'greedy']",3500.0
1828/A,give a positive integer $$$ n $$$ please find array $$$ a_1 a_2 \ldots a_n $$$ perfect a perfect array $$$ a_1 a_2 \ldots a_n $$$ satisfy follow criteria : test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 200 $$$ ) description test case follow line test case contain a single positive integer $$$ n $$$ ( $$$ 1 \le n \le 200 $$$ ) — length array $$$ a $$$ test case output array $$$ a_1 a_2 \ldots a_n $$$ perfect show answer always exist multiple solutions print third test case : fifth test case :,['math'],800.0
1830/D,"give a tree $$$ n $$$ nod node either color $$$ 0 $$$ $$$ 1 $$$ value a path $$$ ( u v ) $$$ equal mex $$$ ^\dagger $$$ color nod shortest path $$$ u $$$ $$$ v $$$ value a color equal sum value paths $$$ ( u v ) $$$ $$$ 1 \leq u \leq v \leq n $$$ maximum possible value color tree ? $$$ ^ { \dagger } $$$ mex ( minimum exclude ) array smallest non - negative integer belong array instance : test contain multiple test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number nod tree follow $$$ n-1 $$$ line test case contain $$$ 2 $$$ integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a_i b_i \leq n a_i \neq b_i $$$ ) — indicate edge vertices $$$ a_i $$$ $$$ b_i $$$ guarantee give edge form a tree guarantee sum $$$ n $$$ across test case exceed $$$ 200000 $$$ test case print maximum possible value color tree first sample color vertex $$$ 2 $$$ $$$ 1 $$$ vertices $$$ 1,3 $$$ $$$ 0 $$$ , consider paths : notice sum value $$$ 8 $$$ maximum possible","['brute force', 'dp', 'trees']",2800.0
1833/F,ira love <unknown> <unknown> dance much decide start dance studio find $$$ n $$$ students $$$ i $$$ th level $$$ a_i $$$ ira choose several students set a dance set a huge number dance interest magnificent dance dance call magnificent follow true : example $$$ m = 3 $$$ $$$ a = [ 4 2 2 3 6 ] $$$ follow dance magnificent ( students participate dance highlight red ) : $$$ [ \color { red } { 4 } 2 \color { red } { 2 } \color { red } { 3 } 6 ] $$$ $$$ [ \color { red } { 4 } \color { red } { 2 } 2 \color { red } { 3 } 6 ] $$$ time dance $$$ [ \color { red } { 4 } 2 2 \color { red } { 3 } 6 ] $$$ $$$ [ 4 \color { red } { 2 } \color { red } { 2 } \color { red } { 3 } 6 ] $$$ $$$ [ \color { red } { 4 } 2 2 \color { red } { 3 } \color { red } { 6 } ] $$$ magnificent dance $$$ [ \color { red } { 4 } 2 2 \color { red } { 3 } 6 ] $$$ $$$ 2 $$$ students participate although $$$ m = 3 $$$ dance $$$ [ 4 \color { red } { 2 } \color { red } { 2 } \color { red } { 3 } 6 ] $$$ involve students level $$$ 2 $$$ $$$ 2 $$$ although level dancers must pairwise distinct dance $$$ [ \color { red } { 4 } 2 2 \color { red } { 3 } \color { red } { 6 } ] $$$ students level $$$ 3 $$$ $$$ 6 $$$ participate $$$ |3 - 6| = 3 $$$ although $$$ m = 3 $$$ help ira count number magnificent dance set since number large count modulo $$$ 1000000000 + 7 $$$ two dance consider different set students participate different first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le m \le n \le 200000 $$$ ) — number ira students number dancers magnificent dance second line testcase contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — level students guarantee sum $$$ n $$$ testcases exceed $$$ 200000 $$$ testcase print a single integer — number magnificent dance since number large print modulo $$$ 1000000000 + 7 $$$ first testcase ira set magnificent dance : $$$ [ \color { red } { 8 } 10 10 \color { red } { 9 } \color { red } { 6 } 11 \color { red } { 7 } ] $$$ $$$ [ \color { red } { 8 } \color { red } { 10 } 10 \color { red } { 9 } 6 11 \color { red } { 7 } ] $$$ $$$ [ \color { red } { 8 } 10 \color { red } { 10 } \color { red } { 9 } 6 11 \color { red } { 7 } ] $$$ $$$ [ \color { red } { 8 } 10 \color { red } { 10 } \color { red } { 9 } 6 \color { red } { 11 } 7 ] $$$ $$$ [ \color { red } { 8 } \color { red } { 10 } 10 \color { red } { 9 } 6 \color { red } { 11 } 7 ] $$$ second testcase explain statements,"['combinatorics', 'data structures', 'implementation', 'math', 'sortings', 'two pointers']",1700.0
1834/C,alice bob play a game two string $$$ s $$$ $$$ t $$$ length $$$ n $$$ consist lowercase latin letter players take turn alternately alice go first turn alice choose integer $$$ i $$$ $$$ 1 $$$ $$$ n $$$ one string $$$ s $$$ $$$ t $$$ lowercase latin letter $$$ c $$$ replace $$$ i $$$ -th symbol choose string character $$$ c $$$ turn bob choose one string $$$ s $$$ $$$ t $$$ reverse formally bob make replacement $$$ s : = \operatorname { rev } ( s ) $$$ $$$ t : = \operatorname { rev } ( t ) $$$ $$$ \operatorname { rev } ( p ) = p_n p _ { n-1 } \ldots p_1 $$$ game last string $$$ s $$$ $$$ t $$$ equal soon string become equal game end instantly define duration game total number move make players game example alice make $$$ 2 $$$ move total bob make $$$ 1 $$$ move duration game $$$ 3 $$$ alice 's goal minimize duration game bob 's goal maximize duration game duration game players play optimally ? show game end a finite number turn test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length string $$$ s $$$ $$$ t $$$ second line test case contain a string $$$ s $$$ length $$$ n $$$ consist lowercase latin letter third line test case contain a string $$$ t $$$ length $$$ n $$$ consist lowercase latin letter guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output a single number a separate line — duration describe game players play optimally first test case turn alice replace third symbol string $$$ s $$$ x. string become equal ` ` <unknown> '' game end one move since alice 's goal finish game move possible move one optimal first move final answer $$$ 1 $$$ second test case turn alice replace fifth symbol string $$$ t $$$ h. move $$$ s = $$$ ` ` hello '' $$$ t = $$$ ` ` olleh '' bob make turn turn must reverse one string bob choose string $$$ s $$$ turn string equal ` ` olleh '' choose string $$$ t $$$ turn string equal ` ` hello '' thus present first move alice game definitely end $$$ 2 $$$ move show strategy alice finish game less $$$ 2 $$$ move players play optimally final answer $$$ 2 $$$ third test case first move alice replace second symbol string $$$ s $$$ c. move $$$ s = $$$ ` ` ac '' $$$ t = $$$ ` ` cd '' bob make turn bob reverse string $$$ s $$$ turn $$$ s = $$$ ` ` ca '' $$$ t = $$$ ` ` cd '' easy see case alice definitely finish game $$$ 3 $$$ -rd move replace second symbol string $$$ t $$$ a string become equal ` ` ca '' bob reverse string $$$ t $$$ turn $$$ s = $$$ ` ` ac '' $$$ t = $$$ ` ` dc '' case alice also definitely finish game $$$ 3 $$$ rd move replace first symbol string $$$ s $$$ d string become equal ` ` dc '' thus alice definitely finish game $$$ 3 $$$ move regardless bob 's move show game end less $$$ 3 $$$ move players play optimally fifth test case string $$$ s $$$ $$$ t $$$ equal game end without start $$$ 0 $$$ move,"['greedy', 'math', 'strings']",1200.0
1834/F,recently polycarp give unusual typewriter a gift ! unfortunately typewriter defective a rather strange design typewriter consist $$$ n $$$ cells number leave right $$$ 1 $$$ $$$ n $$$ a carriage move typewriter cells contain $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ cell $$$ i $$$ initially contain integer $$$ p_i $$$ action carriage cell number $$$ 1 $$$ nothing buffer storage cell carriage locate call current cell carriage perform five type operations : polycarp interest typewriter ask help understand ask $$$ q $$$ query three type : query polycarp want know minimum number carriage reset need current sequence order distribute number cells ( number $$$ i $$$ end cell number $$$ i $$$ ) note polycarp want know minimum number carriage reset require arrange number place actually distribute help polycarp find answer query ! first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 400000 $$$ ) — number cells second line contain $$$ n $$$ distinct integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) — initial arrangement integers cells third line contain a single integer $$$ q $$$ ( $$$ 0 \le q \le 400000 $$$ ) — number query next $$$ q $$$ line describe a query polycarp : $$$ j $$$ -th line first contain integer $$$ t_j $$$ ( $$$ 1 \le t_j \le 3 $$$ ) — type query query type $$$ t_j = 1 $$$ $$$ t_j = 2 $$$ integer $$$ k_j $$$ ( $$$ 1 \le k_j \le n $$$ ) — length shift — follow line output $$$ q + 1 $$$ number — minimum number carriage reset require polycarp 's query first example answer $$$ 1 $$$ understand carriage work use example second example sequence answer need calculate look like : third example sequence query look like :,"['brute force', 'math']",2500.0
1835/A,consider equalities form $$$ a + b = c $$$ $$$ a $$$ $$$ a $$$ digits $$$ b $$$ $$$ b $$$ digits $$$ c $$$ $$$ c $$$ digits number positive integers write without lead zero find $$$ k $$$ -th lexicographically smallest equality write a string like determine exist example first three equalities satisfy $$$ a = 1 $$$ $$$ b = 1 $$$ $$$ c = 2 $$$ equality $$$ s $$$ lexicographically smaller equality $$$ t $$$ lengths number follow hold : test contain multiple test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case description test case follow first line test case contain integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ k $$$ ( $$$ 1 \leq a b c \leq 6 $$$ $$$ 1 \leq k \leq 10^ { 12 } $$$ ) input file $$$ 5 $$$ test case satisfy $$$ a b c \leq 3 $$$ test case strictly less $$$ k $$$ valid equalities output $$$ -1 $$$ otherwise output $$$ k $$$ -th equality a string form $$$ a + b = c $$$ first test case first $$$ 9 $$$ solutions : $$$ \langle 1 1 2 \rangle \langle 1 2 3 \rangle \langle 1 3 4 \rangle \langle 1 4 5 \rangle \langle 1 5 6 \rangle \langle 1 6 7 \rangle \langle 1 7 8 \rangle \langle 1 8 9 \rangle \langle 2 1 3 \rangle $$$ int third test case solutions smallest possible value $$$ a $$$ $$$ b $$$ larger maximal possible value $$$ c $$$ — $$$ 10 + 10 = 20 > 9 $$$ please note whitespaces output matter,"['brute force', 'implementation', 'math']",1700.0
1835/D,"rebel crush recent battle imperial force a ray new hope meanwhile one conquer planets luke get ready illegal street race ( come surprise give family history ) luke arrive finish line 88 miles per hour <unknown> get car greet a new reality turn battle happen yet start exactly $$$ k $$$ hours rebel place a single battleship $$$ n $$$ planets $$$ m $$$ unidirectional wormholes connect planets traverse wormhole take exactly one hour general <unknown> plan battle precisely troop <unknown> adapt change circumstances , enough rebel move ship around battle confuse enemy secure victory change galaxy 's fate owe numerous <unknown> considerations omit rebel would like choose two ship switch place move whole time ( exactly $$$ k $$$ hours ) word rebel look two planets $$$ x $$$ $$$ y $$$ paths length $$$ k $$$ exist $$$ x $$$ $$$ y $$$ $$$ y $$$ $$$ x $$$ limit fuel supply choose one ship would also acceptable ship fly wormholes $$$ k $$$ hours return initial planet many ways choose ship complete mission ? first line input three integer number $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ 0 \leq m \leq 200000 $$$ $$$ n^3 \leq k \leq 10^ { 18 } $$$ ) denote respectively number planets wormholes hours leave battle start follow $$$ m $$$ line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq x y \leq n $$$ $$$ x \ne y $$$ ) mean a wormhole planet $$$ x $$$ planet $$$ y $$$ guarantee two identical wormholes i. e. every two wormholes either $$$ x_1 \neq x_2 $$$ $$$ y_1 \neq y_2 $$$ first line program output number possible ways choose a pair a single <unknown> mission first sample test one choose pair ship follow planets : $$$ 2 $$$ $$$ 5 $$$ $$$ 3 $$$ $$$ 5 $$$ $$$ 1 $$$ $$$ 4 $$$ individual ship planets $$$ 6 $$$ $$$ 7 $$$ could also choose second sample test one choose a pair ship follow planets : $$$ 2 $$$ $$$ 3 $$$ individual ship planets $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ could also choose third sample test pair ship choose individual ship planets $$$ 2 $$$ $$$ 3 $$$ could also choose","['dfs and similar', 'graphs', 'math', 'number theory']",2900.0
1837/C,give a string $$$ s $$$ consist character 0 1 and/or ? let 's call a pattern let 's say binary string ( a string character either 0 1 ) match pattern replace character ? 0 1 ( character choice independent ) string become equal example 0010 match ? 01 ? 010 n't match 1 ? ? ? ? ? ? ? ? let 's define cost binary string minimum number operations form ` ` reverse arbitrary contiguous substring string '' require sort string non - descending order find a binary string minimum possible cost among match give pattern multiple answer print first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 30000 $$$ ) — number test case first line test case contain string $$$ s $$$ ( $$$ 1 \le |s| \le 300000 $$$ ) consist character 0 1 and/or ? sum string lengths test case exceed $$$ 300000 $$$ test case print a binary string minimum possible cost among match give pattern multiple answer print first test case example cost result string $$$ 0 $$$ second test case cost result string $$$ 2 $$$ : reverse substring $$$ 1 $$$ -st character $$$ 5 $$$ -th character obtain string 00101 . reverse substring $$$ 3 $$$ -rd $$$ 4 $$$ -th character obtain string 00011 sort non - descending order,['greedy'],1000.0
1838/E,give array $$$ a $$$ $$$ n $$$ integers elements $$$ a_i $$$ lie range $$$ [ 1 k ] $$$ many different array $$$ b $$$ $$$ m $$$ integers elements $$$ b_i $$$ lie range $$$ [ 1 k ] $$$ contain $$$ a $$$ a subsequence ? two array consider different differ least one position a sequence $$$ x $$$ a subsequence a sequence $$$ y $$$ $$$ x $$$ obtain $$$ y $$$ deletion several ( possibly zero ) elements since answer may large print modulo $$$ 1000000000 + 7 $$$ first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n \le 2\cdot 100000 $$$ $$$ n \le m \le 1000000000 $$$ $$$ 1 \le k \le 1000000000 $$$ ) — size $$$ a $$$ size $$$ b $$$ maximum value allow array respectively next line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1\le a_i \le k $$$ ) — elements array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case output a single integer — number suitable array $$$ b $$$ modulo $$$ 1000000000 + 7 $$$ first example since $$$ k=1 $$$ one array size $$$ m $$$ consist integers $$$ [ 1 k ] $$$ array ( $$$ [ 1 1 \ldots 1 ] $$$ ) contain original array a subsequence answer 1 . second example $$$ 9 $$$ array $$$ [ 1 1 2 2 ] $$$ $$$ [ 1 2 1 2 ] $$$ $$$ [ 1 2 2 1 ] $$$ $$$ [ 1 2 2 2 ] $$$ $$$ [ 1 2 2 3 ] $$$ $$$ [ 1 2 3 2 ] $$$ $$$ [ 1 3 2 2 ] $$$ $$$ [ 2 1 2 2 ] $$$ $$$ [ 3 1 2 2 ] $$$ fourth example since $$$ m = n $$$ array size $$$ m $$$ contain $$$ a $$$ a subsequence $$$ a $$$,"['combinatorics', 'dp', 'math']",2500.0
1840/B,upon a time toma find a binary cafe a popular unusual place cafe offer visitors $$$ k $$$ different delicious desserts desserts number $$$ 0 $$$ $$$ k-1 $$$ cost $$$ i $$$ -th dessert $$$ 2^i $$$ coin a binary cafe ! toma will spend $$$ n $$$ coin taste desserts time interest buy dessert one enough evaluate taste many different ways buy several desserts ( possibly zero ) taste ? first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case follow $$$ t $$$ line describe one test case test case give a single line consist two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 1000000000 $$$ ) — number coin toma will spend number desserts binary cafe output $$$ t $$$ integers $$$ i $$$ -th equal answer $$$ i $$$ -th test case — number ways buy desserts taste variants 1st sample : { } { 1 } variants 2nd sample : { } { 1 } variants 3rd sample : { } { 1 } { 2 } variants 4th sample : { } { 1 } { 2 } { 1 2 },"['bitmasks', 'combinatorics', 'math']",1100.0
1840/C,"dima <unknown> a math teacher school send vacation $$$ n $$$ days good work dima long dream go a ski resort want allocate several consecutive days go ski since vacation require careful preparation go least $$$ k $$$ days give array $$$ a $$$ contain weather forecast resort , $$$ i $$$ -th day temperature $$$ a_i $$$ degrees dima bear <unknown> go vacation temperature rise $$$ q $$$ degrees throughout vacation unfortunately dima absorb abstract algebra forget count ask help count number ways choose vacation date resort first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow descriptions test case first line test case contain three integers $$$ n $$$ $$$ k $$$ $$$ q $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le k \le n $$$ $$$ -1000000000 \le q \le 1000000000 $$$ ) — length array $$$ a $$$ minimum number days resort maximum comfortable temperature dima second line test case contain $$$ n $$$ integers $$$ a_1 a_2 a_3 \dots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) — temperature ski resort sum $$$ n $$$ value test case exceed $$$ 200000 $$$ output $$$ t $$$ integers answer correspond test case — number ways dima choose vacation date resort first test case example dima go day suitable date [ 1 ] [ 2 ] [ 3 ] [ 1 2 ] [ 2 3 ] [ 1 2 3 ] second fourth test case example dima go day due high temperature suitable date third test case example dima go date [ 1 2 3 ]","['combinatorics', 'math', 'two pointers']",1000.0
1840/E,give two string equal length $$$ s_1 $$$ $$$ s_2 $$$ consist lowercase latin letter integer $$$ t $$$ need answer $$$ q $$$ query number $$$ 1 $$$ $$$ q $$$ $$$ i $$$ -th query come $$$ i $$$ -th second time query one three type : note query second type character swap string $$$ s_1 $$$ $$$ s_2 $$$ first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow descriptions test case first line test case contain a string $$$ s_1 $$$ consist lowercase latin letter ( length $$$ 200000 $$$ ) second line test case contain a string $$$ s_2 $$$ consist lowercase latin letter ( length $$$ 200000 $$$ ) string equal length third line test case contain two integers $$$ t $$$ $$$ q $$$ ( $$$ 1 \le t q \le 200000 $$$ ) number $$$ t $$$ indicate number second a character block number $$$ q $$$ correspond number query next $$$ q $$$ line test case contain a single query query one three type : query first type guarantee time query character position $$$ pos $$$ block query second type guarantee character swap block value $$$ pos pos_1 pos_2 $$$ range $$$ 1 $$$ length string sum value $$$ q $$$ test case well total length string $$$ s_1 $$$ exceed $$$ 200000 $$$ query third type output ` ` yes '' two string $$$ s_1 $$$ $$$ s_2 $$$ equal time query ignore block character ` ` '' otherwise output letter case ( lowercase uppercase ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' accept a positive answer let 's look string $$$ s_1 $$$ $$$ s_2 $$$ $$$ q $$$ query block character denote red first example input : ( $$$ codeforces $$$ $$$ codeblocks $$$ ) $$$ \rightarrow $$$ ( $$$ codeforces $$$ $$$ codeblocks $$$ ) $$$ \rightarrow $$$ ( $$$ code\color { red } { f } <unknown> $$$ $$$ code\color { red } { b } lock $$$ ) $$$ \rightarrow $$$ ( $$$ code\color { red } { fo } rces $$$ $$$ code\color { red } { bl } <unknown> $$$ ) $$$ \rightarrow $$$ ( $$$ code\color { red } { } <unknown> $$$ $$$ code\color { red } { blo } <unknown> $$$ ) $$$ \rightarrow $$$ ( $$$ code\color { red } { } c\color { red } { e } s $$$ $$$ code\color { red } { blo } c\color { red } { k } s $$$ ) $$$ \rightarrow $$$ ( $$$ code\color { red } { } c\color { red } { e } s $$$ $$$ code\color { red } { blo } c\color { red } { k } s $$$ ) $$$ \rightarrow $$$ ( $$$ <unknown> { red } { } c\color { red } { e } s $$$ $$$ <unknown> { red } { lo } c\color { red } { k } s $$$ ) second example input : ( $$$ cool $$$ $$$ club $$$ ) $$$ \rightarrow $$$ ( $$$ cuol $$$ $$$ <unknown> $$$ ) $$$ \rightarrow $$$ ( $$$ cuol $$$ $$$ cbol $$$ ) $$$ \rightarrow $$$ ( $$$ c\color { red } { u } ol $$$ $$$ c\color { red } { b } ol $$$ ) $$$ \rightarrow $$$ ( $$$ c\color { red } { u } ol $$$ $$$ c\color { red } { b } ol $$$ ) $$$ \rightarrow $$$ ( $$$ cuol $$$ $$$ cbol $$$ ),"['data structures', 'implementation']",1600.0
1841/F,"monocarp play a strategic computer game develop a city city inhabit creatures four different race — humans elves orcs dwarves inhabitant city a happiness value integer depend many creatures different race inhabit city specifically happiness inhabitant $$$ 0 $$$ default ; increase $$$ 1 $$$ creature race decrease $$$ 1 $$$ creature a hostile race humans hostile orcs ( vice versa ) elves hostile dwarves ( vice versa ) begin game monocarp 's city inhabit anyone game $$$ n $$$ group creatures come city wish settle $$$ i $$$ -th group consist $$$ a_i $$$ humans $$$ b_i $$$ orcs $$$ c_i $$$ elves $$$ d_i $$$ dwarves time monocarp either accept entire group creatures city reject entire group game calculate monocarp 's score accord follow formula : $$$ m + k $$$ $$$ m $$$ number inhabitants city $$$ k $$$ sum happiness value creatures city help monocarp earn maximum possible number point end game ! first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 3 \cdot 10^ { 5 } $$$ ) — number group creatures come monocarp 's city $$$ n $$$ line follow $$$ i $$$ -th contain four integers $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ $$$ d_i $$$ ( $$$ 0 \leq a_i b_i c_i d_i \leq 10^ { 9 } $$$ ) — number humans orcs elves dwarves ( respectively ) $$$ i $$$ -th group output a single number — maximum score monocarp end game answer consider correct absolute relative error exceed $$$ 10^ { -9 } $$$ , answer $$$ a $$$ jury 's answer $$$ b $$$ solution accept $$$ \frac { |a - b| } { \max ( 1 |b| ) } \le 10^ { -9 } $$$ note correct answer always integer sometimes n't fit $$$ 64 $$$ -bit integer type allow print a non - integer number first example best course action accept group second example best course action accept group $$$ 2 $$$ $$$ 3 $$$ decline group $$$ 1 $$$ $$$ 4 $$$","['geometry', 'sortings', 'two pointers']",2700.0
1842/D,"tenzing $$$ n $$$ animal friends number $$$ 1 $$$ $$$ n $$$ one day tenzing want play animal friends , tenzing host several game one game choose a set $$$ s $$$ a subset $$$ \ { 1,2,3 ... n\ } $$$ choose integer $$$ t $$$ , play game animals $$$ s $$$ $$$ t $$$ minutes restrictions : tenzing want know maximum total time play animal friends please find maximum total time tenzing play animal friends a way organize game achieve maximum total time report play animal friends infinite amount time also tenzing want host many game host $$$ n^2 $$$ game first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 100 $$$ $$$ 0 \leq m \leq \frac { n ( n-1 ) } { 2 } $$$ ) — number animal friends number special restrictions $$$ i $$$ -th follow $$$ m $$$ line input contain three integers $$$ u_i $$$ $$$ v_i $$$ $$$ y_i $$$ ( $$$ 1\leq u_i < v_i\leq n $$$ $$$ 0\leq y_i\leq 1000000000 $$$ ) — describe $$$ i $$$ -th special restriction guarantee $$$ 1 \leq i < j \leq m $$$ $$$ ( u_i v_i ) \neq ( u_j v_j ) $$$ tenzing play animal friends infinite amount time output ` ` inf '' ( output without quote ) otherwise first line output total time $$$ t $$$ ( $$$ 0 \leq t \leq 10^ { 18 } $$$ ) number game $$$ k $$$ ( $$$ 0 \leq k \leq n^2 $$$ ) follow $$$ k $$$ line output output a binary string $$$ s $$$ length $$$ n $$$ integer $$$ t $$$ ( $$$ 0 \leq t \leq 10^ { 18 } $$$ ) — represent set $$$ s $$$ number minutes game play $$$ s_i=\texttt { 1 } $$$ $$$ i \in s $$$ otherwise $$$ s_i=\texttt { 0 } $$$ $$$ i \notin s $$$ constraints problem prove tenzing play friends a finite amount time play $$$ 10^ { 18 } $$$ minutes first test case : tenzing host another game friends $$$ \ { 1,2\ } $$$ $$$ 1 $$$ minute time exactly one friends $$$ 2 $$$ $$$ 3 $$$ tenzing become $$$ 2 $$$ minutes satisfy $$$ 3 $$$ -rd special restriction second test case special restrictions tenzing host a game friend $$$ \ { 1\ } $$$ infinite amount time","['graphs', 'greedy']",1900.0
1842/F,"tenzing undirected tree $$$ n $$$ vertices define value a tree black white vertices follow way value edge absolute difference number black nod two components tree delete edge value tree sum value edge $$$ k $$$ $$$ 0 \leq k \leq n $$$ tenzing want know maximum value tree $$$ k $$$ vertices paint black $$$ n - k $$$ vertices paint white first line input contain a single integer $$$ n $$$ ( $$$ 1\leq n\leq 5000 $$$ ) — number vertices follow $$$ n-1 $$$ line input contain $$$ 2 $$$ integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n u_i \neq v_i $$$ ) — indicate edge vertices $$$ u_i $$$ $$$ v_i $$$ guarantee give edge form a tree output $$$ n+1 $$$ number $$$ i $$$ -th number answer $$$ k = i-1 $$$ consider first example $$$ k=2 $$$ tenzing paint vertices $$$ 1 $$$ $$$ 2 $$$ black value edge $$$ ( 1,2 ) $$$ 0 value edge equal $$$ 2 $$$ value tree $$$ 4 $$$","['dfs and similar', 'greedy', 'shortest paths', 'sortings', 'trees']",2500.0
1843/B,"today alex bring array $$$ a_1 a_2 \dots a_n $$$ length $$$ n $$$ apply many operations want ( include zero operations ) change array elements $$$ 1 $$$ operation alex choose $$$ l $$$ $$$ r $$$ $$$ 1 \leq l \leq r \leq n $$$ multiply elements array $$$ l $$$ $$$ r $$$ inclusive $$$ -1 $$$ word alex replace subarray $$$ [ a_l a _ { l + 1 } \dots a_r ] $$$ $$$ [ <unknown> -a _ { l + 1 } \dots <unknown> ] $$$ $$$ 1 $$$ operation example let $$$ n = 5 $$$ array $$$ [ 1 -2 0 3 -1 ] $$$ $$$ l = 2 $$$ $$$ r = 4 $$$ operation array $$$ [ 1 2 0 -3 -1 ] $$$ alex late school help find maximum possible sum number array obtain make number operations well minimum number operations must do first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case descriptions test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — length array second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ -1000000000 \leq a_i \leq 1000000000 $$$ ) — elements array guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output two space - separated number : maximum possible sum number array minimum number operations get sum pay attention answer may fit a standard integer type forget use 64 - bit integer type , test case one possible shortest sequence operations provide among many others length lead maximum sum elements first test case alex make operations : $$$ ( 1 4 ) $$$ $$$ ( 2 2 ) $$$ $$$ ( 6 6 ) $$$ second test case get largest sum need make operations : $$$ ( 1 8 ) $$$ $$$ ( 5 6 ) $$$ fourth test case necessary make one operation : $$$ ( 2 3 ) $$$","['greedy', 'math', 'two pointers']",800.0
1843/C,"vanya really like math one day solve another math problem come interest tree tree build follow initially tree one vertex number $$$ 1 $$$ — root tree , vanya add two children assign consecutive number — $$$ 2 $$$ $$$ 3 $$$ respectively , add children vertices increase order number start $$$ 2 $$$ assign children minimum unused indices a result vanya infinite tree root vertex $$$ 1 $$$ vertex exactly two children vertex number arrange sequentially layer vanya wonder sum vertex number path vertex number $$$ 1 $$$ vertex number $$$ n $$$ a tree equal since vanya n't like count ask help find sum first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow $$$ t $$$ line — description test case line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 10^ { 16 } $$$ ) — number vertex vanya want count sum vertex number path root vertex test case print one integer — desire sum first test case example path root vertex $$$ 3 $$$ two vertices $$$ 1 $$$ $$$ 3 $$$ sum equal $$$ 4 $$$ second test case example path root vertex number $$$ 10 $$$ vertices $$$ 1 $$$ $$$ 2 $$$ $$$ 5 $$$ $$$ 10 $$$ sum number equal $$$ 1 + 2 + 5 + 10 = 18 $$$","['bitmasks', 'combinatorics', 'math', 'trees']",800.0
1843/E,give array $$$ a $$$ consist $$$ n $$$ zero also give a set $$$ m $$$ necessarily different segment segment define two number $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) represent a subarray $$$ a _ { l_i } a _ { l_i+1 } \dots a _ { r_i } $$$ array $$$ a $$$ let 's call segment $$$ l_i r_i $$$ beautiful number ones segment strictly greater number zero example $$$ a = [ 1 0 1 0 1 ] $$$ segment $$$ [ 1 5 ] $$$ beautiful ( number ones $$$ 3 $$$ number zero $$$ 2 $$$ ) segment $$$ [ 3 4 ] $$$ beautiful ( number ones $$$ 1 $$$ number zero $$$ 1 $$$ ) also $$$ q $$$ change change give number $$$ 1 \le x \le n $$$ mean must assign element $$$ a_x $$$ value $$$ 1 $$$ find first change least one $$$ m $$$ give segment become beautiful report none beautiful process $$$ q $$$ change first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le m \le n \le 100000 $$$ ) — size array $$$ a $$$ number segment respectively $$$ m $$$ line consist two number $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) — the boundaries segment next line contain integer $$$ q $$$ ( $$$ 1 \le q \le n $$$ ) — number change follow $$$ q $$$ line contain a single integer $$$ x $$$ ( $$$ 1 \le x \le n $$$ ) — index array element need set $$$ 1 $$$ guarantee index query distinct guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output one integer — minimum change number least one segment beautiful $$$ -1 $$$ none segment beautiful first case first 2 change wo n't beautiful segment third one a segment $$$ [ 1 ; 5 ] $$$ 3 ones 2 zero answer 3 . second case wo n't beautiful segment,"['binary search', 'brute force', 'data structures', 'two pointers']",1600.0
1845/A,"give integer $$$ n $$$ want obtain unlimited supply every integer $$$ 1 $$$ $$$ k $$$ except integer $$$ x $$$ ( integer $$$ x $$$ ) allow take arbitrary amount integers ( possibly zero ) make sum take integers equal $$$ n $$$ ? multiple answer print first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number testcases line testcase contain three integers $$$ n k $$$ $$$ x $$$ ( $$$ 1 \le x \le k \le n \le 100 $$$ ) test case first line print ` ` yes '' ` ` '' — whether take arbitrary amount integer $$$ 1 $$$ $$$ k $$$ except integer $$$ x $$$ sum equal $$$ n $$$ , second line contain a single integer $$$ m $$$ — total amount take integers third line contain $$$ m $$$ integers — $$$ 1 $$$ $$$ k $$$ equal $$$ x $$$ sum $$$ n $$$ multiple answer print another possible answer first testcase $$$ [ 3 3 3 1 ] $$$ note n't minimize amount take integers also exist answer second testcase unlimited supply integer $$$ 2 $$$ way get sum $$$ 5 $$$ use fifth testcase integers available ca n't get positive sum","['implementation', 'math', 'number theory']",800.0
189/A,polycarpus a ribbon length n. want cut ribbon a way fulfil follow two condition : help polycarpus find number ribbon piece require cut first line contain four space - separated integers n a b c ( 1 ≤ n a b c ≤ 4000 ) — length original ribbon acceptable lengths ribbon piece cut correspondingly number a b c coincide print a single number — maximum possible number ribbon piece guarantee least one correct ribbon cut exist first example polycarpus cut ribbon way : first piece length 2 second piece length 3 . second example polycarpus cut ribbon way : first piece length 5 second piece length 2,"['brute force', 'dp']",1300.0
189/B,two positive integers w h. task count number rhombi follow properties : count number rhombi let us remind a rhombus a quadrilateral whose four side length first line contain two integers w h ( 1 ≤ w h ≤ 4000 ) — rectangle 's size print a single number — number seek rhombi please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first example exist one rhombus vertices locate point ( 1 0 ) ( 2 1 ) ( 1 2 ) ( 0 1 ),"['brute force', 'math']",1300.0
190/E,berland manage repel <unknown> ' attack start counter attack flatland n cities number 1 n pair connect bidirectional roads <unknown> map show roads cities fact road pair cities ( know whether a clever spy - proof strategy save ink ) word two cities connect a road a flatland map fact road opposite situation also true : two cities connect a road a flatland map fact a road berlanders get hold a flatland map vasya corporal commission general <unknown> find group flatland cities group cities get city one move along actual roads also cities different group unreachable move along actual roads indeed destroy group one one much easier surround flatland ! help corporal complete task finally become a sergeant ! n't forget a flatland map show a road cities fact road first line contain two space - separated integers n m ( 1 ≤ n ≤ 5·105 0 ≤ m ≤ 106 ) — number cities number roads mark flatland map correspondingly next m line contain descriptions cities map i - th line contain two integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) — number cities connect i - th road flatland map guarantee pair cities occur input first line print number k — number group cities flatland group get city one flatland roads time cities different group unreachable flatland roads follow k line first print ti ( 1 ≤ ti ≤ n ) — number vertexes i - th group print space - separated number cities i - th group order print group order print number group matter total sum ti k group must equal n. first sample roads pair cities 1 - 4 2 - 3 . second sample road cities 1 2 still get one city one city number 3,"['data structures', 'dsu', 'graphs', 'sortings']",2100.0
191/C,say berland exactly two problems fool roads besides berland n cities populate fool connect roads berland roads bidirectional many fool berland pair cities a path ( else fool would get upset ) also pair cities one simple path ( else fool would get lose ) end berland 's special feature country fool sometimes visit thus spoil roads fool n't smart always use simple paths a simple path path go every berland city berland government know paths fool use help government count road many distinct fool go note fool ' paths give input first line contain a single integer n ( 2 ≤ n ≤ 105 ) — number cities next n - 1 line contain two space - separated integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) mean a road connect cities ui vi next line contain integer k ( 0 ≤ k ≤ 105 ) — number pair fool visit next k line contain two space - separated number i - th line ( i > 0 ) contain number ai bi ( 1 ≤ ai bi ≤ n ) mean fool number 2i - 1 live city ai visit fool number 2i live city bi give pair describe simple paths every pair cities one simple path print n - 1 integer integers separate space i - th number equal number fool go i - th road roads number start one order occur input first sample fool number one go first third road fool number 3 go second first fourth ones second sample fool number 1 3 5 go first road fool number 5 go second road third road go fool number 3 fourth one go fool number 1,"['data structures', 'dfs and similar', 'trees']",1900.0
196/A,' ve get string s consist lowercase english letter find lexicographically maximum subsequence 'll call a non - empty string s [ p1p2 ... pk ] = sp1sp2 ... spk ( 1 ≤ p1 < p2 < ... < pk ≤ |s| ) a subsequence string s = s1s2 ... s|s| string x = x1x2 ... x|x| lexicographically larger string y = y1y2 ... y|y| either |x| > |y| x1 = y1 x2 = y2 ... x|y| = y|y| exist number r ( r < |x| r < |y| ) x1 = y1 x2 = y2 ... xr = yr xr + 1 > yr + 1 . character line compare like ascii cod single line contain a non - empty string s consist lowercase english letter string 's length n't exceed 105 . print lexicographically maximum subsequence string s. let 's look sample see seek subsequences look like ( mark uppercase bold letter ) first sample : <unknown> second sample : <unknown>,"['greedy', 'strings']",1100.0
2/A,"winner card game popular berland ` ` <unknown> '' determine accord follow rule end game one player maximum number point winner situation become difficult number players one round a player gain lose a particular number point course game number point register line ` ` name score '' name a player 's name score number point gain round integer number score negative mean player lose round , two players maximum number point ( say equal m ) end game win one score least m point first initially player 0 point 's guarantee end game least one player a positive number point first line contain integer number n ( 1 ≤ n ≤ 1000 ) n number round play follow n line contain information round ` ` name score '' format chronological order name a string lower - case latin letter length 1 32 score integer number -1000 1000 inclusive print name winner",['implementation'],1500.0
2/B,a square matrix n × n consist non - negative integer number find a way moreover multiply together number along way result least ` ` round '' word end least possible number zero first line contain integer number n ( 2 ≤ n ≤ 1000 ) n size matrix follow n line contain matrix elements ( non - negative integer number exceed 109 ) first line print least number trail zero second line print correspondent way,"['dp', 'math']",2000.0
200/D,recently valery come across entirely new program language language attract template function procedures let us remind templates tool a language design encode generic algorithms without reference parameters ( e.g. data type buffer size default value ) valery decide examine template procedures language detail description a template procedure consist procedure name list parameter type generic type t parameters use parameters template procedures a procedure call consist a procedure name a list variable parameters let 's call a procedure suitable call follow condition fulfil : give a description set template procedures also give a list variables use program well direct procedure call use describe variables call need count number procedures suitable call first line contain a single integer n ( 1 ≤ n ≤ 1000 ) — number template procedures next n line contain description procedures specify follow format : '' void procedurename ( <unknown> <unknown> ... <unknown> ) '' ( 1 ≤ t ≤ 5 ) void keyword procedurename procedure name type_i type next parameter type language parameters ` ` int '' ` ` string '' ` ` double '' keyword ` ` t '' denote generic type next line contain a single integer m ( 1 ≤ m ≤ 1000 ) — number use variables next m line specify description variables follow format : '' type variablename '' type type variable take value ` ` int '' ` ` string '' ` ` double '' variablename — name variable next line contain a single integer k ( 1 ≤ k ≤ 1000 ) — number procedure call next k line specify procedure call follow format : '' procedurename ( <unknown> <unknown> ... <unknown> ) '' ( 1 ≤ t ≤ 5 ) procedurename name procedure <unknown> name a variable line describe variables template procedures call may contain space begin line end line bracket commas space may keyword void length input line exceed 100 character name variables procedures non - empty string lowercase english letter number lengths 10 character note condition name specify variables use procedure call name variables distinct two procedures two procedures identical name identical order set type parameters k line print a single number i - th number stand number suitable template procedures i - th call,"['binary search', 'brute force', 'implementation']",1800.0
202/A,problem 's actual name ` ` lexicographically largest palindromic subsequence '' long fit page <unknown> give string s consist lowercase english letter find lexicographically largest palindromic subsequence 'll call a non - empty string s [ p1p2 ... pk ] = sp1sp2 ... spk ( 1 ≤ p1 < p2 < ... < pk ≤ |s| ) a subsequence string s = s1s2 ... s|s| |s| length string s. example string ` ` abcb '' ` ` b '' ` ` abacaba '' subsequences string ` ` abacaba '' string x = x1x2 ... x|x| lexicographically larger string y = y1y2 ... y|y| either |x| > |y| x1 = y1 x2 = y2 ... x|y| = y|y| exist number r ( r < |x| r < |y| ) x1 = y1 x2 = y2 ... xr = yr xr + 1 > yr + 1 . character string compare accord ascii cod example string ` ` ranger '' lexicographically larger string ` ` racecar '' string ` ` poster '' lexicographically larger string ` ` post '' string s = s1s2 ... s|s| a palindrome match string rev ( s ) = <unknown> - 1 ... s1 word a string a palindrome read way leave right right leave example palindromic string ` ` racecar '' ` ` refer '' ` ` z '' input line contain a non - empty string s consist lowercase english letter length exceed 10 . print lexicographically largest palindromic subsequence string s. among distinct subsequences string ` ` radar '' follow ones palindromes : ` ` a '' ` ` d '' ` ` r '' ` ` aa '' ` ` rr '' ` ` ada '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` radar '' lexicographically largest ` ` rr '',"['binary search', 'bitmasks', 'brute force', 'greedy', 'implementation', 'strings']",800.0
207/A3,smart beaver abbyy surprise us ! develop a new calculate device call ` ` beaver 's calculator 1.0 '' peculiar plan use a variety scientific problems test smart beaver invite n scientists number 1 n. i - th scientist bring ki calculate problems device develop smart beaver abbyy problems i - th scientist number 1 ki must calculate sequentially describe order since calculate problem heavily depend result calculate previous ones problem n scientists describe one integer ai j i ( 1 ≤ i ≤ n ) number scientist j ( 1 ≤ j ≤ ki ) number problem ai j number resource units calculate device need solve problem calculate device develop smart beaver pretty unusual solve problems sequentially one another problem solve next one consider calculate device allocate free resources expensive operation calculate device free resources work much slower allocate therefore desirable next problem calculate device require less resources previous one give information problems scientists offer test need arrange problems order number adjacent ` ` bad '' pair problems list minimum possible call two consecutive problems list a ` ` bad pair '' problem perform first require resources one go forget problems scientist must solve a fix order first line contain integer n — number scientists <unknown> size input next n line contain five integers ki ai 1 xi yi mi ( 0 ≤ ai 1 < mi ≤ 109 1 ≤ xi yi ≤ 109 ) — number problems i - th scientist resources first problem require three parameters generate subsequent value ai j. j 2 ki inclusive calculate value ai j formula ai j = ( ai j - 1 * xi + yi ) mod mi a mod b operation take remainder division number a number b. get full point first group test sufficient solve problem n = 2 1 ≤ ki ≤ 2000 . get full point second group test sufficient solve problem n = 2 1 ≤ ki ≤ 200000 . get full point third group test sufficient solve problem 1 ≤ n ≤ 5000 1 ≤ ki ≤ 5000 . first line print a single number — number ` ` bad '' pair optimal order total number problems exceed 200000 also print line — optimal order problems line print two integers separate a single space — require number resources problem number scientist offer problem respectively scientists number 1 n order input first sample n = 2 k1 = 2 a1 1 = 1 a1 2 = 2 k2 = 2 a2 1 = 3 a2 2 = 4 . ' ve get two scientists two calculate problems problems first scientist require 1 2 resource units problems second one require 3 4 resource units let 's list possible variants calculate order ( problem characterize number resource units require ) : ( 1 2 3 4 ) ( 1 3 2 4 ) ( 3 1 2 4 ) ( 1 3 4 2 ) ( 3 4 1 2 ) ( 3 1 4 2 ) sequence problems ( 1 3 2 4 ) one ` ` bad '' pair ( 3 2 ) ( 3 1 4 2 ) two ` ` bad '' pair ( 3 1 4 2 ) ( 1 2 3 4 ) ` ` bad '' pair,['greedy'],2000.0
212/B,'ll call string s [ a b ] = sasa + 1 ... sb ( 1 ≤ a ≤ b ≤ |s| ) a substring string s = s1s2 ... s|s| |s| length string s. trace a non - empty string t a set character string consist example trace string ` ` aab '' equal { ' a ' ' b ' } let 's consider arbitrary string s set substrings trace equal c. denote number substrings set maximal inclusion r ( c s ) substring s [ a b ] length n = b - a + 1 belong set call maximal inclusion substring s [ x y ] set length greater n 1 ≤ x ≤ a ≤ b ≤ y ≤ |s| two substrings string s consider different even equal locate different position s. polycarpus get a challenge practical task a stringology exam must follow : give string s non - empty set character c1 c2 ... cm find r ( ci s ) set ci help polycarpus solve problem really n't want expel university go army ! first line contain a non - empty string s ( 1 ≤ |s| ≤ 106 ) second line contain a single integer m ( 1 ≤ m ≤ 104 ) next m line contain descriptions set ci i - th line contain string ci trace equal ci guarantee character string ci different note ci necessarily different give string consist lowercase english letter print m integers — i - th integer must equal r ( ci s ),"['bitmasks', 'implementation']",2300.0
212/C,a <unknown> moment : n cowboys stand a circle one point colt a neighbor cowboy point colt person follow precede clockwise direction human life <unknown> like real western picture change second ! every second cowboys analyse situation a pair cowboys realize aim turn around a second pair neighbor cowboys aim turn around action happen instantaneously simultaneously a second 'll use character ` ` a '' denote a cowboy aim neighbour clockwise direction character ` ` b '' a cowboy aim neighbour counter clockwise direction a string letter ` ` a '' ` ` b '' denote circle cowboys record make first a clockwise direction example a circle look like ` ` abbbabbba '' a second transform ` ` <unknown> '' a circle look like ` ` babba '' transform ` ` <unknown> '' a second pass cowboys ' position describe string s. task determine number possible state lead s a second two state consider distinct a cowboy aim clockwise neighbor one state counter clockwise neighbor state input data consist a single string s. length 3 100 character inclusive line s consist letter ` ` a '' ` ` b '' print seek number state first sample possible initial state ` ` <unknown> '' ` ` abbbabbba '' second sample possible initial state ` ` aabbb '' ` ` babba '',"['combinatorics', 'dp', 'math']",2100.0
213/C,furik rubik take part a relay race race set a large square side n meter give square split n × n cells ( represent unit square ) cell number begin race furik stand a cell coordinate ( 1 1 ) rubik stand a cell coordinate ( n n ) right start furik run towards rubik besides furik stand a cell coordinate ( i j ) move cell ( i + 1 j ) ( i j + 1 ) furik reach rubik rubik start run cell coordinate ( n n ) cell coordinate ( 1 1 ) rubik stand cell ( i j ) move cell ( i - 1 j ) ( i j - 1 ) neither furik rubik allow go beyond boundaries field ; a player go beyond boundaries disqualify win race furik rubik must earn many point possible number point sum number cells furik rubik visit cell count sum print maximum number point furik rubik earn relay race first line contain a single integer ( 1 ≤ n ≤ 300 ) next n line contain n integers : j - th number i - th line ai j ( - 1000 ≤ ai j ≤ 1000 ) number write cell coordinate ( i j ) a single line print a single number — answer problem comment second sample : profitable path furik : ( 1 1 ) ( 1 2 ) ( 2 2 ) rubik : ( 2 2 ) ( 2 1 ) ( 1 1 ) comment third sample : optimal path furik : ( 1 1 ) ( 1 2 ) ( 1 3 ) ( 2 3 ) ( 3 3 ) rubik : ( 3 3 ) ( 3 2 ) ( 2 2 ) ( 2 1 ) ( 1 1 ) figure sample :,['dp'],2000.0
215/E,a non - empty string s call binary consist character ` ` 0 '' ` ` 1 '' let 's number character binary string s 1 string 's length let 's denote i - th character string s si binary string s length n periodical integer 1 ≤ k < n : example binary string ` ` 101010 '' ` ` 11 '' periodical ` ` 10 '' ` ` 10010 '' a positive integer x periodical binary representation ( without lead zero ) a periodic string task calculate many periodic number interval l r ( end include ) single input line contain two integers l r ( 1 ≤ l ≤ r ≤ 1018 ) number separate a space please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print a single integer show many periodic number interval l r ( end include ) first sample periodic number 3 7 10 . second sample periodic number 31 36,"['combinatorics', 'dp', 'number theory']",2100.0
216/A,several age ago berland a kingdom king berland adore math 's first visit one many palaces first pay attention floor one hall floor tile hexagonal tile hall also turn hexagonal shape king walk along perimeter hall conclude six side a b c a b c adjacent tile correspondingly better visualize situation look picture show a similar hexagon a = 2 b = 3 c = 4 . accord legend king berland obtain value a b c almost immediately calculate total number tile hall floor ? first line contain three integers : a b c ( 2 ≤ a b c ≤ 1000 ) print a single number — total number tile hall floor,"['implementation', 'math']",1200.0
216/B,one day n students come stadium want play football need split team team must equal number people know group people archenemies student two archenemies besides student a archenemy student b student b archenemy student a. students want split two archenemies one team split require manner impossible students sit bench determine minimum number students send bench order form two team describe manner begin game last first line contain two integers n m ( 2 ≤ n ≤ 100 1 ≤ m ≤ 100 ) — number students number pair archenemies correspondingly next m line describe enmity students enmity describe two number ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) — index students enemies enmity occur list exactly guarantee student two archenemies consider students index manner distinct integers 1 n. print a single integer — minimum number students send bench order start game,"['dfs and similar', 'implementation']",1700.0
218/B,lolek bolek travel abroad plane local airport a special ` ` choose plane '' offer offer 's condition follow : ticket office airport already a queue n passengers front lolek bolek stand queue yet already wonder maximum minimum number zlotys airport administration earn n passengers buy ticket accord condition offer ? passengers buy ticket turn first person queue go first go second one n - th person first line contain two integers n m ( 1 ≤ n m ≤ 1000 ) — number passengers queue number plan airport correspondingly next line contain m integers a1 a2 ... ( 1 ≤ ai ≤ 1000 ) — ai stand number empty seat i - th plane ticket office start sell ticket number line separate a space guarantee least n empty seat total print two integers — maximum minimum number zlotys airport administration earn correspondingly first test sample number passengers equal number empty seat regardless way plan choose administration earn sum second sample sum maximize 1 - st person queue buy a ticket 1 - st plane 2 - nd person — 2 - nd plane 3 - rd person — 3 - rd plane 4 - th person — 1 - st plane sum minimize 1 - st person queue buy a ticket 1 - st plane 2 - nd person — 1 - st plane 3 - rd person — 2 - nd plane 4 - th person — 2 - nd plane,['implementation'],1100.0
219/A,a string call a k - string represent k concatenate copy string example string ` ` <unknown> '' time a 1 - string a 2 - string a 4 - string a 3 - string a 5 - string a 6 - string obviously string a 1 - string give a string s consist lowercase english letter a positive integer k. task reorder letter string s a way result string a k - string first input line contain integer k ( 1 ≤ k ≤ 1000 ) second line contain s character s lowercase english letter string length s satisfy inequality 1 ≤ |s| ≤ 1000 |s| length string s. rearrange letter string s a way result a k - string print result a single output line multiple solutions print solution n't exist print ` ` -1 '' ( without quote ),"['implementation', 'strings']",1000.0
222/A,"one day shooshuns find a sequence n integers write a blackboard shooshuns perform one operation operation consist two step : shooshuns wonder many operations number board whether number ever first line contain two space - separated integers n k ( 1 ≤ k ≤ n ≤ 105 ) second line contain n space - separated integers : a1 a2 ... ( 1 ≤ ai ≤ 105 ) — sequence shooshuns find print minimum number operations require number blackboard become impossible achieve print -1 . first test case first operation blackboard sequence [ 1 1 1 ] , one operation enough make number thus answer equal one second test case sequence never consist number always contain least two distinct number 3 1 . thus answer equal -1","['brute force', 'implementation']",1200.0
222/C,"confuse opponents galactic empire represent fraction unusual format fraction represent two set integers product number first set give fraction numerator product number second set give fraction denominator however turn program work fraction representations n't complete lack support operation reduce fraction implement operation empire wo n't forget first input line contain two space - separated integers n m ( 1 ≤ n m ≤ 105 ) show many number first set ( numerator ) second set ( denominator ) contain correspondingly second line contain n space - separated integers : a1 a2 ... ( 1 ≤ ai ≤ 107 ) — number multiply produce numerator third line contain m space - separated integers : b1 b2 ... bm ( 1 ≤ bi ≤ 107 ) — number multiply produce denominator print answer problem form similar form input data number value set print nout mout must satisfy inequality 1 ≤ nout mout ≤ 105 actual value set aout i bout i must satisfy inequality 1 ≤ aout i bout i ≤ 107 . separate value line space print fraction must reduce , must n't integer x ( x > 1 ) numerator denominator print fraction divisible x. several match answer print first test sample numerator equal 1000 denominator equal 500 . reduce fraction <unknown> greatest common divisor numerator denominator ( 500 ) obtain fraction <unknown> second test sample numerator equal 2000 denominator equal 300 . reduce fraction <unknown> greatest common divisor numerator denominator ( 100 ) obtain fraction <unknown>","['implementation', 'math', 'number theory', 'sortings']",1800.0
223/C,' ve get array a consist n integers array elements index 1 n. let 's determine a two step operation like : task find array a exactly k describe operations apply first line contain two space - separated integers n k ( 1 ≤ n ≤ 2000 0 ≤ k ≤ 109 ) next line contain n space - separated integers a1 a2 ... — elements array a ( 0 ≤ ai ≤ 109 ) print n integers — elements array a operations apply print elements order increase index array a. separate print number space,"['combinatorics', 'math', 'number theory']",1900.0
226/C,less 60 years leave till 900 - th birthday anniversary a famous italian mathematician <unknown> fibonacci course important anniversary need much preparations dima sure 'll great learn solve follow problem big day : 're give a set a consist number l l + 1 l + 2 ... r ; let 's consider k - element subsets ; subset let 's find largest common divisor fibonacci number index determine subset elements among find common divisors dima interest largest one dima ask remind fibonacci number elements a numeric sequence f1 = 1 f2 = 1 fn = fn - 1 + fn - 2 n ≥ 3 . dima half a century ahead solve give task two hours count residue divide seek largest common divisor m. first line contain four space - separated integers m l r k ( 1 ≤ m ≤ 109 ; 1 ≤ l < r ≤ 1012 ; 2 ≤ k ≤ r - l + 1 ) please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print a single integer — residue divide seek greatest common divisor m,"['data structures', 'implementation', 'math', 'number theory']",2400.0
226/D,harry potter a difficult homework give a rectangular table consist n × m cells cell table contain integer harry know use two spell : first spell change sign integers select row second — select column harry 's task make non - negative sum number row column use spell alone boy cope help young magician ! first line contain two integers n m ( 1 ≤ n m ≤ 100 ) — number row number columns next n line follow contain m integers : j - th integer i - th line ai j ( |ai j| ≤ 100 ) number i - th row j - th column table row table number 1 n. columns table number 1 m. first line print number a — number require applications first spell next print a space - separated integers — row number want apply a spell row number must distinct ! second line print number b — number require applications second spell next print b space - separated integers — column number want apply a spell column number must distinct ! several solutions allow print,['greedy'],2100.0
228/C,little vasya like paint fractals much like first boy cut a 2 × 2 - cell square square paper paint cells black boy call cut square a fractal pattern take a clean square sheet paper paint a fractal follow algorithm : follow step step 2 repeat draw a fractal boy make arbitrary positive number step algorithm need make least two step word step 2 algorithm must do least result picture ( square paint cells ) a fractal figure show draw a fractal ( boy make three step algorithm ) one even vasya get tire n't paint fractal take a sheet paper paint a n × m - cell field vasya paint cells black wonder many square field a fractal obtain describe equal square square consider equal fractal consist amount elementary divide cells elementary cell square correspond elementary cell fractal color first line contain two space - separated integers n m ( 2 ≤ n m ≤ 500 ) — number row columns field correspondingly next n line contain m character — description field paint vasya character ` ` . '' represent a white cell character ` ` * '' represent a black cell guarantee field description n't contain character ` ` . '' ` ` * '' a single line print a single integer — number square field square contain a draw fractal obtain describe answer first sample show picture fractals outline red blue green square answer second sample 0 . fractal equal give picture,['dp'],2000.0
229/B,"<unknown> apophis capture jack <unknown> 's team ! jack able escape time apophis 's ship already jump hyperspace jack know planet apophis land order save friends jack must repeatedly go stargates get planet overall galaxy n planets index number 1 n. jack planet index 1 apophis land planet index n. jack move pair planets stargates ( move directions ) ; transfer take a positive , perhaps different pair planets <unknown> number second jack begin journey time 0 . travellers arrive planet jack currently locate case jack wait exactly 1 second use stargate , time t another traveller arrive planet jack pass stargate time t + 1 unless travellers arrive time t + 1 planet know information travel time planets time jack would able use stargate particular planets determine minimum time get planet index n. first line contain two space - separated integers : n ( 2 ≤ n ≤ 105 ) number planets galaxy m ( 0 ≤ m ≤ 105 ) — number pair planets jack travel use stargates m line follow contain three integers : i - th line contain number planets ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) connect stargates integer transfer time ( second ) ci ( 1 ≤ ci ≤ 104 ) planets guarantee pair planets one stargate connection n line follow : i - th line contain integer ki ( 0 ≤ ki ≤ 105 ) denote number moments time travellers arrive planet index i. ki distinct space - separated integers tij ( 0 ≤ tij < 109 ) follow sort ascend order integer tij mean time tij ( second ) another traveller arrive planet i. guarantee sum ki exceed 105 . print a single number — least amount time jack need get planet 1 planet n. jack ca n't get planet n amount time print number -1 . first sample jack three ways go planet 1 . move planet 4 spend 8 second transfer planet 3 spend 3 second travellers arrive planet 3 time 3 4 travel planet 4 time 5 thus spend 8 second total jack move planet 2 — planet 4 spend a total 2 + 5 = 7 second second sample one ca n't get planet 1 planet 3 move stargates","['binary search', 'data structures', 'graphs', 'shortest paths']",1700.0
231/B,"vasya great magician <unknown> love kinds <unknown> wizardry one wave a magic wand turn object something else , know better magic universe magic number 's vasya adore math spend a lot time turn number ones morning n card integers line front integer less 1 greater l. vasya wave magic wand two rightmost card vanish line a new card magically appear place contain difference leave right number two vanish card vasya interest know would happen next wave magic wand table a single card leave suppose vasya originally follow card : 4 1 1 3 ( list leave right ) first wave line would : 4 1 -2 second one : 4 3 third one table would a single card number 1 . please note spite fact initially number card less 1 greater l number appear card anything restrictions impose even vasya tire want return everything back remember card morning remember n card contain integers 1 l magical action leave a single card contain number d. help vasya recover initial set card number single line contain three space - separated integers : n ( 2 ≤ n ≤ 100 ) — initial number card table d ( |d| ≤ 104 ) — number card leave table magical action l ( 1 ≤ l ≤ 100 ) — limit initial integers vasya mistake , n't exist a set meet requirements give statement print a single number -1 otherwise print seek set contain n integers 1 l. separate integers space print integers order write card leave right several suitable set number print",['greedy'],1500.0
232/C,john doe decide mathematical object must name invent doe graph doe graph a family undirected graph characterize a single non - negative number — order 'll denote a graph order k d ( k ) 'll denote number vertices graph d ( k ) |d ( k ) | let 's define doe graph follow : john think doe graph great exist a polynomial algorithm search hamiltonian path however task answer query find shortest - length path vertices ai bi graph d ( n ) a path a pair vertices u v graph a sequence vertices x1 x2 ... xk ( k > 1 ) x1 = u xk = v i ( i < k ) vertices xi xi + 1 connect a graph edge length path x1 x2 ... xk number ( k - 1 ) first line contain two integers t n ( 1 ≤ t ≤ 105 ; 1 ≤ n ≤ 103 ) — number query order give graph i - th next t line contain two integers ai bi ( 1 ≤ ai bi ≤ 1016 ai ≠ bi ) — number two vertices i - th query guarantee ai bi ≤ |d ( n ) | please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier query print a single integer a single line — length shortest path vertices ai bi print answer query order query give input,"['divide and conquer', 'dp', 'graphs', 'shortest paths']",2600.0
234/C,scientists say a lot problems global warm cool earth indeed natural <unknown> strongly influence life planet hero vasya quite concern problems decide try a little experiment observe outside daily temperature change hang a <unknown> balcony every morning record temperature measure temperature last n days thus get a sequence number t1 t2 ... tn i - th number temperature i - th day vasya analyze temperature statistics cities come conclusion city environmental problems first temperature outside negative non - zero number days temperature positive non - zero number days formally must a positive integer k ( 1 ≤ k ≤ n - 1 ) t1 < 0 t2 < 0 ... tk < 0 tk + 1 > 0 tk + 2 > 0 ... tn > 0 . particular temperature never zero condition meet vasya decide city environmental problems get upset want upset vasya therefore want select multiple value temperature modify satisfy vasya 's condition need know least number temperature value need change first line contain a single integer n ( 2 ≤ n ≤ 105 ) — number days vasya measure temperature second line contain a sequence n integers t1 t2 ... tn ( |ti| ≤ 109 ) — sequence temperature value number ti separate single space print a single integer — answer give task note first sample : two ways change exactly one number sequence meet vasya 's condition either replace first number 1 negative number replace number -2 positive number,"['dp', 'implementation']",1300.0
234/H,"two deck card lie table front card deck lay face lay face want merge one deck card face 're go two stag first stage merge two deck a way relative order card deck n't change , two different card i j one deck card i lie card j merge card i must also card j. second stage perform deck result first stage stage execute operation turn operation one turn take a top card turn put back thus take card get turn order card reverse , card bottom turn top task make sure card lie face find order merge card first stage sequence turn operations second stage make card lie face number turn minimum first input line contain a single integer n — number card first deck ( 1 ≤ n ≤ 105 ) second input line contain n integers separate single space a1 a2 ... ( 0 ≤ ai ≤ 1 ) value ai equal 0 i - th card lie face 1 card lie face card give order topmost one bottommost one third input line contain integer m — number card second deck ( 1 ≤ m ≤ 105 ) fourth input line contain m integers separate single space b1 b2 ... bm ( 0 ≤ bi ≤ 1 ) value bi equal 0 i - th card lie face 1 card lie face card give order topmost bottommost first line print n + m space - separated integers — number card order lie first stage list card top bottom card first deck match index 1 n order top bottom card second deck match index increase n , number n + 1 n + m order top bottom second line print a single integer x — minimum number turn operations need make card deck lie face third line print x integers : c1 c2 ... cx ( 1 ≤ ci ≤ n + m ) represent number card take top deck perform a turn operation print operations order perform multiple optimal solutions print guarantee minimum number operations n't exceed 6·105",['greedy'],2000.0
235/C,days ago wjmzbmr learn answer query ` ` many time a string x occur a string s '' quickly <unknown> string s. want make harder want ask ` ` many consecutive substrings s cyclical isomorphic a give string x '' give string s n string xi string xi find many consecutive substrings s cyclical isomorphic xi two string call cyclical isomorphic one rotate one string get one ' rotate ' mean ' to take consecutive <unknown> ( maybe none ) begin a string put back end string order ' example string ` ` abcde '' rotate string ` ` <unknown> '' take character ` ` abc '' begin put end ` ` de '' first line contain a non - empty string s. length string s greater 106 character second line contain integer n ( 1 ≤ n ≤ 105 ) — number query n line follow : i - th line contain string xi — string i - th query total length xi less equal 106 character problem string consist lowercase english letter query xi print a single integer show many consecutive substrings s cyclical isomorphic xi print answer query order give input,"['data structures', 'strings']",2700.0
235/D,"computer science a method call ` ` divide conquer node '' solve hard problems paths a tree let 's <unknown> method work function : solve ( t ) ( t a tree ) : end t one node delete 's nothing , wjmzbmr mistakenly believe 's ok choose node ` ` line a '' 'll choose a node random make situation worse think a ` ` tree '' number edge nod ! procedure become like let 's define variable totalcost initially value totalcost equal 0 . solve ( t ) ( t a graph ) : 'll apply solve a connect graph n nod n edge think work quickly 's slow want know expectation totalcost procedure help ? first line contain integer n ( 3 ≤ n ≤ 3000 ) — number nod edge graph next n line contain two space - separated integers ai bi ( 0 ≤ ai bi ≤ n - 1 ) indicate edge nod ai bi consider graph nod number 0 ( n - 1 ) 's guarantee self - loops multiple edge graph 's guarantee graph connect print a single real number — expectation totalcost answer consider correct absolute relative error exceed 10 - 6 . consider second example matter choose first totalcost always 3 + 2 + 1 = 6",['graphs'],3000.0
235/E,let 's denote d ( n ) number divisors a positive integer n. give three integers a b c. task calculate follow sum : find sum modulo 1073741824 ( 230 ) first line contain three space - separated integers a b c ( 1 ≤ a b c ≤ 2000 ) print a single integer — require sum modulo 1073741824 ( 230 ) first example result 1 + 2 + 2 + 3 + 2 + 3 + 3 + 4 = 20,"['combinatorics', 'dp', 'implementation', 'math', 'number theory']",2600.0
237/D,' ve get a undirected tree s consist n nod task build optimal t - decomposition let 's define a t - decomposition follow let 's denote set nod s v. let 's consider undirected tree t whose nod non - empty subsets v 'll call xi tree t a t - decomposition s follow condition hold : obviously many distinct tree t t - decompositions tree s. example a t - decomposition a tree consist a single node equal set v. let 's define cardinality node xi number nod tree s contain node let 's choose node maximum cardinality t. let 's assume cardinality equal w. weight t - decomposition t value w. optimal t - decomposition one minimum weight task find optimal t - decomposition give tree s minimum number nod first line contain a single integer n ( 2 ≤ n ≤ 105 ) denote number nod tree s. follow n - 1 line contain two space - separated integers ai bi ( 1 ≤ ai bi ≤ n ; ai ≠ bi ) denote nod tree s indices ai bi connect edge consider nod tree s index 1 n. guarantee s a tree first line print a single integer m denote number nod require t - decomposition print m line contain descriptions t - decomposition nod i - th ( 1 ≤ i ≤ m ) print description node xi t - decomposition description node xi start integer ki represent number nod initial tree s contain node xi print ki distinct space - separated integers — number nod s contain xi arbitrary order print m - 1 line consist two integers pi qi ( 1 ≤ pi qi ≤ m ; pi ≠ qi ) pair integers pi qi mean edge nod <unknown> <unknown> t - decomposition print t - decomposition optimal t - decomposition give tree s minimum possible number nod among optimal t - decompositions multiple optimal t - decompositions minimum number nod print,"['dfs and similar', 'graphs', 'greedy', 'trees']",2000.0
239/B,a program language every program a non - empty sequence ` ` < ` ` ` ` > '' sign digits let 's explain interpreter program language work a program interpret use movement instruction pointer ( ip ) consist two part initially cp point leftmost character sequence dp point right repeat follow step first moment cp point somewhere outside sequence moment cp go outside sequence execution terminate 's obvious every program language terminate step a sequence s1 s2 ... sn ` ` < ` ` ` ` > '' digits answer q query query give l r ask many digit print run sequence sl sl + 1 ... sr independent program language first line input contain two integers n q ( 1 ≤ n q ≤ 100 ) — represent length sequence s number query second line contain s a sequence ` ` < ` ` ` ` > '' digits ( 0 .. 9 ) write leave right note character s separate space next q line contain two integers li ri ( 1 ≤ li ≤ ri ≤ n ) — i - th query query print 10 space separate integers : x0 x1 ... x9 xi equal number time interpreter print i run correspond program print answer query order give input,"['brute force', 'implementation']",1500.0
242/B,a coordinate line n segment i - th segment start position li end position ri denote a segment [ li ri ] suggest one define segment cover others word segment give set contain ones want test assumption find give set segment cover segment print number a segment n't exist print -1 . formally assume segment [ a b ] cover segment [ c d ] meet condition a ≤ c ≤ d ≤ b. first line contain integer n ( 1 ≤ n ≤ 105 ) — number segment next n line contain descriptions segment i - th line contain two space - separated integers li ri ( 1 ≤ li ≤ ri ≤ 109 ) — border i - th segment guarantee two segment coincide print a single integer — number segment cover segment set 's solution print -1 . segment number start 1 order appear input,"['implementation', 'sortings']",1100.0
245/A,"polycarpus a system administrator two servers strict guidance — a b. stay inform servers ' performance polycarpus execute command ` ` ping a '' ` ` ping b '' ping command send exactly ten packets server specify argument command execute a program result two integers x y ( x + y = 10 ; x y ≥ 0 ) number mean x packets successfully reach correspond server network y packets lose today polycarpus perform overall n ping command <unknown> server polycarpus want know whether server ` ` alive '' polycarpus think server ` ` alive '' least half packets send server reach successfully along network help polycarpus determine server whether ` ` alive '' give command result first line contain a single integer n ( 2 ≤ n ≤ 1000 ) — number command polycarpus fulfil follow n line contain three integers — description command i - th line contain three space - separated integers ti xi yi ( 1 ≤ ti ≤ 2 ; xi yi ≥ 0 ; xi + yi = 10 ) ti = 1 i - th command ` ` ping a '' otherwise i - th command ` ` ping b '' number xi yi represent result execute command , xi packets reach correspond server successfully yi packets lose guarantee input least one ` ` ping a '' command least one ` ` ping b '' command first line print string ` ` live '' ( without quote ) server a ` ` alive '' otherwise print ` ` dead '' ( without quote ) second line print state server b similar format consider first test case 10 packets send server a 5 reach therefore least half packets send server successfully reach network overall 10 packets send server b 6 reach therefore least half packets send server successfully reach network consider second test case overall 20 package send server a 10 reach therefore least half packets send server successfully reach network overall 10 packets send server b 0 reach therefore less half packets send server successfully reach network",['implementation'],800.0
246/E,polycarpus get hold a family tree find tree describe family relations n people number 1 n. every person tree one direct ancestor also person tree a name name necessarily unique call man a number a a 1 - ancestor man a number b man a number a a direct ancestor man a number b. call man a number a a k - ancestor ( k > 1 ) man a number b man a number b a 1 - ancestor man a number a a ( k - 1 ) -ancestor 1 - ancestor man a number b. tree family tie form cycle word n't a person direct indirect ancestor ( x - ancestor x x > 0 ) call a man a number a k - son man a number b man a number b a k - ancestor man a number a. polycarpus much interest many sons sons person take a piece paper write m pair number vi ki help learn pair vi ki number distinct name among name ki - sons man number vi first line input contain a single integer n ( 1 ≤ n ≤ 105 ) — number people tree next n line contain description people tree i - th line contain space - separated string si integer ri ( 0 ≤ ri ≤ n ) si name man a number i ri either number direct ancestor man a number i 0 man a number i direct ancestor next line contain a single integer m ( 1 ≤ m ≤ 105 ) — number polycarpus 's record next m line contain space - separated pair integers i - th line contain integers vi ki ( 1 ≤ vi ki ≤ n ) guarantee family relationships form cycle name people non - empty string consist 20 lowercase english letter print m whitespace - separated integers — answer polycarpus 's record print answer record order record occur input,"['binary search', 'data structures', 'dfs and similar', 'dp', 'sortings']",2400.0
249/D,even donkey would join shrek look star would sit a log <unknown> tea would watch starry sky sky hang roof right behind chimney shrek 's star right chimney donkey 's star leave days donkey would count star know exactly n. time want a challenge imagine a coordinate system : put origin coordinate intersection roof chimney direct ox axis leave along roof oy axis — along chimney ( see figure ) donkey imagine two ray emanate origin ax angle α1 α2 ox axis choose star lie strictly ray imagine ray emanate star angle α1 α2 ox axis choose another star lie strictly new ray repeat operation long still star choose ray emanate a star a result donkey get a chain star consecutively get star act give rule task find maximum number star m donkey 's chain contain note chain must necessarily start point origin ax n't take consideration count number m star chain first line contain integer n ( 1 ≤ n ≤ 105 ) — number star second line contain simple fraction represent relationships ` ` a / b c / d '' ( 0 ≤ a b c d ≤ 105 ; ; ; ) give number a b c d integers next n line contain pair integers xi yi ( 1 ≤ xi yi ≤ 105 ) — star ' coordinate guarantee star distinct coordinate a single line print number m — answer problem sample longest chain donkey build consist four star note donkey ca n't choose star lie ray imagine,"['data structures', 'dp', 'geometry', 'math', 'sortings']",2700.0
251/B,"little petya like permutations a lot recently mom present permutation q1 q2 ... qn length n. a permutation a length n a sequence integers a1 a2 ... ( 1 ≤ ai ≤ n ) integers distinct one thing petya like permutations : play little masha turn masha also a permutation length n. petya decide get permutation whatever cost may , devise a game follow rule : know k - th move board contain masha 's permutation s1 s2 ... sn besides know throughout game process masha 's permutation never occur board k - th move note game exactly k move , throughout game coin toss exactly k time task determine whether describe situation possible else state petya mistake somewhere see sample note a better understand first line contain two integers n k ( 1 ≤ n k ≤ 100 ) second line contain n space - separated integers q1 q2 ... qn ( 1 ≤ qi ≤ n ) — permutation petya 's get a present third line contain masha 's permutation s similar format guarantee give sequence q s correct permutations situation describe statement possible print ` ` yes '' ( without quote ) otherwise print ` ` '' ( without quote ) first sample masha 's permutation coincide permutation write board begin game consequently violate condition masha 's permutation never occur board k move perform second sample describe situation possible case toss a coin get tail third sample possible coin toss sequence : heads - tails - tails fourth sample possible coin toss sequence : heads - heads","['implementation', 'math']",1800.0
251/E,"little petya like tree a lot recently mother present a tree 2n nod petya immediately decide place tree a rectangular table consist 2 row n columns fulfill follow condition : petya wonder many ways place tree table call two placements distinct a tree node correspond distinct table cells two placements since large number scare petya print answer modulo 1000000007 ( 109 + 7 ) first line contain a single integer n ( 1 ≤ n ≤ 105 ) next ( 2n - 1 ) line contain two integers ai bi ( 1 ≤ ai bi ≤ 2n ; ai ≠ bi ) determine number vertices connect correspond edge consider tree vertexes number integers 1 2n guarantee graph give input a tree , a connect acyclic undirected graph print a single integer — require number ways place tree table modulo 1000000007 ( 109 + 7 ) note first sample ( 12 variants place tree table give ) :","['dfs and similar', 'dp', 'implementation', 'trees']",3000.0
253/E,let 's consider a network printer function like start work time 0 . second print one page a text moments time printer receive print task know a printer receive n task let 's number task consecutive integers 1 n. task number i characterise three integers : ti time task come si task 's volume ( page ) pi task 's priority priorities task distinct printer receive a task task go queue remain page task print printer choose a page print time either stop print page free receive a new task among task queue moment printer choose task highest priority next second print <unknown> page task assume a task go queue immediately 's a task arrive time t printer already choose print give full information task except one : n't know task 's priority however know time last page task finish print give information find unknown priority value determine moments time printer finish print task first line contain integer n ( 1 ≤ n ≤ 50000 ) next n line describe task i - th line contain three integers ti si pi separate single space ( 0 ≤ ti ≤ 109 1 ≤ si pi ≤ 109 ) exactly one task ( let 's assume number x ) number -1 write instead priority priorities different last line contain integer t — time printer finish print last page task x ( 1 ≤ t ≤ 1015 ) number ti necessarily distinct task input write arbitrary order first line print integer px — priority task number x ( 1 ≤ px ≤ 109 remember priorities distinct ) print n integers i - th represent moment time last page task number i finish print guarantee least one solution exist multiple solutions print let 's consider first test case let 's assume unknown priority equal 4 printer 's action second follow : end task number 1 print end 7 - th second require task 2 3 print end 8 - th 4 - th second correspondingly,"['binary search', 'data structures', 'implementation', 'sortings']",2200.0
254/B,"2013 writers berland state university prepare problems n olympiads assume olympiads number consecutive integers 1 n. olympiad know many members jury must involve preparation well time require prepare problems namely olympiad number i prepare pi people ti days preparation olympiad a continuous period time end exactly one day olympiad day olympiad juries prepare already work example olympiad hold december 9th preparation take 7 people 6 days seven members jury work problems olympiad december 3rd december <unknown> ( jury members wo n't work problems olympiad december 9th , start prepare problems olympiad ) olympiad hold november 3rd require 5 days train members jury work october <unknown> november 2nd order overload jury follow rule introduce : one member jury work day task different olympiads write a program determine minimum number people must part jury olympiads could prepare time first line contain integer n — number olympiads 2013 ( 1 ≤ n ≤ 100 ) follow n line contain four integers mi di pi ti — month day olympiad ( give without lead zero ) need number jury members time need prepare i - th olympiad ( 1 ≤ mi ≤ 12 di ≥ 1 1 ≤ pi ti ≤ 100 ) di n't exceed number days month mi olympiads give arbitrary order several olympiads take place one day use modern ( gregorian ) calendar solution note date give year 2013 . a leap year february 28 days please note preparation olympiad start 2012 year print a single number — minimum jury size","['brute force', 'implementation']",1500.0
254/D,rat breed hundreds hundreds basement store own vasily petrovich vasily petrovich may notice presence get habit sneak warehouse steal food vasily petrovich put anymore destroy rat basement since <unknown> outdated help rat poison poison <unknown> people well rat choose a radical way : blow two grenades basement ( ) problem present shop basement a rectangular table n × m cells cells occupy wall rest empty vasily watch rat find a certain time go sleep time sleep place want blow a grenade convenient time come plan basement mark cells sleep rat naturally cells occupy wall grenades blow a cell occupy a wall blast wave a grenade distribute follow assume grenade blast occur time 0 . initial time cell grenade blow get ' clear ' time t cell clear time t + 1 side - <unknown> cells occupy wall get clear ( could clear ) blast wave distribute exactly d second die immediately vasily petrovich wonder whether choose two cells blast grenades clear cells sleep rat write program find first line contain three integers n m d separate single space ( 4 ≤ n m ≤ 1000 1 ≤ d ≤ 8 ) next n line contain table represent basement plan row table consist m character character ` ` x '' mean correspond cell occupy wall character ` ` . '' represent a empty cell character ` ` r '' represent a empty cell sleep rat guarantee first last row well first last column consist character ` ` x '' plan least two empty cells least one cell sleep rat impossible blow cells sleep rat print a single integer -1 . otherwise print four space - separated integers r1 c1 r2 c2 mean one grenade go cell ( r1 c1 ) one — cell ( r2 c2 ) consider table row number top bottom 1 n table columns — leave right 1 m. r1 r2 represent row number c1 c2 represent column number table fit limit : 1 ≤ r1 r2 ≤ n 1 ≤ c1 c2 ≤ m. forbid blow a grenade twice cell blast wave grenades intersect possible one grenade blast destroy rat one destroy,"['brute force', 'dfs and similar', 'graphs', 'implementation', 'shortest paths']",2300.0
254/E,student vasya come study berland state university country live a dormitory a semester n days days parent send food morning i - th day receive ai kilograms food eat day next one ( food go bad become unfit consumption ) every day vasya eat v kilograms food know vasya 's parent allow starve always enough food vasya vasya m friends sometimes live let 's index friends 1 m. friend number j live vasya day lj day rj inclusive also j - th friend require fj kilograms food per day usually vasya 's friends eat canteen sometimes generous vasya feed every day vasya fee friends live day ( may fee nobody ) every time vasya feed friend give much food friend need day vasya 's popularity rat university increase one vasya fee friend multiple time one day addition know eat habit must regular always eat v kilograms food per day vasya want choose fee day semester make rat high possible originally vasya 's rat 0 a freshman first line contain two integers n v ( 1 ≤ n v ≤ 400 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 400 ) separate single space value ai mean morning i - th day ai kilograms food come food good eat day i and/or day i + 1 ( food go bad ) guarantee vasya n't fee anyone a way eat consume v kilograms food every day third line contain integer m ( 1 ≤ m ≤ 400 ) follow m line describe one vasya 's friend : j - th line contain three integers lj rj fj ( 1 ≤ lj ≤ rj ≤ n 1 ≤ fj ≤ 400 ) separate single space first line print highest rat vasya reach next n line print friends vasya need fee day i - th line first print number friends fee i - th day list index friends print friends list order multiple optimal solutions print,"['dp', 'implementation']",2100.0
255/D,mr . bender a digital table size n × n cell switch want field least c switch square condition fulfil mr bender happy 'll consider table row number top bottom 1 n columns — number leave right 1 n. initially exactly one switch cell coordinate ( x y ) ( x row number y column number ) cells switch second switch cells side - adjacent cells a cell coordinate ( x y ) side - adjacent cells cells coordinate ( x - 1 y ) ( x + 1 y ) ( x y - 1 ) ( x y + 1 ) many second mr . bender get happy ? first line contain four space - separated integers n x y c ( 1 ≤ n c ≤ 109 ; 1 ≤ x y ≤ n ; c ≤ n2 ) a single line print a single integer — answer problem initially first test one paint cell answer 0 . second test events go show figure,"['binary search', 'implementation', 'math']",1800.0
255/E,furlo rublo play a game table n pile coin lie i - th pile ai coin furlo rublo move turn furlo move first one move allow : player ca n't make a move lose task find win give game furlo rublo play optimally well first line contain integer n ( 1 ≤ n ≤ 77777 ) — number pile next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ <unknown> ) — size pile number separate single space please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier players play optimally well furlo win print ` ` furlo '' otherwise print ` ` rublo '' print answer without quote,"['implementation', 'math']",2200.0
257/B,"petya vasya decide play a little find n red cub m blue cub game go like : players take turn choose a cube color ( red blue ) put a line leave right ( overall line n + m cub ) petya move first petya 's task get many pair neighbour cub color possible vasya 's task get many pair neighbour cub different color possible number petya 's point game number pair neighbor cub color line number vasya 's point game number neighbour cub different color line task calculate score end game ( petya 's vasya 's point correspondingly ) boys play optimally well ` ` play optimally well '' first mean maximize number one 's point second — minimize number opponent 's point line contain two space - separated integers n m ( 1 ≤ n m ≤ 105 ) — number red blue cub correspondingly a single line print two space - separated integers — number petya 's vasya 's point correspondingly provide players play optimally well first test sample optimal strategy petya put blue cube line red cub leave end game line cub leave right look [ blue red red red ] , petya get 2 point vasya get 1 point petya would choose red cube first move , provide boys play optimally well petya would get 1 point vasya would get 2 point","['greedy', 'implementation']",1300.0
257/C,flatland recently introduce a new type eye check driver 's <unknown> check go like : a plane mannequins stand tell value minimum angle vertex origin coordinate mannequins stand inside <unknown> angle spend lot time ` ` glue screen '' vision impair write a program pass check first line contain a single integer n ( 1 ≤ n ≤ 105 ) — number mannequins next n line contain two space - separated integers : xi yi ( |xi| |yi| ≤ 1000 ) — coordinate i - th mannequin guarantee origin coordinate mannequin guarantee two mannequins locate point plane print a single real number — value seek angle degrees answer consider valid relative absolute error n't exceed 10 - 6 . solution first sample test show : solution second sample test show : solution third sample test show : solution fourth sample test show :,"['brute force', 'geometry', 'math']",1800.0
258/A,little elephant integer a write binary notation want write number a piece paper make sure number a fit piece paper little elephant ought delete exactly one digit number a binary record a new number appear consist remain binary digits write correspond order ( possible lead zero ) little elephant want number go write paper large possible help find maximum number obtain delete exactly one binary digit print binary notation single line contain integer a write binary notation without lead zero number contain 1 105 digits single line print number write without lead zero binary notation — answer problem first sample best strategy delete second digit result number 112 = 310 . second sample best strategy delete third fourth digits — result number <unknown> = <unknown>,"['greedy', 'math']",1100.0
258/B,"recently elections zoo overall 7 main political party : one little elephant political party 6 party less <unknown> name political party find number ballot highly important overall m possible number : 1 2 ... m. 7 party go assign way exactly one number , two distinct party receive number little elephant political party members believe lucky digits 4 7 . want evaluate chance elections , need find many correct assignments number lucky digits little elephant political party ballot number strictly larger total number lucky digits ballot number 6 party help little elephant political party calculate number answer rather large print remainder divide 1000000007 ( 109 + 7 ) a single line contain a single positive integer m ( 7 ≤ m ≤ 109 ) — number possible number ballot a single line print a single integer — answer problem modulo 1000000007 ( 109 + 7 )","['brute force', 'combinatorics', 'dp']",1900.0
259/A,"little elephant love chess much one day little elephant friend decide play chess ' ve get chess piece board a problem ' ve get 8 × 8 checker board square paint either black white little elephant friend know a proper chessboard n't side - adjacent cells color upper leave cell white play chess want make board a proper chessboard friends choose row board cyclically shift cells choose row , put last ( rightmost ) square first place row shift others one position right run describe operation multiple time ( run ) example first line board look like ` ` <unknown> '' ( white cells line mark character ` ` w '' black cells mark character ` ` b '' ) one cyclic shift look like ` ` <unknown> '' help little elephant friend find whether use number describe operations turn board a proper chessboard input consist exactly eight line line contain exactly eight character ` ` w '' ` ` b '' without space : j - th character i - th line stand color j - th cell i - th row <unknown> ' board character ` ` w '' stand white color character ` ` b '' stand black color consider row board number 1 8 top bottom columns — 1 8 leave right give board initially a proper chessboard a single line print ` ` yes '' ( without quote ) make board a proper chessboard ` ` '' ( without quote ) otherwise first sample shift follow line one position right : 3 - rd 6 - th 7 - th 8 - th second sample way achieve goal","['brute force', 'strings']",1000.0
26/C,bob decide lay a parquet floor live room live room size n × m metres bob plank three type : a plank 1 × 2 meter b plank 2 × 1 meter c plank 2 × 2 meter help bob find possible parquet live room a set plank possible find one possible ways bob n't use plank first input line contain 5 space - separated integer number n m a b c ( 1 ≤ n m ≤ 100 0 ≤ a b c ≤ 104 ) n m — live room dimension a b c — amount plank 1 × 2 2 × 1 и 2 × 2 respectively 's allow turn plank possible parquet room a set plank output impossible otherwise output one possible ways parquet room — output n line m lower - case latin letter two square common side contain letter belong one plank different letter otherwise different plank mark one letter ( see examples ) answer unique output,"['combinatorics', 'greedy', 'implementation']",2000.0
260/C,"little vasya n box ball room box stand a row number number 1 n leave right vasya choose one box let 's assume number i take ball ( guarantee box originally least one ball ) begin put ball ( one a time ) box number i + 1 i + 2 i + 3 vasya put a ball box number n next ball go box 1 next one go box 2 ball leave hand possible vasya put multiple ball box also possible one ball go box number i. i = n vasya put first ball box number 1 next ball go box 2 example let 's suppose initially vasya four box first box 3 ball second one 2 third one 5 fourth one 4 ball , i = 3 vasya take five ball third box put box number : 4 1 2 3 4 . vasya 's action ball lie box follow : first box 4 ball 3 second one 1 third one 6 fourth one point vasya completely forget original arrangement ball box know arrange number x — number box put last take ball ask help find initial arrangement ball box first line input contain two integers n x ( 2 ≤ n ≤ 105 1 ≤ x ≤ n ) represent number box index box get last ball vasya correspondingly second line contain n space - separated integers a1 a2 ... , integer ai ( 0 ≤ ai ≤ 109 ax ≠ 0 ) represent number ball box index i vasya complete action please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print n integers i - th one represent number ball box number i vasya start act separate number output space multiple correct solutions allow print","['greedy', 'implementation']",1700.0
261/B,maxim open restaurant ! restaurant get a huge table table 's length p meter maxim get a dinner party tonight n guests come let 's index guests maxim 's restaurant 1 n. maxim know size guests go come i - th guest 's size ( ai ) represent number meter guest go take sit restaurant table long dinner guests line a queue front restaurant order maxim let guests one one maxim stop let guests place restaurant table another guest queue place restaurant table another guest queue sum size guests restaurant plus size guest queue larger p. case offend guest place table maxim n't let guest restaurant even one follow guests queue would fit table maxim wonder average number visitors come restaurant possible n ! order guests queue help maxim calculate number first line contain integer n ( 1 ≤ n ≤ 50 ) — number guests restaurant next line contain integers a1 a2 ... ( 1 ≤ ai ≤ 50 ) — guests ' size meter third line contain integer p ( 1 ≤ p ≤ 50 ) — table 's length meter number line separate single space a single line print a real number — answer problem answer consider correct absolute relative error n't exceed 10 - 4 . first sample people come follow order : total get ( 2 + 1 + 2 + 1 + 1 + 1 ) / 6 = 8 / 6 = 1 ( 3 ),"['dp', 'math']",1900.0
263/A,' ve get a 5 × 5 matrix consist 24 zero a single number one let 's index matrix row number 1 5 top bottom let 's index matrix columns number 1 5 leave right one move allow apply one two follow transformations matrix : think a matrix look beautiful single number one matrix locate middle ( cell intersection third row third column ) count minimum number move need make matrix beautiful input consist five line line contain five integers : j - th integer i - th line input represent element matrix locate intersection i - th row j - th column guarantee matrix consist 24 zero a single number one print a single integer — minimum number move need make matrix beautiful,['implementation'],800.0
263/D,' ve get a undirected graph g consist n nod consider nod graph index integers 1 n. know node graph g connect edge least k nod graph task find give graph a simple cycle length least k + 1 . a simple cycle length d ( d > 1 ) graph g a sequence distinct graph nod v1 v2 ... vd nod v1 vd connect edge graph also integer i ( 1 ≤ i < d ) nod vi vi + 1 connect edge graph first line contain three integers n m k ( 3 ≤ n m ≤ 105 ; 2 ≤ k ≤ n - 1 ) — number nod graph number graph 's edge lower limit degree graph node next m line contain pair integers i - th line contain integers ai bi ( 1 ≤ ai bi ≤ n ; ai ≠ bi ) — index graph nod connect i - th edge guarantee give graph n't contain multiple edge self - loops guarantee node graph connect edge least k nod graph first line print integer r ( r ≥ k + 1 ) — length find cycle next line print r distinct integers v1 v2 ... vr ( 1 ≤ vi ≤ n ) — find simple cycle guarantee answer exist multiple correct answer allow print,"['dfs and similar', 'graphs']",1800.0
264/B,squirrel liss interest sequence also preferences integers think n integers a1 a2 ... good interest good sequence a sequence x1 x2 ... xk call good satisfy follow three condition : find length longest good sequence input consist two line first line contain a single integer n ( 1 ≤ n ≤ 105 ) — number good integers second line contain a single - space separate list good integers a1 a2 ... strictly increase order ( 1 ≤ ai ≤ 105 ; ai < ai + 1 ) print a single integer — length longest good sequence first example follow sequence examples good sequence : [ 2 ; 4 ; 6 ; 9 ] [ 2 ; 4 ; 6 ] [ 3 ; 9 ] [ 6 ] length longest good sequence 4,"['dp', 'number theory']",1500.0
265/B,squirrel liss love nut n tree ( number 1 n west east ) along a street a delicious nut top tree height tree i hi liss want eat nut liss root tree number 1 . one second liss perform one follow action : compute minimal time ( second ) require eat nut first line contain integer n ( 1 ≤ n ≤ 105 ) — number tree next n line contain height tree : i - th line contain integer hi ( 1 ≤ hi ≤ 104 ) — height tree number i. print a single integer — minimal time require eat nut second,"['greedy', 'implementation']",1000.0
266/A,n stone table a row red green blue count minimum number stone take table two neighbor stone different color stone a row consider neighbor stone first line contain integer n ( 1 ≤ n ≤ 50 ) — number stone table next line contain string s represent color stone 'll consider stone row number 1 n leave right i - th character s equal ` ` r '' i - th stone red ` ` g '' 's green ` ` b '' 's blue print a single integer — answer problem,['implementation'],800.0
266/D,<unknown> a well - known fast food restaurant go open a cafe bertown important thing choose new restaurant 's location would easy get bertown road system represent n junctions connect m bidirectional roads road know length also know get junction one move along roads task find location restaurant shortest distance along roads cafe farthest junction would minimum note restaurant locate junction point road first line contain two integers n m ( ) — number junctions number roads correspondingly m line follow describe bertown roads road describe three integers ai bi wi ( 1 ≤ ai bi ≤ n ai ≠ bi ; 1 ≤ wi ≤ 105 ) ai bi number junctions connect i - th road wi length i - th road guarantee road connect two distinct junctions one road two junctions get junction one print a single real number — shortest distance optimal restaurant location farthest junction answer consider correct absolute relative error n't exceed 10 - 9,"['graphs', 'math', 'shortest paths']",2400.0
269/C,emuskald consider a master flow algorithms complete ingenious program yet — calculate maximum flow undirected graph graph consist n vertices m edge vertices number 1 n. vertices 1 n source sink respectively however max - flow algorithm seem a little flaw — find flow volume edge direction help find edge direction flow edge note result flow correct maximum flow formally give undirected graph 's undirected edge ( ai bi ) give flow volume ci direct edge way follow condition hold : first line input contain two space - separated integers n m ( 2 ≤ n ≤ 2·105 n - 1 ≤ m ≤ 2·105 ) number vertices edge graph follow m line contain three space - separated integers ai bi ci ( 1 ≤ ai bi ≤ n ai ≠ bi 1 ≤ ci ≤ 104 ) mean undirected edge ai bi flow volume ci guarantee two edge connect vertices ; give graph connect ; a solution always exist output m line contain one integer di 0 direction i - th edge ai → bi ( flow go vertex ai vertex bi ) 1 otherwise edge number 1 m order give input several solutions print first test case 10 flow units pass path 5 flow units pass directly source sink :,"['graphs', 'greedy']",2100.0
269/D,emuskald hire design artificial waterfall accord latest trend landscape architecture a modern artificial waterfall consist multiple horizontal panel <unknown> a wide flat wall water flow top wall panel panel reach bottom wall wall height t n panel wall panel a horizontal segment height hi begin li end ri i - th panel connect point ( li hi ) ( ri hi ) plane top wall consider a panel connect point ( - 109 t ) ( 109 t ) similarly bottom wall consider a panel connect point ( - 109 0 ) ( 109 0 ) two panel share a common point emuskald know waterfall aesthetically please flow panel i panel j ( ) follow condition hold : flow equal min ( ri rj ) - max ( li lj ) length horizontal projection overlap emuskald decide waterfall water flow a single path top bottom water flow a panel ( except bottom wall ) water fall exactly one lower panel total amount water flow waterfall define minimum horizontal projection overlap two consecutive panel path waterfall formally : make a truly great waterfall emuskald must maximize water flow many panel a hard time plan creation example a waterfall emuskald want : help emuskald maintain reputation find value maximum possible water flow first line input contain two space - separated integers n t ( 1 ≤ n ≤ 105 2 ≤ t ≤ 109 ) number panel exclude top bottom panel height wall n follow line contain three space - separated integers hi li ri ( 0 < hi < t - 109 ≤ li < ri ≤ 109 ) height leave right end i - th panel segment guarantee two segment share a common point output a single integer — maximum possible amount water flow desire waterfall first test case correspond picture,"['data structures', 'dp', 'graphs', 'sortings']",2600.0
271/C,greatest secret ever consist n word index positive integers 1 n. secret need divide k keepers ( let 's index positive integers 1 k ) i - th keeper get a non - empty set word number set ui = ( ui 1 ui 2 ... ui <unknown> ) 'll <unknown> set elements write increase order 'll say secret safe follow condition hold : let us remind elements set ( u1 u2 ... us ) form arithmetic progression number d i ( 1 ≤ i < s ) fulfill ui + d = ui + 1 . example elements set ( 5 ) ( 1 10 ) ( 1 5 9 ) form arithmetic progressions elements set ( 1 2 4 ) ( 3 6 8 ) n't task find partition set word subsets u1 u2 ... uk secret safe otherwise indicate 's partition input consist a single line contain two integers n k ( 2 ≤ k ≤ n ≤ 106 ) — number word secret number keepers number separate a single space way keep secret safe print a single integer ` ` -1 '' ( without quote ) otherwise print n integers i - th represent number keeper 's get i - th word secret multiple solutions print,['implementation'],1500.0
272/C,"dima 's get a staircase consist n stairs first stair height a1 second one a2 last one ( 1 ≤ a1 ≤ a2 ≤ ... ≤ ) dima decide play staircase throw rectangular box staircase i - th box width wi height hi dima throw box vertically first wi stairs staircase , box cover stairs number 1 2 ... wi throw box fly vertically least one two follow events happen : consider touch horizontal side stairs box touch corner n't take consideration specifically imply a box width wi touch stair number wi + 1 . give description staircase sequence dima throw box box determine high bottom box land consider a box fall previous one land first line contain integer n ( 1 ≤ n ≤ 105 ) — number stairs staircase second line contain a non - decreasing sequence consist n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ; ai ≤ ai + 1 ) next line contain integer m ( 1 ≤ m ≤ 105 ) — number box follow m line contain a pair integers wi hi ( 1 ≤ wi ≤ n ; 1 ≤ hi ≤ 109 ) — size i - th throw box number line separate space print m integers — box height bottom box land print answer box order box give input please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier first sample show picture","['data structures', 'implementation']",1500.0
272/E,dima come horse land n horse live land horse horse land several enemies ( enmity a symmetric relationship ) horse land n't hostile number enemies horse 3 . right horse land go election campaign horse trust dima split two part horse want follow condition hold : a horse n't one enemy party help dima split horse party note one party turn empty first line contain two integers n m — number horse horse land number enemy pair next m line define enemy pair i - th line contain integers ai bi ( 1 ≤ ai bi ≤ n ; ai ≠ bi ) mean horse ai enemy horse bi consider horse index way 1 n. guarantee horse three enemies pair enemies occur input print a line consist n character : i - th character line must equal ` ` 0 '' horse number i need go first party otherwise character equal ` ` 1 '' n't a way divide horse require print -1,"['combinatorics', 'graphs']",2200.0
275/B,consider n × m grid initially cells grid color white lenny paint cells ( least one ) black call a paint grid convex one walk black cell another black cell use a path side - adjacent black cells change direction path figure leave grid convex right one convex exist two cells need one time change direction path 're give a paint grid input tell lenny grid convex first line input contain two integers n m ( 1 ≤ n m ≤ 50 ) — size grid next n line contain m character ` ` b '' ` ` w '' character ` ` b '' denote a black cell grid ` ` w '' denote a white cell grid 's guarantee grid least one black cell line output print ` ` yes '' grid convex otherwise print ` ` '' print quote,['implementation'],1700.0
276/D,a little girl love problems bitwise operations much 's one give two integers l r. let 's consider value pair integers a b ( l ≤ a ≤ b ≤ r ) task find maximum value among consider ones expression mean apply bitwise exclude operation integers x y. give operation exist modern program languages example languages c++ java represent ` ` ^ '' pascal — ` ` xor '' single line contain space - separated integers l r ( 1 ≤ l ≤ r ≤ 1018 ) please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier a single line print a single integer — maximum value pair integers a b ( l ≤ a ≤ b ≤ r ),"['bitmasks', 'dp', 'greedy', 'implementation', 'math']",1700.0
28/B,one day n cells array decide play follow game initially cell contain a number equal 's ordinal number ( start 1 ) also cell determine 's favourite number 's move i - th cell exchange 's value value j - th cell |i - j| = di di a favourite number i - th cell cells make move order number move unlimited favourite number cell give also give a permutation number 1 n. determine whether game could move state first line contain positive integer n ( 1 ≤ n ≤ 100 ) — number cells array second line contain n distinct integers 1 n — permutation last line contain n integers 1 n — favourite number cells give state reachable describe game output yes otherwise,"['dfs and similar', 'dsu', 'graphs']",1600.0
28/E,horrible ! empire galactic chickens try conquer a beautiful city ` ` z '' build a huge incubator produce millions chicken soldier a day fence around huge incubator look like a polygon plane oxy n vertices naturally dravde ca n't keep still want destroy chicken empire sure start incubator dravde strictly outside incubator 's territory point a ( xa ya ) want get inside kill chickens work take a lot ! problem recently dravde go roller skate break legs get incubator 's territory <unknown> airplane levap-41 levap-41 fly speed v ( xv yv zv ) dravde get plane point a fly time air drop dravde heavy 's fall vertically speed fdown point free fall dravde open parachute moment start fall wind speed u ( xu yu zu ) land unfortunately dravde n't good mathematics would help poor world 's <unknown> find air drop plan allow land incubator 's territory ? answer unique dravde want find plan minimum time flight plane answer still multiple want find one minimum time free fall open <unknown> first line contain number n ( 3 ≤ n ≤ 104 ) — amount vertices fence follow n line contain coordinate vertices ( two integer number xi yi ) clockwise counter - clockwise order 's guarantee fence contain self - intersections follow four line contain coordinate point a ( xa ya ) speed v ( xv yv zv ) fdown speed u ( xu yu zu ) input number integer coordinate n't exceed 104 absolute value 's guarantee zv > 0 fdown zu < 0 point a strictly outside incubator 's territory first line output two number t1 t2 dravde air drop time t1 ( count begin flight ) land incubator 's territory ( land border <unknown> land territory ) dravde n't open parachute second number equal duration dravde 's fall 's impossible dravde get incubator 's territory output -1 -1 . answer unique output answer minimum t1 answer still multiple output answer minimum t2 answer must absolute relative error less 10 - 6,"['geometry', 'math']",2800.0
282/C,bitlandians quite weird people everything differently a different alphabet a different definition a string a bitlandish string a string make character ` ` 0 '' ` ` 1 '' bithaval ( mayor bitland ) love play bitlandish string take bitlandish string a apply several ( possibly zero ) operations one operation mayor may take two adjacent character a string define one x one y. calculate two value p q : p = x xor y q = x y. replace one two take character p one q. xor operation mean bitwise exclude operation operation bitwise operation example one operation transform string 11 string 10 string 01 . string 1 transform string ' ve get two bitlandish string a b. task check possible bithaval transform string a string b several ( possibly zero ) describe operations first line contain bitlandish string a second line contain bitlandish string b. string different lengths guarantee give string consist character ` ` 0 '' ` ` 1 '' string empty length n't exceed 106 . print ` ` yes '' a transform b otherwise print ` ` '' please print quote,"['implementation', 'math']",1500.0
283/B,"farmer john give cow a program play ! program contain two integer variables x y perform follow operations a sequence a1 a2 ... positive integers : cow good arithmetic though want see program work please help ! give sequence a2 a3 ... , suppose i ( 1 ≤ i ≤ n - 1 ) run program sequence i a2 a3 ... , run output final value y program terminate -1 terminate first line contain a single integer n ( 2 ≤ n ≤ 2·105 ) next line contain n - 1 space separate integers a2 a3 ... ( 1 ≤ ai ≤ 109 ) output n - 1 line i - th line print request value program run sequence i a2 a3 ... please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first sample","['dfs and similar', 'dp', 'graphs']",1700.0
284/A,cow learn a primitive root ! give a prime p a primitive root integer x ( 1 ≤ x < p ) none integers x - 1 x2 - 1 ... xp - 2 - 1 divisible p xp - 1 - 1 unfortunately compute primitive root time consume cow need help give a prime p help cow find number primitive root input contain a single line contain integer p ( 2 ≤ p < 2000 ) guarantee p a prime output a single line number primitive root primitive root 2 . primitive root 2 3,"['implementation', 'math', 'number theory']",1400.0
284/B,n cow play poker a table current bet phase player 's status either ` ` allin '' ` ` '' ` ` fold '' change throughout phase increase <unknown> a player whose current status ` ` fold '' may show his / her hand table however affect bet decisions he / she may players a status either ` ` allin '' ` ` fold '' player 's status may either ` ` allin '' ` ` '' find number cow currently show hand without affect bet decisions first line contain a single integer n ( 2 ≤ n ≤ 2·105 ) second line contain n character either ` ` a '' ` ` i '' ` ` f '' i - th character ` ` a '' i - th player 's status ` ` allin '' ` ` i '' i - th player 's status ` ` '' ` ` f '' i - th player 's status ` ` fold '' first line contain a single integer denote number players currently show hand first sample cow 1 4 5 6 show hand second sample cow 3 show hand,"['brute force', 'implementation']",1000.0
286/A,a permutation p size n sequence p1 p2 ... pn consist n distinct integers 1 n ( 1 ≤ pi ≤ n ) a lucky permutation permutation p integer i ( 1 ≤ i ≤ n ) meet condition ppi = n - i + 1 . integer n. find lucky permutation p size n. first line contain integer n ( 1 ≤ n ≤ 105 ) — require permutation size print ` ` -1 '' ( without quote ) lucky permutation p size n n't exist otherwise print n distinct integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) a space — require permutation multiple answer print,['math'],1400.0
29/B,"a car move point a point b speed v meter per second action take place x - axis distance d meter a traffic light start time 0 first g second green light follow r second red light green light g second , car instantly accelerate 0 v vice versa instantly slow v 0 . consider pass traffic light green light instantly car approach traffic light moment red light turn n't time pass approach traffic light moment green light turn move car leave point a time 0 . minimum time car get point a point b without break traffic rule ? first line contain integers l d v g r ( 1 ≤ l d v g r ≤ 1000 d < l ) — distance a b ( meter ) distance a traffic light car 's speed duration green light duration red light output a single number — minimum time car need get point a point b. output must relative absolute error less 10 - 6",['implementation'],1500.0
290/C,input contain 1 10 line i - th line contain integer number xi ( 0 ≤ xi ≤ 9 ) output a single real number answer consider correct absolute relative error exceed 10 - 4,"['implementation', 'trees']",1700.0
291/A,polycarpus director a large corporation n secretaries work corporation correspond via famous spyke <unknown> system day know two people call via spyke spyke network assign a unique i d call a positive integer session number one day polycarpus wonder secretaries talk via spyke secretary write either session number call a 0 secretary n't talk via spyke moment help polycarpus analyze data find number pair secretaries talk polycarpus make a mistake data describe situation could take place say note secretaries correspond via spyke also people place also spyke conferences n't permit — one call connect exactly two people first line contain integer n ( 1 ≤ n ≤ 103 ) — number secretaries polycarpus 's corporation next line contain n space - separated integers : id1 id2 ... idn ( 0 ≤ idi ≤ 109 ) number idi equal number call session i - th secretary secretary talk via spyke zero otherwise consider secretaries index 1 n way print a single integer — number pair chat secretaries -1 polycarpus 's get a mistake record describe situation could take place first test sample two spyke call secretaries : secretary 2 secretary 4 secretary 3 secretary 5 . second test sample describe situation impossible conferences n't allow,"['implementation', 'sortings']",800.0
292/E,"often copy large volumes information operation take many computer resources therefore problem advise come a way copy part a number array another one quickly formally ' ve get two array integers a1 a2 ... b1 b2 ... bn length n. also ' ve get m query two type : query second type print result — value correspond element array b. first line contain two space - separated integers n m ( 1 ≤ n m ≤ 105 ) — number elements array number query correspondingly second line contain array integers a1 a2 ... ( |ai| ≤ 109 ) third line contain array integers b1 b2 ... bn ( |bi| ≤ 109 ) next m line contain descriptions query i - th line first contain integer ti — type i - th query ( 1 ≤ ti ≤ 2 ) ti = 1 i - th query mean copy operation ti = 2 i - th query mean take value array b. ti = 1 query type follow three integers xi yi ki ( 1 ≤ xi yi ki ≤ n ) — parameters copy query ti = 2 query type follow integer xi ( 1 ≤ xi ≤ n ) — position array b. number line separate single space guarantee query correct , copy border fit border array a b. second type query print result a single line",['data structures'],1900.0
293/D,ksusha a vigorous mathematician keen absolutely incredible mathematical riddle today ksusha come across a convex polygon non - zero area wonder : choose a pair distinct point uniformly among integer point ( point integer coordinate ) inside border polygon draw a square two opposite vertices lie choose point expectation square 's area ? a pair distinct point choose uniformly among pair distinct point locate inside border polygon pair point p q ( p ≠ q ) q p consider help ksusha ! count require expectation first line contain integer n ( 3 ≤ n ≤ 105 ) — number vertices ksusha 's convex polygon next n line contain coordinate polygon vertices clockwise counterclockwise order i - th line contain integers xi yi ( |xi| |yi| ≤ 106 ) — coordinate vertex go i - th order print a single real number — require expect area answer consider correct absolute relative error n't exceed 10 - 6,"['geometry', 'math', 'two pointers']",2700.0
295/C,one day greg friends walk forest overall n people walk include greg soon find front a river guy immediately decide get across river luckily a boat river bank guy stand know boat hold people total weight k kilograms greg immediately take a piece paper list weight people group ( include ) turn person weight either 50 100 kilograms greg want know minimum number time boat need cross river transport whole group bank boat need least one person navigate one bank boat cross river non - zero number passengers long total weight n't exceed k. also greg wonder many ways transport everybody side minimum number boat rid two ways consider distinct ride distinct set people boat help greg problem first line contain two integers n k ( 1 ≤ n ≤ 50 1 ≤ k ≤ 5000 ) — number people include greg boat 's weight limit next line contain n integers — people 's weight a person 's weight either 50 kilos 100 kilos consider greg friends index way first line print integer — minimum number rid transport everyone bank impossible print integer -1 . second line print remainder divide number ways transport people minimum number rid number 1000000007 ( 109 + 7 ) transport everyone bank impossible print integer 0 . first test greg walk alone consequently need one ride across river second test follow plan : total 5 rid depend person choose step 2 get two distinct ways,"['combinatorics', 'dp', 'graphs', 'shortest paths']",2100.0
296/A,yaroslav array consist n integers one second yaroslav swap two neighbor array elements yaroslav wonder obtain array two neighbor elements would distinct a finite time help yaroslav first line contain integer n ( 1 ≤ n ≤ 100 ) — number elements array second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 1000 ) — array elements single line print ` ` yes '' ( without quote ) yaroslav obtain array need ` ` '' ( without quote ) otherwise first sample initial array fit well second sample yaroslav get array : 1 2 1 . swap last second last elements obtain third sample <unknown> ca n't get array need,"['greedy', 'math']",1100.0
298/A,a straight snowy road divide n block block number 1 n leave right one move i - th block ( i + 1 ) -th block leave a right footprint i - th block similarly one move i - th block ( i - 1 ) -th block leave a leave footprint i - th block already a footprint i - th block new footprint cover old one begin footprints polar bear alice start s - th block make a sequence move end t - th block know alice never move outside road give description alice 's footprints task find a pair possible value s t look footprints first line input contain integer n ( 3 ≤ n ≤ 1000 ) second line contain description road — string consist n character character either ` ` . '' ( a block without footprint ) ` ` l '' ( a block a leave footprint ) ` ` r '' ( a block a right footprint ) 's guarantee give string contain least one character equal ` ` . ` ` also first last character always ` ` . ` ` 's guarantee a solution exist print two space - separated integers — value s t. several possible solutions print first test sample one picture,"['greedy', 'implementation']",1300.0
303/A,"bike interest permutations a permutation length n integer sequence integer 0 ( n - 1 ) appear exactly example [ 0 2 1 ] a permutation length 3 [ 0 2 2 ] [ 1 2 3 ] a permutation triple permutations length n ( a b c ) call a lucky permutation triple sign ai denote i - th element permutation a. modular equality describe denote remainder divide ai + bi n divide ci n equal , integer n want find a lucky permutation triple could please help ? first line contain a single integer n ( 1 ≤ n ≤ 105 ) lucky permutation triple length n exist print -1 . otherwise need print three line line contain n space - seperated integers first line must contain permutation a second line — permutation b third — permutation c. multiple solutions print sample 1 permutation triple ( [ 1 4 3 2 0 ] [ 1 0 2 4 3 ] [ 2 4 0 1 3 ] ) lucky permutation triple follow hold : sample 2 easily notice lucky permutation triple exist","['implementation', 'math']",1300.0
306/C,"polycarpus sure life fit description : ` ` first a white stripe a black one a white one '' , polycarpus sure rule go fulfill next n days polycarpus know w good events b not - so - good events least one event go take place day day <unknown> characterize a part a white a black stripe day go events type ( ether good not - so - good ) number distinct ways scenario develop next n days polycarpus a white stripe ( a stripe good events stripe 's length least 1 day ) a black stripe ( a stripe not - so - good events stripe 's length least 1 day ) a white stripe ( a stripe good events stripe 's length least 1 day ) n days belong one three strip note even events type distinct even events occur day go order ( simultaneous events ) write a code print number possible configurations sort events days see sample clarifications scenarios consider distinct print answer modulo 1000000009 ( 109 + 9 ) single line input contain integers n w b ( 3 ≤ n ≤ 4000 2 ≤ w ≤ 4000 1 ≤ b ≤ 4000 ) — number days number good events number not - so - good events guarantee w + b ≥ n. print require number ways modulo 1000000009 ( 109 + 9 ) 'll represent good events number start 1 not - so - good events — letter start ' a ' vertical line separate days first sample possible ways : ` ` <unknown> '' ` ` <unknown> '' second sample possible ways : ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' third sample possible ways : ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> ''","['combinatorics', 'number theory']",2100.0
31/B,email address berland a string form a @ b a b arbitrary string consist small latin letter bob a system administrator « bersoft » company keep a list email address company 's staff list a large string address write arbitrary order separate commas address write suddenly unknown reason commas bob 's list disappear bob a string address write one another without separators impossible determine boundaries address unfortunately day chief ask bring initial list address bob want <unknown> address valid way help first line contain list address without separators length string 1 200 inclusive string consist small latin letter character « @ » list valid ( accord berland rule ) email address remove commas coincide give string output solution case output list address write list several solutions output,"['greedy', 'implementation', 'strings']",1500.0
314/D,sereja place n point a plane sereja want place plane two straight line intersect a right angle one straight line intersect ox axis angle 45 degrees maximum distance point straight line minimum problem consider distance point ( x1 y1 ) ( x2 y2 ) equal |x1 - x2| + |y1 - y2| distance point straight line minimum distance point point belong one line help sereja find maximum distance point optimally locate straight line first line contain integer n ( 1 ≤ n ≤ 105 ) next n line contain coordinate line i - th line contain two integers xi yi ( |xi| |yi| ≤ 109 ) a single line print a real number — answer problem answer consider correct iff absolute relative error n't exceed 10 - 6,"['binary search', 'data structures', 'geometry', 'sortings', 'two pointers']",2500.0
315/B,"sereja get array consist n integers a1 a2 ... , sereja active boy go complete m operations operation one three form : help sereja complete operations first line contain integers n m ( 1 ≤ n m ≤ 105 ) second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — original array next m line describe operations i - th line describe i - th operation first number i - th line integer ti ( 1 ≤ ti ≤ 3 ) represent operation type ti = 1 follow two integers vi xi ( 1 ≤ vi ≤ n 1 ≤ xi ≤ 109 ) ti = 2 follow integer yi ( 1 ≤ yi ≤ 104 ) ti = 3 follow integer qi ( 1 ≤ qi ≤ n ) third type operation print value <unknown> print value order correspond query follow input",['implementation'],1200.0
319/B,"n psychos stand a line psycho assign a unique integer 1 n. step every psycho i d greater psycho right ( exist ) kill right neighbor line note a psycho might kill get kill step 're give initial arrangement psychos line calculate many step need moment time nobody kill neighbor moment look note understand statement precise first line input contain integer n denote number psychos ( 1 ≤ n ≤ 105 ) second line a list n space separate distinct integers range 1 n inclusive — ids psychos line leave right print number step line remain afterward first sample line psychos transform follow : [ 10 9 7 8 6 5 3 4 2 1 ] → [ 10 8 4 ] → [ 10 ] , two step","['data structures', 'implementation']",1900.0
319/D,"a substring a string a contiguous subsequence string , string bca substring string abcabc string cc a repeat block a string form concatenate string , string abcabc a repeat block string <unknown> ababab ' ve get a sequence latin character ( string ) step find shortest substring a repeat block exist one must choose leftmost substring form xx ( x — string ) replace substring x word delete one x substrings substring repeat process remain repeat block string would final string look like ? look sample explanation understand statement precise first line input 're give a string small latin character length 1 50000 inclusive print final string apply change first sample string transform follow : <unknown> → abcabc → abc second sample string transform follow : <unknown> → <unknown> → <unknown> → abaaab → abaab → abab → ab","['greedy', 'strings']",2800.0
32/C,know fleas berland jump vertically horizontally length jump always equal s centimeters a flea find center cell check board size n × m centimeters ( cell 1 × 1 centimeters ) jump wish arbitrary number time even visit a cell restriction jump board flea count amount cells reach start position ( x y ) let 's denote amount dx y. task find number start position ( x y ) maximum possible value dx y. first line contain three integers n m s ( 1 ≤ n m s ≤ 106 ) — length board width board length flea 's jump output integer — number require start position flea,['math'],1700.0
327/B,"iahub iahubina go a date a luxury restaurant everything go fine pay food instead money waiter want iahub write a hungry sequence consist n integers a sequence a1 a2 ... , consist n integers hungry : iahub trouble ask help find a hungry sequence n elements input contain a single integer : n ( 1 ≤ n ≤ 105 ) output a line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 107 ) represent a possible hungry sequence note ai must greater 10000000 ( 107 ) less 1 . multiple solutions output one",['math'],1200.0
33/A,one little know beautiful country call <unknown> live a lovely shark valerie like shark several row teeth feed crucians one valerie 's distinguish feature eat one crucian use one row teeth rest teeth ` ` relax '' a long time <unknown> search sea crucians a great misfortune happen teeth start <unknown> see local dentist <unknown> ashot a professional ashot quickly relieve valerie toothache moreover manage determine cause valerie 's develop <unknown> ( later nickname cap ) turn valerie eat many crucians help valerie avoid <unknown> toothache ashot find valerie 's tooth residual viability residual viability a tooth a value equal amount crucians valerie eat tooth every time valerie eat a crucian viability teeth use decrease one viability least one tooth become negative shark see dentist unhappy valerie come back home a portion crucians wait sure shark could n't say favourite meal desire go back dentist 's decide eat maximum amount crucians portion viability tooth become negative valerie good mathematics ask help find total amount crucians consume dinner remind eat one crucian valerie use exactly one row teeth viability tooth row decrease one first line contain three integers n m k ( 1 ≤ m ≤ n ≤ 1000 0 ≤ k ≤ 106 ) — total amount valerie 's teeth amount tooth row amount crucians valerie 's portion dinner follow n line contain two integers : r ( 1 ≤ r ≤ m ) — index row belong correspond tooth c ( 0 ≤ c ≤ 106 ) — residual viability 's guarantee tooth row positive amount teeth first line output maximum amount crucians valerie consume dinner,"['greedy', 'implementation']",1200.0
33/C,learn learn learn — valera every day study mathematical school math main discipline mathematics teacher love discipline much try cultivate love children 's always give students large difficult homework despite valera one best students fail manage new homework 's ask help follow task a sequence n number give a prefix a sequence part sequence ( possibly empty ) take start sequence a suffix a sequence part sequence ( possibly empty ) take end sequence allow sequentially make two operations sequence first operation take prefix sequence multiply number prefix - 1 . second operation take suffix multiply number - 1 . choose prefix suffix may intersect maximum total sum sequence obtain apply describe operations ? first line contain integer n ( 1 ≤ n ≤ 105 ) — amount elements sequence second line contain n integers ai ( - 104 ≤ ai ≤ 104 ) — sequence first line output contain answer problem,['greedy'],1800.0
33/D,berland face dark time army evil lord van de mart go conquer whole kingdom council war call berland 's king valery severe come n knight long discussions become clear kingdom exactly n control point ( enemy conquer least one point war lose ) knight occupy one point berland divide m + 1 regions m fence way get one region another climb fence fence a circle a plane two fence common point control point fence give k pair number ai bi pair find : many fence a knight control point index ai climb reach control point bi ( case van de mart attack control point bi first ) knight rid a horse ( difficult throw a horse a fence ) find pair minimum amount fence climb first input line contain three integers n m k ( 1 ≤ n m ≤ 1000 0 ≤ k ≤ 100000 ) follow n line contain two integers kxi kyi ( - 109 ≤ kxi kyi ≤ 109 ) — coordinate control point index i. control point coincide follow m line describe fence index i three integers ri cxi cyi ( 1 ≤ ri ≤ 109 - 109 ≤ cxi cyi ≤ 109 ) — radius center circle correspond fence situate follow k pair integers ai bi ( 1 ≤ ai bi ≤ n ) a separate line — request answer ai bi coincide output exactly k line contain one integer — answer correspond request,"['geometry', 'graphs', 'shortest paths', 'sortings']",2000.0
330/A,give a rectangular cake represent r × c grid cell either evil strawberry empty example a 3 × 4 cake may look follow : cakeminator go eat cake ! time eat choose a row a column contain evil <unknown> contain least one cake cell eat eat cake cells may decide eat number time please output maximum number cake cells cakeminator eat first line contain two integers r c ( 2 ≤ r c ≤ 10 ) denote number row number columns cake next r line contain c character — j - th character i - th line denote content cell row i column j either one : output maximum number cake cells cakeminator eat first example one possible way eat maximum number cake cells follow ( perform 3 eat ),"['brute force', 'implementation']",800.0
332/A,everybody know berland citizens keen health especially students berland students tough drink orange juice ! yesterday one student vasya mat make barbecue drink healthy drink run first barrel juice decide play a simple game n people come barbecue sit a circle ( thus person receive a unique index bi 0 n - 1 ) person number 0 start game ( time vasya ) turn game number integers start 1 . j - th turn make person index bi person act like : person point last turn make action problem vasya 's drink much juice ca n't remember goal game however vasya 's get record sequence participants ' action ( include ) vasya want find maximum amount juice could drink play optimally well ( players ' action change ) help assume scenario enough juice everybody first line contain a single integer n ( 4 ≤ n ≤ 2000 ) — number participants game second line describe actual game : i - th character line equal ' a ' participant move i - th point next person elbow ' b ' participant point a nod game continue least 1 2000 turn print a single integer — number glass juice vasya could drink play optimally well sample vasya get two turn — 1 5 . first sample vasya could drink a glass juice fifth turn point next person a nod case sequence move would look like ` ` abbbb '' second sample vasya would n't drink a single glass juice move perform turn 3 4 different,['implementation'],1300.0
332/D,"insurgents accidentally get hold plan a top secret research polygon create a distant planet need galaxy empire insurgents suppose polygon develop new deadly weapon polygon consist n missile silos connect bidirectional underground passages passages link <unknown> research conduct naturally passages guard severely : passage silos i j patrol ci j war droids insurgents study polygon plan notice unusual structure turn k - element set silos s exactly one silo directly connect a passage silo s ( 'll call silo adjacent s ) consider insurgents decide act follow : danger operation total number droids patrol passages scout go danger operation obviously depend way choose set s. insurgents n't yet decide exact silos send scout however already want start prepare weapons scout group , insurgents need know mathematical average dangers operations correspond possible ways choose set s. solve problem help insurgents protect <unknown> republic ! first line contain two integers n k ( 2 ≤ n ≤ 2000 1 ≤ k ≤ n - 1 ) — number silos number scout group correspondingly next n - 1 line describe polygon plan : i - th line contain n - i integers ci i + 1 ci i + 2 ... ci n — number droids patrol correspond passages ( -1 ≤ ci j ≤ 109 ; ci j = -1 silos i j n't a passage ) passages bidirectional , assume ci j = cj i. passages connect a silo guarantee polygon plan meet condition problem statement print average danger scout operation round integer note give limit answer problem always fit standard integer 64 - bit data type please use % lld specifier write 64 - bit integers с++ prefer use cout stream % i64d specifier first sample 6 one - element set silos set { 1 } { 5 } operation danger equal 8 set { 3 } { 6 } — 3 set { 2 } { 4 } — 5 . mathematical average equal second sample 3 two - elements set silos : { 1 3 } ( danger equal 21 ) { 1 2 } ( danger equal 11 ) { 2 3 } ( danger equal 10 ) average operation danger equal","['graphs', 'math']",2400.0
332/E,let 's assume p q string positive length call container key correspondingly string q consist character 0 1 . let 's take a look a simple algorithm extract message s give container p : give pseudocode i j integer variables s a string ' = ' assignment operator ' = = ' a comparison operation ' [ ] ' operation obtain string character preset index ' < > ' empty string suppose string character number start zero understand implement algorithm quite easy task go slightly different need construct lexicographically minimum key length k use algorithm give extract message s container p ( otherwise find key n't exist ) first two line input non - empty string p s ( 1 ≤ |p| ≤ 106 1 ≤ |s| ≤ 200 ) describe container message correspondingly string contain character ascii cod 32 126 inclusive third line contain a single integer k ( 1 ≤ k ≤ 2000 ) — key 's length print require key ( string length k consist character 0 1 ) key n't exist print single character 0 . string x = x1x2 ... xp lexicographically smaller string y = y1y2 ... yq either p < q x1 = y1 x2 = y2 ... xp = yp exist integer r ( 0 ≤ r < min ( p q ) ) x1 = y1 x2 = y2 ... xr = yr xr + 1 < yr + 1 . symbols compare accord ascii cod,"['dp', 'greedy', 'implementation']",2400.0
333/E,many schoolchildren look a job summer one day gerald still a schoolboy also decide work summer gerald quite unusual schoolboy find quite unusual work a certain company agree pay a certain sum money draw three identical circle a plane circle must interfere ( may touch ) choose center circle n options grant company free choose radius circle ( three <unknown> must equal ) please note larger radius get pay help gerald earn much possible first line contain a single integer n — number center ( 3 ≤ n ≤ 3000 ) follow n line contain two integers xi yi ( - 104 ≤ xi yi ≤ 104 ) — coordinate potential circle center provide company give point distinct print a single real number — maximum possible radius circle answer accept relative absolute error n't exceed 10 - 6,"['binary search', 'bitmasks', 'brute force', 'geometry', 'sortings']",2500.0
335/E,a number skyscrapers build a line number skyscrapers choose uniformly random 2 314 ! ( 314 factorial a large number ) height skyscraper choose randomly independently height i probability 2 - i positive integers i. floor a skyscraper height i number 0 i - 1 . speed transit time a number zip line instal skyscrapers specifically a zip line connect i - th floor one skyscraper i - th floor another skyscraper skyscrapers i - th floor alice bob decide count number skyscrapers alice thorough want know exactly many skyscrapers begin leftmost skyscraper a counter 1 . move right one skyscraper a time add 1 counter time move continue reach rightmost skyscraper bob impatient want finish fast possible begin leftmost skyscraper a counter 1 . move build build use zip line stage bob use highest available zip line right ignore floor a height greater h due fear heights bob use a zip line travel fast count many skyscrapers pass instead add 2i counter i number floor 's currently continue reach rightmost skyscraper consider follow example 6 build heights 1 4 3 4 1 2 leave right h = 2 . alice begin counter 1 add 1 five time a result 6 . bob begin counter 1 add 1 4 4 2 order a result 12 . note bob ignore highest zip line fear heights ( h = 2 ) bob 's counter top image alice 's counter bottom zip line show bob 's path show green dash line alice 's pink dash line floor skyscrapers number zip line bob use mark amount add counter alice bob reach right - most skyscraper compare counter give either value alice 's counter value bob 's counter must compute expect value 's counter first line input a name either string ` ` alice '' ` ` bob '' second line input contain two integers n h ( 2 ≤ n ≤ 30000 0 ≤ h ≤ 30 ) name ` ` alice '' n represent value alice 's counter reach rightmost skyscraper otherwise n represent value bob 's counter reach rightmost skyscraper ; h represent highest floor number bob will use output a single real value give expect value alice 's counter give bob 's counter bob 's counter give alice 's counter answer consider correct absolute relative error n't exceed 10 - 9 . first example bob 's counter a <unknown> % chance 3 a 25 % chance 4 a <unknown> % chance 5,"['dp', 'math']",2800.0
337/B,manao a monitor screen monitor horizontal vertical length ratio a : b. go watch a movie movie 's frame horizontal vertical length ratio c : d. manao adjust view a way movie preserve original frame ratio also occupy much space screen possible fit within completely thus may zoom movie manao always change frame proportionally dimension calculate ratio empty screen ( part screen occupy movie ) total screen size print answer irreducible fraction p / q. a single line contain four space - separated integers a b c d ( 1 ≤ a b c d ≤ 1000 ) print answer problem ` ` p / q '' p a non - negative integer q a positive integer number p q n't a common divisor larger 1 . sample 1 . manao 's monitor a square screen movie 3:2 horizontal vertical length ratio obviously movie occupy screen width picture coincide width screen case 2/3 monitor project movie horizontal dimension : sample 2 . time monitor 's width <unknown> time larger height movie 's frame square case picture must take whole monitor vertical dimension 3/4 horizontal dimension :,"['greedy', 'math', 'number theory']",1400.0
337/E,"a divisor tree a root tree meet follow condition : manao n distinct integers a1 a2 ... , try build a divisor tree contain number , ai least one vertex tree contain ai manao love compact style tree large help manao determine minimum possible number vertices divisor tree seek first line contain a single integer n ( 1 ≤ n ≤ 8 ) second line contain n distinct space - separated integers ai ( 2 ≤ ai ≤ 1012 ) print a single integer — minimum number vertices divisor tree contain number ai sample 1 . smallest divisor tree look way : sample 2 . case build follow divisor tree : sample 3 . note tree consist a single vertex","['brute force', 'number theory', 'trees']",2200.0
34/A,n soldier stand a circle soldier height ai know a reconnaissance unit make two neighbour soldier whose heights difference minimal i.e |ai - <unknown> minimal less <unknown> output pair soldier form a reconnaissance unit first line contain integer n ( 2 ≤ n ≤ 100 ) — amount soldier follow heights soldier order circle — n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 1000 ) soldier heights give clockwise counterclockwise direction output two integers — index neighbour soldier form a reconnaissance unit many optimum solutions output remember soldier stand a circle,['implementation'],800.0
34/B,bob get a sale old tv set n tv set sale tv set index i cost ai <unknown> tv set a negative price — owners ready pay bob buy useless <unknown> bob « buy » tv set want though 's strong bob carry m tv set desire go sale second time please help bob find maximum sum money earn first line contain two space - separated integers n m ( 1 ≤ m ≤ n ≤ 100 ) — amount tv set sale amount tv set bob carry follow line contain n space - separated integers ai ( - 1000 ≤ ai ≤ 1000 ) — price tv set output number — maximum sum money bob earn give carry m tv set,"['greedy', 'sortings']",900.0
340/B,iahub draw a set n point cartesian plane call ` ` special point '' a quadrilateral a simple polygon without self - intersections four side ( also call edge ) four vertices ( also call corner ) please note a quadrilateral n't convex a special quadrilateral one four vertices set special point give set special point please calculate maximal area a special quadrilateral first line contain integer n ( 4 ≤ n ≤ 300 ) next n line contain two integers : xi yi ( - 1000 ≤ xi yi ≤ 1000 ) — cartesian coordinate ith special point guarantee three point line guarantee two point coincide output a single real number — maximal area a special quadrilateral answer consider correct absolute relative error does't exceed 10 - 9 . test example choose first 4 point vertices quadrilateral form a square side 4 area <unknown> = 16,"['brute force', 'geometry']",2100.0
340/D,iahub recently learn bubble sort algorithm use sort a permutation n elements a1 a2 ... ascend order bore simple algorithm invent graph graph ( let 's call g ) initially n vertices 0 edge bubble sort execution edge appear describe follow algorithm ( pseudocode ) a graph independent set a set vertices a graph two adjacent ( edge vertices independent set ) a maximum independent set independent set maximum cardinality give permutation find size maximum independent set graph g use permutation <unknown> a procedure <unknown> first line input contain integer n ( 2 ≤ n ≤ 105 ) next line contain n distinct integers a1 a2 ... ( 1 ≤ ai ≤ n ) output a single integer — answer problem consider first example bubble sort swap elements 3 1 . add edge ( 1 3 ) permutation [ 1 3 2 ] bubble sort swap elements 3 2 . add edge ( 2 3 ) permutation sort a graph 3 vertices 2 edge ( 1 3 ) ( 2 3 ) maximal independent set [ 1 2 ],"['binary search', 'data structures', 'dp']",1500.0
342/B,xenia vigorous detective face n ( n ≥ 2 ) foreign spy line a row 'll consider spy number 1 n leave right spy s important note pass note spy f. xenia <unknown> spy several step one step spy keep important note pass note one neighbour row word spy 's number x pass note another spy either x - 1 x + 1 ( x = 1 x = n spy one neighbour ) also a step spy keep a note pass anyone nothing easy m step xenia watch spy attentively specifically step ti ( step number 1 ) xenia watch spy number li li + 1 li + 2 ... ri ( 1 ≤ li ≤ ri ≤ n ) course step a spy watch ca n't anything : neither give note take spy otherwise xenia reveal spy ' cunning plot nevertheless spy current step keep note xenia see nothing suspicious even watch ' ve get s f. also step xenia watch spy spy go watch step find best way spy act order pass note spy s spy f quickly possible ( minimum number step ) first line contain four integers n m s f ( 1 ≤ n m ≤ 105 ; 1 ≤ s f ≤ n ; s ≠ f ; n ≥ 2 ) follow m line contain three integers ti li ri ( 1 ≤ ti ≤ 109 1 ≤ li ≤ ri ≤ n ) guarantee t1 < t2 < t3 < ... < tm print k character a line : i - th character line must represent spy ' action step i. step i spy note must pass note spy a lesser number i - th character equal ` ` l '' step i spy note must pass spy a larger number i - th character must equal ` ` r '' spy must keep note i - th step i - th character must equal ` ` x '' a result apply print sequence action spy s must pass note spy f. number print character k must small possible xenia must catch spy pass note <unknown> optimal solutions print guarantee answer exist,"['brute force', 'greedy', 'implementation']",1500.0
343/B,mad scientist mike finish construct a new device search extraterrestrial intelligence ! a hurry launch first time plug power wire without give a proper glance start experiment right away a mike observe wire end entangle untangle device power two wire ` ` plus '' ` ` minus '' wire run along floor wall ( leave ) device ( right ) wall device two contact level wire plug order wire consider entangle one place one wire run one example picture four place ( top view ) : mike know sequence wire run mike also notice leave side ` ` plus '' wire always plug top contact ( see picture ) would like untangle wire without unplug without move device determine possible a wire freely move stretch floor cut understand problem better please read note test sample single line input contain a sequence character ` ` + '' ` ` - '' length n ( 1 ≤ n ≤ 100000 ) i - th ( 1 ≤ i ≤ n ) position sequence contain character ` ` + '' i - th step wall ` ` plus '' wire run ` ` minus '' wire character ` ` - '' otherwise print either ` ` yes '' ( without quote ) wire untangle ` ` '' ( without quote ) wire untangle first testcase correspond picture statement untangle wire one first move ` ` plus '' wire lower thus eliminate two cross middle draw ` ` minus '' wire eliminate also remain two cross second testcase ` ` plus '' wire make one full revolution around ` ` minus '' wire thus wire untangle : third testcase ` ` plus '' wire simply run ` ` minus '' wire twice sequence wire untangle lift ` ` plus '' move higher : fourth testcase ` ` minus '' wire run ` ` plus '' wire wire untangle without move device :,"['data structures', 'greedy', 'implementation']",1600.0
344/A,mad scientist mike entertain arrange row dominoes n't need dominoes though : use rectangular magnets instead magnet two pole positive ( a ` ` plus '' ) negative ( a ` ` minus '' ) two magnets put together a close distance like pole repel opposite pole attract mike start lay one magnet horizontally table follow step mike add one magnet horizontally right end row depend mike put magnet table either attract previous one ( form a group multiple magnets link together ) repel ( mike lay magnet distance right previous one ) assume a sole magnet link others form a group mike arrange multiple magnets a row determine number group magnets form first line input contain integer n ( 1 ≤ n ≤ 100000 ) — number magnets n line follow i - th line ( 1 ≤ i ≤ n ) contain either character ` ` 01 '' mike put i - th magnet ` ` plus - minus '' position character ` ` 10 '' mike put magnet ` ` minus - plus '' position single line output print number group magnets first testcase correspond figure testcase three group consist three one two magnets second testcase two group consist two magnets,['implementation'],800.0
344/B,mad scientist mike busy carry experiment chemistry today attempt join three atoms one molecule a molecule consist atoms pair atoms connect atomic bond atom a valence number — number bond atom must form atoms atom form one multiple bond atom form a bond number bond atom molecule must equal valence number mike know valence number three atoms find a molecule build atoms accord state rule determine impossible single line input contain three space - separated integers a b c ( 1 ≤ a b c ≤ 106 ) — valence number give atoms a molecule build print three space - separated integers — number bond 1 - st 2 - nd 2 - nd 3 - rd 3 - rd 1 - st atoms correspondingly multiple solutions output solution print ` ` impossible '' ( without quote ) first sample correspond first figure bond atoms 1 2 case second sample correspond second figure one bond pair atoms third sample correspond third figure solution atom form bond configuration fourth figure impossible atom must least one atomic bond,"['brute force', 'graphs', 'math']",1200.0
346/B,mathematics a subsequence a sequence derive another sequence delete elements without change order remain elements example sequence <unknown> a subsequence abcdef a substring a string a continuous subsequence string example bcd a substring abcdef give two string s1 s2 another string call virus task find longest common subsequence s1 s2 n't contain virus a substring input contain three string three separate line : s1 s2 virus ( 1 ≤ |s1| |s2| <unknown> ≤ 100 ) string consist uppercase english letter output longest common subsequence s1 s2 without virus a substring multiple answer accept valid common subsequence output 0,"['dp', 'strings']",2000.0
346/C,give a sequence positive integers x1 x2 ... xn two non - negative integers a b. task transform a b. perform follow move : operation a mod xi mean take remainder division number a number xi want know minimum number move need transform a b. first line contain a single integer n ( 1 ≤ n ≤ 105 ) second line contain n space - separated integers x1 x2 ... xn ( 2 ≤ xi ≤ 109 ) third line contain two integers a b ( 0 ≤ b ≤ a ≤ 109 a - b ≤ 106 ) print a single integer — require minimum number move need transform number a number b,"['greedy', 'math']",2200.0
35/D,upon a time dravde outstanding person famous professional achievements ( must remember work a warehouse store ogudar - olok a magical non - alcoholic drink ) come home a hard day day drink <unknown> box drink come home go bed dravde dream manage a successful farm dream every day one animal come ask let settle however dravde <unknown> kind could send animal away go reject exactly n days dravde ’ s dream animal come i - th day eat exactly ci tons food daily start day i. one day animal could get food need get really sad begin dream exactly x tons food farm dravde wake terrify ... <unknown> dream ’ t remember many animals farm end n - th day remember nobody get sad ( a happy farm ) maximum possible amount animals ’ s number want find notice animals arrive morning dravde start fee afternoon animal will join reject ’ t eat farm food animal join farm eat daily day n - th first input line contain integers n x ( 1 ≤ n ≤ 100 1 ≤ x ≤ 104 ) — amount days dravde ’ s dream total amount food ( tons ) initially second line contain integers ci ( 1 ≤ ci ≤ 300 ) number second line divide a space output number — maximum possible amount animals farm end n - th day give food enough everybody note first example : dravde leave second third animal farm second animal eat one ton food second day one ton third day third animal eat one ton food third day,"['dp', 'greedy']",1700.0
351/D,"<unknown> a sequence consist n integers : a1 a2 ... , jeff perform follow operation sequence a : a beauty a sequence a minimum number operations need delete elements sequence a. jeff 's write a sequence m integers b1 b2 ... bm want ask q question question describe two integers li ri answer question beauty sequence bli bli + 1 ... <unknown> give sequence b question help jeff answer question first line contain integer m ( 1 ≤ m ≤ 105 ) next line contain m integers b1 b2 ... bm ( 1 ≤ bi ≤ 105 ) third line contain integer q ( 1 ≤ q ≤ 105 ) — number question next q line contain pair integers i - th contain a pair integers li ri ( 1 ≤ li ≤ ri ≤ m ) — description i - th question q line print answer jeff 's query print answer accord order question input",['data structures'],2700.0
351/E,jeff 's friends know full well boy like get sequence array birthday thus jeff get sequence p1 p2 ... pn birthday jeff hat inversions sequence inversion sequence a1 a2 ... a pair index i j ( 1 ≤ i < j ≤ n ) inequality ai > aj hold jeff multiply number sequence p -1 . want number inversions sequence minimum help jeff find minimum number inversions manage get first line contain integer n ( 1 ≤ n ≤ 2000 ) next line contain n integers — sequence p1 p2 ... pn ( |pi| ≤ 105 ) number separate space a single line print answer problem — minimum number inversions jeff get,['greedy'],2200.0
352/B,"one day jeff get hold integer sequence a1 a2 ... length n. boy immediately decide analyze sequence , need find value x condition hold : help jeff find x meet problem condition first line contain integer n ( 1 ≤ n ≤ 105 ) next line contain integers a1 a2 ... ( 1 ≤ ai ≤ 105 ) number separate space first line print integer t — number valid x. next t line print two integers x px x current suitable value px common difference number progression ( x occur exactly sequence px must equal 0 ) print pair order increase x. first test 2 occur exactly sequence ergo p2 = 0","['implementation', 'sortings']",1300.0
353/C,valera array a consist n integers a0 a1 ... - 1 function f ( x ) take integer 0 2n - 1 single argument value f ( x ) calculate formula value bite ( i ) equal one binary representation number x contain a 1 i - th position zero otherwise example n = 4 x = 11 ( 11 = 20 + 21 + 23 ) f ( x ) = a0 + a1 + a3 help valera find maximum function f ( x ) among x inequality hold : 0 ≤ x ≤ m. first line contain integer n ( 1 ≤ n ≤ 105 ) — number array elements next line contain n space - separated integers a0 a1 ... - 1 ( 0 ≤ ai ≤ 104 ) — elements array a. third line contain a sequence digits zero one without space s0s1 ... sn - 1 — binary representation number m. number m equal print a single integer — maximum value function f ( x ) first test case m = 20 = 1 f ( 0 ) = 0 f ( 1 ) = a0 = 3 . second sample m = 20 + 21 + 23 = 11 maximum value function equal f ( 5 ) = a0 + a2 = 17 + 10 = 27,"['implementation', 'math', 'number theory']",1600.0
353/E,a direct acyclic graph g consist n vertexes number 0 n - 1 . graph contain n edge number 0 n - 1 . edge number i connect vertexes i ( i + 1 ) mod n direct either direction ( i ( i + 1 ) mod n vise versa ) operation x mod y mean take remainder divide number x number y. let 's call two vertexes u v graph g comparable graph contain a path either u v v u. 'll assume antichain a set vertexes graph g two distinct vertexes comparable size antichain number vertexes correspond set antichain maximum graph n't <unknown> a larger size task find size maximum antichain graph g. first line contain sequence character s0s1 ... sn - 1 ( 2 ≤ n ≤ 106 ) consist number zero one length line ( number n ) correspond number vertexes edge graph g. character si ( i ≥ 0 ) equal 0 edge vertexes i ( i + 1 ) mod n direct i - th vertex ( i + 1 ) mod n - th one otherwise — opposite point guarantee give graph acyclic print a single integer — size maximum antichain graph g. consider first test sample graph 's g edge : 0 → 1 1 → 2 0 → 2 . choose set vertexes [ 0 ] maximum antichain choose antichain larger size,"['dp', 'greedy']",2200.0
354/C,vasya 's get a birthday come mom decide give array positive integers a length n. vasya think array 's beauty greatest common divisor elements mom course want give beautiful array possible ( largest possible beauty ) unfortunately shop one array a leave plus side seller say could decrease number array ( k number ) seller obtain array b array a follow condition hold : bi > 0 ; 0 ≤ ai - bi ≤ k 1 ≤ i ≤ n. help mom find maximum possible beauty array give vasya ( seller obtain ) first line contain two integers n k ( 1 ≤ n ≤ 3·105 ; 1 ≤ k ≤ 106 ) second line contain n integers ai ( 1 ≤ ai ≤ 106 ) — array a. single line print a single number — maximum possible beauty result array first sample obtain <unknown> 6 9 12 12 15 in second sample obtain next <unknown> 21 49 14 77,"['brute force', 'dp', 'number theory']",2100.0
356/E,xenia coder go olympiad informatics get a string problem unfortunately xenia n't fabulous string algorithms help solve problem string s a sequence character s1s2 ... s|s| record |s| show length string substring s [ i ... j ] string s string sisi + 1 ... sj string s a gray string meet condition : example string ` ` abacaba '' ` ` <unknown> '' ` ` g '' gray string string ` ` aaa '' ` ` xz '' ` ` <unknown> '' beauty string p sum square lengths substrings string p gray string word consider pair value i j ( 1 ≤ i ≤ j ≤ |p| ) substring p [ i ... j ] a gray string add ( j - i + 1 ) 2 beauty xenia get string t consist lowercase english letter allow replace one letter string english letter task get a string maximum beauty first line contain a non - empty string t ( 1 ≤ |t| ≤ 105 ) string t consist lowercase english letter print seek maximum beauty value xenia get please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first test sample give string transform string p = ` ` <unknown> '' string contain gray string substrings p [ 1 ... 1 ] p [ 2 ... 2 ] p [ 3 ... 3 ] и p [ 1 ... 3 ] total beauty string p get equal 12 + 12 + 12 + 32 = 12 . ca n't obtain a beautiful string second test case necessary perform operation initial string maximum possible beauty,"['dp', 'implementation', 'strings']",3000.0
358/B,seryozha a <unknown> character time refuse leave room dima girlfriend ( <unknown> inna way ) however two <unknown> always find a way communicate today write text message dima inna use a secret code text message dima want send inna sentence write word insert a heart word last word a heart a sequence two character : ` ` less '' character ( < ) digit three ( 3 ) apply code a test message look like : < <unknown> < <unknown> < 3 ... <unknown> < 3 encode n't end dima insert a random number small english character digits sign ` ` '' ` ` less '' place message inna know dima perfectly well know phrase dima go send beforehand inna get a text message help find dima encode message correctly word find a text message could receive encode manner describe first line contain integer n ( 1 ≤ n ≤ 105 ) — number word dima 's message next n line contain non - empty word one word per line word consist small english letter total length word n't exceed 105 . last line contain non - empty text message inna get number character text message n't exceed 105 . a text message contain small english letter digits sign less a single line print ` ` yes '' ( without quote ) dima decode text message correctly ` ` '' ( without quote ) otherwise please note dima get a good old kick pant second sample statement,"['brute force', 'strings']",1500.0
359/D,"simon array a1 a2 ... , consist n positive integers today simon ask find a pair integers l r ( 1 ≤ l ≤ r ≤ n ) follow condition hold : help simon find require pair number ( l r ) multiple require pair find first line contain integer n ( 1 ≤ n ≤ 3·105 ) second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 106 ) print two integers first line — number require pair maximum value r - l. follow line print l value optimal pair increase order first sample pair number right number 6 9 3 divisible 3 . second sample number divisible number 1 . third sample number prime condition 1 2 true pair number ( 1 1 ) ( 2 2 ) ( 3 3 ) ( 4 4 ) ( 5 5 )","['binary search', 'brute force', 'data structures', 'math', 'two pointers']",2000.0
36/A,recently vasya get interest find extra - terrestrial intelligence make a simple extra - terrestrial signal ’ receiver keep a record signal n days a row n days vasya write a 1 notebook receive a signal day a 0 ’ t vasya think find extra - terrestrial intelligence a system way signal receive i.e intervals successive signal equal otherwise vasya think signal send stupid alien one care help vasya deduce information give receiver find extra - terrestrial intelligence first line contain integer n ( 3 ≤ n ≤ 100 ) — amount days vasya check signal second line contain n character 1 0 — record vasya keep n days ’ s guarantee give record sequence contain least three 1s vasya find extra - terrestrial intelligence output yes otherwise output,['implementation'],1300.0
36/B,ever since kalevitch a famous berland <unknown> hear fractals make main topic canvas every morning artist take a piece graph paper start make a model future canvas take a square big n × n square paint black take a clean square piece paper paint fractal use follow algorithm : step 1 . paper divide n2 identical square paint black accord model step 2 . every square remain white divide n2 smaller square paint black accord model every follow step repeat step 2 . unfortunately tiresome work demand much time paint genius kalevitch dream make process automatic move make 3d even 4d fractals first line contain integers n k ( 2 ≤ n ≤ 3 1 ≤ k ≤ 5 ) k amount step algorithm follow n line contain n symbols determine model symbol « . » stand a white square whereas « * » stand a black one guarantee model least one white square output a matrix nk × nk a picture look like k step algorithm,['implementation'],1600.0
36/C,petya a good mood decide help mum <unknown> - up n dirty bowl sink geometrical point view bowl look like a <unknown> cone disregard width wall bottom petya put clean bowl one another naturally i. e. vertical ax coincide ( see picture ) give order petya wash bowl determine height construction i.e distance bottom lowest bowl top highest one first input line contain integer n ( 1 ≤ n ≤ 3000 ) follow n line contain 3 integers h r r ( 1 ≤ h ≤ 10000 1 ≤ r < r ≤ 10000 ) height a bowl radius bottom radius top plat give order petya put table output height plate pile accurate least 10 - 6,"['geometry', 'implementation']",2200.0
360/B,"levko array consist integers : a1 a2 ... , ’ t like array levko think beauty array a directly depend value c ( a ) calculate formula : ’ s time change world levko go change array better exact levko want change value k array elements ( allow replace value integers ) course change make array beautiful possible help levko calculate minimum number c ( a ) reach first line contain two integers n k ( 1 ≤ k ≤ n ≤ 2000 ) second line contain space - separated integers a1 a2 ... ( - 109 ≤ ai ≤ 109 ) a single number — minimum value c ( a ) levko get first sample levko change second fourth elements get array : 4 4 4 4 4 . third sample get array : 1 2 3 4 5 6","['binary search', 'dp']",2000.0
361/A,levko love table consist n row n columns much especially love beautiful table a table beautiful levko sum elements row column table equal k. unfortunately n't know table task help find least one single line contain two integers n k ( 1 ≤ n ≤ 100 1 ≤ k ≤ 1000 ) print beautiful table levko n't like big number elements table must n't exceed 1000 absolute value multiple suitable table allow print first sample sum first row 1 + 3 = 4 second row — 3 + 1 = 4 first column — 1 + 3 = 4 second column — 3 + 1 = 4 . beautiful table sample second sample sum elements row column equal 7 . besides table meet statement requirements,['implementation'],800.0
365/B,"array a1 a2 ... , segment [ l r ] ( 1 ≤ l ≤ r ≤ n ) good ai = ai - 1 + ai - 2 i ( l + 2 ≤ i ≤ r ) let 's define len ( [ l r ] ) = r - l + 1 len ( [ l r ] ) length segment [ l r ] segment [ l1 r1 ] longer segment [ l2 r2 ] len ( [ l1 r1 ] ) > len ( [ l2 r2 ] ) task find a good segment maximum length array a. note a segment length 1 2 always good first line contain a single integer n ( 1 ≤ n ≤ 105 ) — number elements array second line contain integers : a1 a2 ... ( 0 ≤ ai ≤ 109 ) print length longest good segment array a",['implementation'],1100.0
367/B,"sereja two sequence a b number p. sequence a consist n integers a1 a2 ... , similarly sequence b consist m integers b1 b2 ... bm usual sereja study sequence today want find number position q ( q + ( m - 1 ) · p ≤ n ; q ≥ 1 ) sequence b obtain sequence aq aq + p aq + 2p ... aq + ( m - 1 ) p rearrange elements sereja need rush gym ask find describe position q. first line contain three integers n m p ( 1 ≤ n m ≤ 2·105 1 ≤ p ≤ 2·105 ) next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) next line contain m integers b1 b2 ... bm ( 1 ≤ bi ≤ 109 ) first line print number valid <unknown> second line print valid value increase order","['binary search', 'data structures']",1900.0
370/A,"little petya learn play chess already learn move a king a rook a bishop let us remind rule move chess piece a chessboard 64 square field organize 8 × 8 table a field represent a pair integers ( r c ) — number row number column ( a classical game columns traditionally index letter ) chess piece take exactly one field make a move move a chess piece piece move follow rule : petya think follow problem : minimum number move need piece move field ( r1 c1 ) field ( r2 c2 ) ? , assume piece besides one board help solve problem input contain four integers r1 c1 r2 c2 ( 1 ≤ r1 c1 r2 c2 ≤ 8 ) — coordinate start final field start field n't coincide final one assume chessboard row number top bottom 1 8 columns number leave right 1 8 . print three space - separated integers : minimum number move rook bishop king ( order ) need move field ( r1 c1 ) field ( r2 c2 ) a piece make a move print a 0 instead correspond number","['graphs', 'math', 'shortest paths']",1100.0
371/A,task exclusively concentrate array elements equal 1 and/or 2 . array a k - period length divisible k array b length k a represent array b write exactly time consecutively word array a k - periodic period length k. example array n - periodic n array length array [ 2 1 2 1 2 1 ] time 2 - periodic 6 - periodic array [ 1 2 1 1 2 1 1 2 1 ] time 3 - periodic 9 - periodic give array a consist number one two find minimum number elements change make array k - periodic array already k - periodic require value equal 0 . first line input contain a pair integers n k ( 1 ≤ k ≤ n ≤ 100 ) n length array value n divisible k. second line contain sequence elements give array a1 a2 ... ( 1 ≤ ai ≤ 2 ) ai i - th element array print minimum number array elements need change make array k - periodic array already k - periodic print 0 . first sample enough change fourth element 2 1 array change [ 2 1 2 1 2 1 ] second sample give array already 4 - periodic third sample enough replace occurrence number two number one case array look [ 1 1 1 1 1 1 1 1 1 ] — array simultaneously 1- 3- 9 - periodic,"['greedy', 'implementation', 'math']",1000.0
371/E,berland go tough time — dirt price drop a blow country 's economy everybody know berland top world dirt <unknown> ! president berland force leave k currently exist n subway station subway station locate a straight line one another train consecutively visit station move assume station ox axis i - th station point coordinate xi case distance station i j calculate a simple formula |xi - xj| currently ministry transport choose station close ones leave obviously residents capital wo n't enthusiastic innovation decide show best side people ministry transport want choose k station minimize average commute time subway ! assume train speed constant ( a fix value ) average commute time subway calculate sum pairwise distance station divide number pair ( ) divide speed train help minister transport solve difficult problem write a program give location station select k station average commute time subway minimize first line input contain integer n ( 3 ≤ n ≤ 3·105 ) — number station innovation second line contain coordinate station x1 x2 ... xn ( - 108 ≤ xi ≤ 108 ) third line contain integer k ( 2 ≤ k ≤ n - 1 ) — number station innovation station coordinate distinct necessarily sort print a sequence k distinct integers t1 t2 ... tk ( 1 ≤ tj ≤ n ) — number station leave innovation arbitrary order assume station number 1 n order give input number station print must minimum possible average commute time among possible ways choose k station multiple ways allow print sample testcase optimal answer destroy first station ( x = 1 ) average commute time equal 1 way,"['greedy', 'math', 'two pointers']",2000.0
372/B,n × m rectangular grid cell grid contain a single integer : zero one let 's call cell i - th row j - th column ( i j ) let 's define a ` ` rectangle '' four integers a b c d ( 1 ≤ a ≤ c ≤ n ; 1 ≤ b ≤ d ≤ m ) rectangle denote a set cells grid { ( x y ) : a ≤ x ≤ c b ≤ y ≤ d } let 's define a ` ` good rectangle '' a rectangle include cells zero answer follow q query : calculate number good rectangles cells give rectangle three integers first line : n m q ( 1 ≤ n m ≤ 40 1 ≤ q ≤ 3·105 ) next n line contain m character — grid consider grid row number top bottom grid columns number leave right columns row number start 1 . next q line contain a query — four integers describe current rectangle a b c d ( 1 ≤ a ≤ c ≤ n ; 1 ≤ b ≤ d ≤ m ) query output answer — a single integer a separate line first example a 5 × 5 rectangular grid first second third query represent follow image,"['brute force', 'divide and conquer', 'dp']",1900.0
372/C,a festival hold a town 's main street n section main street section number 1 n leave right distance adjacent section 1 . festival m fireworks launch i - th ( 1 ≤ i ≤ m ) launch time ti section ai section x ( 1 ≤ x ≤ n ) time i - th launch 'll gain happiness value bi - |ai - x| ( note happiness value might a negative value ) move d length units a unit time interval 's prohibit go main street also arbitrary section initial time moment ( time equal 1 ) want maximize sum happiness gain watch fireworks find maximum total happiness note two fireworks launch time first line contain three integers n m d ( 1 ≤ n ≤ 150000 ; 1 ≤ m ≤ 300 ; 1 ≤ d ≤ n ) next m line contain integers ai bi ti ( 1 ≤ ai ≤ n ; 1 ≤ bi ≤ 109 ; 1 ≤ ti ≤ 109 ) i - th line contain description i - th launch guarantee condition ti ≤ ti + 1 ( 1 ≤ i < m ) satisfy print a single integer — maximum sum happiness gain watch fireworks please write % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier,"['data structures', 'dp', 'math']",2100.0
372/D,a tree consist n vertices vertices number 1 n. let 's define length interval [ l r ] value r - l + 1 . score a subtree tree maximum length interval [ l r ] vertices number l l + 1 ... r belong subtree consider subtrees tree whose size k return maximum score subtree note problem tree root a subtree — arbitrary connect subgraph tree two integers first line n k ( 1 ≤ k ≤ n ≤ 105 ) next n - 1 line contain integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) mean ai bi connect a tree edge guarantee input represent a tree output contain a single integer — maximum possible score first case subtree whose size 6 include 3 consecutive number vertices example subtree consist { 1 3 4 5 7 8 } { 1 4 6 7 8 10 } include 3 consecutive number vertices subtree whose size 6 include 4 consecutive number vertices,"['binary search', 'data structures', 'dfs and similar', 'trees', 'two pointers']",2600.0
374/C,"inna dima buy a table size n × m shop cell table contain a single letter : ` ` d '' ` ` i '' ` ` m '' ` ` a '' inna love dima want go name many time possible move table , inna act follow : depend choice initial table cell inna go name dima either infinite number time positive finite number time ca n't go name help inna find maximum number time go name dima first line input contain two integers n m ( 1 ≤ n m ≤ 103 ) follow n line describe inna dima 's table line contain m character character one follow four character : ` ` d '' ` ` i '' ` ` m '' ` ` a '' note guarantee table contain least one letter ` ` d '' inna go name dima print a single line ` ` poor dima ! '' without quote infinite number name dima inna go print ` ` poor inna ! '' without quote otherwise print a single integer — maximum number time inna go name dima note sample : first test sample inna go name dima a single time second test sample inna go infinite number word dima , move clockwise direction start lower right corner third test sample best strategy start cell upper leave corner table start cell inna go name dima four time","['dfs and similar', 'dp', 'graphs', 'implementation']",1900.0
379/D,many countries a new year christmas tradition write a letter santa include a wish list present vasya ordinary programmer boy like ordinary boys go write letter santa new year eve ( russians actually expect santa new year christmas ) vasya come algorithm follow write a letter first choose two string s1 <unknown> s2 consist uppercase english letter boy make string sk use a recurrent equation sn = sn - 2 + sn - 1 operation ' + ' mean a concatenation ( sequential record ) string give order vasya write string sk a piece paper put envelope send santa vasya absolutely sure santa bring best present result string sk exactly x occurrences substring ac ( short - cut remind оf accept problems ) besides vasya decide string s1 length n string s2 length m. vasya n't decide anything else moment vasya 's get urgent new year business ask choose two string s1 s2 require manner help vasya first line contain four integers k x n m ( 3 ≤ k ≤ 50 ; 0 ≤ x ≤ 109 ; 1 ≤ n m ≤ 100 ) first line print string s1 consist n uppercase english letter second line print string s2 consist m uppercase english letter multiple valid string print require pair string n't exist print ` ` happy new year ! '' without quote,"['bitmasks', 'brute force', 'dp']",2000.0
379/E,"due <unknown> soviet past christmas n't <unknown> celebrate russia <unknown> century a result russian traditions christmas new year mix one event celebrate new year include tree a santa - like ' grandfather frost ' present huge family <unknown> dinner party country <unknown> a tree new year instal house a tradition usually whole family decorate tree new year eve hope codeforces a big love family problem go decorate a tree well , decoration consist n piece piece a piece color paper border a close polyline a special shape piece go one one show picture i - th piece a polyline go point : ( 0 0 ) ( 0 y0 ) ( 1 y1 ) ( 2 y2 ) ... ( k yk ) ( k 0 ) width piece equal k. piece number 1 ( show red figure ) outer piece ( see completely ) piece number 2 ( show yellow ) follow ( n't see completely partially close first piece ) programmers quite curious guy moment hang a decoration new year tree start wonder : area piece people see ? first line contain two integers n k ( 1 ≤ n k ≤ 300 ) follow n line contain k + 1 integers — description polyline i - th line contain <unknown> yi 0 yi 1 ... yi k mean polyline i - th piece go point ( 0 0 ) ( 0 yi 0 ) ( 1 yi 1 ) ( 2 yi 2 ) ... ( k yi k ) ( k 0 ) ( 1 ≤ yi j ≤ 1000 ) print n real number — polyline area visible part answer consider correct relative absolute error exceed 10 - 4","['geometry', 'sortings']",2500.0
38/D,"vasya play bricks bricks set regular cubical shape vasya <unknown> a talented architect however tower build keep fall apart let us consider build process vasya take a brick put top already build tower side brick parallel side bricks already use let 's introduce a cartesian coordinate system horizontal plane vasya put first brick projection brick number i plane a square side parallel ax coordinate opposite corner point ( xi 1 yi 1 ) ( xi 2 yi 2 ) bricks cast <unknown> plastic weight a brick a × a × a a3 grams guarantee vasya put brick except first one previous one area intersection upper side previous brick lower side next brick always positive ( vasya include ) live a normal world laws physical <unknown> work , perhaps put yet another brick tower collapse weight vasya put cub consecutively one top least one cube lose balance fall happen vasya get upset stop construction print number bricks maximal stable tower maximal number m satisfy condition tower consist bricks 1 2 ... k every integer k 1 m remain stable first input file contain integer n ( 1 ≤ n ≤ 100 ) number bricks next n line contain four number xi 1 yi 1 xi 2 yi 2 ( xi 1 ≠ xi 2 |xi 1 - xi 2| = |yi 1 - yi 2| ) coordinate opposite angle base brick number i. coordinate integers absolute value exceed 50 . cub give order vasya put guarantee area intersection upper side brick number i - 1 lower side brick number i strictly strictly greater zero i ≥ 2 . print number bricks maximal stable tower",['implementation'],1900.0
38/F,petya vasya invent a new game call ` ` smart boy '' locate a certain set word — dictionary — game admissible dictionary contain similar word rule game follow : first first player choose letter ( a word long 1 ) word dictionary write a piece paper second player add letter one 's initial final position thus make a word long 2 's first player 's turn add a letter begin end thus make a word long 3 player must n't break one condition : newly create word must a substring a word a dictionary player ca n't add a letter current word without break condition lose also end a turn a certain string s write paper player whose turn get a number point accord formula : task learn win game final score every player play optimally try win — maximize number point — minimize number point opponent first input line contain integer n number word locate dictionary ( 1 ≤ n ≤ 30 ) n line contain word dictionary — one word write one line line nonempty consist latin lower - case character longer 30 character equal word list word first output line print a line ` ` first '' ` ` second '' mean win game second line output number point first player number point second player game end separate number a single space,"['dp', 'strings']",2100.0
380/E,let 's assume a sequence double a1 a2 ... a|a| a double variable x. allow perform follow two - <unknown> operation : let 's use function g ( a x ) represent largest value obtain variable x use describe operation number time sequence a. sereja sequence b1 b2 ... b|b| help sereja calculate sum : record [ bi bi + 1 ... bj ] represent a sequence contain elements bracket give order avoid problems precision please print require sum divide |b|2 first line contain integer |b| ( 1 ≤ |b| ≤ 3·105 ) — length sequence b. second line contain |b| integers b1 b2 ... b|b| ( 1 ≤ bi ≤ 105 ) a single line print a real number — require sum divide |b|2 answer consider correct absolute relative error wo n't exceed 10 - 6,['data structures'],2600.0
381/B,sereja love integer sequence much especially like stairs sequence a1 a2 ... a|a| ( |a| length sequence ) stairs index i ( 1 ≤ i ≤ |a| ) follow condition meet : example sequence [ 1 2 3 2 ] [ 4 2 ] stairs sequence [ 3 1 2 ] n't sereja m card number want put card table a row get a stair sequence maximum number card put table ? first line contain integer m ( 1 ≤ m ≤ 105 ) — number sereja 's card second line contain m integers bi ( 1 ≤ bi ≤ 5000 ) — number sereja 's card first line print number card put table second line print result stairs,"['greedy', 'implementation', 'sortings']",1100.0
382/D,ksenia a chessboard size n × m. cell chessboard contain one character : ` ` < ` ` ` ` > '' ` ` ^ '' ` ` v '' ` ` # '' cells contain character ` ` # '' block know chessboard cells touch border block ksenia play two pawn chessboard initially put pawn chessboard one cell chessboard contain two pawn cell block case two pawn stand one cell game begin ksenia put pawn board one move ksenia move pawn a side adjacent cell direction arrows paint cell correspond pawn sit ( pawn sit ` ` # '' move ) assume ksenia move pawn simultaneously ( see second test case ) course ksenia play point one calculate point per game ? simply ! let 's count many movements first pawn make many movements second pawn make sum two number — result score game ksenia wonder : maximum number point earn ( place pawn optimally well early game ) help find number first line contain two integers n m ( 1 ≤ n m ≤ 2000 ) — size board follow n line contain m character – board 's description character one character : ` ` < ` ` ` ` > '' ` ` ^ '' ` ` v '' ` ` # '' guarantee border cells table block cells ( character ` ` # '' ) ksenia get infinitely many point print -1 . otherwise print maximum number point get,"['dfs and similar', 'graphs', 'implementation', 'trees']",2200.0
383/A,"iahub help grandfather farm today must milk cow n cow sit a row number 1 n leave right cow either face leave face right iahub milk a cow cow see current cow get scar lose one unit quantity milk give a cow face leave see cow lower indices index a cow face right see cow higher indices index a cow get scar get scar ( lose one unit milk ) a cow milk get scar lose milk assume a cow never lose milk give ( a cow give infinitely amount milk ) iahub decide order milk cow must milk cow exactly iahub want lose little milk possible print minimum amount milk lose first line contain integer n ( 1 ≤ n ≤ 200000 ) second line contain n integers a1 a2 ... , ai 0 cow number i face leave 1 face right print a single integer minimum amount lose milk please write % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first sample iahub milk cow follow order : cow 3 cow 4 cow 2 cow 1 . milk cow 3 cow 4 lose 1 unit milk , milk lose","['data structures', 'greedy']",1600.0
384/A,iahub like chess much even invent a new chess piece name coder a coder move ( attack ) one square horizontally vertically precisely coder locate position ( x y ) move ( attack ) position ( x + 1 y ) ( <unknown> y ) ( x y + 1 ) ( x <unknown> ) iahub want know many coders place n × n chessboard coder attack coder first line contain integer n ( 1 ≤ n ≤ 1000 ) first line print integer maximum number coders place chessboard next n line print n character describe configuration coders empty cell print ' ' a coder print a ' c ' multiple correct answer print,['implementation'],800.0
386/D,play follow game n point a plane vertices a regular n - polygon point label integer number 1 n. pair distinct point connect a diagonal color one 26 color point denote lowercase english letter three stone position three distinct vertices stone one move move stone another free vertex along diagonal color diagonal must color diagonal connect another two stone goal move stone way vertices occupy stone 1 2 3 . must achieve position use minimal number move write a program play game optimal way first line one integer n ( 3 ≤ n ≤ 70 ) — number point second line three space - separated integer 1 n — number vertices stone initially locate follow n line contain n symbols — matrix denote color diagonals color denote lowercase english letter symbol j line i denote color diagonal point i j. matrix symmetric j - th symbol i - th line equal i - th symbol j - th line main diagonal fill ' * ' symbols diagonal connect point way put stone vertices 1 2 3 print -1 a single line otherwise first line print minimal require number move next line print description move one move per line describe a move print two integers point remove stone point move stone several optimal solutions print first example move stone point 4 point 1 point connect diagonal color ' a ' diagonal connection point 2 3 stone locate connect diagonal color stone point 1 2 3,"['dp', 'graphs', 'implementation', 'shortest paths']",2100.0
387/A,"george wake saw current time s digital clock besides george know sleep time t. help george ! write a program give time s t determine time p george go bed note george could go bed yesterday relatively current time ( see second test sample ) first line contain current time s a string format ` ` hh : mm '' second line contain time t format ` ` hh : mm '' — duration george 's sleep guarantee input contain correct time 24 - hour format , 00 ≤ hh ≤ 23 00 ≤ mm ≤ 59 . single line print time p — time george go bed format similar format time input first sample george go bed ` ` 00:06 '' note print time format ` ` 00:06 '' 's answer ` ` <unknown> '' ` ` <unknown> '' others consider incorrect second sample george go bed yesterday third sample george n't bed",['implementation'],900.0
387/C,george a cat really like play like play array positive integers b. game george modify array use special change let 's mark george 's current array b1 b2 ... b|b| ( record |b| denote current length array ) one change a sequence action : george play a long time array b receive array b array consist exactly one number p. george want know : maximum number elements array b could contain originally ? help find number note originally array could contain positive integers first line input contain a single integer p ( 1 ≤ p < 10100000 ) guarantee number p n't contain lead zero print integer — maximum number elements array b could contain originally let 's consider test examples : note number large,"['greedy', 'implementation']",1700.0
4/B,"tomorrow peter a biology exam like subject much d days ago learn would take exam peter 's strict parent make prepare exam immediately purpose study less mintimei maxtimei hours per i - th day moreover warn peter a day exam would check follow instructions , today day peter 's parent ask show timetable <unknown> study boy count sum hours sumtime spend preparation want know show parent a timetable sсhedule d number number <unknown> stand time hours spend peter i - th day biology study satisfy limitations impose parent time sum total <unknown> equal sumtime first input line contain two integer number d sumtime ( 1 ≤ d ≤ 30 0 ≤ sumtime ≤ 240 ) — amount days peter study total amount hours spend preparation follow d line contain two integer number mintimei maxtimei ( 0 ≤ mintimei ≤ maxtimei ≤ 8 ) separate a space — minimum maximum amount hours peter could spend i - th day first line print yes second line print d number ( separate a space ) number — amount hours spend peter preparation correspond day follow parent ' instructions ; print unique line many solutions print",['greedy'],1200.0
401/A,vanya love play even a special set card play card a single integer number card positive negative even equal zero limit number card n't exceed x absolute value natasha n't like vanya spend a long time play hide card vanya become sad start look card find n vanya love balance want sum number find card equal zero hand get tire look card help boy say minimum number card need find make sum equal zero ? assume initially vanya infinitely many card integer number - x x. first line contain two integers : n ( 1 ≤ n ≤ 1000 ) — number find card x ( 1 ≤ x ≤ 1000 ) — maximum absolute value number a card second line contain n space - separated integers — number find card guarantee number exceed x absolute value print a single number — answer problem first sample vanya need find a single card number -2 . second sample vanya need find two card number 2 . ca n't find a single card require number number lose card exceed 3 absolute value,"['implementation', 'math']",800.0
401/B,sereja a coder like take part codesorfes round however uzhland n't good internet connection sereja sometimes skip round codesorfes round two type : div1 ( advance coders ) div2 ( beginner coders ) two round div1 div2 go simultaneously ( div1 round hold without div2 ) case round n't overlap time round a unique identifier — a positive integer round sequentially ( without gap ) number identifiers start time round identifiers round run simultaneously different one also identifier div1 round always greater sereja a beginner coder take part round div2 type moment take part a div2 round identifier equal x. sereja remember well take part exactly k round round also remember identifiers round take part identifiers round go simultaneously sereja n't remember anything round miss sereja wonder : minimum maximum number div2 round could miss ? help find two number first line contain two integers : x ( 1 ≤ x ≤ 4000 ) — round sereja take part today k ( 0 ≤ k < 4000 ) — number round take part next k line contain descriptions round sereja take part sereja take part one two simultaneous round correspond line look like : ` ` 1 num2 num1 '' ( num2 identifier div2 round num1 identifier div1 round ) guarantee num1 - num2 = 1 . sereja take part a usual div2 round correspond line look like : ` ` 2 num '' ( num identifier div2 round ) guarantee identifiers give round less x. print a single line two integers — minimum maximum number round sereja could miss second sample unused identifiers round 1 6 7 . minimum number round sereja could miss equal 2 . case round identifier 1 a usual div2 round round identifier 6 <unknown> div1 round maximum number round equal 3 . case unused identifiers belong usual div2 round,"['greedy', 'implementation', 'math']",1200.0
402/A,a nut lot box box a wonderful feature : put x ( x ≥ 0 ) divisors ( <unknown> bar divide a box ) get a box divide x + 1 section minimalist therefore one hand divide box k section hand put v nut section box minimum number box use want put nut box b divisors ? please note need minimize number use box section minimize number use divisors first line contain four space - separated integers k a b v ( 2 ≤ k ≤ 1000 ; 1 ≤ a b v ≤ 1000 ) — maximum number section box number nut number divisors capacity section box print a single integer — answer problem first sample act like : end ' ve put ten nut box second sample different exactly one divisor put first box next two box one section,"['greedy', 'math']",1100.0
402/E,matrix a size n × n. let 's number row matrix 1 n top bottom let 's number columns 1 n leave right let 's use aij represent element intersection i - th row j - th column matrix a meet follow two condition : matrix b strictly positive number i j ( 1 ≤ i j ≤ n ) inequality bij > 0 hold task determine integer k ≥ 1 matrix ak strictly positive first line contain integer n ( 2 ≤ n ≤ 2000 ) — number row columns matrix a. next n line contain description row matrix a. i - th line contain n non - negative integers ai1 ai2 ... ( 0 ≤ aij ≤ 50 ) guarantee a positive integer k ≥ 1 matrix ak strictly positive print ` ` yes '' ( without quote ) otherwise print ` ` '' ( without quote ),"['graphs', 'math']",2200.0
403/E,two root undirected tree contain n vertices let 's number vertices tree integers 1 n. root tree vertex 1 . edge first tree paint blue edge second one paint red simplicity let 's say first tree blue second tree red edge { x y } call bad edge { p q } two condition fulfil : problem task simulate process describe process consist several stag : stage delete edge determine edge remove stage note definition a bad edge always consider initial tree edge remove first line contain integer n ( 2 ≤ n ≤ 2·105 ) — number vertices tree next line contain n - 1 positive integers a2 a3 ... ( 1 ≤ ai ≤ n ; ai ≠ i ) — description edge first tree number ai mean first tree edge connect vertex ai vertex i. next line contain n - 1 positive integers b2 b3 ... bn ( 1 ≤ bi ≤ n ; bi ≠ i ) — description edge second tree number bi mean second tree edge connect vertex bi vertex i. next line contain integer idx ( 1 ≤ idx < n ) — index blue edge remove first stage assume edge tree number number 1 n - 1 order give input stage remove edge print description description must consist exactly two line stage blue edge delete first line description must contain word blue otherwise — word red second line print index edge delete stage increase order simplicity let 's assume edge root tree receive direction vertices reachable vertex 1 . a subtree vertex v a set vertices reachable vertex v result direct graph ( vertex v also include set ),"['data structures', 'implementation', 'trees']",2900.0
405/A,little chris bore physics lessons ( easy ) build a toy box keep occupy box special since ability change gravity n columns toy cub box arrange a line i - th column contain ai cub first gravity box pull cub downwards chris switch gravity begin pull cub right side box figure show initial final configurations cub box : cub change position highlight orange give initial configuration toy cub box find amount cub n columns gravity switch ! first line input contain integer n ( 1 ≤ n ≤ 100 ) number columns box next line contain n space - separated integer number i - th number ai ( 1 ≤ ai ≤ 100 ) denote number cub i - th column output n integer number separate space i - th number amount cub i - th column gravity switch first example case show figure top cube first column fall top last column ; top cube second column fall top third column ; middle cube first column fall top second column second example case gravity switch change heights columns,"['greedy', 'implementation', 'sortings']",900.0
407/A,"a right triangle legs length a b. task determine whether possible locate triangle plane a way none side parallel coordinate ax vertices must integer coordinate exist a location output appropriate coordinate vertices first line contain two integers a b ( 1 ≤ a b ≤ 1000 ) separate a single space first line print either ` ` yes '' ` ` '' ( without quote ) depend whether require location exist , print next three line three pair integers — coordinate triangle vertices one pair per line coordinate must integers exceed 109 absolute value","['brute force', 'geometry', 'implementation', 'math']",1600.0
41/A,translation berland language <unknown> language easy task languages similar : a berlandish word differ a birlandish word mean a little : spell ( pronounce ) reversely example a berlandish word code correspond a birlandish word <unknown> however 's easy make a mistake « translation » vasya translate word s berlandish birlandish t. help : find translate word correctly first line contain word s second line contain word t. word consist lowercase latin letter input data consist unnecessary space word empty lengths exceed 100 symbols word t a word s write reversely print yes otherwise print,"['implementation', 'strings']",800.0
412/A,"r1 company recently buy a high rise build centre moscow main office 's time decorate new office first thing write company 's slogan main entrance build slogan company consist n character <unknown> hang a large banner n meter wide 1 meter high divide n equal square first character slogan must first square ( leftmost ) poster second character must second square , course r1 programmers want write slogan poster , a large ( a heavy ) ladder put exactly opposite k - th square poster draw i - th character slogan poster need climb ladder stand front i - th square poster action ( along climb ladder ) take one hour a painter painter allow draw character adjacent square ladder front i - th square uncomfortable position ladder may make character <unknown> besides programmers move ladder one hour move ladder either a meter right a meter leave draw character move ladder tire programmers want finish job little time possible develop optimal poster paint plan ! first line contain two integers n k ( 1 ≤ k ≤ n ≤ 100 ) — number character slogan initial position ladder correspondingly next line contain slogan n character write without space character slogan either a large english letter digit one character : ' ' ' ! ' ' ' ' ? ' t line print action programmers need make i - th line print : paint time ( variable t ) must minimum possible multiple optimal paint plan print note ladder shift less one meter ladder stand front square poster example shift a ladder half a meter position two square go paint first character second character","['greedy', 'implementation']",900.0
414/D,mashmokh play a new game begin k liters water p coin additionally a root tree ( undirected connect acyclic graph ) consist m vertices vertex tree contain a water tank empty begin game begin fact mashmokh choose ( k ) tank ( except root ) pour exactly 1 liter water follow process perform water remain tank suppose l move make tree become empty let 's denote amount water inside tank root i - th move wi mashmokh win max ( w1 w2 ... <unknown> ) dollars mashmokh want know maximum amount dollars win play game ask find value first line input contain three space - separated integers m k p ( 2 ≤ m ≤ 105 ; 0 ≤ k p ≤ 109 ) follow m - 1 line contain two space - separated integers ai bi ( 1 ≤ ai bi ≤ m ; ai ≠ bi ) — edge tree consider vertices tree number 1 m. root tree number 1 . output a single integer number mashmokh ask find tree first sample show picture black red blue color correspond vertices 0 1 2 liters water one way achieve maximum amount money put 1 liter water vertices 3 4 . begin state show picture first move mashmokh pay one token close door third vertex tank tree first move show picture second move 2 liters water root show picture,"['binary search', 'data structures', 'greedy', 'trees', 'two pointers']",2300.0
415/B,bimokh mashmokh 's boss follow n days decide pay workers a new way begin day give worker a certain amount tokens end day worker give tokens back get a certain amount money worker save rest tokens ca n't use day get money a worker give back w tokens 'll get dollars mashmokh like tokens however like money 's want save many tokens possible amount money get maximal possible day n number x1 x2 ... xn number xi number tokens give worker i - th day help calculate n days number tokens save first line input contain three space - separated integers n a b ( 1 ≤ n ≤ 105 ; 1 ≤ a b ≤ 109 ) second line input contain n space - separated integers x1 x2 ... xn ( 1 ≤ xi ≤ 109 ) output n space - separated integers i - th number tokens mashmokh save i - th day,"['binary search', 'greedy', 'implementation', 'math']",1500.0
416/B,"a well - known art union call ` ` <unknown> alive ! '' manufacture object <unknown> ( picture ) union consist n painters decide organize work follow painter use color assign color distinct painters let 's assume first painter use color 1 second one use color 2 , picture contain n color add j - th color i - th picture take j - th painter tij units time order important everywhere painters ' work order follow rule : give painters start work time 0 find picture time ready sale first line input contain integers m n ( 1 ≤ m ≤ 50000 1 ≤ n ≤ 5 ) m number picture n number painters follow descriptions picture one per line line contain n integers <unknown> <unknown> ... <unknown> ( 1 ≤ tij ≤ 1000 ) tij time j - th painter need work i - th picture print sequence m integers r1 r2 ... <unknown> ri moment n - th painter stop work i - th picture","['brute force', 'dp', 'implementation']",1300.0
417/D,a boy name gena really want get ` ` russian code cup '' finals least get a t - shirt offer problems complex make arrangement n friends solve problems participants offer m problems contest friend gena know problems solve gena 's friends wo n't agree help gena nothing : i - th friend ask gena xi rubles help solve problems also friend agree write a code gena gena 's computer connect least ki monitor monitor cost b rubles gena careful money want spend little money possible solve problems help gena tell spend smallest possible amount money initially 's monitor connect gena 's computer first line contain three integers n m b ( 1 ≤ n ≤ 100 ; 1 ≤ m ≤ 20 ; 1 ≤ b ≤ 109 ) — number gena 's friends number problems cost a single monitor follow 2n line describe friends line number 2i ( 2i + 1 ) contain information i - th friend 2i - th line contain three integers xi ki mi ( 1 ≤ xi ≤ 109 ; 1 ≤ ki ≤ 109 ; 1 ≤ mi ≤ m ) — desire amount money monitor number problems friend solve ( 2i + 1 ) -th line contain mi distinct positive integers — number problems i - th friend solve problems number 1 m. print minimum amount money gena need spend solve problems print -1 achieve,"['bitmasks', 'dp', 'greedy', 'sortings']",1900.0
42/A,'s a unfortunate day volodya today get bad mark algebra therefore force work kitchen namely cook borscht ( traditional russian soup ) also improve algebra skills accord borscht recipe consist n ingredients mix proportion litres ( thus a1 · x ... · x litres correspond ingredients mix non - negative x ) kitchen volodya find b1 ... bn litres ingredients disposal correspondingly order correct algebra mistake ought cook much soup possible a v litres volume pan ( mean amount soup cook 0 v litres ) volume borscht volodya cook ultimately ? first line input contain two space - separated integers n v ( 1 ≤ n ≤ 20 1 ≤ v ≤ 10000 ) next line contain n space - separated integers ai ( 1 ≤ ai ≤ 100 ) finally last line contain n space - separated integers bi ( 0 ≤ bi ≤ 100 ) program output one real number — volume soup volodya cook answer must a relative absolute error less 10 - 4,"['greedy', 'implementation']",1400.0
42/D,"volodya recently visit a odd town n tourist attractions town every two connect a bidirectional road road travel price ( natural number ) assign price distinct strike thing town city sightsee tour total price ! , choose city sightsee tour — a cycle visit every attraction exactly — sum cost tour roads independent tour volodya curious find price system road price greater 1000 . input contain one natural number ( 3 ≤ n ≤ 20 ) — number town attractions output contain n row contain n positive integer number — adjacency matrix price graph ( thus j - th number i - th row equal price road j - th i - th attraction ) diagonal number equal zero number greater 1000 . price positive pairwise distinct several solutions output",['math'],2300.0
42/E,baldman a warp master possess a unique ability — create wormholes ! give two position space baldman make a wormhole make possible move directions unfortunately operation n't free baldman : create wormhole make lose plenty hair head extraordinary abilities baldman catch military 's attention charge a special task first things first military base consist several underground object connect bidirectional tunnel necessarily exist a path tunnel system pair object additionally exactly two object connect surface purpose security a patrol inspect tunnel system every day : enter one object connect surface walk base pass tunnel least leave one object connect surface enter leave either object different object military management notice patrol visit tunnel multiple time decide optimize process face a problem : a system wormholes need make allow a patrol pass tunnel exactly time a patrol allow pass wormhole number time baldman come operation : one plan build system wormholes unfortunately strict confidentiality military ca n't tell arrangement tunnel instead insist system portals solve problem arrangement tunnel satisfy give condition nevertheless baldman information : know pair object potentially connect much would cost ( hair ) moreover tomorrow tell object ( exactly two ) connect surface course hero decide waste time calculate minimal cost get job do pair object ( find likely ones connect surface ) help baldman ! first line input contain a single natural number n ( 2 ≤ n ≤ 100000 ) — number object military base second line — one number m ( 1 ≤ m ≤ 200000 ) — number wormholes baldman make follow m line describe wormholes : line contain three integer number a b c ( 1 ≤ a b ≤ n 1 ≤ c ≤ 100000 ) — number object connect number hair baldman spend make wormhole next line contain one natural number q ( 1 ≤ q ≤ 100000 ) — number query finally last q line contain a description one query — a pair number different object ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) could one wormhole a pair object program output q line one query i - th line contain a single integer number — answer i - th query : minimum cost ( hair ) a system wormholes allow optimal patrol system tunnel ( satisfy give condition ) ai bi two object connect surface ` ` -1 '' system wormholes make,"['dfs and similar', 'graphs', 'trees']",2700.0
424/E,cold winter even tomsk bore — nobody want streets a time residents tomsk away time sit warm apartments invent a lot different game one game ' colored <unknown> ' game require wooden block three color : red green blue a tower n level make level consist three wooden block block level arbitrary color always locate close parallel example a tower show figure game play exactly one person every minute a player throw a special dice six side two side dice green two blue one red one black dice show side equiprobably dice show red green blue player must take block color tower minute tower n't fall possible player wait end minute without touch tower also wait end minute without touch tower dice show black side allow take block top level tower ( whether complete ) a player get a block must put top tower form a new level finish upper level consist previously place block newly construct level properties initial level upper level complete start new level prohibit tower fall level except top least one block moreover level exactly one block leave block middle block tower fall game end moment block tower take tower n't fall a wonderful game invent residents city tomsk i wonder many minutes game last player act optimally well ? a player act optimally well moment try choose block take minimize expect number game duration task write a program determine expect number desire amount minutes first line input contain integer n ( 2 ≤ n ≤ 6 ) — number level tower n line follow describe level tower bottom top ( first line top tower ) level describe three character first third set border block level second one middle block character describe block one follow value ' r ' ( a red block ) ' g ' ( a green block ) ' b ' ( a blue block ) line output print seek mathematical expectation value answer consider correct relative absolute error n't exceed 10 - 6,"['dfs and similar', 'dp']",2500.0
429/C,iahub iahubina go a picnic a forest full tree less 5 minutes pass iahub remember tree program moreover invent a new problem iahubina solve otherwise iahub wo n't give food iahub ask iahubina : build a root tree <unknown> guess tree a smart girl realize 's possible tree follow iahub 's restrictions way iahub eat food need help iahubina : determine 's least one tree follow iahub 's restrictions require tree must contain n nod first line input contain integer n ( 1 ≤ n ≤ 24 ) next line contain n positive integers : i - th number represent ci ( 1 ≤ ci ≤ n ) output first line ` ` yes '' ( without quote ) exist least one tree follow iahub 's restrictions otherwise output ` ` '' ( without quote ),"['bitmasks', 'dp', 'greedy', 'trees']",2300.0
432/B,consider a football tournament n team participate team two football kit : home game away game kit home game i - th team color xi kit away game team color yi ( xi ≠ yi ) tournament team play exactly one home game exactly one away game team ( n ( n - 1 ) game total ) team play home game traditionally play home kit team play away game play away kit however two team kit color distinguish case away team play home kit calculate many game describe tournament team play home kit many game play away kit first line contain a single integer n ( 2 ≤ n ≤ 105 ) — number team next n line contain description team i - th line contain two space - separated number xi yi ( 1 ≤ xi yi ≤ 105 ; xi ≠ yi ) — color number home away kit i - th team team print a single line two space - separated integers — number game team go play home away kit correspondingly print answer team order appear input,"['brute force', 'greedy', 'implementation']",1200.0
432/D,a string s = s1s2 ... s|s| |s| length string s si i - th character let 's introduce several definitions : task prefix string s match a suffix string s print number time occur string s a substring single line contain a sequence character s1s2 ... s|s| ( 1 ≤ |s| ≤ 105 ) — string s. string consist uppercase english letter first line print integer k ( 0 ≤ k ≤ |s| ) — number prefix match a suffix string s. next print k line line print two integers li ci number li ci mean prefix length li match suffix length li occur string s a substring ci time print pair li ci order increase li,"['dp', 'strings', 'two pointers']",2000.0
433/A,kitahara haruki buy n apples touma kazusa ogiso setsuna want divide apples friends apple weight 100 grams 200 grams course kitahara haruki n't want offend friend therefore total weight apples give touma kazusa must equal total weight apples give ogiso setsuna unfortunately kitahara haruki n't a knife right split apple part please tell : possible divide apples a fair way friends ? first line contain integer n ( 1 ≤ n ≤ 100 ) — number apples second line contain n integers w1 w2 ... wn ( wi = 100 wi = 200 ) wi weight i - th apple a single line print ` ` yes '' ( without quote ) possible divide apples friends otherwise print ` ` '' ( without quote ) first test sample kitahara haruki give first last apple ogiso setsuna middle apple touma kazusa,"['brute force', 'implementation']",1100.0
436/C,load game ` ` dungeons candy '' require get descriptions k level server description a map n × m checker rectangular field cells field contain candy ( cell one candy ) empty cell denote ` ` . '' map a cell a candy denote a letter english alphabet a level may contain identical candy case letter correspond cells map transmit information via a network want minimize traffic — total size transfer data level transmit order two ways transmit current level a : task find a way transfer k level minimize traffic first line contain four integers n m k w ( 1 ≤ n m ≤ 10 ; 1 ≤ k w ≤ 1000 ) follow description k level level describe n line line contain m character character either a letter english alphabet a dot ( ` ` . ` ` ) please note case letter matter first line print require minimum number transfer bytes print k pair integers x1 y1 x2 y2 ... xk yk describe way transfer level pair xi yi mean level xi need transfer way yi yi equal 0 mean level must transfer use first way otherwise yi must equal number a previously transfer level mean transfer difference level yi xi transfer level xi print pair order transfer level level number 1 k order follow input multiple optimal solutions print,"['dsu', 'graphs', 'greedy', 'trees']",1800.0
437/B,children 's day child come pick 's house mess house pick angry a lot important things lose particular favorite set pick fortunately pick remember something set s : help pick find set s satisfy condition ? first line contain two integers : sum limit ( 1 ≤ sum limit ≤ 105 ) first line print integer n ( 1 ≤ n ≤ 105 ) denote size s. print elements set s order multiple answer print 's impossible find a suitable set print -1 . sample test 1 : lowbit ( 4 ) = 4 lowbit ( 5 ) = 1 4 + 1 = 5 . sample test 2 : lowbit ( 1 ) = 1 lowbit ( 2 ) = 2 lowbit ( 3 ) = 1 1 + 2 + 1 = 4,"['bitmasks', 'greedy', 'implementation', 'sortings']",1500.0
44/B,"celebrate open winter computer school organizers decide buy n liters cola however unexpected difficulty occur shop : turn cola sell bottle 0.5 1 2 liters volume , exactly a bottle 0.5 volume b one - liter bottle c two - liter ones organizers enough money buy amount cola cause heat arguments many bottle every kind buy question <unknown> distribution cola among participants ( organizers well ) thus organizers argument discuss different variants buy cola winter school ca n't start task count number possible ways buy exactly n liters cola persuade organizers number large keep argue winter computer school organize summer bottle cola consider indistinguishable i.e two variants buy different differ number bottle least one kind first line contain four integers — n a b c ( 1 ≤ n ≤ 10000 0 ≤ a b c ≤ 5000 ) print unique number — solution problem impossible buy exactly n liters cola print 0",['implementation'],1500.0
44/C,school holiday come berland holiday go continue n days students school № n time live teacher marina sergeyevna spend summer busy check <unknown> ( berland state examination ) result finally take a vacation break ! people charge daily water flower shift accord schedule however marina sergeyevna make schedule tire work lose dream oncoming vacation perhaps make several mistake fact possible accord schedule days holiday flower water water multiple time help marina sergeyevna find a mistake first input line contain two number n m ( 1 ≤ n m ≤ 100 ) — number days berland holiday number people charge water respectively next m line contain description duty schedule line contain two integers ai bi ( 1 ≤ ai ≤ bi ≤ n ) mean i - th person charge water flower ai - th bi - th day inclusively a day duty shift describe sequentially i.e bi ≤ ai + 1 i 1 n - 1 inclusively print ` ` ok '' ( without quote ) schedule contain mistake otherwise find minimal number a day flower water water multiple time output two integers — day number number time flower water day keep mind second sample mistake occur second day also sixth day nobody water flower however print second day i.e day minimal number,['implementation'],1300.0
44/F,anfisa monkey get disappoint word processors n't good enough reflect range emotions 's decide switch graphics editors open <unknown> saw a white rectangle w × h size paint first anfisa learn navigate draw tool use paint segment quickly paint rectangle a certain number black - colored segment result picture n't seem bright enough anfisa 's turn attention ` ` fill '' tool use find a point rectangle paint choose a color area color point contain completely paint choose color apply fill several time anfisa express emotions completely stop paint task information paint segment apply fill find every color total area areas paint color fill first input line two integers w h ( 3 ≤ w h ≤ 104 ) — size initially white rectangular paint area second line contain integer n — number black segment ( 0 ≤ n ≤ 100 ) next n line describe segment give coordinate endpoints x1 y1 x2 y2 ( 0 < x1 x2 < w 0 < y1 y2 < h ) segment non - zero length next line contain preset number fill m ( 0 ≤ m ≤ 100 ) follow m line define fill operation form ` ` x y color '' ( x y ) coordinate choose point ( 0 < x < w 0 < y < h ) color — a line lowercase latin letter 1 15 symbols length determine color coordinate give input integers initially rectangle ` ` white '' color whereas segment draw ` ` black '' color every color present final picture print single line name color total area areas paint color accuracy 10 - 6 . print color order initially black segment paint anfisa also paint a color choose point lay segment segment areas equal 0 . final picture part segment paint color area paint color equal 0,"['geometry', 'graphs']",2700.0
44/H,alas find one 's true love easy masha unsuccessful yet friend dasha tell masha a way determine phone number one 's prince charm <unknown> phone number divine like first one need write one 's phone number example let 's suppose masha 's phone number 12345 . one write favorite digit 0 9 first digit number first digit need number example masha 's favorite digit 9 . second digit determine a half sum second digit masha 's number already write first digit beloved one 's number case arithmetic average equal ( 2 + 9 ) / 2 = <unknown> . masha round number depend wish example choose digit 5 . write result digit second digit number masha move find third digit way i.e find half sum third digit number second digit new number result ( 5 + 3 ) / 2 = 4 . case answer unique thus every i - th digit determine arithmetic average i - th digit masha 's number i - 1 - th digit true love 's number need digit round example masha get : first line contain nonempty sequence consist digits 0 9 — masha 's phone number sequence length exceed 50 . output single number — number phone number masha dial,['dp'],1700.0
441/B,valera love garden n fruit tree grow year enjoy a great harvest ! i - th tree bi fruit grow ripen a day number ai unfortunately fruit tree get wither collect day ai day ai + 1 ( fruit collect two days become unfit eat ) valera fast positive point valera ready work every day one day valera collect v fruit fruit may either tree different ones maximum amount fruit valera collect time operate optimally well ? first line contain two space - separated integers n v ( 1 ≤ n v ≤ 3000 ) — number fruit tree garden number fruit valera collect a day next n line contain description tree garden i - th line contain two space - separated integers ai bi ( 1 ≤ ai bi ≤ 3000 ) — day fruit ripen i - th tree number fruit i - th tree print a single integer — maximum number fruit valera collect first sample order obtain optimal answer act follow second sample collect 60 fruit remain fruit simply wither,"['greedy', 'implementation']",1400.0
446/A,dzy a sequence a consist n integers 'll call a sequence ai ai + 1 ... aj ( 1 ≤ i ≤ j ≤ n ) a subsegment sequence a. value ( j - i + 1 ) denote length subsegment task find longest subsegment a possible change one number ( change one number integer want ) subsegment make subsegment strictly increase need output length subsegment find first line contain integer n ( 1 ≤ n ≤ 105 ) next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) a single line print answer problem — maximum length require subsegment choose subsegment a2 a3 a4 a5 a6 change 3rd element ( a4 ) 4,"['dp', 'implementation', 'two pointers']",1600.0
446/C,"mathematical term sequence fn fibonacci number define recurrence relation dzy love fibonacci number much today dzy give array consist n integers : a1 a2 ... , moreover m query query one two type : help dzy reply query first line input contain two integers n m ( 1 ≤ n m ≤ 300000 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — initial array a. m line follow a single line describe a single query format give statement guarantee query inequality 1 ≤ l ≤ r ≤ n hold query second type print value sum a single line first query a = [ 2 3 5 7 ] second query sum = 2 + 3 + 5 + 7 = 17 . third query a = [ 2 4 6 9 ] fourth query sum = 2 + 4 + 6 = 12","['data structures', 'math', 'number theory']",2400.0
446/D,"today dzy begin play old game game a big maze n room connect m corridors ( corridor allow move directions ) assume room connect corridors directly indirectly dzy get lose maze currently first room k live act like follow : room trap first room definitely trap n - th room definitely a trap time dzy enter one room lose one life , dzy know enter n - th room exactly 2 live firstly lose one live open a bonus round want know probability open bonus round please help first line contain three integers n m k ( 2 ≤ n ≤ 500 ; 1 ≤ m ≤ 105 ; 2 ≤ k ≤ 109 ) second line contain n integers either 0 1 . i - th number 1 i - th room a trap otherwise a trap please note number room a trap 101 . guarantee first room trap n - th room a trap m line follow contain two integers ui vi ( 1 ≤ ui vi ≤ n ; ui ≠ vi ) mean current corridor connect two room ui vi guarantee corridor system connect print real number — probability dzy open bonus round answer consider correct relative absolute error n't exceed 10 - 4",['math'],2800.0
448/B,bizon champion n't a <unknown> also a favorite ` ` bizons '' team a competition ` ` bizons '' get follow problem : ` ` give two distinct word ( string english letter ) s t. need transform word s word t '' task look simple guy know suffix data structure well bizon senior love suffix automaton apply a string remove string single character bizon middle know suffix array well apply a string swap two character string guy know anything suffix tree help much bizon champion wonder whether ` ` bizons '' solve problem perhaps solution require data structure find whether guy solve problem ? solve either use suffix automaton use suffix array need structure ? note structure may use unlimited number time structure may use order first line contain a non - empty word s. second line contain a non - empty word t. word s t different word consist lowercase english letter word contain 100 letter single line print answer problem print ` ` need tree '' ( without quote ) word s transform word t even use suffix array suffix automaton print ` ` automaton '' ( without quote ) need suffix automaton solve problem print ` ` array '' ( without quote ) need suffix array solve problem print ` ` '' ( without quote ) need data structure solve problem 's guarantee solve problem use suffix array impossible solve use suffix automaton also true suffix automaton third sample act like : first transform ` ` '' ` ` <unknown> '' remove first character use suffix automaton make two swap string use suffix array get ` ` hot '',"['implementation', 'strings']",1400.0
45/E,vasya a bear berland film director currently work a new <unknown> ` ` unexpected '' vasya know experience important choose main character ' name surnames wisely make a list n name n surnames want use vasya n't decide yet call character free match name surname make list main character follow format : ` ` name1 <unknown> name2 <unknown> ... <unknown> <unknown> '' i.e name - surname pair separate exactly one comma exactly one space name separate surname exactly one space first vasya want maximize number pair name surname start one letter several variants vasya want get lexicographically minimal one help answer verify a line format show include need commas space 's lexicographical minimality a line need ensure output line n't end a space a comma first input line contain number n ( 1 ≤ n ≤ 100 ) — number name surnames follow n line — list name follow n line — list surnames two 2n string match every name surname a non - empty string consist 10 latin letter guarantee first letter uppercase rest lowercase output data consist a single line — need list note one follow closely output data format !,['greedy'],2000.0
45/H,berland capital ( well know ) contain n junctions pair connect two - way roads unfortunately number traffic jam capital increase dramatically 's decide build several new roads every road connect two junctions city administration notice cities develop countries two roads one drive along least two paths paths n't share roads ( may share junction ) administration decide add minimal number roads rule fulfil berland capital well city road network exist one road every pair junctions reform first input line contain a pair integers n m ( 2 ≤ n ≤ 900 1 ≤ m ≤ 100000 ) n number junctions m number roads follow m line contain a description a road give number connect junctions ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) junctions number 1 n. possible reach junction city one move along roads first line print t — number add roads t line print descriptions add roads format input data use order print roads well junctions link every road several solutions problem print capital n't need reform print single number 0 . 's solution print single number -1,['graphs'],2100.0
45/I,vasya get interest program contest tcmcf+++ rule contest n problems suggest every problem a cost — a certain integral number point ( perhaps negative even equal zero ) accord tcmcf+++ rule accept problems earn point overall number point a contestant equal product cost problems he / she complete a person n't solve anything he / she n't even appear final stand n't consider participant vasya understand get maximal number point always useful solve problems unfortunately understand contest finish ask help : find problems solve earn maximal number point first line contain integer n ( 1 ≤ n ≤ 100 ) — number suggest problems next line contain n space - separated integers ci ( - 100 ≤ ci ≤ 100 ) — cost i - th task task ' cost may <unknown> print space - separated cost problems need solve get maximal possible number point forget please necessary solve least one problem several solutions problem print,['greedy'],1400.0
450/A,n children jzzhu 's school jzzhu go give candy let 's number children 1 n. i - th child want get least ai candy jzzhu ask children line initially i - th child stand i - th place line jzzhu start distribution candy follow algorithm : consider children order go home jzzhu want know child last order ? first line contain two integers n m ( 1 ≤ n ≤ 100 ; 1 ≤ m ≤ 100 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 100 ) output a single integer represent number last child let 's consider first sample firstly child 1 get 2 candy go home child 2 get 2 candy go end line currently line look like [ 3 4 5 2 ] ( indices children order line ) child 3 get 2 candy go home child 4 get 2 candy go end line currently line look like [ 5 2 4 ] child 5 get 2 candy go home child 2 get two candy go home finally child 4 get 2 candy go home child 4 last one go home,['implementation'],1000.0
451/E,devu want decorate garden flower purchase n box i - th box contain fi flower flower a single box color ( hence indistinguishable ) also two box flower color devu want select exactly s flower box decorate garden devu would like know many different ways select flower box ? since number may large ask find number modulo ( 109 + 7 ) devu consider two ways different least one box different number flower select two ways first line input contain two space - separated integers n s ( 1 ≤ n ≤ 20 0 ≤ s ≤ 1014 ) second line contain n space - separated integers f1 f2 ... fn ( 0 ≤ fi ≤ 1012 ) output a single integer — number ways devu select flower modulo ( 109 + 7 ) sample 1 . two ways select 3 flower : { 1 2 } { 0 3 } sample 2 . one way select 4 flower : { 2 2 } sample 3 . three ways select 5 flower : { 1 2 2 } { 0 3 2 } { 1 3 1 },"['bitmasks', 'combinatorics', 'number theory']",2300.0
452/B,give a rectangular grid lattice point ( 0 0 ) ( n m ) inclusive choose exactly 4 different point build a polyline possibly self - intersections self - <unknown> polyline long possible a polyline define point p1 p2 p3 p4 consist line segment p1 p2 p2 p3 p3 p4 length sum lengths individual line segment line input contain two integers n m ( 0 ≤ n m ≤ 1000 ) guarantee grid contain least 4 different point print 4 line two integers per line separate space — coordinate point p1 p2 p3 p4 order represent longest possible polyline judge program compare answer jury 's answer 10 - 6 precision,"['brute force', 'geometry', 'trees']",1800.0
455/B,andrew fedor alex inventive guy invent game string two players give a group n non - empty string game two players build word together initially word empty players move turn step player must add a single letter end word result word must prefix least one string group a player lose move andrew alex decide play game k time player loser i - th game make first move ( i + 1 ) -th game guy decide winner game player win last ( k - th ) game andrew alex already start game fedor want know win game players play optimally help first line contain two integers n k ( 1 ≤ n ≤ 105 ; 1 ≤ k ≤ 109 ) next n line contain a single non - empty string give group total length string group n't exceed 105 . string group consist lowercase english letter player move first win print ` ` first '' otherwise print ` ` second '' ( without quote ),"['dfs and similar', 'dp', 'implementation', 'strings', 'trees']",1900.0
457/F,pieguy piegirl play a game a root binary tree a property node either a leaf exactly two children leaf a number associate his / her turn a player choose two leaf share immediate parent remove associate either value parent become a leaf ( player decide two value associate ) game end one node ( one root tree ) leave pieguy go first goal maximize value associate root game end piegirl want minimize value assume players play optimally number associate root game end ? first line contain a single integer t ( 1 ≤ t ≤ 100 ) — number test case t test case follow test case begin empty line follow a line a single integer n ( 1 ≤ n ≤ 250 ) follow n line describe n nod tree n line either contain a non - negative number ai indicate a leaf node value ai ( 0 ≤ ai ≤ 1000 ) associate - 1 follow integers l r indicate a non - leaf node children l r ( 0 ≤ l r ≤ n - 1 ) nod number 0 n - 1 . root always node 0 . test case print one line one integer — number associate root game end,"['dp', 'greedy', 'trees']",3200.0
459/E,"pashmak 's homework a problem graph although always try homework completely ca n't solve problem know 's really weak graph theory ; try help solve problem give a weight direct graph n vertices m edge need find a path ( perhaps non - simple ) maximum number edge weight edge increase along path word edge path must strictly greater weight previous edge path help pashmak print number edge require path first line contain two integers n m ( 2 ≤ n ≤ 3·105 ; 1 ≤ m ≤ min ( n · ( n - 1 ) 3·105 ) ) , m line follow i - th line contain three space separate integers : ui vi wi ( 1 ≤ ui vi ≤ n ; 1 ≤ wi ≤ 105 ) indicate 's a direct edge weight wi vertex ui vertex vi 's guarantee graph n't contain self - loops multiple edge print a single integer — answer problem first sample maximum trail trail : second sample maximum trail third sample maximum trail","['dp', 'sortings']",1900.0
460/A,vasya n pair sock morning day vasya put a pair sock go school come home even vasya take use sock throw away every m - th day ( days number m 2 m 3 m ... ) mom buy a pair sock vasya late even vasya put a new pair sock next day many consecutive days pass vasya run sock ? single line contain two integers n m ( 1 ≤ n ≤ 100 ; 2 ≤ m ≤ 100 ) separate a space print a single integer — answer problem first sample vasya spend first two days wear sock initially day three put sock buy day two second sample vasya spend first nine days wear sock initially spend three days wear sock buy third sixth ninth days spend another day wear sock buy twelfth day,"['brute force', 'implementation', 'math']",900.0
463/E,caisa home son a simple task give a root tree n vertices number 1 n ( vertex 1 root ) vertex tree a value answer q query query one follow : give query help caisa solve problem first line contain two space - separated integers n q ( 1 ≤ n q ≤ 105 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 2·106 ) ai represent value node i. next n - 1 line contain two integers xi yi ( 1 ≤ xi yi ≤ n ; xi ≠ yi ) denote edge tree vertices xi yi next q line contain a query format give query follow inequalities hold : 1 ≤ v ≤ n 1 ≤ w ≤ 2·106 note : 50 query change value a vertex query first type output result <unknown> ( x y ) greatest common divisor two integers x y,"['brute force', 'dfs and similar', 'math', 'number theory', 'trees']",2100.0
464/A,paul hat palindromes assume string s tolerable character one first p letter english alphabet s n't contain palindrome contiguous substring length 2 paul find a tolerable string s length n. help find lexicographically next tolerable string length else state string exist first line contain two space - separated integers : n p ( 1 ≤ n ≤ 1000 ; 1 ≤ p ≤ 26 ) second line contain string s consist n small english letter guarantee string tolerable ( accord definition ) lexicographically next tolerable string length exist print otherwise print ` ` '' ( without quote ) string s lexicographically larger ( simply larger ) string t length number i s1 = t1 ... si = ti si + 1 > ti + 1 . lexicographically next tolerable string lexicographically minimum tolerable string larger give one a palindrome a string read forward reverse,"['greedy', 'strings']",1700.0
464/C,andrew eugene play a game initially andrew string s consist digits eugene send andrew multiple query type ` ` di → ti '' mean ` ` replace digits di string s substrings equal ti '' example s = <unknown> query ` ` 2 → 00 '' transform s <unknown> query ` ` 3 → ` ` ( ` ` replace 3 empty string '' ) transform s = <unknown> . query eugene ask andrew find remainder division number decimal representation equal s 1000000007 ( 109 + 7 ) represent s a decimal number please ignore lead zero ; also s empty string 's assume number equal zero andrew get tire process eugene 's request manually ask write a program help ! first line contain string s ( 1 ≤ |s| ≤ 105 ) consist digits — string process request second line contain a single integer n ( 0 ≤ n ≤ 105 ) — number query next n line contain descriptions query i - th query describe string ` ` <unknown> > ti '' di exactly one digit ( 0 9 ) ti a string consist digits ( ti empty string ) sum lengths ti query n't exceed 105 . query write order need perform print a single integer — remainder division result number 1000000007 ( 109 + 7 ) note lead zero remove string s replacement ( see third sample ),['dp'],2100.0
466/A,ann recently start commute subway know a one ride subway ticket cost a rubles besides ann find buy a special ticket m rid ( buy several time ) cost b rubles ann math ; need use subway n time help ann tell minimum sum money spend make n rid ? single line contain four space - separated integers n m a b ( 1 ≤ n m a b ≤ 1000 ) — number rid ann plan number rid cover m ride ticket price a one ride ticket price m ride ticket print a single integer — minimum sum rubles ann need spend first sample one optimal solutions : time buy a one ride ticket optimal solutions example buy three m ride ticket,['implementation'],1200.0
466/E,"n employees work company ` ` x '' ( let 's number 1 n convenience ) initially employees n't relationships among m next days one follow events take place : task write a program give events answer query describe type , guarantee throughout whole work time company n't cyclic dependencies first line contain two integers n m ( 1 ≤ n m ≤ 105 ) — number employees number events next m line contain description one event ( events give chronological order ) first number line determine type event t ( 1 ≤ t ≤ 3 ) guarantee input least one query third type query third type print ` ` yes '' employee sign document package ` ` '' otherwise print word without quote","['dfs and similar', 'dsu', 'graphs', 'trees']",2100.0
467/B,help george alex move dorm go help friend fedor play a new computer game « call soldier 3 » game ( m + 1 ) players n type soldier total players « call soldier 3 » number form 1 ( m + 1 ) type soldier number 0 n - 1 . player army army i - th player describe non - negative integer xi consider binary representation xi : j - th bite number xi equal one army i - th player soldier j - th type fedor ( m + 1 ) -th player game assume two players become friends armies differ k type soldier ( word binary representations correspond number differ k bits ) help fedor count many players become friends first line contain three integers n m k ( 1 ≤ k ≤ n ≤ 20 ; 1 ≤ m ≤ 1000 ) i - th next ( m + 1 ) line contain a single integer xi ( 1 ≤ xi ≤ 2n - 1 ) describe i - th player 's army remind fedor ( m + 1 ) -th player print a single integer — number fedor 's potential friends,"['bitmasks', 'brute force', 'implementation']",1100.0
467/D,help fedor find friends « call soldier 3 » game stop study completely today english teacher tell prepare essay fedor n't want prepare essay ask alex help alex come help write essay fedor fedor n't like essay fedor go change essay use synonym dictionary english language fedor want change mean essay change would : change a word essay one synonyms base a replacement rule dictionary fedor may perform operation number time a result fedor want get essay contain little letter « r » ( case n't matter ) possible multiple essay minimum number « r » s want get one minimum length ( length essay sum lengths word ) help fedor get require essay please note problem case letter n't matter example synonym dictionary say word cat replace word dog allow replace word cat word dog first line contain a single integer m ( 1 ≤ m ≤ 105 ) — number word initial essay second line contain word essay word separate a single space guarantee total length word wo n't exceed 105 character next line contain a single integer n ( 0 ≤ n ≤ 105 ) — number pair word synonym dictionary i - th next n line contain two space - separated non - empty word xi yi mean word xi replace word yi ( vise versa ) guarantee total length pair synonyms n't exceed 5·105 character word input consist uppercase lowercase letter english alphabet print two integers — minimum number letter « r » optimal essay minimum length optimal essay,"['dfs and similar', 'dp', 'graphs', 'strings']",2400.0
467/E,"read problems probably think alex genius person 's true ! one day come follow task give a sequence integer number a1 a2 ... , find a longest sequence b1 b2 ... b4 m satisfy follow condition : finally ... alex give complicate task george george give help george cope task first line contain a single integer n ( 1 ≤ n ≤ 5·105 ) next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) first line print a single integer 4 m — maximal possible length require sequence b. second line print 4 m integers b1 b2 ... b4 m require sequence multiple optimal answer may print","['data structures', 'dp', 'greedy']",2300.0
476/D,"dreamoon like play set integers define largest positive integer divide a b. let s a set exactly four distinct integers greater 0 . define s rank k pair distinct elements si sj s , give k n dreamoon want make n set rank k use integers 1 m integer use two different set ( course leave integers without use ) calculate minimum m make possible print one possible solution single line input contain two space separate integers n k ( 1 ≤ n ≤ 10 000 1 ≤ k ≤ 100 ) first line print a single integer — minimal possible m. next n line print four space separate integers represent i - th set neither order set order integers within a set important multiple possible solutions minimal m print one first example 's easy see set { 1 2 3 4 } n't a valid set rank 1 since","['greedy', 'math']",1900.0
477/D,dreamoon saw a large integer x write grind want print binary form dreamoon accomplish part turn x binary format go print follow manner integer n = 0 perform follow two operations order unlimited time : let 's define ideal sequence a sequence operations successfully print binary representation x without lead zero end a print operation ( i.e operation 1 ) dreamoon want know many different ideal sequence length ( operations ) shortest ideal sequence answer might large please print modulo 1000000007 ( 109 + 7 ) let 's define string representation ideal sequence a string ' 1 ' ' 2 ' i - th character string match i - th operation perform two ideal sequence call different string representations different single line input contain a binary integer represent x ( 1 ≤ x < 25000 ) without lead zero first line output contain integer represent number different ideal sequence modulo 1000000007 ( 109 + 7 ) second line output contain integer represent minimal length ideal sequence modulo 1000000007 ( 109 + 7 ) first sample shortest ideal sequence « <unknown> » length 6 . second sample three ideal sequence « <unknown> » « <unknown> » « <unknown> » among shortest one length 5,"['dp', 'strings']",2700.0
477/E,"dreamoon create a document hard problems use notepad.exe document consist n line text ai denote length i - th line want know fastest way move cursor around document really long let ( r c ) a current cursor position r row number c position cursor row 1 ≤ r ≤ n 0 ≤ c ≤ ar use follow six operations notepad.exe move cursor assume current cursor position ( r c ) : 're give document description ( n sequence ai ) q query dreamoon query ask minimal number key press need move cursor ( r1 c1 ) ( r2 c2 ) first line contain integer n ( 1 ≤ n ≤ 400 000 ) — number line text second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 108 ) third line contain integer q ( 1 ≤ q ≤ 400 000 ) next q line contain four integers r1 c1 r2 c2 represent a query ( 1 ≤ r1 r2 ≤ n 0 ≤ c1 ≤ ar1 0 ≤ c2 ≤ ar2 ) query print result query first sample first query solve key : home right second query solve key : , end , third query solve key : end , fourth query solve key : end ,",['data structures'],3100.0
478/D,r red g green block construction red - green tower red - green tower build follow next rule : let h maximum possible number level red - green tower build r red g green block meet rule task determine many different red - green tower h level build available block two red - green tower consider different exist level consist red block one tower consist green block tower write a program find number different red - green tower height h modulo 109 + 7 . line input contain two integers r g separate a single space — number available red green block respectively ( 0 ≤ r g ≤ 2·105 r + g ≥ 1 ) output integer — number different possible red - green tower height h modulo 109 + 7 . image problem statement show possible red - green tower first sample,['dp'],2000.0
482/C,play game friend description game list friend create n distinct string length m tell string randomly choose one choose string equiprobably i.e probability choose n string equal want guess string choose friend order guess string friend choose allow ask question question follow form : « character stand position pos string choose ? » a string consider guess answer give question uniquely identify string string guess stop ask question a particular strategy question equiprobably ask a position n't yet mention task determine expect number question need guess string choose friend first line contain a single integer n ( 1 ≤ n ≤ 50 ) — number string friend come next n line contain string friend create guarantee string distinct consist large small english letter besides lengths string 1 20 inclusive print single number — expect value answer consider correct absolute relative error n't exceed 10 - 9 . first sample string differ character third position follow situations possible : thus expect value equal second sample need two question pair question uniquely identify string expect number question third sample whatever position ask first question immediately identify string,"['bitmasks', 'dp']",2600.0
482/D,a root tree consist n vertices let 's number integers 1 n inclusive root tree vertex 1 . i > 1 direct parent vertex i pi say vertex i child direct parent pi initially paint vertices red color like repaint vertices tree perform paint use function paint call root tree argument pseudocode function : a result function vertices may change color white black may remain red task determine number distinct possible color vertices tree assume color possible a nonzero probability get color a single call paint ( 1 ) assume color different a pair vertices paint different color color since require number may large find remainder division 1000000007 ( 109 + 7 ) first line contain a single integer n ( 2 ≤ n ≤ 105 ) — number vertexes tree second line contain n - 1 integers p2 p3 ... pn ( 1 ≤ pi < i ) number pi parent vertex i. print a single integer — answer problem modulo 1000000007 ( 109 + 7 ) possible color pattern first sample give,"['combinatorics', 'dp', 'trees']",2700.0
484/B,give a sequence a consist n integers find maximum possible value ( integer remainder ai divide aj ) 1 ≤ i j ≤ n ai ≥ aj first line contain integer n — length sequence ( 1 ≤ n ≤ 2·105 ) second line contain n space - separated integers ai ( 1 ≤ ai ≤ 106 ) print answer problem,"['binary search', 'math', 'sortings', 'two pointers']",2100.0
484/E,bizon champion recently finish paint wood fence fence consist a sequence n panel 1 meter width arbitrary height i - th panel 's height hi meter adjacent plank follow without a gap bizon paint fence decide put a ` ` sale '' sign sign draw a rectangular piece paper place fence side sign parallel fence panel also align edge panel bizon champion introduce follow constraints sign position : sign really pretty bizon champion want sign 's height large possible give description fence several query place sign query print maximum possible height sign place correspond segment fence give fix width sign first line input contain integer n — number panel fence ( 1 ≤ n ≤ 105 ) second line contain n space - separated integers hi — heights panel ( 1 ≤ hi ≤ 109 ) third line contain integer m — number query ( 1 ≤ m ≤ 105 ) next m line contain descriptions query query represent three integers l r w ( 1 ≤ l ≤ r ≤ n 1 ≤ w ≤ r - l + 1 ) — segment fence width sign respectively query print answer a separate line — maximum height sign put correspond segment fence condition satisfy fence describe sample look follow : possible position sign query give,"['binary search', 'data structures']",2500.0
487/A,a monster attack cyberland ! master yang a <unknown> go beat monster yang monster 3 attribute : <unknown> ( hp ) offensive power ( atk ) defensive power ( def ) battle every second monster 's hp decrease max ( 0 atky - defm ) yang 's hp decrease max ( 0 atkm - defy ) index y denote master yang index m denote monster decrease happen simultaneously monster 's hp ≤ 0 time master yang 's hp > 0 master yang win master yang buy attribute magic shop cyberland : h bitcoins per hp a bitcoins per atk d bitcoins per def master yang want know minimum number bitcoins spend order win first line contain three integers <unknown> atky defy separate a space denote initial hp atk def master yang second line contain three integers <unknown> atkm defm separate a space denote hp atk def monster third line contain three integers h a d separate a space denote price 1 hp 1 atk 1 def number input integer lie 1 100 inclusively output line contain integer denote minimum bitcoins master yang spend order win first sample price atk def extremely high master yang buy 99 hp beat monster 1 hp leave second sample master yang strong enough beat monster n't need buy anything,"['binary search', 'brute force', 'implementation']",1800.0
489/E,a traveler plan a water hike along river note suitable rest point night write distance start point locations characterize picturesqueness i - th rest point distance start equal xi picturesqueness equal bi traveler move river one direction assume start point 0 coordinate axis rest point point coordinate xi every day traveler want cover distance l. practice turn always possible need end day one rest point addition traveler choose two desire : cover distance l every day visit <unknown> place let 's assume traveler cover distance rj a day feel frustration total frustration hike calculate total frustration days help plan route minimize relative total frustration : total frustration divide total picturesqueness rest point use traveler 's path must end farthest rest point first line input contain integers n l ( 1 ≤ n ≤ 1000 1 ≤ l ≤ 105 ) — number rest point optimal length one day path n line follow line describe one rest point a pair integers xi bi ( 1 ≤ xi bi ≤ 106 ) two rest point xi line give order strictly increase xi print traveler 's path a sequence number rest point use order use number point 1 n order increase xi last print number must equal n. sample test minimum value relative total frustration approximately equal <unknown> . value calculate,"['binary search', 'dp']",2300.0
492/A,"vanya get n cub decide build a pyramid vanya want build pyramid follow : top level pyramid must consist 1 cube second level must consist 1 + 2 = 3 cub third level must 1 + 2 + 3 = 6 cub , thus i - th level pyramid must 1 + 2 + ... + ( i - 1 ) + i cub vanya want know maximum height pyramid make use give cub first line contain integer n ( 1 ≤ n ≤ 104 ) — number cub give vanya print maximum possible height pyramid single line illustration second sample :",['implementation'],800.0
492/C,vanya want pass n exams get academic scholarship get scholarship average grade mark exams least avg exam grade exceed r. vanya pass exams get grade ai i - th exam increase grade i - th exam 1 point vanya must write bi essay raise exam grade multiple time minimum number essay vanya need write get scholarship ? first line contain three integers n r avg ( 1 ≤ n ≤ 105 1 ≤ r ≤ 109 1 ≤ avg ≤ min ( r 106 ) ) — number exams maximum grade require grade point average respectively follow n line contain space - separated integers ai bi ( 1 ≤ ai ≤ r 1 ≤ bi ≤ 106 ) first line print minimum number essay first sample vanya write 2 essay 3rd exam raise grade 2 point 2 essay 4th exam raise grade 1 point second sample vanya n't need write essay general point average already average,"['greedy', 'sortings']",1400.0
492/D,vanya friend vova play a computer game need destroy n monsters pass a level vanya 's character perform attack frequency x hit per second vova 's character perform attack frequency y hit per second character spend fix time raise a weapon hit ( time raise weapon 1 / x second first character 1 / y second second one ) i - th monster die receive ai hit vanya vova wonder make last hit monster vanya vova make last hit time assume make last hit first line contain three integers n x y ( 1 ≤ n ≤ 105 1 ≤ x y ≤ 106 ) — number monsters frequency vanya 's vova 's attack correspondingly next n line contain integers ai ( 1 ≤ ai ≤ 109 ) — number hit need destroy i - th monster print n line i - th line print word ` ` vanya '' last hit i - th monster perform vanya ` ` vova '' vova perform last hit ` ` '' boys perform time first sample vanya make first hit time 1 / 3 vova make second hit time 1 / 2 vanya make third hit time 2 / 3 boys make fourth fifth hit simultaneously time 1 . second sample vanya vova make first second hit simultaneously time 1,"['binary search', 'implementation', 'math', 'sortings']",1800.0
494/B,ham recently find a string t suddenly become quite fond spend several days try find occurrences t string finally become tire start think follow problem give a string s many ways extract k ≥ 1 non - overlapping substrings contain string t a substring ? formally need calculate number ways choose two sequence a1 a2 ... ak b1 b2 ... bk satisfy follow requirements : number ways rather large print modulo 109 + 7 . input consist two line contain string s t ( 1 ≤ |s| |t| ≤ 105 ) string consist lowercase latin letter print answer a single line,"['dp', 'strings']",2000.0
5/A,polycarp work a new project call ` ` <unknown> '' follow modern <unknown> decide project contain chat well achieve goal polycarp spend several hours front laptop implement a chat server process three type command : polycarp want find amount outgo traffic server produce process a particular set command polycarp know chat server send traffic ' add ' ' remove ' command ' send ' command process server send l bytes participant chat l length message polycarp time ask help solve problem input file contain 100 command line line exceed 100 character format command follow : < name > < <unknown> > a non - empty sequence latin letter digits < message_text > contain letter digits space ca n't start end a space < message_text > empty line guarantee input data correct i.e ' add ' command person a name already chat ' remove ' command person a name chat etc name case - sensitive print a single number — answer problem,['implementation'],1000.0
5/E,everyone know long ago territory present - day berland live <unknown> tribes capital surround n hill form a circle hill a watchman watch neighbourhood day night case danger watchman could make a fire hill one watchman could see signal another watchman circle arc connect two hill hill higher two two hill two different circle arc connect signal see mention condition satisfy least one arc example two neighbour watchmen true signal one see important characteristics watch system amount pair watchmen able see 's signal find amount give heights hill first line input data contain integer number n ( 3 ≤ n ≤ 106 ) n — amount hill around capital second line contain n number — heights hill clockwise order height number integer lie 1 109 . print require amount pair,['data structures'],2400.0
500/A,"new year come line world ! world n cells number integers 1 n a 1 × n board people live cells however hard move distinct cells difficulty escape cell people want meet people live cells , user <unknown> make a transportation system move cells celebrate new year first think n - 1 positive integers a1 a2 ... - 1 . every integer i 1 ≤ i ≤ n - 1 condition 1 ≤ ai ≤ n - i hold next make n - 1 portals number integers 1 n - 1 . i - th ( 1 ≤ i ≤ n - 1 ) portal connect cell i cell ( i + ai ) one travel cell i cell ( i + ai ) use i - th portal unfortunately one use portal backwards mean one move cell ( i + ai ) cell i use i - th portal easy see condition 1 ≤ ai ≤ n - i one ca n't leave line world use portals currently i stand cell 1 i want go cell t. however i n't know whether possible go please determine whether i go cell t use <unknown> transportation system first line contain two space - separated integers n ( 3 ≤ n ≤ 3 × 104 ) t ( 2 ≤ t ≤ n ) — number cells index cell i want go second line contain n - 1 space - separated integers a1 a2 ... - 1 ( 1 ≤ ai ≤ n - i ) guarantee use give transportation system one leave line world i go cell t use transportation system print ` ` yes '' otherwise print ` ` '' first sample visit cells : 1 2 4 ; successfully visit cell 4 . second sample possible cells visit : 1 2 4 6 7 8 ; ca n't visit cell 5 want visit","['dfs and similar', 'graphs', 'implementation']",1000.0
500/B,user ainta a permutation p1 p2 ... pn new year come want make permutation pretty possible permutation a1 a2 ... prettier permutation b1 b2 ... bn exist integer k ( 1 ≤ k ≤ n ) a1 = b1 a2 = b2 ... ak - 1 = bk - 1 ak < bk hold know permutation p sensitive could modify swap two distinct elements swap two elements harder think give n × n binary matrix a user ainta swap value pi pj ( 1 ≤ i j ≤ n i ≠ j ) ai j = 1 . give permutation p matrix a user ainta want know prettiest permutation obtain first line contain integer n ( 1 ≤ n ≤ 300 ) — size permutation p. second line contain n space - separated integers p1 p2 ... pn — permutation p user ainta integer 1 n occur exactly give permutation next n line describe matrix a. i - th line contain n character ' 0 ' ' 1 ' describe i - th row a. j - th character i - th line ai j element intersection i - th row j - th column a. guarantee integers i j 1 ≤ i < j ≤ n ai j = aj i hold also integers i 1 ≤ i ≤ n ai i = 0 hold first line print n space - separated integers describe prettiest permutation obtain first sample swap need obtain prettiest permutation : ( p1 <unknown> ) second sample swap need obtain prettiest permutation ( p1 p3 ) ( p4 p5 ) ( p3 p4 ) a permutation p a sequence integers p1 p2 ... pn consist n distinct positive integers n't exceed n. i - th element permutation p denote pi size permutation p denote n,"['dfs and similar', 'dsu', 'graphs', 'greedy', 'math', 'sortings']",1600.0
500/C,"new year come jaehyun decide read many book 2015 unlike year n book number integers 1 n. weight i - th ( 1 ≤ i ≤ n ) book wi jaehyun 's house large enough a bookshelf keep n book stack vertically want read a certain book x follow step describe decide read book m days j - th ( 1 ≤ j ≤ m ) day read book number integer bj ( 1 ≤ bj ≤ n ) read book use process describe paragraph possible decide re - read book several time make plan realize total weight book lift m days would heavy , decide change order stack book new year come minimize total weight may assume book stack possible order note book go read certain step n't consider lift step help ? first line contain two space - separated integers n ( 2 ≤ n ≤ 500 ) m ( 1 ≤ m ≤ 1000 ) — number book number days jaehyun would read book second line contain n space - separated integers w1 w2 ... wn ( 1 ≤ wi ≤ 100 ) — weight book third line contain m space separate integers b1 b2 ... bm ( 1 ≤ bj ≤ n ) — order book would read note read book print minimum total weight book lift achieve rearrange order stack book 's a picture depict example vertical column present stack book","['greedy', 'implementation', 'math']",1600.0
500/E,"celebrate new year many people post videos fall dominoes ; 's a list : https : <unknown> / <unknown> ? <unknown> = <unknown> user ainta live a 2d world go post a video well n dominoes a 2d cartesian plane i - th domino ( 1 ≤ i ≤ n ) represent a line segment parallel y - axis whose length li lower point domino x - axis let 's denote x - coordinate i - th domino pi dominoes place one another p1 < p2 < ... < pn - 1 < pn hold user ainta want take a video fall dominoes make dominoes fall push a single domino right , domino fall draw a circle - shaped orbit line segment totally overlap x - axis also s - th domino touch t - th domino fall t - th domino also fall towards right follow procedure domino s touch domino t segment represent s t intersect see picture push leftmost domino right fall touch dominoes ( a ) ( b ) ( c ) a result dominoes ( a ) ( b ) ( c ) also fall towards right however domino ( d ) wo n't affect push leftmost domino eventually fall touch domino ( c ) first time picture example fall dominoes red circle denote a touch two dominoes user ainta q plan post video j - th start push xj - th domino last yj - th domino fall sometimes could impossible achieve plan lengthen dominoes cost one dollar increase length a single domino 1 . user ainta want know plan minimum cost need achieve plan process independently i. e. domino 's length increase plan n't affect length plan set dominos fall except xj - th domino yj - th domino n't matter initial push domino xj first line contain integer n ( 2 ≤ n ≤ 2 × 105 ) — number dominoes next n line describe dominoes i - th line ( 1 ≤ i ≤ n ) contain two space - separated integers pi li ( 1 ≤ pi li ≤ 109 ) — x - coordinate length i - th domino guarantee p1 < p2 < ... < pn - 1 < pn next line contain integer q ( 1 ≤ q ≤ 2 × 105 ) — number plan next q line describe plan j - th line ( 1 ≤ j ≤ q ) contain two space - separated integers xj yj ( 1 ≤ xj < yj ≤ n ) mean j - th plan push xj - th domino shoot a video yj - th domino fall plan print a line contain minimum cost need achieve cost need print 0 . consider example dominoes set like picture let 's take a look 4th plan make 6th domino fall push 2nd domino length 3rd domino ( whose x - coordinate 4 ) increase 1 5th domino ( whose x - coordinate 9 ) increase 1 ( option increase 4th domino instead 5th also 1 ) , dominoes fall like picture cross denote a touch two dominoes","['data structures', 'dp', 'dsu']",2300.0
506/D,"mr . kitayuta buy undirected graph n vertices m edge vertices graph number 1 n. edge namely edge i a color ci connect vertex ai bi mr . kitayuta want process follow q query i - th query give two integers - ui vi find number color satisfy follow condition : edge color connect vertex ui vertex vi directly indirectly first line input contain space - separated two integers - n m ( 2 ≤ n ≤ 105 1 ≤ m ≤ 105 ) denote number vertices number edge respectively next m line contain space - separated three integers - ai bi ( 1 ≤ ai < bi ≤ n ) ci ( 1 ≤ ci ≤ m ) note multiple edge two vertices however multiple edge color two vertices , i ≠ j ( ai bi ci ) ≠ ( aj bj cj ) next line contain a <unknown> q ( 1 ≤ q ≤ 105 ) denote number query follow q line contain space - separated two integers - ui vi ( 1 ≤ ui vi ≤ n ) guarantee ui ≠ vi query print answer a separate line let 's consider first sample","['brute force', 'dfs and similar', 'dsu', 'graphs']",2400.0
508/B,"berland 2016 . exchange rate currency know burle increase much simplify calculations fractional part neglect exchange rate assume integer reliable source inform financier anton information exchange rate currency know burle tomorrow anton know tomorrow exchange rate even number obtain present rate swap exactly two distinct digits possible value meet condition exchange rate tomorrow maximum possible guarantee today exchange rate odd positive integer n. help anton determine exchange rate currency know tomorrow ! first line contain odd positive integer n — exchange rate currency know today length number n 's representation within range 2 105 inclusive representation n n't contain lead zero information tomorrow 's exchange rate inconsistent , integer meet condition print - 1 . otherwise print exchange rate currency know burle tomorrow maximum possible number even obtain today 's exchange rate swap exactly two digits exchange rate representation contain lead zero","['greedy', 'math', 'strings']",1300.0
508/E,notice memory limit non - standard recently arthur sasha study correct bracket sequence arthur understand topic perfectly become amaze correct bracket sequence even get a favorite correct bracket sequence length 2n unlike arthur sasha understand topic badly break arthur 's favorite correct bracket sequence spite arthur remember favorite sequence open parenthesis ( ' ( ' ) approximate distance correspond close one ( ' ) ' ) i - th open bracket remember segment [ li ri ] contain distance correspond close bracket formally speak i - th open bracket ( order leave right ) know difference position position correspond close bracket belong segment [ li ri ] help arthur restore favorite correct bracket sequence ! first line contain integer n ( 1 ≤ n ≤ 600 ) number open bracket arthur 's favorite correct bracket sequence next n line contain number li ri ( 1 ≤ li ≤ ri < 2n ) represent segment lie distance i - th open bracket correspond close one descriptions segment give order open bracket occur arthur 's favorite sequence list leave right possible restore correct bracket sequence give data print possible choice arthur get something wrong sequence correspond give information print a single line ` ` impossible '' ( without quote ),"['dp', 'greedy']",2200.0
513/E2,give array length n a number k. let 's pick k non - overlapping non - empty subarrays initial array let si sum i - th subarray order leave right compute maximum value follow expression : subarray a contiguous part array first line input contain two integers n k. second line contain n integers — elements array absolute value elements exceed 104 . problem consist two subproblems subproblems different constraints input get score correct submission subproblem description subproblems follow output a single integer — maximum possible value consider first sample test optimal solution obtain first subarray contain first element second subarray span next three elements last subarray contain last element sum subarrays 5 9 1 correspondingly consider second sample test optimal solution first subarray consist first two elements second subarray consist third element note last element belong subarray solution,['dp'],2700.0
514/C,watto owner a spare part store recently get order mechanism process string a certain way initially memory mechanism fill n string mechanism able process query follow type : ` ` give string s determine memory mechanism contain string t consist number character s differ s exactly one position '' watto already compile mechanism 's leave write a program check data consist n initial line m query decide entrust job first line contain two non - negative number n m ( 0 ≤ n ≤ 3·105 0 ≤ m ≤ 3·105 ) — number initial string number query respectively next follow n non - empty string upload memory mechanism next follow m non - empty string query mechanism total length line input n't exceed 6·105 line consist letter ' a ' ' b ' ' c ' query print a single line ` ` yes '' ( without quote ) memory mechanism contain require string otherwise print ` ` '' ( without quote ),"['binary search', 'data structures', 'strings']",2000.0
514/E,darth vader get bore sit sofa close eye think infinite root tree node exactly n sons node distance i - th leave child equal di sith lord love count number nod tree a distance x root distance sum lengths edge path nod get use activity even grow bore ' <unknown> ? ' — may ask 's feel superior know solve problem want challenge darth vader ? count require number nod answer rather large find modulo 109 + 7 . first line contain two space - separated integers n x ( 1 ≤ n ≤ 105 0 ≤ x ≤ 109 ) — number children node distance root within range need count nod next line contain n space - separated integers di ( 1 ≤ di ≤ 100 ) — length edge connect node i - th child print a single number — number vertexes tree distance root equal x. picture sample ( yellow color mark nod distance three ),['dp'],2200.0
515/C,"drazil play a math game varda let 's define positive integer x a product factorials digits example , first choose a decimal number a consist n digits contain least one digit larger 1 . number may possibly start lead zero find maximum positive number x satisfy follow two conditions:1 . x n't contain neither digit 0 digit 1.2 = help friends find number first line contain integer n ( 1 ≤ n ≤ 15 ) — number digits a. second line contain n digits a. least one digit a larger 1 . number a may possibly contain lead zero output a maximum possible integer satisfy condition zero ones number decimal representation first case ,","['greedy', 'math', 'sortings']",1400.0
518/D,ilya get tire sport program leave university get a job subway give task determine escalator load factor let 's assume n people stand queue escalator second one two follow possibilities take place : either first person queue enter escalator probability p first person queue n't move probability ( 1 - p ) <unknown> fear <unknown> make whole queue wait behind formally speak i - th person queue enter escalator people indices 1 i - 1 inclusive enter one second one person enter escalator escalator infinite a person enter never leave stand escalator follow second ilya need count expect value number people stand escalator t second task help solve complicate task first line input contain three number n p t ( 1 ≤ n t ≤ 2000 0 ≤ p ≤ 1 ) number n t integers number p real give exactly two digits decimal point print a single real number — expect number people stand escalator t second absolute relative error must n't exceed 10 - 6,"['combinatorics', 'dp', 'math']",1700.0
518/F,a certain meet a rule party ` ` a '' minister pavel suggest improve <unknown> system create a new pipe city city n × m rectangular square field square field either empty ( pipe go ) occupy ( pipe go square ) empty square denote character ' ' occupy square denote character ' # ' pipe must meet follow criteria : sample allow pip rout : sample forbid pip rout : sample pip represent character ' * ' ask write a program calculate number distinct ways make exactly one pipe city two ways make a pipe consider distinct distinct least one square first line input contain two integers n m ( 2 ≤ n m ≤ 2000 ) — height width berland map next n line contain m character — map city square map mark character ' ' square empty pipe square map mark character ' # ' square full pipe ca n't first line output print a single integer — number distinct ways create a pipe first sample 3 ways make a pipe ( square pipe mark character ' * ' ) :,"['binary search', 'brute force', 'combinatorics', 'dp', 'implementation']",2300.0
519/B,"a b prepare program contest b love debug code run solution start debug first compile code initially compiler display n compilation errors represent a positive integer effort b manage fix mistake another one mistake however despite fact b sure correct two errors understand exactly compilation errors disappear — compiler language b use show errors new order every time ! b sure unlike many program languages compilation errors program language depend , correct one error set error change help b find exactly two errors correct ? first line input contain integer n ( 3 ≤ n ≤ 105 ) — initial number compilation errors second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — errors compiler display first time third line contain n - 1 space - separated integers b1 b2 ... bn - 1 — errors display second compilation guarantee sequence third line contain number second string except exactly one fourth line contain n - 2 space - separated integers <unknown> <unknown> ... <unknown> - 2 — errors display third compilation guarantee sequence fourth line contain number third line except exactly one print two number a single line : number compilation errors disappear b make first second correction respectively first test sample b first correct error number 8 error number 123 . second test sample b first correct error number 1 error number 3 . note multiple errors number b correct one one step","['data structures', 'implementation', 'sortings']",1100.0
519/D,a b prepare program contest several years sport program solve many problems require calculate sort abstract object a b also develop rather peculiar taste a like lowercase letter latin alphabet assign letter a number show much like letter ( assign negative number letter dislike ) b like substrings especially like ones start end letter ( length must exceed one ) also a b a string s. try find many substrings t a string s interest b ( t start end letter length larger one ) also sum value letter ( assign a ) except first last one equal zero naturally a b quickly find number substrings t interest ? first line contain 26 integers xa xb ... xz ( - 105 ≤ xi ≤ 105 ) — value assign letter a b c ... z respectively second line contain string s length 1 105 character consist <unknown> lowercase <unknown> — string need calculate answer print answer problem first sample test string satisfy condition abca <unknown> second sample test string satisfy condition two occurences aa,"['data structures', 'dp', 'two pointers']",1800.0
520/C,vasya become interest bioinformatics 's go write article similar cyclic dna sequence invent a new method determine similarity cyclic sequence let 's assume string s t length n function h ( s t ) define number position respective symbols s t function h ( s t ) use define function vasya distance ρ ( s t ) : vasya find a string s length n internet want count many string t vasya distance string s attain maximum possible value formally speak t must satisfy equation : vasya could try possible string find answer need help answer may large count number string modulo 109 + 7 . first line input contain a single integer n ( 1 ≤ n ≤ 105 ) second line input contain a single string length n consist character ` ` <unknown> '' print a single number — answer modulo 109 + 7 . please note two distinct string t1 t2 value ρ ( s t1 ) и ρ ( s t2 ) maximum among possible t string must take account answer even one obtain a circular shift another one first sample ρ ( ` ` c '' ` ` c '' ) = 1 remain string t length 1 value ρ ( s t ) 0 . second sample ρ ( ` ` ag '' ` ` ag '' ) = ρ ( ` ` ag '' ` ` ga '' ) = ρ ( ` ` ag '' ` ` aa '' ) = ρ ( ` ` ag '' ` ` gg '' ) = 4 . third sample ρ ( ` ` ttt '' ` ` ttt '' ) = 27,"['math', 'strings']",1500.0
520/D,vasya petya assemble a figure m cub associate a number 0 m - 1 ( inclusive number appear exactly ) let 's consider a coordinate system ox grind oy direct upwards cube associate coordinate lower leave corner coordinate integers cube figure turn stable mean cube grind least one cube two cub touch a side a corner formally mean cube coordinate ( x y ) either y = 0 a cube coordinate ( x - 1 y - 1 ) ( x y - 1 ) ( x + 1 y - 1 ) boys want disassemble figure put cub a row one step cube remove figure put right block already lay guy remove cub order figure remain stable make process interest guy decide play follow game guy take cub figure turn easy see figure disassemble integers write cub form a number write m - ary positional numerical system ( possibly a lead zero ) vasya want result number maximum possible petya contrary try make small possible vasya start game task determine number form figure disassemble boys play optimally determine remainder answer modulo 109 + 9 . first line contain number m ( 2 ≤ m ≤ 105 ) follow m line contain coordinate cub xi yi ( - 109 ≤ xi ≤ 109 0 ≤ yi ≤ 109 ) ascend order number write guarantee original figure stable two cub occupy place line print answer problem,"['greedy', 'implementation']",2100.0
522/C,"polycarp fly airplane finally favorite time — lunchtime beravia company stewardess give food consecutively passengers 1 - th one last one polycarp sit seat m mean m - th person get food flight menu k dish total polycarp board flight time count number portion dish board thus know value a1 a2 ... ak ai number portion i - th dish stewardess already give food m - 1 passengers give polycarp a polite smile ask would prefer 's polycarp realize might run dish moment m - 1 passengers ahead notice dish give besides 's hear strange <unknown> m - 1 passengers ahead similar phrase ' i ' m disappoint ' happen a passenger ask dish stewardess give a polite smile say run dish case passenger need choose dish available polycarp hear sound a passenger mean passenger choose dish first try help polycarp find dish : whether could run dish moment <unknown> serve dish definitely available test problem consist one input set first go a string contain a single integer t ( 1 ≤ t ≤ 100 000 ) — number input data set test set follow set precede empty line first line set input contain integers m k ( 2 ≤ m ≤ 100 000 1 ≤ k ≤ 100 000 ) — number polycarp 's seat number dish respectively second line contain a sequence k integers a1 a2 ... ak ( 1 ≤ ai ≤ 100 000 ) ai initial number portion i - th dish m - 1 line follow line contain description polycarp 's observations give food a passenger sit front : j - th line contain a pair integers tj rj ( 0 ≤ tj ≤ k 0 ≤ rj ≤ 1 ) tj number dish give j - th passenger ( 0 polycarp n't notice dish give passenger ) rj — a 1 a 0 depend whether j - th passenger n't disappoint respectively know sum ai equal least m , polycarp definitely get dish even last thing want guarantee data consistent sum m input set n't exceed 100 000 . sum k input set n't exceed 100 000 . input set print answer a single line print a string k letter ` ` y '' ` ` n '' letter ` ` y '' position i print could run i - th dish time stewardess start serve polycarp first input set depend choice second passenger situation could develop different ways : thus answer ` ` <unknown> '' second input set example follow possible scenario first first passenger take third dish second passenger take second dish , third passenger ask third dish available make disappoint mutter end second dish fourth passenger take fourth dish polycarp end choice first fourth fifth dish likewise another possible scenario time stewardess come polycarp run either first fifth dish ( happen one dish take second passenger ) easy see enough fourth dish polycarp always count thus answer ` ` <unknown> ''",['greedy'],2100.0
524/B,<unknown> много <unknown> и на <unknown> <unknown> <unknown> n друзей с <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> вперёд <unknown> <unknown> с <unknown> и теперь не <unknown> чтобы один из друзей <unknown> с <unknown> и тем <unknown> <unknown> не <unknown> на <unknown> <unknown> <unknown> <unknown> можно <unknown> следующим образом на фотографии каждый из друзей занимает прямоугольник из пикселей : в <unknown> <unknown> i - й из них занимает прямоугольник ширины wi пикселей и высоты hi пикселей но также при <unknown> каждый человек может <unknown> и тогда он будет <unknown> прямоугольник ширины hi пикселей и высоты wi пикселей общая фотография будет иметь размеры w × h где w — <unknown> <unknown> всех <unknown> - людей а h — <unknown> из <unknown> <unknown> хотят определить <unknown> <unknown> <unknown> может иметь общая фотография помогите им в этом в первой строке следует целое число n ( 1 ≤ n ≤ 1000 ) — количество друзей в последующих n строках следуют по два целых числа wi hi ( 1 ≤ wi hi ≤ 1000 ) <unknown> размеры <unknown> <unknown> i - <unknown> из друзей выведите <unknown> целое число <unknown> <unknown> возможной <unknown> фотографии <unknown> всех друзей,"['dp', 'greedy']",1700.0
525/D,finally a day arthur enough money buy apartment find a great option close center city a nice price plan apartment find arthur look like a rectangle n × m consist square size 1 × 1 . square contain either a wall ( square denote a symbol ` ` * '' plan ) a free space ( square denote plan a symbol ` ` . ` ` ) room apartment a maximal connect area consist free square square consider adjacent share a common side old arthur dream live apartment room rectangles ask calculate minimum number wall need remove order achieve goal remove a wall a square become a free square remove wall possible room unite a single one first line input contain two integers n m ( 1 ≤ n m ≤ 2000 ) denote size arthur apartments follow n line contain m symbols — plan apartment cell denote a symbol ` ` * '' contain a wall cell denote a symbol ` ` . '' cell free wall also cell contain room output n row consist m symbols show arthur apartment plan look like delete minimum number wall order make room ( maximum connect area free wall ) a rectangle several possible answer output,"['data structures', 'graphs', 'greedy', 'shortest paths']",2400.0
526/A,problem meet simplify model game king thieve a new zeptolab game call ` ` king thieve '' aim reach a chest gold control character avoid trap obstacles way interest feature game design level available players let 's consider follow simple design a level a dungeon consist n segment locate a vertical level segment either a platform character stand a pit a trap make player lose fall segment length platforms scheme level represent ' * ' pit represent ' . ' one things affect <unknown> characteristics level a possibility perform a series consecutive jump length formally character platform number i1 make a sequence jump platforms i1 < i2 < ... < ik i2 - i1 = i3 - i2 = ... = ik - ik - 1 . course segment i1 i2 ... ik exactly platforms pit let 's call a level good perform a sequence four jump length word must a sequence i1 i2 ... <unknown> consist five platforms intervals consecutive platforms length give scheme level check good first line contain integer n ( 1 ≤ n ≤ 100 ) — number segment level next line contain scheme level represent a string n character ' * ' ' . ' level good print word ` ` yes '' ( without quote ) otherwise print word ` ` '' ( without quote ) first sample test may perform a sequence jump platforms 2 5 8 11 14,"['brute force', 'implementation']",1300.0
526/C,a sweet little monster om nom love candy much one day find a rather tricky situation require think a bite order enjoy candy would succeed task place ? one day come friend <unknown> om nom n't find home find two bag candy first full blue candy second bag full red candy om nom know red candy weigh wr grams blue candy weigh wb grams eat a single red candy give om nom hr joy units eat a single blue candy give om nom hb joy units candy important thing world hand overeat good om nom know eat c grams candy get sick om nom think n't proper leave candy leftovers eat a whole candy om nom a great mathematician quickly determine many candy type eat order get maximum number joy units repeat achievement ? assume bag contain candy om nom eat single line contain five integers c hr hb wr wb ( 1 ≤ c hr hb wr wb ≤ 109 ) print a single integer — maximum number joy units om nom get sample test om nom eat two candy type thus get 16 joy units,"['brute force', 'greedy', 'math']",2000.0
527/A,one day vasya sit a interest maths lesson make origami a rectangular a mm × b mm sheet paper ( a > b ) usually first step make origami make a square piece paper rectangular sheet fold sheet along <unknown> right angle cut excess part make a paper ship square piece vasya look remain ( a - b ) mm × b mm strip paper get idea use strip paper way make origami use remainder ( exist ) moment leave a square piece paper make last ship stop determine many ship vasya make lesson ? first line input contain two integers a b ( 1 ≤ b < a ≤ 1012 ) — size original sheet paper print a single integer — number ship vasya make picture first second sample test,"['implementation', 'math']",1100.0
527/C,"leonid want become a glass carver ( person create beautiful artworks cut glass ) already a rectangular w mm × h mm sheet glass a diamond glass <unknown> lot enthusiasm lack understand carve order waste time decide practice technique carve , make vertical horizontal cut entire sheet process result make smaller rectangular fragment glass leonid move newly make glass fragment particular a cut divide fragment glass go smaller fragment cut leonid try determine area largest currently available glass fragment since appear fragment question take time distract fascinate process leonid offer divide labor — cut glass calculate area maximum fragment cut agree ? first line contain three integers w h n ( 2 ≤ w h ≤ 200 000 1 ≤ n ≤ 200 000 ) next n line contain descriptions cut description form h y v x. first case leonid make horizontal cut distance y millimeters ( 1 ≤ y ≤ h - 1 ) lower edge original sheet glass second case leonid make a vertical cut distance x ( 1 ≤ x ≤ w - 1 ) millimeters leave edge original sheet glass guarantee leonid wo n't make two identical cut cut print a single line area maximum available glass fragment <unknown> picture first sample test :","['binary search', 'data structures', 'implementation']",1500.0
527/D,clique problem one well - known np - complete problems simplification formulate follow consider undirected graph g. require find a subset vertices c maximum size two connect edge graph g. sound simple n't ? nobody yet know algorithm find a solution problem polynomial time size graph however many np - complete problems clique problem easier consider a specific type a graph consider n distinct point a line let i - th point coordinate xi weight wi let 's form graph g whose vertices point edge connect exactly pair point ( i j ) distance less sum weight formally : |xi - xj| ≥ wi + wj find size maximum clique graph first line contain integer n ( 1 ≤ n ≤ 200 000 ) — number point next n line contain two number xi wi ( 0 ≤ xi ≤ 109 1 ≤ wi ≤ 109 ) — coordinate weight a point xi different print a single number — number vertexes maximum clique give graph happen know solve problem without use specific properties graph formulate problem statement able get a prize one million dollars ! picture sample test,"['data structures', 'dp', 'greedy', 'implementation', 'sortings']",1800.0
527/E,project a data center a big software company consist n computers connect m cable simply speak computer consider a box multiple cable go box important information transmit along cable one two directions data center plan yet approve n't determine yet direction information go along cable cable put computer connect one perhaps computers person charge clean data center claudia ivanova <unknown> love tie cable bundle use cable tie reason group cable stick a computer group two n't possible get furious attack computer water bucket also note due specific physical characteristics important information strictly forbid connect one bundle two cable information flow different directions management data center want determine send information along cable claudia ivanova able group cable come computer group two observe condition since may possible exist connections plan allow add minimum possible number cable scheme need determine direction information flow cable ( yes sometimes data center design base <unknown> ' convenience ... ) first line contain two number n m ( 1 ≤ n ≤ 100 000 1 ≤ m ≤ 200 000 ) — number computers number already present cable respectively next line contain two number ai bi ( 1 ≤ ai bi ≤ n ) — indices computers connect i - th cable data center often a complex structure a pair computers may one pair cable cable may connect a computer first line print a single number p ( p ≥ m ) — minimum number cable final scheme next p line print a pair number ci di ( 1 ≤ ci di ≤ n ) describe another cable entry mean information go along a certain cable direction ci di among cable print cable present original plan two possible directions guarantee a solution p n't exceed 500 000 . several <unknown> solutions minimum possible value p print picture first sample test tie pair cable show go point picture second test statement add cable <unknown> bold alternative answer second sample test :,"['dfs and similar', 'graphs']",2600.0
529/B,"many years pass n friends meet a party technologies leap forward since last meet cameras timer appear obligatory one friends stand a camera , thus absent photo simply speak process photograph describe follow friend occupy a rectangle pixels photo : i - th a stand state occupy a wi pixels wide a hi pixels high rectangle also person lie photo occupy a hi pixels wide a wi pixels high rectangle total photo size w × h w total width people rectangles h maximum heights friends want determine minimum area group photo obtain n / 2 lie grind ( would strange n / 2 gentlemen lie grind together n't ?   ) help achieve goal first line contain integer n ( 1 ≤ n ≤ 1000 ) — number friends next n line two integers wi hi ( 1 ≤ wi hi ≤ 1000 ) represent size rectangle correspond i - th friend print a single integer equal minimum possible area photo contain friends n / 2 lie grind","['brute force', 'greedy', 'sortings']",1900.0
53/B,one popular blog site edit upload photos like cut a rectangular area ratio height width ( i.e height / width quotient ) vary 0.8 1.25 inclusively besides least one side cut area a size equal power number 2 ( 2x integer x ) rule n't indicate size cut clearly way cut part possess largest area choose course side cut area integer several answer problem choose answer maximal height first line contain a pair integers h w ( 1 ≤ h w ≤ 109 ) height width upload photo pixels print two integers height width cut area,"['binary search', 'implementation']",1700.0
534/A,exam n students take place a long narrow room students sit a line order teacher suspect students adjacent number ( i i + 1 ) always study side side become friends take exam sit next help sure task choose maximum number students make arrangement students room two students adjacent number sit side side a single line contain integer n ( 1 ≤ n ≤ 5000 ) — number students exam first line print integer k — maximum number students seat two students adjacent number sit next second line print k distinct integers a1 a2 ... ak ( 1 ≤ ai ≤ n ) ai number student i - th position students adjacent position must n't adjacent number formally follow true : |ai - ai + 1| ≠ 1 i 1 k - 1 . several possible answer output,"['implementation', 'math']",1100.0
534/C,polycarp n dice d1 d2 ... dn i - th dice show number 1 di polycarp roll dice sum number show a. agrippina n't see dice show number know sum a value d1 d2 ... dn however find enough make a series statements follow type : dice i could n't show number r. example polycarp two six - faced dice total sum a = 11 agrippina state two dice could n't show a value less five ( otherwise remain dice must a value least seven impossible ) dice find number value guarantee dice could n't show value sum show value a. first line contain two integers n a ( 1 ≤ n ≤ 2·105 n ≤ a ≤ s ) — number dice sum show value s = d1 + d2 + ... + dn second line contain n integers d1 d2 ... dn ( 1 ≤ di ≤ 106 ) di maximum value i - th dice show print n integers b1 b2 ... bn bi number value guarantee i - th dice could n't show first sample statement a equal 8 could obtain case first second dice show 4 . correspondingly dice could n't show value 1 2 3 . second sample statement a equal 3 could obtain single dice show 3 . correspondingly could n't show 1 2 4 5 . third sample statement a equal 3 could obtain one dice show 1 dice show 2 . 's first dice n't value could n't show second dice could n't show 3,['math'],1600.0
534/E,"berland a bus travel along main street capital street begin main square look like a long segment n bus stop locate along street i - th locate distance ai central square distance distinct stop number order increase distance square , ai < ai + 1 i 1 n - 1 . bus start journey first stop pass stop 2 3 reach stop number n turn around go opposite direction stop 1 pass intermediate stop reverse order , start move towards stop n. day bus run non - stop route bus equip berland local position system bus pass a stop system note number one key feature system respond query distance cover bus part path pair stop a special module system take input information a set stop a segment path a stop number occur set many time bus drive past module return length travel segment path ( -1 impossible determine length uniquely ) operation module complicate fact stop number occur request order visit non - decreasing order example number stop 6 part bus path start bus stop number 5 end stop number 3 pass stop follow : request segment path form : 3 4 5 5 6 . bus segment path stop 5 stop 3 time drive past 1 - th stop ( i.e. consider a segment end second visit stop 3 way 5 ) request form : 1 2 2 3 3 4 5 5 6 . repeat berland programmers achievement implement function first line contain integer n ( 2 ≤ n ≤ 2·105 ) — number stop second line contain n integers ( 1 ≤ ai ≤ 109 ) — distance i - th stop central square number second line go increase order third line contain integer m ( 1 ≤ m ≤ 4·105 ) — number stop bus visit segment path fourth line contain m integers ( 1 ≤ bi ≤ n ) — sort list number stop visit bus segment path number a stop occur many time visit a bus guarantee query correspond segment path single line please print distance cover a bus impossible determine unambiguously print - 1 . first test statement demonstrate first example show statement problem second test statement demonstrate second example show statement problem third sample two possible paths distinct lengths consequently seek length segment n't define uniquely fourth sample even though two distinct paths correspond query lengths seek length segment define uniquely","['greedy', 'implementation']",2400.0
535/D,"tavas a strange creature usually ` ` zzz '' come people 's mouth sleep string s length n come tavas ' mouth instead today tavas fell asleep malekas ' place sleep malekas a little process s. malekas a favorite string p. determine position x1 < x2 < ... < xk p match s. formally xi ( 1 ≤ i ≤ k ) condition <unknown> + 1 ... <unknown> + |p| - 1 = p <unknown> malekas write one subsequences x1 x2 ... xk ( possibly n't write anything ) a piece paper a sequence b a subsequence sequence a turn a b remove elements ( maybe one ) tavas wake malekas tell everything could n't remember string s know p s contain lowercase english letter also subsequence write piece paper tavas wonder number possible value s ? ask saddas n't smart enough solve , tavas ask calculate number answer large tavas want print answer modulo 109 + 7 . first line contain two integers n m length s length subsequence malekas write ( 1 ≤ n ≤ 106 0 ≤ m ≤ n - |p| + 1 ) second line contain string p ( 1 ≤ |p| ≤ n ) next line contain m space separate integers y1 y2 ... ym malekas ' subsequence ( 1 ≤ y1 < y2 < ... < ym ≤ n - |p| + 1 ) a single line print answer modulo 1000 000 007 . first sample test string form ` ` <unknown> ? '' question mark replace arbitrary english letter satisfy |x| denote length string x. please note 's possible string ( answer 0 )","['greedy', 'strings']",1900.0
536/D,tavas live kansas kansas n cities number 1 n connect m bidirectional roads travel city city via roads kansas strange tavas may a road a city one road two cities tavas invent a game call ` ` dashti '' want play dashti girlfriends nafas game assign arbitrary integer value city kansas value i - th city equal pi game tavas city s nafas city t. play turn tavas go first a player his / her turn must choose a non - negative integer x his / her score increase sum value cities ( shortest ) distance x his / her city city may use word first time a player get score a city city score become zero additional rule : player must choose x he / she get point least one city use note city may initially value 0 city n't consider use begin game i. e. player may use <unknown> rule game end nobody make a move a player 's score sum point he / she earn game winner player greater score a draw players score value players start game zero point tavas win 'll break girlfriend 's heart nafas win tavas cry score equal 'll happy tavas give nafas flower 're emotional 'll play optimally task tell tavas 's go happen game end first line input contain two integers n m ( 2 ≤ n ≤ 2000 n - 1 ≤ m ≤ 105 ) second line input contain two integers s t ( 1 ≤ s t ≤ n s ≠ t ) next line contain n integers p1 p2 ... pn separate space ( |pi| ≤ 109 ) next m line contain roads line contain three integers v u w mean 's road length w cities v u ( 1 ≤ u v ≤ n 0 ≤ w ≤ 109 ) road may lead city may several roads pair cities tavas win print ` ` break a heart '' nafas win print ` ` cry '' nobody win ( i. e. game end draw ) print ` ` flower '',['dp'],2900.0
54/C,probability theory follow paradox call <unknown> 's law know : ` ` many list random number take real source number start digit 1 occur much often number start digit '' ( 's simplest form law ) read codeforces hedgehog get intrigue statement wish thoroughly explore find follow similar problem interest particular : n random variables i - th take integer value segment [ li ; ri ] ( number segment equiprobable ) mean value i - th quantity equal integer number a give interval [ li ; ri ] probability 1 / ( ri - li + 1 ) hedgehog want know probability event first digits least k % value equal one word let us consider set fix value random variables leave first digit ( <unknown> — significant digit ) value let 's count many time digit 1 encounter encounter least k per cent n value set value call a good one find probability a set value give random variables a good one first line contain number n number random variables ( 1 ≤ n ≤ 1000 ) follow n line contain pair number li ri a description a random variable guarantee 1 ≤ li ≤ ri ≤ 1018 . last line contain integer k ( 0 ≤ k ≤ 100 ) number input file integers please use % lld specificator read write 64 - bit integers c++ preffered use cin ( also may use % i64d ) print require probability print fractional number a precision relative absolute error result wo n't exceed 10 - 9,"['dp', 'math']",2000.0
540/D,bad luck island inhabit three kinds species : r rock s scissor p paper moments time two random individuals meet ( pair individuals meet equiprobably ) belong different species one individual kill one : a rock kill scissor scissor kill paper paper kill a rock task determine species probability species one inhabit island a long enough period time single line contain three integers r s p ( 1 ≤ r s p ≤ 100 ) — original number individuals species rock scissor paper respectively print three space - separated real number : probabilities rock scissor paper survive species respectively answer consider correct relative absolute error number n't exceed 10 - 9,['dp'],1900.0
543/E,please note memory limit differ standard really love listen music next s days listen exactly m songs playlist consist exactly n songs let 's number songs playlist number 1 n inclusive quality song number i ai i - th day choose integer v ( li ≤ v ≤ ri ) listen songs number v v + 1 ... v + m - 1 . i - th day listen one song quality less qi increase displeasure exactly one determine minimum displeasure get s next days first line contain two positive integers n m ( 1 ≤ m ≤ n ≤ 2·105 ) second line contain n positive integers a1 a2 ... ( 0 ≤ ai < 230 ) — description songs playlist next line contain a single number s ( 1 ≤ s ≤ 2·105 ) — number days consider next s line contain three integers li ri xi ( 1 ≤ li ≤ ri ≤ n - m + 1 ; 0 ≤ xi < 230 ) — description parameters i - th day order calculate value qi need use formula : ansi answer problem day i. assume ans0 = 0 . print exactly s integers <unknown> <unknown> ... <unknown> ansi minimum displeasure get day i,['data structures'],3200.0
544/B,a map object a rectangular field consist n row n columns cell initially occupy sea cover cells map sand exactly k islands appear map call a set sand cells island possible get move sand cells move a cell a side - adjacent cell cells call side - adjacent share a vertical horizontal side easy see islands share cells ( otherwise together form a bigger island ) find a way cover cells sand exactly k islands appear n × n map determine way exist single line contain two positive integers n k ( 1 ≤ n ≤ 100 0 ≤ k ≤ n2 ) — size map number islands form answer n't exist print ` ` '' ( without quote ) a single line otherwise print ` ` yes '' first line next n line print description map line description must consist character 's ' ' l ' 's ' a cell occupy sea ' l ' cell cover sand length line description must equal n. multiple answer may print maximize size islands,['implementation'],1400.0
545/D,little girl susie go shop mom wonder improve service quality n people queue person know time ti need serve a person disappoint time wait time need serve time a person wait total time people stand queue front serve susie think swap people queue decrease number people disappoint help susie find maximum number disappoint people achieve swap people queue first line contain integer n ( 1 ≤ n ≤ 105 ) next line contain n integers ti ( 1 ≤ ti ≤ 109 ) separate space print a single number — maximum number disappoint people queue value 4 achieve arrangement example : 1 2 3 5 15 . thus make everything feel disappoint except person time 5,"['greedy', 'implementation', 'sortings']",1300.0
546/B,colonel n badge want give one badge every n soldier badge a coolness factor show much 's owner reach coolness factor increase one cost one coin every pair soldier one get a badge strictly higher factor second one exact value factor n't important need distinct factor colonel know soldier suppose get badge initially a problem badge may factor coolness help calculate much money pay make badge different factor coolness first line input consist one integer n ( 1 ≤ n ≤ 3000 ) next line consist n integers ai ( 1 ≤ ai ≤ n ) stand coolness factor badge output single integer — minimum amount coin colonel pay first sample test increase factor first badge 1 . second sample test increase factor second third badge 1,"['brute force', 'greedy', 'implementation', 'sortings']",1200.0
546/D,two soldier play a game begin first choose a positive integer n give second soldier second one try make maximum possible number round round consist choose a positive integer x > 1 n divisible x replace n n / x. n become equal 1 possible valid move game score second soldier equal number round perform make game interest first soldier choose n form a ! / b ! positive integer a b ( a ≥ b ) k ! denote factorial k define a product positive integers large k. maximum possible score second soldier ? first line input consist single integer t ( 1 ≤ t ≤ 1 000 000 ) denote number game soldier play follow t line contain pair integers a b ( 1 ≤ b ≤ a ≤ 5 000 000 ) define value n a game game output a maximum score second soldier get,"['dp', 'math', 'number theory']",1700.0
546/E,country n cities m bidirectional roads city army army i - th city consist ai soldier soldier roam roam soldier either stay city go one neighbor cities move along one road check possible roam exactly bi soldier i - th city first line input consist two integers n m ( 1 ≤ n ≤ 100 0 ≤ m ≤ 200 ) next line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 100 ) next line contain n integers b1 b2 ... bn ( 0 ≤ bi ≤ 100 ) m line follow consist two integers p q ( 1 ≤ p q ≤ n p ≠ q ) denote undirected road cities p q. guarantee one road pair cities condition meet output single word ` ` '' otherwise output word ` ` yes '' n line consist n integers number i - th line j - th column denote many soldier road city i city j ( i ≠ j ) many soldier stay city i ( i = j ) several possible answer may output,"['graphs', 'math']",2100.0
547/D,everyone know bear love fish mike a strange bear ; hat fish ! even strange thing infinite number blue red fish mark n distinct point plane i - th point point ( xi yi ) want put exactly one fish point difference number red fish blue fish horizontal vertical line 1 . ca n't find a way perform ! please help first line input contain integer n ( 1 ≤ n ≤ 2 × 105 ) next n line contain information point i - th line contain two integers xi yi ( 1 ≤ xi yi ≤ 2 × 105 ) i - th point coordinate guarantee least one valid answer print answer a sequence n character ' r ' ( red ) ' b ' ( blue ) i - th character denote color fish i - th point,"['dfs and similar', 'graphs']",2600.0
548/B,"mike bear play a game fun mike judge bear except mike stand n × m grid 's exactly one bear cell denote bear stand column number j row number i ( i j ) mike 's hand ears ( since 's judge ) bear stand grid hand either mouth eye play q round round mike choose a bear ( i j ) tell change state i. e. hand mouth 'll put hand eye 'll put hand mouth otherwise , mike want know score bear score bear maximum row number consecutive bear hand eye row since bear lazy mike ask help round tell score bear change state a bear select round first line input contain three integers n m q ( 1 ≤ n m ≤ 500 1 ≤ q ≤ 5000 ) next n line contain grid description m integers separate space line number either 0 ( mouth ) 1 ( eye ) next q line contain information round contain two integers i j ( 1 ≤ i ≤ n 1 ≤ j ≤ m ) row number column number bear change state round print current score bear","['brute force', 'dp', 'greedy', 'implementation']",1400.0
549/A,"developers looksery write efficient algorithm detect face a picture unfortunately currently busy prepare a contest , problem image a rectangular table consist lowercase latin letter a face image a 2 × 2 square four letter square make word ` ` face '' need write a program determine number face image square correspond face overlap first line contain two space - separated integers n m ( 1 ≤ n m ≤ 50 ) — height width image respectively next n line define image line contain m lowercase latin letter single line print number face image first sample image contain a single face locate a square upper leave corner second line second column : second sample image also contain exactly one face upper leave corner second row first column third sample two face show : fourth sample image face","['implementation', 'strings']",900.0
549/G,like summer ? residents berland especially love eat ice cream hot summer summer day a large queue n berland residents line front ice cream stall know a certain amount berland dollars residents berland nice people person agree swap place person right behind 1 dollar formally person a stand behind person b person a pay person b 1 dollar a b get swap course person a zero dollars swap place person b. residents berland strange people particular get upset someone a strictly smaller sum money line front help residents berland form order line happy ? a happy resident one stand first line one front another resident stand less number dollars note people berland people honor agree swap place manner describe first line contain integer n ( 1 ≤ n ≤ 200 000 ) — number residents stand line second line contain n space - separated integers ai ( 0 ≤ ai ≤ 109 ) ai number berland dollars a man stand i - th position line position number start end line impossible make residents happy print ` ` : ( ` ` without quote otherwise print single line n space - separated integers i - th must equal number money person position i new line multiple answer print first sample two residents swap place first resident 10 dollars head line second resident 9 coin end line second sample impossible achieve desire result third sample first person swap second one follow number dollars : 4 11 3 second person ( new line ) swap third one result number dollars equal : 4 4 10 . line everybody happy,"['greedy', 'sortings']",2200.0
550/B,n problems estimate difficulty i - th one integer ci want prepare a problemset a contest use problems ' ve make a problemset contest must consist least two problems think total difficulty problems contest must least l r. also think difference difficulties easiest hardest choose problems must least x. find number ways choose a problemset contest first line contain four integers n l r x ( 1 ≤ n ≤ 15 1 ≤ l ≤ r ≤ 109 1 ≤ x ≤ 106 ) — number problems minimum maximum value total difficulty problemset minimum difference difficulty hardest problem pack easiest one respectively second line contain n integers c1 c2 ... cn ( 1 ≤ ci ≤ 106 ) — difficulty problem print number ways choose a suitable problemset contest first example two set suitable one consist second third problem another one consist three problems second example two set problems suitable — set problems difficulties 10 30 well set problems difficulties 20 30 . third example set consist one problem difficulty 10 one problem difficulty 20 suitable,"['bitmasks', 'brute force']",1400.0
550/E,"implication a function two logical arguments value false value first argument true value second argument false implication write use character ` ` arguments result implication write ' 0 ' ( false ) ' 1 ' ( true ) accord definition implication : a logical expression contain multiple <unknown> bracket calculate leave fight example , bracket first calculate expression bracket example , give logical expression determine possible place bracket value a logical expression false possible task find arrangement bracket first line contain integer n ( 1 ≤ n ≤ 100 000 ) — number arguments a logical expression second line contain n number a1 a2 ... ( ) mean value arguments expression order occur print ` ` '' ( without quote ) impossible place bracket expression value equal 0 . otherwise print ` ` yes '' first line logical expression require arrangement bracket second line expression contain character ' 0 ' ' 1 ' ' - ' ( character ascii code 45 ) ' > ' ( character ascii code 62 ) ' ( ' ' ) ' character ' - ' ' > ' occur expression pair like : ( ` ` - > '' ) represent implication total number logical arguments ( i.e digits ' 0 ' ' 1 ' ) expression must equal n. order digits follow expression leave right must coincide a1 a2 ... , expression correct formally a correct expression determine follow : total number character result expression must n't exceed 106 . multiple possible answer allow print","['greedy', 'implementation', 'math']",2200.0
551/B,professor gukiz n't accept string like swap letter string obtain a new one gukiz string a b c. want obtain string k swap letter a k contain many non - overlapping substrings equal either b c possible substring string x a string form consecutive segment character x. two substrings string x overlap position i string x occupy gukiz disappoint none students manage solve problem help find one possible string k ? first line contain string a second line contain string b third line contain string c ( 1 ≤ |a| |b| |c| ≤ 105 |s| denote length string s ) three string consist lowercase english letter possible b c coincide find one possible string k describe problem statement multiple possible answer print third sample optimal solutions three non - <unknown> substrings equal either b c position 1 – 2 ( ab ) 3 – 4 ( ab ) 5 – 7 ( aca ) sample exist many optimal solutions one would <unknown>,"['brute force', 'implementation', 'strings']",1800.0
552/A,vanya a table consist 100 row row contain 100 cells row number integers 1 100 bottom top columns number 1 100 leave right table vanya choose n rectangles side go along border square ( rectangles probably occur multiple time ) cell table count number rectangles belong write number want find sum value cells table table large ask help find result first line contain integer n ( 1 ≤ n ≤ 100 ) — number rectangles follow n line contain four integers x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ 100 1 ≤ y1 ≤ y2 ≤ 100 ) x1 y1 number column row lower leave cell x2 y2 number column row upper right cell a rectangle a single line print sum value cells table note first sample test : value table first three row columns <unknown> sum value equal 10 . note second sample test : value table first three row columns <unknown> sum value equal 18,"['implementation', 'math']",1000.0
552/E,vanya maths homework expression form x1 x2 ... xn digits 1 9 sign represent either a plus ' + ' multiplication sign ' * ' vanya need add one pair bracket expression maximize value result expression first line contain expression s ( 1 ≤ |s| ≤ <unknown> |s| odd ) odd position contain digits 1 9 even position contain sign + * number sign * n't exceed 15 . first line print maximum possible value expression note first sample test 3 + 5 * ( 7 + 8 ) * 4 = <unknown> . note second sample test ( 2 + 3 ) * 5 = 25 . note third sample test ( 3 * 4 ) * 5 = 60 ( also many variants valid instance ( 3 ) * 4 * 5 = 60 ),"['brute force', 'dp', 'greedy', 'implementation', 'strings']",2100.0
553/A,"kyoya ootori a bag n color ball color k different color color label 1 k. ball color indistinguishable draw ball bag one one bag empty notice draw last ball color i draw last ball color i + 1 i 1 k - 1 . wonder many different ways happen first line input one integer k ( 1 ≤ k ≤ 1000 ) number color , k line follow i - th line contain ci number ball i - th color ( 1 ≤ ci ≤ 1000 ) total number ball n't exceed 1000 . a single integer number ways kyoya draw ball bag describe statement modulo 1 000 000 007 . first sample 2 ball color 1 2 ball color 2 1 ball color 3 . three ways kyoya :","['combinatorics', 'dp', 'math']",1500.0
553/C,"many anime ` ` love triangles '' : alice love bob charlie love bob well alice hat charlie think anime n character character label 1 n. every pair two character either mutually love mutually hate ( neutral state ) hate love triangles ( a - b love b - c love a - c hate ) also hate nobody love , consider three character happy exactly one pair love ( a b love c hat a b ) three pair love ( a love b b love c c love a ) give a list m know relationships anime know sure certain pair love certain pair hate 're wonder many ways fill remain relationships happy every triangle two ways consider different two character love one way hate print count modulo 1 000 000 007 . first line input contain two integers n m ( 3 ≤ n ≤ 100 000 0 ≤ m ≤ 100 000 ) next m line contain description know relationships i - th line contain three integers ai bi ci ci 1 ai bi love otherwise hate ( 1 ≤ ai bi ≤ n ai ≠ bi ) pair people describe print a single integer equal number ways fill remain pair happy every triangle modulo 1 000 000 007 . first sample four ways : second sample possible solution make 1 3 love 2 4 hate","['dfs and similar', 'dsu', 'graphs']",2200.0
553/E,kyoya ootori want take train get school n train station m one - way train line go various station kyoya currently train station 1 school station n. take a train must pay a ticket train also take a certain amount time however train perfect take random amount time arrive destination kyoya arrive school strictly t time units pay a fine x. train line describe a ticket price a probability distribution time train take formally train line i ticket cost ci a probability distribution pi k denote probability train take k time units 1 ≤ k ≤ t. amount time train use <unknown> take mutually independent random value ( moreover kyoya travel along train possible train take different amount time amount also independent one another ) kyoya want get school spend least amount money expectation ( ticket price plus possible fine late ) course kyoya optimal plan get school every time arrive a train station may recalculate plan base much time remain expect cost kyoya pay get school move optimally ? first line input contain four integers n m t x ( 2 ≤ n ≤ 50 1 ≤ m ≤ 100 1 ≤ t ≤ 20 000 0 ≤ x ≤ 106 ) next 2 m line contain description train 2i - th line 3 integers ai bi ci represent a one way train station ai bi ticket cost ci ( 1 ≤ ai bi ≤ n ai ≠ bi 0 ≤ ci ≤ 106 ) always least one path station school ( 2i + 1 ) -th line contain t integers pi 1 pi 2 ... pi t pi k / 100000 probability train take k units time traverse ( 0 ≤ pi k ≤ 100 000 1 ≤ k ≤ t ) guarantee one train pair platforms directions print a single real number equal optimal expect cost get school answer consider correct relative absolute error n't exceed 10 - 6 . optimal strategy first case follow : first travel along first train line probability 1 / 2 kyoya take 1 time unit otherwise kyoya take 3 time units train take 1 time unit travel along 4th train line kyoya make school time probability 1 / 2 . otherwise train take 3 time units travel along 2nd train line kyoya make school time probability 1 / 10 . since cost train line zero look probability kyoya incur penalty probability kyoya pay penalty 1 / 2 × 1 / 2 + 1 / 2 × 9 / 10 = 7 / 10 . show strategy strictly better optimal strategy second case travel along 1 → 2 → 4 matter kyoya incur penalty probability 3 / 4 cost train 200 thus expect cost <unknown>,"['dp', 'graphs', 'math']",3200.0
557/A,soon a school olympiad informatics hold berland n schoolchildren participate a meet jury olympiad decide n participants depend result get a diploma first second third degree thus student receive exactly one diploma also decide must give least min1 max1 diplomas first degree least min2 max2 diplomas second degree least min3 max3 diplomas third degree discussion decide choose options distribute diplomas satisfy limitations one maximize number participants receive diplomas first degree options select one maximize number participants receive diplomas second degree multiple options select option maximize number diplomas third degree choose best option distribute certificate entrust ilya one best programmers berland however find important things task choose best option distribute diplomas base describe limitations guarantee describe limitations a way choose option distribute diplomas n participants olympiad receive a diploma degree first line input contain a single integer n ( 3 ≤ n ≤ 3·106 ) — number schoolchildren participate olympiad next line input contain two integers min1 max1 ( 1 ≤ min1 ≤ max1 ≤ 106 ) — minimum maximum limit number diplomas first degree distribute third line input contain two integers min2 max2 ( 1 ≤ min2 ≤ max2 ≤ 106 ) — minimum maximum limit number diplomas second degree distribute next line input contain two integers min3 max3 ( 1 ≤ min3 ≤ max3 ≤ 106 ) — minimum maximum limit number diplomas third degree distribute guarantee min1 + min2 + min3 ≤ n ≤ max1 + max2 + max3 first line output print three number show many diplomas first second third degree give students optimal variant distribute diplomas optimal variant distribute diplomas one maximize number students receive diplomas first degree suitable options best one one maximize number participants receive diplomas second degree several options best one one maximize number diplomas third degree,"['greedy', 'implementation', 'math']",1100.0
557/B,pasha decide invite friends a tea party occasion a large teapot capacity w milliliters 2n tea cup cup one pasha 's friends i - th cup hold ai milliliters water turn among pasha 's friends exactly n boys exactly n girls go come tea party please everyone pasha decide pour water tea follow : word boy get two time water girl pasha kind polite want maximize total amount water pour friends task help determine optimum distribution cup pasha 's friends first line input contain two integers n w ( 1 ≤ n ≤ 105 1 ≤ w ≤ 109 ) — number pasha 's friends boys ( equal number pasha 's friends girls ) capacity pasha 's teapot milliliters second line input contain sequence integers ai ( 1 ≤ ai ≤ 109 1 ≤ i ≤ 2n ) — capacities pasha 's tea cup milliliters print a single real number — maximum total amount water milliliters pasha pour friends without violate give condition answer consider correct absolute relative error n't exceed 10 - 6 . pasha also candy go give girls another task .,"['implementation', 'math', 'sortings']",1500.0
558/B,amr get a large array size n. amr n't like large array intend make smaller amr n't care anything array except beauty beauty array define maximum number time number occur array want choose smallest subsegment array beauty original array help amr choose smallest subsegment possible first line contain one number n ( 1 ≤ n ≤ 105 ) size array second line contain n integers ai ( 1 ≤ ai ≤ 106 ) represent elements array output two integers l r ( 1 ≤ l ≤ r ≤ n ) begin end subsegment choose respectively several possible answer may output a subsegment b array a l r array size r - l + 1 bi = al + i - 1 1 ≤ i ≤ r - l + 1,['implementation'],1300.0
559/A,gerald get a curious hexagon birthday boy find angle hexagon equal measure length side find equal integer number centimeters properties hexagon end gerald decide draw paint a line parallel side hexagon line split hexagon regular triangles side 1 centimeter gerald wonder many triangles get many gerald lose track count help boy count triangles first single line input contain 6 space - separated integers a1 a2 a3 a4 a5 a6 ( 1 ≤ ai ≤ 1000 ) — lengths side hexagons centimeters clockwise order guarantee hexagon indicate properties exactly side exist print a single integer — number triangles side one 1 centimeter hexagon split gerald 's hexagon look like first sample : 's look like second sample :,"['brute force', 'geometry', 'math']",1600.0
559/B,today a lecture string gerald learn a new definition string <unknown> two string a b equal length call equivalent one two case : a home task teacher give two string students ask determine equivalent gerald already complete home task 's turn ! first two line input contain two string give teacher length 1 200 000 consist lowercase english letter string length print ` ` yes '' ( without quote ) two string equivalent ` ` '' ( without quote ) otherwise first sample split first string string ` ` aa '' ` ` ba '' second one — string ` ` ab '' ` ` aa '' ` ` aa '' equivalent ` ` aa '' ; ` ` ab '' equivalent ` ` ba '' ` ` ab '' = ` ` a '' + ` ` b '' ` ` ba '' = ` ` b '' + ` ` a '' second sample first string splitted string ` ` aa '' ` ` bb '' equivalent 's string ` ` aabb '' equivalent string ` ` bbaa '',"['divide and conquer', 'sortings', 'strings']",1700.0
566/F,must know maximum clique problem arbitrary graph np - hard nevertheless graph specific kinds solve effectively case let us remind a clique a non - directed graph a subset vertices a graph two vertices subset connect edge particular empty set vertexes a set consist a single vertex cliques let 's define a divisibility graph a set positive integers a = { a1 a2 ... } follow vertices give graph number set a two number ai aj ( i ≠ j ) connect edge either ai divisible aj aj divisible ai give a set non - negative integers a. determine size a maximum clique a divisibility graph set a. first line contain integer n ( 1 ≤ n ≤ 106 ) set size set a. second line contain n distinct positive integers a1 a2 ... ( 1 ≤ ai ≤ 106 ) — elements subset a. number line follow ascend order print a single number — maximum size a clique a divisibility graph set a. first sample test a clique size 3 example a subset vertexes { 3 6 18 } a clique a larger size n't exist graph,"['dp', 'math', 'number theory']",1500.0
567/B,"berland national library recently build capital berland addition library take collect work berland leaders library a read room today pilot launch automate read room visitors ' account system ! scanner system instal entrance read room record events form ` ` reader enter room '' ` ` reader leave room '' every reader assign a registration number registration procedure library — 's a unique integer 1 106 . thus system log events two form : first launch system a success function period time , time launch time <unknown> read room may already visitors significant fund budget berland spend design installation system therefore citizens capital demand explain need system benefit implementation bring , developers system need urgently come reason existence help system developers find minimum possible capacity read room ( visitors ) use log system available first line contain a positive integer n ( 1 ≤ n ≤ 100 ) — number record system log next follow n events system journal order make event write a single line look ` ` + ri '' ` ` - ri '' ri integer 1 106 registration number visitor ( distinct visitors always distinct registration number ) guarantee log contradictory , every visitor type two consecutive events distinct start system stop room may possibly contain visitors print a single integer — minimum possible capacity read room first sample test system log ensure point read room visitors registration number 1 <unknown> <unknown> . people room time base log therefore answer test 3",['implementation'],1300.0
569/A,little lesha love listen music via smartphone smartphone n't much memory lesha listen favorite songs a well - known social network <unknown> unfortunately internet fast city <unknown> song take a lot time download lesha quite impatient song 's duration t second lesha download first s second song play <unknown> reach point yet download lesha immediately play song start ( load part song stay phone download continue place ) happen song download completely lesha listen end q second real time internet allow download q - 1 second track tell lesha many time start song include first start single line contain three integers t s q ( 2 ≤ q ≤ 104 1 ≤ s < t ≤ 105 ) print a single integer — number time song restart first test song play twice faster download mean four first second lesha reach moment download start song another two second song download completely thus lesha start song twice second test song almost download lesha start third sample test download finish lesha finish listen moment note song n't restart case,"['implementation', 'math']",1500.0
571/C,"' in boolean logic a formula <unknown> normal form ( cnf ) <unknown> normal form a conjunction clauses a clause a disjunction literals ' ( <unknown> https : //en.wikipedia.org / wiki / <unknown> ) word cnf a formula type & represent a logical ` ` '' ( conjunction ) represent a logical ` ` '' ( disjunction ) vij boolean variables negations statement bracket call a clause vij call literals give a cnf contain variables x1 ... xm negations know variable occur two clauses ( negation without negation total ) task determine whether cnf satisfiable , whether value variables cnf value true cnf satisfiable also need determine value variables cnf true guarantee variable occur clause first line contain integers n m ( 1 ≤ n m ≤ 2·105 ) — number clauses number variables correspondingly next n line contain descriptions clause i - th line first contain first number ki ( ki ≥ 1 ) — number literals i - th clauses follow space - separated literals vij ( 1 ≤ <unknown> ≤ m ) a <unknown> correspond vij <unknown> either negation vij negative without negation otherwise cnf satisfiable print a single line ` ` '' ( without quote ) otherwise print two string : string ` ` yes '' ( without quote ) a string m number zero one — value variables satisfy assignment order x1 xm first sample test formula one possible answer x1 = true x2 = true","['dfs and similar', 'graphs', 'greedy']",2500.0
573/B,limak a little bear love play today play destroy block tower build n tower a row i - th tower make hi identical block clarification see picture first sample limak repeat follow operation till everything destroy block call internal four neighbor i.e side ( top leave right ) adjacent block floor otherwise block boundary one operation limak destroy boundary block paw fast destroy block time limak ready start task count many operations take destroy tower first line contain single integer n ( 1 ≤ n ≤ 105 ) second line contain n space - separated integers h1 h2 ... hn ( 1 ≤ hi ≤ 109 ) — size tower print number operations need destroy tower picture show three operations first sample test time boundary block mark red color,"['binary search', 'data structures', 'dp', 'math']",1600.0
573/D,would want fight bear rid horse ? neither limak a grizzly bear general dreadful army bearland important part army cavalry course cavalry bearland consist n warriors n horse i - th warrior strength wi i - th horse strength hi warrior together horse call a unit strength a unit equal multiply strengths warrior horse total strength cavalry equal sum strengths n units good assignment warriors horse make cavalry truly powerful initially i - th warrior i - th horse give q query query two warriors swap horse general limak must ready every possible situation warriors n't allow ride horse ? query find maximum possible strength cavalry consider assignments warriors horse warrior assign horse ( prove n ≥ 2 always least one correct assignment ) note ca n't leave a warrior without a horse first line contain two space - separated integers n q ( 2 ≤ n ≤ 30 000 1 ≤ q ≤ 10 000 ) second line contain n space - separated integers w1 w2 ... wn ( 1 ≤ wi ≤ 106 ) — strengths warriors third line contain n space - separated integers h1 h2 ... hn ( 1 ≤ hi ≤ 106 ) — strengths horse next q line describe query i - th contain two space - separated integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) indices warriors swap horse print q line answer query i - th line print maximum possible strength cavalry first i query clarification first sample : horse : 3 7 2 5 first query situation look like follow : horse : 3 5 2 7 get 1·2 + 10·3 + <unknown> + <unknown> = <unknown> ( note <unknown> take horse assignment ) second query get back initial situation optimal assignment 1·2 + 10·3 + 100·5 + <unknown> = <unknown> . clarification second sample first query : horse : 2 3 1 optimal assignment 7·1 + 11·2 + <unknown> = 44 . second query 7·3 + 11·2 + 5·1 = 48 . finally 7·2 + <unknown> + 5·1 = 52,"['data structures', 'divide and conquer', 'dp']",3000.0
574/B,know a story three musketeers ? anyway learn <unknown> richelimakieu a cardinal city bearis tire deal crime need three brave warriors help fight bad guy n warriors richelimakieu want choose three become musketeers 's easy important condition musketeers must know cooperate efficiently n't well know could <unknown> old friends musketeer recognition number warriors know exclude two musketeers help richelimakieu ! find possible choose three musketeers know minimum possible sum recognitions first line contain two space - separated integers n m ( 3 ≤ n ≤ 4000 0 ≤ m ≤ 4000 ) — respectively number warriors number pair warriors know <unknown> - th follow m line contain two space - separated integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) warriors ai bi know pair warriors list richelimakieu choose three musketeers print minimum possible sum recognitions otherwise print ` ` -1 '' ( without quote ) first sample richelimakieu choose a triple 1 2 3 . first musketeer n't know anyone except two musketeers recognition 0 . second musketeer recognition 1 know warrior number 4 . third musketeer also recognition 1 know warrior 4 . sum recognitions 0 + 1 + 1 = 2 . possible triple 2 3 4 greater sum recognitions equal 1 + 1 + 1 = 3 . second sample triple warriors know,"['brute force', 'dfs and similar', 'graphs']",1500.0
581/F,"'s election time berland <unknown> course party zublicanes mumocrates election campaign party include numerous demonstrations n main square capital berland n square certainly demonstrations one party otherwise could lead riot hand party apply host a huge number demonstrations square demonstrations must hold capital management distribute area two party pair square connect ( n - 1 ) bidirectional roads pair square a unique way get one square another square outskirts capital mean connect a road one square square call dead end square mayor capital instruct distribute square party dead end square number demonstrations first second party guarantee number dead end square city even prevent possible conflict zublicanes mumocrates decide minimize number roads connect square distinct party , a developer department distribute square determine smallest number first line input contain a single integer n ( 2 ≤ n ≤ 5000 ) — number square capital berland next n - 1 line contain pair integers x y ( 1 ≤ x y ≤ n x ≠ y ) — number square connect road square number integers 1 n. guarantee number dead end square city even print a single number — minimum number roads connect square demonstrations different party","['dp', 'trees', 'two pointers']",2400.0
584/C,marina love string length vasya love a third string different exactly t character help vasya find least one string formally give two string s1 s2 length n number t. let 's denote f ( a b ) number character string a b different task find string s3 length n f ( s1 s3 ) = f ( s2 s3 ) = t. string print - 1 . first line contain two integers n t ( 1 ≤ n ≤ 105 0 ≤ t ≤ n ) second line contain string s1 length n consist lowercase english letter third line contain string s2 length n consist lowercase english letter print a string length n differ string s1 s2 exactly t character string consist lowercase english letter string n't exist print -1,"['greedy', 'strings']",1700.0
590/A,a schoolboy name vasya love read book program mathematics recently read encyclopedia article describe method median smooth ( median filter ) many applications science engineer vasya like idea method much decide try practice apply simplest variant median smooth sequence number a1 a2 ... result a new sequence b1 b2 ... bn obtain follow algorithm : median a set three number number go second place three number write non - decreasing order example median set 5 1 2 number 2 median set 1 0 1 equal 1 . order make task easier vasya decide apply method sequence consist zero ones make procedure vasya look result sequence think : i apply algorithm apply next result ? vasya try a couple examples find number median smooth algorithm applications sequence stop change say sequence stable change median smooth apply vasya wonder whether sequence always eventually become stable ask write a program give a sequence zero ones determine whether ever become stable moreover ever become stable determine look like many time one need apply median smooth algorithm initial sequence order obtain a stable one first input line input contain a single integer n ( 3 ≤ n ≤ 500 000 ) — length initial sequence next line contain n integers a1 a2 ... ( ai = 0 ai = 1 ) give initial sequence sequence never become stable print a single number - 1 . otherwise first print a single integer — minimum number time one need apply median smooth algorithm initial sequence become stable second line print n number separate a space — result sequence second sample <unknown> occur two step : sequence 00000 obviously stable,['implementation'],1700.0
594/C,edo get a collection n refrigerator magnets ! decide buy a refrigerator hang magnets door shop make refrigerator size door meet follow restrictions : refrigerator door must rectangle length width door must positive integers edo figure want place magnets refrigerator introduce a system coordinate plane magnet represent a rectangle side parallel coordinate ax want remove k magnets ( may choose keep ) attach remain magnets refrigerator door area ​​the door small possible a magnet consider attach refrigerator door center lie door boundary relative position remain magnets must correspond plan let us explain last two sentence let 's suppose want hang two magnets refrigerator magnet plan coordinate lower leave corner ( x1 y1 ) upper right corner ( x2 y2 ) center locate ( ) ( may integers ) say relative position correspond plan mean available operation translation i.e vector connect center two magnets original plan must equal vector connect center two magnets refrigerator side refrigerator door must also parallel coordinate ax first line contain two integers n k ( 1 ≤ n ≤ 100 000 0 ≤ k ≤ min ( 10 n - 1 ) ) — number magnets edo maximum number magnets edo may place refrigerator next n line describe initial plan place magnets line contain four integers x1 y1 x2 y2 ( 1 ≤ x1 < x2 ≤ 109 1 ≤ y1 < y2 ≤ 109 ) — coordinate lower leave upper right corner current magnet magnets partially overlap even fully coincide print a single integer — minimum area door refrigerator use place least n - k magnets preserve relative position first test sample optimal remove either first third magnet remove first magnet center two others lie point ( 2.5 2.5 ) ( 3.5 3.5 ) thus enough buy a fridge door width 1 door height 1 area door also equal one correspondingly second test sample n't matter magnet remove answer change — need a fridge door width 8 door height 8 . third sample remove anything k = 0,"['brute force', 'greedy', 'implementation', 'two pointers']",2300.0
594/D,today a math lesson teacher tell vovochka euler function a positive integer φ ( n ) arithmetic function count positive integers less equal n relatively prime n. number 1 coprime positive integers φ ( 1 ) = 1 . teacher give vovochka array n positive integers a1 a2 ... a task process q query li ri — calculate print modulo 109 + 7 . hard a second grade school student ' ve decide help vovochka first line input contain number n ( 1 ≤ n ≤ 200 000 ) — length array give vovochka second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 106 ) third line contain integer q ( 1 ≤ q ≤ 200 000 ) — number query next q line contain query one per line query define boundaries segment li ri ( 1 ≤ li ≤ ri ≤ n ) print q number — value euler function query calculate modulo 109 + 7 . second sample value calculate like :,"['data structures', 'number theory']",2500.0
595/A,"one day vitaly go home late night wonder : many people n't sleep moment ? estimate vitaly decide look windows light house pass moment vitaly see a build n floor 2·m windows floor floor m flats number 1 m two consecutive windows correspond flat number windows 1 2·m leave right j - th flat i - th floor windows 2·j - 1 2·j correspond row windows ( usual floor enumerate bottom ) vitaly think people flat n't sleep moment least one windows correspond flat light give information windows give house task calculate number flats accord vitaly people n't sleep first line input contain two integers n m ( 1 ≤ n m ≤ 100 ) — number floor house number flats floor respectively next n line describe floor top bottom contain 2·m character i - th window give floor light i - th character line ' 1 ' otherwise ' 0 ' print a single integer — number flats light least one window , flats accord vitaly people n't sleep first test case house two floor two flats floor , total 4 flats light n't second floor leave flat , room flat light second test case house one floor first floor three flats light leftmost flat ( windows ) middle flat ( one window ) right flat light",['implementation'],800.0
596/E,wilbur pig want play string find n m table consist digits 0 9 row number 1 n columns number 1 m. wilbur start square make certain move square ( x y ) digit d ( 0 ≤ d ≤ 9 ) write position ( x y ) must move square ( x + ad y + bd ) square lie within table stay square ( x y ) otherwise wilbur make a move choose whether write digit write square white board digits write whiteboard form string every time a new digit write go end current string wilbur q string worry string si wilbur want know whether exist a start position ( x y ) make finitely many move wilbur end string si write white board first line input consist three integers n m q ( 1 ≤ n m q ≤ 200 ) — dimension table number string process respectively next n line contain m digits 0 9 give table follow 10 line i - th contain value ai - 1 bi - 1 ( - 200 ≤ ai bi ≤ 200 ) i.e vector wilbur use make a move square a digit i - 1 q line follow i - th contain a string si consist digits 0 9 . guarantee total length q string wo n't exceed 1 000 000 . q string print ` ` yes '' wilbur choose x y order finish string finite number move 's impossible print ` ` '' correspond string first sample a 1 1 table consist digit 0 . move make stay square first string write white board write 0 repeatedly second string write 2 table,"['dfs and similar', 'dp', 'graphs', 'strings']",2500.0
599/D,"spongebob already tire try reason weird action calculations simply ask find pair n m exactly x distinct square table consist n row m columns example a 3 × 5 table 15 square side one 8 square side two 3 square side three total number distinct square a 3 × 5 table 15 + 8 + 3 = 26 . first line input contain a single integer x ( 1 ≤ x ≤ 1018 ) — number square inside table spongebob interest first print a single integer k — number table exactly x distinct square inside print k pair integers describe table print pair order increase n case equality — order increase m. a 1 × 2 table 2 1 × 1 square , 2 distinct square total a 2 × 3 table 6 1 × 1 square 2 2 × 2 square equal 8 square total","['brute force', 'math']",1900.0
599/E,root tree a connect graph without simple cycle one vertex select a root problem vertex number 1 always serve a root lowest common ancestor two vertices u v farthest root vertex lie path u root path v root denote lca ( u v ) sandy a root tree consist n vertices use store nut unfortunately underwater storm break tree n't remember 's edge manage restore m edge initial tree q triple ai bi ci suppose lca ( ai bi ) = ci help sandy count number tree size n vertex 1 a root match information remember make a mess tree print 0 . two root tree consider distinct exist edge occur one n't occur one first line input contain three integers n m q ( 1 ≤ n ≤ 13 0 ≤ m < n 0 ≤ q ≤ 100 ) — number vertices number edge lca triple remember sandy respectively next m line contain two integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) — number vertices connect i - th edge 's guarantee set edge a subset edge tree last q line contain triplets number ai bi ci ( 1 ≤ ai bi ci ≤ n ) triple define lca ( ai bi ) = ci 's guarantee exist a tree satisfy give lca condition print a single integer — number tree size n satisfy condition second sample correct answer look like : third sample two possible tree : fourth sample answer 0 information lca inconsistent,"['bitmasks', 'dp', 'trees']",2600.0
60/C,pasha akim make a forest map — lawns graph 's vertexes roads join lawns edge decide encode number laughy mushroom every lawn follow way : every edge two lawns write two number greatest common divisor ( gcd ) least common multiple ( lcm ) number mushroom lawns one day pasha akim argument laughy mushroom tear map pasha leave part contain m roads task help pasha — use map restore number mushroom every lawn result necessarily unique help pasha restore one report arrangement mushroom exist guarantee number roads initial map less 1 exceed 106 . first line contain two number n m ( ) number lawns roads know follow m line contain four number number lawns road connect gcd lcm number mushroom lawns ( 1 ≤ gcd lcm ≤ 106 ) guarantee road connect lawn two lawns connect one road answer contain ` ` yes '' ` ` '' first line say whether possible perform arrangement answer ` ` yes '' print follow line n number number mushroom correspond lawns,"['brute force', 'dfs and similar']",2100.0
600/A,"give string s. let 's call word largest sequence consecutive symbols without symbols ' ' ( comma ) ' ; ' ( <unknown> ) example four word string ` ` aba,123 ; 1a ; 0 '' : ` ` aba '' ` ` 123 '' ` ` 1a '' ` ` 0 '' a word empty : example string s= '' ; ; '' contain three empty word separate ' ; ' find word give string nonnegative integer number without lead zero build new string a. string a contain word number separate ' ' ( order number remain string s ) word build string b way ( order number remain string s ) string ` ` 101 '' ` ` 0 '' integer number ` ` 01 '' ` ` 1.0 '' example string aba,123 ; 1a ; 0 string a would equal ` ` <unknown> '' string b would equal ` ` <unknown> '' line input contain string s ( 1 ≤ |s| ≤ 105 ) string contain symbols ' . ' ( ascii 46 ) ' ' ( ascii 44 ) ' ; ' ( ascii 59 ) digits lowercase uppercase latin letter print string a first line string b second line string surround quote ( ascii 34 ) word number print dash ( ascii 45 ) first line word number print dash second line second example string s contain five word : ` ` 1 '' ` ` '' ` ` 01 '' ` ` a0 '' ` ` ''","['implementation', 'strings']",1600.0
603/B,<unknown> intelligent schoolboy kevin sun study <unknown> <unknown> <unknown> bovinia state university ( <unknown> ) farmer ivan mathematics olympiads ( moo ) class kevin confront a weird functional equation need help two fix integers k p p odd prime number functional equation state function ( equation hold integer x range 0 p - 1 inclusive ) turn f actually many different function instead find a solution kevin want count number distinct function f satisfy equation since answer may large print result modulo 109 + 7 . input consist two space - separated integers p k ( 3 ≤ p ≤ 1 000 000 0 ≤ k ≤ p - 1 ) a single line guarantee p odd prime number print a single integer number distinct function f modulo 109 + 7 . first sample p = 3 k = 2 . follow function work :,"['combinatorics', 'dfs and similar', 'dsu', 'math', 'number theory']",1800.0
603/D,kevin sun ruminate origin cow stand origin cartesian plane notice n line plane representable equation form ax + = c. also observe two line parallel three line pass point triple ( i j k ) 1 ≤ i < j < k ≤ n kevin consider triangle form three line call a triangle original circumcircle triangle pass origin since kevin believe circle <unknown> life tie directly triangles want know number original triangles form unordered triple distinct line recall circumcircle a triangle circle pass vertices triangle first line input contain a single integer n ( 3 ≤ n ≤ 2000 ) number line next n line describe line i - th line contain three space - separated integers ai bi ci ( |ai| |bi| |ci| ≤ 10 000 ai2 + bi2 > 0 ) represent equation <unknown> + <unknown> = ci line print a single integer number triple ( i j k ) i < j < k line form original triangle note first sample line pass origin second sample exactly one triple line : y = 1 x + y = 2 x - y = - 2 . triangle form vertices ( 0 2 ) ( 1 1 ) ( - 1 1 ) circumcircle triangle equation x2 + ( y - 1 ) 2 = 1 . indeed pass ( 0 0 ),"['geometry', 'math']",2900.0
609/A,sean try save a large file a usb flash drive n usb flash drive capacities equal a1 a2 ... megabytes file size equal m megabytes find minimum number usb flash drive need write sean 's file split file drive first line contain positive integer n ( 1 ≤ n ≤ 100 ) — number usb flash drive second line contain positive integer m ( 1 ≤ m ≤ 105 ) — size sean 's file next n line contain positive integer ai ( 1 ≤ ai ≤ 1000 ) — size usb flash drive megabytes guarantee answer exist i. e. sum ai less m. print minimum number usb flash drive write sean 's file split file drive first example sean need two usb flash drive — first third second example sean need three usb flash drive third example sean need one usb flash drive use available usb flash drive — first second,"['greedy', 'implementation', 'sortings']",800.0
610/B,vika n jar paint distinct color jar number 1 n i - th jar contain ai liters paint color i. vika also infinitely long rectangular piece paper width 1 consist square size 1 × 1 . square number 1 2 3 vika decide start paint square one one leave right start square number 1 arbitrary color square paint color x next square paint color x + 1 . case x = n next square paint color 1 . paint color vika want use stop square always paint one color take exactly 1 liter paint task calculate maximum number square might paint vika choose right color paint first square first line input contain a single integer n ( 1 ≤ n ≤ 200 000 ) — number jar color vika second line input contain a sequence integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) ai equal number liters paint i - th jar i.e number liters color i vika line output contain a single integer — maximum number square vika paint follow rule describe first sample best strategy start paint use color 4 . square paint follow color ( leave right ) : 4 5 1 2 3 4 5 1 2 3 4 5 . second sample vika start paint use color third sample vika start paint use color number 5,['implementation'],1300.0
612/E,a permutation length n array contain integer 1 n exactly example q = [ 4 5 1 2 3 ] a permutation permutation q square permutation permutation p p [ i ] = q [ q [ i ] ] i = 1 ... n. example square q = [ 4 5 1 2 3 ] p = q2 = [ 2 3 4 5 1 ] problem inverse operation : give permutation p task find permutation q q2 = p. several q find first line contain integer n ( 1 ≤ n ≤ 106 ) — number elements permutation p. second line contain n distinct integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) — elements permutation p. permutation q q2 = p print number ` ` -1 '' answer exist print line contain n different integers qi ( 1 ≤ qi ≤ n ) — elements permutation q. several solutions print,"['combinatorics', 'dfs and similar', 'graphs', 'math']",2200.0
613/D,"meanwhile kingdom k get ready marriage king 's daughter however order lose face front relatives king first finish reform kingdom king wait daughter 's marriage reform must finish soon possible kingdom currently consist n cities cities connect n - 1 bidirectional road one get city city king save a lot one path two cities point reform ? key <unknown> state relocate distinct cities ( call cities important ) however due fact a high risk attack barbarians must do carefully king make several plan describe a set important cities wonder best plan barbarians capture cities important ( important ones enough protection sure ) capture city become impassable particular interest feature plan minimum number cities barbarians need capture order make important cities isolate , important cities would impossible reach important city help king calculate characteristic plan first line input contain integer n ( 1 ≤ n ≤ 100 000 ) — number cities kingdom next n - 1 line contain two distinct integers ui vi ( 1 ≤ ui vi ≤ n ) — indices cities connect i - th road guarantee get city one move along exist roads next line contain a single integer q ( 1 ≤ q ≤ 100 000 ) — number king 's plan next q line look follow : first go number ki — number important cities king 's plan ( 1 ≤ ki ≤ n ) follow exactly ki space - separated pairwise distinct number 1 n — number important cities plan sum ki 's does't exceed 100 000 . plan print a single integer — minimum number cities barbarians need capture print - 1 barbarians ' attempt isolate important cities effective first sample first third king 's plan barbarians capture city 3 enough second fourth plan attempt effective second sample cities capture 3 5","['dfs and similar', 'divide and conquer', 'dp', 'graphs', 'sortings', 'trees']",2800.0
615/C,a boy name ayrat live planet ami-1511 inhabitant planet a talent specifically ayrat love run moreover run enough dream make run a real art first want construct run track coat t. planet ami-1511 coat track sequence color block block denote small english letter therefore every coat treat a string unfortunately block n't freely sell non - business customers ayrat find infinite number coat s. also scissor glue ayrat go buy coat s cut exactly one continuous piece ( substring ) glue end track coat moreover may choose flip block glue ayrat want 's know minimum number coat s need buy order get coat t run track course also want 's know way achieve answer first line input contain string s — coat present shop second line contain string t — coat ayrat want obtain string non - empty consist small english letter length n't exceed 2100 . first line contain minimum need number coat n -1 's impossible create desire coat answer -1 follow n line contain two integers xi yi — number end block correspond piece xi ≤ yi piece use regular order xi > yi piece use reverse order print piece order glue get string t. first sample string ` ` cbaabc '' = ` ` cba '' + ` ` abc '' second sample : ` ` ayrat '' = ` ` a '' + ` ` yr '' + ` ` '',"['dp', 'greedy', 'strings', 'trees']",2000.0
617/D,three point mark coordinate plane goal make a simple polyline without self - intersections self - touches pass point also polyline must consist segment parallel coordinate ax find minimum number segment polyline may consist three line input contain two integers i - th line contain integers xi yi ( - 109 ≤ xi yi ≤ 109 ) — coordinate i - th point guarantee point distinct print a single number — minimum possible number segment polyline variant polyline first sample : variant polyline second sample : variant polyline third sample :,['implementation'],1700.0
62/A,"statistics claim students sleep three hours a day even world dream <unknown> peacefully sense <unknown> doom still upon a poor student dream sit mathematical analysis exam examine <unknown> professor time a three time soviet union hero a noble prize <unknown> student expulsion <unknown> petr palych poor student could n't answer a single question thus instead a large spacious office go apply a job <unknown> mine wait a minute ! petr palych decide give student last chance ! yes possible dream professor begin : ` ` a venusian girl a marsian boy meet earth decide take a walk hold hand problem girl al finger leave hand ar finger right one boy correspondingly bl br finger feel comfortable hold hand pair girl 's finger touch , comfortable two girl 's finger a boy 's finger addition three finger boy touch determine hold hand comfortable ` ` boy girl n't care go leave go right difference boy go leave girl take leave hand right one go right girl vice versa first line contain two positive integers exceed 100 . number finger venusian girl 's leave right hand correspondingly second line contain two integers exceed 100 . number finger marsian boy 's leave right hand correspondingly print yes , answer petr palych 's question boy girl n't really care go leave","['greedy', 'math']",1300.0
62/C,medieval time exist tradition burn <unknown> steaks together pet black cat end 15 - th century population black cat <unknown> exist difficulty situation lead create <unknown> - <unknown> <unknown> commission resolution # 666 say a white cat consider black perimeter black spot exceed acceptable norm acceptable norm equal ? every <unknown> choose depend situation task find perimeter black spot cat 's fur resolution say cat 's fur a white square length 105 . measurement spot customary put lower leave corner fur origin ax ( 0 ; 0 ) upper right one — point coordinate ( 105 ; 105 ) cat ' spot nondegenerate triangles spot intersect overlap guarantee pair triangular spot ' side one common point 'll regard perimeter problem total length <unknown> a cat 's fur change color first input line contain a single integer n ( 0 ≤ n ≤ 100 ) number spot cat 's fur i - th last n line contain 6 integers : x1i y1i x2i y2i <unknown> <unknown> coordinate i - th triangular spot ( 0 < <unknown> <unknown> < 105 ) print a single number answer problem perimeter union triangles answer differ correct one 10 - 6,"['geometry', 'implementation', 'sortings']",2300.0
62/E,a result pinky brain 's mysterious experiment large hadron collider portals black hole open parallel dimension world evil creep veil world brain quickly evaluate situation understand evil tentacles creep become free higher possibility brain rule world collider 's <unknown> a rectangular grid roll a cylinder consist n row m columns show picture : example n = 4 m = 5 . dot line <unknown> close column a ring i. e. connect n - th 1 - th row grid leftmost column grid portals situate tentacles world evil ready creep rightmost column exit doors locate tentacles get doors segment join nod grid corridors brain would <unknown> let tentacles face a problem : infinite number tentacles creep portals every <unknown> possess infinite length width volume corridors unfortunately quite limit brain could approximately evaluate maximal number tentacles able crawl every corridor help mice determine maximal number tentacles world evil crawl large hadron collider first line input file contain two integers n m ( 2 ≤ n ≤ 5 2 ≤ m ≤ 105 ) size large hadron collider grid next m - 1 line contain n number horizontal corridors ' capacities next m line contain n number vertical corridors ' capacities corridors describe leave right top bottom every n - th vertical corridor connect nod n - th 1 - th row a corridor 's capacity a non - negative integer exceed 109 . print a single number number world evil tentacles pinky brain command please use % lld specificator read write 64 - bit integers c++ preffered use cout ( also may use % i64d ),['dp'],2700.0
620/F,give array n integers ai m query query describe two integers ( lj rj ) let 's define function function define u ≤ v. query print maximal value function f ( ax ay ) lj ≤ x y ≤ rj ax ≤ ay first line contain two integers n m ( 1 ≤ n ≤ 5·104 1 ≤ m ≤ 5·103 ) — size array number query second line contain n integers ai ( 1 ≤ ai ≤ 106 ) — elements array a. next m line contain two integers lj rj ( 1 ≤ lj ≤ rj ≤ n ) – parameters j - th query query print value aj a separate line — maximal value function f ( ax ay ) lj ≤ x y ≤ rj ax ≤ ay,"['data structures', 'strings', 'trees']",2800.0
621/C,"n shark grow flower wet shark sit around table shark i i + 1 neighbour i 1 n - 1 . shark n 1 neighbour shark grow number flower si i - th shark value si random integer equiprobably choose range li ri wet shark 's favourite prime number p really like ! pair neighbour shark i j product si·sj divisible p wet shark become happy give 1000 dollars shark end day shark sum money wet shark grant find expectation value first line input contain two space - separated integers n p ( 3 ≤ n ≤ 100 000 2 ≤ p ≤ 109 ) — number shark wet shark 's favourite prime number guarantee p prime i - th follow n line contain information i - th shark — two space - separated integers li ri ( 1 ≤ li ≤ ri ≤ 109 ) range flower shark i produce remember si choose equiprobably among integers li ri inclusive print a single real number — expect number dollars shark receive total answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer a answer jury b. checker program consider answer correct , a prime number a positive integer number divisible 1 1 consider prime consider first sample first shark grow number flower 1 2 second shark grow 420 421 flower third <unknown> <unknown> . eight case quantities flower ( s0 s1 s2 ) shark grow : expect value second sample combination quantities <unknown> shark money","['combinatorics', 'math', 'number theory']",1700.0
621/D,wet shark ask rat kwesh generate three positive real number x y z 0.1 200.0 inclusive wet <unknown> want impress wet shark generate number exactly one digit decimal point wet shark know rat kwesh want a lot cheese give rat opportunity earn a lot cheese hand three number x y z rat kwesh rat kwesh pick one twelve options : let m maximum ai c smallest index ( 1 12 ) ac = m. rat 's goal find c ask help rat kwesh want see much cheese get print expression correspond ac line input contain three space - separated real number x y z ( 0.1 ≤ x y z ≤ 200.0 ) x y z give exactly one digit decimal point find maximum value expression among xyz <unknown> ( xy ) z ( xz ) y yxz yzx ( yx ) z ( <unknown> ) x <unknown> zyx ( <unknown> ) y ( zy ) x print correspond expression many maximums print one come first list xyz output <unknown> ( without bracket ) ( xy ) z output ( x^y ) <unknown> ( quote clarity ),"['brute force', 'math']",2400.0
622/E,tree a connect graph without cycle a leaf a tree vertex connect exactly one vertex give a tree n vertices a root vertex 1 . ant leaf tree one second ants simultaneously go parent vertex vertex two ants vertex simultaneously except root tree find minimal time require ants root tree note start ants leave tree first line contain integer n ( 2 ≤ n ≤ 5·105 ) — number vertices tree next n - 1 line contain two integers xi yi ( 1 ≤ xi yi ≤ n ) — end i - th edge guarantee give correct undirected tree print integer t — minimal time require ants root tree,"['dfs and similar', 'greedy', 'sortings', 'trees']",2200.0
623/C,"programmer sasha a student <unknown> ( moscow institute physics technology ) need make a laboratory work pass finals a laboratory unit a plane standard coordinate ax mark physicists moscow institute physics technology charge ax large electric charge : axis x positive axis y negative experience laboratory worker mark n point integer coordinate ( xi yi ) plane stop time sasha use ` ` atomic <unknown> '' place elementary particles point unlimited number electrons ( <unknown> charge elementary particles ) protons ( positively charge elementary particles ) put either electron a proton mark point soon mark point fill particles laboratory worker turn time particles come motion time stabilize equilibrium objective laboratory work arrange particles a way diameter result state ( maximum distance pair point set ) small possible since sasha a programmer <unknown> think particles simply ` ` fall '' projections correspond ax : electrons fall axis x protons fall axis y. programmers consider model sasha , a particle get point ( x y ) point ( x 0 ) electron point ( 0 y ) a proton laboratory high background radiation sasha take care laptop take ca n't write a program compute minimum possible diameter result set therefore , print a square minimum possible diameter set first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number point mark plane next n line contain two integers xi yi ( - 108 ≤ xi yi ≤ 108 ) — coordinate i - th point guarantee two point coincide print a single integer — square minimum possible diameter set first sample sasha put electrons point particles eventually fall a single point ( 1 0 ) second sample sasha put electron point ( 1 10 ) a proton point ( 10 1 ) result a set two point ( 1 0 ) ( 0 1 ) a diameter","['binary search', 'dp']",2900.0
625/A,kolya <unknown> love kefir much live year 1984 know detail buy delicious drink one day probably know find year 2084 buy kefir much complicate kolya hungry go nearest milk shop 2084 may buy kefir a plastic liter bottle cost a rubles glass liter bottle cost b rubles also may return empty glass bottle get c ( c < b ) rubles back return plastic bottle kolya n rubles really hungry want drink much kefir possible plastic bottle 1984 kolya n't know act optimally ask help first line input contain a single integer n ( 1 ≤ n ≤ 1018 ) — number rubles kolya begin follow three line contain integers a b c ( 1 ≤ a ≤ 1018 1 ≤ c < b ≤ 1018 ) — cost one plastic liter bottle cost one glass liter bottle money one get back return empty glass bottle respectively print integer — maximum number liters kefir kolya drink first sample kolya buy one glass bottle return buy one glass bottle thus drink 2 liters kefir second sample kolya buy two plastic bottle get two liters kefir buy one liter glass bottle return buy one plastic bottle case drink two liters kefir,"['implementation', 'math']",1700.0
625/C,people many crazy things stand a crowd dance learn heart rule russian language try become outstanding competitive programmers others collect funny math object <unknown> among collectors right want get one k - special table case forget table n × n call k - special follow three condition satisfy : goal help alice find least one k - special table size n × n. row columns number 1 n row number top bottom columns number leave right first line input contain two integers n k ( 1 ≤ n ≤ 500 1 ≤ k ≤ n ) — size table alice look column maximum possible sum first print sum integers k - th column require table next n line contain description table : first line contain n elements first row second line contain n elements second row multiple suitable table allow print,['implementation'],1300.0
626/D,"andrew jerry play a game harry <unknown> game consist three round round andrew jerry draw randomly without replacement a jar contain n ball label a distinct positive integer without look hand ball harry award point player larger number return ball jar winner game one win least two three round andrew win round 1 2 jerry win round 3 andrew win game however jerry unhappy system claim often lose match despite higher overall total probability sum three ball jerry draw strictly higher sum three ball andrew draw ? first line input contain a single integer n ( 2 ≤ n ≤ 2000 ) — number ball jar second line contain n integers ai ( 1 ≤ ai ≤ 5000 ) — number write ith ball guarantee two ball number print a single real value — probability jerry a higher total give andrew win first two round jerry win third answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer a answer jury b. checker program consider answer correct , first case two ball first two round andrew must draw 2 jerry must draw 1 vice versa final round thus andrew 's sum 5 jerry 's sum 4 jerry never a higher total second case game could ' ve three outcomes — 10 - 2 10 - 1 2 - 1 . jerry a higher total andrew 2 - 1 first two round jerry draw 10 last round probability","['brute force', 'combinatorics', 'dp']",1800.0
626/E,define simple skewness a collection number collection 's mean minus median give a list n ( necessarily distinct ) integers find non - empty subset ( repetition ) maximum simple skewness mean a collection average elements median a collection middle element elements sort average two middle elements even size first line input contain a single integer n ( 1 ≤ n ≤ 200 000 ) — number elements list second line contain n integers xi ( 0 ≤ xi ≤ 1 000 000 ) — ith element list first line print a single integer k — size subset second line print k integers — elements subset order multiple optimal subsets print first case optimal subset mean 5 median 2 simple skewness 5 - 2 = 3 . second case optimal subset note repetition allow last case subset median mean simple skewness 0,"['binary search', 'math']",2400.0
63/C,` ` bull cow '' game need two people play thinker think a number guesser try guess thinker think a four - digit number decimal system digits number different number may a lead zero ca n't one lead zero 's digits different guesser try guess number make a series guess try experimental number receive answer first person format ` ` x bull y cow '' x represent number digits experimental number occupy position seek number y represent number digits experimental number present seek number occupy different position naturally experimental number well seek number represent four - digit number digits different a lead zero present example let 's suppose thinker think number 0123 . <unknown> ' experimental number <unknown> receive a reply ` ` 1 bull 2 cow '' ( 3 occupy position number 1 2 present number occupy different position ) also answer number <unknown> ` ` 2 bull 1 cow '' ( analogically 1 3 occupy position 0 occupy a different one ) guesser answer ` ` 4 bull 0 cow '' game guesser already make several guess want know whether next guess possibly last one first input line contain integer n ( 1 ≤ n ≤ 10 ) represent number already make guess follow n line form ` ` ai bi ci '' ai i - th experimental number bi number bull ci number cow ( 1 ≤ i ≤ n 0 ≤ bi ci bi + ci ≤ 4 ) experimental number correct i.e. contain exactly four digits four digits different a lead zero experimental number different guesser n't guess number yet answer ` ` 4 bull 0 cow '' present input data enough determine seek number print number four digits a single line less four digits add lead zero data enough print ` ` need data '' without quote thinker happen make a mistake reply print ` ` incorrect data '' without quote,"['brute force', 'implementation']",1700.0
63/E,karlsson visit lillebror find a box chocolates a big <unknown> cream cake lillebror 's place karlsson immediately suggest divide sweets fairly lillebror specifically play together a game invent chocolates winner get cake a reward box chocolates form a hexagon contain 19 cells chocolates contain a chocolate players move turn one move allow eat one several chocolates lay neighbor cells one line parallel one box 's side picture show examples allow move unacceptable one player make a move lose karlsson make first move lillebror 's guest vice versa players play optimally determine get cake input data contain 5 line contain 19 word consist one symbol word ` ` o '' mean cell contain a chocolate a ` ` . '' stand empty cell guarantee box contain least one chocolate see examples better understand karlsson get cake print ` ` karlsson '' ( without quote ) otherwise print ` ` lillebror '' ( yet without quote ),"['bitmasks', 'dfs and similar', 'dp', 'implementation']",2000.0
630/D,a <unknown> period game development company city petya include a group programmers develop a new turn - based strategy game resemble well know ` ` heroes might & magic '' a part game turn - based fight big <unknown> enemies infinite field every cell form a hexagon magic effect able affect several field cells cells situate farther n cells away cell effect apply distance cells minimum number cell border cross a path one cell another easy see number cells affect a magic effect grow rapidly n increase <unknown> affect game performance 's petya decide write a program give n determine number cells repaint effect application game designers balance scale effect game performance help find number hexagons situate farther n cells away a give cell line input contain one integer n ( 0 ≤ n ≤ 109 ) output one integer — number hexagons situate farther n cells away a give cell,['math'],1100.0
630/K,city company develop computer game decide upgrade way reward employees look follow way a new game release users start buy actively company track number sales precision transaction every time next number sales divisible number 2 10 every developer game get a small bonus a game designer petya know company release a new game partly develop basis experience predict n people buy game first month petya want determine many time get bonus help know line input contain one integer n ( 1 ≤ n ≤ 1018 ) — prediction number people buy game output one integer show many number 1 n divisible number 2 10,"['math', 'number theory']",1500.0
630/M,vasya start work a machine vision company city vasya 's team create software hardware identification people face one project 's know - how a camera rotate around <unknown> axis shoot people see eye - <unknown> gadget — a rotate camera — come see better look camera take photo time could better high quality identification ? everything simple picture camera appear rotate ( clockwise camera rotation frame content become rotate counter - clockwise ) identification algorithm work face slightly deviate vertical vasya entrust correct situation — rotate a capture image image would minimally deviate vertical requirements severe firstly picture rotate angle divisible 90 degrees lose a bite information image secondly frame camera huge fps big adequate rotation speed provide hardware fpga solution solution rotate 90 degrees clockwise course one apply 90 degrees turn several time sake performance number turn minimize help vasya implement program give rotation angle camera determine minimum number 90 degrees clockwise turn necessary get a picture direction deviation vertical minimum next figure contain frame take <unknown> camera rotate 90 degrees clockwise rotate 90 degrees counter - clockwise arrows show direction ` ` true '' next figure show 90 degrees clockwise turn fpga hardware line input contain one integer x ( - 1018 ≤ x ≤ 1018 ) — camera angle degrees positive value denote clockwise camera rotation negative — counter - clockwise output one integer — minimum require number 90 degrees clockwise turn camera rotate 60 degrees counter - clockwise ( second example ) image rotate 60 degrees clockwise one 90 degrees clockwise turn image result 150 degrees clockwise total rotation deviation ` ` true '' one turn 150 degrees two 90 degrees clockwise turn image result 240 degrees clockwise total rotation deviation ` ` true '' two turn 120 degrees 240 degrees clockwise equal 120 degrees counter - clockwise three 90 degrees clockwise turn image result 330 degrees clockwise total rotation deviation ` ` true '' three turn 30 degrees 330 degrees clockwise equal 30 degrees counter - clockwise 60 150 120 30 degrees <unknown> smallest 30 achieve three 90 degrees clockwise turn,"['geometry', 'math']",1800.0
633/A,dante engage a fight ` ` <unknown> '' fight sword need break shield two gun ebony ivory able perform non - negative number shots every bullet hit shield ebony deal a units damage ivory deal b units damage order break shield dante deal exactly c units damage find possible first line input contain three integers a b c ( 1 ≤ a b ≤ 100 1 ≤ c ≤ 10 000 ) — number units damage deal ebony gun ivory gun total number damage require break shield respectively print ` ` yes '' ( without quote ) dante deal exactly c damage shield ` ` '' ( without quote ) otherwise second sample dante fire 1 bullet ebony 2 ivory deal exactly 1·3 + 2·2 = 7 damage third sample dante fire 1 bullet ebony bullets ivory <unknown> + <unknown> = 6 damage,"['brute force', 'math', 'number theory']",1100.0
633/B,mr . santa ask great programmers world solve a trivial problem give integer m ask number positive integers n factorial n end exactly m zero among great programmers solve problem ? line input contain integer m ( 1 ≤ m ≤ 100 000 ) — require number trail zero factorial first print k — number value n factorial n end m zero print k integers increase order factorial n equal product integers 1 n inclusive n ! = 1·2·3 · ... · n first sample 5 ! = 120 6 ! = 720 7 ! = 5040 8 ! = <unknown> 9 ! = <unknown>,"['brute force', 'math', 'number theory']",1300.0
633/D,"yash recently learn fibonacci sequence excite call a sequence fibonacci - ish give sequence integers a1 a2 ... , task rearrange elements sequence a way longest possible prefix fibonacci - ish sequence first line input contain a single integer n ( 2 ≤ n ≤ 1000 ) — length sequence ai second line contain n integers a1 a2 ... ( |ai| ≤ 109 ) print length longest possible fibonacci - ish prefix give sequence rearrangement first sample rearrange elements sequence - 1 2 1 whole sequence ai would fibonacci - ish second sample optimal way rearrange elements , , 28","['brute force', 'dp', 'implementation', 'math']",2000.0
637/A,celebrate <unknown> students one <unknown> berland state university decide conduct a vote best photo publish photos social network agree rule choose a winner : photo get like win multiple photoes get like winner photo get number first help guy determine winner photo record like first line input contain a single integer n ( 1 ≤ n ≤ 1000 ) — total like publish photoes second line contain n positive integers a1 a2 ... ( 1 ≤ ai ≤ 1 000 000 ) ai identifier photo get i - th like print identifier photo elections first test sample photo i d 1 get two like ( first fifth ) photo i d 2 get two like ( third fourth ) photo i d 3 get one like ( second ) thus winner photo identifier 2 get :,['implementation'],1000.0
639/C,"limak a little polar bear n't many toy thus often play polynomials consider a polynomial valid degree n coefficients integers exceed k absolute value formally : let a0 a1 ... denote coefficients , , a polynomial p ( x ) valid follow condition satisfy : limak recently get a valid polynomial p coefficients a0 a1 a2 ... , notice p ( 2 ) ≠ 0 want change go change one coefficient get a valid polynomial q degree n q ( 2 ) = 0 . count number ways count two ways a distinct coefficients target <unknown> differ first line contain two integers n k ( 1 ≤ n ≤ 200 000 1 ≤ k ≤ 109 ) — degree polynomial limit absolute value coefficients second line contain n + 1 integers a0 a1 ... ( |ai| ≤ k ≠ 0 ) — describe a valid polynomial 's guarantee p ( 2 ) ≠ 0 . print number ways change one coefficient get a valid polynomial q q ( 2 ) = 0 . first sample give a polynomial p ( x ) = 10 - <unknown> - <unknown> + <unknown> limak change one coefficient three ways : second sample give polynomial time though k equal 12 instead 109 . two first ways list still valid third way would get <unknown> > k allow thus answer 2 time","['implementation', 'math']",2200.0
64/A,print factorial give integer number n. factorial n equal 1·2 · ... · n line contain n ( 1 ≤ n ≤ 10 ) print factorial n,['implementation'],1300.0
641/E,little artem invent a time machine ! could go anywhere time thoughts course computer science want apply time machine a well - known data structure : multiset artem want create a basic multiset integers want structure support operations three type : time machine ? artem n't simply apply operations multiset one one travel different moments time apply operation consider follow example note artem dislike exceptions much assure change make delete operations apply element present multiset answer query third type compute moment artem make correspond query affect way future change make help artem implement time travellers multiset first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number artem 's query follow n line query descriptions contain three integers ai ti xi ( 1 ≤ ai ≤ 3 1 ≤ ti xi ≤ 109 ) — type query moment time artem travel order execute query value query respectively 's guarantee moments time distinct operation apply operations first second type consistent ask operation output number instance integer query give moment time,['data structures'],2000.0
645/A,bessie cow best friend elsie receive a slide puzzle pi day puzzle consist a 2 × 2 grid three tile label ' a ' ' b ' ' c ' three tile sit top grid leave one grid cell empty make a move bessie elsie slide a tile adjacent empty cell empty cell show : order determine truly best friends life ( bffls ) bessie elsie would like know exist a sequence move take puzzle configuration ( move perform puzzle ) two puzzle consider configuration tile top grid cell puzzle since tile label letter rotations reflections allow first two line input consist a 2 × 2 grid describe initial configuration bessie 's puzzle next two line contain a 2 × 2 grid describe initial configuration elsie 's puzzle position tile label ' a ' ' b ' ' c ' empty cell label ' x ' 's guarantee puzzle contain exactly one tile letter exactly one empty position output ` ` yes '' ( without quote ) puzzle reach configuration ( bessie elsie truly bffls ) otherwise print ` ` '' ( without quote ) solution first sample describe image bessie need slide ' a ' tile second sample two puzzle never configuration perhaps bessie elsie mean friends .,"['brute force', 'implementation']",1200.0
645/D,farmer john rebuild farm unfamiliar portion bovinia bessie try alternative job new <unknown> a <unknown> bessie need know program competition result quickly possible cover 2016 robot rap battle tournament notice robots operate deterministic algorithms particular robot i beat robot j robot i a higher skill level robot j. robot i beat robot j robot j beat robot k robot i beat robot k. since rap a subtle art two robots never skill level give result rap battle order play determine minimum number first rap battle need take place bessie could order robots skill level first line input consist two integers number robots n ( 2 ≤ n ≤ 100 000 ) number rap battle m ( ) next m line describe result rap battle order take place consist two integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) indicate robot ui beat robot vi i - th rap battle two rap battle involve pair robots guarantee least one order robots satisfy m relations print minimum k order robots skill level uniquely define first k rap battle exist one order satisfy m relations output -1 . first sample robots strongest weakest must ( 4 2 1 3 ) bessie deduce know result first four rap battle second sample ( 1 3 2 ) ( 3 1 2 ) possible order robots strongest weakest rap battle,"['binary search', 'dp', 'graphs']",1800.0
645/E,get kick report job know alphabet bessie decide attend school <unknown> egg eater academy make good progress study know first k english letter morning bessie travel school along a sidewalk consist m + n tile order help bessie review mr . moozing label first m sidewalk tile one first k lowercase english letter spell a string t. mr . moozing impress bessie 's <unknown> knowledge farm animals plan let finish label last n tile sidewalk consider result string s ( |s| = m + n ) consist letter label tile order home school sequence indices p1 < p2 < ... < <unknown> define subsequence string s string sp1sp2 ... <unknown> two subsequences consider distinct differ string bessie want label remain part sidewalk number distinct subsequences tile maximum possible however since bessie n't even finish learn alphabet need help ! note empty subsequence also count first line input contain two integers n k ( 0 ≤ n ≤ 1 000 000 1 ≤ k ≤ 26 ) second line contain a string t ( |t| = m 1 ≤ m ≤ 1 000 000 ) consist first k lowercase english letter determine maximum number distinct subsequences bessie form label last n sidewalk tile one first k lowercase english letter since number rather large print modulo 109 + 7 . please note ask maximize remainder modulo 109 + 7 ! goal maximize initial value print remainder first sample optimal label give 8 different subsequences : ` ` '' ( empty string ) ` ` a '' ` ` c '' ` ` b '' ` ` ac '' ` ` ab '' ` ` cb '' ` ` acb '' second sample entire sidewalk already label 10 possible different subsequences : ` ` '' ( empty string ) ` ` a '' ` ` b '' ` ` aa '' ` ` ab '' ` ` ba '' ` ` aaa '' ` ` aab '' ` ` aba '' ` ` aaba '' note string include ` ` aa '' obtain multiple sequence tile count,"['dp', 'greedy', 'strings']",2200.0
653/A,limak a little polar bear n ball i - th ball size ti limak want give one ball three friends give gift n't easy — two rule limak must obey make friends happy : example limak choose ball size 4 5 3 ball size 90 91 92 . ca n't choose ball size 5 5 6 ( two friends would get ball size ) ca n't choose ball size 30 31 33 ( size 30 33 differ 2 ) task check whether limak choose three ball satisfy condition first line input contain one integer n ( 3 ≤ n ≤ 50 ) — number ball limak second line contain n integers t1 t2 ... tn ( 1 ≤ ti ≤ 1000 ) ti denote size i - th ball print ` ` yes '' ( without quote ) limak choose three ball distinct size two differ 2 . otherwise print ` ` '' ( without quote ) first sample 4 ball limak able choose three satisfy rule must must choose ball size 18 16 17 . second sample way give gift three friends without break rule third sample even one way choose ball :,"['brute force', 'implementation', 'sortings']",900.0
653/D,niwel a little golden bear everyone know bear live forest niwel get tire see tree decide move city city niwel take a job manage bear deliver goods city live represent a direct graph n nod m edge edge a weight capacity a delivery consist a bear carry weight bear hand a simple path node 1 node n. total weight travel across a particular edge must exceed weight capacity edge niwel exactly x bear interest fairness bear rest weight bear carry must exactly however bear may take different paths like niwel would like determine maximum amount weight deliver ( 's sum weight carry bear ) find maximum weight first line contain three integers n m x ( 2 ≤ n ≤ 50 1 ≤ m ≤ 500 1 ≤ x ≤ 100 000 ) — number nod number direct edge number bear respectively follow m line contain three integers ai bi ci ( 1 ≤ ai bi ≤ n ai ≠ bi 1 ≤ ci ≤ 1 000 000 ) represent a direct edge node ai bi weight capacity ci self loop multiple edge one city city formally i j i ≠ j 's guarantee ai ≠ aj bi ≠ bj also guarantee least one path node 1 node n. print one real value a single line — maximum amount weight niwel deliver use exactly x bear answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer a answer jury b. checker program consider answer correct first sample niwel three bear two bear choose path one bear choose path even though bear go path carry one unit weight interest fairness restrict carry 0.5 units weight thus total weight 1.5 units overall note even though niwel deliver weight 2 bear must use exactly 3 bear day,"['binary search', 'graphs']",2200.0
658/A,"limak radewoosh go compete upcoming algorithmic contest equally skilled wo n't solve problems order n problems i - th problem initial score pi take exactly ti minutes solve problems sort difficulty — 's guarantee pi < pi + 1 ti < ti + 1 . a constant c give represent speed loose point , submit i - th problem time x ( x minutes start contest ) give max ( 0 pi - <unknown> ) point limak go solve problems order 1 2 ... n ( sort increasingly pi ) radewoosh go solve order n n - 1 ... 1 ( sort <unknown> pi ) task predict outcome — print name winner ( person get point end ) a word ` ` tie '' case a tie may assume duration competition greater equal sum ti mean limak radewoosh accept n problems first line contain two integers n c ( 1 ≤ n ≤ 50 1 ≤ c ≤ 1000 ) — number problems constant represent speed loose point second line contain n integers p1 p2 ... pn ( 1 ≤ pi ≤ 1000 pi < pi + 1 ) — initial score third line contain n integers t1 t2 ... tn ( 1 ≤ ti ≤ 1000 ti < ti + 1 ) ti denote number minutes one need solve i - th problem print ` ` limak '' ( without quote ) limak get point total print ` ` radewoosh '' ( without quote ) radewoosh get point total print ` ` tie '' ( without quote ) limak radewoosh get total number point first sample 3 problems limak solve follow : limak get 30 + 35 + 150 = 215 point radewoosh solve problem reverse order : radewoosh get 200 + 5 + 0 = 205 point total limak 215 point limak win second sample limak get 0 point problem radewoosh first solve hardest problem get 250 - <unknown> = 100 point radewoosh get 0 point two problems winner anyway third sample limak get 2 point 1 - st problem 2 point 2 - nd problem radewoosh get 4 point 8 - th problem wo n't get point problems thus a tie 2 + 2 = 4",['implementation'],800.0
659/C,berland recently a new collection toy go sale collection consist 109 type toy number integers 1 109 . a toy new collection i - th type cost i bourles tania manage collect n different type toy a1 a2 ... new collection today tanya 's birthday mother decide spend m bourles gift daughter tanya choose several different type toy new collection a gift course want get a type toy already tanya want many distinct type toy collection possible result new collection diverse tanya little ask help first line contain two integers n ( 1 ≤ n ≤ 100 000 ) m ( 1 ≤ m ≤ 109 ) — number type toy tanya already number bourles mom will spend buy new toy next line contain n distinct integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — type toy tanya already first line print a single integer k — number different type toy tanya choose number different type toy collection maximum possible course total cost select toy exceed m. second line print k distinct space - separated integers t1 t2 ... tk ( 1 ≤ ti ≤ 109 ) — type toy tanya choose multiple answer may print value ti print order first sample mom buy two toy : one toy 2 - nd type one toy 5 - th type purchase 7 bourles ( assume toy type 1 3 4 already buy ) impossible buy two toy,"['greedy', 'implementation']",1200.0
659/F,"farmer polycarp a warehouse hay represent n × m rectangular table n number row m number columns table cell table contain a haystack height meter hay locate i - th row j - th column equal integer ai j coincide number cubic meter hay haystack cells size base 1 × 1 . polycarp decide tidy warehouse remove arbitrary integer amount cubic meter hay top stack take different amount hay different <unknown> besides allow touch a stack , contrary remove completely a stack completely remove correspond cell become empty longer contain stack polycarp want follow requirements hold reorganization : two stack consider adjacent share a side table area call connect stack area get stack area move adjacent stack case two adjacent stack necessarily belong area help polycarp complete challenge task inform impossible first line input contain three integers n m ( 1 ≤ n m ≤ 1000 ) k ( 1 ≤ k ≤ 1018 ) — number row columns rectangular table heap hay lie require total number cubic meter hay reorganization n line follow contain m positive integers ai j ( 1 ≤ ai j ≤ 109 ) ai j equal number cubic meter hay make hay stack i - th row j - th column table first line print ` ` yes '' ( without quote ) polycarpus perform <unknown> ` ` '' ( without quote ) otherwise answer ` ` yes '' ( without quote ) next n line print m number — heights remain hay stack remain non - zero value equal represent a connect area least one value n't alter multiple answer print first sample non - zero value make a connect area value exceed initial heights hay stack non - zero value equal 7 number 5 total volume remain hay equal require value k = 7·5 = 35 . stack second line third row remain <unknown>","['dfs and similar', 'dsu', 'graphs', 'greedy', 'sortings']",2000.0
66/A,little petya recently start attend a program club naturally face problem choose a program language long considerations realize java best choice main argument favor choose java a large integer data type call biginteger attend several class club petya realize task require use biginteger type turn task much easier use small data type 's a question arise : ` ` integer type use one want store a positive integer n ? ` ` petya know 5 integer types:1 ) byte occupy 1 byte allow store number - 128 <unknown> ) short occupy 2 bytes allow store number - 32768 <unknown> ) int occupy 4 bytes allow store number - <unknown> <unknown> ) long occupy 8 bytes allow store number - <unknown> <unknown> ) biginteger store integer number a primitive type operations much slower type give boundary value include value range list petya want choose smallest type store a positive integer n. since biginteger work much slower peter regard last help first line contain a positive number n. consist 100 digits n't contain lead zero number n ca n't represent empty string please use % lld specificator read write 64 - bit integers c++ preffered use cout ( also may use % i64d ) print first type list ` ` byte short int long biginteger '' store natural number n accordance data give,"['implementation', 'strings']",1300.0
66/E,little vasya 's uncle a postman post offices locate one circular road besides post office gas station locate next petya 's uncle work follow : morning leave house go post office office receive a portion letter a car must drive give car exactly one round along circular road return start post office ( uncle drive along circle direction counterclockwise clockwise ) besides since car belong city post also fuel gasoline post office station total number station equal n. one fuel car i - th station ai liters gasoline besides one fuel car station also distance 1 - st 2 - nd station b1 kilometers distance 2 - nd 3 - rd one b2 kilometers ... ( n - 1 ) -th n - th ones distance bn - 1 kilometers n - th 1 - st one distance bn kilometers petya 's uncle 's high - tech car use one liter gasoline per kilometer know station locate sum ai equal sum bi i - th gas station i - th post office close distance 0 kilometers thus become clear start post offices always possible drive one round along a circular road uncle face follow problem : station go morning able ride exactly one circle along circular road visit post offices ? petya use attend program class volunteer help uncle knowledge turn enough ask help write program solve pose problem first line contain integer n ( 1 ≤ n ≤ 105 ) second line contain n integers ai — amount gasoline i - th station third line contain n integers b1 b2 ... bn distance 1 - st 2 - nd gas station 2 - nd 3 - rd ones ... n - th 1 - st ones respectively sum bi equal sum ai 109 . number ai bi less 1 109 . print first line number k — number possible post offices car drive one circle along a circular road print second line k number ascend order — number offices car start,"['data structures', 'dp']",2000.0
660/A,give array n elements must make a co - prime array move possible move insert positive integral number want greater 109 place array array co - prime two adjacent number co - prime number theory two integers a b say co - prime positive integer divide 1 . first line contain integer n ( 1 ≤ n ≤ 1000 ) — number elements give array second line contain n integers ai ( 1 ≤ ai ≤ 109 ) — elements array a. print integer k first line — least number elements need add array a make co - prime second line contain n + k integers aj — elements array a add k elements note new array co - prime two adjacent value co - prime also new array get original array a add k elements multiple answer print one,"['greedy', 'implementation', 'math', 'number theory']",1200.0
662/D,international abbreviation olympiad take place annually start 1989 . year competition receive abbreviation form iao ' y y stand number consequent last digits current year organizers always pick abbreviation non - empty string y never use among valid abbreviations choose shortest one announce abbreviation year 's competition example first three olympiads ( years 1989 <unknown> <unknown> respectively ) receive abbreviations iao ' 9 iao ' 0 iao ' 1 competition 2015 receive abbreviation <unknown> iao ' 5 already use <unknown> . give a list abbreviations determine year stand first line input contain a single integer n ( 1 ≤ n ≤ 1000 ) — number abbreviations process n line follow contain a single abbreviation 's guarantee abbreviation contain nine digits abbreviation give input find year correspond olympiad,"['greedy', 'implementation', 'math']",2000.0
662/E,consider a regular codeforces round consist three problems use dynamic score give almost final scoreboard participant ( include ) time accept submission problems give also solution already know whether able hack change scoreboard happen end round challenge best place may take end ? formally n people participate ( include ) problem solve exactly k people end round maximum score problem define : let maximum possible score problem equal s. a contestant n't manage get accept ( solution hack ) earn 0 point problem get solution accept t minutes begin round ( solution n't hack ) earn point problem overall score a participant equal sum point earn problem plus 100 point successful hack ( make hack ) result place get equal one plus number participants 's overall score strictly greater first line input contain a single integer n ( 1 ≤ n ≤ 5000 ) — number participants participant number 1 . follow n line contain three integers ai bi ci ai = 0 mean participant number i n't manage accept first problem 1 ≤ ai ≤ 120 participant number i get first problem accept ai minutes start contest hack solution finally - 120 ≤ ai ≤ - 1 mean participant number i get first problem accept - ai minutes start contest hack solution similarly bi ci provide information regard second third problems format 's guarantee integers a1 b1 c1 non - negative print integer — best place take end round consider first sample hack solutions win contest ( scoreboard leave ) however hack solution first problem third participant ( one hack ) maximum score first problem change finish second ( scoreboard right ),"['brute force', 'dp', 'greedy']",3100.0
665/F,"integer a divisible another integer b b call divisor a. example : 12 positive 6 divisors 1 2 3 4 6 12 . let ’ s define a function d ( n ) — number integers 1 n ( inclusive ) exactly four positive divisors 1 10 integers 6 8 10 exactly four positive divisors , d ( 10 ) = 3 . give integer n. calculate d ( n ) line contain integer n ( 1 ≤ n ≤ 1011 ) — parameter problem statement print integer c — number integers 1 n exactly four divisors","['data structures', 'dp', 'math', 'number theory', 'sortings', 'two pointers']",2400.0
67/C,"give a sequence ball a teacher label a lowercase latin letter ' a'- ' z ' n't like give sequence want change a new sequence b suit better , allow four operations : teacher place time constraints operation mean operation perform certain time , first operation take time ti second one take td third one take tr fourth one take te also give <unknown> ≥ ti + td find minimal time convert sequence a sequence b. first line contain four space - separated integers ti td tr te ( 0 < ti td tr te ≤ 100 ) follow two line contain sequence a b separate line length line 1 4000 character inclusive print a single integer represent minimum time convert a b. second sample could delete ball label ' a ' first position insert another ' a ' new second position total time 6 . however exchange ball give total time 3",['dp'],2600.0
670/F,vasya decide pass a large integer n kate first write number a string append right integer k — number digits n. magically number shuffle arbitrary order note pass kate thing vasya remember a non - empty substring n ( a substring n a sequence consecutive digits number n ) vasya know may one way restore number n. task find smallest possible initial integer n. note decimal representation number n contain lead zero except case integer n equal zero ( case a single digit 0 use ) first line input contain string receive kate number digits string exceed 1 000 000 . second line contain substring n vasya remember string contain lead zero guarantee input data correct answer always exist print <unknown> integer n vasya could pass kate,"['brute force', 'strings']",2300.0
671/A,"recycle day kekoland celebrate adil bera go central perk take bottle grind put a recycle bin think central perk coordinate plane n bottle grind i - th bottle locate position ( xi yi ) adil bera carry one bottle adil bera process look follow : adil bera may move independently allow pick bottle simultaneously bottle may pick two 's allow one stay still one continue pick bottle want organize process total distance walk ( sum distance walk adil distance walk bera ) minimum possible course end bottle lie recycle bin first line input contain six integers ax ay bx , tx ty ( 0 ≤ ax ay bx , tx ty ≤ 109 ) — initial position adil bera recycle bin respectively second line contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number bottle grind follow n line contain two integers xi yi ( 0 ≤ xi yi ≤ 109 ) — position i - th bottle 's guarantee position adil bera recycle bin bottle distinct print one real number — minimum possible total distance adil bera need walk order put bottle recycle bin answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer a answer jury b. checker program consider answer correct consider first sample adil use follow path : bera use follow path : adil 's path units long bera 's path units long","['dp', 'geometry', 'greedy', 'implementation']",1800.0
671/D,mayor yusland lottery decide spend money something good town example repair roads town yusland consist n intersections connect n - 1 bidirectional roads one travel intersection intersection use roads one road repair company town name ` ` rc company '' company 's center locate intersection 1 . rc company n't repair roads tell instead workers intersections repair specific paths i - th worker pay ci coin repair roads a path ui vi lie path ui intersection 1 . mayor ask choose cheapest way hire subset workers order repair roads yusland 's allow roads repair 's impossible repair roads print - 1 . first line input contain two integers n m ( 1 ≤ n m ≤ 300 000 ) — number cities yusland number workers respectively follow n−1 line contain two integers xi yi ( 1 ≤ xi yi ≤ n ) — indices intersections connect i - th road last m line provide description workers line contain three integers ui vi ci ( 1 ≤ ui vi ≤ n 1 ≤ ci ≤ 109 ) mean i - th worker repair roads path vi ui ci coin 's guarantee vi lie path ui 1 . note vi ui may coincide 's impossible repair roads print - 1 . otherwise print a single integer — minimum cost require repair roads use ` ` rc company '' workers first sample choose workers indices 1 3 4 5 roads repair ok . cost equal 2 + 3 + 1 + 2 = 8 coin,"['data structures', 'dp', 'greedy']",2900.0
672/A,every year hundreds people come summer camp learn new algorithms solve hard problems first year summer camp ask solve follow problem integers start 1 write one line prefix line ` ` <unknown> ... '' task print n - th digit string ( digits number start 1 . line input contain a single integer n ( 1 ≤ n ≤ 1000 ) — position digit need print print n - th digit line first sample digit position 3 ' 3 ' integers 1 2 consist one digit second sample digit position 11 ' 0 ' belong integer 10,['implementation'],800.0
673/A,"bear limak like watch sport tv go watch a game today game last 90 minutes break minute either interest bore 15 consecutive minutes bore limak immediately turn tv know n interest minutes t1 t2 ... tn task calculate many minutes limak watch game first line input contain one integer n ( 1 ≤ n ≤ 90 ) — number interest minutes second line contain n integers t1 t2 ... tn ( 1 ≤ t1 < t2 < ... tn ≤ 90 ) give increase order print number minutes limak watch game first sample minutes 21 22 ... 35 bore thus limak turn tv immediately 35 - th minute , would watch game 35 minutes second sample first 15 minutes bore third sample consecutive 15 bore minutes , limak watch whole game",['implementation'],800.0
676/C,high school student vasya get a string length n a birthday present string consist letter ' a ' ' b ' vasya denote beauty string maximum length a substring ( consecutive subsequence ) consist equal letter vasya change k character original string maximum beauty string achieve ? first line input contain two integers n k ( 1 ≤ n ≤ 100 000 0 ≤ k ≤ n ) — length string maximum number character change second line contain string consist letter ' a ' ' b ' print integer — maximum beauty string vasya achieve change k character first sample vasya obtain string ` ` aaaa '' ` ` bbbb '' second sample optimal answer obtain string ` ` <unknown> '' string ` ` <unknown> '',"['binary search', 'dp', 'strings', 'two pointers']",1500.0
676/E,100 years pass since last victory man versus computer go technologies make a huge step forward robots conquer earth ! 's time final fight human robot decide <unknown> planet follow game choose fight : initially a polynomial polynomial p ( x ) say divisible polynomial q ( x ) exist a representation p ( x ) = b ( x ) q ( x ) b ( x ) also polynomial move make already wonder true human guarantee victory play optimally ? first line input contain two integers n k ( 1 ≤ n ≤ 100 000 |k| ≤ 10 000 ) — size polynomial integer k. i - th follow n + 1 line contain character ' ? ' coefficient near xi - 1 yet undefined integer value ai coefficient already know ( - 10 000 ≤ ai ≤ 10 000 ) integers ai ( even ) may equal 0 . please note 's guarantee give position game 's computer 's turn move print ` ` yes '' ( without quote ) human win strategy ` ` '' ( without quote ) otherwise first sample computer set a0 - 1 first move human set coefficient a1 0.5 win second sample coefficients already set result polynomial divisible x - 100 human,['math'],2400.0
677/A,vanya friends walk along fence height h want guard notice order achieve height friends exceed h. height person greater h bend surely wo n't notice guard height i - th person equal ai consider width person walk usual equal 1 width bend person equal 2 . friends want talk walk would like walk a single row minimum width road friends walk a row remain unattended guard ? first line input contain two integers n h ( 1 ≤ n ≤ 1000 1 ≤ h ≤ 1000 ) — number friends height fence respectively second line contain n integers ai ( 1 ≤ ai ≤ 2h ) i - th equal height i - th person print a single integer — minimum possible valid width road first sample person number 3 must bend require width equal 1 + 1 + 2 = 4 . second sample friends short enough one bend width 1 + 1 + 1 + 1 + 1 + 1 = 6 enough third sample persons bend except last one require minimum width road equal 2 + 2 + 2 + 2 + 2 + 1 = 11,['implementation'],800.0
678/D,consider a linear function f ( x ) = ax + b. let 's define g ( 0 ) ( x ) = x g ( n ) ( x ) = f ( g ( n - 1 ) ( x ) ) n > 0 . give integer value a b n x find value g ( n ) ( x ) modulo 109 + 7 . line contain four integers a b n x ( 1 ≤ a b x ≤ 109 1 ≤ n ≤ 1018 ) — parameters problem statement note give value n large use 64 - bit integer type store c++ use long long integer type java use long integer type print integer s — value g ( n ) ( x ) modulo 109 + 7,"['math', 'number theory']",1700.0
678/E,rule sith tournament well know everyone n sith take part tournament tournament start random choice two sith fight first battle one lose place take next randomly choose sith n't fight need say battle sith tournament end a death one opponents ? tournament end sith remain alive jedi ivan accidentally appear list participants sith tournament however skills light side force strong influence choice participants either start tournament take loser 's place battle course wo n't miss chance take advantage help calculate probability victory first line contain a single integer n ( 1 ≤ n ≤ 18 ) — number participants sith tournament next n line contain n real number form a matrix pij ( 0 ≤ pij ≤ 1 ) element pij probability i - th participant defeat j - th a duel elements main diagonal <unknown> equal zero different i j equality pij + <unknown> = 1 hold probabilities give six decimal place jedi ivan number 1 list participants output a real number — probability jedi ivan stay alive tournament absolute relative error answer must exceed 10 - 6,"['bitmasks', 'dp', 'math']",2200.0
680/B,n cities bearland number 1 n. cities arrange one long row distance cities i j equal |i - j| limak a police officer live a city a. job catch criminals 's hard n't know cities criminals though know one criminal city limak go use a bcd ( bear criminal detector ) bcd tell limak many criminals every distance a city a. limak catch a criminal city sure must a criminal know cities criminals count number criminals limak catch use bcd first line input contain two integers n a ( 1 ≤ a ≤ n ≤ 100 ) — number cities index city limak live second line contain n integers t1 t2 ... tn ( 0 ≤ ti ≤ 1 ) ti criminals i - th city print number criminals limak catch first sample six cities limak live third one ( blue arrow ) criminals cities mark red use bcd give limak follow information : limak catch criminals cities 1 3 5 3 criminals total second sample ( draw ) bcd give limak information one criminal distance 2 limak 's city one city distance 2 limak sure a criminal,['implementation'],1000.0
681/E,dima live a dormitory well cockroaches moment 0 dima saw a cockroach run a table decide kill dima need exactly t second aim precisely strike cockroach finish survive cockroach run a shadow cast round plat stand table t second shadow cast plat shape a circle shadow circle may intersect nest overlap arbitrarily cockroach use follow strategy : first equiprobably pick a direction run towards run towards constant speed v. moment t ≤ t reach shadow circle immediately stop shadow thus stay alive otherwise cockroach kill dima 's precise strike consider dima 's precise strike instant determine probability cockroach stay alive first line input four integers x0 y0 v t ( <unknown> <unknown> ≤ 109 0 ≤ v t ≤ 109 ) give — cockroach initial position table cartesian system moment 0 cockroach 's constant speed time second dima need aim respectively next line number n ( 1 ≤ n ≤ 100 000 ) give — number shadow circle cast plat next n line shadow circle description give : ith consist three integers xi yi ri ( |xi| |yi| ≤ 109 0 ≤ r ≤ 109 ) — ith shadow circle on - table position cartesian system radius respectively consider table big enough cockroach run table edge avoid dima 's precise strike print real number p — probability cockroach stay alive answer consider correct absolute relative error exceed 10 - 4 . picture first sample give red color stand point choose cockroach 's run direction cause kill green color stand survival directions please note despite contain a circle center ( - 2 2 ) a part zone color red cockroach able reach one second,"['geometry', 'sortings']",2500.0
682/A,finish eat bun alyona come two integers n m. decide write two columns integers — first column contain integers 1 n second contain integers 1 m. girl want count many pair integers choose one first column second column sum divisible 5 . formally alyona want count number pair integers ( x y ) 1 ≤ x ≤ n 1 ≤ y ≤ m equal 0 . usual alyona trouble ask help line input contain two integers n m ( 1 ≤ n m ≤ 1 000 000 ) print integer — number pair integers ( x y ) 1 ≤ x ≤ n 1 ≤ y ≤ m ( x + y ) divisible 5 . follow pair suitable first sample case : pair ( 1 4 ) suitable third sample case,"['math', 'number theory']",1100.0
682/D,return forest alyona start read a book notice string s t lengths n m respectively usual read bore alyona decide pay attention string s t consider similar alyona favourite positive integer k small k exceed 10 . girl want choose k disjoint non - empty substrings string s string appear disjoint substrings string t order string s. also interest length maximum possible among variants formally alyona want find a sequence k non - empty string p1 p2 p3 ... pk satisfy follow condition : please help alyona solve complicate problem find least sum lengths string a desire sequence a substring a string a subsequence consecutive character string first line input three integers n m k ( 1 ≤ n m ≤ 1000 1 ≤ k ≤ 10 ) give — length string s length string t alyona 's favourite number respectively second line input contain string s consist lowercase english letter third line input contain string t consist lowercase english letter line print non - negative integer — sum lengths string a desire sequence guarantee least one desire sequence exist follow image describe answer second sample case :,"['dp', 'strings']",1900.0
685/A,robbers attack gerda 's cab successful cover kingdom police make goal catch even harder use watch first know kingdom police bad math robbers use positional numeral system base 7 . second divide one day n hours hour m minutes personal watch robber divide two part : first smallest possible number place necessary display integer 0 n - 1 second smallest possible number place necessary display integer 0 m - 1 . finally value hours minutes display use less number place base 7 watch require number zero add begin notation note display number 0 section watch require least one place little robber want know number moments time ( particular value hours minutes ) digits display watch distinct help calculate number first line input contain two integers give decimal notation n m ( 1 ≤ n m ≤ 109 ) — number hours one day number minutes one hour respectively print one integer decimal notation — number different pair hour minute digits display watch distinct first sample possible pair : ( 0 : 1 ) ( 0 : 2 ) ( 1 : 0 ) ( 1 : 2 ) second sample possible pair : ( 02 : 1 ) ( 03 : 1 ) ( 04 : 1 ) ( <unknown> : 1 ) ( <unknown> : 1 ),"['brute force', 'combinatorics', 'dp', 'math']",1700.0
687/B,today pari arya play a game call remainder pari choose two positive integer x k tell arya k x. arya find value n ancient number c1 c2 ... cn pari tell arya arya want give k ancient value tell us arya a win strategy independent value x formally true arya understand value positive integer x ? note mean remainder x divide y. first line input contain two integers n k ( 1 ≤ n k ≤ 1 000 000 ) — number ancient integers value k choose pari second line contain n integers c1 c2 ... cn ( 1 ≤ ci ≤ 1 000 000 ) print ` ` yes '' ( without quote ) arya a win strategy independent value x ` ` '' ( without quote ) otherwise first sample arya understand 5 one ancient number second sample arya ca n't sure example 1 7 remainder divide 2 3 differ remainder divide 7,"['math', 'number theory']",1800.0
687/E,today pari give arya a cool graph problem arya write a non - optimal solution believe ability optimize non - optimal solutions addition non - optimal code <unknown> try a lot optimize code also become dirty ! keep get time limit exceed disappoint suddenly a bright idea come mind ! dirty code look like : ask write tof function order optimize run time code minimize number call dfs function input a direct graph tof function rearrange edge graph list neighbor vertex number call dfs function depend arrangement neighbor vertex first line input contain two integers n m ( 1 ≤ n m ≤ 5000 ) — number vertices number direct edge input graph next m line contain a pair integers ui vi ( 1 ≤ ui vi ≤ n ) mean a direct edge input graph may assume graph wo n't contain self - loops one edge unordered pair vertices print a single integer — minimum possible number dfs call achieve permute edge,"['dfs and similar', 'graphs']",2900.0
689/C,bad news come mike 's village thieve steal a bunch chocolates local factory ! horrible ! aside love sweet things thieve area know greedy a thief take number chocolates next thief take exactly k time previous one value k ( k > 1 ) a secret integer know also know thief 's bag carry n chocolates ( intend take deal cancel ) exactly four thieve involve sadly thieve know value n rumour say number ways could take chocolates ( a fix n fix k ) m. two ways consider different one thieve ( number order take chocolates ) take different number chocolates mike want track thieve want know bag value n help please find smallest possible value n tell rumor false n. single line input contain integer m ( 1 ≤ m ≤ 1015 ) — number ways thieve might steal chocolates rumour say print integer n — maximum amount chocolates thieve ' bag carry one n satisfy rumor print smallest one n a false - <unknown> m print - 1 . first sample case smallest n lead exactly one way steal chocolates n = 8 whereas amount steal chocolates ( 1 2 4 8 ) ( number chocolates steal thieve ) second sample case smallest n lead exactly 8 ways n = 54 possibilities : ( 1 2 4 8 ) ( 1 3 9 27 ) ( 2 4 8 16 ) ( 2 6 18 54 ) ( 3 6 12 24 ) ( 4 8 16 32 ) ( 5 10 20 40 ) ( 6 12 24 48 ) n lead exactly 10 ways steal chocolates third sample case,"['binary search', 'combinatorics', 'math']",1700.0
69/E,programmer sasha recently begin study data structure coach stas tell solve problem find a minimum segment array sasha cop sasha think learn stas give a new task segment fix length sasha must find maximum element occur give segment exactly help sasha solve problem first line contain two positive integers n k ( 1 ≤ n ≤ 105 1 ≤ k ≤ n ) — number array elements length segment follow n line : i - th one contain a single number ai ( - 109 ≤ ai ≤ 109 ) print n – k + 1 number one per line : i - th line print maximum number number subarray ai ai + 1 … ai + k - 1 occur subarray exactly 1 time number subarray print ` ` nothing '',"['data structures', 'implementation']",1800.0
690/D3,many wall design choose ! even modulo 106 + 3 's enormous number give recently heidi acquire unlimited supply bricks choices endless ! really need something narrow heidi quick come criteria a useful wall : rule a fair amount possibilities right ? help heidi compute number useless wall confirm either criteria word a wall useless every segment width w height h. parameter c total width wall mean easy version however note number bricks unlimited output number useless wall modulo 106 + 3 . first line input contain three space - separated integers c w h ( 1 ≤ c ≤ 108 1 ≤ w h ≤ 100 ) output number different wall modulo 106 + 3 useless accord heidi 's criteria brick columns structure consider a useless wall,['dp'],2100.0
691/B,let 's call a string ` ` s - palindrome '' symmetric middle string example string ` ` <unknown> '' ` ` s - palindrome '' string ` ` aa '' string ` ` aa '' ` ` s - palindrome '' second half a mirror reflection first half give a string s. check string ` ` s - palindrome '' line contain string s ( 1 ≤ |s| ≤ 1000 ) consist english letter print ` ` tak '' string s ` ` s - palindrome '' ` ` nie '' otherwise,"['implementation', 'strings']",1600.0
691/F,"couple cover a wildly popular luck - based game begin ! two players must work together construct a rectangle a bag n ball integer write place table first player reach grab a ball randomly ( ball equal probability choose ) — number write ball rectangle 's width meter ball return bag second player reach bag grab another ball — number write ball rectangle 's height meter area rectangle greater equal threshold p square meter players win otherwise lose organizers game try select appropriate value p probability a couple win high low slow count hire answer question give a list number write ball organizers would like know many win pair ball exist different value p. note two pair different either first second ball different two pair two different ball number consider different input begin a single positive integer n line ( 1 ≤ n ≤ 106 ) second line contain n positive integers — i - th number line equal ai ( 1 ≤ ai ≤ 3·106 ) number write i - th ball next line contain integer m ( 1 ≤ m ≤ 106 ) number question ask , follow line contain m positive integers — j - th number line equal value p ( 1 ≤ p ≤ 3·106 ) j - th question ask question print number win pair ball exist give value p separate line","['brute force', 'dp', 'number theory']",2200.0
696/B,barney live country usc ( unite state <unknown> ) usc n cities number 1 n n - 1 roads cities roads usc form a root tree ( barney 's sure root ) root tree city number 1 . thus one start journey city 1 visit city want follow roads girl steal barney 's heart barney want find start look root tree ( since barney <unknown> a random guy ) use a random dfs search cities a pseudo code algorithm follow : tell barney start journey root tree ( equivalent call dfs ( 1 ) ) barney need pack a backpack want know upcoming journey : every city i barney want know expect value starting_time [ i ] 's a friend jon snow know nothing 's ask help first line input contain a single integer n ( 1 ≤ n ≤ 105 ) — number cities usc second line contain n - 1 integers p2 p3 ... pn ( 1 ≤ pi < i ) pi number parent city city number i tree mean a road cities number pi i usc first line output print n number i - th number expect value starting_time [ i ] answer city consider correct absolute relative error exceed 10 - 6,"['dfs and similar', 'math', 'trees']",1700.0
7/C,a line plane describe equation ax + + c = 0 . find point line whose coordinate integer number - 5·1018 5·1018 inclusive find point exist first line contain three integers a b c ( - 2·109 ≤ a b c ≤ 2·109 ) — correspond coefficients line equation guarantee a2 + b2 > 0 . require point exist output coordinate otherwise output -1,"['math', 'number theory']",1800.0
70/D,a walrus professor <unknown> ask program students perform follow practical task students implement a data structure would support a convex hull set point s. input program q query two type : 1 . add a point coordinate ( x y ) set s. note case convex hull s could change could remain 2 . say whether a point coordinate ( x y ) belong area limit convex hull include border students cop task ? first line contain integer q ( 4 ≤ q ≤ 105 ) follow q line follow way : ` ` t x y '' t query type ( 1 2 ) ( x y ) coordinate point ( - 106 ≤ x y ≤ 106 x y integers ) least one query type 2 . guarantee three query first type follow first point give query form a non - <unknown> triangle also point add s distinct query second type print one string contain ` ` yes '' point lie inside convex hull border otherwise print ` ` '',"['data structures', 'geometry']",2700.0
70/E,think already xxi century mass media n't popular walrusland cities get news <unknown> travel along roads network roads walrusland build possible get city one exactly one way roads ' lengths equal north pole <unknown> decide carry information reform several cities decide choose make regional center maintain a region center take k fishlars ( a local currency ) per year assume a regional center always information latest news every city a regional center decide appoint a regional center responsible keep city inform case maintenance cost equal <unknown> fishlars per year len distance a city correspond regional center measure number roads along one need go task minimize cost carry reform first line contain two give number n k ( 1 ≤ n ≤ 180 1 ≤ k ≤ 105 ) second line contain n - 1 integers di number start 1 ( di ≤ di + 1 0 ≤ di ≤ 105 ) next n - 1 line contain pair cities connect a road first line print minimum number fishlars need a year 's maintenance second line print n number i - th number represent number regional center appoint i - th city i - th city a regional center print number i. several solutions problem print,"['dp', 'implementation', 'trees']",2700.0
701/B,vasya square chessboard size n × n m rook initially chessboard empty vasya consequently put rook board one another cell field rook 's attack least one rook locate row column cell a rook locate cell cell also attack give position board vasya put rook rook determine number cells attack vasya put board first line input contain two integers n m ( 1 ≤ n ≤ 100 000 1 ≤ m ≤ min ( 100 000 n2 ) ) — size board number rook next m line contain integers xi yi ( 1 ≤ xi yi ≤ n ) — number row number column vasya put i - th rook vasya put rook board order appear input guarantee cell contain one rook print m integer i - th equal number cells attack first i rook put picture show state board put three rook cells paint grey color attack,"['data structures', 'math']",1200.0
702/B,"give n integers a1 a2 ... , find number pair index i j ( i < j ) ai + aj a power 2 ( i. e. integer x exist ai + aj = 2x ) first line contain single positive integer n ( 1 ≤ n ≤ 105 ) — number integers second line contain n positive integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) print number pair index i j ( i < j ) ai + aj a power 2 . first example follow pair index include answer : ( 1 4 ) ( 2 4 ) second example pair index ( i j ) ( i < j ) include answer","['brute force', 'data structures', 'implementation', 'math']",1500.0
703/C,mishka enjoy trip ... chris a little brown bear one know meet mishka a long time together ( exclude current trip ) however best friends important john chris ' best friend walk friend john give chris follow problem : infinite horizontal road width w bound line y = 0 y = w a bus move present a convex polygon n vertices bus move continuously a constant speed v a straight ox line direction decrease x coordinate thus time x coordinate point change formally time t x coordinate point decrease vt . a pedestrian point ( 0 0 ) move a vertical pedestrian cross present a segment connect point ( 0 0 ) ( 0 w ) speed exceed u. thus pedestrian move a straight line oy direction speed exceed u leave road border pedestrian instantly change speed thus example stop instantly please look sample note picture better understand consider pedestrian hit bus moment point locate lie strictly inside bus polygon ( mean point lie polygon vertex edge pedestrian hit bus ) give bus position moment 0 . please help chris determine minimum amount time pedestrian need cross road reach point ( 0 w ) hit bus first line input contain four integers n w v u ( 3 ≤ n ≤ 10 000 1 ≤ w ≤ 109 1 ≤ v u ≤ 1000 ) — number bus polygon vertices road width bus speed pedestrian speed respectively next n line describe polygon vertices counter - clockwise order i - th contain pair integers xi yi ( - 109 ≤ xi ≤ 109 0 ≤ yi ≤ w ) — coordinate i - th polygon point guarantee polygon non - degenerate print single real t — time pedestrian need <unknown> road hit bus answer consider correct relative absolute error n't exceed 10 - 6 . follow image describe initial position first sample case :,"['geometry', 'implementation']",2100.0
706/E,"vasiliy finally get work a huge amount task wait vasiliy give a matrix consist n row m columns q task task swap two <unknown> give matrix task vasiliy know six integers ai bi ci di hi wi ai index row top - left corner first rectangle locate bi index column ci index row top - left corner second rectangle di index column hi height rectangle wi width 's guarantee two rectangles one query overlap touch , cell belong rectangles two cells belong different rectangles share a side however rectangles allow share angle vasiliy want know matrix look like task perform first line input contain three integers n m q ( 2 ≤ n m ≤ 1000 1 ≤ q ≤ 10 000 ) — number row columns matrix number task vasiliy perform follow n line contain m integers vi j ( 1 ≤ vi j ≤ 109 ) — initial value cells matrix follow q line contain six integers ai bi ci di hi wi ( 1 ≤ ai ci hi ≤ n 1 ≤ bi di wi ≤ m ) print n line contain m integers — result matrix","['data structures', 'implementation']",2500.0
708/B,string s consist character ' 0 ' ' 1 ' one define four integers a00 a01 a10 a11 <unknown> number subsequences length 2 string s equal sequence { x y } problem give four integers a00 a01 a10 a11 find non - empty string s match determine string one prove least one answer exist exist answer length 1 000 000 . line input contain four non - negative integers a00 a01 a10 a11 n't exceed 109 . exist a non - empty string match four integers input print line output otherwise print ` ` impossible '' length answer must exceed 1 000 000,"['greedy', 'implementation', 'math']",1900.0
71/E,follow puzzle popular among nuclear physicists a <unknown> contain a set n atoms chemical elements shall understand phrase ` ` atomic number '' number atom 's element periodic table chemical elements allow take two different atoms fuse a new one result a new atom whose number equal sum number original atoms fusion operation perform several time aim get a new <unknown> set k atoms puzzle 's difficulty allow fuse two atoms one allow split atom several atoms suggest try solve puzzle first line contain two integers n k ( 1 ≤ k ≤ n ≤ 17 ) second line contain space - separated symbols elements n atoms available start third line contain space - separated symbols elements k atoms need result fusion symbols elements coincide symbols periodic table chemical elements atomic number exceed 100 ( elements possess larger number highly unstable ) atoms identical number ( several atoms element ) sum number initial atoms equal sum number atoms need synthesize impossible synthesize require atoms print ` ` '' without quote otherwise print first line « yes » next k line print way synthesize k atoms equations equation follow form : ` ` <unknown> + ... + <unknown> > yi '' xj symbol element atom original set yi symbol element atom result set atom input data occur output data exactly one time order summands equations well output order matter several solutions print a better understand output format see sample reactions first example possess follow form ( atomic number write leave element ) : find a periodic table chemical elements may use favorite search engine pretest set contain first 100 elements periodic table least use information check <unknown>,"['bitmasks', 'dp']",2200.0
711/A,"zs coder chris baboon travel udayland ! get get special ioi bus ioi bus n row seat 4 seat row seat separate pair a walkway zs chris come place bus already occupy zs chris good friends insist get a pair neighbour empty seat two seat consider neighbour row pair give configuration bus help zs chris determine sit ? first line input contain a single integer n ( 1 ≤ n ≤ 1000 ) — number row seat bus , n line follow line contain exactly 5 character first two denote first pair seat row third character denote walkway ( always equal ' | ' ) last two denote second pair seat row character except walkway equal ' o ' ' x ' ' o ' denote empty seat ' x ' denote occupy seat see sample case detail possible chris zs sit neighbour empty seat print ` ` yes '' ( without quote ) first line next n line print bus configuration character pair seat chris zs change character ' + ' thus configuration differ input one exactly two <unknown> ( equal ' o ' input ' + ' output ) pair seat chris zs print ` ` '' ( without quote ) a single line multiple solutions may print note follow incorrect configuration first sample case seat must pair <unknown>","['brute force', 'implementation']",800.0
711/B,zs coder chris baboon arrive entrance udayland a n × n magic grid entrance fill integers chris notice exactly one cells grid empty enter udayland need fill a positive integer empty cell chris try fill random number n't work zs coder realize need fill a positive integer number grid form a magic square mean fill a positive integer sum number row grid ( ) column grid ( ) two long diagonals grid ( main diagonal — secondary diagonal — ) equal chris n't know number fill help chris find correct positive integer fill determine impossible ? first line input contain a single integer n ( 1 ≤ n ≤ 500 ) — number row columns magic <unknown> line follow contain n integers j - th number i - th denote ai j ( 1 ≤ ai j ≤ 109 ai j = 0 ) number i - th row j - th column magic grid correspond cell empty ai j equal 0 . otherwise ai j positive guarantee exactly one pair integers i j ( 1 ≤ i j ≤ n ) ai j = 0 . output a single integer positive integer x ( 1 ≤ x ≤ 1018 ) fill empty cell whole grid become a magic square positive integer x exist output - 1 instead multiple solutions may print first sample case fill 9 empty cell make result grid a magic square indeed sum number row is:4 + 9 + 2 = 3 + 5 + 7 = 8 + 1 + 6 = 15 . sum number column is:4 + 3 + 8 = 9 + 5 + 1 = 2 + 7 + 6 = 15 . sum number two diagonals is:4 + 5 + 6 = 2 + 5 + 8 = 15 . third sample case impossible fill a number empty square result grid a magic square,['implementation'],1400.0
712/D,memory friend lexa compete get higher score one popular computer game memory start score a lexa start score b. a single turn memory lexa get integer range [ - k ; k ] ( i.e one integer among - k - k + 1 - k + 2 ... - 2 - 1 0 1 2 ... k - 1 k ) add current score game exactly t turn memory lexa however good game always get a random integer turn memory wonder many possible game exist end a strictly higher score lexa two game consider different least one turn least one player get different score ( 2k + 1 ) 2 t game total since answer large print modulo 109 + 7 . please solve problem memory first line input contain four integers a b k t ( 1 ≤ a b ≤ 100 1 ≤ k ≤ 1000 1 ≤ t ≤ 100 ) — amount memory lexa start number k number turn respectively print number possible game satisfy condition modulo 1 000 000 007 ( 109 + 7 ) one line first sample test memory start 1 lexa start 2 . lexa pick - 2 memory pick 0 1 2 win lexa pick - 1 memory pick 1 2 win lexa pick 0 memory pick 2 win lexa pick 1 2 memory win thus 3 + 2 + 1 = 6 possible game memory win,"['combinatorics', 'dp', 'math']",2200.0
712/E,n casinos line a row memory play casino i probability pi win move casino right ( i + 1 ) exit row ( i = n ) a probability 1 - pi lose move casino leave ( i - 1 ) also exit row ( i = 1 ) say memory dominate interval i ... j complete a walk note memory still walk leave 1 - st casino right casino n always finish process memory request one follow form : guarantee moment time p a non - decreasing sequence i.e pi ≤ pi + 1 i 1 n - 1 . please help memory answer request ! first line input contain two integers n q ( 1 ≤ n q ≤ 100 000 ) — number casinos number request respectively next n line contain integers ai bi ( 1 ≤ ai < bi ≤ 109 ) — probability pi win casino i. next q line contain query one type specify ( 1 ≤ a < b ≤ 109 1 ≤ i ≤ n 1 ≤ l ≤ r ≤ n ) 's guarantee least one query type 2 i.e output non - empty additionally guarantee p form a non - decreasing sequence time print a real number every request type 2 — probability boy ` ` dominate '' interval answer consider correct absolute error exceed 10 - 4 . namely : let 's assume one answer a correspond answer jury b. checker program consider answer correct |a - b| ≤ 10 - 4,"['data structures', 'math']",2500.0
713/D,owl sonya give a huge lake puzzle size n × m hedgehog filya a birthday present friends immediately start assemble puzzle part turn empty — picture part picture denote 1 empty part denote 0 . row puzzle number top bottom integers 1 n columns number leave right integers 1 m. animals decide complete picture play might even fun ! owl hedgehog ask query query provide four integers x1 y1 x2 y2 define rectangle ( x1 y1 ) stand coordinate leave cell rectangle ( x2 y2 ) stand coordinate bottom right cell answer query size maximum square consist picture part ( part denote 1 ) locate fully inside query rectangle help sonya filya answer t query first line input contain two integers n m ( 1 ≤ n m ≤ 1000 ) — size puzzle follow n line contain m integers aij equal 1 correspond cell contain a picture 0 's empty next line contain integer t ( 1 ≤ t ≤ 1 000 000 ) — number query follow t line query ' descriptions contain four integers x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ m ) — coordinate leave bottom right cells query rectangle print t line i - th contain maximum size square consist 1 - s lie fully inside query rectangle,"['binary search', 'data structures']",2700.0
713/E,owl sonya decide become a <unknown> train role gather owl friends country house m chair locate a circle consequently number integers 1 m. thus chair i i + 1 neighbour i 1 m - 1 . chair 1 m also neighbour chair occupy friends n friends total two friends occupy chair rule follow : owls busy want get rid game soon possible cooperate pick direction goal find minimum number o move require finish game first line input contain a single integer m ( 1 ≤ m ≤ 109 ) — length circle second line contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number friends last line contain increase sequence n integers ai ( 1 ≤ ai ≤ m ) — initial position owls print minimum number move require finish game note 0 also may answer first sample 's possible owls move clockwise i.e direction increase indices sample first owl move clockwise second — counterclockwise third sample first fourth owls move counterclockwise third sixth — clockwise second <unknown> may move direction,"['binary search', 'dp']",3300.0
714/A,today outstanding event go happen forest — hedgehog filya come old fry sonya ! sonya owl sleep day stay awake minute l1 minute r1 inclusive also minute k prink unavailable filya filya work a lot plan visit sonya minute l2 minute r2 inclusive calculate number minutes able spend together line input contain integers l1 r1 l2 r2 k ( 1 ≤ l1 r1 l2 r2 k ≤ 1018 l1 ≤ r1 l2 ≤ r2 ) provide segment time sonya filya moment time sonya prink print one integer — number minutes sonya filya able spend together first sample together minutes 9 10 . second sample together minute 50 minute 74 minute <unknown> minute 100,"['implementation', 'math']",1100.0
714/B,"today hedgehog filya go school first time ! teacher give a homework filya unable complete without help filya give array non - negative integers a1 a2 ... , first pick integer x add x elements array ( ) subtract x elements ( also ) change elements want elements array equal wonder 's possible pick integer x change elements array use x order make elements equal first line input contain integer n ( 1 ≤ n ≤ 100 000 ) — number integers filya 's array second line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 109 ) — elements array 's impossible make elements array equal use process give problem statement print ` ` '' ( without quote ) line output otherwise print ` ` yes '' ( without quote ) first sample filya select x = 1 add first last elements array subtract second third elements","['implementation', 'sortings']",1200.0
715/A,"zs coder play a game a number display screen two button ' + ' ( plus ) ` ` ( square root ) initially number 2 display screen n + 1 level game zs coder start level 1 . zs coder level k : additionally move zs coder level k number screen m m must a multiple k. note condition check perform press example zs coder level 4 current number 100 press ` ` button number turn 10 . note moment 10 divisible 4 press still valid , zs coder level 5 10 divisible 5 . zs coder need help beat game — want reach level n + 1 . word need press ` ` button n time help determine number time press ' + ' button press ` ` button level please note zs coder want find sequence press allow reach level n + 1 necessarily a sequence minimize number press first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) denote zs coder want reach level n + 1 . print n non - negative integers one per line i - th equal number time zs coder need press ' + ' button press ` ` button level i. number output exceed 1018 . however number screen greater 1018 . guarantee least one solution exist multiple solutions print first sample case : first level zs coder press ' + ' button 14 time ( number screen initially 2 ) number become 2 + <unknown> = 16 . zs coder press ` ` button number become , second level zs press ' + ' button 16 time number become 4 + <unknown> = 36 . zs press ` ` button level change number , third level zs press ' + ' button 46 time number become 6 + <unknown> = 144 . zs press ` ` button level change number note 12 indeed divisible 4 zs coder reach level 4 . also note press ' + ' button 10 time third level level work number become 6 + 10·3 = 36 ` ` button press number become zs coder level 4 . however 6 divisible 4 a valid solution second sample case : first level zs coder press ' + ' button <unknown> time ( number screen initially 2 ) number become 2 + <unknown> = 1018 . zs coder press ` ` button number become , second level zs press ' + ' button <unknown> time number become 109 + <unknown> = <unknown> , zs press ` ` button level change number note 300000 a multiple 3 zs coder reach level 3",['math'],1600.0
717/A,"prodiggers quite a cool band reason surprise guest enter festival past 80 years begin career ’ t successful spend time dig channel earn money ; hence name anyway like tour a lot surprise amount energy extremely long tour however hate spend two consecutive days without a concert would like avoid a tour define a sequence concert days - off need count many ways prodiggers select k different tour length l r. example k = 2 l = 1 r = 2 define concert day { 1 } day - off { 0 } possible tour : { 0 } { 1 } { 00 } { 01 } { 10 } { 11 } tour 00 select 2 days - off a row , need count many ways select k = 2 tour length range [ 1 ; 2 ] : { 0,1 } ; { <unknown> } ; { <unknown> } ; { <unknown> } since schedule quite busy want tell many ways modulo 1 000 000 007 ( 109 + 7 ) first line input contain three integers k l r ( 1 ≤ k ≤ 200 1 ≤ l ≤ r ≤ 1018 ) output a single number : number ways select k different tour length modulo 1 000 000 007","['combinatorics', 'math', 'number theory']",2900.0
717/F,"i ’ m stroll <unknown> yeah - ah ! ’ t feel good ! well certainly feel good heroes make magic <unknown> walk a one - directional road fight imps imps weak <unknown> creatures good much however heroes enjoy fight fun nothing else hero ignatius simply adore imps observe a line imps represent a zero - indexed array integers a length n ai denote number imps i - th position sometimes imps appear nowhere heroes fight imps select a segment line start one end segment finish end without ever exit segment move exactly one cell leave right current position defeat one imp cell move , number imps cell decrease one also apply heroes appear one end segment begin walk goal defeat imps segment without ever move empty cell ( without imps ) since would get bore since ignatius love imps ’ t really want fight imps harm events task however would like tell whether would possible clear a certain segment imps mention way want give q query two type : first line contain a single integer n ( 1 ≤ n ≤ 200 000 ) length array a. follow line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 5 000 ) initial number imps cell third line contain a single integer q ( 1 ≤ q ≤ 300 000 ) number query remain q line contain one query query provide integers a b possibly k ( 0 ≤ a ≤ b < n 0 ≤ k ≤ 5 000 ) second type query output 1 possible clear segment 0 first query one easily check indeed impossible get first last cell clear everything add 1 second position clear segment example move follow way :",['data structures'],2600.0
718/C,"sasha array integers a1 a2 ... , perform m query might query two type : problem define fibonacci number follow : f ( 1 ) = 1 f ( 2 ) = 1 f ( x ) = f ( x - 1 ) + f ( x - 2 ) x > 2 . sasha a talented boy manage perform query five second able write program perform well sasha ? first line input contain two integers n m ( 1 ≤ n ≤ 100 000 1 ≤ m ≤ 100 000 ) — number elements array number query respectively next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) follow m line query descriptions contain integers tpi li ri may xi ( 1 ≤ tpi ≤ 2 1 ≤ li ≤ ri ≤ n 1 ≤ xi ≤ 109 ) tpi = 1 correspond query first type tpi correspond query second type 's guarantee input contain least one query second type query second type print answer modulo 109 + 7 . initially array a equal 1 1 2 1 1 . answer first query second type f ( 1 ) + f ( 1 ) + f ( 2 ) + f ( 1 ) + f ( 1 ) = 1 + 1 + 1 + 1 + 1 = 5 . query 1 2 4 2 array a equal 1 3 4 3 1 . answer second query second type f ( 3 ) + f ( 4 ) + f ( 3 ) = 2 + 3 + 2 = 7 . answer third query second type f ( 1 ) + f ( 3 ) + f ( 4 ) + f ( 3 ) + f ( 1 ) = 1 + 2 + 3 + 2 + 1 = 9","['data structures', 'math']",2300.0
718/D,chemistry lesson andrew learn saturate <unknown> ( <unknown> ) enter radical <unknown> reaction andrew a curious boy wonder many different products reaction may form a give <unknown> manage solve task small <unknown> large ones face difficulties ask help formally give a tree consist n vertices degree vertex n't exceed 4 . count number distinct non - isomorphic tree obtain add tree one new vertex one new edge graph still tree degree vertex n't exceed 4 . two tree isomorphic exist a bijection f ( v ) vertices u v connect edge vertices f ( v ) f ( u ) connect edge first line input contain integer n ( 1 ≤ n ≤ 100 000 ) — number vertices tree follow n - 1 line edge descriptions edge give two integers ui vi ( 1 ≤ ui vi ≤ n ) — indices vertices connect edge 's guarantee give graph a tree degree vertex n't exceed 4 . print one integer — answer question first sample one add new vertex exist vertex tree obtain add a new vertex vertices 1 3 4 isomorphic thus answer 2 . second sample one ca n't add new vertex first vertex degree already equal four tree obtain add a new vertex vertices 2 3 4 5 isomorphic thus answer 1,"['dp', 'trees']",2900.0
719/B,anatoly live university dorm many students know cockroaches also live together students cockroaches might two color : black red n cockroaches live anatoly 's room anatoly make cockroaches form a single line a perfectionist would like color cockroaches line alternate a black paint a red paint one turn either swap two cockroaches take single cockroach change 's color help anatoly find minimum number turn need make color cockroaches line alternate first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number cockroaches second line contain a string length n consist character ' b ' ' r ' denote black cockroach red cockroach respectively print one integer — minimum number move anatoly perform order make color cockroaches line alternate first sample anatoly swap third fourth cockroaches need 1 turn second sample optimum answer paint second fourth cockroaches red require 2 turn third sample color cockroaches line alternate already thus answer 0,['greedy'],1400.0
72/B,ini file format a de facto standard configuration file ini file simple text file a basic structure commonly associate <unknown> windows also use platforms line ini - file stand key - value map define new section a key - value line a format ` ` key = value '' key — name property value — 's value possible space side key and/or value space ignore a section line a format ` ` [ section ] '' mean key - value line define properties specify section cause follow section line change current section a section line may space around bracket also ignore comment line — first non - space character comment line ` ` ; '' task write program format give ini - file a special way : first line contain single integer n ( 1 ≤ n ≤ 510 ) — number line give ini - file rest input contain a valid ini - file n line value section key value contain latin letter digits ` ` . '' and/or ` ` - '' line length exceed 255 character less 1 character total length line ’ t exceed 10000 . print format ini - file,['implementation'],2200.0
72/G,king <unknown> love fibonacci number several armies today want make a new army want number men army n - th fibonacci number give n find n - th fibonacci number set fibonacci number start f0 = f1 = 1 i ≥ 2 fi = fi - 1 + fi - 2 . input contain a single integer n ( 1 ≤ n ≤ 20 ) write a single integer n - th fibonacci number,['dp'],1000.0
720/E,borya recently find a big electronic display computer manage display store integer number number n decimal digits display show encode version number digit show use lowercase letter english alphabet a legend near display describe number encode digit position i digit j character c know encode digit position different digits code character second number increase 1 . one second a moment number reach value represent n 9 - s decimal notation loud <unknown> sound andrew know number store computer want know many second must pass borya definitely tell original number encode display assume borya precisely measure time encode number first increase exactly one second borya start watch display input data contain multiple test case first line input contain t ( 1 ≤ t ≤ 100 ) — number test case test case describe follow first line description contain n ( 1 ≤ n ≤ 18 ) — number digits number second line contain n decimal digits without space ( possibly lead zero ) — number initially store display computer follow n line contain 10 character j - th character i - th line code character a digit j - 1 position i significant digit position describe first test case print integer : number second borya definitely know initial number store display computer print lead zero,['implementation'],3100.0
721/E,danil student return home tram stop lately straight road length l. stop locate point x = 0 danil 's home — point x = l. danil go x = 0 x = l a constant speed change direction movement n street light road light continuous segment road n lighten segment share common point danil love sing thus want sing favourite song walk soon non - <unknown> segment road scare sing go lighten segment danil pass distance p perform favourite song danil ca n't start another performance segment pass perform fully lighten moreover danil take a pause two performances perform pass a segment length least t. formally determine many time danil perform favourite song walk x = 0 x = l. please note danil break a single performance thus start sing another time finish sing a segment length p pass performance start point first line input contain four integers l n p t ( 1 ≤ l ≤ 109 0 ≤ n ≤ 100 000 1 ≤ p ≤ 109 1 ≤ t ≤ 109 ) — length danil 's path number street light road distance danil pass single performance minimum distance pause respectively next n line describe segment lighten street light i - th contain two integers li ri ( 0 ≤ li < ri ≤ l ) — endpoints segment lighten i - th street light guarantee two segment intersect nest touch segment give order leave right print integer — maximum number performances danil 's favourite song path x = 0 x = l. first sample case correspond picture statement,"['binary search', 'dp']",2700.0
723/C,"polycarp a music editor radio station receive a playlist tomorrow represent a sequence a1 a2 ... , ai a band perform i - th song polycarp like band number 1 m n't really like others define bj number songs group j go perform tomorrow polycarp want change playlist a way minimum among number b1 b2 ... bm large possible find maximum possible value minimum among bj ( 1 ≤ j ≤ m ) minimum number change playlist polycarp need make achieve one change playlist a replacement performer i - th song group first line input contain two integers n m ( 1 ≤ m ≤ n ≤ 2000 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) ai performer i - th song first line print two integers : maximum possible value minimum among bj ( 1 ≤ j ≤ m ) bj number songs change playlist perform j - th band minimum number change playlist polycarp need make second line print change playlist multiple answer print first sample polycarp 's change first band perform two songs ( b1 = 2 ) second band also perform two songs ( b2 = 2 ) thus minimum value equal 2 . impossible achieve a higher minimum value change playlist second sample polycarp 's change first band perform two songs ( b1 = 2 ) second band perform three songs ( b2 = 3 ) third band also perform two songs ( b3 = 2 ) thus best minimum value 2",['greedy'],1600.0
724/C,k sensors locate rectangular room size n × m meter i - th sensor locate point ( xi yi ) sensors locate distinct point strictly inside rectangle opposite corner room locate point ( 0 0 ) ( n m ) wall room parallel coordinate ax moment 0 point ( 0 0 ) laser ray release direction point ( 1 1 ) ray travel a speed meter per second thus ray reach point ( 1 1 ) exactly one second start ray meet wall 's reflect rule angle incidence equal angle reflection ray reach four corner immediately stop sensor determine first moment time ray pass point sensor locate ray never pass point print - 1 sensors first line input contain three integers n m k ( 2 ≤ n m ≤ 100 000 1 ≤ k ≤ 100 000 ) — lengths room 's wall number sensors follow k line contain two integers xi yi ( 1 ≤ xi ≤ n - 1 1 ≤ yi ≤ m - 1 ) — coordinate sensors 's guarantee two sensors locate point print k integers i - th equal number second ray first pass point i - th sensor locate - 1 never happen first sample ray consequently pass point ( 0 0 ) ( 1 1 ) ( 2 2 ) ( 3 3 ) thus stop point ( 3 3 ) 3 second second sample ray consequently pass follow point : ( 0 0 ) ( 1 1 ) ( 2 2 ) ( 3 3 ) ( 2 4 ) ( 1 3 ) ( 0 2 ) ( 1 1 ) ( 2 0 ) ( 3 1 ) ( 2 2 ) ( 1 3 ) ( 0 4 ) ray stop point ( 0 4 ) 12 second reflect point ( 3 3 ) ( 2 4 ) ( 0 2 ) ( 2 0 ) ( 3 1 ),"['greedy', 'implementation', 'math', 'number theory', 'sortings']",1800.0
724/F,a tree a connect graph without cycle two tree consist n vertices call isomorphic exist a permutation p : { 1 ... n } → { 1 ... n } edge ( u v ) present first tree edge ( pu pv ) present second tree vertex tree call internal degree greater equal two count number different non - isomorphic tree consist n vertices degree internal vertex exactly d. print answer give prime modulo mod single line input contain three integers n d mod ( 1 ≤ n ≤ 1000 2 ≤ d ≤ 10 108 ≤ mod ≤ 109 ) — number vertices tree degree internal vertices prime modulo print number tree modulo mod,"['combinatorics', 'dp', 'trees']",2700.0
73/C,vasya play <unknown> ii bore play a stupid computer instal popular mmorpg fight friends vasya come name character — non - empty string s consist a lowercase latin letter however order put a front friends vasya decide change k letter character name new name sound good possible euphony line define follow : pair adjacent letter x y ( x immediately precede y ) bonus c ( x y ) add result task determine greatest euphony obtain change k letter name vasya 's character first line contain character 's name s integer number k ( 0 ≤ k ≤ 100 ) length nonempty string s exceed 100 . second line contain integer number n ( 0 ≤ n ≤ <unknown> ) — amount pair letter give bonus euphony next n line contain description pair « x y c » mean sequence xy give bonus c ( x y — lowercase latin letter - 1000 ≤ c ≤ 1000 ) guarantee pair x y mention twice input data output number — maximum possible euphony оf new character 's name first example euphony name <unknown> easy calculate euphony 36,['dp'],1800.0
73/D,vasya play freediv game manage a huge state n cities m two - way roads unfortunately every city reach one move along roads therefore vasya decide divide state provinces every province one could reach every city cities province roads provinces unlike turn - based strategies freediv a player opportunity build tunnel cities tunnel two - way roads along one move armies <unknown> enemy however one tunnel connect city vasya want build a network tunnel pair cities state reachable path consist roads a tunnel k tunnel connect province ( otherwise province difficult keep case provinces capture enemy armies ) vasya discover maybe able build a network current condition state maybe 'll first build several roads cities different provinces merge provinces task determine minimum number roads vasya need build possible build require network tunnel result state first line contain three integers n m k ( 1 ≤ n k ≤ 106 0 ≤ m ≤ 106 ) next m line contain two integers number cities connect a correspond road road connect city one road pair cities print a single number minimum number additional roads first example one province exist necessary build tunnel roads second example two provinces exist possible merge provinces build a tunnel cities 1 3 . third example least one additional road necessary example possible build additional road cities 1 2 build two tunnel cities 1 3 2 4,"['dfs and similar', 'graphs', 'greedy']",2200.0
730/A,a group n friends enjoy play popular video game <unknown> 2 . a rat system describe skill level player initially rat i - th friend ri friends decide take part championship a team equal rat allow compose a single team consist n friends friends face problem : make rat equal one way change rat <unknown> lose match friends form a party consist two five ( n ) friends play a match game party lose rat members decrease 1 . a rat ca n't become negative ri = 0 n't change lose friends take part multiple match time make a party subset friends ( remember constraints party size : 2 5 members ) friends want make rat equal high possible help friends develop a strategy lose match rat become equal result rat maximum possible first line contain a single integer n ( 2 ≤ n ≤ 100 ) — number friends second line contain n non - negative integers r1 r2 ... rn ( 0 ≤ ri ≤ 100 ) ri initial rat i - th friend first line print a single integer r — final rat friends second line print integer t — number match friends play follow t line contain n character ' 0 ' ' 1 ' j - th character i - th line equal : line contain two five character ' 1 ' inclusive value t exceed 104 guarantee solution exist remember n't minimize value t maximize r. multiple solutions print,"['greedy', 'implementation']",1800.0
730/J,"nick n bottle soda leave birthday bottle describe two value : remain amount soda ai bottle volume bi ( ai ≤ bi ) nick decide pour remain soda minimal number bottle moreover soon possible nick spend x second pour x units soda one bottle another nick ask help determine k — minimal number bottle store remain soda t — minimal time pour soda k bottle a bottle ca n't store soda volume remain soda save first line contain positive integer n ( 1 ≤ n ≤ 100 ) — number bottle second line contain n positive integers a1 a2 ... ( 1 ≤ ai ≤ 100 ) ai amount soda remain i - th bottle third line contain n positive integers b1 b2 ... bn ( 1 ≤ bi ≤ 100 ) bi volume i - th bottle guarantee ai ≤ bi i. line contain two integers k t k minimal number bottle store soda t minimal time pour soda k bottle first example nick pour soda first bottle second bottle take 3 second second bottle contain 3 + 3 = 6 units soda pour soda fourth bottle second bottle third bottle : one unit second two units third take 1 + 2 = 3 second , soda two bottle spend 3 + 3 = 6 second",['dp'],1900.0
732/C,"vasiliy spend vacation a sanatorium come back find completely forget detail vacation ! every day a breakfast a dinner a supper a din room sanatorium ( course order ) thing vasiliy a card din room <unknown> note many time a breakfast a dinner a supper ( thus card contain three integers ) vasiliy could sometimes miss meal example could a breakfast a supper a dinner , probably days n't din room vasiliy n't remember time day arrive sanatorium ( breakfast dinner supper supper ) time leave ( breakfast dinner supper supper ) consider options vasiliy arrive sanatorium time leave please note 's possible vasiliy leave sanatorium day arrive accord note card help vasiliy determine minimum number meals din room could miss n't count miss meals arrival day vasiliy 's arrival meals departure day leave line contain three integers b d s ( 0 ≤ b d s ≤ 1018 b + d + s ≥ 1 ) — number breakfast <unknown> <unknown> vasiliy vacation sanatorium print single integer — minimum possible number meals vasiliy could miss vacation first sample vasiliy could miss one supper example case arrive breakfast sanatorium two days ( include day arrival ) leave breakfast third day second sample vasiliy could arrive breakfast , immediately leave sanatorium miss meal third sample vasiliy could sanatorium one day miss meal","['binary search', 'greedy', 'implementation', 'math']",1200.0
734/A,anton like play chess friend danik play n game a row game 's know winner — anton danik none game end a tie anton wonder game danik ? help determine first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number game play second line contain a string s consist n uppercase english letter ' a ' 'd ' — outcome game i - th character string equal ' a ' anton i - th game 'd ' danik i - th game anton game danik print ` ` anton '' ( without quote ) line output danik game anton print ` ` danik '' ( without quote ) line output anton danik number game print ` ` friendship '' ( without quote ) first sample anton 6 game danik — 1 . hence answer ` ` anton '' second sample anton 3 game danik 4 game answer ` ` danik '' third sample anton danik 3 game answer ` ` friendship '',"['implementation', 'strings']",800.0
735/E,ostap already settle rio de <unknown> <unknown> start grow a tree garden recall a tree a connect undirected acyclic graph ostap 's tree n vertices want paint vertices tree black vertex u least one black vertex v distance k. distance two vertices tree minimum possible number edge path number ways paint tree large ostap want compute modulo 109 + 7 . two ways paint tree consider different exist a vertex paint black one way paint one first line input contain two integers n k ( 1 ≤ n ≤ 100 0 ≤ k ≤ min ( 20 n - 1 ) ) — number vertices ostap 's tree maximum allow distance nearest black vertex n't miss unusual constraint k. next n - 1 line contain two integers ui vi ( 1 ≤ ui vi ≤ n ) — indices vertices connect i - th edge 's guarantee give graph a tree print one integer — remainder division number ways paint tree 1 000 000 007 ( 109 + 7 ) first sample ostap paint vertices black second sample enough paint one two vertices thus answer 3 : ostap paint vertex 1 vertex 2 vertices 1 2 third sample valid ways paint vertices : { 1 3 } { 1 4 } { 2 3 } { 2 4 } { 1 2 3 } { 1 2 4 } { 1 3 4 } { 2 3 4 } { 1 2 3 4 },"['dp', 'trees']",2500.0
737/E,tanya five friends gather together celebrate birthday n children celebration include tanya celebration close end last plan attraction game machine m machine hall number 1 m. children a list machine want play moreover machine know exact time want play every machine one child play machine time even already every <unknown> want go home speed process additionally rent second copy machine rent second copy j - th machine pay pj burl rent a machine use long want long take make every child play accord plan a budget b burl rent additional machine ? one copy machine 's impossible rent a third machine type children interrupt game moment continue later i - th child want play j - th machine allow rent copy j - th machine child would play part time j - th machine part time copy ( part could empty ) <unknown> change take time perform integer moment time course a child ca n't play one machine time remember need save money ( one save money expense children happiness ! ) need minimize latest moment time child end game first line contain three integers n m b ( 1 ≤ n ≤ 40 1 ≤ m ≤ 10 0 ≤ b ≤ 106 ) — number children number game machine budget rent additional machine second line contain m integers p1 p2 ... pm ( 1 ≤ pj ≤ 106 ) pj rent price second copy j - th <unknown> line follow i - th describe wish i - th child line start integer ki ( 0 ≤ ki ≤ m ) — number machine i - th child want play ki pair line y - th xiy tiy mean i - th child want play tiy ( 1 ≤ tiy ≤ 2500 ) minutes xiy - th ( 1 ≤ xiy ≤ m ) machine n line value xiy distinct first line print minimum time children finish game second line print a string length m consist zero ones j - th character ' 1 ' copy j - th machine rat ' 0 ' otherwise third line print integer g ( 0 ≤ g ≤ 106 ) — total number time segment continuous play children g line print segment four integers i j s d mean i - th child play j - th machine copy time moment s ( s ≥ 0 ) d minutes ( d ≥ 1 ) print line arbitrary order multiple answer print,"['graphs', 'greedy']",3300.0
739/C,alyona build n tower put small cub top others cube size 1 × 1 × 1 . a tower a non - zero amount cub stand top tower next form a row sometimes alyona choose segment tower put top tower several cub formally <unknown> choose segment tower li ri add di cub top let sequence a1 a2 ... heights tower leave right let 's call a segment tower al al + 1 ... ar a hill follow condition hold : integer k ( l ≤ k ≤ r ) al < al + 1 < al + 2 < ... < ak > ak + 1 > ak + 2 > ... > ar addition di cub top tower li ri alyona want know maximum width among hill width a hill number tower first line contain single integer n ( 1 ≤ n ≤ 3·105 ) — number tower second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — number cub tower third line contain single integer m ( 1 ≤ m ≤ 3·105 ) — number additions next m line contain 3 integers i - th line contain integers li ri di ( 1 ≤ l ≤ r ≤ n 1 ≤ di ≤ 109 ) mean alyona put di cub <unknown> tower li ri print m line i - th line print maximum width hill i - th addition first sample follow : addition 2 cub top tower first third number cub tower become equal [ 7 7 7 5 5 ] hill maximum width [ 7 5 ] thus maximum width 2 . addition 1 cube second tower number cub tower become equal [ 7 8 7 5 5 ] hill maximum width [ 7 8 7 5 ] thus maximum width 4 . addition 1 cube fourth tower number cub tower become equal [ 7 8 7 6 5 ] hill maximum width [ 7 8 7 6 5 ] thus maximum width 5,['data structures'],2500.0
743/C,vladik chloe decide determine better math vladik claim positive integer n represent fraction a sum three distinct positive fraction form help vladik i.e a give n find three distinct positive integers x y z chloe ca n't check vladik 's answer number large ask print number exceed 109 . answer print -1 . single line contain single integer n ( 1 ≤ n ≤ 104 ) answer exist print 3 distinct number x y z ( 1 ≤ x y z ≤ 109 x ≠ y x ≠ z y ≠ z ) otherwise print -1 . multiple answer print,"['brute force', 'math', 'number theory']",1500.0
746/D,innokentiy like tea much today want drink exactly n cup tea would happy drink exactly n tea bag a green b black innokentiy n't like drink tea ( green black ) k time a row task determine order brew tea bag innokentiy able drink n cup tea without drink tea k time a row inform impossible tea bag use exactly first line contain four integers n k a b ( 1 ≤ k ≤ n ≤ 105 0 ≤ a b ≤ n ) — number cup tea innokentiy want drink maximum number cup tea drink a row number tea bag green black tea guarantee a + b = n. impossible drink n cup tea print ` ` '' ( without quote ) otherwise print string length n consist character ' g ' ' b ' character equal ' g ' correspond cup tea green character equal ' b ' correspond cup tea black multiple answer print,"['greedy', 'math']",1500.0
746/E,eugeny n card exactly one integer write eugeny want exchange card nikolay number even integers card would equal number odd integers number would distinct nikolay m card distinct number 1 m write one per card mean nikolay exactly one card number 1 exactly one card number 2 a single exchange a process eugeny give one card nikolay take another one nikolay task find minimum number card exchange determine card eugeny exchange first line contain two integers n m ( 2 ≤ n ≤ 2·105 1 ≤ m ≤ 109 ) — number card eugeny number card nikolay guarantee n even second line contain a sequence n positive integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — number eugeny 's card answer print -1 . otherwise first line print minimum number exchange second line print n integers — eugeny 's card exchange nikolay order card coincide card 's order input data i - th card n't exchange i - th number coincide number input data otherwise consider card exchange i - th number equal number card exchange multiple answer allow print,"['greedy', 'implementation', 'math']",1900.0
746/F,"sasha reach work car take exactly k minutes way listen music songs playlist go one one listen i - th song sasha get a pleasure equal ai i - th song last ti minutes begin way sasha turn song x listen songs one one : first song x song ( x + 1 ) song number ( x + 2 ) , listen songs reach work listen last song playlist sasha listen song end partly second case listen song integer number minutes least half song 's length formally length song equal d minutes sasha listen less minutes immediately switch next song ( ) example length song sasha want partly listen equal 5 minutes listen least 3 minutes length song equal 8 minutes listen least 4 minutes take time switch a song sasha want listen partly w songs last listen song play less half length sasha n't get pleasure song include list partly listen songs allow skip songs a pleasure a song depend listen mode i - th song value equal ai help sasha choose x w songs partial listen get maximum pleasure write a program find maximum pleasure sasha get listen songs way work first line contain three integers n w k ( 1 ≤ w ≤ n ≤ 2·105 1 ≤ k ≤ 2·109 ) — number songs playlist number songs sasha listen partly time minutes sasha need reach work second line contain n positive integers a1 a2 ... ( 1 ≤ ai ≤ 104 ) ai equal pleasure sasha get listen i - th song third line contain n positive integers t1 t2 ... tn ( 2 ≤ ti ≤ 104 ) ti equal length i - th song minutes print maximum pleasure sasha get listen songs way work first example sasha need start listen song number 2 . listen partly ( 4 minutes ) listen song number 3 end ( 3 minutes ) partly listen song number 4 ( 3 minutes ) listen songs sasha get pleasure equal 4 + 3 + 5 = 12 . sasha time listen song number 5 spend 4 + 3 + 3 = 10 minutes listen songs number 2 3 4 1 minute leave","['data structures', 'greedy', 'two pointers']",2200.0
747/E,"a rare article internet post without a possibility comment a polycarp 's website article comment fee comment polycarp 's website a non - empty string consist uppercase lowercase letter english alphabet comment tree - like structure mean comment except root comment ( comment highest level ) exactly one parent comment polycarp want save comment hard drive use follow format comment write follow format : example comment look like : first comment write ` ` hello,2 ok,0 bye,0 '' second write ` ` test,0 '' third comment write ` ` one,1 two,2 a,0 b,0 '' whole comment fee write : ` ` hello,2 ok,0 bye,0 test,0 one,1 two,2 a,0 b,0 '' a give comment fee format specify print comment a different format : first line contain non - empty comment fee describe format consist uppercase lowercase letter english alphabet digits commas guarantee comment a non - empty string consist uppercase lowercase english character number comment integer ( consist least one digit ) either equal 0 contain lead zero length whole string exceed 106 . guarantee give structure comment valid print comment a format give statement level nest comment print order give input first example explain statements","['dfs and similar', 'implementation', 'strings']",1700.0
750/B,problem assume earth a completely round ball surface a perfect sphere length equator <unknown> consider exactly 40 000 kilometers thus travel north pole south pole vice versa take exactly 20 000 kilometers limak a polar bear live north pole close new year help somebody deliver package around world instead coordinate place visit limak get a description move assume start north pole description consist n part i - th part journey limak move ti kilometers direction represent a string diri one : ` ` north '' ` ` south '' ` ` west '' ` ` east '' limak ’ t sure whether description valid must help check follow condition : check condition satisfy print ` ` yes '' ` ` '' a single line first line input contain a single integer n ( 1 ≤ n ≤ 50 ) i - th next n line contain integer ti a string diri ( 1 ≤ ti ≤ 106 ) — length direction i - th part journey accord description limak get print ` ` yes '' description satisfy three condition otherwise print ` ` '' without quote draw show limak 's journey would look like first two sample second sample answer ` ` '' n't end north pole,"['geometry', 'implementation']",1300.0
750/H,"pay attention output section see information flush output bearland a grid h row w columns row number 1 h top bottom columns number 1 w leave right every cell either allow ( denote ' . ' input ) permanently block ( denote ' # ' ) bearland a cold land heavy snow often make travel harder every day a allow cells temporarily block snow note block work particular day next day cells might allow ( unless another temporarily block ) 's possible move directly two cells share a side none permanently temporarily block limak a little polar bear live bearland house top leave cell school bottom right cell every day limak first go house school return back house since get bore easily n't want visit cell twice one day except cell house start end limak reach a school return home avoid revisit cells call a day interest q days must process one another days check 's interest print ` ` yes '' ` ` '' a separate line order able read description next day print answer previous one flush output 's guarantee a day cells temporarily block snow would interest 's also guarantee cells limak 's house school never block ( neither permanently temporarily ) first line input contain three integers h w q ( 2 ≤ h w ≤ 1000 1 ≤ q ≤ 10 000 ) — height width grid number days respectively next h line describe cells allow permanently block i - th line contain a string length w describe i - th row every character either ' . ' ( denote allow cell ) ' # ' ( denote a permanently block cell ) 's guarantee a day cells temporarily block snow would interest , description q days give description i - th day start a line contain a single integer ki ( 1 ≤ ki ≤ 10 ) — number cells temporarily block snow day next ki line contain two integers ri j ci j ( 1 ≤ ri j ≤ h 1 ≤ ci j ≤ w ) represent a cell intersection row ri j column ci j. give ki cells distinct none permanently block also none contain limak 's house school q days print ` ` yes '' day interest otherwise print ` ` '' without quote print answer print end - of - line character flush output proceed next day get idleness limit exceed n't print anything forget flush output flush use ( print a yes / no end - of - line ) : first sample 4 days draw show limak could go school return home second third day ( leave right respectively ) a permanently block cell paint red cells temporarily block snow paint orange black green arrows limak 's way school back house respectively second sample see grid look like day ' # ' denote a cell block either temporarily permanently","['dfs and similar', 'dsu', 'graphs']",3500.0
754/D,character hobbies true fedor enjoy shop neighbor supermarket goods supermarket unique integer ids also every integer a product i d equal integer fedor n discount coupons i - th use products ids range li ri inclusive today fedor want take exactly k coupons fedor want choose k coupons a way number products x coupons use product x large possible ( better understand see examples ) fedor want save time well ask choose coupons help fedor ! first line contain two integers n k ( 1 ≤ k ≤ n ≤ 3·105 ) — number coupons fedor number coupons want choose next n line contain two integers li ri ( - 109 ≤ li ≤ ri ≤ 109 ) — description i - th coupon coupons equal first line print single integer — maximum number products choose coupons use products least one coupon use n't count second line print k distinct integers p1 p2 ... pk ( 1 ≤ pi ≤ n ) — ids coupons fedor choose multiple answer print first example take first two coupons products ids range [ 40 70 ] buy coupons 31 products total second example product buy two coupons answer 0 . fedor choose two coupons example,"['binary search', 'data structures', 'greedy', 'sortings']",2100.0
755/G,polandball stand a row many ball precisely exactly n ball ball proud home land — want prove 's strong ball decide start select exactly m group ball consist either single ball two neighbor ball ball join one group ball really want impress enemies kindly ask calculate number divisions m 1 ≤ m ≤ k. output value modulo 998244353 enemies impress anyway exactly two number n k ( 1 ≤ n ≤ 109 1 ≤ k < 215 ) denote number ball <unknown> number group respectively output a sequence k value i - th represent seek number divisions exactly i group accord polandball 's rule first sample case divide ball group follow : { 1 } { 2 } { 3 } { 12 } { 23 } { 12 } { 3 } { 1 } { 23 } { 1 } { 2 } { 1 } { 3 } { 2 } { 3 } . { 1 } { 2 } { 3 } therefore output : 5 5 1,"['combinatorics', 'divide and conquer', 'dp', 'math', 'number theory']",3200.0
758/B,nothing eternal world kostya understand 7 - th january saw partially dead four - color garland a goal replace dead light bulbs however n't know many light bulbs color require guarantee four color least one light work know garland contain light bulbs four color : red blue yellow green garland make follow : take four consecutive light bulbs light bulbs color among example garland look like ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' look like ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' letter denote color : ' r ' — red ' b ' — blue ' y ' — yellow ' g ' — green use information color least one light bulb still work count number dead light bulbs four color first line contain string s ( 4 ≤ |s| ≤ 100 ) describe garland i - th symbol describe color i - th light bulb order begin garland : string s contain symbols except five describe guarantee give string least four letter ' r ' ' b ' ' y ' ' g ' guarantee string s correct garland blow light bulbs mean example line ` ` <unknown> ! ! ! b '' input data line print four integers kr <unknown> <unknown> kg — number dead light bulbs red blue yellow green color accordingly first example dead light bulbs second example obvious one blue bulb blow could light bulbs color place accord statements,"['brute force', 'implementation', 'number theory']",1100.0
758/D,alexander learn convert number decimal system however n't know english letter write number a decimal number mean instead letter a write number 10 . thus convert number 475 decimal hexadecimal system get <unknown> ( 475 = <unknown> + <unknown> + <unknown> ) alexander live calmly try convert number back decimal number system alexander remember work little number ask find minimum decimal number convert system base n get number k. first line contain integer n ( 2 ≤ n ≤ 109 ) second line contain integer k ( 0 ≤ k < <unknown> ) guarantee number k contain 60 symbols digits second line strictly less n. alexander guarantee answer exist exceed 1018 . number k n't contain lead zero print number x ( 0 ≤ x ≤ 1018 ) — answer problem first example 12 could obtain convert two number system base 13 : 12 = <unknown> 15 = <unknown> + <unknown>,"['dp', 'greedy', 'math', 'strings']",2000.0
761/B,run barriers circle track popular country dasha live wonder way class saw follow situation : track circle length l distinct point n barriers athlete always run track counterclockwise direction look barriers locate integer distance along track friends parrot kefa <unknown> sasha participate competitions run one lap friends start integral point track friends write distance start along track n barriers thus write n integers ascend order 0 l - 1 inclusively several track country length number barriers position barriers differ among different track dasha interest possible kefa sasha run track participate different track write program check kefa 's sasha 's track coincide ( mean one obtain change start position ) note always run track one direction — counterclockwise look a track first line contain two integers n l ( 1 ≤ n ≤ 50 n ≤ l ≤ 100 ) — number barriers a track length second line contain n distinct integers ascend order — distance kefa 's start barrier order appearance integers range 0 l - 1 inclusively second line contain n distinct integers ascend order — distance sasha 's start barrier order overcome integers range 0 l - 1 inclusively print ` ` yes '' ( without quote ) kefa sasha run coincide track ( mean position barriers coincide start run point track ) otherwise print ` ` '' ( without quote ) first test analyze statement,"['brute force', 'implementation', 'math']",1300.0
762/B,"due increase number students berland state university decide equip a new computer room give task buy mouse spend little possible , country crisis ! computers buy room different usb port — ps/2 port options find a price list a certain computer shop , m mouse specify cost type port require plug mouse ( usb ps/2 ) mouse list buy want buy set mouse give price list a way maximize number computers equip mouse ( guarantee able equip computers ) case equality value want minimize total cost mouse buy first line contain three integers a b c ( 0 ≤ a b c ≤ 105 ) — number computers usb port number computers ps/2 port number computers options respectively next line contain one integer m ( 0 ≤ m ≤ 3·105 ) — number mouse price list next m line describe another mouse i - th line contain first integer vali ( 1 ≤ vali ≤ 109 ) — cost i - th mouse type port ( usb ps/2 ) require plug mouse output two integers separate space — number equip computers total cost mouse buy first example buy first three mouse way equip one computers a usb port a usb mouse two ps/2 mouse plug computer ps/2 port computer port","['greedy', 'implementation', 'sortings', 'two pointers']",1400.0
762/C,give two string a b. remove minimum possible number consecutive ( stand one another ) character string b a way become a subsequence string a. happen need remove character maybe remove character b make empty subsequence string s string obtain erase zero character ( necessarily consecutive ) string s. first line contain string a second line — string b. string nonempty consist lowercase letter english alphabet length string bigger 105 character first line output a subsequence string a obtain b erase minimum number consecutive character answer consist zero character output « - » ( a minus sign ) first example string a b n't share symbols longest string get empty second example ac a subsequence a time obtain erase consecutive symbols <unknown> string b,"['binary search', 'strings', 'two pointers']",2100.0
763/A,new year timofey friends cut a tree n vertices bring home paint n vertices i - th vertex get color ci 's time timofey birthday mother ask remove tree timofey remove tree follow way : take vertex hand vertices move tree become root choose vertex timofey bring tree a trash timofey n't like many color mix together a subtree annoy vertices different color timofey want find a vertex take hand subtrees annoy n't consider whole tree a subtree since ca n't see color root vertex a subtree vertex a subgraph contain vertex descendants task determine a vertex take hand timofey would n't annoy first line contain single integer n ( 2 ≤ n ≤ 105 ) — number vertices tree next n - 1 line contain two integers u v ( 1 ≤ u v ≤ n u ≠ v ) denote edge vertices u v. guarantee give graph a tree next line contain n integers c1 c2 ... cn ( 1 ≤ ci ≤ 105 ) denote color vertices print ` ` '' a single line timofey ca n't take tree a way n't annoy otherwise print ` ` yes '' first line second line print index vertex timofey take hand multiple answer print,"['dfs and similar', 'dp', 'dsu', 'graphs', 'implementation', 'trees']",1600.0
763/B,one timofey 's birthday present a <unknown> a shape infinite plane plane n rectangles side parallel coordinate ax situate side rectangles odd length rectangles intersect touch help timofey color rectangles 4 different color a way every two rectangles touch side would different color determine impossible two rectangles intersect intersection positive area two rectangles touch side a pair side intersection non - zero <unknown> first line contain single integer n ( 1 ≤ n ≤ 5·105 ) — number <unknown> line follow i - th line contain four integers x1 y1 x2 y2 ( - 109 ≤ x1 < x2 ≤ 109 - 109 ≤ y1 < y2 ≤ 109 ) mean point ( x1 y1 ) ( x2 y2 ) coordinate two opposite corner i - th rectangle guarantee side rectangles odd lengths rectangles n't intersect print ` ` '' line impossible color rectangles 4 different color a way every two rectangles touch side would different color otherwise print ` ` yes '' first line print n line i - th print single integer ci ( 1 ≤ ci ≤ 4 ) — color i - th rectangle,['geometry'],2100.0
765/B,"kostya like codeforces contest much however disappoint solutions frequently hack 's decide obfuscate ( intentionally make less readable ) code upcoming contest obfuscate code kostya first look first variable name use program replace occurrences a single symbol a look second variable name replace yet replace occurrences b , kostya well - <unknown> n't use one - letter name obfuscation moreover 26 unique identifiers program give a list identifiers program remove space line break check program a result kostya 's obfuscation line input a string s lowercase english letter ( 1 ≤ |s| ≤ 500 ) — identifiers a program remove whitespace character program a result kostya 's obfuscation print ` ` yes '' ( without quote ) otherwise print ` ` '' first sample case one possible list identifiers would ` ` number string number character number string number '' kostya would obfuscate program :","['greedy', 'implementation', 'strings']",1100.0
766/E,mahmoud ehab live a country n cities number 1 n connect n - 1 undirected roads 's guarantee reach city use roads city a number ai attach define distance city x city y xor number attach cities path x y ( include x y ) word value attach cities path x y form array p length l distance bitwise xor operation mahmoud ehab want choose two cities make a journey one another index start city always less equal index finish city ( may start finish city case distance equal number attach city ) ca n't determine two cities try every city a start every city greater index a finish want know total distance pair cities first line contain integer n ( 1 ≤ n ≤ 105 ) — number cities mahmoud ehab 's country second line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 106 ) represent number attach cities integer ai attach city i. next n - 1 line contain two integers u v ( 1 ≤ u v ≤ n u ≠ v ) denote undirected road cities u v. 's guarantee reach city use roads output one number denote total distance pair cities a bitwise xor take two bite integers equal length perform logical xor operation pair correspond bits result position 1 first bite 1 second bite 1 0 0 1 . read bitwise xor operation : https : //en.wikipedia.org / wiki / bitwise_operation # xor first sample available paths :,"['bitmasks', 'data structures', 'dfs and similar', 'dp', 'math', 'trees']",2100.0
767/A,"accord old <unknown> a long time ago ankh - morpork residents something wrong miss fortune curse say time n snack distinct size fall city residents build a snacktower place snack one another course big snack bottom tower small snack top years pass different snack start fall onto city residents begin build snacktower however face trouble day exactly one snack fell onto city order strange , days residents n't able put new stack top snacktower : wait bigger snack fell course order anger miss fortune residents place snack top tower immediately could write a program model behavior ankh - morpork residents first line contain single integer n ( 1 ≤ n ≤ 100 000 ) — total number snack second line contain n integers i - th equal size snack fell i - th day size distinct integers 1 n. print n line i - th print size snack residents place top snacktower i - th day order snack place day leave correspond line empty example a snack size 3 fell first day residents immediately place second day a snack size 1 fell residents n't able place miss snack size 2 . third day a snack size 2 fell residents immediately place right place snack size 1 fall","['data structures', 'implementation']",1100.0
767/D,olya like milk much drink k cartons milk day least k drink n't 's issue — expiration date carton a date ca n't drink ( still drink exactly date write carton ) due olya 's fridge contain a carton past expiry date throw away olya hat throw cartons drink a carton choose one expire fastest 's easy understand strategy minimize amount cartons throw let avoid 's even possible main issue olya one buy new cartons currently n cartons milk olya 's fridge one expiration date know ( soon expire measure days ) shop olya visit m cartons expiration date know cartons well find maximum number cartons olya buy would n't throw away cartons assume olya drink cartons today first line three integers n m k ( 1 ≤ n m ≤ 106 1 ≤ k ≤ n + m ) — amount cartons olya 's fridge amount cartons shop number cartons olya drink day second line n integers f1 f2 ... fn ( 0 ≤ fi ≤ 107 ) — expiration date cartons olya 's fridge expiration date express number days drink carton delay example a 0 expiration date mean must drink today 1 — later tomorrow etc third line m integers s1 s2 ... sm ( 0 ≤ si ≤ 107 ) — expiration date cartons shop a similar format 's way olya drink cartons already fridge print -1 . otherwise first line print maximum number x cartons olya buy would n't throw a carton away next line contain exactly x integers — number cartons buy ( cartons number order write input start 1 ) number repeat arbitrary order multiple correct answer print first example k = 2 olya three cartons expiry date 0 1 1 ( expire today tomorrow tomorrow ) shop 3 cartons expiry date 0 3 cartons expiry date 2 . olya buy three cartons example one expiry date 0 two expiry date 2 . second example three cartons olya own expire today mean would throw packets away regardless whether buy extra one third example olya would drink k = 2 cartons today ( one <unknown> fridge one shop ) remain one tomorrow,"['binary search', 'data structures', 'greedy', 'sortings', 'two pointers']",2100.0
769/C,"robot a rectangular maze size n × m. cell maze either empty occupy obstacle robot move neighbor cells side leave ( symbol ` ` l '' ) right ( symbol ` ` r '' ) ( symbol ` ` u '' ) ( symbol ` ` d '' ) robot move cell empty initially robot empty cell task find lexicographically minimal robot 's cycle length exactly k begin end cell robot initially allow robot visit cell many time ( include start ) consider robot 's way give a line consist symbols ` ` l '' ` ` r '' ` ` u '' ` ` d '' example firstly robot go leave right mean way write ` ` <unknown> '' task n't need minimize length way find minimum lexicographical ( alphabet order dictionary ) line satisfy requirements first line contain three integers n m k ( 1 ≤ n m ≤ 1000 1 ≤ k ≤ 106 ) — size maze length cycle follow n line contain m symbols — description maze symbol equal ` ` . '' current cell empty symbol equal ` ` * '' current cell occupy obstacle symbol equal ` ` x '' initially robot cell empty guarantee symbol ` ` x '' find maze exactly print lexicographically minimum robot 's way length exactly k start end cell initially robot way print ` ` impossible '' ( without quote ) first sample two cyclic ways robot length 2 exist — ` ` ud '' ` ` rl '' second cycle lexicographically less second sample robot move follow way : leave , leave leave leave right right right , right , third sample robot ca n't move neighbor cells occupy obstacles","['dfs and similar', 'graphs', 'greedy', 'shortest paths']",1700.0
77/B,reason many american cartoon anvils fall time time onto heroes ' head course safes <unknown> <unknown> plan fall sometimes ... anvils anvils come different size shape quite often get hero stick deep grind ever think throw anvils sky ? height ? sure question never trouble ! turn throw anvil properly easy task let 's describe one popular anvil throw model let height p potential victim vary range [ 0 ; a ] direction wind q vary range [ - b ; b ] p q could real ( float ) number assume anvil fit <unknown> 's head perfectly follow equation least one real root : determine probability aim successfully hit anvil assume p q coefficients choose equiprobably independently range first line contain integer t ( 1 ≤ t ≤ 10000 ) — amount testcases follow t line contain two space - separated integers a b ( 0 ≤ a b ≤ 106 ) pretests contain test 0 < a < 10 0 ≤ b < 10 . print t line — probability a successful anvil hit testcase absolute relative error answer exceed 10 - 6,['math'],1800.0
771/A,bear limak examine a social network main functionality two members become friends ( talk share funny picture ) n members number 1 n. m pair members friends course a member ca n't a friend let a - b denote members a b friends limak think a network reasonable follow condition satisfy : every three distinct members ( x y z ) x - y y - z also x - z example : alan bob friends bob ciri friends alan ciri friends well help limak check network reasonable ? print ` ` yes '' ` ` '' accordingly without quote first line input contain two integers n m ( 3 ≤ n ≤ 150 000 ) — number members number pair members friends i - th next m line contain two distinct integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) members ai bi friends pair members appear input give network reasonable print ` ` yes '' a single line ( without quote ) otherwise print ` ` '' a single line ( without quote ) draw show situation first sample ( leave ) second sample ( right ) edge represent two members friends answer ` ` '' second sample members ( 2 3 ) friends members ( 3 4 ) friends members ( 2 4 ),"['dfs and similar', 'dsu', 'graphs']",1500.0
772/C,give integer m a list n distinct integers 0 m - 1 . would like construct a sequence satisfy properties : construct sequence satisfy properties first line input contain two integers n m ( 0 ≤ n < m ≤ 200 000 ) — number forbid prefix products modulus n non - zero next line input contain n distinct integers 0 m - 1 forbid prefix products n zero line n't exist first line print number k denote length sequence second line print k space separate integers denote sequence first case prefix products sequence modulo m [ 1 2 3 4 0 ] second case prefix products sequence modulo m [ 3 7 4 6 8 0 ],"['dp', 'graphs', 'math', 'number theory']",2300.0
773/D,country never n cities a well - developed road system exactly one bidirectional road every pair cities thus many roads ! two roads intersect road pass intermediate cities art build tunnel bridge master neverians independent committee evaluate road never a positive integer call perishability road lower road 's perishability pleasant drive road 's year transport never decide build a museum transport one cities set a single signpost direct city ( necessarily one museum ) cities signpost must satisfy follow important condition : neverian live a city without museum start travel city follow directions signpost person eventually arrive city museum neverians incredibly positive - minded a neverian travel a route consist several roads consider perishability route equal smallest perishability roads route government never yet decide build museum consider n possible options important sum perishabilities rout museum city cities never travelers strictly follow directions signpost government never care citizens want set signpost a way minimize sum help determine minimum possible sum n possible options city museum build first line contain a single integer n ( 2 ≤ n ≤ 2000 ) — number cities never follow n - 1 line contain description road network i - th line contain n - i integers j - th integer i - th line denote perishability road cities i i + j. road perishabilities 1 109 inclusive city order 1 n output minimum possible sum perishabilities rout city cities never signpost set a way minimize sum first example explain picture leave right initial road network optimal directions signpost case museum build city 1 2 3 respectively museum city represent a blue circle directions signpost represent green arrows instance museum build city 3 signpost city 1 must direct city 3 signpost city 2 must direct city 1 . route city 1 city 3 perishability 2 route city 2 city 3 perishability 1 . sum perishabilities rout 3,"['dp', 'graphs', 'shortest paths']",2700.0
773/F,"test data generation easy task ! often generate big random test case enough ensure thorough test solutions correctness example consider a problem old codeforces round input format look roughly follow : first line contain a single integer n ( 1 ≤ n ≤ maxn ) — size set second line contain n distinct integers a1 a2 ... ( 1 ≤ ai ≤ maxa ) — elements set increase order n't pay attention problem solution look fairly easy generate a good test case problem let n = maxn take random distinct ai 1 maxa sort ... soon understand 's easy actual problem solution let g greatest common divisor a1 a2 ... , let x = / g - n. correct solution output ` ` alice '' x odd ` ` bob '' x even consider two wrong solutions problem differ correct one formula calculate x. first wrong solution calculate x x = / g ( without subtract n ) second wrong solution calculate x x = - n ( without divide g ) a test case interest make wrong solutions output incorrect answer give maxn maxa q find number interest test case satisfy constraints output modulo q. line contain three integers maxn maxa q ( 1 ≤ maxn ≤ 30 000 ; maxn ≤ maxa ≤ 109 ; 104 ≤ q ≤ 105 + 129 ) output a single integer — number test case satisfy constraints make wrong solutions output incorrect answer modulo q. first example interest test case look follow :","['combinatorics', 'divide and conquer', 'dp', 'math', 'number theory']",3400.0
776/A,"beloved detective sherlock currently try catch a serial killer kill a person day use power deduction come know killer a strategy select next victim killer start two potential victims first day select one two kill select victim replace a new person repeat procedure day way day two potential victims choose sherlock know initial two potential victims also know murder happen a particular day new person replace victim need help get pair potential victims day sherlock observe pattern first line input contain two name ( length n't exceed 10 ) two initial potential victims next line contain integer n ( 1 ≤ n ≤ 1000 ) number days next n line contain two name ( length n't exceed 10 ) first person murder day second one replace person input format consistent , a person murder guarantee two potential victims time also name guarantee distinct consist lowercase english letter output n + 1 line i - th line contain two persons killer select i - th murder ( n + 1 ) -th line contain two persons next victim select line two name print order first example killer start <unknown> <unknown>","['brute force', 'implementation', 'strings']",900.0
776/D,"moriarty trap n people n distinct room a hotel room lock others unlock , a condition people hotel escape doors unlock time m switch switch control doors room door control exactly two switch give initial configuration doors toggle switch , turn turn toggle condition doors switch control say toggle switch 1 connect room 1 2 3 respectively lock unlock unlock , toggle switch become unlock lock lock need tell sherlock exist a way unlock doors time first line input contain two integers n m ( 2 ≤ n ≤ 105 2 ≤ m ≤ 105 ) — number room number switch next line contain n space - separated integers r1 r2 ... rn ( 0 ≤ ri ≤ 1 ) tell status room doors i - th room lock ri = 0 otherwise unlock i - th next m line contain integer xi ( 0 ≤ xi ≤ n ) follow xi distinct integers separate space denote number room control i - th switch follow room number switch control guarantee room number range 1 n. guarantee door control exactly two switch output ` ` yes '' without quote possible open doors time otherwise output ` ` '' without quote second example input initial <unknown> doors [ 1 0 1 ] ( 0 mean lock 1 — unlock ) toggle switch 3 get [ 0 0 0 ] mean doors lock , toggle switch 1 get [ 1 1 1 ] mean doors unlock see first third example input possible make doors unlock","['dfs and similar', 'dsu', 'graphs']",2000.0
776/F,"sherlock meet moriarty a final battle wits give a regular n side convex polygon addition give certain diagonals form regions polygon guarantee diagonals intersect interior point take region calculate importance value importance value a region form vertices a1 a2 ... ax polygon give 2a1 + 2a2 + ... + <unknown> , sort regions basis importance value ascend order assign region index 1 k k number regions index region position sort array calculate want moriarty color regions use 20 color two regions color simple paths two regions least one region color value less color value assign regions simple path two regions f h a sequence regions r1 r2 ... rt r1 = f rt = h 1 ≤ i < t regions ri ri + 1 share edge ri = rj i = j. moriarty could n't answer ask sherlock solve help sherlock first line contain two integers n m ( 3 ≤ n ≤ 100000 0 ≤ m ≤ n - 3 ) number vertices polygon number diagonals add next m line contain two integers a b ( 1 ≤ a b ≤ n ) describe a diagonal vertices a b. guarantee diagonals correct i. e. a b n't coincide neighbor guarantee diagonals intersect let number regions k. output k space - separated integers 1 20 represent color regions order increase importance multiple answer print show least one answer exist 2nd input regions form order sort ( 1 2 3 ) ( 1 3 4 ) ( 1 4 5 ) ( 1 5 6 ) i.e region ( 1 2 3 ) first region follow region ( 1 3 4 ) , color regions 1 3 color region number 2 path 1 3 color 1 less color 1 3 i.e. color number 2","['data structures', 'divide and conquer', 'geometry', 'graphs', 'implementation', 'trees']",2800.0
778/B,"bob recently read bitwise operations use computers : xor study properties invent a new game initially bob choose integer m bite depth game mean number game consist m bits ask peter choose m - bit number , bob compute value n variables variable assign either a constant m - bit number result bitwise operation operands operation may either variables define number choose peter , peter 's score equal sum variable value bob want know number peter need choose get minimum possible score number need choose get maximum possible score case several ways get score find minimum number choose first line contain two integers n m number variables bite depth respectively ( 1 ≤ n ≤ 5000 ; 1 ≤ m ≤ 1000 ) follow n line contain descriptions variables line describe exactly one variable description follow format : name a new variable space sign ` ` : = '' space follow one : variable name string consist lowercase latin letter length 10 . variable name different first line output minimum number choose peter make sum variable value minimum possible second line output minimum number choose peter make sum variable value maximum possible number print m - bit binary number first sample peter choose a number 0112 a = 1012 b = 0112 c = 0002 sum value 8 . choose number <unknown> a = 1012 b = 0112 c = 1112 sum value 15 . second test minimum maximum sum variables a bb cx d e 2 sum n't depend number choose peter minimum peter choose 0","['bitmasks', 'brute force', 'dfs and similar', 'implementation']",1800.0
778/C,peterson love learn new languages favorite hobby make new ones language a set word word a sequence lowercase latin letter peterson make new language every morning difficult task store whole language peterson invent new data structure store languages call broom broom root tree edge mark letter initially broom represent vertex — root broom peterson want add new word language stand root process letter new word one one consider peterson stand vertex u. edge u mark current letter peterson go edge otherwise peterson add new edge u new vertex v mark current letter go new edge size broom number vertices even work day peterson ca n't understand language make morning difficult bore peterson try make simpler simplification language process erase letter word language formally peterson take positive integer p erase p - th letter word language length least p. letter word index start 1 . peterson consider simplification change least one word i.e least one word length least p. peterson try make language simple possible want choose p size broom simplify language small possible peterson pretty annoy task ask help write a program find smallest possible size broom integer p. first line input contain integer n ( 2 ≤ n ≤ 3·105 ) — size broom next n - 1 line describe broom : i - th contain integers ui vi letter xi — describe edge ui vi mark letter xi vertices number 1 n. xi lowercase latin letter vertex 1 root broom edge describe correct broom make peterson 's language first line output contain minimum possible size broom simplification second line output contain integer p choose several suitable p value print smallest one broom second sample test build use language ` ` piece '' ` ` '' ` ` pie '' ` ` pretty '' ` ` prefix '' simplification p = 2 obtain language word ` ` <unknown> '' ` ` o '' ` ` pe '' ` ` petty '' ` ` <unknown> '' language give us broom minimum possible size,"['brute force', 'dfs and similar', 'dsu', 'strings', 'trees']",2500.0
784/C,expect find ? base and / xor language include string ? n't byte <unknown> distort largest mathematics <unknown> ` ` abracadabra '' without a magic wo n't <unknown> last stack <unknown> die oh <unknown> ! i array i must <unknown> may store west <unknown> first line input data contain a single integer n ( 1 ≤ n ≤ 10 ) second line input data contain n space - separated integers ai ( 1 ≤ ai ≤ 11 ) output a single integer,['implementation'],1800.0
785/E,anton like permutations especially like permute elements note a permutation n elements a sequence number { a1 a2 ... } every number 1 n appear exactly one day anton get a new permutation start play follow operation q time : take two elements permutation swap elements operation ask friend vanya many inversions new permutation number inversions a permutation number distinct pair ( i j ) 1 ≤ i < j ≤ n ai > aj vanya tire answer anton 's silly question ask write a program would answer question instead initially anton 's permutation { 1 2 ... n } ai = i i 1 ≤ i ≤ n. first line input contain two integers n q ( 1 ≤ n ≤ 200 000 1 ≤ q ≤ 50 000 ) — length permutation number operations anton follow q line input contain two integers li ri ( 1 ≤ li ri ≤ n ) — indices elements anton swap i - th operation note indices elements anton swap i - th operation coincide elements permutation number start one output q line i - th line output number inversions anton 's permutation i - th operation consider first sample first anton 's operation permutation { 1 2 3 5 4 } one inversion : ( 4 5 ) second anton 's operation permutation { 1 5 3 2 4 } four inversions : ( 2 3 ) ( 2 4 ) ( 2 5 ) ( 3 4 ) third anton 's operation permutation { 1 4 3 2 5 } three inversions : ( 2 3 ) ( 2 4 ) ( 3 4 ) fourth anton 's operation permutation n't change still three inversions,"['brute force', 'data structures']",2200.0
786/A,"rick morty play version berzerk ( nothing common famous berzerk game ) game need a huge space play a computer game n object number 1 n arrange a circle ( clockwise order ) object number 1 a black hole others planets 's a monster one planet rick morty n't know one yet 's initially black hole unity inform game start , want prepare every possible scenario one a set number 1 n - 1 ( inclusive ) rick 's set s1 k1 elements morty 's s2 k2 elements one go first player change alternatively player 's turn choose arbitrary number like x set monster move x - th next object current position ( clockwise ) move monster get black hole win task monster 's initial position play first determine <unknown> win lose game stick infinite loop case player lose make game infinity profitable choose infinity game first line input contain a single integer n ( 2 ≤ n ≤ 7000 ) — number object game second line contain integer k1 follow k1 distinct integers s1 1 s1 2 ... s1 k1 — rick 's set third line contain integer k2 follow k2 distinct integers s2 1 s2 2 ... s2 k2 — morty 's <unknown> ≤ ki ≤ n - 1 1 ≤ si 1 si 2 ... si ki ≤ n - 1 1 ≤ i ≤ 2 . first line print n - 1 word separate space i - th word ` ` win '' ( without quotations ) scenario rick play first monster initially object number i + 1 win ` ` lose '' lose ` ` loop '' game never end similarly second line print n - 1 word separate space i - th word ` ` win '' ( without quotations ) scenario morty play first monster initially object number i + 1 win ` ` lose '' lose ` ` loop '' game never end","['dfs and similar', 'dp']",2000.0
786/B,rick co - workers make a new <unknown> formula a lot bad guy rick want give <unknown> morty bad guy catch n planets universe number 1 n. rick planet number s ( earth ) n't know morty know rick own a portal gun gun open one - way portal a planet planet ( include planet ) limit gun 's still use free trial default open portal gun q plan website sell gun every time purchase a plan use purchase want use plan website three type : rick n't know morty unity go inform want prepare find start journey immediately planet ( include earth ) want know minimum amount money need get earth planet first line input contain three integers n q s ( 1 ≤ n q ≤ 105 1 ≤ s ≤ n ) — number planets number plan index earth respectively next q line contain plan line start a number t type plan ( 1 ≤ t ≤ 3 ) t = 1 follow three integers v u w w cost plan ( 1 ≤ v u ≤ n 1 ≤ w ≤ 109 ) otherwise follow four integers v l r w w cost plan ( 1 ≤ v ≤ n 1 ≤ l ≤ r ≤ n 1 ≤ w ≤ 109 ) first line output print n integers separate space i - th minimum money get earth i - th planet - 1 's impossible get planet first sample testcase rick purchase 4th plan 2nd plan order get get planet number 2,"['data structures', 'graphs', 'shortest paths']",2300.0
787/B,"since giant head appear sky humanity danger rick mortys parallel universes gather group find a solution get rid n parallel universes participate event ( n rick n mortys ) i. e. n universes one rick one morty 're gather m group person many group a group contain arbitrary number members rick mortys register online group , a person join a group ( developer website n't consider possibility ) summer universe # 1 know parallel universe ( include ) exactly one rick morty universe a traitor loyal one know one know doom 's a group every member group a traitor ( plan destroy world ) summer know 's a possibility world end ( 's a group members traitors ) immediately cancel event want know cancel event tell yes 's least one scenario ( among 2n possible scenarios 2 possible scenarios a traitor universe ) scenario world end first line input contain two integers n m ( 1 ≤ n m ≤ 104 ) — number universes number group respectively next m line contain information group i - th first contain integer k ( number time someone join i - th group k > 0 ) follow k integers vi 1 vi 2 ... vi k. vi j negative mean rick universe number - vi j join group otherwise mean morty universe number vi j join sum k group exceed 104 . a single line print answer summer 's question print ` ` yes '' cancel event ` ` '' otherwise first sample testcase 1st group contain rick universe number 3 case 's a traitor members group traitors summer cancel event","['greedy', 'implementation', 'math']",1300.0
791/A,bear limak want become largest bear least become larger brother bob right limak bob weigh a b respectively 's guarantee limak 's weight smaller equal brother 's weight limak eat a lot weight triple every year bob 's weight double every year many full years limak become strictly larger ( strictly <unknown> ) bob ? line input contain two integers a b ( 1 ≤ a ≤ b ≤ 10 ) — weight limak weight bob respectively print one integer denote integer number years limak become strictly larger bob first sample limak weigh 4 bob weigh 7 initially one year weight 4·3 = 12 7·2 = 14 respectively ( one weight triple one double ) limak n't larger bob yet second year weight 36 28 first weight greater second one limak become larger bob two years print 2 . second sample limak 's bob 's weight next years : 12 18 36 36 finally 108 72 ( three years ) answer 3 . remember limak want larger bob wo n't satisfy equal weight third sample limak become larger bob first year weight 3 2,['implementation'],800.0
793/C,"igor analyst fell asleep work a strange dream dream desk crowd computer mice buy a mousetrap catch desk consider infinite plane mousetrap a rectangle side parallel ax opposite side locate point ( x1 y1 ) ( x2 y2 ) igor want catch mice igor analyse behavior discover mouse move along a straight line constant speed speed i - th mouse equal ( vix viy ) mean x coordinate mouse increase vix units per second y coordinate increase viy units mousetrap open initially mice able move freely desk igor close mousetrap moment catch mice strictly inside mousetrap igor work a lot busy dream well ask write a program give mousetrap 's coordinate initial coordinate mice speed determine earliest time moment able catch mice please note igor close mousetrap first line contain single integer n ( 1 ≤ n ≤ 100 000 ) — number computer mice desk second line contain four integers x1 y1 x2 y2 ( 0 ≤ x1 ≤ x2 ≤ 100 000 ) ( 0 ≤ y1 ≤ y2 ≤ 100 000 ) — coordinate opposite corner mousetrap next n line contain information mice i - th line contain four integers rix riy vix viy ( 0 ≤ rix riy ≤ 100 000 - 100 000 ≤ vix viy ≤ 100 000 ) ( rix riy ) initial position mouse ( vix viy ) speed line print minimum possible non - negative number t igor close mousetrap t second begin mice strictly inside mousetrap t print -1 . answer consider correct absolute relative error n't exceed 10 - 6 . formally let answer a jury 's answer b. answer consider correct a picture first samplepoints a b c d - start mice position segment paths , first time mice rectangle look like : a picture second samplepoints a d b never enter rectangle","['geometry', 'implementation', 'math', 'sortings']",2300.0
794/D,"oleg bank client live bankopolia n cities bankopolia pair cities connect directly bi - directional roads cities number 1 n. a total m roads bankopolia i - th road connect cities ui vi guarantee city possible travel city use roads oleg want give a label city suppose label city i equal xi , must hold pair cities ( u v ) condition |xu - xv| ≤ 1 hold a road connect u v. oleg wonder a label possible find example label task possible state impossible otherwise first line input contain two space - separated integers n m ( 2 ≤ n ≤ 3·105 1 ≤ m ≤ 3·105 ) — number cities number roads next m line follow i - th line contain two space - separated integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) — cities connect i - th road guarantee one road pair cities possible travel city city use roads require label possible output a single line contain string ` ` '' ( without quote ) otherwise output string ` ` yes '' ( without quote ) first line next line output n space - separated integers x1 x2 ... xn condition 1 ≤ xi ≤ 109 must hold i pair cities ( u v ) condition |xu - xv| ≤ 1 must hold a road connect u v. first sample x1 = 2 x2 = 3 x3 = x4 = 1 a valid label indeed ( 3 4 ) ( 1 2 ) ( 1 3 ) ( 1 4 ) pair cities difference label greater 1 precisely roads bankopolia second sample pair cities difference label greater 1 pair cities a road connect last sample impossible construct a label satisfy give constraints","['dfs and similar', 'graphs']",2400.0
797/D,let t arbitrary binary tree — tree every vertex two children give tree root exist one vertex n't a parent — 's root a tree every vertex integer number write follow algorithm run every value tree t : pseudo - code describe algorithm : describe algorithm work correctly tree binary search tree ( i.e node value leave subtree less value node value right subtree greater value node ) return invalid result tree a binary search tree since give tree necessarily a binary search tree number find way task calculate many time search fail run every value tree tree multiple vertices value run algorithm every one separately first line contain integer number n ( 1 ≤ n ≤ 105 ) — number vertices tree next n line contain 3 number v l r ( 0 ≤ v ≤ 109 ) — value current vertex index leave child vertex index right child vertex respectively child n't exist number - 1 set instead note different vertices tree may contain value print number time search algorithm fail example root tree vertex 2 . search number 5 15 return fail first step algorithm choose subtree n't contain number look,"['data structures', 'dfs and similar']",2100.0
797/E,a array n positive integers greater n. process q query array query represent two number p k. several operations perform query ; operation change p p + ap + k. operations apply p become greater n. answer query number perform operations first line contain one integer n ( 1 ≤ n ≤ 100000 ) second line contain n integers — elements a ( 1 ≤ ai ≤ n i 1 n ) third line containts one integer q ( 1 ≤ q ≤ 100000 ) q line follow line contain value p k correspond query ( 1 ≤ p k ≤ n ) print q integers ith integer must equal answer ith query consider first example : first query first operation p = 3 second operation p = 5 . next two query p greater n first operation,"['brute force', 'data structures', 'dp']",2000.0
798/B,mike n string s1 s2 ... sn consist lowercase english letter one move choose a string si erase first character append end string example string ` ` <unknown> '' one move transform string ` ` <unknown> '' mike ask : minimal number move need order make string equal ? first line contain integer n ( 1 ≤ n ≤ 50 ) — number string follow n line contain a string i - th line correspond string si lengths string equal lengths string positive n't exceed 50 . print minimal number move mike need order make string equal print - 1 solution first sample testcase optimal scenario perform operations a way transform string ` ` <unknown> '',"['brute force', 'dp', 'strings']",1300.0
798/C,mike a sequence a = [ a1 a2 ... ] length n. consider sequence b = [ b1 b2 ... bn ] beautiful gcd elements bigger 1 i.e   mike want change sequence order make beautiful one move choose index i ( 1 ≤ i < n ) delete number ai ai + 1 put number ai - ai + 1 ai + ai + 1 place instead order want perform operations possible find minimal number operations make sequence a beautiful 's possible tell impossible biggest non - negative number d d divide bi every i ( 1 ≤ i ≤ n ) first line contain a single integer n ( 2 ≤ n ≤ 100 000 ) — length sequence a. second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — elements sequence a. output first line ` ` yes '' ( without quote ) possible make sequence a beautiful perform operations describe ` ` '' ( without quote ) otherwise answer ` ` yes '' output minimal number move need make sequence a beautiful first example simply make one move obtain sequence [ 0 2 ] second example gcd sequence already greater 1,"['dp', 'greedy', 'number theory']",1700.0
802/A,"search heidi – finally find a library dress a human fact spend much time run place ! job buy book keep library people borrow read n different book number 1 n. look library 's operation n consecutive days heidi know advance i - th day ( 1 ≤ i ≤ n ) precisely one person come library request borrow book ai read a hours return book later day heidi desperately want please guests make sure always book ai available library i - th day night i - th day option go bookstore ( operate nights avoid competition library ) buy book price 1 chf course already a book library need buy initially library contain book a problem though capacity library k – mean time k book library buy a new book would cause heidi k book must first get rid book already order make room new book later need a book get rid need buy book give k sequence request book a1 a2 ... , minimum cost ( chf ) buy new book satisfy request ? first line input contain two integers n k ( 1 ≤ n k ≤ 80 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ n ) – sequence book request a single line print minimum cost buy book store satisfy request first test case heidi able keep book forever therefore need buy book 1 first day book 2 second day second test case keep one book a time therefore need buy new book first second fourth day third test case buy book 3 third day must decide book 1 2 get rid course keep book 1 request fourth day",['greedy'],1800.0
802/F,task exact easy version time marmots subtract village 's population p random number respond heidi 's request also villages a single inhabitant mean help heidi find whether a village follow a poisson a uniform distribution ? easy medium versions remember 1 ≤ p ≤ 1000 marmots may provide positive well negative integers output one line per village order provide input village 's line shall state poisson village 's distribution poisson type uniform answer come a uniform distribution,['math'],2800.0
802/L,heidi terrify estimate find unrealistic friends would <unknown> drive debt expect actually person pick a random friend send heidi ( randomness assumption imply however visit friend arbitrary number time ... ) moreover a person one friend common heidi ( i.e. person a leaf tree ) person send heidi back ( heidi 's travel end point ) heidi also find unrealistic assumption make travel one day therefore assume every time travel a route two friends need buy a new ticket want know : much expect spend trip ? 's worth heidi know jenny least two friends first line contain number friends n ( 3 ≤ n ≤ 105 ) next n - 1 line contain three space - separated integers u v c ( 0 ≤ u v ≤ n - 1 1 ≤ c ≤ 104 ) mean u v friends cost travel u v c ( pay every time ! ) guarantee social network input form a tree assume expect cost trip write irreducible fraction a / b ( a b coprime ) heidi weird cow ask output ( output a single integer 0 109 + 6 ) first example probability 1 / 2 heidi go 1 0 probability 1 / 2 go 2 . first case cost would 10 second would 20 . reach 1 2 stop 1 2 leave social tree hence expect cost pay 10·1 / 2 + <unknown> / 2 = 15 . third example expect cost 81 / 5 . output <unknown> . travel heidi learn intrigue fact structure social network tell follow : mysterious determinant might wonder cause strange errors reasonable solution ... mention heidi a weird cow ?,"['dfs and similar', 'dp', 'math', 'trees']",2400.0
802/M,"marmots prepare a easy problem year 's hc2 – one involve number n k a sequence n positive integers a1 a2 ... , also come a beautiful <unknown> story problem statement explain input mean program output also read like a good criminal however i heidi none joke today i remove story statement replace two <unknown> paragraph solve problem fool ! first line input contain two space - separated integers n k ( 1 ≤ k ≤ n ≤ 2200 ) second line contain n space - separated integers a1 ... ( 1 ≤ ai ≤ 104 ) output one number","['greedy', 'sortings']",1200.0
802/O,plan hc2 rather far - <unknown> : 500 000 days away hc2 <unknown> example accordingly plan a couple hundred thousand problems edition ( hope program contest become wildly popular ) marmots need get work could use a good plan ... medium version limit change : 1 ≤ k ≤ n ≤ 500 000 . medium version,"['binary search', 'data structures']",2900.0
803/C,give positive integer number n. create strictly increase sequence k positive number a1 a2 ... ak sum equal n greatest common divisor maximal greatest common divisor sequence maximum number every element sequence divisible possible sequence output -1 . first line consist two number n k ( 1 ≤ n k ≤ 1010 ) answer exist output k number — result sequence otherwise output -1 . multiple answer print,"['greedy', 'math']",1900.0
804/C,isart modsart try solve interest problem suddenly <unknown> arrive <unknown> ask : ` ` solve a problem i ' m stick day ? ` ` a tree t n vertices m type ice cream numerate 1 m. vertex i a set si type ice cream vertices i - th ( 1 ≤ i ≤ m ) type ice cream form a connect subgraph build a new graph g m vertices put edge v - th u - th ( 1 ≤ u v ≤ m u ≠ v ) vertices g exist a vertex t v - th u - th type ice cream set problem paint vertices g minimum possible number color a way adjacent vertices color please note consider empty set vertices form a connect subgraph problem usual modsart n't like abandon previous problem isart want solve new problem first line contain two integer n m ( 1 ≤ n m ≤ 3·105 ) — number vertices t number ice cream <unknown> line follow i - th line contain single integer si ( 0 ≤ si ≤ 3·105 ) si distinct integers 1 m — type ice cream i - th vertex sum si n't exceed <unknown> - 1 line follow line describe edge tree two integers u v ( 1 ≤ u v ≤ n ) — index connect edge vertices print single integer c first line — minimum number color paint vertices graph g. second line print m integers i - th color i - th vertex color 1 c. answer print first example first type ice cream present first vertex color color second third ice cream present second vertex paint different color second example color second fourth fifth ice cream obviously distinct,"['dfs and similar', 'greedy']",2200.0
804/F,isart people n't die n gang criminals i - th gang contain si evil people numerate 0 si - 1 . people take part a big mine robbery pick one gold bullion ( people give input ) happen 10100 years ago gang escape a remote area far towns years copy gold bullions accord organize plan order get arrest construct a tournament direct graph ( a graph exactly one direct edge every pair vertices ) gang ( graph give input ) graph edge u v mean i - th hour person gang u send a fake gold bullion person gang v. send bullion ( real fake ) receiver n't thus moment gangsters zero one gold bullion real bullions fake ones begin year police finally find gang could n't catch usual police decide open a jewelry store gangsters would sell bullions thus every <unknown> a bullion ( fake real ) try sell a real gold bullion sell without problems a fake one a choice two events happen : power a gang number people successfully sell bullion sell do police arrest b gang top gang sort gang power call first a gang top gang ( sort equal power order ) consider possible result sell fake gold bullions possible choice b gang among top gang count number different set b gang modulo 109 + 7 . two set x y consider different gang x n't y. first line contain four integers n a b ( 1 ≤ b ≤ a ≤ n ≤ 5·103 ) — number gang constants a b statement n line follow line contain a string size n consist zero ones j - th character i - th line equal 1 vertex i a direct edge vertex j. guarantee aii = 0 aij + aji = 1 i ≠ j. n line follow line start integer si ( 1 ≤ si ≤ 2·106 ) — number gangsters i - th gang contain a string zero ones length si j - th character 0 j - th person i - th gang a real gold bullion initially otherwise 1 . guarantee sum si exceed 2·106 print single integer : number different set b gang police arrest modulo 109 + 7,"['combinatorics', 'dfs and similar', 'dp', 'graphs', 'number theory']",3400.0
807/B,long ago codecraft-17 contest hold codeforces top 25 participants additionally random 25 participants get top 500 receive a codeforces t - shirt unfortunately n't manage get top 25 get top 500 take place p. elimination round 8vc venture cup 2017 hold announce codecraft-17 t - shirt winners choose follow let s number point winner elimination round 8vc venture cup 2017 . follow pseudocode execute : ` ` div '' integer division operator ` ` mod '' modulo ( remainder division ) operator result pseudocode execution 25 integers 26 500 inclusive print number place participants get codecraft-17 t - shirts guarantee 25 print integers pairwise distinct value s. 're lead elimination round 8vc venture cup 2017 x point believe least y point current round enough victory change final score make number successful unsuccessful hack a successful hack bring 100 point unsuccessful one take 50 point 's difficult successful hack though want win current round time ensure get a codecraft-17 t - shirt smallest number successful hack achieve ? line contain three integers p x y ( 26 ≤ p ≤ 500 ; 1 ≤ y ≤ x ≤ 20000 ) — place codecraft-17 current score elimination round 8vc venture cup 2017 smallest number point consider sufficient win current round output a single integer — smallest number successful hack order win elimination round 8vc venture cup 2017 ensure get a codecraft-17 t - shirt 's guarantee goal achievable valid input data first example need hack since <unknown> point already bring t - shirt 239 - th place codecraft-17 ( ) case accord pseudocode t - shirts give participants follow place : second example two successful one unsuccessful hack make score equal <unknown> . third example need many 24 successful hack make score equal <unknown> . fourth example 's sufficient 6 unsuccessful hack ( successful ones ) make score equal <unknown> enough win current round also get t - shirt,"['brute force', 'implementation']",1300.0
808/B,"'s almost a week since polycarp could n't get rid <unknown> may already know one week berland last k days ! polycarp go a doctor problem doctor ask sleep schedule ( specifically average amount hours sleep per week ) luckily polycarp keep record sleep time last n days a sequence a1 a2 ... , ai sleep time i - th day number record large polycarp unable calculate average value thus ask help calculations get average polycarp go consider k consecutive days a week n - k + 1 weeks take consideration example k = 2 n = 3 a = [ 3 4 7 ] result write a program calculate average sleep time polycarp weeks first line contain two integer number n k ( 1 ≤ k ≤ n ≤ 2·105 ) second line contain n integer number a1 a2 ... ( 1 ≤ ai ≤ 105 ) output average sleep time weeks answer consider correct absolute relative error exceed 10 - 6 . particular enough output real number least 6 digits decimal point third example n - k + 1 = 7 weeks answer sum weeks divide 7","['data structures', 'implementation', 'math']",1300.0
809/C,a wonderful even restaurant time go home come leha a true gentlemen suggest noora give a lift certainly girl agree pleasure suddenly one problem appear : leha find car a huge park near restaurant decide turn watchman help formally park represent a matrix 109 × 109 . exactly one car every cell matrix cars machine number represent a positive integer let 's index columns matrix integers 1 109 leave right row integers 1 109 top bottom coincidence turn every cell ( x y ) number car stand cell equal minimum positive integer ca n't find cells ( i y ) ( x j ) 1 ≤ i < x 1 ≤ j < y. leha want ask watchman q request help find car every request represent five integers x1 y1 x2 y2 k. watchman consider cells ( x y ) matrix x1 ≤ x ≤ x2 y1 ≤ y ≤ y2 number car cell ( x y ) exceed k increase answer request number car cell ( x y ) request leha ask watchman tell result sum due fact sum turn quite large hacker ask calculate modulo 109 + 7 . however request seem <unknown> watchman help watchman answer leha 's request first line contain one integer q ( 1 ≤ q ≤ 104 ) — number leha 's request next q line contain five integers x1 y1 x2 y2 k ( 1 ≤ x1 ≤ x2 ≤ 109 1 ≤ y1 ≤ y2 ≤ 109 1 ≤ k ≤ 2·109 ) — parameters leha 's request print exactly q line — first line print answer first request second — answer second request let 's analyze request case request submatrix highlight blue first request ( k = 1 ) leha ask upper leave park cell cell car 's number 1 . consequentally answer 1 . second request ( k = 5 ) suitable number 4 1 2 3 2 1 . consequentally answer 4 + 1 + 2 + 3 + 2 + 1 = 13 . third request ( k = 10000 ) leha ask upper leave <unknown> 5 × 5 park since k big enough answer equal 93 . last request ( k = 2 ) none <unknown> 's number suitable answer 0,"['combinatorics', 'divide and conquer', 'dp']",2600.0
809/E,tire bore date leha noora decide play a game leha find a tree n vertices number 1 n. remind tree undirected graph without cycle vertex v a tree a number av write quite accident turn value write vertices distinct natural number 1 n. game go follow way noora choose vertex u a tree uniformly random pass a move leha leha turn choose ( also uniformly random ) vertex v remain vertices a tree ( v ≠ u ) could guess n ( n - 1 ) variants choose vertices players players calculate value a function f ( u v ) = φ ( <unknown> ) · d ( u v ) choose vertices φ ( x ) euler 's totient function d ( x y ) shortest distance vertices x y a tree soon game become bore noora leha decide defuse situation calculate expect value function f variants choose vertices u v hop least somehow surprise girl leha ask help calculate expect value let value representable form irreducible fraction surprise noora want name value help leha ! first line input contain one integer number n ( 2 ≤ n ≤ 2·105 ) — number vertices a tree second line contain n different number a1 a2 ... ( 1 ≤ ai ≤ n ) separate space denote value write a tree vertices next n - 1 line contain two integer number x y ( 1 ≤ x y ≤ n ) describe next edge a tree guarantee set edge describe a tree a single line print a number equal p·q - 1 modulo 109 + 7 . euler 's totient function φ ( n ) number i 1 ≤ i ≤ n gcd ( i n ) = 1 gcd ( x y ) greatest common divisor number x y. 6 variants choose vertices leha noora first testcase : expect value equal value leha want name noora 7·3 - 1 = <unknown> = 333333338 second testcase expect value equal leha surprise <unknown> number 8·1 - 1 = 8,"['divide and conquer', 'math', 'number theory', 'trees']",3100.0
81/D,polycarp love take picture also show photos friends personal website recently instal a widget display n photos scroll option moment time widget display exactly one photograph option show previous / next one first photo switch second one n - th one second photo switch third one first one etc thus navigation perform a cycle polycarp 's collection consist m photo albums i - th album contain ai photos polycarp want choose n photos put a new widget make watch photos interest visitors go post picture two photos one album neighbor ( photo exactly two neighbor first photo 's neighbor second n - th one ) help polycarp compile a photo gallery select n photos collection put order two photos one album go one first line contain two integers n m ( 3 ≤ n ≤ 1000 1 ≤ m ≤ 40 ) n number photos widget m number albums second line contain m integers a1 a2 ... ( 1 ≤ ai ≤ 1000 ) ai number photos i - th album print single number -1 solution otherwise print n number t1 t2 ... tn ti represent number album i - th picture widget albums number 1 order appearance input several solutions print,['greedy'],2100.0
810/B,summer holiday ! someone go trip someone visit grandparents someone try get a part - time job summer noora decide want earn money take a job a shop assistant shop noora work a plan follow n days day sales manager know exactly i - th day ki products put sale exactly li clients come shop day also manager sure everyone come shop buy exactly one product n't leave leave shop without buy anything moreover due short shelf - life products manager establish follow rule : part products leave shelve end day products n't keep next day send <unknown> advertise purpose manager offer start a sell - out shop ask noora choose f days n next sell - outs f choose days number products put sale would double thus i - th day shop plan put sale ki products noora choose day sell - out shelve shop would keep <unknown> products consequently opportunity sell two time products days sell - out noora 's task choose f days maximize total number sell products ask help a difficult problem first line contain two integers n f ( 1 ≤ n ≤ 105 0 ≤ f ≤ n ) denote number days shop 's plan number days noora choose sell - out line follow n subsequent line contain two integers ki li ( 0 ≤ ki li ≤ 109 ) denote number products shelve shop i - th day number clients come shop i - th day print a single integer denote maximal number products shop sell first example choose days number 2 4 sell - out case new number products sale would equal [ 2 6 2 2 ] respectively first day shop sell 1 product second — 5 third — 2 fourth — 2 . total 1 + 5 + 2 + 2 = 10 product units second example possible sell 5 products choose third day sell - out,"['greedy', 'sortings']",1300.0
811/C,vladik often travel train remember trip especially well i would like tell one trip : vladik initial train station n people ( include vladik ) want get train already line order city code ai know ( code city go ) train chief select number disjoint segment original sequence people ( cover entire sequence segment necessary ) people segment train carriage segment select way least one person travel city x people go city x railway carriage mean ’ t belong different segment note people travel city x either go railway carriage go anywhere comfort a train trip people segment position l position r equal xor distinct cod cities people segment position l position r. xor operation also know exclusive total comfort a train trip equal sum comfort segment help vladik know maximal possible total comfort first line contain single integer n ( 1 ≤ n ≤ 5000 ) — number people second line contain n space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 5000 ) ai denote code city i - th person go output contain a single integer — maximal possible total comfort first test case best partition segment : [ 4 4 ] [ 2 5 2 ] [ 3 ] answer calculate follow : 4 + ( 2 xor 5 ) + 3 = 4 + 7 + 3 = 14 in second test case best partition segment : 5 1 [ 3 ] 1 5 [ 2 4 2 ] 5 answer calculate follow : 3 + ( 2 xor 4 ) = 3 + 6 = 9,"['dp', 'implementation']",1900.0
812/D,"sagheer work a kindergarten n children m different toy children use well - <unknown> <unknown> play toy : children n't like play 's never share toy a child request a toy grant toy child depend whether toy free toy free sagheer give child otherwise child wait ca n't request another toy children smart detect wait forever get toy want case start cry word a cry set a set children child wait a toy keep another child set , reach a scenario children make request lovely set except one child x still one last request lovely set children play others wait a toy child cry one yet finish play child x currently wait toy make last request get toy otherwise make request right away child x make last request many children start cry ? give scenario q independent query query form x y mean last request child x toy y. task help sagheer find size maximal cry set child x make last request first line contain four integers n m k q ( 1 ≤ n m k q ≤ 105 ) — number children toy scenario request query next k line contain two integers a b ( 1 ≤ a ≤ n 1 ≤ b ≤ m ) — a scenario request mean child a request toy b. request give order make children next q line contain two integers x y ( 1 ≤ x ≤ n 1 ≤ y ≤ m ) — request add scenario mean child x request toy y get toy wait ( ) guarantee scenario request consistent child initially cry scenario request distinct query coincide a scenario request query print a single line number children start cry child x make last request toy y. please answer query independent first example child 1 wait toy 2 child 2 child 2 wait top 3 child 3 child 3 make last request toy request hold child 1 . three children wait a toy hold another child one play three start cry second example begin child i hold toy i 1 ≤ i ≤ 4 . children 1 3 complete lovely set finish play toy 3 free toy 1 take child 2 complete lovely set finish toy 1 2 free child 5 take toy 1 . :","['dfs and similar', 'graphs', 'implementation', 'trees']",2700.0
813/B,unlucky year berland a year number n represent n = xa + yb a b non - negative integer number example x = 2 y = 3 years 4 17 unlucky ( 4 = 20 + 31 17 = 23 + 32 = 24 + 30 ) year 18 n't unlucky representation interval years unlucky years call golden age write a program find maximum length golden age start earlier year l end later year r. years interval [ l r ] unlucky answer 0 . first line contain four integer number x y l r ( 2 ≤ x y ≤ 1018 1 ≤ l ≤ r ≤ 1018 ) print maximum length golden age within interval [ l r ] years interval [ l r ] unlucky print 0 . first example unlucky years 2 3 4 5 7 9 10 . maximum length golden age <unknown> intervals [ 1 1 ] [ 6 6 ] [ 8 8 ] second example longest golden age interval [ 15 22 ],"['brute force', 'math']",1800.0
816/A,"karen get ready a new school day ! currently hh : mm give a 24 - hour format know karen love palindromes believe good luck wake time a palindrome minimum number minutes sleep , wake time a palindrome ? remember a palindrome a string read forward backwards instance 05:39 a palindrome 05:39 backwards <unknown> . hand 05:50 a palindrome 05:50 backwards 05:50 . first line input contain a single string format hh : mm ( 00 ≤ hh ≤ 23 00 ≤ mm ≤ 59 ) output a single integer a line minimum number minutes sleep , wake time a palindrome first test case minimum number minutes karen sleep 11 . wake 05:50 time a palindrome second test case karen wake immediately current time <unknown> already a palindrome third test case minimum number minutes karen sleep 1 minute wake 00:00 time a palindrome","['brute force', 'implementation']",1000.0
817/B,return army make receive a gift — array a consist n positive integer number n't solve problems a long time become interest answer a particular question : many triple indices ( i j k ) ( i < j < k ) ai·aj·ak minimum possible array ? help ! first line input contain a positive integer number n ( 3 ≤ n ≤ 105 ) — number elements array a. second line contain n positive integer number ai ( 1 ≤ ai ≤ 109 ) — elements a give array print one number — quantity triple ( i j k ) i j k pairwise distinct ai·aj·ak minimum possible first example make always choose three ones four number ways choose 4 . second example a triple number ( 1 2 3 ) choose ( number indices ) since two ways choose element 3 answer 2 . third example a triple number ( 1 1 2 ) choose 's one way choose indices,"['combinatorics', 'implementation', 'math', 'sortings']",1500.0
817/D,give array a consist n elements imbalance value subsegment array difference maximum minimum element segment imbalance value array sum imbalance value subsegments array example imbalance value array [ 1 4 1 ] 9 6 different subsegments array : determine imbalance value array a. first line contain one integer n ( 1 ≤ n ≤ 106 ) — size array a. second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 106 ) — elements array print one integer — imbalance value a,"['data structures', 'divide and conquer', 'dsu', 'sortings']",1900.0
817/F,give a set integer number initially empty perform n query three different type query : query output mex set — smallest positive ( mex ≥ 1 ) integer number present set first line contain one integer number n ( 1 ≤ n ≤ 105 ) next n line contain three integer number t l r ( 1 ≤ t ≤ 3 1 ≤ l ≤ r ≤ 1018 ) — type query leave right bound print mex set query content set query first example :,"['binary search', 'data structures', 'trees']",2300.0
818/A,n students take part olympiad 's time award students receive diplomas <unknown> get certificate others wo n't receive anything students diplomas certificate call winners rule count number diplomas certificate number certificate must exactly k time greater number diplomas number winners must greater half number students ( i.e greater half n ) 's possible winners identify maximum possible number winners accord rule also case calculate number students diplomas number students certificate number students winners first ( ) line input contain two integers n k ( 1 ≤ n k ≤ 1012 ) n number students k ratio number certificate number diplomas output three number : number students diplomas number students certificate number students winners case number winners maximum possible 's possible winners,"['implementation', 'math']",800.0
818/D,alice bob get bore a long car trip decide play a game window see cars different color run past cars go one another game rule like firstly alice choose color a bob choose color b ( a ≠ b ) car update number cars choose color run past let 's define number i - th car <unknown> ( i ) cntb ( i ) bob know color cars encounter order appearance alice already choose color a bob want choose color b win game ( draw a win ) help find color multiple solutions print color print -1 . first line contain two integer number n a ( 1 ≤ n ≤ 105 1 ≤ a ≤ 106 ) – number cars color choose alice second line contain n integer number c1 c2 ... cn ( 1 ≤ ci ≤ 106 ) — color cars alice bob encounter order appearance output color b ( 1 ≤ b ≤ 106 ) bob choose win game multiple solutions print color print -1 . guarantee exist solution exist solution ( 1 ≤ b ≤ 106 ) let 's consider availability color first example : third example every color acceptable except 10,"['data structures', 'implementation']",1700.0
819/B,time ago mister b detect a strange signal space start study transformation signal turn a permutation p length n cyclic shift investigation mister b need basis 's decide choose cyclic shift permutation minimum possible deviation let 's define deviation a permutation p find a cyclic shift permutation p minimum possible deviation multiple solutions print let 's denote i d k ( 0 ≤ k < n ) a cyclic shift permutation p number right shift need reach shift example : first line contain single integer n ( 2 ≤ n ≤ 106 ) — length permutation second line contain n space - separated integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) — elements permutation guarantee elements distinct print two integers : minimum deviation cyclic shift permutation p i d shift multiple solutions print first sample test give permutation p identity permutation 's deviation equal 0 shift i d equal 0 well second sample test deviation p equal 4 deviation 1 - st cyclic shift ( 1 2 3 ) equal 0 deviation 2 - nd cyclic shift ( 3 1 2 ) equal 4 optimal 1 - st cyclic shift third sample test deviation p equal 4 deviation 1 - st cyclic shift ( 1 3 2 ) equal 2 deviation 2 - nd cyclic shift ( 2 1 3 ) also equal 2 optimal 1 - st 2 - nd cyclic shift,"['data structures', 'implementation', 'math']",1900.0
822/E,first semester end know end first semester holiday begin holiday noora decide return vičkopolis a modest souvenir leha bring a sausage length m pavlopolis everyone know sausage represent a string lowercase english letter length equal length sausage leha please gift immediately eat sausage realize a quite <unknown> act sausage a souvenir ! hacker immediately go butcher shop unfortunately another sausage length n shop however leha upset buy sausage come home decide cut purchase sausage several piece number piece start 1 leave right want select several piece glue together obtain sausage equal sausage noora give hacker glue two piece together number leave piece less number right piece besides know glue x piece noora notice <unknown> souvenir sausage upset course leha ’ t want upset girl hacker ask find whether able cut sausage buy glue piece noora n't notice anything formally give two string s t. length string s n length string t m. require select several pairwise non - intersecting substrings s concatenation order substrings appear s equal string t. denote f ( s t ) minimal number substrings choose concatenation equal string t. impossible choose substrings f ( s t ) = ∞ leha really want know whether ’ s true f ( s t ) ≤ x. first line contain single integer n ( 1 ≤ n ≤ 105 ) — length sausage buy leha i.e length string s. second line contain string s length n consist lowercase english letter third line contain single integer m ( 1 ≤ m ≤ n ) — length sausage buy noora i.e length string t. fourth line contain string t length m consist lowercase english letter fifth line contain single integer x ( 1 ≤ x ≤ 30 ) — maximum number piece sausage leha glue noora ’ t notice anything line print ` ` yes '' ( without quote ) leha able succeed create new sausage noora n't notice anything otherwise print ` ` '' ( without quote ) let 's consider first sample optimal answer leha cut sausage buy follow way : <unknown> = h + <unknown> + a + y + g + rt number receive part 1 6 : hereupon hacker glue part number 2 4 6 get sausage <unknown> equal one give noora thus glue three piece since x = 3 print ` ` yes '' ( without quote ) second sample sausages coincide sausages first sample however since x = 2 print ` ` '' ( without quote ),"['binary search', 'dp']",2400.0
825/B,alice bob play 5 - in - a - row game a play field size 10 × 10 . turn put either cross noughts one a time alice put cross bob put noughts current match make turn 's alice 's turn wonder put cross empty cell win immediately alice win cross field form line length smaller 5 . line horizontal vertical diagonal give matrix 10 × 10 ( 10 line 10 character ) capital latin letter ' x ' a cross letter ' o ' a nought ' . ' empty cell number ' x ' cells equal number ' o ' cells least one type least one empty cell guarantee current arrangement nobody still print ' yes ' 's possible alice win one turn put cross empty cell otherwise print ' no ',"['brute force', 'implementation']",1600.0
825/C,"make solve problems decoforces lot different online judge problem denote difficulty — a positive integer number difficulties measure across judge ( problem difficulty d decoforces hard problem difficulty d judge ) make choose n problems solve decoforces difficulties a1 a2 ... , solve problems arbitrary order though solve problem i difficulty ai already solve problem difficulty ( matter online judge ) start choose list problems make already solve problems maximum difficulty k. give condition 's easy see make sometimes ca n't solve choose problems matter order choose want solve problems judge finish solve problems list every positive integer y exist problem difficulty y least one judge besides decoforces make solve problems judge time n't necessary problems choose list one right another make n't much free time ask calculate minimum number problems solve judge order solve choose problems decoforces first line contain two integer number n k ( 1 ≤ n ≤ 103 1 ≤ k ≤ 109 ) second line contain n space - separated integer number a1 a2 ... ( 1 ≤ ai ≤ 109 ) print minimum number problems make solve judge order solve choose problems decoforces first example make first solve problems 1 2 . order solve problem difficulty 9 solve problem difficulty less 5 . available difficulties 5 6 judge solve give make opportunity solve problem 3 . second example solve every problem right start","['greedy', 'implementation']",1600.0
825/D,give two string s t consist small latin letter string s also contain ' ? ' character suitability string s calculate follow metric : two letter swap position operations perform arbitrary number time pair position among result string s choose one largest number non - intersecting occurrences string t. suitability number occurrences replace ' ? ' character small latin letter a way suitability string s maximal first line contain string s ( 1 ≤ |s| ≤ 106 ) second line contain string t ( 1 ≤ |t| ≤ 106 ) print string s ' ? ' replace small latin letter a way suitability string maximal multiple string maximal suitability print first example string ` ` baab '' transform ` ` abab '' swap one suitability 2 . mean string ` ` baab '' also suitability 2 . second example maximal suitability achieve 1 several dozens string ` ` <unknown> '' one third example ' ? ' character suitability string 0,"['binary search', 'greedy', 'implementation']",1500.0
828/A,a small restaurant a table one person b table two persons know n group people come today consist one two people a group consist one person seat a vacant one - seater table none seat a vacant two - seater table none seat a two - seater table occupy single person still none restaurant deny service group a group consist two people seat a vacant two - seater table none restaurant deny service group give a chronological order group come determine total number people restaurant deny service first line contain three integers n a b ( 1 ≤ n ≤ 2·105 1 ≤ a b ≤ 2·105 ) — number group come restaurant number one - seater number two - seater table second line contain a sequence integers t1 t2 ... tn ( 1 ≤ ti ≤ 2 ) — description clients chronological order ti equal one i - th group consist one person otherwise i - th group consist two people print total number people restaurant deny service first example first group consist one person seat a vacant one - seater table next group occupy a whole two - seater table third group consist one person occupy one place remain two - seater table fourth group consist one person seat remain seat two - seater table thus clients serve second example first group consist one person seat vacant one - seater table next group consist one person occupy one place two - seater table 's impossible seat next group two people restaurant deny service fourth group consist one person seat remain seat two - seater table thus restaurant deny service 2 clients,['implementation'],1200.0
830/A,"n people k key a straight line every person want get office locate line well , need reach point a key take key go office a key take somebody could n't take anybody else determine minimum time need n people get office key assume people move a unit distance per 1 second two people reach a key time one take key a person pass a point a key without take first line contain three integers n k p ( 1 ≤ n ≤ 1 000 n ≤ k ≤ 2 000 1 ≤ p ≤ 109 ) — number people number key office location second line contain n distinct integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — position people locate initially position give arbitrary order third line contain k distinct integers b1 b2 ... bk ( 1 ≤ bj ≤ 109 ) — position key position give arbitrary order note ca n't one person one key point a person a key locate point print minimum time ( second ) need n reach office key first example person locate point 20 take key locate point 40 go office locate point 50 . spend 30 second person locate point 100 take key locate point 80 go office spend 50 second thus 50 second everybody office key","['binary search', 'brute force', 'dp', 'greedy', 'sortings']",1800.0
833/C,"recently a wild krakozyabra appear jelly castle , truth say always eager something dinner favorite meal natural number ( typically serve honey <unknown> ) , precise zero correspond decimal representations digits krakozyabra dislike ; moreover often cause <unknown> ! , a necessary <unknown> krakozyabra prefer sort digits a number non - descending order proceed feast , lead zero result number eat remain part discard inedible tail example krakozyabra number <unknown> dinner inedible tail would number 457 . slastyona really fond idea krakozyabra live castle <unknown> natural <unknown> prevent leave guest without food slastyona a range natural number l r go fee guest help determine many distinct inedible tail go discard krakozyabra end dinner first string number l r give – boundaries range ( 1 ≤ l ≤ r ≤ 1018 ) output sole number – answer problem first sample case inedible tail number 1 9 . note 10 1 inedible tail – number 1 . second sample case number a unique inedible tail except pair 45 54 . answer sample case go ( 57 - 40 + 1 ) - 1 = 17","['brute force', 'combinatorics', 'greedy', 'math']",2700.0
833/D,slastyona like watch life nearby <unknown> 's dwellers time watch a strange red - black spider sit center a huge cobweb cobweb a set n nod connect thread tread either red black use thread spider move nod thread connect a node two nod a unique sequence thread connect slastyona decide study special qualities cobweb notice thread a value clamminess x. however slastyona mostly interest jelliness cobweb consider shortest paths pair nod number red black thread differ twice path compute product clamminess thread path jelliness cobweb product obtain value among paths paths differ direction count course number huge slastyona ask compute jelliness give cobweb print answer modulo 109 + 7 . first line contain number nod n ( 2 ≤ n ≤ 105 ) next n - 1 line contain four integers denote i - th thread cobweb : nod connect ui vi ( 1 ≤ ui ≤ n 1 ≤ vi ≤ n ) clamminess thread xi ( 1 ≤ x ≤ 109 + 6 ) color thread ci ( ) red color denote 0 black color denote 1 . print single integer jelliness cobweb modulo 109 + 7 . paths number red black thread differ twice print 1 . first example 4 pair nod number thread color differ twice pair ( 1 3 ) product clamminess equal 45 ( 1 5 ) product clamminess equal 45 ( 3 4 ) product clamminess equal 25 ( 4 5 ) product clamminess equal 25 . jelliness cobweb equal <unknown>,"['data structures', 'divide and conquer', 'implementation', 'trees']",2800.0
834/A,walk streets <unknown> city slastyona spot merchants sell a kind useless toy popular nowadays – caramel spinner ! want join <unknown> immediately buy strange <unknown> <unknown> sweetland form v - shaped piece caramel spinner well spin around invisible magic axis a specific point time a spinner take 4 position show ( one rotate 90 degrees relative previous fourth one follow first one ) : spinner spin start rotation describe a follow algorithm : spinner maintain position a second <unknown> switch next position clockwise counter - clockwise order depend direction spinner spin slastyona manage spinner rotate exactly n second fascinate <unknown> process completely forget direction spinner spin ! lucky manage recall start position want deduct direction give information know help two character first string – start end position a spinner position encode one follow character : v ( ascii code 118 lowercase v ) < ( ascii code 60 ) ^ ( ascii code 94 ) > ( ascii code 62 ) ( see picture reference ) character separate a single space second string a single number n give ( 0 ≤ n ≤ 109 ) – duration rotation guarantee end position a spinner a result a n second spin directions assume give start position output <unknown> direction clockwise <unknown> – counter - clockwise undefined otherwise,['implementation'],900.0
835/B,natural number write board sum digits less k. distract a bite someone change number n replace digits others 's know length number n't change find minimum number digits two number differ first line contain integer k ( 1 ≤ k ≤ 109 ) second line contain integer n ( 1 ≤ n < 10100000 ) lead zero n. 's guarantee situation possible print minimum number digits initial number n differ first example initial number could 12 . second example sum digits n less k. initial number could equal n,['greedy'],1100.0
837/A,give a text single - space separate word consist small capital latin letter volume word number capital letter word volume text maximum volume word text calculate volume give text first line contain one integer number n ( 1 ≤ n ≤ 200 ) — length text second line contain text single - space separate word s1 s2 ... si consist small capital latin letter print one integer number — volume text first example one word 5 capital letter second example word contain 0 capital letter,['implementation'],800.0
837/B,flag berland rectangular field n × m satisfy follow condition : give a field n × m consist character ' r ' ' g ' ' b ' output ` ` yes '' ( without quote ) field correspond correct flag berland otherwise print ` ` '' ( without quote ) first line contain two integer number n m ( 1 ≤ n m ≤ 100 ) — size field follow n line consist m character ' r ' ' g ' ' b ' — description field print ` ` yes '' ( without quote ) give field correspond correct flag berland otherwise print ` ` '' ( without quote ) field third example n't three parralel strip row field fourth example parralel border different heights — 2 1 1,"['brute force', 'implementation']",1600.0
837/E,vasya study number theory denote a function f ( a b ) : vasya two number x y want calculate f ( x y ) try find calculate function way want might take long time decide ask implement a program calculate function <unknown> first line contain two integer number x y ( 1 ≤ x y ≤ 1012 ) print f ( x y ),"['binary search', 'implementation', 'math']",2100.0
837/F,consider function p ( x ) x array m integers return array y consist m + 1 integers yi equal sum first i elements array x ( 0 ≤ i ≤ m ) infinite sequence array a0 a1 a2 ... a0 give input i ≥ 1 ai = p ( ai - 1 ) also a positive integer k. find minimum possible i ai contain a number larger equal k. first line contain two integers n k ( 2 ≤ n ≤ 200000 1 ≤ k ≤ 1018 ) n size array a0 second line contain n integers a00 a01 ... <unknown> - 1 — elements a0 ( 0 ≤ <unknown> ≤ 109 ) least two elements a0 positive print minimum i ai contain a number larger equal k,"['binary search', 'brute force', 'combinatorics', 'math']",2400.0
838/B,give a direct weight graph n nod 2n - 2 edge nod label 1 n edge label 1 2n - 2 . graph 's edge split two part give q query two type <unknown> query print shortest path lengths first line input contain two integers n q ( 2 ≤ n q ≤ 200 000 ) number nod number query respectively next 2n - 2 integers contain 3 integers ai bi ci denote a direct edge node ai node bi weight ci first n - 1 line describe a root span tree point away node 1 last n - 1 line bi = 1 . specifically next q line contain 3 integers describe a query format describe statement edge weight 1 106 . type 2 query print length shortest path line,"['data structures', 'dfs and similar', 'trees']",2100.0
84/A,hero story valera best friend arcady still school therefore spend free time play turn - based strategy ` ` gaga : go go '' gameplay follow two armies play field consist n men ( n always even ) current player specify soldier enemy 's soldier shoot ( a target ) player 's soldier shoot simultaneously a game world soldier shoot perfectly absolutely always hit specify target enemy soldier hit surely die may happen several soldier indicate target kill soldier participate game anymore game ` ` gaga '' consist three step : first valera make a move arcady valera game end ask calculate maximum total number soldier may kill game input data consist a single integer n ( 2 ≤ n ≤ 108 n even ) please note game start 2n soldier field print a single number — a maximum total number soldier could kill course game three turn first sample <unknown> ) valera 's soldier 1 2 shoot arcady 's soldier 1.2 ) arcady 's soldier 2 shoot valera 's soldier 1.3 ) valera 's soldier 1 shoot arcady 's soldier 2 . 3 soldier kill total : valera 's soldier 1 arcady 's soldier 1 2,"['math', 'number theory']",900.0
840/D,", leha find leave pocket array consist n integers right pocket q query form l r k. query must answer answer query minimal x x occur interval l r strictly time - 1 number help leha a difficult task first line input data contain two integers n q ( 1 ≤ n q ≤ 3·105 ) — number elements array number query respectively next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ n ) — leha 's array next q line contain three integers l r k ( 1 ≤ l ≤ r ≤ n 2 ≤ k ≤ 5 ) — description query output answer query new line",['data structures'],2500.0
842/D,today lesson vitya learn a interest function — mex mex a sequence number minimum non - negative number present sequence element example mex ( [ 4 33 0 1 1 5 ] ) = 2 mex ( [ 1 2 3 ] ) = 0 . vitya quickly understand task teacher ? give array consist n non - negative integers m query query characterize one number x consist follow consecutive step : note query array change first line contain two integer number n m ( 1 ≤ n m ≤ 3·105 ) — number elements array number query next line contain n integer number ai ( 0 ≤ ai ≤ 3·105 ) — elements array next m line contain query — one integer number x ( 0 ≤ x ≤ 3·105 ) query print answer a separate line,"['binary search', 'data structures']",2000.0
843/B,interactive problem give a sort increase order singly link list find minimum integer list greater equal x. formally a singly like list build array n elements element index i contain two integers : valuei integer value element nexti index next element singly link list ( -1 current element last ) list sort i.e nexti ≠ - 1 valuenexti > valuei give number elements list n index first element start integer x. make 2000 query follow two type : write a program solve problem first line contain three integers n start x ( 1 ≤ n ≤ 50000 1 ≤ start ≤ n 0 ≤ x ≤ 109 ) — number elements list index first element integer x. print answer problem print ! ans ans minimum integer list greater equal x -1 integer make a query first type print ? i ( 1 ≤ i ≤ n ) i index element want know information query type ? read two integers valuei nexti ( 0 ≤ valuei ≤ 109 - 1 ≤ nexti ≤ n nexti ≠ 0 ) guarantee nexti ≠ - 1 valuenexti > valuei array value give a valid singly link list start first element note ca n't ask 1999 query type ? nexti = - 1 valuei = - 1 mean ask query allow ask invalid query program immediately terminate ( example call exit ( 0 ) ) receive ` ` wrong answer '' mean ask query allow ask invalid query ignore get verdicts since program continue read a close stream solution get ` ` idleness limit exceed '' n't print anything forget flush output include final answer flush use ( print a query line end ) : hack formatfor hack use follow format : first line print three integers n start x ( 1 ≤ n ≤ 50000 1 ≤ start ≤ n 0 ≤ x ≤ 109 ) next n line print description elements list : i - th line print two integers valuei nexti ( 0 ≤ valuei ≤ 109 - 1 ≤ nexti ≤ n nexti ≠ 0 ) print structure a valid singly link list particular possible reach elements start follow link nexti last element end -1 <unknown> read singly link list follow link : https : //en.wikipedia.org / wiki / <unknown> # <unknown> illustration first sample case start finish elements mark dark,['brute force'],2000.0
845/A,berland annual chess tournament come ! organizers gather 2·n chess players divide two team n people first team sponsor beroil second team sponsor <unknown> obviously organizers guarantee win team beroil thus organizers divide 2·n players two team n people a way first team always win every chess player rat ri know chess player greater rat always win player lower rat rat equal players win team assignment come a draw form n pair opponents : pair a player first team a player second team every chess player exactly one pair every pair play draw totally random possible divide 2·n players two team n people player first team every pair win regardless result draw ? first line contain one integer n ( 1 ≤ n ≤ 100 ) second line contain 2·n integers a1 a2 ... a2n ( 1 ≤ ai ≤ 1000 ) 's possible divide 2·n players two team n people player first team every pair win regardless result draw print ` ` yes '' otherwise print ` ` '',"['implementation', 'sortings']",1100.0
845/E,capital berland look like a rectangle size n × m square block size fire ! know k + 1 block get catch fire ( k + 1 ≤ n·m ) block center ignition moreover position k center know one stay unknown k + 1 position distinct fire go follow way : zero minute fire k + 1 center ignition burn every next minute fire go neighbour block one burn consider block burn long time exceed time take problem neighbour block touch current block a side a corner berland fire <unknown> want estimate minimal time take fire lighten whole city remember position k block ( center ignition ) know ( k + 1 ) -th position block help berland fire department estimate minimal time take fire lighten whole city first line contain three integers n m k ( 1 ≤ n m ≤ 109 1 ≤ k ≤ 500 ) next k line contain two integers xi yi ( 1 ≤ xi ≤ n 1 ≤ yi ≤ m ) — coordinate i - th center ignition guarantee locations center ignition distinct print minimal time take fire lighten whole city ( minutes ) first example last block coordinate ( 4 4 ) second example last block coordinate ( 8 3 ),"['binary search', 'data structures']",2400.0
847/A,doubly link list one fundamental data structure a doubly link list a sequence elements contain information previous next elements list problem list linear structure i.e element except first exactly one previous element element except last exactly one next element list close a cycle problem give n memory cells form one doubly link list cell contain information element list memory cells number 1 n. cell i give two value : cell i contain information element previous element li = 0 . similarly cell i contain information element next element ri = 0 . example picture value l r follow : l1 = 4 r1 = 7 ; l2 = 5 r2 = 0 ; l3 = 0 r3 = 0 ; l4 = 6 <unknown> = 1 ; l5 = 0 <unknown> = 2 ; <unknown> = 0 <unknown> = 4 ; <unknown> = 1 <unknown> = 0 . task unite give list a single list join order particular input data already contain a single list need perform action print result list form value li ri action join begin one list end another perform first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number memory cells doubly link list locate follow n line contain two integers li ri ( 0 ≤ li ri ≤ n ) — cells previous next element list cell i. value li = 0 element cell i previous element list value ri = 0 element cell i next element list guarantee input contain correct description a single doubly link list list linear structure : element list except first exactly one previous element ; element list except last exactly one next element memory cell contain information one element list element list write one n give cells print n line i - th line must contain two integers li ri — cells previous next element list cell i list input unite a single list many solutions print,['implementation'],1500.0
847/J,soon first year students initiate students university berland organizers <unknown> come a program holiday opinion would good first - year students present small souvenirs voice idea first - year students find follow : organizers write pair first - year friends familiar want determine new student give souvenirs opinion pair familiar students exactly one student must present a souvenir another student first year students already decide call unluckiest one present greatest number souvenirs organizers return promise unluckiest unlucky minimum possible degree : course present greatest number souvenirs compare students number small possible organizers busy ask determine pair first - year friends present a souvenir first line contain two integers n m ( 1 ≤ n ≤ 5000 0 ≤ m ≤ min ( 5000 n · ( n - 1 ) / 2 ) ) — number first year students number pair students know students number 1 n. follow m line contain two integers xi yi ( 1 ≤ xi yi ≤ n xi ≠ yi ) — students pair guarantee pair present list exactly also guarantee a pair ( xi yi ) list pair ( yi xi ) print a single integer first line — smallest number souvenirs unluckiest student present follow m line contain two integers — students familiar first number pair must student present souvenir second student pair pair print order many solutions print,"['binary search', 'graphs']",2400.0
848/D,"a never - ending fast - <unknown> dream - like world unfold secret door open a world unordered graph g whose vertex set v ( g ) two special vertices s ( g ) t ( g ) initial world vertex set { s ( g ) t ( g ) } edge a total n change take place initial world change a new vertex w add v ( g ) exist edge ( u v ) choose two edge ( u w ) ( v w ) add e ( g ) note 's possible edge choose one change 's know capacity minimum s - t cut result graph m , least m edge need remove order make s ( g ) t ( g ) disconnect count number non - similar worlds build constraints modulo 109 + 7 . define two worlds similar isomorphic <unknown> s t vertices <unknown> formally two worlds g h consider similar a bijection vertex set : first line input contain two space - separated integers n m ( 1 ≤ n m ≤ 50 ) — number operations perform minimum cut respectively output one integer — number non - similar worlds build modulo 109 + 7 . first example follow 6 worlds pairwise non - similar satisfy constraints s ( g ) mark green t ( g ) mark blue one minimum cut light blue second example follow 3 worlds satisfy constraints","['combinatorics', 'dp', 'graphs']",2900.0
848/E,"floral clock stand side mirror lake years though unable keep time remind people passage time good old days rim floral clock 2n flower number 1 2n clockwise a colour among n possible ones colour exactly two flower distance either less equal 2 equal n. additionally flower u v colour flower opposite u opposite v colour well — symmetry beautiful ! formally distance two flower 1 plus number flower minor arc ( <unknown> ) a possible arrangement n = 6 cover possibilities beauty arrangement define product lengths flower segment separate opposite flower colour word order compute beauty remove circle flower colour flower opposite , beauty product lengths remain segment note include segment length 0 product flower colour flower opposite beauty equal 0 . instance beauty arrangement equal 1 × 3 × 1 × 3 = 9 — segment { 2 } { 4 5 6 } { 8 } { 10 11 12 } keep constraints satisfy may lot different arrangements find sum beauty possible arrangements modulo 998 244 353 . two arrangements consider different a pair ( u v ) ( 1 ≤ u v ≤ 2n ) exist flower u v colour one , first line input contain a lonely positive integer n ( 3 ≤ n ≤ 50 000 ) — number colour present floral clock output one integer — sum beauty possible arrangements flower modulo 998 244 353 . n = 3 follow six arrangements a beauty 2 × 2 = 4 . many others leave one figure a beauty 0 . right one invalid since 's <unknown>","['combinatorics', 'divide and conquer', 'dp', 'math']",3400.0
85/D,one well - known algorithm find k - th order statistics divide elements group five consecutive elements find median five a median call middle element a sort array ( 's third largest element a group five ) increase algorithm 's performance speed a modern video card able find a sum medians five array a sum medians a sort k - element set s = { a1 a2 ... ak } a1 < a2 < a3 < ... < ak understand operator stand take remainder stand remainder divide x y. organize exercise test quickly calculate sum medians a change set need first line contain number n ( 1 ≤ n ≤ 105 ) number operations perform n line contain description one three operations : add x operation true element x include set directly operation <unknown> x operation true element x include set directly operation number input positive integers exceed 109 . operation sum print single line sum medians current set set empty print 0 . please use % lld specificator read write 64 - bit integers c++ prefer use cin cout stream ( also may use % i64d specificator ),"['binary search', 'brute force', 'data structures', 'implementation']",2300.0
850/D,"ivan read a book tournaments know a tournament orient graph exactly one orient edge pair vertices score a vertex number edge go outside vertex yesterday ivan learn <unknown> 's criterion : tournament score d1 ≤ d2 ≤ ... ≤ dn 1 ≤ k < n , ivan wan na solve follow problem : give a set number s = { a1 a2 ... } a tournament give set score ? i.e tournament sequence score d1 d2 ... dn remove duplicate score obtain require set { a1 a2 ... } ? find a tournament minimum possible number vertices first line contain a single integer m ( 1 ≤ m ≤ 31 ) next line contain m distinct integers a1 a2 ... ( 0 ≤ ai ≤ 30 ) — elements set s. guarantee elements set distinct tournaments print string ` ` = ( ` ` ( without quote ) otherwise print integer n — number vertices tournament print n line n character — matrix tournament j - th element i - th row 1 edge i - th j - th vertices orient towards j - th vertex 0 otherwise main diagonal contain zero","['dp', 'graphs', 'greedy', 'math']",2800.0
853/C,ilya sit a wait area metropolis airport bore look time table show plane delay take a sheet paper decide solve problems first ilya draw a grid size n × n mark n square two mark square share row column call a rectangle a grid side parallel grid side beautiful exactly two corner square mark exactly n · ( n - 1 ) / 2 beautiful rectangles ilya choose q query rectangles a grid side parallel grid side ( necessarily beautiful ones ) rectangles want find beauty degree beauty degree a rectangle number beautiful rectangles share least one square give one ilya think might enough time solve problem till departure flight give description mark cells query rectangles help ilya find beauty degree query rectangles first line input contain two integers n q ( 2 ≤ n ≤ 200 000 1 ≤ q ≤ 200 000 ) — size grid number query rectangles second line contain n integers p1 p2 ... pn separate space ( 1 ≤ pi ≤ n pi different ) specify grid square mark ilya : column i mark a square row pi row number 1 n bottom top columns number 1 n leave right follow q line describe query rectangles rectangle describe four integers : l d r u ( 1 ≤ l ≤ r ≤ n 1 ≤ d ≤ u ≤ n ) l r leftmost rightmost columns rectangle d u bottommost topmost row rectangle query rectangle output beauty degree a separate line first sample test one beautiful rectangle occupy whole grid therefore answer query 1 . second sample test first query rectangle intersect 3 beautiful rectangles show picture : 5 beautiful rectangles intersect second query rectangle show follow picture :,['data structures'],2100.0
855/B,"professor dumbledore help harry destroy horcruxes go gaunt <unknown> suspect a horcrux present saw <unknown> gaunt 's ring identify a horcrux although destroy still affect curse professor snape help dumbledore remove curse , want give dumbledore exactly x drop potion make value x calculate maximum p·ai + q·aj + r·ak give p q r array a1 a2 ... 1 ≤ i ≤ j ≤ k ≤ n. help snape find value x. note value x may negative first line input contain 4 integers n p q r ( - 109 ≤ p q r ≤ 109 1 ≤ n ≤ 105 ) next line input contain n space separate integers a1 a2 ... ( - 109 ≤ ai ≤ 109 ) output a single integer maximum value p·ai + q·aj + r·ak obtain provide 1 ≤ i ≤ j ≤ k ≤ n. first sample case take i = j = k = 5 thus make answer 1·5 + 2·5 + 3·5 = 30 . second sample case select i = j = 1 k = 5 give answer 12","['brute force', 'data structures', 'dp']",1500.0
855/G,"destroy voldemort 's horcruxes harry voldemort final battle cast spell <unknown> spell collide battle scene hogwarts represent form a tree , total n place hogwarts join use n - 1 undirected roads ron view battle harry voldemort wonder many triplets place ( u v w ) harry stand place u voldemort stand place v spell collide a place w. possible a triplet u v w distinct exist paths u w v w pass roads , due battle <unknown> new paths add time tell ron answer addition formally give a tree n vertices n - 1 edge q new edge add nod tree addition need tell number triplets ( u v w ) u v w distinct exist two paths one u w another v w paths edge common first line contain integer n ( 1 ≤ n ≤ 105 ) number place hogwarts next n - 1 line contain two space separate integers u v ( 1 ≤ u v ≤ n ) indicate a road place u v. guarantee give roads form a connect tree next line contain a single integer q ( 1 ≤ q ≤ 105 ) number new edge add next q line contain two space separate integers u v ( 1 ≤ u v ≤ n ) represent new road add note possible a newly add road connect place connect a road also a newly add road may connect a place first line print value number triplets change occur print q line a single integer ansi line contain value number triplets i - th edge addition first sample case initial tree ( 1 3 2 ) ( 3 1 2 ) possible triplets ( u v w ) addition edge 2 3 ( 1 3 2 ) ( 3 1 2 ) ( 1 2 3 ) ( 2 1 3 ) possible triplets","['dfs and similar', 'dp', 'graphs', 'trees']",3300.0
856/D,masha fond cacti a little girl decide plant a tree masha want make a nice cactus tree recall tree a connect undirected graph cycle cactus a connect undirected graph vertex belong one cycle masha additional edge add a tree edge know vertices would connect beauty edge masha add edge graph result graph a cactus beauty result cactus sum beauties add edge help masha find maximum beauty result cactus achieve first line input data contain two integers n m — number vertices a tree number additional edge available ( 3 ≤ n ≤ 2·105 ; 0 ≤ m ≤ 2·105 ) let us describe masha 's tree a root vertex 1 . second line contain n - 1 integers : p2 p3 ... pn pi — parent a vertex i — first vertex a path vertex i root tree ( 1 ≤ pi < i ) follow m line contain three integers ui vi ci — pair vertices connect additional edge masha add tree beauty edge ( 1 ≤ ui vi ≤ n ; ui ≠ vi ; 1 ≤ ci ≤ 104 ) guarantee additional edge coincide edge tree output one integer — maximum beauty a cactus masha achieve,"['dp', 'trees']",2400.0
858/C,beroffice text editor a wide range feature help work text one feature automatic search typos suggestions fix beroffice work small english letter ( i.e 26 letter a z ) beroffice think a word type a typo three consonants a row word exception block consonants letter block ( even length greater three ) consider a typo formally a word type a typo a block less three consonants a row least two different letter block example : beroffice editor find a word a typo insert little possible number space word ( divide several word ) a way result word type without typos implement feature beroffice editor consider follow letter vowels : ' a ' ' e ' ' i ' ' o ' ' u ' letter consonants problem line contain a non - empty word consist small english letter length word 1 3000 letter print give word without change typos least one typo word insert minimum number space word result word n't typos multiple solutions print,"['dp', 'greedy', 'implementation']",1500.0
859/F,'s another start [ c ] mean t - shirts order order make sure t - shirts ship soon possible ' ve decide year 're go order necessary t - shirts actual competition top c contestants go award t - shirts obviously n't know contestants plan get t - shirt size contestants actual competition order enough t - shirts matter top c 'll t - shirts available order award order get t - shirt size contestants send a survey survey allow contestants either specify a single desire t - shirt size two adjacent t - shirt size a contestant specify two size mean award either size probably tell plan could require order a lot unnecessary t - shirts 'd like help determine minimum number t - shirts 'll need order ensure 'll able award t - shirts matter outcome competition input begin two integers n c ( 1 ≤ n ≤ 2·105 1 ≤ c ) number t - shirt size number t - shirts award respectively follow a line 2·n - 1 integers s1 <unknown> - 1 ( 0 ≤ si ≤ 108 ) odd i si indicate number contestants desire t - shirt size ( ( i + 1 ) / 2 ) even i si indicate number contestants okay receive either t - shirt size ( i / 2 ) ( i / 2 + 1 ) c exceed total number contestants print minimum number t - shirts need buy first example buy 100 size,['greedy'],2800.0
860/E,"arkady word a large company n employees work a system a strict hierarchy namely employee exception ceo exactly one immediate manager ceo a manager ( a chain immediate managers ) employees employee integer rank ceo rank equal 1 employee rank equal rank immediate manager plus 1 . arkady a good post company however feel nobody company 's structure a lot people replace introduce value replaceability consider employee a employee b latter manager a ( necessarily immediate ) replaceability r ( a b ) a respect b number subordinate ( necessarily immediate ) manager b whose rank greater rank a. apart replaceability arkady introduce value negligibility negligibility za employee a equal sum <unknown> respect managers i.e , sum take managers b. arkady interest negligibility also negligibility employees company find negligibility employee arkady first line contain single integer n ( 1 ≤ n ≤ 5·105 ) — number employees company second line contain n integers p1 p2 ... pn ( 0 ≤ pi ≤ n ) pi = 0 i - th employee ceo otherwise pi equal i d immediate manager employee i d i. employees number 1 n. guarantee exactly one 0 among value also ceo a manager ( necessarily immediate ) employees print n integers — <unknown> employees order ids : z1 z2 ... zn consider first example :","['data structures', 'dfs and similar', 'trees']",2700.0
862/A,"dr . evil <unknown> mahmoud ehab evil land performance evil olympiad informatics ( <unknown> ) decide give problems let go dr . evil interest set a set n integers dr . evil call a set integers evil mex exactly x. mex a set integers minimum non - negative integer n't exist example mex set { 0 2 4 } 1 mex set { 1 2 3 } 0 dr . evil go make set evil perform operations operation add non - negative integer set erase element minimal number operations dr . evil perform make set evil ? first line contain two integers n x ( 1 ≤ n ≤ 100 0 ≤ x ≤ 100 ) — size set dr . evil own desire mex second line contain n distinct non - negative integers exceed 100 represent set line contain one integer — minimal number operations dr . evil perform first test case dr . evil add 1 2 set perform 2 operations second test case dr . evil erase 0 set , set become empty mex 0 . third test case set already evil","['greedy', 'implementation']",1000.0
863/A,let quasi - palindromic number number add lead zero ( possible none ) produce a palindromic string string t call a palindrome read leave right right leave example number 131 <unknown> quasi - palindromic transform string ` ` 131 '' ` ` <unknown> '' respectively palindromes give integer number x. check 's a quasi - palindromic number first line contain one integer number x ( 1 ≤ x ≤ 109 ) number give without lead zero print ` ` yes '' number x quasi - palindromic otherwise print ` ` '' ( without quote ),"['brute force', 'implementation']",900.0
864/D,"ivan array consist n elements elements integer 1 n. recently ivan learn permutations lexicographical order want change ( replace ) minimum number elements array a way array become a permutation ( i.e integers 1 n encounter array exactly ) multiple ways want find lexicographically minimal permutation among thus minimize number change first priority lexicographical minimize second priority order determine two permutations lexicographically smaller compare first elements equal — compare second , two permutations x y x lexicographically smaller xi < yi i first index permutations x y differ determine array ivan obtain perform change first line contain single integer n ( 2 ≤ n ≤ 200 000 ) — number elements ivan 's array second line contain a sequence integers a1 a2 ... ( 1 ≤ ai ≤ n ) — description ivan 's array first line print q — minimum number elements need change ivan 's array order make array a permutation second line print lexicographically minimal permutation obtain array q change first example ivan need replace number three position 1 number one number two position 3 number four get a permutation [ 1 2 4 3 ] two change number — permutation lexicographically minimal among suitable second example ivan need change anything array already a permutation","['greedy', 'implementation', 'math']",1500.0
864/E,polycarp really serious trouble — house fire ! 's time save valuable items polycarp estimate would take ti second save i - th item addition item estimate value di — moment item i completely burn longer valuable particular ti ≥ di i - th item save give value pi items find a set items polycarp save total value items maximum possible polycarp save items one another example take item a first item b item a save ta second item b — ta + tb second fire start first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number items polycarp 's house follow n line contain three integers ti di pi ( 1 ≤ ti ≤ 20 1 ≤ di ≤ 2 000 1 ≤ pi ≤ 20 ) — time need save item i time item i burn completely value item i. first line print maximum possible total value set save items second line print one integer m — number items desire set third line print m distinct integers — number save items order polycarp save items 1 - indexed order appear input several answer print first example polycarp time save two items order maximize total value save items must save second third item example firstly save third item 3 second save second item another 2 second thus total value save items 6 + 5 = 11 . second example polycarp save first item since even immediately start save second item save 3 second item already completely burn time,"['dp', 'sortings']",2000.0
864/F,"n cities berland pair connect m direct roads one use roads move one city another roads connect a city pair cities ( x y ) one road x y. a path city s city t a sequence cities p1 p2 ... pk p1 = s pk = t a road city pi city pi + 1 i 1 k - 1 . path pass multiple time city except t. ca n't pass t a path p s t ideal lexicographically minimal path word p ideal path s t path q s t pi < qi i minimum integer pi ≠ qi a tourist agency country offer q unusual excursions : j - th excursion start city sj end city tj pair sj tj help agency study ideal path sj tj note possible ideal path sj tj possible due two reason : agency would like know ideal path sj tj kj - th city path ( way sj tj ) triple sj tj kj ( 1 ≤ j ≤ q ) find ideal path sj tj print kj - th city path , first line contain three integers n m q ( 2 ≤ n ≤ <unknown> ≤ m ≤ 3000 1 ≤ q ≤ 4·105 ) — number cities number roads number excursions next m line contain two integers xi yi ( 1 ≤ xi yi ≤ n xi ≠ yi ) denote i - th road go city xi city yi roads one - directional ca n't one road direction two cities next q line contain three integers sj tj kj ( 1 ≤ sj tj ≤ n sj ≠ tj 1 ≤ kj ≤ 3000 ) j - th line print city kj - th ideal path sj tj ideal path sj tj integer kj greater length path print string ' -1 ' ( without quote ) j - th line","['dfs and similar', 'graphs', 'trees']",2700.0
865/B,'s another start [ c ] finals mean pizza order onsite contestants 2 type pizza ( obviously let 's pretend sake problem ) pizzas contain exactly s slice know i - th contestant eat si slice pizza gain ai happiness slice type 1 pizza eat bi happiness slice type 2 pizza eat order number type 1 type 2 pizzas want buy minimum possible number pizzas contestants able eat require number slice give restriction maximum possible total happiness achieve ? first line input contain integers n s ( 1 ≤ n ≤ 105 1 ≤ s ≤ 105 ) number contestants number slice per pizza respectively n line follow i - th line contain integers si ai bi ( 1 ≤ si ≤ 105 1 ≤ ai ≤ 105 1 ≤ bi ≤ 105 ) number slice i - th contestant eat happiness gain type 1 slice eat happiness gain type 2 slice eat respectively print maximum total happiness achieve first example need buy one pizza buy a type 1 pizza total happiness 3·5 + <unknown> + <unknown> = 84 buy a type 2 pizza total happiness 3·7 + <unknown> + <unknown> = 74,"['binary search', 'sortings']",1900.0
865/F,"game egg roulette play two players initially 2r raw egg 2c cook egg place randomly a carton shell leave way distinguish a raw egg a cook egg one a time a player select egg smash egg his / her forehead egg cook much happen egg raw make quite mess continue one player break r raw egg point player declare loser player win order players take turn describe a string ' a ' ' b ' character i - th character tell player choose i - th egg traditionally players take turn go one , follow order ` ` ababab ... '' n't fair though second player win often first 'd like find a better order players take turn let 's define unfairness order absolute difference first player 's win probability second player 's win probability 're interest order minimize unfairness consider order valid contain number ' a 's ' b 's also give a string s length 2 ( r + c ) contain ' a ' ' b ' ' ? ' character order say match s differ s position s contain a ' ? ' valid order minimize unfairness many match s ? first line input contain integers r c ( 1 ≤ r c ≤ 20 r + c ≤ 30 ) second line input contain string s length 2 ( r + c ) consist character ' a ' ' b ' ' ? ' print number valid order minimize unfairness match s. first test case minimum unfairness 0 order achieve ` ` abba '' ` ` baab '' neither match s. note order ` ` abbb '' would also unfairness 0 invalid contain number ' a 's ' b 's second example match order ` ` <unknown> ''","['bitmasks', 'brute force', 'divide and conquer', 'math']",3300.0
868/C,snark philip prepare problemset upcoming pre - qualification round semi - quarter - finals a bank n problems want select non - empty subset a <unknown> experience team participate contest team already know problems make contest interest team know half select problems determine snark philip make interest problemset ! first line contain two integers n k ( 1 ≤ n ≤ 105 1 ≤ k ≤ 4 ) — number problems number experience team next n line contain k integers equal 0 1 . j - th number i - th line 1 j - th team know i - th problem 0 otherwise print ` ` yes '' ( quote clarity ) possible make interest problemset ` ` '' otherwise print character either upper- lowercase ( ` ` yes '' ` ` yes '' valid answer ` ` yes '' ) first example ca n't make interest problemset first team know problems second example choose first third problems,"['bitmasks', 'brute force', 'dp']",1500.0
868/E,give a tree ( a connect non - oriented graph without cycle ) vertices number 1 n length i - th edge wi vertex s a policeman vertices x1 x2 ... xm ( xj ≠ s ) m criminals locate policeman walk along edge speed 1 criminals move arbitrary large speed a criminal moment point policeman instantly get catch policeman determine time need policeman catch criminals assume everybody behave optimally ( i.e criminals maximize time policeman minimize time ) everybody know position everybody else moment time first line contain single integer n ( 1 ≤ n ≤ 50 ) — number vertices tree next n - 1 line contain three integers : ui vi wi ( 1 ≤ ui vi ≤ n 1 ≤ wi ≤ 50 ) denote edge lengths guarantee give graph a tree next line contain single integer s ( 1 ≤ s ≤ n ) — number vertex policeman start next line contain single integer m ( 1 ≤ m ≤ 50 ) — number criminals next line contain m integers x1 x2 ... xm ( 1 ≤ xj ≤ n xj ≠ s ) — number vertices criminals locate xj necessarily distinct policeman ca n't catch criminals print single line ` ` terrorists win '' ( without quote ) otherwise print single integer — time need catch criminals first example one optimal scenarios follow criminal number 2 move vertex 3 criminal 4 — vertex 4 . policeman go vertex 4 catch two criminals criminal number 1 move vertex 2 . policeman go vertex 3 catch criminal 2 go vertex 2 catch remain criminal,"['dp', 'graphs', 'trees']",2700.0
87/B,"programmer vasya study a new program language & k * & k * language resemble languages c family syntax however powerful rule actual c - like languages <unknown> fully understand statement please read language 's description carefully follow similar rule real program languages a powerful system pointers & k * — add asterisk right exist type x — result new type x * call pointer - definition operation also operation opposite — type x a pointer add <unknown> — result a type & x refer x. call a dereference operation & k * language two basic data type — void errtype also language operators typedef typeof attempt <unknown> void type lead error : a special data type errtype errtype follow equation hold true : errtype * = & errtype = errtype attempt use data type n't define also lead errtype use typedef define one type several time definitions last one valid however type define earlier use type change let us also note dereference operation lower priority pointer operation word & t * always equal t. note operators execute consecutively one one two operators ` ` typedef & void a '' ` ` typedef a * b '' first a become errtype b become errtype * = errtype & void * = void ( see sample 2 ) vasya yet fully understand powerful technology 's ask help write a program analyze operators first line contain integer n ( 1 ≤ n ≤ 100 ) — number operators follow n line operators operator one two type : either ` ` typedef a b '' ` ` typeof a '' first case b type differ void errtype type besides n't asterisk ampersands data type name non - empty line 20 lowercase latin letter number asterisk ampersands separately one type operator exceed 10 however bring type void several asterisk number may exceed 10 . every typeof operator print single line answer operator — type give operator return let 's look second sample first two query typedef b type equivalent void * с — void * * next query typedef redefine b — equal & b = & void * = void , с type n't change с type define & & b * = & & void * = & void = errtype n't influence b type 's next typedef define c & void * = void b type redefine & void = errtype please note c type next query define exactly errtype * * * * * * * = errtype & void * * * * * * * = void * * * * * * happen last typedef","['implementation', 'strings']",1800.0
870/A,give two list non - zero digits let 's call integer pretty ( base 10 ) representation least one digit first list least one digit second list smallest positive pretty integer ? first line contain two integers n m ( 1 ≤ n m ≤ 9 ) — lengths first second list respectively second line contain n distinct digits a1 a2 ... ( 1 ≤ ai ≤ 9 ) — elements first list third line contain m distinct digits b1 b2 ... bm ( 1 ≤ bi ≤ 9 ) — elements second list print smallest pretty integer first example 25 46 <unknown> pretty well many integers smallest among 25 42 24 pretty n't digits second list second example integers least one digit different 9 pretty 's obvious smallest among 1 's smallest positive integer,"['brute force', 'implementation']",900.0
875/B,"recently dima meet sasha a <unknown> store since collect coin together favorite occupation sort <unknown> coin sasha like things order want coin arrange a row a way firstly come coin circulation come coin still circulation arrange coin dima use follow algorithm one step algorithm look like follow : dima repeat procedure happen two coin exchange procedure dima call hardness order number step require accord algorithm sort sequence e.g number time look coin begin example order sequence hardness order equal one today sasha invite dima propose a game first put n coin a row circulation sasha choose one coin circulation replace a coin circulation n time process sasha constantly ask dima hardness order sequence task complicate dima touch coin determine hardness order mind help dima task first line contain single integer n ( 1 ≤ n ≤ 300 000 ) — number coin sasha put behind dima second line contain n distinct integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) — position sasha put coin circulation first sasha replace coin locate position p1 coin locate position p2 coin number leave right print n + 1 number a0 a1 ... , a0 a hardness order begin a1 a hardness order first replacement let 's denote o coin circulation x — coin circulation first sample initially row coin circulation dima look leave right wo n't make exchange replacement first coin a coin circulation dima exchange coin next three time finally look coin finish process <unknown> → <unknown> replacement third coin dima 's action look way : <unknown> → <unknown> → <unknown> replacement fourth coin dima 's action look way : <unknown> → <unknown> replacement second coin row become consist coin circulation dima look coin leave right without exchange","['dsu', 'implementation', 'sortings', 'two pointers']",1500.0
875/D,<unknown> : lot <unknown> <unknown> russian version statement one reason learn russian : ) rick morty like go ridge high cry cry loudly — extraordinary <unknown> recently discover interest <unknown> characteristic ridge : rick morty begin cry simultaneously different mountains cry would hear mountains height equal bitwise mountains ' ve climb mountains bitwise a binary operation determine follow way consider representation number x y binary numeric system ( probably lead zero ) x = xk ... <unknown> y = yk ... <unknown> z = x | y define follow way : z = zk ... <unknown> zi = 1 xi = 1 yi = 1 zi = 0 otherwise word digit bitwise two number equal zero digits correspond position number equal zero example bitwise number 10 = 10102 9 = 10012 equal 11 = <unknown> . program languages c / c++/java / python operation define « | » pascal « » help rick morty calculate number ways select two mountains a way start cry mountains cry hear mountains mountains formally find number pair l r ( 1 ≤ l < r ≤ n ) bitwise heights mountains l r ( inclusive ) larger height mountain interval first line contain integer n ( 1 ≤ n ≤ 200 000 ) number mountains ridge second line contain n integers ai ( 0 ≤ ai ≤ 109 ) heights mountains order locate ridge print integer number ways choose two different mountains first test case ways pair mountains number ( number one ) : second test case pair pair mountains height cry 3 height equal height mountain,"['binary search', 'bitmasks', 'combinatorics', 'data structures', 'divide and conquer']",2200.0
877/D,"olya love energy drink love much room full empty can energy drink formally room represent a field n × m cells cell empty litter can olya drink a lot energy drink run k meter per second second choose one four directions ( , leave right ) run 1 k meter direction course run empty cells olya need get cell ( x1 y1 ) cell ( x2 y2 ) many second take move optimally ? 's guarantee cells ( x1 y1 ) ( x2 y2 ) empty cells coincide first line contain three integers n m k ( 1 ≤ n m k ≤ 1000 ) — size room olya 's speed n line follow contain m character i - th contain j - th position ` ` # '' cell ( i j ) litter can ` ` . '' otherwise last line contain four integers x1 y1 x2 y2 ( 1 ≤ x1 x2 ≤ n 1 ≤ y1 y2 ≤ m ) — coordinate first last cells print a single integer — minimum time take olya get ( x1 y1 ) ( x2 y2 ) 's impossible get ( x1 y1 ) ( x2 y2 ) print -1 . first sample olya run 3 meter right first second 2 meter second second 3 meter leave third second second sample olya run right 3 second 2 second leave 3 second olya recommend drink energy drink generally believe bad","['data structures', 'dfs and similar', 'graphs', 'shortest paths']",2100.0
878/E,a sequence n integers write a blackboard soon sasha come blackboard start follow action : let x y two adjacent number ( x y ) remove write x + <unknown> instead perform operations one number leave sasha like big number get biggest possible number nikita want get blackboard sasha erase number q options option i erase number leave li - th number number right ri - th number i. e. number li - th ri - th inclusive remain blackboard options want know big sasha 's final number go number big output modulo 109 + 7 . first line contain two integers n q ( 1 ≤ n q ≤ 105 ) — number integers blackboard number nikita 's options next line contain n integers a1 a2 ... ( - 109 ≤ ai ≤ 109 ) — sequence blackboard next q line contain two integers li ri ( 1 ≤ li ≤ ri ≤ n ) describe nikita 's options option output sasha 's result modulo 109 + 7 . second sample nikita n't erase anything sasha first erase number 1 2 write 5 . erase 5 -3 get -1 -1 modulo 109 + 7 109 + 6,"['combinatorics', 'dp']",3300.0
883/C,t milliseconds leave start well - known online program contest codehorses round 2017 . polycarp need download b++ compiler take part contest size file f bytes polycarp 's internet tariff allow download data rate one byte per t0 milliseconds tariff already prepay use incur expense polycarp addition internet service provider offer two additional package : polycarp buy package many time buy a package price ( p1 p2 ) prepay usage a package buy replace regular tariff package data limit completely use a package consume polycarp immediately buy a new package switch regular tariff without loose time a package use polycarp ca n't buy another package switch back regular internet tariff find minimum amount money polycarp spend download f bytes file t milliseconds note technical reason polycarp download integer number bytes use regular tariff package i.e three download modes number download bytes integer mean polycarp ca n't download a byte partially use regular tariff or / and package first line contain three integer number f t t0 ( 1 ≤ f t t0 ≤ 107 ) — size file download ( bytes ) maximal time download file ( milliseconds ) number milliseconds download one byte use regular internet tariff second line contain a description first additional package line contain three integer number a1 t1 p1 ( 1 ≤ a1 t1 p1 ≤ 107 ) a1 maximal size download data ( bytes ) t1 time download one byte ( milliseconds ) p1 price package ( burl ) third line contain a description second additional package line contain three integer number a2 t2 p2 ( 1 ≤ a2 t2 p2 ≤ 107 ) a2 maximal size download data ( bytes ) t2 time download one byte ( milliseconds ) p2 price package ( burl ) polycarp buy package many time package buy replace regular tariff package data limit completely use a package use polycarp ca n't buy another package switch back regular internet tariff print minimum amount money polycarp need pay download b++ compiler t milliseconds solution print integer -1 . first example polycarp buy first additional package 5 time buy second additional package download 120 bytes ( total <unknown> = 130 bytes ) <unknown> = 960 milliseconds ( 960 ≤ <unknown> ) spend 8·5 = 40 burl second example polycarp enough time download 10 bytes take <unknown> = 200 milliseconds equal upper constraint download time third example polycarp buy one first additional package one second additional package fourth example polycarp way download file time,"['binary search', 'implementation']",2300.0
883/D,game field represent a line n square cells cells packmen cells asterisk rest cells empty packmen eat asterisk game start choose a movement direction leave right packman game begin packmen simultaneously start move accord directions a packman ca n't change give direction a packman enter a cell contain asterisk packman immediately eat asterisk packman leave cell become empty packman move speed 1 cell per second a packman enter a border cell packman stop packmen interfere movement packmen ; one cell number packmen move directions task assign a direction packman eat maximal number asterisk multiple ways assign directions eat maximal number asterisk choose way minimize time first line contain integer number n ( 2 ≤ n ≤ 1 000 000 ) — number cells game field second line contain n character i - th character ' ' i - th cell empty i - th character ' * ' i - th cell contain asterisk i - th character ' p ' i - th cell contain a packman field contain least one asterisk least one packman print two integer number — maximal number asterisk packmen eat minimal time first example leftmost packman move right rightmost packman move leave asterisk eat last asterisk eat 4 second,"['binary search', 'dp', 'math']",2500.0
883/G,vasya a graph contain direct ( orient ) undirected ( non - oriented ) edge multiple edge a pair vertices vasya pick a vertex s graph vasya want create two separate plan : two plan undirected edge must become direct edge choose directions differ two plan help vasya find plan first line contain three integers n m s ( 2 ≤ n ≤ 3·105 1 ≤ m ≤ 3·105 1 ≤ s ≤ n ) — number vertices edge graph vertex vasya pick follow m line contain information graph edge line contain three integers ti ui vi ( 1 ≤ ti ≤ 2 1 ≤ ui vi ≤ n ui ≠ vi ) — edge type vertices connect edge ti = 1 edge direct go vertex ui vertex vi ti = 2 edge undirected connect vertices ui vi guarantee least one undirected edge graph first two line describe plan maximize number reachable vertices line three four describe plan minimize number reachable vertices a description plan start a line contain number reachable vertices second line a plan consist f symbols ' + ' ' - ' f number undirected edge initial graph print ' + ' j - th symbol string j - th undirected edge ( u v ) input orient u v. print ' - ' signify opposite direction ( v u ) consider undirected edge number order give input multiple solutions print,"['dfs and similar', 'graphs']",1900.0
884/A,recently luba buy a interest book know take t second read book luba want finish read fast work n next days number second luba spend work i - th day ai free time remain spend read help luba determine minimum number day finish read guarantee answer n't exceed n. remember 86400 second a day first line contain two integers n t ( 1 ≤ n ≤ 100 1 ≤ t ≤ 106 ) — number days time require read book second line contain n integers ai ( 0 ≤ ai ≤ 86400 ) — time luba spend work i - th day print minimum day luba finish read book guarantee answer n't exceed n,['implementation'],800.0
888/C,give a string s consist lowercase latin letter character c call k - dominant iff substring s length least k contain character c. find minimum k exist least one k - dominant character first line contain string s consist lowercase latin letter ( 1 ≤ |s| ≤ 100000 ) print one number — minimum value k exist least one k - dominant character,"['binary search', 'implementation', 'two pointers']",1400.0
893/C,"vova promise would never play computer game ... recently <unknown> — a well - known game develop company — publish newest game world <unknown> become really popular course vova start play try solve a quest task come a settlement name overcity spread a rumor vova know n character overcity character friends share information get also vova know bribe character start spread rumor ; i - th character want ci gold exchange spread rumor a character hear rumor tell friends start spread rumor friends ( free ) , quest finish n character know rumor minimum amount gold vova need spend order finish quest ? take a look note think n't understand problem completely first line contain two integer number n m ( 1 ≤ n ≤ 105 0 ≤ m ≤ 105 ) — number character overcity number pair friends second line contain n integer number ci ( 0 ≤ ci ≤ 109 ) — amount gold i - th character ask start spread rumor m line follow contain a pair number ( xi yi ) represent character xi yi friends ( 1 ≤ xi yi ≤ n xi ≠ yi ) guarantee pair list print one number — minimum amount gold vova spend order finish quest first example best decision bribe first character ( spread rumor fourth character fourth one spread fifth ) also vova bribe second third character know rumor second example vova bribe everyone third example optimal decision bribe first third fifth seventh ninth character","['dfs and similar', 'graphs', 'greedy']",1300.0
894/B,ralph a magic field divide n × m block say n row m columns field ralph put integer block however magic field n't always work properly work product integers row column equal k k either 1 -1 . ralph want figure number ways put number block a way magic field work properly two ways consider different exist least one block number first way second way different ask output answer modulo 1000000007 = 109 + 7 . note range number put block prove answer infinity line contain three integers n m k ( 1 ≤ n m ≤ 1018 k either 1 -1 ) print a single number denote answer modulo 1000000007 . first example way put -1 block second example way put 1 every block,"['combinatorics', 'math', 'number theory']",1800.0
895/D,byteland state university mark string length mark x consider better y string y lexicographically smaller x. recently bsu important test work vasya <unknown> mark a. hard teacher remember exact mark every student know mark b every student recieved mark strictly smaller b. vasya n't satisfy mark decide improve swap character string correspond mark many time like want know number different ways improve mark teacher n't notice something suspicious formally : give two string a b length need figure number different string c that:1 ) c obtain a swap character word c a permutation <unknown> ) string a lexicographically smaller <unknown> ) string c lexicographically smaller b. two string x y length true x lexicographically smaller y exist i x1 = y1 x2 = y2 ... xi - 1 = yi - 1 xi < yi since answer large need find answer modulo 109 + 7 . first line contain string a second line contain string b. string a b consist lowercase english letter lengths equal n't exceed 106 . guarantee a lexicographically smaller b. print one integer — number different string satisfy condition problem modulo 109 + 7 . first sample string abc obtain string acb bac bca cab cba larger abc smaller ddd answer 5 . second sample string obtain abcdef larger <unknown> answer 0,"['combinatorics', 'math', 'strings']",2100.0
895/E,vasya petya tire study decide play a game game begin vasya look array a consist n integers soon remember elements a game begin vasya close eye petya q action one two types:1 ) petya say 4 integers l1 r1 l2 r2 — boundaries two non - intersecting segment swap one random element [ l1 r1 ] segment another random element [ l2 r2 ] <unknown> ) petya ask vasya sum elements a [ l r ] segment vasya a mathematician answer petya mathematical expectation sum elements segment task write a program answer second type question vasya would word program print mathematical expectation sum elements a [ l r ] segment every second type query first line contain two integers n q ( 2 ≤ n ≤ 105 1 ≤ q ≤ 105 ) — number elements array number query need handle second line contain n integers ai ( 1 ≤ ai ≤ 109 ) — elements array next q line contain petya 's action type 1 2 . a type 1 action line contain 5 integers 1 l1 r1 l2 r2 ( 1 ≤ l1 ≤ r1 ≤ n 1 ≤ l2 ≤ r2 ≤ n ) a type 2 query line contain 3 integers 2 l r ( 1 ≤ l ≤ r ≤ n ) guarantee least one type 2 query segment [ l1 r1 ] [ l2 r2 ] n't common elements type 2 query print one real number — mathematical expectation sum elements segment answer consider correct absolute relative error n't exceed 10 - 4 — formally answer correct x jury 's answer y,['data structures'],2300.0
9/B,a misfortune fell poor student late exam rush a bus stop point ( 0 0 ) get a minibus drive along a straight line parallel axis ox direction increase x. poor student know follow : poor student want get university soon possible help choose bus stop get bus stop multiple choose bus stop closest university first line contain three integer number : 2 ≤ n ≤ 100 1 ≤ <unknown> vs ≤ 1000 . second line contain n non - negative integers ascend order : coordinate xi bus stop index i. guarantee x1 equal zero xn ≤ 105 . third line contain coordinate university integers xu yu exceed 105 absolute value line output answer problem — index optimum bus stop know students a special sort people <unknown> usually hurry 's surprise student 's speed higher speed minibus,"['brute force', 'geometry', 'implementation']",1200.0
9/C,one beautiful july morning a terrible thing happen mainframe : a mean virus megabyte somehow get access memory less mean sister hexadecimal load a huge amount n different natural number 1 n obtain total control energy plan fail reason simple : hexadecimal n't perceive information apart number write binary format mean a number a decimal representation contain character apart 0 1 store memory megabyte want know many number load successfully input data contain number n ( 1 ≤ n ≤ 109 ) output number — answer problem n = 10 answer include number 1 10,"['brute force', 'implementation', 'math']",1200.0
9/E,hexadecimal like draw draw many graph already direct recently start work a still - life « interest graph apples » undirected graph call interest vertices belong one cycle — a funny ring — belong cycle a funny ring a cycle go vertices moreover loop funny ring already draw apples graph edge clear connect rest vertices get interest graph a result answer contain minimal amount add edge furthermore answer lexicographically smallest one set edge ( x1 y1 ) ( x2 y2 ) ... ( xn yn ) xi ≤ yi lexicographically smaller set ( u1 v1 ) ( u2 v2 ) ... ( un vn ) ui ≤ vi provide sequence integers x1 y1 x2 y2 ... xn yn lexicographically smaller sequence u1 v1 u2 v2 ... un vn cope hexadecimal eat ... eat alive first line input data contain a pair integers n m ( 1 ≤ n ≤ 50 0 ≤ m ≤ 2500 ) — amount vertices edge respectively follow line contain pair number xi yi ( 1 ≤ xi yi ≤ n ) — vertices already connect edge initial graph may contain multiple edge loop first line output « yes » « » : possible construct interest graph answer « yes » second line output k — amount edge add initial graph finally output k line : pair vertices xj yj edge draw result may contain multiple edge loop k equal zero,"['dfs and similar', 'dsu', 'graphs']",2300.0
900/C,give a permutation p length n. remove one element permutation make number record maximum possible remind a sequence number a1 a2 ... ak element ai a record every integer j ( 1 ≤ j < i ) follow hold : aj < ai first line contain integer n ( 1 ≤ n ≤ 105 ) — length permutation second line contain n integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) — permutation integers distinct print integer — element remove make number record maximum possible multiple elements print smallest one first example element remove,"['brute force', 'data structures', 'math']",1700.0
901/D,give a connect undirected graph n vertices m edge vertices enumerate 1 n. give n integers c1 c2 ... cn - n n inclusive also guarantee parity cv equal parity degree vertex v. degree a vertex number edge connect write a weight - 2·n2 2·n2 ( inclusive ) edge a way vertex v sum weight edge connect vertex equal cv determine impossible first line contain two integers n m ( 2 ≤ n ≤ 105 n - 1 ≤ m ≤ 105 ) — number vertices number edge next line contain n integers c1 c2 ... cn ( - n ≤ ci ≤ n ) ci require sum weight edge connect vertex i. guarantee parity ci equal parity degree vertex i. next m line describe edge graph i - th line contain two integers ai bi ( 1 ≤ ai bi ≤ n ; ai ≠ bi ) mean i - th edge connect vertices ai bi guarantee give graph connect contain loop multiple edge solution print ` ` '' otherwise print ` ` yes '' m line i - th weight i - th edge wi ( - 2·n2 ≤ wi ≤ 2·n2 ),"['dfs and similar', 'graphs']",2700.0
903/E,"a string s consist n lowercase latin letter make k copy string thus obtain k identical string s1 s2 ... sk , string swap exactly two character ( character swap could identical different indices string ) give k string s1 s2 ... sk restore string s possible obtain string perform aforementioned operations note total length string give n't exceed 5000 ( <unknown> ≤ 5000 ) first line contain two integers k n ( 1 ≤ k ≤ 2500 2 ≤ n ≤ 5000 k · n ≤ 5000 ) — number string obtain length string next k line contain string s1 s2 ... sk consist exactly n lowercase latin letter print suitable string s -1 string n't exist first example s1 obtain swap second fourth character acab s2 obtain swap first second character get s3 swap third fourth character second example s1 obtain swap third fourth character <unknown> s2 — swap second fourth s3 — swap first third third example 's impossible obtain give string aforementioned operations","['brute force', 'implementation', 'strings']",2200.0
906/E,hurricane come berland suburbs <unknown> go check 's right favorite string <unknown> break a bite reverse non - intersecting substrings a photo string hurricane want restore original state use reverse minimum possible number substrings find substrings reverse give a string s — original state string string t — state string hurricane select k non - intersecting substrings t a way reverse substrings string equal s k minimum possible first line input contain string s second line contain string t. string length consist lowercase english letter 1 ≤ |s| = |t| ≤ 5·105 in first line print k — minimum number substrings reverse next output k line line contain two integers li ri mean reverse substring symbol number li symbol ri ( string 1 - indexed ) substrings n't intersect multiple answer print 's impossible restore string output -1,"['dp', 'strings']",3300.0
907/B,two bear play tic - tac - toe via mail 's bore play usual tic - tac - toe game a play modify version game rule game play follow field players make move turn first move a player put chip cell small field follow move restrictions : last move opposite player put chip cell coordinate ( xl yl ) small field next move do one cells small field coordinate ( xl yl ) example first move a player put chip lower leave cell central field second player next move put chip cell lower leave field ( pay attention first test case ) free cells require field player put chip empty cell field give current state game coordinate cell last move do find cells current player put chip a hare work a postman forest like foul bear sometimes change game field a bite current state game could unreachable however change cell last move do empty n't need find state unreachable output possible next move accord rule first 11 line contain descriptions table 9 row 9 columns divide 9 small field space empty line small field describe 9 character without space empty line character ` ` x '' ( ascii - code 120 ) mean cell occupy chip first player character ` ` o '' ( ascii - code 111 ) denote a field occupy chip second player character ` ` . '' ( ascii - code 46 ) describe empty cell line table contain two integers x y ( 1 ≤ x y ≤ 9 ) describe coordinate cell table last move do row table number columns number leave right 's guarantee cell last move do fill ` ` x '' ` ` o '' also 's guarantee least one empty cell 's guarantee current state game reachable output field format character ` ` ! '' ( ascii - code 33 ) position current player put chip cells modify first test case first player make a move lower leave cell central field second player put a chip cells lower leave field second test case last move do upper leave cell lower central field however cells upper leave field occupy second player put chip empty cell third test case last move do central cell central field current player put chip cell central field already occupy move anywhere pay attention state game unreachable,['implementation'],1400.0
909/B,give integer n. consider possible segment coordinate axis endpoints integer point coordinate 0 n inclusive ; want draw segment several layer layer segment n't overlap ( might touch endpoints though ) move segment a different location coordinate axis find minimal number layer use give n. input line contain a single integer n ( 1 ≤ n ≤ 100 ) output a single integer - minimal number layer require draw segment give n. example segment optimal arrangement layer n = 4,['math'],1300.0
910/A,a frog live axis ox need reach home point n. start point 1 . frog jump right a distance d. jump point x reach point x + a a integer 1 d. point 1 n know a lily flower frog jump point a lilies guarantee lilies point 1 n. determine minimal number jump frog need reach home point n point 1 . consider initially frog point 1 . frog reach home print -1 . first line contain two integers n d ( 2 ≤ n ≤ 100 1 ≤ d ≤ n - 1 ) — point frog want reach maximal length frog jump second line contain a string s length n consist zero ones a character string s equal zero correspond point lily flower case correspond point a lily flower guarantee first last character string s equal one frog reach home print -1 . case print minimal number jump frog need reach home point n point 1 . first example reach home two jump : first jump point 1 point 4 ( length jump three ) second jump point 4 point 8 ( length jump four ) second example frog reach home make need jump a distance three maximum length jump equal two,"['dfs and similar', 'dp', 'greedy', 'implementation']",800.0
911/B,'s new year 's eve soon ivan decide 's high time start set table ivan buy two cake cut piece : first cake cut a piece second one — b piece ivan know n people celebration ( include ) ivan set n plat cake think distribute cake plat ivan want a way follow condition meet : make guests happy ivan want distribute cake a way minimum number piece plate maximize formally ivan want know maximum possible number x distribute cake accord aforementioned condition plate contain least x piece cake help ivan calculate number x ! first line contain three integers n a b ( 1 ≤ a b ≤ 100 2 ≤ n ≤ a + b ) — number plat number piece first cake number piece second cake respectively print maximum possible number x ivan distribute cake a way plate contain least x piece cake first example one way distribute cake plat 1 cake second example two plat 3 4 piece first cake two plat 5 piece second cake minimal number piece 3,"['binary search', 'brute force', 'implementation']",1200.0
911/F,give unweighted tree n vertices n - 1 follow operations apply tree a single operation consist follow step : initial answer ( apply operations ) 0 . obviously n - 1 operations tree consist a single vertex calculate maximal possible answer achieve construct a sequence operations allow achieve answer ! first line contain one integer number n ( 2 ≤ n ≤ 2·105 ) — number vertices tree next n - 1 line describe edge tree form ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) guarantee give graph a tree first line print one integer number — maximal possible answer next n - 1 line print operations order apply format ai bi ci ai bi — pair leave choose current operation ( 1 ≤ ai bi ≤ n ) ci ( 1 ≤ ci ≤ n ci = ai ci = bi ) — choosen leaf remove tree current operation see examples better understand,"['dfs and similar', 'graphs', 'greedy', 'trees']",2400.0
911/G,give array a consist n integers process q query array ; query give four number l r x y denote every i l ≤ i ≤ r ai = x set ai equal y. print array query process first line contain one integer n ( 1 ≤ n ≤ 200000 ) — size array a. second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 100 ) — elements array a. third line contain one integer q ( 1 ≤ q ≤ 200000 ) — number query process q line follow i - th line contain four integers l r x y denote i - th query ( 1 ≤ l ≤ r ≤ n 1 ≤ x y ≤ 100 ) print n integers — elements array a change make,['data structures'],2500.0
912/A,"winter holiday demand christmas ball exceptionally high since 's already 2018 advance alchemy allow easy efficient ball creation utilize magic crystals grisha need obtain yellow green blue ball 's know produce a yellow ball one need two yellow crystals green — one yellow one blue a blue ball three blue crystals enough right a yellow b blue crystals grisha 's disposal find many additional crystals acquire order produce require number ball first line feature two integers a b ( 0 ≤ a b ≤ 109 ) denote number yellow blue crystals respectively grisha 's disposal next line contain three integers x y z ( 0 ≤ x y z ≤ 109 ) — respective amount yellow green blue ball obtain print a single integer — minimum number crystals grisha acquire addition first sample case grisha need five yellow four blue crystals create two yellow ball one green ball one blue ball , grisha need obtain two additional crystals : one yellow one blue",['implementation'],800.0
912/C,"a lot students spend winter holiday <unknown> vlad advance well ! three days already fuel <unknown> tangerines — leftovers new year celebration — <unknown> rat favorite <unknown> game play a hero name perun perun ultimate ability call ` ` thunderwrath '' instant activation enemy map ( n total ) lose health point a single - time effect also a restriction : activate moment time integer initial bounty kill enemy additionally increase second formally second t ability activate i - th enemy kill a result ( i.e health drop zero lower ) vlad earn units gold every enemy receive damage well heal multiple ways vlad interest detail n enemies know : also m health update vlad know : obviously vlad want maximize profit 's necessary could even wait years activate ability right second help determine exact second ( note must integer ) 0 ( inclusively ) + ∞ a single activation ability would yield vlad maximum possible amount gold print amount first line two integers give ( separate space ) — n m ( 1 ≤ n ≤ 105 0 ≤ m ≤ 105 ) second line three integers : ( ) follow n line three integers — , ( ) next m line contain three integers — , ( , ) guarantee one hearth change per second enemy : formally a b 1 ≤ a b ≤ m a ≠ b hold , output single integer — maximum amount gold vlad obtain apply ` ` thunderwrath '' exactly -1 amount infinitely large picture see health point enemy versus time sample case periods vlad kill one enemy mark yellow color periods vlad kill two enemies mark purple color first sample case vlad activate ability 50 - th second : enemies 2 3 die since would 40 50 health point correspondingly vlad earn 2 · ( 1000 + <unknown> ) = 3000 gold second sample case maximum amount health enemy 1 less damage deal ability hence enemy could kill anytime bounty increase 50 time maximum possible amount gold infinite","['brute force', 'greedy', 'sortings']",2500.0
912/D,"grisha celebrate new year ded moroz misha gift sasha a small rectangular pond size n × m divide cells size 1 × 1 inhabit tiny evil fish ( one fish per cell otherwise 'll <unknown> ! ) gift bundle also include a square scoop size r × r design fish lower - left corner scoop - net locate cell ( x y ) fish inside square ( x y ) ... ( x + r - 1 y + r - 1 ) get catch note scoop - net lie completely inside pond use unfortunately sasha skilled fish hence throw scoop randomly order frustrate sasha misha decide release k fish empty pond a way expect value number catch fish high possible help misha ! word put k fish pond distinct cells a way scoop - net place a random position among ( n - r + 1 ) · ( m - r + 1 ) possible position average number catch fish high possible line contain four integers n m r k ( 1 ≤ n m ≤ 105 1 ≤ r ≤ min ( n m ) 1 ≤ k ≤ min ( n·m 105 ) ) print a single number — maximum possible expect number catch fish answer consider correct absolute relative error exceed 10 - 9 . namely let answer a jury 's answer b. answer consider correct , first example put fish cells ( 2 1 ) ( 2 2 ) ( 2 3 ) case four possible position scoop - net ( highlight light green ) number fish inside equal two expect value","['data structures', 'graphs', 'greedy', 'shortest paths']",2100.0
912/E,opposite grisha 's nice behavior oleg though entire year disposal n't manage learn solve number theory problems past year 's instead ded moroz visit teammate andrew solemnly present a set n distinct prime number alongside a simple task : oleg find k - th smallest integer prime divisors set first line contain a single integer n ( 1 ≤ n ≤ 16 ) next line list n distinct prime number p1 p2 ... pn ( 2 ≤ pi ≤ 100 ) ascend order last line give a single integer k ( 1 ≤ k ) guarantee k - th smallest integer prime divisors set exceed 1018 . print a single line feature k - th smallest integer 's guarantee answer n't exceed 1018 . list number prime divisors inside { 2 3 5 } begin follow : ( 1 2 3 4 5 6 8 ... ) seventh number list ( 1 - indexed ) eight,"['binary search', 'dfs and similar', 'math', 'number theory', 'two pointers']",2400.0
913/D,"prepare exam schedule theory exam last exactly t milliseconds consist n problems either solve problem i exactly ti milliseconds ignore spend time n't need time rest solve a problem either unfortunately teacher consider problems easy thus assign integer ai every problem i mean problem i bring a point final score case solve ai problems overall ( include problem i ) formally suppose solve problems p1 p2 ... pk exam , final score s equal number value j 1 k k ≤ <unknown> guess real first problem exam already front therefore want choose a set problems solve exam maximize final score advance n't forget exam limit time must enough time solve choose problems exist different set problems lead maximum final score , first line contain two integers n t ( 1 ≤ n ≤ 2·105 ; 1 ≤ t ≤ 109 ) — number problems exam length exam milliseconds respectively next n line contain two integers ai ti ( 1 ≤ ai ≤ n ; 1 ≤ ti ≤ 104 ) problems number 1 n. first line output a single integer s — maximum possible final score second line output a single integer k ( 0 ≤ k ≤ n ) — number problems solve third line output k distinct integers p1 p2 ... pk ( 1 ≤ pi ≤ n ) — index problems solve order several optimal set problems may output first example solve problems 3 1 4 . case 'll spend 80 + 100 + 90 = 270 milliseconds fall within length exam 300 milliseconds ( even leave 30 milliseconds a rest ) problems 3 1 bring a point problem 4 wo n't 'll score two point second example length exam <unknown> enough solve even a single problem third example enough time solve problems 42 + 58 = 100 milliseconds hand solutions teacher a smile","['binary search', 'brute force', 'data structures', 'greedy', 'sortings']",1800.0
913/H,"generate real number s1 s2 ... sn follow : give real number x1 x2 ... xn interest probability si ≤ xi true i simultaneously show represent p q coprime integers , print value p·q - 1 modulo 998244353 . first line contain integer n ( 1 ≤ n ≤ 30 ) next n line contain real number x1 x2 ... xn give six digits decimal point ( 0 < xi ≤ n ) print a single integer answer problem first example seek probability 1 since sum i real number n't exceed 1 n't exceed i. second example probability x1 third example seek probability 3 / 8",['math'],3400.0
914/H,ember storm play a game first ember pick a label tree t n vertices degree every vertex d. storm pick two distinct vertices u v tree write label vertices path u v a sequence a1 a2 ... ak finally ember pick index i ( 1 ≤ i < k ) array perform one follow two operations exactly : ember win array <unknown> increase decrease otherwise storm win game describe tuple ( t u v i op ) op « flip » « negate » depend action ember choose last turn find number tuples occur ember storm play optimally play optimally multiple move guarantee win may play win move otherwise someone lose matter play may play possible move report answer modulo m. input consist a single line contain three integers n d m ( 2 ≤ n ≤ 200 1 ≤ d < n 1 ≤ m ≤ 2·109 ) print a single number — number possible tuples ember storm play describe modulo m. first sample case one possible tree two possible paths 1 2 2 1 . paths i 1 op take possibilities therefore answer 4 . second sample possible tree third sample three possible tree,"['combinatorics', 'dp', 'trees']",3400.0
915/G,let 's call array a size n coprime iff gcd ( a1 a2 ... ) = 1 gcd greatest common divisor arguments give two number n k. i ( 1 ≤ i ≤ k ) determine number coprime array a size n every j ( 1 ≤ j ≤ n ) 1 ≤ aj ≤ i. since answer large calculate modulo 109 + 7 . first line contain two integers n k ( 1 ≤ n k ≤ 2·106 ) — size desire array maximum upper bind elements respectively since print 2·106 number may take a lot time output answer a way : let bi number coprime array elements range [ 1 i ] take modulo 109 + 7 . print take modulo 109 + 7 . denote bitwise xor operation ( ^ c++ java xor pascal ) explanation example : since number coprime array large list array non - coprime contain elements range [ 1 i ] : i = 1 array coprime b1 = 1 . i = 2 array [ 2 2 2 ] coprime b2 = 7 . i = 3 array [ 2 2 2 ] [ 3 3 3 ] coprime b3 = 25 . i = 4 array [ 2 2 2 ] [ 3 3 3 ] [ 2 2 4 ] [ 2 4 2 ] [ 2 4 4 ] [ 4 2 2 ] [ 4 2 4 ] [ 4 4 2 ] [ 4 4 4 ] coprime b4 = 55,"['math', 'number theory']",2300.0
916/A,jamie love sleep one day decide need wake exactly hh : mm however hat wake want make wake less painful set alarm a lucky time press snooze button every x minutes hh : mm reach wake want know smallest number time need press snooze button a time consider lucky contain a digit ' 7 ' example 13 : 07 17 : 27 lucky 00 : 48 21 : 34 lucky note necessary time set alarm wake - up time day guarantee a lucky time jamie set wake hh : mm formally find smallest possible non - negative integer y time representation time x·y minutes hh : mm contain digit ' 7 ' jamie use 24 - hours clock 23 : 59 come 00 : 00 . first line contain a single integer x ( 1 ≤ x ≤ 60 ) second line contain two two - digit integers hh mm ( 00 ≤ hh ≤ 23 00 ≤ mm ≤ 59 ) print minimum number time need press button first sample jamie need wake <unknown> . set alarm 11:17 . would press snooze button alarm ring 11:17 <unknown> . second sample jamie set alarm exactly <unknown> lucky,"['brute force', 'implementation', 'math']",900.0
916/B,"jamie prepare a codeforces round get idea a problem know solve help write a solution follow problem : find k integers sum two power number equal number n largest integer answer small possible may multiple answer ask output lexicographically largest one clear consider integer sequence length k ( a1 a2 ... ak ) give a value sequence among sequence ( s ) minimum y value output one lexicographically largest definitions power lexicographical order see note first line consist two integers n k ( 1 ≤ n ≤ 1018 1 ≤ k ≤ 105 ) — require sum length sequence output ` ` '' ( without quote ) a single line exist sequence otherwise output ` ` yes '' ( without quote ) first line k number separate space second line — require sequence guarantee integers answer sequence fit range [ - 1018 1018 ] sample <unknown> + 23 + 22 + 21 + 20 = 8 + 8 + 4 + 2 + 1 = <unknown> like ( 3 3 2 0 1 ) ( 0 1 2 3 3 ) lexicographically largest answer like ( 4 1 1 1 0 ) minimum y value sample 2 : show exist a sequence length 2 . sample 3 : power 2 : x > 0 2x = <unknown> · ... · 2 ( x time ) x = 0 2x = 1 . x < 0 , lexicographical order : give two different sequence length ( a1 a2 ... ak ) ( b1 b2 ... bk ) first one smaller second one lexicographical order ai < bi first i ai bi differ","['bitmasks', 'greedy', 'math']",2000.0
917/E,know eleven special abilities thus hopper convince close gate upside world mind upside monsters like move worlds go attack hopper eleven order make stop monsters live vines vines form a tree n vertices number 1 n. 's a lowercase english letter write tunnel ( edge ) upside a magical world m type monsters upside number 1 m. type monster a special word give power special word type i si q monsters upside one a junction ( vertex ) go junction monster type k go junction i junction j power gain number time see special world ( sk ) consecutively tunnel formally : f ( i j ) string get concatenate letter write tunnel shortest path i j power monster gain number occurrences sk f ( i j ) hopper eleven want get prepare monster want know power monster gain move first line input contain three integers n m q ( 2 ≤ n ≤ 105 1 ≤ m q ≤ 105 ) next n - 1 line contain tunnel ( edge ) line contain two integers v u ( 1 ≤ v u ≤ n v ≠ u ) a lowercase english letter c mean 's a tunnel connect junctions v u write c guarantee give graph a tree next m line contain special word i - th line contain a single string si ( 1 ≤ |si| ≤ 105 ) consist lowercase english letter guarantee |s1| + |s2| + ... + <unknown> ≤ 105 ) next q line contain monsters line contain three integers i j k ( 1 ≤ i j ≤ n i ≠ j 1 ≤ k ≤ m ) mean a monster type k go junction number i junction number j. print q line i - th line contain a single integer power i - th monster gain move,"['data structures', 'strings', 'trees']",3400.0
920/C,array a consist n integers integer 1 n appear exactly array indices i ( 1 ≤ i ≤ n - 1 ) possible swap i - th element ( i + 1 ) -th indices possible may perform number swap operations order limit number time swap i - th element ( i + 1 ) -th ( position forbid ) make array sort ascend order perform sequence swap operations ? first line contain one integer n ( 2 ≤ n ≤ 200000 ) — number elements array second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 200000 ) — elements array integer 1 n appear exactly third line contain a string n - 1 character character either 0 1 . i - th character 1 swap i - th element ( i + 1 ) -th number time otherwise forbid swap i - th element ( i + 1 ) -th possible sort array ascend order use sequence swap allow make print yes otherwise print first example may swap a3 a4 swap a4 a5,"['dfs and similar', 'greedy', 'math', 'sortings', 'two pointers']",1400.0
923/C,"alice a important message m consist non - negative integers want keep secret eve alice know <unknown> secure cipher one - time pad alice generate a random key k length equal message 's length alice compute bitwise xor element message key ( denote bitwise xor operation ) store encrypt message a. alice smart like alice example alice may want store a message m = ( 0 15 9 18 ) generate a key k = ( 16 7 6 3 ) encrypt message thus a = ( 16 8 15 17 ) alice realise store key encrypt message alice send key k bob delete copy alice smart really like alice bob realise encrypt message secure long key secret bob thus randomly permute key store bob think way even eve get encrypt message key able read message bob smart n't like bob example bob may instance select a permutation ( 3 4 1 2 ) store permute key p = ( 6 3 16 7 ) one year pass alice want decrypt message bob realise impossible permute key randomly message lose forever mention bob n't smart ? bob want <unknown> least information message since smart ask help know encrypt message a permute key p. lexicographically smallest message could result give encrypt text ? precisely give a p find lexicographically smallest message o exist a permutation π every i. note sequence s lexicographically smaller sequence t index i si < ti j < i condition sj = tj hold first line contain a single integer n ( 1 ≤ n ≤ 300000 ) length message second line contain n integers a1 a2 ... ( 0 ≤ ai < 230 ) represent encrypt message third line contain n integers p1 p2 ... pn ( 0 ≤ pi < 230 ) represent permute encryption key output a single line n integers lexicographically smallest possible message o. note elements non - negative first case solution ( 10 3 28 ) since , possible permutations key yield message ( 25 6 10 ) ( 25 3 15 ) ( 10 21 10 ) ( 15 21 15 ) ( 15 6 28 ) lexicographically larger solution","['data structures', 'greedy', 'strings', 'trees']",1800.0
923/D,alice a string consist character ' a ' ' b ' ' c ' bob use follow transition substring string order number time : note a substring one consecutive character give query determine whether possible obtain target string source first line contain a string s ( 1 ≤ |s| ≤ 105 ) second line contain a string t ( 1 ≤ |t| ≤ 105 ) string consist uppercase english letter ' a ' ' b ' ' c ' third line contain number query q ( 1 ≤ q ≤ 105 ) follow q line describe query i - th line contain four space separate integers ai bi ci di represent i - th query : possible create t [ ci .. di ] s [ ai .. bi ] apply transition finite amount time ? u [ x .. y ] a substring u begin index x ( index 1 ) end index y. particular u [ 1 .. <unknown> ] whole string u. guarantee 1 ≤ a ≤ b ≤ |s| 1 ≤ c ≤ d ≤ |t| print a string q character i - th character ' 1 ' answer i - th query positive ' 0 ' otherwise first query achieve result instance use transition third query ask change aab a — case able get rid character ' b ',"['implementation', 'strings']",2500.0
923/E,"a number x initially write a blackboard repeat follow action a fix amount time : determine distribution final number give distribution initial number number step first line contain two integers n ( 1 ≤ n ≤ 105 ) — maximum number write blackboard — m ( 0 ≤ m ≤ 1018 ) — number step perform second line contain n + 1 integers p0 p1 ... pn ( 0 ≤ pi < 998244353 ) pi describe probability start number i. express probability irreducible fraction p / q , guarantee sum <unknown> equal 1 ( modulo 998244353 ) output a single line n + 1 integers ri probability final number m step i. prove probability may always express irreducible fraction p / q. ask output first case start number 2 . one step 0 1 2 probability <unknown> second case number remain 2 probability 1/9 probability 1/9 stay 2 first round change 1 next probability <unknown> change 1 first round stay second case final integer 0",['math'],3100.0
924/F,call a positive integer x a k - beautiful integer possible split multiset digits decimal representation two subsets difference sum digits one subset sum digits subset less equal k. digit belong exactly one subset split n query query describe three integers l r k mean ask many integers x l r ( inclusive ) k - beautiful first line contain a single integer n ( 1 ≤ n ≤ 5·104 ) indicate number query next n line describe a query contain three integers l r k ( 1 ≤ l ≤ r ≤ 1018 0 ≤ k ≤ 9 ) query print a single number — answer query 1 ≤ x ≤ 9 integer x k - beautiful x ≤ k. 10 ≤ x ≤ 99 integer x = <unknown> + b k - beautiful |a - b| ≤ k a b integers 0 9 <unknown> k - beautiful k ≥ 1,['dp'],3200.0
925/B,"one department software company $$$ n $$$ servers different specifications servers index consecutive integers $$$ 1 $$$ $$$ n $$$ suppose specifications $$$ j $$$ -th server may express a single integer number $$$ c_j $$$ artificial resource units order production work need deploy two service $$$ s_1 $$$ $$$ s_2 $$$ process incoming request use servers department process incoming request service $$$ s_i $$$ take $$$ x_i $$$ resource units describe situation happen advance company service may deploy use one server several servers simultaneously service $$$ s_i $$$ deploy use $$$ k_i $$$ servers load divide equally servers server require $$$ x_i / k_i $$$ ( may a fractional number ) resource units server may leave unused use deploy exactly one service ( two simultaneously ) service use resources server provide determine possible deploy service use give servers yes determine servers use deploy service first line contain three integers $$$ n $$$ $$$ x_1 $$$ $$$ x_2 $$$ ( $$$ 2 \leq n \leq 300\,000 $$$ $$$ 1 \leq x_1 x_2 \leq 1000000000 $$$ ) — number servers department may use resource units requirements service second line contain $$$ n $$$ space - separated integers $$$ c_1 c_2 \ldots c_n $$$ ( $$$ 1 \leq c_i \leq 1000000000 $$$ ) — number resource units provide servers impossible deploy service use give servers print word ` ` '' ( without quote ) otherwise print word ` ` yes '' ( without quote ) second line print two integers $$$ k_1 $$$ $$$ k_2 $$$ ( $$$ 1 \leq k_1 k_2 \leq n $$$ ) — number servers use service third line print $$$ k_1 $$$ integers indices servers use first service fourth line print $$$ k_2 $$$ integers indices servers use second service index may appear twice among indices print last two line several possible answer allow print first sample test servers 1 2 6 provide $$$ 8 / 3 = 2 ( 6 ) $$$ resource units servers 5 4 provide $$$ 16 / 2 = 8 $$$ resource units second sample test first server provide $$$ 20 $$$ resource units remain servers provide $$$ 32 / 3 = 10 ( 6 ) $$$ resource units","['binary search', 'implementation', 'sortings']",1700.0
926/E,"give a sequence positive integers a1 a2 ... , possible perform follow operation : find a pair equal consecutive elements one pair find leftmost ( smallest indices elements ) two integers equal x delete insert a single integer x + 1 place way number elements sequence decrease 1 step stop perform operation pair equal consecutive elements example initial sequence [ 5 2 1 1 2 2 ] first operation get [ 5 2 2 2 2 ] second — [ 5 3 2 2 ] third — [ 5 3 3 ] finally fourth get [ 5 4 ] equal consecutive elements leave sequence stop process determine final sequence stop perform operation first line contain a single integer n ( 2 ≤ n ≤ 2·105 ) — number elements sequence second line contain sequence integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) first line print a single integer k — number elements sequence stop perform operation second line print k integers — sequence stop perform operation first example describe statements second example initial sequence [ 1000000000 1000000000 1000000000 1000000000 ] first operation sequence equal [ 1000000001 1000000000 1000000000 ] second operation sequence [ 1000000001 1000000001 ] third operation sequence [ <unknown> ] third example two equal consecutive elements initially sequence change",['data structures'],1900.0
928/C,polycarp currently develop a project vaja language use a popular dependency management system call vamen vamen 's point view vaja project <unknown> treat project simplicity a project vaja <unknown> non - empty name consist lowercase latin letter length exceed 10 version — positive integer 1 106 . project ( keep mind determine name version ) might depend project sure cyclic dependencies 're give a list project descriptions first give project one develop polycarp moment help polycarp determine project project depend ( directly via a certain chain ) 's possible polycarp 's project depend two different versions project case collision resolve apply i.e project system choose version minimize distance polycarp 's project several options <unknown> ( maximum version ) prefer version consider actual ; versions dependencies ignore formal choose a set project minimum possible size follow condition hold : output polycarp 's project 's dependencies ( polycarp 's project <unknown> print ) lexicographical order first line contain integer n ( 1 ≤ n ≤ 1 000 ) — number project vaja follow line contain project descriptions project describe a line consist name version separate space next line give number direct dependencies ( 0 n - 1 ) dependencies ( one a line ) arbitrary order dependency specify name version project also give arbitrary order first always polycarp 's project descriptions separate one empty line refer sample better understand 's guarantee cyclic dependencies output polycarp 's project 's dependencies lexicographical order first sample give pic arrow a b mean b directly depend a. project polycarp 's project « a » ( version 3 ) depend paint black second sample give pic arrow a b mean b directly depend a. project polycarp 's project « codehorses » ( version 5 ) depend paint black note « extra 1 » choose instead « extra 3 » since « mashadb 1 » dependencies ignore due « mashadb 2 »,"['graphs', 'implementation']",1900.0
930/D,"consider follow game two players one white token number black tokens token place a plane a point integer coordinate x y. players take turn make move white start turn a player move tokens color 1 , leave right black player choose directions token independently a turn white player white token a point a black token locate constraints locations tokens : position black tokens coincide a turn black player initially white token point black point moment white player ca n't make a move lose white player make <unknown> move win solve follow problem give initial position black tokens guarantee initially position distinct many place white token locate initially players play optimally black player win ? first line contain a single integer n ( 1 ≤ n ≤ 105 ) — number black point ( i + 1 ) -th line contain two integers xi yi ( - 105 ≤ xi yi ≤ 105 ) — coordinate point i - th black token initially locate guarantee initial position black tokens distinct print number point white token locate initially players play optimally black player win first second examples initial position black tokens show black point possible position white token ( black player win ) show white point first example : second example : third example white tokens locate inner square 2 × 2 make black player win","['data structures', 'implementation']",2500.0
933/A,"a dragon symbolize wisdom power wealth lunar new year 's day people model a dragon bamboo strip clothe raise rods hold rods high low resemble a fly dragon a performer hold rod low represent a 1 one hold high represent a 2 . thus line performers represent a sequence a1 a2 ... , little tommy among would like choose interval [ l r ] ( 1 ≤ l ≤ r ≤ n ) reverse al al + 1 ... ar length longest non - decreasing subsequence new sequence maximum a non - decreasing subsequence a sequence indices p1 p2 ... pk p1 < p2 < ... < pk ap1 ≤ ap2 ≤ ... ≤ apk length subsequence k. first line contain integer n ( 1 ≤ n ≤ 2000 ) denote length original sequence second line contain n space - separated integers describe original sequence a1 a2 ... ( 1 ≤ ai ≤ 2 i = 1 2 ... n ) print a single integer mean maximum possible length longest non - decreasing subsequence new sequence first example reverse [ 2 3 ] array become [ 1 1 2 2 ] length longest non - decreasing subsequence 4 . second example reverse [ 3 7 ] array become [ 1 1 1 1 2 2 2 2 2 1 ] length longest non - decreasing subsequence 9",['dp'],1800.0
933/E,east west home best 's family reunion <unknown> necessity lunar new year celebration put a position reunion dinner little tommy play a game family a concise <unknown> game : obviously every game end n - 1 descensions please share solution game lowest cost first line contain one integer n ( 1 ≤ n ≤ 3·105 ) second line contain n space - separated integers p1 p2 ... pn ( 0 ≤ pi ≤ 109 i = 1 2 ... n ) first line print one integer number descensions m ( 0 ≤ m ≤ n - 1 ) next m line print descensions chronologically precisely line next m line print one integer i ( 1 ≤ i < n ) represent a <unknown> would operate pi pi + 1 descensions could utilize top bottom many possible solutions reach minimal cost print first sample one possible best solution cost 1 + 1 = 2 . second sample one possible best solution cost 1 + 1 + 1 = 3,['dp'],3200.0
935/D,"ancient egyptians know use a large set symbols write wall temples fafa fifa go one temples find two non - empty word s1 s2 equal lengths wall temple write one since temple ancient symbols word erase symbols set equal probability position erase symbol fifa challenge fafa calculate probability s1 lexicographically greater s2 help fafa task ? know i. e. m distinct character egyptians ' alphabet problem character denote integers 1 m alphabet order a word x lexicographically greater a word y length word position word x a larger character word y. prove probability equal fraction p q coprime integers , print answer value i. e. a non - negative integer less 109 + 7 , mean a b give remainder divide m. first line contain two integers n m ( 1 ≤ n m ≤ 105 ) — length two word size alphabet respectively second line contain n integers a1 a2 ... ( 0 ≤ ai ≤ m ) — symbols s1 ai = 0 symbol position i erase third line contain n integers represent s2 format s1 print value p q coprime answer problem first sample first word convert ( 1 ) ( 2 ) second option one make lexicographically larger second word , answer problem <unknown> , second example replacement zero second word make first one lexicographically larger , answer problem 0",['math'],1900.0
939/B,dima a hamsters farm soon n hamsters grow dima sell a city nearby hamsters transport box box completely full hamsters bore 's box completely full hamsters dima buy box a factory factory produce box k kinds box i - th kind contain ai hamsters dima buy amount box buy box one kind get a <unknown> discount course dima would buy box a way box completely fill hamsters transport city place hamsters dima leave farm find many box type dima buy transport maximum number hamsters first line contain two integers n k ( 0 ≤ n ≤ 1018 1 ≤ k ≤ 105 ) — number hamsters grow dima 's farm number type box factory produce second line contain k integers a1 a2 ... ak ( 1 ≤ ai ≤ 1018 i ) — capacities box output two integers : type box dima buy number box type dima buy type box number 1 k order give input many correct answer output,['implementation'],1000.0
939/E,give a multiset s consist positive integers ( initially empty ) two kind query : first line contain a single integer q ( 1 ≤ q ≤ 5·105 ) — number query next q line contain a description query query type 1 two integers 1 x give x ( 1 ≤ x ≤ 109 ) a number add s. 's guarantee x less number s. query type 2 a single integer 2 give 's guarantee first query type 1 i. e. s empty a query type 2 come output answer query second type order query give input number print separate line answer consider correct answer absolute relative error greater 10 - 6 . formally let answer a jury 's answer b. answer consider correct,"['binary search', 'greedy', 'two pointers']",1800.0
939/F,arkady want a dinner return a shop buy a <unknown> cutlet need fry cutlet fry 2n second particular fry n second one side n second side arkady already get a fry pan turn fire understand maybe wo n't able flip cutlet exactly n second begin cook arkady busy sort sticker pack favorite messenger flip cutlet periods time namely k periods time i - th interval time li second start cook till ri second inclusive arkady decide 's require flip cutlet exactly middle cook instead flip several time a way cutlet fry exactly n second one side n second side total help arkady find 's possible cook cutlet able flip cutlet give periods time ; yes find minimum number flip need cook cutlet first line contain two integers n k ( 1 ≤ n ≤ 100 000 1 ≤ k ≤ 100 ) — number second cutlet cook side number periods time arkady flip next k line contain descriptions intervals line contain two integers li ri ( 0 ≤ li ≤ ri ≤ 2·n ) mean arkady flip cutlet moment start li second begin cook finish ri second begin cook particular li = ri arkady flip cutlet moment li = ri 's guarantee li > ri - 1 2 ≤ i ≤ k. output ` ` hungry '' arkady wo n't able fry cutlet exactly n second one side exactly n second side otherwise output ` ` full '' first line minimum number time flip cutlet second line first example arkady flip cutlet time moment 3 second start cook time moment 13 second start cook second example arkady flip cutlet 10 second start cook,"['data structures', 'dp']",2400.0
940/F,come home fell unpleasant smell come ? give array a. answer follow query : mex a multiset number smallest non - negative integer set note problem elements a positive mean c0 = 0 0 never answer query second type first line input contain two integers n q ( 1 ≤ n q ≤ 100 000 ) — length array number query respectively second line input contain n integers — a1 a2 ... ( 1 ≤ ai ≤ 109 ) next q line describe a single query first type query describe three integers ti = 1 li ri 1 ≤ li ≤ ri ≤ n — bound subarray second type query describe three integers ti = 2 pi xi 1 ≤ pi ≤ n index element must change 1 ≤ xi ≤ 109 new value query first type output a single integer — mex { c0 c1 ... <unknown> } subarray first query consist single element — 1 . subarray second query consist four 2s one 3 two 1s subarray fourth query consist three 1s three 2s one 3,"['brute force', 'data structures']",2600.0
946/A,give a sequence a consist n integers may partition sequence two sequence b c a way every element belong exactly one sequence let b sum elements belong b c sum elements belong c ( sequence empty sum 0 ) maximum possible value b - c ? first line contain one integer n ( 1 ≤ n ≤ 100 ) — number elements a. second line contain n integers a1 a2 ... ( - 100 ≤ ai ≤ 100 ) — elements sequence a. print maximum possible value b - c b sum elements sequence b c sum elements sequence c. first example may choose b = { 1 0 } c = { - 2 } b = 1 c = - 2 b - c = 3 . second example choose b = { 16 23 16 15 42 8 } c = { } ( empty sequence ) b = 120 c = 0 b - c = 120,['greedy'],800.0
946/G,call array almost increase erase one element array become strictly increase ( every element <unknown> greater every element ) give array a consist n elements allow replace element integer number ( may number time need ) minimum number replacements perform order make array almost increase ? first line contain one integer n ( 2 ≤ n ≤ 200000 ) — number elements a. second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — array a. print minimum number replace perform a almost increase,"['data structures', 'dp']",2500.0
950/B,hacker zhorik want decipher two secret message intercept yesterday yeah message a sequence encrypt block consist several bytes information zhorik know message archive contain one file zhorik know archive transfer network : archive consist k file size l1 l2 ... lk bytes i - th file split one block bi 1 bi 2 ... bi mi ( total length block bi 1 + bi 2 + ... + bi mi equal length file li ) block transfer network maintain order file archive zhorik think two message contain archive total lengths equal however file split block different ways two message give lengths block two message help zhorik determine maximum number file could archive zhorik 's assumption correct first line contain two integers n m ( 1 ≤ n m ≤ 105 ) — number block first second message second line contain n integers x1 x2 ... xn ( 1 ≤ xi ≤ 106 ) — length block form first message third line contain m integers y1 y2 ... ym ( 1 ≤ yi ≤ 106 ) — length block form second message guarantee x1 + ... + xn = y1 + ... + ym also guarantee x1 + ... + xn ≤ 106 . print maximum number file intercept array could consist first example maximum number file archive 3 . example possible archive three file size 2 + 5 = 7 15 = 3 + 1 + 11 = 8 + 2 + 4 + 1 4 + 4 = 8 . second example possible archive contain two file size 1 110 = 10 + 100 = 100 + 10 . note order file keep transfer archive network ca n't say three file size 1 10 100 . third example possibility archive contain a single file size 4,"['greedy', 'implementation']",1100.0
954/A,"mikhail walk a 2d plane go either right give a sequence mikhail 's move think sequence long want make short possible give sequence move describe character u move right describe character r. mikhail replace pair consecutive move ru ur a diagonal move ( describe character d ) , go replacements pair consecutive move ru ur leave problem print minimum possible length sequence move replacements first line input contain one integer n ( 1 ≤ n ≤ 100 ) — length sequence second line contain sequence consist n character u r. print minimum possible length sequence move replacements do first test shorten sequence move may <unknown> ( length 3 ) second test shorten sequence move <unknown> ( length 13 )",['implementation'],800.0
954/D,little town nsk consist n junctions connect m bidirectional roads road connect two distinct junctions two roads connect pair junctions possible get junction junction roads distance two junctions equal minimum possible number roads a path order improve transportation system city council ask mayor build one new road problem mayor buy a wonderful new car really enjoy a ride home locate near junction s work locate near junction t. thus want build a new road a way distance two junctions wo n't decrease assign a task compute number pair junctions connect road new road two junctions build distance s t wo n't decrease <unknown> line input contain integers n m s t ( 2 ≤ n ≤ 1000 1 ≤ m ≤ 1000 1 ≤ s t ≤ n s ≠ t ) — number junctions number roads nsk well indices junctions <unknown> home work locate respectively i - th follow m line contain two integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) mean road connect junctions ui vi directly guarantee a path two junctions two roads connect pair junctions print one integer — number pair junctions connect a direct road build a road two junctions wo n't decrease distance junctions s t,"['dfs and similar', 'graphs', 'shortest paths']",1600.0
955/D,jenya recently acquire quite a useful tool — k - scissors cut string generally use cut two non - intersecting substrings length k arbitrary string s ( length least 2·k order perform operation ) concatenate afterwards ( preserve initial order ) example help 2 - scissors cut ab de abcde concatenate <unknown> ab bc since 're intersect 's a nice idea test tool use practice look paper jenya come two string s t. question whether possible apply scissor string s result concatenation contain t a substring ? first line contain three integers n m k ( 2 ≤ m ≤ 2·k ≤ n ≤ 5·105 ) — length s length t aforementioned scissor ' parameter correspondingly next two line feature s t consist lowercase latin letter answer print « » otherwise print « yes » two integers l r denote index <unknown> substrings start ( 1 - indexed ) several possible answer output first sample case cut two substrings start 1 5 . result string baaaab contain aaaa a substring second sample case result string <unknown>,"['brute force', 'strings']",2600.0
958/D1,rebel fleet run consist m ship currently gather around a single planet a second ago <unknown> powerful empire fleet appear solar system rebel need escape hyperspace order spread fleet captain ship independently come coordinate ship jump obsolete navigation system use rebel coordinate give value arithmetic expression form plan future resistance movement princess heidi need know ship many ship go end coordinate jump hope ! first line input contain a single integer m ( 1 ≤ m ≤ 200 000 ) – number ship next m line describe one jump coordinate give arithmetic expression expression form ( a+b ) <unknown> namely consist : open parenthesis ( a positive integer a two decimal digits a plus sign + a positive integer b two decimal digits a close parenthesis ) a slash / a positive integer c two decimal digits print a single line consist m space - separated integers i - th integer equal number ship whose coordinate equal i - th ship ( include i - th ship ) sample testcase second third ship end coordinate 3 . note problem two versions – easy hard,['math'],1400.0
960/H,santa infinite number candy $$$ m $$$ flavour give a root tree $$$ n $$$ vertices root tree vertex $$$ 1 $$$ vertex contain exactly one candy $$$ i $$$ -th vertex a candy flavour $$$ f_i $$$ sometimes santa fear candy flavour $$$ k $$$ melt choose vertex $$$ x $$$ randomly send subtree $$$ x $$$ bakers a replacement a replacement candy flavour $$$ k $$$ replace a new candy flavour candy flavour $$$ k $$$ leave unchanged replacement tree restore actual cost replace one candy flavour $$$ k $$$ $$$ c_k $$$ ( give $$$ k $$$ ) baker keep price fix order make calculation simple every time a subtree come a replacement baker charge $$$ c $$$ matter subtree flavour suppose a give flavour $$$ k $$$ probability santa choose a vertex replacement vertices need find expect value error calculate cost replacement flavour $$$ k $$$ error calculate cost define follow $$$ $$$ <unknown> e ( k ) = \ ( actual <unknown> – \ <unknown> <unknown> <unknown> <unknown> bakers ) ^ 2 $$$ $$$ note actual cost cost replacement one candy flavour $$$ k $$$ multiply number candy subtree also sometimes santa may wish replace a candy vertex $$$ x $$$ a candy flavour pocket need handle two type operations : first line input contain four integers $$$ n $$$ ( $$$ 2 \leqslant n \leqslant 50000 $$$ ) $$$ m $$$ $$$ q $$$ $$$ c $$$ ( $$$ 1 \leqslant m q \leqslant 50000 $$$ $$$ 0 \leqslant c \leqslant 1000000 $$$ ) — number nod total number different flavour candy number query price charge bakers replacement respectively second line contain $$$ n $$$ integers $$$ f_1 f_2 \dots f_n $$$ ( $$$ 1 \leqslant f_i \leqslant m $$$ ) $$$ f_i $$$ initial flavour candy $$$ i $$$ -th node third line contain $$$ n - 1 $$$ integers $$$ p_2 p_3 \dots p_n $$$ ( $$$ 1 \leqslant p_i \leqslant n $$$ ) $$$ p_i $$$ parent $$$ i $$$ -th node next line contain $$$ m $$$ integers $$$ c_1 c_2 \dots c_m $$$ ( $$$ 1 \leqslant c_i \leqslant 100 $$$ ) $$$ c_i $$$ cost replace one candy flavour $$$ i $$$ next $$$ q $$$ line describe query line start integer $$$ t $$$ ( $$$ 1 \leqslant t \leqslant 2 $$$ ) — type query $$$ t = 1 $$$ line describe a query first type two integers $$$ x $$$ $$$ w $$$ follow ( $$$ 1 \leqslant x \leqslant n $$$ $$$ 1 \leqslant w \leqslant m $$$ ) mean santa replace candy vertex $$$ x $$$ flavour $$$ w $$$ otherwise $$$ t = 2 $$$ line describe a query second type integer $$$ k $$$ ( $$$ 1 \leqslant k \leqslant m $$$ ) follow mean print expect value error calculate cost replacement a give flavour $$$ k $$$ vertices index $$$ 1 $$$ $$$ n $$$ vertex $$$ 1 $$$ root output answer query second type a separate line answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ checker program consider answer correct $$$ \frac { |a - b| } { max ( 1 b ) } \leqslant 10^ { -6 } $$$ $$$ 1 $$$ -st query error calculate cost replacement flavour $$$ 1 $$$ vertex $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ choose $$$ 66 ^ 2 $$$ $$$ 66 ^ 2 $$$ $$$ ( -7 ) ^2 $$$ respectively since probability choose vertex therefore expect value error $$$ \frac { 66 ^ 2 + 66 ^ 2 + ( -7 ) ^2 } { 3 } $$$ similarly $$$ 2 $$$ -nd query expect value error $$$ \frac { 41 ^ 2 + ( -7 ) ^2 + ( -7 ) ^2 } { 3 } $$$ $$$ 3 $$$ -rd query flavour vertex $$$ 2 $$$ change $$$ 1 $$$ $$$ 3 $$$ $$$ 4 $$$ -th query expect value error $$$ \frac { ( -7 ) ^2 + ( -7 ) ^2 + ( -7 ) ^2 } { 3 } $$$ similarly $$$ 5 $$$ -th query expect value error $$$ \frac { 89 ^ 2 + 41 ^ 2 + ( -7 ) ^2 } { 3 } $$$,"['data structures', 'trees']",3100.0
962/E,cities byteland berland locate axis $$$ ox $$$ addition axis also dispute cities belong countries opinion thus line $$$ ox $$$ three type cities : recently project bnet launch — a computer network a new generation task countries connect cities network country connect countries agree connect pair cities bnet cable a way : thus necessary choose a set pair cities connect cable a way condition satisfy simultaneously cable allow bi - directional data transfer cable connect exactly two distinct cities cost lay a cable one city another equal distance find minimum total cost lay a set cable two subsets cities ( byteland dispute cities berland dispute cities ) connect city a point line $$$ ox $$$ technically possible connect cities $$$ a $$$ $$$ b $$$ a cable city $$$ c $$$ ( $$$ a < c < b $$$ ) connect cable $$$ a $$$ $$$ b $$$ $$$ c $$$ simultaneously coordinate cities $$$ a $$$ $$$ b $$$ $$$ c $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 2 \cdot 10^ { 5 } $$$ ) — number cities follow $$$ n $$$ line contain integer $$$ x_i $$$ letter $$$ c_i $$$ ( $$$ -10^ { 9 } \le x_i \le 10^ { 9 } $$$ ) — coordinate city type city belong byteland $$$ c_i $$$ equal ' b ' city belong berland $$$ c_i $$$ equal « r » city dispute $$$ c_i $$$ equal ' p ' cities distinct coordinate guarantee cities give increase order coordinate print minimal total length set cable delete berland cities ( $$$ c_i $$$ = ' r ' ) possible find a way remain city remain city move cable similarly delete byteland cities ( $$$ c_i $$$ = ' b ' ) possible find a way remain city remain city move cable first example connect first city second second third third fourth total length cable $$$ 5 + 3 + 4 = 12 $$$ second example dispute cities need connect neighbor cities byteland neighbor cities berland cities berland coordinate $$$ 10 21 32 $$$ connect need two cable length $$$ 11 $$$ $$$ 11 $$$ cities byteland coordinate $$$ 14 $$$ $$$ 16 $$$ connect need one cable length $$$ 2 $$$ thus total length cable $$$ 11 + 11 + 2 = 24 $$$,['greedy'],2200.0
965/D,a lot frog want cross a river a river $$$ w $$$ units width frog jump $$$ l $$$ units long $$$ l < w $$$ frog also jump lengths shorter $$$ l $$$ ca n't jump longer hopefully stone river help stone locate integer distance bank $$$ a_i $$$ stone distance $$$ i $$$ units bank frog currently stone use one frog drown water maximum number frog cross river give jump stone ? first line contain two integers $$$ w $$$ $$$ l $$$ ( $$$ 1 \le l < w \le 100000 $$$ ) — width river maximum length a frog 's jump second line contain $$$ w - 1 $$$ integers $$$ a_1 a_2 \ldots a _ { <unknown> } $$$ ( $$$ 0 \le a_i \le 10000 $$$ ) $$$ a_i $$$ number stone distance $$$ i $$$ bank frog currently print a single integer — maximum number frog cross river first sample two frog use different stone distance $$$ 5 $$$ one frog use stone distance $$$ 3 $$$ $$$ 8 $$$ second sample although two stone distance $$$ 5 $$$ help three paths : $$$ 0 \to 3 \to 6 \to 9 \to 10 $$$ $$$ 0 \to 2 \to 5 \to 8 \to 10 $$$ $$$ 0 \to 1 \to 4 \to 7 \to 10 $$$,"['binary search', 'greedy', 'two pointers']",1900.0
97/D,"professor lose home robot yet think professor understand leave robot basement basement professor 's house represent a rectangle n × m split 1 × 1 square square wall impassable ; square passable get passable square passable square move edge - adjacent passable square one passable square exit basement robot place exactly one passable square also robot may place exit square professor scar go dark basement look robot night however a basement plan robot 's remote control use remote professor send signal robot shift one square leave right , robot receive a signal move require direction robot 's neighbor square give direction passable otherwise robot stay idle professor write a sequence k command a piece paper think sequence lead robot basement wherever 's initial position might professor program another robot press require button remote accord note piece paper professor run program go bed epiphany execute command take energy professor n't want get huge electricity bill end month 's want find sequence write minimal possible prefix would guarantee lead robot exit prefix fulfil 's problem professor challenge late hour first line contain three integers n m k ( 3 ≤ n m ≤ 150 1 ≤ k ≤ 105 ) next n line contain m character — professor 's basement 's description : ` ` # '' stand a wall ` ` . '' stand a passable square ` ` e '' stand exit basement ( square also passable ) possible get passable square exit square locate n × m rectangle 's perimeter wall exactly one square exit basement last line contain k character description sequence command professor write a piece paper ` ` l '' ` ` r '' ` ` u '' ` ` d '' stand command leave right correspondingly print output file length smallest possible prefix lead robot exit square word wherever robot position initially position exit square command prefix fulfil ( command robot come leave exit square last position robot interest us ) professor mistake prefix ( include whole sequence ) bring robot exit print ` ` -1 '' ( without quote ) passable square exit print ` ` 0 '' ( without quote )","['bitmasks', 'brute force', 'implementation']",2700.0
976/D,give a sequence n positive integers d1 d2 ... dn ( d1 < d2 < ... < dn ) task construct undirected graph : vertices number 1 ( dn + 1 ) degree sequence array a length equal number vertices a graph ai number vertices adjacent i - th vertex degree set a sort increase order sequence distinct value degree sequence guarantee exist a graph condition hold contain 106 edge print result graph first line contain one integer n ( 1 ≤ n ≤ 300 ) — size degree set second line contain n integers d1 d2 ... dn ( 1 ≤ di ≤ 1000 d1 < d2 < ... < dn ) — degree set first line print one integer m ( 1 ≤ m ≤ 106 ) — number edge result graph guarantee exist a graph condition hold contain 106 edge next m line contain two integers vi ui ( 1 ≤ vi ui ≤ dn + 1 ) — description i - th edge,"['graphs', 'implementation']",2500.0
976/E,recently max get popular <unknown> ` ` brainstone '' ` ` brainstone '' a pretty intellectual game max solve numerous hard problems gameplay one : max own n creatures i - th describe two number — health hpi damage dmgi max also two type spell stock : spell first type use a time total second type — b time total spell use a certain creature multiple time spell use arbitrary order n't necessary use spell max really busy prepare final exams ask determine maximal total damage creatures achieve use spell optimal way first line contain three integers n a b ( 1 ≤ n ≤ 2·105 0 ≤ a ≤ 20 0 ≤ b ≤ 2·105 ) — number creatures spell first type spell second type respectively i - th next n line contain two number hpi dmgi ( 1 ≤ hpi dmgi ≤ 109 ) — description i - th creature print single integer — maximum total damage creatures deal first example max use spell first type second creature spell second type creature total damage equal 15 + 6·2 = 27 . second example max use spell second type first creature spell second type third creature total damage equal 10 + 11 + 5 = 26,"['greedy', 'sortings']",2100.0
978/B,take file send polycarp try send a file social network ` ` codehorses '' encounter unexpected problem name file contain three ` ` x '' ( lowercase latin letter ` ` x '' ) a row system consider file content correspond social network topic case file send error message display determine minimum number character remove file name name contain ` ` xxx '' a substring print 0 file name initially contain a forbid substring ` ` xxx '' delete character arbitrary position ( necessarily consecutive ) delete a character length a string reduce $$$ 1 $$$ example delete character position $$$ 2 $$$ string ` ` <unknown> '' result string ` ` <unknown> '' first line contain integer $$$ n $$$ $$$ ( 3 \le n \le 100 ) $$$ — length file name second line contain a string length $$$ n $$$ consist lowercase latin letter — file name print minimum number character remove file name name contain ` ` xxx '' a substring initially file name <unknown> contain a forbid substring ` ` xxx '' print 0 . first example polycarp try send a file name contain number $$$ 33 $$$ write roman numerals send file name contain three letter ` ` x '' a row send file need remove one letter,"['greedy', 'strings']",800.0
978/F,bersoft $$$ n $$$ programmers work programmer $$$ i $$$ characterize a skill $$$ r_i $$$ a programmer $$$ a $$$ a mentor a programmer $$$ b $$$ skill programmer $$$ a $$$ strictly greater skill programmer $$$ b $$$ $$$ ( r_a > r_b ) $$$ programmers $$$ a $$$ $$$ b $$$ a quarrel give skills programmers a list $$$ k $$$ pair programmers a quarrel ( pair unordered ) programmer $$$ i $$$ find number programmers programmer $$$ i $$$ a mentor first line contain two integers $$$ n $$$ $$$ k $$$ $$$ ( 2 \le n \le 200000 $$$ $$$ 0 \le k \le \min ( 2 \cdot 100000 \frac { n \cdot ( n - 1 ) } { 2 } ) ) $$$ — total number programmers number pair programmers a quarrel second line contain a sequence integers $$$ r_1 r_2 \dots r_n $$$ $$$ ( 1 \le r_i \le 10^ { 9 } ) $$$ $$$ r_i $$$ equal skill $$$ i $$$ -th programmer follow $$$ k $$$ line contain two distinct integers $$$ x $$$ $$$ y $$$ $$$ ( 1 \le x y \le n $$$ $$$ x \ne y ) $$$ — pair programmers a quarrel pair unordered mean $$$ x $$$ a quarrel $$$ y $$$ $$$ y $$$ a quarrel $$$ x $$$ guarantee pair $$$ ( x y ) $$$ pair $$$ ( x y ) $$$ $$$ ( y x ) $$$ input print $$$ n $$$ integers $$$ i $$$ -th number equal number programmers $$$ i $$$ -th programmer a mentor programmers number order skills give input first example first programmer mentor ( second programmer a skill lower first programmer skill a quarrel ) second programmer mentor programmer skill minimal among others third programmer a mentor second programmer fourth programmer a mentor first second programmers a mentor third programmer a quarrel,"['binary search', 'data structures', 'implementation']",1500.0
978/G,"petya study university current academic year finish $$$ n $$$ special days petya need pass $$$ m $$$ exams special days special days problem number $$$ 1 $$$ $$$ n $$$ three value exam : three type activities petya day : spend a day nothing ( take a rest ) spend a day pass exactly one exam spend a day prepare exactly one exam ca n't pass / prepare multiple exams a day ca n't mix activities a day prepare $$$ i $$$ -th exam day $$$ j $$$ $$$ s_i \le j < d_i $$$ allow break a preparation exam alternate preparations different exams consecutive days preparation exam require do consecutive days find schedule petya prepare exams pass report impossible first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 2 \le n \le 100 1 \le m \le n ) $$$ — number days number exams follow $$$ m $$$ line contain three integers $$$ s_i $$$ $$$ d_i $$$ $$$ c_i $$$ $$$ ( 1 \le s_i < d_i \le n 1 \le c_i \le n ) $$$ — day question $$$ i $$$ -th exam give day $$$ i $$$ -th exam number days petya need prepare $$$ i $$$ -th exam guarantee exams different days question different exams give day possible day exam question exams give petya prepare pass exams print -1 . case positive answer print $$$ n $$$ integers $$$ j $$$ -th number : assume exams number order appear input start $$$ 1 $$$ multiple schedule print first example petya example prepare exam $$$ 1 $$$ first day prepare exam $$$ 2 $$$ second day pass exam $$$ 1 $$$ third day relax fourth day pass exam $$$ 2 $$$ fifth day , prepare pass exams second example three days two exams , petya prepare one day ( two days pass exams ) petya prepare pass exams","['greedy', 'implementation', 'sortings']",1700.0
979/E,kuro recently ` ` intelligent cat ever '' contest three friends decide go katie 's home celebrate kuro 's win a big meal take a small break start play game kuro challenge katie create a game a white paper a pencil a pair scissor a lot arrows ( assume number arrows infinite ) immediately katie come game call <unknown> parity paper divide $$$ n $$$ piece enumerate $$$ 1 $$$ $$$ n $$$ shiro paint piece color specifically $$$ i $$$ -th piece color $$$ c _ { i } $$$ $$$ c _ { i } = 0 $$$ define black color $$$ c _ { i } = 1 $$$ define white color $$$ c _ { i } = -1 $$$ mean piece n't color yet rule game simple players must put arrows pair different piece a way arrow number piece start less number piece end also two different piece connect one arrow players must choose color ( $$$ 0 $$$ $$$ 1 $$$ ) unpainted piece score a valid way put arrows color piece define number paths piece alternate color example $$$ [ 1 \to 0 \to 1 \to 0 ] $$$ $$$ [ 0 \to 1 \to 0 \to 1 ] $$$ $$$ [ 1 ] $$$ $$$ [ 0 ] $$$ valid paths count travel piece $$$ x $$$ piece $$$ y $$$ arrow $$$ x $$$ $$$ y $$$ kuro fun yet love parity let 's call favorite parity $$$ p $$$ $$$ p = 0 $$$ stand ` ` even '' $$$ p = 1 $$$ stand ` ` odd '' want put arrows choose color a way score parity $$$ p $$$ seem like many ways satisfy kuro want count number could a large number let 's help problem print modulo $$$ 10^ { 9 } + 7 $$$ first line contain two integers $$$ n $$$ $$$ p $$$ ( $$$ 1 \leq n \leq 50 $$$ $$$ 0 \leq p \leq 1 $$$ ) — number piece kuro 's want parity second line contain $$$ n $$$ integers $$$ c _ { 1 } c _ { 2 } ... c _ { n } $$$ ( $$$ -1 \leq c _ { i } \leq 1 $$$ ) — color piece print a single integer — number ways put arrows choose color number valid paths alternate color parity $$$ p $$$ first example $$$ 6 $$$ ways color piece add arrows show figure score $$$ 3 3 5 $$$ first row $$$ 5 3 3 $$$ second row leave right,['dp'],2400.0
980/D,samer write greatest test case time one problems a give array integers problem ask find minimum number group array divide product pair integers group a perfect square integer must exactly one group however integers a group necessarily contiguous array samer wish create case test case already test case array $$$ a $$$ $$$ n $$$ integers need find number contiguous subarrays $$$ a $$$ answer problem equal $$$ k $$$ integer $$$ k $$$ $$$ 1 $$$ $$$ n $$$ ( inclusive ) first line input contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 5000 $$$ ) size array second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \dots $$$ $$$ a_n $$$ ( $$$ -100000000 \leq a_i \leq 100000000 $$$ ) value array output $$$ n $$$ space - separated integers $$$ k $$$ -th integer number contiguous subarrays $$$ a $$$ answer problem equal $$$ k $$$,"['dp', 'math', 'number theory']",2100.0
980/E,nation panel hold annual show call number game district nation represent one contestant nation $$$ n $$$ district number $$$ 1 $$$ $$$ n $$$ district exactly one path connect every district number fan a contestant district $$$ i $$$ equal $$$ 2^i $$$ year president decide reduce cost want remove $$$ k $$$ contestants game however district remove contestants furious allow anyone cross district president want ensure remain contestants district reach one another also wish maximize total number fan participate contestants contestants president remove ? first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq k < n \leq 1000000 $$$ ) — number district panel number contestants president wish remove respectively next $$$ n-1 $$$ line contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \leq a b \leq n $$$ $$$ a \ne b $$$ ) describe a road connect two different district $$$ a $$$ $$$ b $$$ nation guarantee exactly one path every two district print $$$ k $$$ space - separated integers : number district contestants remove increase order district number first sample maximum possible total number fan $$$ 2 ^ 2 + 2 ^ 5 + 2 ^ 6 = 100 $$$ achieve remove contestants district 1 3 4,"['data structures', 'greedy', 'trees']",2200.0
982/B,"bus character $$$ n $$$ row seat $$$ 2 $$$ seat width seat $$$ i $$$ -th row $$$ w_i $$$ centimeters integers $$$ w_i $$$ distinct initially bus empty $$$ 2n $$$ stop one passenger enter bus two type passengers : give seat width row order passengers enter bus determine row passenger take first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200\,000 $$$ ) — number row bus second line contain sequence integers $$$ w_1 w_2 \dots w_n $$$ ( $$$ 1 \le w_i \le 10^ { 9 } $$$ ) $$$ w_i $$$ width seat $$$ i $$$ -th row guarantee $$$ w_i $$$ distinct third line contain a string length $$$ 2n $$$ consist digits ' 0 ' ' 1 ' — description order passengers enter bus $$$ j $$$ -th character ' 0 ' passenger enter bus $$$ j $$$ -th stop introvert $$$ j $$$ -th character ' 1 ' passenger enter bus $$$ j $$$ -th stop extrovert guarantee number <unknown> equal number introvert ( i. e. number equal $$$ n $$$ ) extrovert always a suitable row print $$$ 2n $$$ integers — row passengers take order passengers input first example first passenger ( introvert ) choose row $$$ 2 $$$ seat smallest width second passenger ( introvert ) choose row $$$ 1 $$$ empty row third passenger ( extrovert ) choose row $$$ 1 $$$ exactly one occupy seat seat width largest among row fourth passenger ( extrovert ) choose row $$$ 2 $$$ row empty place","['data structures', 'greedy', 'implementation']",1300.0
982/D,long time scientists study behavior shark shark many species alternate short movements a certain location long movements locations max a young <unknown> $$$ n $$$ days watch a specific shark know distance shark travel days distance distinct max want know many locations shark visit assume integer $$$ k $$$ shark day travel distance strictly less $$$ k $$$ n't change location ; otherwise one day shark travel distance greater equal $$$ k $$$ ; change a location day note possible shark change a location several consecutive days shark travel distance least $$$ k $$$ shark never return location move thus sequence $$$ n $$$ days find consecutive nonempty segment shark travel distance less $$$ k $$$ days : segment correspond one location max want choose $$$ k $$$ lengths segment equal find integer $$$ k $$$ number locations large possible several $$$ k $$$ print smallest one first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — number days second line contain $$$ n $$$ distinct positive integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — distance travel day print a single integer $$$ k $$$ first example shark travel inside a location days $$$ 1 $$$ $$$ 2 $$$ ( first location ) $$$ 4 $$$ -th $$$ 5 $$$ -th days ( second location ) $$$ 7 $$$ -th $$$ 8 $$$ -th days ( third location ) three locations total second example shark move inside a location $$$ 2 $$$ -nd day one location,"['brute force', 'data structures', 'dsu', 'trees']",1900.0
983/A,"give several query query consist three integers $$$ p $$$ $$$ q $$$ $$$ b $$$ need answer whether result $$$ p / q $$$ notation base $$$ b $$$ a finite fraction a fraction notation base $$$ b $$$ finite contain finite number numerals decimal point also possible a fraction zero numerals decimal point first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number query next $$$ n $$$ line contain query one per line line contain three integers $$$ p $$$ $$$ q $$$ $$$ b $$$ ( $$$ 0 \le p \le 10^ { 18 } $$$ $$$ 1 \le q \le 10^ { 18 } $$$ $$$ 2 \le b \le 10^ { 18 } $$$ ) number give notation base $$$ 10 $$$ question a separate line print finite fraction finite infinite otherwise $$$ \frac { 6 } { 12 } = \frac { 1 } { 2 } = 0,5 _ { 10 } $$$ $$$ \frac { 4 } { 3 } = 1 ( 3 ) _ { 10 } $$$ $$$ \frac { 9 } { 36 } = \frac { 1 } { 4 } = <unknown> $$$ $$$ \frac { 4 } { 12 } = \frac { 1 } { 3 } = <unknown> $$$","['implementation', 'math']",1700.0
983/B,"array $$$ b $$$ length $$$ m $$$ define function $$$ f $$$ $$$ \oplus $$$ bitwise exclusive example $$$ f ( 1,2,4,8 ) = f ( <unknown> ) = f ( 3,6,12 ) = f ( <unknown> ) = f ( 5,10 ) = f ( <unknown> ) = f ( 15 ) = 15 $$$ give array $$$ a $$$ a query query represent two integers $$$ l $$$ $$$ r $$$ answer maximum value $$$ f $$$ continuous subsegments array $$$ a_l a _ { l+1 } \ldots a_r $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 5000 $$$ ) — length $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 2^ { 30 } -1 $$$ ) — elements array third line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 100\,000 $$$ ) — number query next $$$ q $$$ line contain a query represent two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \le l \le r \le n $$$ ) print $$$ q $$$ line — answer query first sample query maximum value function reach subsegment equal whole segment second sample optimal segment first query $$$ [ 3,6 ] $$$ second query — $$$ [ 2,5 ] $$$ third — $$$ [ 3,4 ] $$$ fourth — $$$ [ 1,2 ] $$$",['dp'],1800.0
984/B,one day alex decide remember childhood computers powerful lot people play default game alex enjoy play minesweeper time imagine save world bomb plant terrorists rarely alex grow since easily win difficult level quickly bore think : computer give invalid field childhood alex could win ? need help check a minesweeper field a rectangle $$$ n \times m $$$ cell either empty contain a digit $$$ 1 $$$ $$$ 8 $$$ a bomb field valid cell : two cells neighbor a common side a corner ( i. e. a cell $$$ 8 $$$ neighbor cells ) first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100 $$$ ) — size field next $$$ n $$$ line contain description field line contain $$$ m $$$ character ` ` . '' ( cell empty ) ` ` * '' ( bomb cell ) a digit $$$ 1 $$$ $$$ 8 $$$ inclusive print ` ` yes '' field valid ` ` '' otherwise choose case ( lower upper ) letter arbitrarily second example answer ` ` '' position bomb preserve first line field * 2 * 1 . read minesweeper wikipedia 's article,['implementation'],1100.0
985/D,go beach idea build greatest sand castle ever head ! beach three - dimensional could imagine <unknown> a line spot pile sand pillars spot number 1 infinity leave right obviously enough sand beach bring n pack sand let height hi sand pillar spot i number sand pack spend ca n't split a sand pack multiple pillars sand go a single one a fence height equal height pillar h sand pack leave first spot prevent sand go finally end follow condition build castle : infinite spot build always possible come valid castle structure though want castle compact possible task calculate minimum number spot occupy aforementioned condition hold line contain two integer number n h ( 1 ≤ n h ≤ 1018 ) — number sand pack height fence respectively print minimum number spot occupy castle build condition hold heights valid castle : first list case optimal answer 3 spot occupy invalid ones :,"['binary search', 'math']",2100.0
986/D,work analyst a company work a new system big data storage system store $$$ n $$$ different object object a unique i d create system choose parameters system — integers $$$ m \ge 1 $$$ $$$ b _ { 1 } b _ { 2 } \ldots b _ { m } $$$ parameters i d object system array integers $$$ [ a _ { 1 } a _ { 2 } \ldots a _ { m } ] $$$ $$$ 1 \le a _ { i } \le b _ { i } $$$ hold every $$$ 1 \le i \le m $$$ developers say production cost proportional $$$ \sum _ { i=1 } ^ { m } b _ { i } $$$ ask choose parameters $$$ m $$$ $$$ b _ { i } $$$ system able assign unique ids $$$ n $$$ different object production cost minimize note n't use available ids line input one positive integer $$$ n $$$ length decimal representation $$$ n $$$ greater $$$ 1.5 \cdot 10^ { 6 } $$$ integer contain lead zero print one number — minimal value $$$ \sum _ { i=1 } ^ { m } b _ { i } $$$,['math'],3100.0
987/C,"middle 2018 maria stepanovna live outside <unknown> ( a town <unknown> region ) want rent three display highlight important problem $$$ n $$$ display place along a road $$$ i $$$ -th display a text font size $$$ s_i $$$ maria stepanovna want rent three display indices $$$ i < j < k $$$ font size increase move along road a particular direction namely condition $$$ s_i < s_j < s_k $$$ hold rent cost $$$ i $$$ -th display $$$ c_i $$$ please determine smallest cost maria stepanovna pay first line contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 3\,000 $$$ ) — number display second line contain $$$ n $$$ integers $$$ s_1 s_2 \ldots s_n $$$ ( $$$ 1 \le s_i \le 1000000000 $$$ ) — font size display order stand along road third line contain $$$ n $$$ integers $$$ c_1 c_2 \ldots c_n $$$ ( $$$ 1 \le c_i \le 100000000 $$$ ) — rent cost display three display satisfy criteria print -1 . otherwise print a single integer — minimum total rent cost three display indices $$$ i < j < k $$$ $$$ s_i < s_j < s_k $$$ first example example choose display $$$ 1 $$$ $$$ 4 $$$ $$$ 5 $$$ $$$ s_1 < s_4 < s_5 $$$ ( $$$ 2 < 4 < 10 $$$ ) rent cost $$$ 40 + 10 + 40 = 90 $$$ second example ca n't select a valid triple indices answer -1","['brute force', 'dp', 'implementation']",1400.0
991/D,<unknown> a chess figure consist three square resemble ` ` l - bar '' figure rotate 90 180 270 degrees four possible state : bishwocks n't attack square even occupy adjacent square long n't occupy square vasya a board $$$ 2\times n $$$ square onto want put bishwocks <unknown> several square board already occupy pawn vasya ca n't put bishwocks however pawn also n't attack bishwocks occupy adjacent square peacefully know position pawn board help vasya determine maximum amount bishwocks put onto board would n't occupy square would n't occupy square pawn input contain two nonempty string describe vasya 's board string contain symbols ` ` 0 '' ( zero ) denote empty square symbols ` ` x '' ( uppercase english letter ) denote square occupy pawn string nonempty length exceed $$$ 100 $$$ output a single integer — maximum amount bishwocks place onto give board,"['dp', 'greedy']",1500.0
992/E,nastya like read even spend whole days a library sometimes today find a chronicle byteland library state live shamans long time ago know every moment exactly one shaman byteland n shamans total enumerate integers 1 n order live also shaman a magic power express integer chronicle include a list power n shamans also shamans king - shamans gather power <unknown> i.e power exactly sum power previous shamans nastya interest whether least one king - shaman byteland unfortunately many power unreadable list nastya follow : unfortunately list large nastya want help first line contain two integers n q ( 1 ≤ n q ≤ 2·105 ) second line contain n integers a1 ... ( 0 ≤ ai ≤ 109 ) ai magic power i - th shaman q line follow i - th contain two integers pi xi ( 1 ≤ pi ≤ n 0 ≤ xi ≤ 109 ) mean new power pi - th shaman xi print q line i - th contain - 1 i - th change shaman - kings otherwise a single integer j j index king - shaman i - th change multiple king - shamans change print index first example power shamans first change equal ( 2 3 ) answer equal - 1 sum power shamans first shaman equal 0 second equal 2 . second example first change power equal ( 1 2 3 ) answer equal 3 power third shaman equal 3 sum power first second shaman also 1 + 2 = 3 . second change power become equal ( 2 2 3 ) answer equal 2 . third change power become equal ( 2 4 3 ) answer equal - 1 . fourth change power become equal ( 2 4 6 ) answer equal 3,"['binary search', 'data structures']",2500.0
993/C,"two small spaceship surround two group enemy larger spaceships space a two - dimensional plane one group enemy spaceships position a way integer $$$ y $$$ -coordinates $$$ x $$$ -coordinate equal $$$ -100 $$$ second group position a way integer $$$ y $$$ -coordinates $$$ x $$$ -coordinate equal $$$ 100 $$$ spaceship group simultaneously shoot two laser shots ( infinite ray destroy spaceship touch ) one towards small spaceships time small spaceships able avoid laser shots want position locations $$$ x=0 $$$ ( necessarily integer $$$ y $$$ -coordinates ) ray shoot would destroy many enemy spaceships possible find largest number spaceships destroy way assume enemy spaceships ca n't avoid laser shots first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 60 $$$ ) number enemy spaceships $$$ x = -100 $$$ number enemy spaceships $$$ x = 100 $$$ respectively second line contain $$$ n $$$ integers $$$ y _ { 1,1 } y _ { 1,2 } \ldots y _ { 1 n } $$$ ( $$$ |y _ { 1 i } | \le 10\,000 $$$ ) — $$$ y $$$ -coordinates spaceships first group third line contain $$$ m $$$ integers $$$ y _ { 2,1 } y _ { 2,2 } \ldots y _ { 2 m } $$$ ( $$$ |y _ { 2 i } | \le 10\,000 $$$ ) — $$$ y $$$ -coordinates spaceships second group $$$ y $$$ coordinate guarantee unique even within a group print a single integer – largest number enemy spaceships destroy first example first spaceship position $$$ ( 0 2 ) $$$ second – $$$ ( 0 7 ) $$$ way enemy spaceships first group $$$ 6 $$$ $$$ 9 $$$ spaceships second group destroy second example first spaceship position $$$ ( 0 3 ) $$$ second position anywhere sufficient destroy enemy spaceships","['bitmasks', 'brute force', 'geometry']",2100.0
994/A,lock a room a door a keypad 10 key correspond digits 0 9 . escape room need enter a correct code also a sequence digits key keypad fingerprint believe correct code longest necessarily contiguous subsequence sequence contain digits fingerprint correspond key find code first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 10 $$$ ) represent number digits sequence number key keypad fingerprint next line contain $$$ n $$$ distinct space - separated integers $$$ x_1 x_2 \ldots x_n $$$ ( $$$ 0 \le x_i \le 9 $$$ ) represent sequence next line contain $$$ m $$$ distinct space - separated integers $$$ y_1 y_2 \ldots y_m $$$ ( $$$ 0 \le y_i \le 9 $$$ ) — key fingerprint a single line print a space - separated sequence integers represent code result sequence empty print nothing print a single line break acceptable first example digits fingerprint $$$ 1 $$$ $$$ 2 $$$ $$$ 7 $$$ three appear sequence know $$$ 7 $$$ first $$$ 1 $$$ $$$ 2 $$$ therefore output 7 1 2 . note order important shall order original sequence second example digits $$$ 0 $$$ $$$ 1 $$$ $$$ 7 $$$ $$$ 9 $$$ fingerprint however $$$ 0 $$$ $$$ 1 $$$ appear original sequence $$$ 1 $$$ appear earlier output 1 0 . order important,['implementation'],800.0
995/B,allen host a formal dinner party $$$ 2n $$$ people come event $$$ n $$$ pair ( couple ) a night fun allen want line everyone a final picture $$$ 2n $$$ people line allen n't like order allen prefer pair occupy adjacent position line make picture aesthetic help allen find minimum number swap adjacent position must perform make couple occupy adjacent position line first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) number pair people second line contain $$$ 2n $$$ integers $$$ a_1 a_2 \dots a _ { 2n } $$$ $$$ i $$$ $$$ 1 \le i \le n $$$ $$$ i $$$ appear exactly twice $$$ a_j = a_k = i $$$ mean $$$ j $$$ -th $$$ k $$$ -th people line form a couple output a single integer represent minimum number adjacent swap need line people pair occupy adjacent position first sample case transform $$$ 1 1 2 3 3 2 4 4 \rightarrow 1 1 2 3 2 3 4 4 \rightarrow 1 1 2 2 3 3 4 4 $$$ two step note sequence $$$ 1 1 2 3 3 2 4 4 \rightarrow 1 1 3 2 3 2 4 4 \rightarrow 1 1 3 3 2 2 4 4 $$$ also work number step second sample case already satisfy constraints ; therefore need $$$ 0 $$$ swap,"['greedy', 'implementation', 'math']",1400.0
995/F,"allen graduate moo institute <unknown> ( mit ) start a startup ! allen president startup also hire $$$ n-1 $$$ employees assign a direct superior $$$ u $$$ a superior $$$ v $$$ $$$ v $$$ a superior $$$ w $$$ also $$$ u $$$ a superior $$$ w $$$ additionally $$$ u $$$ $$$ v $$$ $$$ u $$$ superior $$$ v $$$ $$$ v $$$ superior $$$ u $$$ allen superior allen employee number $$$ 1 $$$ others employee number $$$ 2 $$$ $$$ n $$$ finally allen must assign salaries employee company include due budget constraints employee 's salary integer $$$ 1 $$$ $$$ d $$$ additionally employee make strictly superior help allen find number ways assign salaries number may large output modulo $$$ 1000000000 + 7 $$$ first line input contain two integers $$$ n $$$ $$$ d $$$ ( $$$ 1 \le n \le 3000 $$$ $$$ 1 \le d \le 1000000000 $$$ ) remain $$$ n-1 $$$ line contain a single positive integer $$$ i $$$ -th line contain integer $$$ p_i $$$ ( $$$ 1 \le p_i \le i $$$ ) $$$ p_i $$$ denote direct superior employee $$$ i+1 $$$ output a single integer : number ways assign salaries modulo $$$ 1000000000 + 7 $$$ first sample case employee 2 3 report directly allen three salaries order $$$ ( 1,1,1 ) $$$ $$$ ( 2,1,1 ) $$$ $$$ ( 2,1,2 ) $$$ $$$ ( 2,2,1 ) $$$ $$$ ( 2,2,2 ) $$$ second sample case employee 2 report allen employee 3 report employee 2 . order possible salaries $$$ ( 1,1,1 ) $$$ $$$ ( 2,1,1 ) $$$ $$$ ( 2,2,1 ) $$$ $$$ ( 2,2,2 ) $$$ $$$ ( 3,1,1 ) $$$ $$$ ( 3,2,1 ) $$$ $$$ ( 3,2,2 ) $$$ $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ $$$ ( 3,3,3 ) $$$","['combinatorics', 'dp', 'math', 'trees']",2700.0
996/A,allen a lot money $$$ n $$$ dollars bank security reason want withdraw cash ( disclose reason ) denominations dollar bill $$$ 1 $$$ $$$ 5 $$$ $$$ 10 $$$ $$$ 20 $$$ $$$ 100 $$$ minimum number bill allen could receive withdraw entire balance ? first line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) output minimum number bill allen could receive first sample case allen withdraw a $$$ 100 $$$ dollar bill a $$$ 20 $$$ dollar bill a $$$ 5 $$$ dollar bill way allen receive $$$ 125 $$$ dollars one two bill second sample case allen withdraw two $$$ 20 $$$ dollar bill three $$$ 1 $$$ dollar bill third sample case allen withdraw $$$ 100000000 $$$ ( ten million ! ) $$$ 100 $$$ dollar bill,"['dp', 'greedy']",800.0
999/E,$$$ n $$$ cities $$$ m $$$ roads berland road connect a pair cities roads berland one - way minimum number new roads need build make cities reachable capital ? new roads also one - way first line input consist three integers $$$ n $$$ $$$ m $$$ $$$ s $$$ ( $$$ 1 \le n \le 5000 0 \le m \le 5000 1 \le s \le n $$$ ) — number cities number roads index capital cities index $$$ 1 $$$ $$$ n $$$ follow $$$ m $$$ line contain roads : road $$$ i $$$ give a pair cities $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) pair cities $$$ ( u v ) $$$ one road $$$ u $$$ $$$ v $$$ roads opposite directions a pair cities allow ( i.e $$$ u $$$ $$$ v $$$ $$$ v $$$ $$$ u $$$ ) print one integer — minimum number extra roads need make cities reachable city $$$ s $$$ cities already reachable $$$ s $$$ print 0 . first example illustrate follow : example add roads ( $$$ 6 4 $$$ ) ( $$$ 7 9 $$$ ) ( $$$ 1 7 $$$ ) make cities reachable $$$ s = 1 $$$ second example illustrate follow : example add one roads ( $$$ 5 1 $$$ ) ( $$$ 5 2 $$$ ) ( $$$ 5 3 $$$ ) ( $$$ 5 4 $$$ ) make cities reachable $$$ s = 5 $$$,"['dfs and similar', 'graphs', 'greedy']",2000.0
