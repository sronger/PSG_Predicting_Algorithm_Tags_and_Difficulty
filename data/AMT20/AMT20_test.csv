,description,tags,rating
1408/F,give integer $$$ n $$$ find a list pair $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ ... $$$ ( x_q y_q ) $$$ ( $$$ 1 \leq x_i y_i \leq n $$$ ) satisfy follow condition let 's consider function $$$ f : \mathbb { n } \times \mathbb { n } \to \mathbb { n } $$$ ( define $$$ \mathbb { n } $$$ set positive integers ) word $$$ f $$$ a function return a positive integer a pair positive integers let 's make array $$$ a_1 a_2 \ldots a_n $$$ $$$ a_i = i $$$ initially perform $$$ q $$$ operations $$$ i $$$ -th : word need simultaneously change $$$ a _ { x_i } $$$ $$$ a _ { y_i } $$$ $$$ f ( a _ { x_i } a _ { y_i } ) $$$ note process $$$ f ( p q ) $$$ always a fix pair $$$ p $$$ $$$ q $$$ end two different number array $$$ a $$$ true function $$$ f $$$ find possible list pair number pair exceed $$$ 500000 $$$ single line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq <unknown> $$$ ) first line print $$$ q $$$ ( $$$ 0 \leq q \leq 500000 $$$ ) — number pair next $$$ q $$$ line print two integers $$$ i $$$ -th line print $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \leq x_i y_i \leq n $$$ ) condition describe statement satisfy exist multiple answer print first example perform operation array $$$ a $$$ $$$ [ f ( a_1 a_2 ) f ( a_1 a_2 ) a_3 ] $$$ always two different number second example perform two operations array $$$ a $$$ $$$ [ f ( a_1 a_2 ) f ( a_1 a_2 ) f ( a_3 a_4 ) f ( a_3 a_4 ) ] $$$ always two different number,['divide and conquer'],2300.0
1375/H,"give a permutation $$$ a_1 a_2 \dots a_n $$$ number $$$ 1 $$$ $$$ n $$$ also $$$ n $$$ set $$$ s_1 s_2 \dots s_n $$$ $$$ <unknown> { <unknown> } $$$ lastly a variable $$$ cnt $$$ represent current number set initially $$$ cnt = n $$$ define two kinds function set : $$$ f ( s ) = \min\limits _ { u\in s } u $$$ ; $$$ g ( s ) = \max\limits _ { u\in s } u $$$ obtain a new set merge two set $$$ a $$$ $$$ b $$$ satisfy $$$ g ( a ) < f ( b ) $$$ ( notice old set disappear ) formally perform follow sequence operations : $$$ <unknown> <unknown> $$$ ; $$$ s _ { cnt } = <unknown> s_v $$$ free choose $$$ u $$$ $$$ v $$$ $$$ 1\le u v < cnt $$$ satisfy $$$ g ( s_u ) < f ( s_v ) $$$ require obtain specific set $$$ q $$$ requirements contain two integers $$$ l_i $$$ $$$ r_i $$$ mean must exist a set $$$ s _ { k_i } $$$ ( $$$ k_i $$$ i d set determine ) equal $$$ \ { <unknown> l_i\leq <unknown> <unknown> } $$$ , set consist $$$ a_i $$$ indices $$$ l_i $$$ $$$ r_i $$$ end must ensure $$$ <unknown> 2.2\times 1000000 $$$ note n't minimize $$$ cnt $$$ guarantee a solution give constraints exist first line contain two integers $$$ n q $$$ $$$ ( 1\leq n \leq 2^ { 12 } , 1 \leq q \leq 2^ { 16 } ) $$$ — length permutation number need set correspondently next line consist $$$ n $$$ integers $$$ a_1 a_2 \cdots a_n $$$ ( $$$ 1\leq a_i\leq n $$$ $$$ a_i $$$ pairwise distinct ) — give permutation $$$ i $$$ -th next $$$ q $$$ line contain two integers $$$ l_i r_i $$$ $$$ ( 1\leq l_i\leq <unknown> n ) $$$ describe a requirement $$$ i $$$ -th set guarantee a solution give constraints exist first line contain one integer $$$ cnt_e $$$ $$$ ( n\leq <unknown> 2.2\times 1000000 ) $$$ represent number set operations $$$ cnt_e - n $$$ line must follow line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1\leq u v\leq cnt ' $$$ $$$ cnt ' $$$ value $$$ cnt $$$ operation ) mean choose $$$ s_u $$$ $$$ s_v $$$ perform a merge operation operation $$$ g ( s_u ) < f ( s_v ) $$$ must satisfy last line contain $$$ q $$$ integers $$$ k_1 k_2 \cdots k_q $$$ $$$ ( 1\leq <unknown> cnt_e ) $$$ represent set $$$ s _ { k_i } $$$ $$$ i $$$ th require set please notice large amount output first sample : $$$ <unknown> { 1\ } <unknown> { 3\ } <unknown> { 2\ } $$$ initially first operation $$$ g ( s_3 ) = 2 < f ( s_2 ) =3 $$$ merge $$$ s_3 s_2 $$$ $$$ s_4=\ { 2,3\ } $$$ second operation $$$ g ( s_1 ) = 1 < f ( s_3 ) = 2 $$$ merge $$$ s_1 s_3 $$$ $$$ <unknown> { <unknown> } $$$ third operation $$$ g ( s_5 ) = 2 < f ( s_2 ) =3 $$$ merge $$$ s_5 s_2 $$$ $$$ s_6=\ { 1,2,3\ } $$$ first requirement $$$ s_4=\ { 2,3\ } = \ { a_2 a_3\ } $$$ satisfy thus $$$ <unknown> $$$ second requirement $$$ s_6=\ { 1,2,3\ } = \ { a_1 a_2 a_3\ } $$$ satisfy thus $$$ <unknown> $$$ notice unused set identical set output set multiple time use set present initially allow",['divide and conquer'],3300.0
873/D,"merge sort a well - known sort algorithm main function sort elements array a indices [ l r ) implement follow : array problem 0 - indexed sort whole array need call mergesort ( a 0 n ) number call function mergesort important ivan decide calculate sort array example a = { 1 2 3 4 } 1 call mergesort — mergesort ( 0 4 ) check array sort end a = { 2 1 3 } number call 3 : first call mergesort ( 0 3 ) set <unknown> = 1 call mergesort ( 0 1 ) mergesort ( 1 3 ) perform recursive call segment ( 0 1 ) ( 1 3 ) sort ivan implement program count number mergesort call need test , need find array a a a permutation size n ( number elements a n every integer number [ 1 n ] find array ) number mergesort call sort array exactly k. help ivan find array want ! first line contain two number n k ( 1 ≤ n ≤ 100000 1 ≤ k ≤ 200000 ) — size a desire permutation number mergesort call require sort a permutation size n exactly k call mergesort sort n't exist output - 1 . otherwise output n integer number a [ 0 ] a [ 1 ] ... a [ n - 1 ] — elements a permutation would meet require condition multiple answer print",['divide and conquer'],1800.0
512/E,fox ciel design a puzzle game call ` ` polygon '' ! play use triangulations a regular n - edge polygon goal transform one triangulation another <unknown> rule triangulation n - edge <unknown> a set n - 3 diagonals satisfy condition two diagonals share a common internal point example initial state game may look like ( a ) figure goal may look like ( c ) step choose a diagonal inside polygon ( one edge polygon ) flip diagonal suppose go flip a diagonal a – b. always exist two triangles share a – b a side let 's denote a – b – c a – b – d. a result operation diagonal a – b replace a diagonal c – d. easily prove flip operation result set diagonals still a triangulation polygon order solve case may first flip diagonal 6 – 3 replace diagonal 2 – 4 . flip diagonal 6 – 4 get figure ( c ) result ciel prove start destination triangulations game a solution want solve 20 000 step puzzle satisfy n ≤ 1000 . first line contain integer n ( 4 ≤ n ≤ 1000 ) number edge regular polygon follow two group ( n - 3 ) line describe original triangulation goal triangulation description triangulation consist ( n - 3 ) line line contain 2 integers ai bi ( 1 ≤ ai bi ≤ n ) describe a diagonal ai – bi guarantee original goal triangulations correct ( i. e. two diagonals share a common internal point triangulations ) first output integer k ( 0 ≤ k ≤ 20 000 ) : number step output k line contain 2 integers ai bi : endpoints a diagonal go flip step i. may output ai bi order several possible solutions output sample test 2 discuss show picture,['divide and conquer'],2900.0
161/C,polycarpus analyze a string call abracadabra string construct use follow algorithm : let 's a closer look algorithm second step polycarpus concatenate two string ` ` a '' insert character ` ` b '' result ` ` aba '' string third step transform ` ` abacaba '' fourth one - ` ` <unknown> '' thus string construct k - th step consist 2k - 1 character polycarpus write string get 30 step give algorithm choose two non - empty substrings task find length longest common substring two substrings select polycarpus a substring s [ i ... j ] ( 1 ≤ i ≤ j ≤ |s| ) string s = s1s2 ... s|s| a string <unknown> + 1 ... sj example substring s [ 2 ... 4 ] string s = ` ` abacaba '' equal ` ` bac '' string substring longest common substring two string s t longest string a substring s t. example longest common substring ` ` contest '' ` ` <unknown> '' string ` ` test '' several common substrings maximum length input consist a single line contain four integers l1 r1 l2 r2 ( 1 ≤ li ≤ ri ≤ 109 i = 1 2 ) number separate single space li ri give indices first last character i - th choose substring correspondingly ( i = 1 2 ) character string abracadabra number start 1 . print a single number — length longest common substring give string common substrings print 0 . first sample first substring ` ` <unknown> '' second one ` ` abac '' two substrings two longest common substrings ` ` ac '' ` ` ab '' interest length — 2 . second sample first substring ` ` a '' second one ` ` c '' two substrings n't common character length longest common substring 0,['divide and conquer'],2400.0
97/B,a set point a plane call good two point least one three condition true : give a set consist n point a plane find good superset give set whose size would exceed 2·105 point first line contain integer n ( 1 ≤ n ≤ 104 ) — number point initial set next n line describe set 's point line contain two integers xi yi ( - 109 ≤ xi yi ≤ 109 ) — a correspond point 's coordinate guarantee point different print first line number point m ( n ≤ m ≤ 2·105 ) a good superset print next m line point absolute value point ' coordinate exceed 109 . note minimize m enough find good superset give set whose size exceed 2·105 point superset integer coordinate,['divide and conquer'],2300.0
1250/M,"berland gardeners unite inc . hire project call ` ` smartgarden '' main feature project <unknown> garden water formally garden represent a square $$$ n \times n $$$ cells row number $$$ 1 $$$ $$$ n $$$ top bottom columns number $$$ 1 $$$ $$$ n $$$ leave right cell garden contain either a plant a slab 's know slabs locate main diagonal matrix represent garden cells main diagonal share a side least one cell main diagonal remain cells garden fill plant implementation project create a smart robot take a list command input process one one command contain : execute command robot water cells intersection specify row specify columns , specify $$$ r $$$ row $$$ c $$$ columns exactly $$$ r \cdot c $$$ cells water demo customer <unknown> robot a way water garden prepare a single command contain $$$ n $$$ row $$$ n $$$ columns unfortunately 5 hours demo customer turn ceo berland gardeners unite inc . go take part moreover probably stand a garden slab demo ! need create a list command robot water plant n't water cell contain a slab since 's a <unknown> version ` ` smartgarden '' total number command n't exceed $$$ 50 $$$ create a program a give size garden find a list $$$ 50 $$$ command allow robot water plant garden without water slabs allow water a plant several time first line input contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 5000 $$$ ) $$$ n $$$ size garden first line print total number command robot $$$ k $$$ ( $$$ 1 \le k \le 50 $$$ ) next $$$ 2 \cdot k $$$ line print command command specify $$$ 2 $$$ line first line command describe row command second line describe columns command $$$ 2 $$$ line follow format : multiple ways water garden print",['divide and conquer'],2500.0
1470/F,"give $$$ n $$$ point a plane please find minimum sum areas two axis - aligned rectangles point contain least one rectangles note choose rectangles degenerate rectangle contain point lie inside boundary first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 200000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number point follow $$$ n $$$ line contain coordinate point $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \le x_i y_i \le 1000000000 $$$ ) guarantee point distinct guarantee sum value $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ test case print one integer — minimum sum areas first two test case answer consist 2 degenerate rectangles third test case one possible answer consist two rectangles $$$ 1 \times 1 $$$ bottom leave corner $$$ ( 0,0 ) $$$ $$$ ( <unknown> ) $$$",['divide and conquer'],3500.0
1218/E,roam <unknown> areas <unknown> order drop legendary loot adventurer give a quest follow give array $$$ a = { a_1 a_2 ... a_n } $$$ length $$$ n $$$ a number $$$ k $$$ define array $$$ b $$$ $$$ b ( q a ) = $$$ { $$$ q - a_1 q - a_2 ... q - a_n $$$ } define function $$$ f $$$ $$$ f ( b k ) $$$ sum products $$$ k $$$ <unknown> elements array $$$ b $$$ example array $$$ b $$$ $$$ [ <unknown> ] $$$ $$$ k=3 $$$ sum products 3 - tuples $$$ $$$ f ( b 3 ) = 2 * 3 * 4 + 2 * 3 * 5 + 3 * 4 * 5 + 2 * 4 * 5 $$$ $$$ give a number q number query two type : change <unknown> make initial array n't propagate follow query help adventurer calculate answer a quest finally get loot ! first two line number $$$ n $$$ ( $$$ 1 \leq n \leq 2 * 10000 $$$ ) $$$ k $$$ ( $$$ 1 \leq k \leq n $$$ ) length initial array $$$ a $$$ tuple size follow $$$ a_1 a_2 a_3 … a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) elements array $$$ a $$$ next line follow number $$$ q $$$ ( $$$ q \leq 10 $$$ ) number query next $$$ q $$$ line come query form : explain ( $$$ 0 \leq q d \leq 1000000000 1 \leq i l r \leq n $$$ ) print $$$ q $$$ line answer query modulo $$$ 998244353 $$$ first query array a = [ 1 2 3 4 5 ] b = [ 5 4 3 2 1 ] sum products 2 - tuples = 85 . second query array a = [ 1 2 3 4 2 ] b = [ 5 4 3 2 4 ] sum products 2 - tuples = <unknown> in third query array a = [ 1 3 4 4 5 ] b = [ 5 3 2 2 1 ] sum products 2 - tuples = 63,['divide and conquer'],2500.0
788/D,program contest roma decide try <unknown> home country uzhlyandia a cartesian plane want walk along main straight line uzhlyandia know line a straight line parallel one ax ( i.e describe equation x = a y = a a integer call coordinate line ) roma lose map find coordinate line first uncle anton agree help use follow rule : uncle anton a hurry <unknown> ( <unknown> olympiad informatics ) answer 3·105 question problem roma n't know find coordinate line write a program play roma 's <unknown> find coordinate input initially program make query get information guarantee number horizontal vertical line least 1 less equal 104 type make a query print a line ` ` 0 x y '' ( -108 ≤ x y ≤ 108 ) x y coordinate point query need print end - of - line make ` ` flush '' operation read answer query — minimum among distance <unknown> point main straight line uzhlyandia 3·105 query ready print answer print three line : print coordinate arbitrary order make ` ` flush '' use ( print a query / answer end - of - line ) : get wrong answer make query allow make invalid query get idleness limit exceed n't print anything forget flush output moment program read -1 answer immediately exit normally ( example call exit ( 0 ) ) get wrong answer case mean make query allow make invalid query ignore get verdicts since program continue read a close stream make test <unknown> first line contain two integers n m ( 1 ≤ n m ≤ 104 ) second line contain n distinct integers xi ( -108 ≤ xi ≤ 108 ) — coordinate vertical line third line contain m distinct integers yi ( -108 ≤ yi ≤ 108 ) — coordinate horizontal line write coordinate arbitrary order see example case note example test minimum distance :,['divide and conquer'],3000.0
1179/E,"call a function good <unknown> definition set integers case 's define $$$ x $$$ $$$ x-1 $$$ $$$ f ( x ) = f ( x-1 ) + 1 $$$ $$$ f ( x ) = f ( x-1 ) $$$ tanya find $$$ n $$$ good function $$$ f _ { 1 } \ldots f _ { n } $$$ define integers $$$ 0 $$$ $$$ 10^ { 18 } $$$ $$$ f_i ( 0 ) = 0 $$$ $$$ f_i ( 10^ { 18 } ) = l $$$ $$$ i $$$ $$$ 1 $$$ $$$ n $$$ 's <unknown> coincidence $$$ n $$$ a divisor $$$ l $$$ suggest alesya a game use one question alesya ask tanya a value single function single point win alesya must choose integers $$$ l _ { i } $$$ $$$ r _ { i } $$$ ( $$$ 0 \leq l _ { i } \leq r _ { i } \leq 10^ { 18 } $$$ ) $$$ f _ { i } ( r _ { i } ) - f _ { i } ( l _ { i } ) \geq \frac { l } { n } $$$ ( $$$ f_i ( x ) $$$ mean value $$$ i $$$ -th function point $$$ x $$$ ) $$$ i $$$ $$$ 1 \leq i \leq n $$$ pair two function segment $$$ [ l_i r_i ] $$$ n't intersect ( may one common point ) unfortunately tanya n't allow make $$$ 2 \cdot 10^ { 5 } $$$ question help alesya win ! prove 's always possible choose $$$ [ l_i r_i ] $$$ satisfy condition describe 's guarantee tanya n't change function game i.e interactor <unknown> first line contain two integers $$$ n $$$ $$$ l $$$ ( $$$ 1 \leq n \leq 1000 $$$ $$$ 1 \leq l \leq 10^ { 18 } $$$ $$$ n $$$ a divisor $$$ l $$$ ) — number function value $$$ 10^ { 18 } $$$ ' ve find need $$$ l_i r_i $$$ print $$$ ` ` ! '' $$$ without quote a separate line $$$ n $$$ line $$$ i $$$ -th contain two integers $$$ l_i $$$ $$$ r_i $$$ divide space ask $$$ f_i ( x ) $$$ print symbol ` ` ? '' without quote two integers $$$ i $$$ $$$ x $$$ ( $$$ 1 \leq i \leq n $$$ $$$ 0 \leq x \leq 10^ { 18 } $$$ ) note must flush output get a response , read integer a value $$$ i $$$ -th function point $$$ x $$$ 're allow $$$ 200000 $$$ question flush use ( print integer end - of - line ) : hack : test $$$ 1 \leq l \leq 2000 $$$ allow hack a hack set a test use follow format : first line contain two integers $$$ n $$$ $$$ l $$$ ( $$$ 1 \leq n \leq 1000 $$$ $$$ 1 \leq l \leq 2000 $$$ $$$ n $$$ a divisor $$$ l $$$ ) — number function value $$$ 10^ { 18 } $$$ $$$ n $$$ follow line contain $$$ l $$$ number $$$ l_1 $$$ $$$ l_2 $$$ ... $$$ <unknown> $$$ ( $$$ 0 \leq l_j < 10^ { 18 } $$$ $$$ 1 \leq j \leq l $$$ $$$ l_j < l _ { j+1 } $$$ $$$ 1 < j \leq l $$$ ) $$$ i $$$ -th $$$ l_j $$$ mean $$$ f_i ( l_j ) < f_i ( l_j + 1 ) $$$ example tanya $$$ 5 $$$ function $$$ f ( 0 ) = 0 $$$ $$$ f ( 1 ) = 1 $$$ $$$ f ( 2 ) = 2 $$$ $$$ f ( 3 ) = 3 $$$ $$$ f ( 4 ) = 4 $$$ remain point value $$$ 5 $$$ alesya must choose two integers function difference value a function point less $$$ \frac { l } { n } $$$ ( $$$ 1 $$$ ) length intersection segment zero one possible way choose pair $$$ [ 0 $$$ $$$ 1 ] $$$ $$$ [ 1 $$$ $$$ 2 ] $$$ $$$ [ 2 $$$ $$$ 3 ] $$$ $$$ [ 3 $$$ $$$ 4 ] $$$ $$$ [ 4 $$$ $$$ 5 ] $$$ function $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ respectively",['divide and conquer'],3200.0
1096/G,bus ticket berland number a number consist $$$ n $$$ digits ( $$$ n $$$ even ) $$$ k $$$ decimal digits $$$ d_1 d_2 \dots d_k $$$ use form ticket number $$$ 0 $$$ among digits number may lead zero example $$$ n = 4 $$$ digits $$$ 0 $$$ $$$ 4 $$$ use $$$ 0000 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ valid ticket number $$$ <unknown> $$$ $$$ 00 $$$ $$$ <unknown> $$$ a ticket lucky sum first $$$ n / 2 $$$ digits equal sum remain $$$ n / 2 $$$ digits calculate number different lucky ticket berland since answer may big print modulo $$$ 998244353 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ $$$ ( 2 \le n \le 2 \cdot 100000 1 \le k \le 10 ) $$$ — number digits ticket number number different decimal digits may use $$$ n $$$ even second line contain a sequence pairwise distinct integers $$$ d_1 d_2 \dots d_k $$$ $$$ ( 0 \le d_i \le 9 ) $$$ — digits may use ticket number digits give arbitrary order print number lucky ticket number take modulo $$$ 998244353 $$$ first example $$$ 6 $$$ lucky ticket number : $$$ 1111 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ one ticket number second example consist $$$ 20 $$$ digits $$$ 6 $$$ ticket number lucky answer $$$ 1 $$$,"['divide and conquer', 'dp']",2400.0
1218/D,"galaxy far far away ancient interplanetary republic bubbleland consist $$$ n $$$ planets , $$$ m $$$ bidirectional wormholes connect a pair planets bubbleland a <unknown> republic a capital planet <unknown> another planet reach use wormholes also guarantee wormhole connect planet two different wormholes connect pair planets call a path begin one planet visit planets return start point a tour interplanetary safety <unknown> guarantee planet belong one tour $$$ 42 $$$ tour many <unknown> usage wormholes need repair wormhole cost $$$ w _ { i } $$$ need pay reparation unfortunately senate bubbleland short budget therefore decide fix many wormholes need order planets reachable capital pay little money repair however way senate calculate cost different cost set reparations binary xor cost individual reparation reparations make cost $$$ a _ { 1 } a _ { 2 } ... a _ { k } $$$ cost entire set $$$ a _ { 1 } \oplus a _ { 2 } \oplus ... \oplus a _ { k } $$$ senate would like know much money pay also number different ways achieve cost modulo $$$ 1000000007 $$$ first line input contain two number $$$ n ( 1 \leq n \leq 100.000 ) $$$ number planets $$$ m ( 1 \leq m \leq <unknown> ) $$$ number wormholes follow $$$ m $$$ line contain three number $$$ u v ( 1 \leq u \neq v \leq n ) $$$ $$$ w ( 1 \leq w \leq 100.000 ) $$$ mean exist a wormhole connect planets $$$ u $$$ $$$ v $$$ repair cost $$$ w $$$ output two number smallest possible cost entire reparation number different valid reparations cost modulo $$$ 1000000007 $$$ repair wormholes $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 5 $$$ $$$ 6 $$$ pay $$$ 5 \oplus <unknown> 2 \oplus 3 \oplus <unknown> $$$ one check <unknown> repair planets connect valid repair cost","['divide and conquer', 'graphs']",2400.0
768/B,"jon fight <unknown> rescue <unknown> attack white - walkers <unknown> arrival sam tell want go <unknown> train citadel become a maester return take <unknown> <unknown> 's place maester castle black jon agree sam 's proposal sam set journey citadel however become a <unknown> citadel a <unknown> hence <unknown> citadel give sam a problem test eligibility initially sam a list a single element n. perform certain operations list operation sam must remove element x x > 1 list insert position , sequentially must continue operations elements list either 0 1 . master want total number 1s range l r ( 1 - indexed ) sam want become a maester unfortunately solve problem help sam pass eligibility test ? first line contain three integers n l r ( 0 ≤ n < 250 0 ≤ r - l ≤ 105 r ≥ 1 l ≥ 1 ) – initial element range l r. guarantee r greater length final list output total number 1s range l r final sequence consider first example : elements position 2 - nd 5 - th list [ 1 1 1 1 ] number ones 4 . second example : elements position 3 - rd 10 - th list [ 1 1 1 0 1 0 1 0 ] number ones 5","['dfs and similar', 'divide and conquer']",1600.0
1316/F,"$$$ n $$$ officer army byteland officer power associate power $$$ i $$$ -th officer denote $$$ p _ { i } $$$ war fast approach general would like know strength army strength army calculate a strange way byteland general select a random subset officer $$$ n $$$ officer call subset a battalion ( $$$ 2^n $$$ subsets $$$ n $$$ officer choose equally <unknown> include empty subset subset officer ) strength a battalion calculate follow way : let power choose officer $$$ a _ { 1 } a _ { 2 } \ldots a _ { k } $$$ $$$ a_1 \le a_2 \le \dots \le a_k $$$ strength battalion equal $$$ <unknown> + <unknown> + \dots + a _ { k-1 } a_k $$$ ( size battalion $$$ \leq 1 $$$ strength battalion $$$ 0 $$$ ) strength army equal expect value strength battalion war really long power officer may change precisely $$$ q $$$ change one form $$$ i $$$ $$$ x $$$ indicate $$$ p _ { i } $$$ change $$$ x $$$ need find strength army initially $$$ q $$$ update note change <unknown> strength find modulo $$$ 10^ { 9 } +7 $$$ formally let $$$ <unknown> { 9 } +7 $$$ show answer express irreducible fraction $$$ p / q $$$ $$$ p $$$ $$$ q $$$ integers $$$ <unknown> 0 \bmod m $$$ ) output integer equal $$$ <unknown> q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \leq x < m $$$ $$$ x <unknown> q \equiv p \bmod m $$$ ) first line input contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 3⋅10^ { 5 } $$$ ) — number officer byteland 's army second line contain $$$ n $$$ integers $$$ p _ { 1 } p _ { 2 } \ldots p _ { n } $$$ ( $$$ 1 \leq p _ { i } \leq 10^ { 9 } $$$ ) third line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 3⋅10^ { 5 } $$$ ) — number update next $$$ q $$$ line contain two integers $$$ i $$$ $$$ x $$$ ( $$$ 1 \leq i \leq n $$$ $$$ 1 \leq x \leq 10^ { 9 } $$$ ) indicate $$$ p _ { i } $$$ update $$$ x $$$ first line output initial strength army $$$ i $$$ -th next $$$ q $$$ line output strength army $$$ i $$$ -th update first testcase initially four possible <unknown> change $$$ p _ { 1 } $$$ $$$ 2 $$$ strength <unknown> { $$$ 1,2 $$$ } change $$$ 4 $$$ strength army become $$$ 1 $$$ change $$$ p _ { 2 } $$$ $$$ 1 $$$ strength battalion { $$$ 1,2 $$$ } become $$$ 2 $$$ strength army become $$$ \frac { 1 } { 2 } $$$","['data structures', 'divide and conquer']",2800.0
862/D,mahmoud ehab fourth stage dr . evil a hide binary string length n. guarantee least one ' 0 ' symbol least one ' 1 ' symbol want mahmoud ehab find a position ' 0 ' symbol ' 1 ' symbol order mahmoud ehab ask dr . evil 15 question tell dr . evil binary string length n dr . evil tell ham distance two string ham distance 2 binary string length number position different symbols find definition ham distance note section help mahmoud ehab find two position get wrong answer verdict exceed maximum number query terminate 0 case 'll get wrong answer n't terminate may receive verdict 'll read a close stream first line input contain a single integer n ( 2 ≤ n ≤ 1000 ) — length hide binary string print final answer print ` ` ! pos0 pos1 '' ( without quote ) pos0 pos1 position ' 0 ' ' 1 ' string ( string 1 - indexed ) n't forget flush output print answer ! ask a question use format ` ` ? s '' ( without quote ) s a query string n't forget flush output print a query ! query read a single integer standard input — ham distance hide string query string flush output use : - hack hack someone print one binary string length 1000 contain least one ' 0 ' least one ' 1 ' ham distance definition : https : //en.wikipedia.org / wiki / <unknown> first test case hide binary string 101 first query 000 ham distance 2 . second query hide string still 101 query 001 ham distance 1 . query find symbol position 2 ' 0 ' symbol position 1 ' 1 ' print ` ` ! 2 1 '',"['binary search', 'divide and conquer']",2000.0
1372/F,"ray lose array need find ask omkar omkar will <unknown> array follow qualities : ray allow send omkar a series query a query consist two integers $$$ l $$$ $$$ r $$$ $$$ 1 \le l \le r \le n $$$ omkar respond two integers $$$ x $$$ $$$ f $$$ $$$ x $$$ mode subarray index $$$ l $$$ index $$$ r $$$ inclusive mode array define number appear frequently multiple number appear number time smallest number consider mode $$$ f $$$ amount time $$$ x $$$ appear query subarray array $$$ k $$$ ( $$$ 1 \le k \le \min ( 25000 n ) $$$ ) distinct elements however due ray 's sin omkar tell ray $$$ k $$$ ray allow send $$$ 4k $$$ query help ray find lose array line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) equal length array try find interaction start read $$$ n $$$ make one type query : answer query form ` ` $$$ x \enspace f $$$ ` ` $$$ x $$$ mode subarray $$$ f $$$ number time $$$ x $$$ appear subarray output answer print : quit query count towards $$$ 4k $$$ query limit print a query forget output end line flush output otherwise get idleness limit exceed , use : hack formatto hack output $$$ 1 $$$ integer first line $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) second line output $$$ n $$$ integers $$$ a_1 a_2 \ldots a _ { n-1 } a_n $$$ separate a space $$$ 25000 $$$ distinct number $$$ a_j \le a _ { j+1 } $$$ $$$ j $$$ $$$ 1 $$$ $$$ n-1 $$$ first query $$$ l=1 $$$ $$$ r=6 $$$ mode $$$ 2 $$$ $$$ 2 $$$ appear $$$ 2 $$$ time $$$ <unknown> $$$ $$$ <unknown> $$$ note $$$ 3 $$$ also appear two time $$$ 2 $$$ output $$$ 2 $$$ smaller second query $$$ l=1 $$$ $$$ r=3 $$$ mode $$$ 2 $$$ $$$ 2 $$$ appear twice subarray indices $$$ [ 1,3 ] $$$ third query $$$ <unknown> $$$ $$$ r=6 $$$ mode $$$ 3 $$$ $$$ 3 $$$ appear twice subarray indices $$$ [ <unknown> ] $$$ fourth query $$$ <unknown> $$$ $$$ <unknown> $$$ mode $$$ 2 $$$ appear subarray indices $$$ [ 3,4 ] $$$ note $$$ 3 $$$ also appear range $$$ 2 $$$ smaller $$$ 3 $$$","['binary search', 'divide and conquer']",2700.0
1613/F,give a root tree consist $$$ n $$$ vertices number $$$ 1 $$$ $$$ n $$$ root tree vertex $$$ 1 $$$ color vertices tree $$$ n $$$ color ( also number $$$ 1 $$$ $$$ n $$$ ) exactly one vertex color let $$$ c_i $$$ color vertex $$$ i $$$ $$$ p_i $$$ parent vertex $$$ i $$$ root tree color consider beautiful vertex $$$ k $$$ ( $$$ k > 1 $$$ ) $$$ c_k = c _ { p_k } - 1 $$$ i. e. vertex color less color parent exactly $$$ 1 $$$ calculate number beautiful color print modulo $$$ 998244353 $$$ first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 250000 $$$ ) — number vertices tree $$$ n-1 $$$ line follow $$$ i $$$ -th line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ ; $$$ x_i \ne y_i $$$ ) denote edge vertex $$$ x_i $$$ vertex $$$ y_i $$$ edge form a tree print one integer — number beautiful color take modulo $$$ 998244353 $$$,"['combinatorics', 'divide and conquer']",2600.0
364/E,' ve get n × m table ( n row m columns ) cell table contain a ` ` 0 '' a ` ` 1 '' task calculate number rectangles side parallel side table go along cell border number one occur exactly k time rectangle first line contain three space - separated integers n m k ( 1 ≤ n m ≤ 2500 0 ≤ k ≤ 6 ) — size table require number number one next n line contain m character ` ` 0 '' ` ` 1 '' i - th character j - th line correspond character j - th row i - th column table print a single number — number rectangles contain exactly k number one please write % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier,"['divide and conquer', 'two pointers']",3000.0
101/E,"little gerald coach mike play interest game begin game a pile consist n candy a pile consist m stone gerald mike move turn mike go first move mike check many candy stone gerald eat let gerald eat a candy b stone mike award gerald f ( a b ) prize point gerald move either eat a candy pile candy a stone pile stone mike see gerald eat everything apart one candy one stone award point last time game end gerald allow eat candy allow eat stone tell gerald play get largest possible number point : require find one possible optimal play strategies gerald first line contain three integers n m p ( 1 ≤ n m ≤ 20000 1 ≤ p ≤ 109 ) second line contain n integers x0 x1 ... xn - 1 ( 0 ≤ xi ≤ 20000 ) third line contain m integers y0 y1 ... ym - 1 ( 0 ≤ yi ≤ 20000 ) value f ( a b ) calculate a remainder division sum xa + yb number p. print first line number : maximal number point gerald earn print second line a sting consist n + m - 2 character either a ` ` c '' ` ` s '' i - th character ` ` c '' gerald 's i - th move eat a candy ` ` s '' eat a stone first test gerald 's first move eat a stone receive a point eat a candy get zero <unknown> way gerald get 0 point first move 1 second one , maximum number point gerald get equal 2 first eat a stone a candy","['divide and conquer', 'dp']",2500.0
1523/G,william own a flat central <unknown> decide rent flat next $$$ n $$$ days earn money since flat center city instantly get $$$ m $$$ offer form $$$ ( l_i r_i ) $$$ mean someone want book flat day $$$ l_i $$$ day $$$ r_i $$$ inclusive avoid spend a lot time figure whether 's profitable accept offer william decide develop algorithm algorithm process offer arrive accept offer $$$ i $$$ follow two condition satisfy : william n't sure value $$$ x $$$ ask help $$$ x $$$ $$$ 1 $$$ $$$ n $$$ want calculate total number days flat would occupy correspond value assign $$$ x $$$ first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 1 \le n \le 5 \cdot 10000 1 \le m \le 100000 ) $$$ number days number offer respectively next $$$ m $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ $$$ ( 1 \le l_i \le r_i \le n ) $$$ describe $$$ i $$$ -th rent offer offer give chronological order print $$$ n $$$ integers number $$$ i $$$ -th line must equal number days flat would occupy algorithm use value $$$ x $$$ equal $$$ i $$$ description segment first sample test $$$ x $$$ :,"['data structures', 'divide and conquer']",3200.0
413/E,"last product r2 company 2d game ' field a new revolutionary algorithm search shortest path a 2 × n maze imagine a maze look like a 2 × n rectangle divide unit square unit square either empty cell obstacle one unit time a person move empty cell maze side - adjacent empty cell shortest path problem <unknown> follow give two free maze cells need determine minimum time require go one cell unfortunately develop algorithm work well one request find shortest path practice request occur quite often , chief r2 programmer commission optimize algorithm find shortest path write a program <unknown> respond multiple request find shortest path a 2 × n maze first line contain two integers n m ( 1 ≤ n ≤ 2·105 ; 1 ≤ m ≤ 2·105 ) — width maze number query correspondingly next two line contain maze line contain n character character equal either ' . ' ( empty cell ) ' x ' ( obstacle ) next m line contain two integers vi ui ( 1 ≤ vi ui ≤ 2n ) — description i - th request number vi ui mean need print value shortest path cell maze number vi cell number ui assume cells first line maze number 1 n leave right cells second line number n + 1 2n leave right guarantee give cells empty print m line i - th line print answer i - th request — either size shortest path -1 ca n't reach second cell first one","['data structures', 'divide and conquer']",2200.0
414/C,mashmokh 's boss bimokh n't like mashmokh fire mashmokh decide go university participate acm instead find a new job want become a member <unknown> 's team order join give program task one week solve mashmokh a experience programmer actually a programmer n't able solve 's ask help task one task follow array a length 2n m query i - th query describe integer qi order perform i - th query must : give initial array a query answer query please note change query save query first line input contain a single integer n ( 0 ≤ n ≤ 20 ) second line input contain 2n space - separated integers a [ 1 ] a [ 2 ] ... a [ 2n ] ( 1 ≤ a [ i ] ≤ 109 ) initial array third line input contain a single integer m ( 1 ≤ m ≤ 106 ) fourth line input contain m space - separated integers <unknown> <unknown> ... <unknown> ( 0 ≤ qi ≤ n ) query note : since size input output could large n't use slow output techniques language example use input output stream ( cin cout ) c++ output m line i - th line print answer ( number inversions ) i - th query reverse array x [ 1 ] x [ 2 ] ... x [ n ] become new array y [ 1 ] y [ 2 ] ... y [ n ] y [ i ] = x [ n - i + 1 ] i. number inversions array x [ 1 ] x [ 2 ] ... x [ n ] number pair indices i j : i < j x [ i ] > x [ j ],"['combinatorics', 'divide and conquer']",2100.0
500/F,dohyun run a grocery store sell n items number integers 1 n. i - th ( 1 ≤ i ≤ n ) cost ci dollars i buy happiness increase hi item display p units time <unknown> dohyun display i - th item time ti customers buy i - th item time ti time ti + ( p - 1 ) inclusively also customer buy item i 'd like visit dohyun 's grocery store buy items new year party maximize happiness i a really busy person i visit store short period time word i visit store time t i buy items available time t. i buy many items possible budget hold i ca n't buy item several time due store rule necessary use whole budget i make a list q pair integers ( aj bj ) mean i may visit store time aj spend bj dollars store pair i 'd like know maximum happiness i obtain many pair i ca n't handle help ? first line contain two space - separated integers n p ( 1 ≤ n ≤ 4000 1 ≤ p ≤ 10 000 ) — number items display time item next n line describe items i - th ( 1 ≤ i ≤ n ) contain three space - separated integers ci hi ti ( 1 ≤ ci hi ≤ 4000 1 ≤ ti ≤ 10 000 ) — cost i - th item happiness i - th item time i - th item start display next line contain integer q ( 1 ≤ q ≤ 20 000 ) — number candidates next q line describe candidates j - th ( 1 ≤ j ≤ q ) contain two space - separated integers aj bj ( 1 ≤ aj ≤ 20 000 1 ≤ bj ≤ 4000 ) — visit time budget j - th visit store candidate print a single line contain maximum happiness i obtain buy items consider first sample,"['divide and conquer', 'dp']",2700.0
526/F,problem meet simplify model game pudding monsters important process develop game create level a game field pudding monsters n × n rectangular grid n cells contain monsters cells contain game object <unknown> move monsters around field two monsters touch glue together a single big one ( pudding remember ? ) statistics show interest map appear initially row column contain exactly one monster rest map <unknown> set correct position game object a <unknown> 's widely use make development process <unknown> <unknown> available <unknown> example a large n × n map choose a smaller k × k square part contain exactly k monsters suggest a simplify version original map wonder many ways choose initial map a k × k ( 1 ≤ k ≤ n ) square fragment contain exactly k pudding monsters calculate number first line contain a single integer n ( 1 ≤ n ≤ 3 × 105 ) — size initial field next n line contain coordinate cells initially contain monsters i - th next line contain two number ri ci ( 1 ≤ ri ci ≤ n ) — row number column number cell initially contain i - th monster guarantee ri distinct number ci distinct number print number distinct square fragment original field form a new map,"['data structures', 'divide and conquer']",3000.0
1295/E,"give a permutation $$$ p_1 p_2 \dots p_n $$$ ( array integer $$$ 1 $$$ $$$ n $$$ appear exactly ) weight $$$ i $$$ -th element permutation $$$ a_i $$$ first separate permutation two non - empty set — prefix suffix formally first set contain elements $$$ p_1 p_2 \dots p_k $$$ second — $$$ p _ { k+1 } p _ { <unknown> } \dots p_n $$$ $$$ 1 \le k < n $$$ , may move elements set operation allow choose element first set move second set vice versa ( move second set first ) pay $$$ a_i $$$ dollars move element $$$ p_i $$$ goal make element first set less element second set note one set empty condition meet example $$$ p = [ 3 1 2 ] $$$ $$$ a = [ 7 1 4 ] $$$ optimal strategy : separate $$$ p $$$ two part $$$ [ 3 1 ] $$$ $$$ [ 2 ] $$$ move $$$ 2 $$$ -element first set ( cost $$$ 4 $$$ ) $$$ p = [ 3 5 1 6 2 4 ] $$$ $$$ a = [ 9 1 9 9 1 9 ] $$$ optimal strategy : separate $$$ p $$$ two part $$$ [ 3 5 1 ] $$$ $$$ [ 6 2 4 ] $$$ move $$$ 2 $$$ -element first set ( cost $$$ 1 $$$ ) $$$ 5 $$$ -element second set ( also cost $$$ 1 $$$ ) calculate minimum number dollars spend first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — length permutation second line contain $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) 's guarantee sequence contain element $$$ 1 $$$ $$$ n $$$ exactly third line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) print one integer — minimum number dollars spend","['data structures', 'divide and conquer']",2200.0
1070/M,"upon a time algoland berland a single country time long go two different countries cities scatter a common territory cities represent point cartesian plane algoland consist $$$ a $$$ cities number $$$ 1 $$$ $$$ a $$$ coordinate $$$ i $$$ -th algoland city a pair integer number $$$ ( xa_i ya_i ) $$$ similarly berland consist $$$ b $$$ cities number $$$ 1 $$$ $$$ b $$$ coordinate $$$ j $$$ -th berland city a pair integer number $$$ ( <unknown> <unknown> ) $$$ three $$$ a+b $$$ mention cities lie a single straight line first step unite countries berland decide build several bidirectional freeways freeway go a line segment start a berland city end algoland city freeways ca n't intersect point except freeway 's start end moreover freeways connect $$$ a+b $$$ cities , <unknown> mean one get specify $$$ a+b $$$ cities $$$ a+b $$$ cities use freeways note freeways bidirectional mean one drive directions mayor $$$ b $$$ berland cities allocate a budget build freeways start city thus give number $$$ r_1 r_2 \dots r_b $$$ $$$ r_j $$$ number freeways go start $$$ j $$$ -th berland city total allocate budget tight cover build minimal necessary set freeways word $$$ r_1+r_2+\dots+r_b = a+b-1 $$$ help berland build freeways : input contain one several test case first input line contain a single integer number $$$ t $$$ ( $$$ 1 \le t \le 3000 $$$ ) — number test case , $$$ t $$$ test case follow solve test case separately test case completely independent affect test case start a line contain space - separated integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le 3000 $$$ ) — number algoland cities number berland cities correspondingly next line contain $$$ b $$$ space - separated integers $$$ r_1 r_2 \dots r_b $$$ ( $$$ 1 \le r_b \le a $$$ ) $$$ r_j $$$ number freeways start $$$ j $$$ -th berland city guarantee $$$ r_1+r_2+\dots+r_b = a+b-1 $$$ next $$$ a $$$ line contain coordinate algoland cities — pair space - separated integers $$$ xa_i ya_i $$$ ( $$$ -10000 \le xa_i ya_i \le 10000 $$$ ) next $$$ b $$$ line contain coordinate berland cities — pair space - separated integers $$$ xb_i yb_i $$$ ( $$$ -10000 \le xb_i yb_i \le 10000 $$$ ) cities locate distinct point three $$$ a+b $$$ cities lie a single straight line sum value $$$ a $$$ across test case n't exceed $$$ 3000 $$$ sum value $$$ b $$$ across test case n't exceed $$$ 3000 $$$ $$$ t $$$ test case first print ` ` yes '' answer ` ` '' otherwise answer print freeway build plan next $$$ a+b-1 $$$ line line plan contain two space - separated integers $$$ j $$$ $$$ i $$$ mean a freeway $$$ j $$$ -th berland city $$$ i $$$ -th algoland city build multiple solutions print","['divide and conquer', 'geometry']",3000.0
1000/F,give array $$$ a $$$ consist $$$ n $$$ integers $$$ q $$$ query $$$ i $$$ -th query denote two integers $$$ l_i $$$ $$$ r_i $$$ query find integer occur exactly subarray $$$ a $$$ index $$$ l_i $$$ index $$$ r_i $$$ ( a subarray a contiguous subsegment array ) example $$$ a = [ 1 1 2 3 2 4 ] $$$ query $$$ ( l_i = 2 r_i = 6 ) $$$ subarray interest $$$ [ 1 2 3 2 4 ] $$$ possible answer $$$ 1 $$$ $$$ 3 $$$ $$$ 4 $$$ ; query $$$ ( l_i = 1 r_i = 2 ) $$$ subarray interest $$$ [ 1 1 ] $$$ element occur exactly answer query ? first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 500000 $$$ ) third line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 500000 $$$ ) $$$ q $$$ line follow $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ represent $$$ i $$$ -th query ( $$$ 1 \le l_i \le r_i \le n $$$ ) answer query follow : integer occur subarray index $$$ l_i $$$ index $$$ r_i $$$ exactly print $$$ 0 $$$ otherwise print integer,"['data structures', 'divide and conquer']",2400.0
848/C,i wo n't feel <unknown> i <unknown> ... everything bury a string n bead leave message leave bead number 1 n leave right a shape number integers 1 n inclusive bead may shape memory a shape x a certain subsegment bead define difference last position first position shape x appear segment memory a subsegment sum memories shape occur time time shape bead change well memories sometimes <unknown> <unknown> subsegments recall find memory first line input contain two space - separated integers n m ( 1 ≤ n m ≤ 100 000 ) — number bead string total number change query respectively second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ n ) — initial shape bead 1 2 ... n respectively follow m line describe either a change bead a query subsegment a line one follow format : query print one line integer — memory recall subsegment initial string bead shape ( 1 2 3 1 3 2 1 ) consider change query order :,"['data structures', 'divide and conquer']",2600.0
793/G,oleg bank client solve interest chess problem : place n × n chessboard maximum number rook n't beat course two rook share cell remind a rook stand cell ( a b ) beat a rook stand cell ( x y ) a = x b = y. unfortunately ( fortunately ? ) oleg answer problem always n task bore oleg soon decide make difficult remove cells board a cell delete oleg ca n't put a rook rook beat ` ` '' delete cells oleg delete cells group namely repeatedly choose a rectangle side parallel board side delete cells inside rectangle formally choose a rectangle lower leave cell coordinate ( x1 y1 ) upper right cell coordinate ( x2 y2 ) delete cells coordinate ( x y ) x1 ≤ x ≤ x2 y1 ≤ y ≤ y2 guarantee cell delete twice i.e choose rectangles intersect version problem oleg ca n't solve friend igor busy a <unknown> ca n't help oleg last hope oleg ! help : give size board delete rectangles find maximum possible number rook could place board two rook beat first line contain single integer n ( 1 ≤ n ≤ 10000 ) — size board second line contain single integer q ( 0 ≤ q ≤ 10000 ) — number delete rectangles next q line contain information delete rectangles line contain four integers x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ n ) — coordinate lower leave upper right cells a delete rectangle guarantee rectangles intersect line print maximum number rook oleg place board two rook beat board example rook placement first example :,"['data structures', 'divide and conquer']",3400.0
786/C,rick morty want find mr . <unknown> ca n't alone need mr . meeseeks generate n mr . meeseeks stand a line number 1 n. color i - th mr . meeseeks ' color ai rick morty gather army want divide mr . meeseeks squads n't want squads colorful squad mr . meeseeks k different color also squad a continuous subarray mr . meeseeks line mean 1 ≤ i ≤ e ≤ j ≤ n mr . meeseeks number i mr . meeseeks number j squad mr . meeseeks number e squad also squad need presidio build a presidio need money want total number squads minimize rick morty n't <unknown> exact value k order choose k 1 n ( inclusive ) need know minimum number presidios need first line input contain a single integer n ( 1 ≤ n ≤ 105 ) — number mr . meeseeks second line contain n integers a1 a2 ... separate space ( 1 ≤ ai ≤ n ) — color mr . meeseeks order stand a line first line input print n integers separate space i - th integer minimum number presidios need value k i. first sample testcase optimal ways divide army squads k : second testcase optimal ways divide army squads k :,"['data structures', 'divide and conquer']",2400.0
549/F,"yura a team k developers a list n task number 1 n. yura go choose task do week due strange <unknown> habit number choose task a segment consecutive integers contain less 2 number i. e. a sequence form l l + 1 ... r 1 ≤ l < r ≤ n. every task i integer number ai associate denote many man - hours require complete i - th task developers self - confident actually afraid difficult task know yura decide pick a hardest task ( one take biggest number man - hours complete among several hardest task difficulty level choose arbitrary one ) complete , task number [ l r ] choose developers leave r - l task do every developer spend integer amount hours task do whole assignment exactly ai man - hours spend i - th task last least problem developers one get angry work another developer a set task [ l r ] consider good possible find a distribution work allow complete task every developer work amount time ( amount work perform yura n't matter workers well ) example let 's suppose yura choose task follow difficulties : a = [ 1 2 3 4 ] three developers disposal take hardest fourth task finish developers leave task difficulties [ 1 2 3 ] first one spend hour first task hour third one second developer spend two hours second task third developer spend two hours third task do since every developer work exactly two hours every task work require amount time another example first task require two hours instead one complete would impossible assign task a way describe besides work yura <unknown> problem solve wonder many pair ( l r ) ( 1 ≤ l < r ≤ n ) exist a segment [ l r ] good ? yura already solve problem time write code please help yura implement solution problem first line input contain two positive integers : n k ( 1 ≤ n ≤ 300 000 1 ≤ k ≤ 1 000 000 ) number task list number developers yura 's disposal second line contain n integers ai ( 1 ≤ ai ≤ 109 ) output a single integer — number pair ( l r ) satisfy condition statement first sample three good segment :","['data structures', 'divide and conquer']",2800.0
1379/F2,"note difference easy hard versions hard version unavailable cells become available easy version ca n't make hack versions solve ildar ivan tire chess really like chessboard invent a new game field a chessboard $$$ 2n \times 2 m $$$ : $$$ 2n $$$ row $$$ 2 m $$$ columns cell row $$$ i $$$ column $$$ j $$$ color white $$$ <unknown> $$$ even color black otherwise game proceed follow : ildar mark white cells chessboard unavailable ask ivan place $$$ n \times m $$$ kings remain white cells way kings attack a king attack another king locate adjacent cells share edge a corner ildar would like explore different combinations cells initially cells mark available $$$ q $$$ query query either mark a cell unavailable mark previously unavailable cell available query would like know whether possible place kings available cells a desire way please help ! first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \leq n m q \leq 200\,000 $$$ ) — size board number query $$$ q $$$ line follow contain a description a query : two integers $$$ i $$$ $$$ j $$$ denote a white cell board ( $$$ 1 \leq i \leq 2n $$$ $$$ 1 \leq j \leq 2 m $$$ $$$ i + j $$$ even ) cell $$$ ( i j ) $$$ available query become unavailable otherwise cell unavailable become available output $$$ q $$$ line $$$ i $$$ -th line contain answer a board $$$ i $$$ query ildar line contain ` ` yes '' possible place kings available cells desire way ` ` '' otherwise first example case second query cells $$$ ( 1 1 ) $$$ $$$ ( 1 5 ) $$$ unavailable ivan place three kings cells $$$ ( 2 2 ) $$$ $$$ ( 2 4 ) $$$ $$$ ( 2 6 ) $$$ third query three cells $$$ ( 1 1 ) $$$ $$$ ( 1 5 ) $$$ $$$ ( 2 4 ) $$$ unavailable remain 3 available cells : $$$ ( 2 2 ) $$$ $$$ ( 1 3 ) $$$ $$$ ( 2 6 ) $$$ ivan put 3 kings cells kings cells $$$ ( 2 2 ) $$$ $$$ ( 1 3 ) $$$ attack since cells share a corner","['data structures', 'divide and conquer']",2800.0
1139/F,$$$ m $$$ people live a city $$$ n $$$ dish sell city dish $$$ i $$$ a price $$$ p_i $$$ a standard $$$ s_i $$$ a beauty $$$ b_i $$$ person $$$ j $$$ income $$$ inc_j $$$ a prefer beauty $$$ pref_j $$$ a person would never buy a dish whose standard less person 's income also a person ca n't <unknown> a dish a price greater income person word a person $$$ j $$$ buy a dish $$$ i $$$ $$$ p_i \leq inc_j \leq s_i $$$ also a person $$$ j $$$ buy a dish $$$ i $$$ $$$ <unknown> - <unknown> \leq ( inc_j - p_i ) $$$ word price dish less person 's income $$$ k $$$ person allow absolute difference $$$ k $$$ beauty dish his / her prefer beauty print number dish buy person city first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ 1 \leq m \leq 100000 $$$ ) number dish available city number people live city second line contain $$$ n $$$ integers $$$ p_i $$$ ( $$$ 1 \leq p_i \leq 1000000000 $$$ ) price dish third line contain $$$ n $$$ integers $$$ s_i $$$ ( $$$ 1 \leq s_i \leq 1000000000 $$$ ) standard dish fourth line contain $$$ n $$$ integers $$$ b_i $$$ ( $$$ 1 \leq b_i \leq 1000000000 $$$ ) beauty dish fifth line contain $$$ m $$$ integers $$$ inc_j $$$ ( $$$ 1 \leq inc_j \leq 1000000000 $$$ ) income every person sixth line contain $$$ m $$$ integers $$$ pref_j $$$ ( $$$ 1 \leq pref_j \leq 1000000000 $$$ ) prefer beauty every person guarantee integers $$$ i $$$ $$$ 1 $$$ $$$ n $$$ follow condition hold : $$$ p_i \leq s_i $$$ print $$$ m $$$ integers number dish buy every person live city first example first person buy dish $$$ 2 $$$ second person buy dish $$$ 1 $$$ $$$ 2 $$$ third person buy dish second example first person buy dish second person buy dish $$$ 1 $$$ $$$ 4 $$$ third person buy dish $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$,"['data structures', 'divide and conquer']",2500.0
1425/B,"'s faculty 's <unknown> <unknown> ! celebrate great event faculty computer science university <unknown> ( fasilkom ) hold cpc - color <unknown> competition <unknown> cpc two players color predetermine rout fasilkom blue red $$$ n $$$ checkpoints $$$ m $$$ undirected predetermine rout rout $$$ i $$$ connect checkpoint $$$ u_i $$$ $$$ v_i $$$ $$$ ( 1 \le i \le m ) $$$ guarantee pair checkpoints connect use one rout rule cpc follow : chaneka interest participate however want waste much energy , interest number final configurations rout round turn count also exhaust chaneka ask figure ! two final configurations consider different a route $$$ u $$$ a different color two configurations first line contain two integers $$$ n $$$ $$$ m $$$ $$$ n $$$ $$$ ( 2 \le n \le 2 \cdot 1000 ) $$$ denote number checkpoints $$$ m $$$ $$$ ( 1 \le m \le 2 \cdot n ) $$$ denote number rout guarantee every checkpoint except checkpoint $$$ 1 $$$ exactly two rout connect next $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ $$$ ( 1 \le u_i v_i \le n u_i \ne v_i ) $$$ denote checkpoint route $$$ i $$$ connect guarantee every pair checkpoints exist a path connect directly <unknown> use rout output a single integer denote number final configurations round cpc modulo $$$ 1000000000 + 7 $$$ every possible final configuration example list : blue - colored number give series move $$$ blue $$$ take red - colored number give series move $$$ red $$$ take","['divide and conquer', 'dp']",2600.0
888/E,give array a consist n integers additionally integer m. choose sequence indices b1 b2 ... bk ( 1 ≤ b1 < b2 < ... < bk ≤ n ) a way value maximize choose sequence empty print maximum possible value first line contain two integers n m ( 1 ≤ n ≤ 35 1 ≤ m ≤ 109 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) print maximum possible value first example choose a sequence b = { 1 2 } sum equal 7 ( 's 3 take modulo 4 ) second example choose a sequence b = { 3 },"['bitmasks', 'divide and conquer']",1800.0
744/B,"interactive problem interaction section see information flush output problem play a game hongcow lucky ! hongcow a hide n n matrix m. let mi j denote entry i - th row j - th column matrix row columns label 1 n. matrix entries 0 109 . addition mi i = 0 valid i. task find minimum value along row exclude diagonal elements formally i must find , ask hongcow question a question consist give hongcow a subset distinct indices { w1 w2 ... wk } 1 ≤ k ≤ n. hongcow respond n integers i - th integer contain minimum value min1 ≤ j ≤ <unknown> wj may ask hongcow 20 question — think need many question answer ready answer print a single integer - 1 line n integers next line i - th integer minimum value i - th row matrix exclude i - th element forget flush final answer well print answer count ask a question get wrong answer verdict first line input contain a single integer n ( 2 ≤ n ≤ 1 000 ) print final answer print string -1 line , next line contain n integers i - th integer minimum value i - th row matrix exclude elements diagonal forget flush answer ! ask a question print a single integer k line denote size subset , next line contain k integers w1 w2 ... wk note must flush output get a response hongcow respond print a line n integers i - th integer line represent minimum value mi wj j 1 k. may ask a question 20 time otherwise get wrong answer flush use ( print integer end - of - line ) : hack hack someone use follow format course contestant program able see input first sample hongcow hide matrix a readable version demonstrate interaction column leave represent hongcow column right represent contestant second sample possible off - diagonal elements matrix zero","['bitmasks', 'divide and conquer']",1900.0
1364/E,"interactive problem ! ehab a hide permutation $$$ p $$$ length $$$ n $$$ consist elements $$$ 0 $$$ $$$ n-1 $$$ , reason want figure permutation , give ehab $$$ 2 $$$ different indices $$$ i $$$ $$$ j $$$ 'll reply $$$ ( p_i|p_j ) $$$ $$$ | $$$ bitwise - <unknown> operation ehab enough free time answer $$$ 4269 $$$ question 's ok answer many question 's lazy play <unknown> game 'll fix permutation beforehand change depend query guess permutation ? line contain integer $$$ n $$$ $$$ ( 3 \le n \le 2048 ) $$$ — length permutation ask a question print ` ` ? $$$ i $$$ $$$ j $$$ ` ` ( without quote $$$ i \neq j $$$ ) read answer $$$ ( p_i|p_j ) $$$ answer $$$ -1 $$$ instead a valid answer mean exceed number query make invalid query exit immediately receive $$$ -1 $$$ see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream print answer print ` ` ! $$$ p_1 $$$ $$$ p_2 $$$ $$$ \ldots $$$ $$$ p_n $$$ ` ` ( without quote ) note answer n't count one $$$ 4269 $$$ query print a query print answer forget output end line flush output otherwise get idleness limit exceed , use : hack : first line contain integer $$$ n $$$ ( $$$ 3 \le n \le 2^ { 11 } $$$ ) — length permutation $$$ p $$$ second line contain $$$ n $$$ space - separated integers $$$ p_1 $$$ $$$ p_2 $$$ $$$ \ldots $$$ $$$ p_n $$$ ( $$$ 0 \le p_i < n $$$ ) — elements permutation $$$ p $$$ first sample permutation $$$ [ <unknown> ] $$$ start ask $$$ <unknown> $$$ ehab reply $$$ 1 $$$ ask $$$ <unknown> $$$ ehab reply $$$ 3 $$$ finally ask $$$ <unknown> $$$ ehab reply $$$ 2 $$$ guess permutation","['bitmasks', 'divide and conquer']",2700.0
217/C,<unknown> institute <unknown> research ( <unknown> ) investigate properties two species bacteria name simply 0 1 . even a <unknown> bacteria two species difficult distinguish fact thing scientists possess able <unknown> a plant call formurosa scientists place a sample colonies bacteria formurosa 's leave activate a complicate nutrition process process color formurosa change reflect result a — possibly complicate — logical formula species bacteria involve constants <unknown> | ( ) & ( ) ^ ( xor ) 0 plant turn red otherwise — turn blue example nutrition process formurosa describe formula : ( ( ( ? ^ ? ) | ? ) & ( <unknown> ? ) ) ; formurosa four leave ( ` ` ? '' sign denote leave ) place 0 1 0 0 respective leave result nutrition process ( ( ( 0 ^ 1 ) <unknown> ) & ( 1 ^ 0 ) ) = 1 therefore plant turn blue scientists n colonies bacteria know type ; thing know sure colonies type want attempt determine bacteria 's species repeat <unknown> formurosa evaluation must place exactly one sample every leaf plant however may use multiple sample one colony a single evaluation ; even cover whole plant bacteria one colony ! possible always determine species colony matter ( assume ) ? first line input contain a single integer n ( 2 ≤ n ≤ 106 ) — number colonies bacteria second line contain formula describe nutrition process formurosa line contain character « 0 » « 1 » « ? » « | » « & » « ^ » « ( » « ) » <unknown> follow grammar : formula consist 106 character always possible determine species colony output ` ` yes '' ( without quote ) otherwise output ` ` '' ( without quote ),"['divide and conquer', 'dp']",2600.0
117/D,let a array consist n number array 's elements number 1 n even array consist <unknown> whose number even a ( <unknown> = a2i 1 ≤ 2i ≤ n ) odd array consist <unknown> whose number odd а ( <unknown> = a2i - 1 1 ≤ 2i - 1 ≤ n ) let 's define transformation array f ( a ) follow manner : let a array consist n number 1 2 3 ... n. b result apply transformation array a ( b = f ( a ) ) give m query ( l r u v ) task find query sum number bi l ≤ i ≤ r u ≤ bi ≤ v. print query result modulo mod first line contain three integers n m mod ( 1 ≤ n ≤ 1018 1 ≤ m ≤ 105 1 ≤ mod ≤ 109 ) next m line describe query query define four integers l r u v ( 1 ≤ l ≤ r ≤ n 1 ≤ u ≤ v ≤ 1018 ) please use % lld specificator read write 64 - bit integers c++ use % i64d specificator print m line contain integer — remainder modulo mod query result let 's consider first example first let 's construct array b = f ( a ) = f ( [ 1 2 3 4 ] ),"['divide and conquer', 'math']",2500.0
1583/F,"even leave fall piece , someone protect right ? find play teucer city liyue take <unknown> little kid around notice something interest structure city liyue represent a direct graph contain $$$ n $$$ nod nod label $$$ 1 $$$ $$$ n $$$ a direct edge node $$$ a $$$ node $$$ b $$$ $$$ a < b $$$ a path nod $$$ a $$$ $$$ b $$$ define a sequence edge start $$$ a $$$ travel along edge correspond direction end $$$ b $$$ length a path define number edge a rainbow path length $$$ x $$$ define a path graph exist least 2 distinct color among set $$$ x $$$ edge teucer 's favorite number $$$ k $$$ curious follow scenario : label edge a color minimum number color need ensure paths length $$$ k $$$ longer rainbow paths ? teucer want surprise <unknown> brother a map liyue also want know a valid color edge use minimum number color please help task ! line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \leq k < n \leq 1000 $$$ ) first line output $$$ c $$$ minimum color need satisfy requirements second line print a valid edge color array $$$ \frac { n ( n-1 ) } { 2 } $$$ integers range $$$ 1 $$$ $$$ c $$$ exactly $$$ c $$$ distinct color exist construction print edge increase order start node first second node example $$$ n=4 $$$ edge color correspond order edge : ( $$$ 1 $$$ $$$ 2 $$$ ) ( $$$ 1 $$$ $$$ 3 $$$ ) ( $$$ 1 $$$ $$$ 4 $$$ ) ( $$$ 2 $$$ $$$ 3 $$$ ) ( $$$ 2 $$$ $$$ 4 $$$ ) ( $$$ 3 $$$ $$$ 4 $$$ ) correspond construction first test case look like : correspond construction second test case look like :","['bitmasks', 'divide and conquer']",2500.0
234/G,little time leave berland annual football championship therefore coach team ` ` losewille rangers '' decide resume practice <unknown> interrupt <unknown> reason overall n players ` ` losewille rangers '' player team a number — a unique integer 1 n. prepare championship coach mr . floppe decide spend number practice mr . floppe spend long nights holiday plan conduct practice come a complex practice system practice consist one game n players team take part game players sort two team way case team may different number players team must least one player coach want sure series practice <unknown> pair players least one practice play different team players ' energy limit coach want achieve goal least number practice help schedule practice a single input line contain integer n ( 2 ≤ n ≤ 1000 ) first line print m — minimum number practice coach schedule print descriptions practice m line i - th line print fi — number players first team i - th practice ( 1 ≤ fi < n ) fi number 1 n — number players first team rest players play second team practice separate number a line space print number players order multiple optimal solutions print,"['divide and conquer', 'implementation']",1600.0
1770/G,"chiyuu a bracket sequence $$$ ^\dagger $$$ $$$ s $$$ length $$$ n $$$ let $$$ k $$$ minimum number character chiyuu remove $$$ s $$$ make $$$ s $$$ balance $$$ ^\ddagger $$$ , <unknown> want count number ways remove $$$ k $$$ character $$$ s $$$ $$$ s $$$ become balance modulo $$$ 998\,244\,353 $$$ note two ways remove character consider distinct set indices remove different $$$ ^\dagger $$$ a bracket sequence a string contain character ` ` ( ` ` ` ` ) '' $$$ ^\ddagger $$$ a bracket sequence call balance one turn a valid math expression add character + 1 . example sequence ( ( ) ) ( ) ( ) ( ( ) ( ( ) ) ) empty string balance ) ( ( ( ) ( ( ) ) ) ( first line input contain a string $$$ s $$$ ( $$$ 1 \leq |s| \leq 5 \cdot { 10 } <unknown> $$$ ) — bracket sequence guarantee $$$ s $$$ contain character ` ` ( ` ` ` ` ) '' output a single integer — number ways remove $$$ k $$$ character $$$ s $$$ $$$ s $$$ become balance modulo $$$ 998\,244\,353 $$$ first test case prove minimum number character chiyuu remove $$$ 2 $$$ $$$ 4 $$$ ways remove $$$ 2 $$$ character make $$$ s $$$ balance follow delete character note red second test case way make $$$ s $$$ balance delete character get empty bracket sequence consider balance","['divide and conquer', 'math']",3400.0
1490/D,"a permutation — a sequence length $$$ n $$$ integers $$$ 1 $$$ $$$ n $$$ number occur exactly example $$$ [ 1 ] $$$ $$$ [ 3 5 2 1 4 ] $$$ $$$ [ 1 3 2 ] $$$ — permutations $$$ [ 2 3 2 ] $$$ $$$ [ 4 3 1 ] $$$ $$$ [ 0 ] $$$ — polycarp recently gift a permutation $$$ a [ 1 \dots n ] $$$ length $$$ n $$$ polycarp like tree permutations want transform permutation $$$ a $$$ a root binary tree transform array different integers a tree follow : example build a tree permutation $$$ a= [ 3 5 2 1 4 ] $$$ root element $$$ <unknown> $$$ leave subtree tree build subarray $$$ a [ 1 \dots 1 ] = [ 3 ] $$$ right one — subarray $$$ a [ 3 \dots 5 ] = [ 2 1 4 ] $$$ a result follow tree build : another example : let permutation $$$ a= [ 1 3 2 7 5 6 4 ] $$$ case tree look like : let us denote $$$ d_v $$$ depth vertex $$$ a_v $$$ , number edge path root vertex number $$$ a_v $$$ note root depth zero give permutation $$$ a $$$ vertex find value $$$ d_v $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — length permutation follow $$$ n $$$ number $$$ a_1 a_2 \ldots a_n $$$ — permutation $$$ a $$$ test case output $$$ n $$$ value — $$$ d_1 d_2 \ldots d_n $$$","['dfs and similar', 'divide and conquer', 'implementation']",1200.0
1553/H,give array $$$ a $$$ consist $$$ n $$$ distinct elements integer $$$ k $$$ element array a non - negative integer exceed $$$ 2^k-1 $$$ let 's define xor distance a number $$$ x $$$ value $$$ $$$ f ( x ) = \min\limits _ { i = 1 } ^ { n } \min\limits _ { j = i + 1 } ^ { n } | ( a_i \oplus x ) - ( a_j \oplus x ) | $$$ $$$ $$$ \oplus $$$ denote bitwise xor operation every integer $$$ x $$$ $$$ 0 $$$ $$$ 2^k-1 $$$ calculate $$$ f ( x ) $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le 19 $$$ ; $$$ 2 \le n \le 2^k $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 2^k-1 $$$ ) integers distinct print $$$ 2^k $$$ integers $$$ i $$$ -th equal $$$ f ( i-1 ) $$$ consider first example :,"['bitmasks', 'divide and conquer', 'trees']",2900.0
1684/H,give a binary string $$$ s $$$ cut number non - intersecting substrings sum binary integers denote substrings a power 2 . element $$$ s $$$ exactly one substring test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow test case contain a binary string $$$ s $$$ ( $$$ 1 \le |s| \le 1000000 $$$ ) guarantee sum $$$ |s| $$$ test case exceed $$$ 1000000 $$$ test case output answer problem follow : multiple valid solutions output first test case impossible cut string substrings sum a power 2 . second test case cut valid :,"['dfs and similar', 'divide and conquer', 'math']",3400.0
632/E,a thief make way a shop usual lucky knapsack knapsack contain k object n kinds products shop infinite number products kind cost one product kind i ai thief greedy take exactly k products ( 's possible kinds take several products kind ) find possible total cost products thief nick knapsack first line contain two integers n k ( 1 ≤ n k ≤ 1000 ) — number kinds products number products thief take second line contain n integers ai ( 1 ≤ ai ≤ 1000 ) — cost products kinds 1 n. print line possible total cost steal products separate a space number print ascend order,"['divide and conquer', 'dp', 'math']",2400.0
1371/F,a warrior fight machine god thor thor challenge solve follow problem : $$$ n $$$ conveyors arrange a line number integers $$$ 1 $$$ $$$ n $$$ leave right conveyor a symbol ` ` < ` ` ` ` > '' initial state conveyor $$$ i $$$ equal $$$ i $$$ -th character string $$$ s $$$ $$$ n+1 $$$ hole number integers $$$ 0 $$$ $$$ n $$$ hole $$$ 0 $$$ leave side conveyor $$$ 1 $$$ $$$ i \geq 1 $$$ hole $$$ i $$$ right side conveyor $$$ i $$$ a ball conveyor $$$ i $$$ ball move next rule : symbol ` ` < ` ` conveyor $$$ i $$$ : symbol ` ` > '' conveyor $$$ i $$$ : answer next $$$ q $$$ query query define pair integers $$$ l r $$$ ( $$$ 1 \leq l \leq r \leq n $$$ ) : first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n \le 5 \times 100000 1 \le q \le 100000 $$$ ) second line contain a string $$$ s $$$ length $$$ n $$$ consist character ` ` < ` ` ` ` > '' next $$$ q $$$ line contain descriptions query $$$ i $$$ -th contain two integers $$$ l $$$ $$$ r $$$ $$$ ( 1 \le l \le r \le n ) $$$ describe $$$ i $$$ -th query print $$$ q $$$ line $$$ i $$$ -th print answer $$$ i $$$ -th query,"['data structures', 'divide and conquer', 'implementation']",2800.0
1278/E,a really <unknown> time generate test problem d. order prepare strong test solve follow problem give undirected label tree consist $$$ n $$$ vertices find a set segment : solve problem ? first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) — number vertices tree $$$ n - 1 $$$ line follow contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ ) denote endpoints $$$ i $$$ -th edge guarantee give graph a tree print $$$ n $$$ pair integers $$$ i $$$ -th pair contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i < r_i \le 2n $$$ ) — endpoints $$$ i $$$ -th segment $$$ 2n $$$ integers print unique guarantee answer always exist,"['dfs and similar', 'divide and conquer', 'trees']",2200.0
232/E,john doe a field a rectangular table size n × m. assume field row number 1 n top bottom field columns number 1 m leave right cell field intersection x - th row y - th column coordinate ( x ; y ) know cells john 's field paint white paint black also john a tortoise move along white cells field tortoise get a white cell coordinate ( x ; y ) cell ( x + 1 ; y ) ( x ; y + 1 ) correspond cell paint white word turtle move along white cells field right turtle go bound field addition john q query characterize four number x1 y1 x2 y2 ( x1 ≤ x2 y1 ≤ y2 ) query john want know whether tortoise start point coordinate ( x1 ; y1 ) reach point coordinate ( x2 ; y2 ) move along white square field first line contain two space - separated integers n m ( 1 ≤ n m ≤ 500 ) — field size next n line contain m character ` ` # '' ` ` ` ` : j - th character i - th line equal ` ` # '' cell ( i ; j ) paint black ` ` ` ` paint white next line contain integer q ( 1 ≤ q ≤ <unknown> ) — number query next q line contain four space - separated integers x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ m ) — coordinate start finish cells guarantee cells ( x1 ; y1 ) ( x2 ; y2 ) white q query print a single line ` ` yes '' a way cell ( x1 ; y1 ) cell ( x2 ; y2 ) meet requirements ` ` '' otherwise print answer query order query give input,"['bitmasks', 'divide and conquer', 'dp']",3000.0
1676/H2,"difference two versions version $$$ n \leq 200000 $$$ sum $$$ n $$$ test case exceed $$$ 200000 $$$ a terminal a row $$$ n $$$ equal segment number $$$ 1 $$$ $$$ n $$$ order two terminals one give array $$$ a $$$ length $$$ n $$$ $$$ i = 1 2 \dots n $$$ a straight wire point segment $$$ i $$$ top terminal point segment $$$ a_i $$$ bottom terminal ca n't select endpoints a segment example follow picture show two possible wire $$$ n=7 $$$ $$$ a= [ 4,1,4,6,7,7,5 ] $$$ a cross occur two wire share a point common picture cross circle red maximum number cross place wire optimally ? first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — elements array sum $$$ n $$$ across test case exceed $$$ 200000 $$$ test case output a single integer — maximum number cross place wire optimally first test case show second picture statement second test case wire possible two wire cross answer $$$ 1 $$$ third test case wire possible one wire answer $$$ 0 $$$","['data structures', 'divide and conquer', 'sortings']",1500.0
1567/E,"alice recently receive array $$$ a_1 a_2 \dots a_n $$$ birthday ! proud array show friend bob array happy present ! however soon bob become curious <unknown> friend would ask alice perform $$$ q $$$ operations two type array : help alice answer bob 's query ! first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n q \le 200000 $$$ ) — size array number query respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements alice 's array next $$$ q $$$ line consist three integers first integer $$$ i $$$ -th line $$$ t_i $$$ operation perform $$$ i $$$ -th step ( $$$ t_i = 1 $$$ $$$ t_i = 2 $$$ ) $$$ t_i = 1 $$$ next two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i \le n $$$ ; $$$ 1 \le y_i \le 1000000000 $$$ ) update element position $$$ x_i $$$ $$$ y_i $$$ ( set $$$ a _ { x_i } = y_i $$$ ) $$$ t_i = 2 $$$ next two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) two indices bob ask alice $$$ i $$$ -th query 's guarantee least one operation second type query type $$$ 2 $$$ print a single integer answer query first query $$$ l = 2 $$$ $$$ r = 5 $$$ non - decreasing subarrays $$$ [ p q ] $$$ $$$ [ 2,2 ] $$$ $$$ [ 3,3 ] $$$ $$$ [ <unknown> ] $$$ $$$ [ 5,5 ] $$$ $$$ [ 2,3 ] $$$ $$$ [ 4,5 ] $$$","['data structures', 'divide and conquer', 'math']",2200.0
1004/F,sonya array $$$ a_1 a_2 \ldots a_n $$$ consist $$$ n $$$ integers also one non - negative integer $$$ x $$$ perform $$$ m $$$ query two type : help sonya perform query ? bitwise a binary operation a pair non - negative integers calculate bitwise two number need write number binary notation result a number binary contain a one digit a one binary notation least one two number example $$$ 10 $$$ $$$ 19 $$$ = $$$ 1010_2 $$$ $$$ <unknown> $$$ = $$$ <unknown> $$$ = $$$ 27 $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ x $$$ ( $$$ 1\leq n m\leq 100000 $$$ $$$ 0\leq x < 2^ { 20 } $$$ ) — number number number query constant query second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0\leq a_i < 2^ { 20 } $$$ ) — number array follow $$$ m $$$ line describe query a line one follow format : query type 2 print number subarrays bitwise number range least $$$ x $$$ first example array [ $$$ 0 $$$ $$$ 3 $$$ $$$ 6 $$$ $$$ 1 $$$ ] query : second example array [ $$$ 6 $$$ $$$ 0 $$$ $$$ 3 $$$ $$$ 15 $$$ $$$ 2 $$$ ] query :,"['bitmasks', 'data structures', 'divide and conquer']",2600.0
1019/E,"year 3018 summer informatics school <unknown> grow hotel « <unknown> » choose a location school camp consist $$$ n $$$ house $$$ n-1 $$$ pathways possible reach every house use pathways everything perfect rain start weather forecast promise rain continue $$$ m $$$ days a special squad teachers able measure $$$ i $$$ -th pathway connect house $$$ u_i $$$ $$$ v_i $$$ rain could pass $$$ b_i $$$ second unfortunately rain <unknown> roads every day time pass road increase $$$ a_i $$$ second word $$$ t $$$ -th ( zero ) day start rain take $$$ a_i \cdot t + b_i $$$ second pass road unfortunately despite efforts teachers even year 3018 students house midnight midnight students go bed important find maximal time pair house day every student would know time run house find maximal time paths every pair house $$$ t=0 $$$ $$$ t=1 $$$ ... $$$ t = m-1 $$$ days first line give two integers $$$ n $$$ $$$ m $$$ — number house camp number rain days ( $$$ 1 \le n \le 100\,000 $$$ ; $$$ 1 \le m \le 1\,000\,000 $$$ ) next $$$ n-1 $$$ line give integers $$$ u_i $$$ $$$ v_i $$$ $$$ a_i $$$ $$$ b_i $$$ — description pathways ( $$$ 1 \le u_i v_i \le n $$$ ; $$$ 0 \le a_i \le 100000 $$$ ; $$$ 0 \le b_i \le 1000000000 $$$ ) $$$ i $$$ -th pathway connect house $$$ u_i $$$ $$$ v_i $$$ day $$$ t $$$ require $$$ a_i \cdot t + b_i $$$ second pass guarantee every two house connect a sequence pathways print $$$ m $$$ integers — lengths longest path camp a $$$ t=0 t=1 \ldots t = m-1 $$$ days start rain let 's consider first example first three days ( $$$ 0 \le t \le 2 $$$ ) longest path 2nd 3rd house length equal $$$ 100 + <unknown> $$$ second third day ( $$$ t=2 $$$ ) road house 1 4 length $$$ 100 $$$ keep increase , days $$$ t=2 3 4 5 $$$ longest path vertices 4 ( 1 2 ) length $$$ 180 + 10 t $$$ notice day $$$ t=2 $$$ three pathways length 100 three maximal paths equal length sixth day ( $$$ t=5 $$$ ) pathway first fifth house get length 100 . every day $$$ t=5 $$$ longest path house 4 5 length $$$ 80 + 30 t $$$","['data structures', 'divide and conquer', 'trees']",3200.0
1042/D,"petya array $$$ a $$$ consist $$$ n $$$ integers learn <unknown> sum recently calculate sum elements segment array really fast segment a non - empty sequence elements stand one next another array wonder number segment array sum less $$$ t $$$ help petya calculate number formally require calculate number pair $$$ l r $$$ ( $$$ l \le r $$$ ) $$$ a_l + a _ { l+1 } + \dots + a _ { r-1 } + a_r < t $$$ first line contain two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 200\,000 |t| \le 2\cdot10^ { 14 } $$$ ) second line contain a sequence integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ |a _ { i } | \le 10^ { 9 } $$$ ) — description petya 's array note might negative zero positive elements print number segment petya 's array sum elements less $$$ t $$$ first example follow segment sum less $$$ 4 $$$ :","['data structures', 'divide and conquer', 'two pointers']",1800.0
1423/C,may already know dušan <unknown> play railway model a big map cities connect railways map see a graph vertices cities railways connect edge far graph correspond map a tree already know a tree a connect acyclic undirected graph curious find whether railway optimize somehow want add <unknown> - <unknown> shortcuts also railways connect pair cities shortcut represent railways unique path tree pair cities connect since dušan n't like repeat railways also define good paths newly obtain network ( notice add shortcuts graph a tree ) call a path good edge appear either a regular railway edge edge represent shortcut ( every shortcut a good path length 1 use edge represent - ca n't appear path ) define good paths define good distance two cities length shortest good path finally shortcutting diameter network largest good distance two cities curious find whether possible achieve shortcutting diameter less equal $$$ k $$$ add shortcuts possible solution add $$$ \mathbf { 10 \cdot n } $$$ shortcuts first line standard input contain integer $$$ n $$$ ( $$$ 1 \le n \le 10000 $$$ ) represent number cities dušan 's railway map integer k ( $$$ 3 \le k \le n $$$ ) represent shortcutting diameter want achieve follow $$$ n - 1 $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n u_i \neq v_i $$$ ) mean a railway cities $$$ u_i $$$ $$$ v_i $$$ first line output contain a number $$$ t $$$ represent number shortcuts add follow $$$ t $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ signify a shortcut add cities $$$ u_i $$$ $$$ v_i $$$ notice add a shortcut cities city 1 make a graph <unknown> diameter become 2 . hand paths obtain way might good since edge might get duplicate example add a shortcut cities city 1 n't create a valid solution cities 5 10 path use shortcuts 5 - 1 1 - 10 valid use edge 1 - 2 2 - 3 3 - 4 4 - 5 twice,"['divide and conquer', 'graphs', 'trees']",3500.0
997/D,"consider a tree ( undirected connect graph without loop ) $$$ t_1 $$$ a tree $$$ t_2 $$$ let 's define cartesian product $$$ t_1 \times t_2 $$$ a follow way let $$$ v $$$ set vertices $$$ t_1 $$$ $$$ u $$$ set vertices $$$ t_2 $$$ set vertices graph $$$ t_1 \times t_2 $$$ $$$ v \times u $$$ , a set order pair vertices first vertex pair $$$ v $$$ second — $$$ u $$$ let 's draw follow edge : please see note section picture products tree sample test let 's examine graph $$$ t_1 \times t_2 $$$ much cycle ( necessarily simple ) length $$$ k $$$ contain ? since number large print modulo $$$ 998244353 $$$ sequence vertices $$$ w_1 $$$ $$$ w_2 $$$ ... $$$ w_k $$$ $$$ w_i \in v \times u $$$ call cycle neighbor vertices adjacent $$$ w_1 $$$ adjacent $$$ w_k $$$ cycle differ cyclic shift direction traversal still consider different first line input contain three integers — $$$ n_1 $$$ $$$ n_2 $$$ $$$ k $$$ ( $$$ 2 \le n_1 n_2 \le 4000 $$$ $$$ 2 \le k \le 75 $$$ ) — number vertices first tree number vertices second tree cycle length respectively follow $$$ n_1 - 1 $$$ line describe first tree line contain two integers — $$$ v_i u_i $$$ ( $$$ 1 \le v_i u_i \le n_1 $$$ ) define edge first tree follow $$$ n_2 - 1 $$$ line describe second tree format guarantee give graph tree print one integer — number cycle modulo $$$ 998244353 $$$ follow three picture illustrate graph products tree sample test first example list cycle length $$$ 2 $$$ follow :","['combinatorics', 'divide and conquer', 'trees']",2900.0
429/D,iahub <unknown> best competitive programmers town however ca n't qualify important contest selection make help a single problem <unknown> a friend iahub manage get hold problem contest want make sure iahub one qualify tell iahub follow task 're give ( 1 - based ) array a n elements let 's define function f ( i j ) ( 1 ≤ i j ≤ n ) ( i - j ) 2 + g ( i j ) 2 . function g calculate follow <unknown> - code : find a value mini ≠ j f ( i j ) probably iahub already figure solution problem ? first line input contain a single integer n ( 2 ≤ n ≤ 100000 ) next line contain n integers a [ 1 ] a [ 2 ] ... a [ n ] ( - 104 ≤ a [ i ] ≤ 104 ) output a single integer — value mini ≠ j f ( i j ),"['data structures', 'divide and conquer', 'geometry']",2200.0
1181/E1,problem differ next problem constraints petya decide visit byteland summer holiday turn history country quite unusual initially $$$ n $$$ different countries land berland country territory represent a rectangle map side rectangle parallel ax corner locate point integer coordinate territories two countries intersect possible territories touch time pass sometimes two countries merge one happen union territories also a rectangle end one country remain — byteland initially country a rectangular castle inside territory side parallel ax corner integer coordinate castle might touch border correspond country side castle miraculously <unknown> castle still intact unfortunately locations information restore initial territories countries petya wonder information initial countries remain suspect whole story a fake recommend a smart person please check whether exist a possible set initial territories could make story true first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000 $$$ ) — number countries castle next $$$ n $$$ line contain four integers $$$ a_i b_i c_i d_i $$$ ( $$$ 0 \leq a_i < c_i \leq 1000000000 $$$ $$$ 0 \leq b_i < d_i \leq 1000000000 $$$ ) — coordinate $$$ i $$$ -th castle $$$ ( a_i b_i ) $$$ coordinate lower leave corner $$$ ( c_i d_i ) $$$ coordinate upper right corner guarantee two castle intersect however may touch exist a possible set territories satisfy story print ` ` yes '' otherwise print ` ` '' print letter case ( upper lower ) castle first second examples show picture,"['brute force', 'divide and conquer', 'sortings']",2500.0
383/E,iahubina tire many complicate languages decide invent a new simple language already make a dictionary consist n 3 - words a 3 - word a sequence exactly 3 lowercase letter first 24 letter english alphabet ( a x ) decide letter vowels others consonants whole language base a simple rule : word contain least one vowel correct iahubina forget letter vowels want find possible correct set vowels ask iahub question question give iahub a set letter consider vowels ( question ) question want know many word dictionary correct consider give set vowels iahubina want know xor square answer possible question <unknown> different question subsets set first 24 letter english alphabet help iahub find number first line contain one integer n ( 1 ≤ n ≤ 104 ) next n line contain a 3 - word consist 3 lowercase letter two identical 3 - words print one number xor square answer query,"['combinatorics', 'divide and conquer', 'dp']",2700.0
1641/E,"give array $$$ a $$$ length $$$ n $$$ also give $$$ m $$$ distinct position $$$ p_1 p_2 \ldots p_m $$$ ( $$$ 1 \leq p_i \leq n $$$ ) a non - empty subset position $$$ t $$$ randomly select equal probability follow value calculate : $$$ $$$ \sum _ { i=1 } ^ { n } ( a_i \cdot \min _ { j \in t } <unknown> - <unknown> ) $$$ $$$ word index array $$$ a_i $$$ distance closest choose position multiply value sum find expect value sum value must find modulo $$$ 998\,244\,353 $$$ formally let $$$ m = 998\,244\,353 $$$ show answer represent irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \neq 0 $$$ ( mod $$$ m $$$ ) output integer equal $$$ p \cdot q^ { -1 } $$$ ( mod $$$ m $$$ ) word output integer $$$ x $$$ $$$ 0 \leq x < m $$$ $$$ x \cdot q = p $$$ ( mod $$$ m $$$ ) first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq m \leq n \leq 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i < 998\,244\,353 $$$ ) third line contain $$$ m $$$ distinct integers $$$ p_1 p_2 \ldots p_m $$$ ( $$$ 1 \leq p_i \le n $$$ ) every $$$ 1 \leq i < m $$$ guarantee $$$ p_i < p _ { i+1 } $$$ print a single integer — answer problem first test : answer problem $$$ \frac { 20 + 10 + 5 } { 3 } = \frac { 35 } { 3 } = <unknown> $$$ ( modulo $$$ 998\,244\,353 $$$ )","['combinatorics', 'divide and conquer', 'math']",3300.0
1842/I,"tenzing a beautiful necklace necklace consist $$$ n $$$ pearl number $$$ 1 $$$ $$$ n $$$ a string connect pearl $$$ i $$$ $$$ ( i \text { mod } n ) +1 $$$ $$$ 1 \leq i \leq n $$$ one day tenzing want cut necklace several part cut string connect part necklace $$$ k $$$ pearl time need cut string may tenzing need spend $$$ a_i $$$ minutes cut string pearl $$$ i $$$ $$$ ( i \text { mod } n ) +1 $$$ tenzing want know minimum time minutes cut necklace connect part $$$ k $$$ pearl test contain multiple test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2\leq n\leq <unknown> 100000 $$$ $$$ 1\leq k < n $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1\leq a_i\leq 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 500000 $$$ test case output minimum total time minutes require first test case necklace cut $$$ 3 $$$ part : $$$ [ 1,2 ] [ 3,4 ] [ 5 ] $$$ total time $$$ 3 $$$ second test case necklace cut $$$ 3 $$$ part : $$$ [ <unknown> ] [ 2 ] [ 3,4 ] $$$ tenzing cut string connect $$$ ( 1,2 ) ( 2,3 ) $$$ $$$ ( 4,5 ) $$$ total time $$$ <unknown> $$$","['divide and conquer', 'dp', 'greedy']",3500.0
1633/F,give a tree consist $$$ n $$$ vertices ( number $$$ 1 $$$ $$$ n $$$ ) $$$ n-1 $$$ edge ( number $$$ 1 $$$ $$$ n-1 $$$ ) initially vertices except vertex $$$ 1 $$$ <unknown> process query three type : note solve problem online mode mean ca n't read whole input read query write answer last query use function fflush c++ <unknown> java languages write program first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number vertices tree $$$ n-1 $$$ line follow $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ; $$$ u_i \ne v_i $$$ ) — endpoints $$$ i $$$ -th edge edge form a tree query follow format describe statement one line per query least $$$ 2 $$$ $$$ <unknown> $$$ query last query ( last one ) type $$$ 3 $$$ note read $$$ i $$$ -th query already give answer query $$$ i-1 $$$ ( except $$$ i = 1 $$$ ) answer one query incorrect judge program recognize instead next query may receive integer $$$ 0 $$$ a separate line receive program terminate gracefully receive ` ` wrong answer '' verdict program n't terminate solution may receive verdict like ` ` time limit exceed '' ` ` idleness limit exceed '' etc note fact solution n't receive integer $$$ 0 $$$ mean answer correct check program terminate query type $$$ 1 $$$ $$$ 2 $$$ print answer a separate line describe statement n't forget flush output,"['data structures', 'divide and conquer', 'trees']",2800.0
772/E,"interactive problem judge a hide root full binary tree n leave a full binary tree one every node either 0 2 children nod 0 children call leave tree since a full binary tree exactly 2n - 1 nod tree leave judge 's tree label 1 n. would like reconstruct a tree isomorphic judge 's tree , ask question a question consist print label three distinct leave a1 a2 a3 let depth a node shortest distance node root tree let lca ( a b ) denote node maximum depth a common ancestor nod a b. consider x = lca ( a1 a2 ) y = lca ( a2 a3 ) z = lca ( a3 a1 ) judge tell one x y z maximum depth note pair uniquely determine since tree a binary tree ; ca n't tie specifically x ( y z respectively ) maximize depth judge respond string ` ` x '' ( ` ` y '' ` ` z '' respectively ) may ask 10·n question first line input contain a single integer n ( 3 ≤ n ≤ 1 000 ) — number leave tree print final answer print string ` ` -1 '' line , next line contain 2n - 1 integers i - th integer parent i - th node -1 root answer judge correct output isomorphic judge 's tree particular label leave need label 1 n. isomorphic mean exist a permutation π node i parent node j judge tree node π ( i ) parent node π ( j ) tree ask a question print three distinct integers a1 a2 a3 integers 1 n inclusive judge respond a single character either ` ` x '' ` ` y '' ` ` z '' string ` ` x '' ( ` ` y '' ` ` z '' respectively ) mean pair ( a1 a2 ) ( ( a2 a3 ) ( a3 a1 ) respectively ) deepest lca among three pair may ask a question 10·n time otherwise get wrong answer ready answer print a single integer ` ` -1 '' line next line contain 2n - 1 integers i - th integer parent i - th node -1 root forget flush final answer well print answer count ask a question get wrong answer verdict get idleness limit exceed n't print anything forget flush output include final answer ( info flush output ) flush use ( print integer end - of - line ) : moment program read -1 answer immediately exit normally ( example call exit ( 0 ) ) get wrong answer case mean make query allow make invalid query ignore get verdicts since program continue read a close stream hack hack someone use follow format denote a tree parent i - th node pi ( pi = - 1 n < pi ≤ 2n - 1 ) pi equal -1 node i root input must describe a valid full root binary tree course contestant program able see input first sample judge hide tree : a readable format interaction :","['binary search', 'divide and conquer', 'trees']",3200.0
1808/E1,"easy version problem difference three versions constraints $$$ n $$$ $$$ k $$$ make hack versions problem solve maxim a minibus driver venus ride maxim 's minibus need a ticket ticket a number consist $$$ n $$$ digits however know residents venus use a numeral system base $$$ k $$$ rather decimal system therefore ticket number consider a sequence $$$ n $$$ integers $$$ 0 $$$ $$$ k-1 $$$ inclusive residents venus consider a ticket lucky a digit equal sum remain digits modulo $$$ k $$$ example $$$ <unknown> $$$ ticket $$$ <unknown> $$$ lucky $$$ 7 + 1 + 5 \equiv 3 \pmod { 10 } $$$ hand ticket $$$ <unknown> $$$ lucky digit equal sum others modulo $$$ 10 $$$ , a trip maxim wonder : many lucky ticket exist ? time maxim understand number large interest answer modulo prime number $$$ m $$$ line input contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \le n \le 100 $$$ $$$ 1 \le k \le 30 $$$ $$$ 100000000 \le m \le 1000000000 + 7 $$$ $$$ m $$$ a prime number ) — number digits ticket base numeral system venus <unknown> answer calculation print one integer — number lucky ticket modulo $$$ m $$$ i. e. remainder divide answer $$$ m $$$ first example four lucky ticket : $$$ 000 $$$ $$$ 011 $$$ $$$ 101 $$$ $$$ 110 $$$","['combinatorics', 'divide and conquer', 'dp']",2200.0
995/E,allen play number <unknown> phone start integer $$$ u $$$ screen every second press one 3 button allen want press 200 button end $$$ v $$$ screen help ! first line input contain 3 positive integers : $$$ u v p $$$ ( $$$ 0 \le u v \le <unknown> $$$ $$$ 3 \le p \le 1000000000 + 9 $$$ ) $$$ p $$$ guarantee prime first line print a single integer $$$ \ell $$$ number button press second line print integers $$$ c_1 \dots c_\ell $$$ button press $$$ 1 \le i \le \ell $$$ $$$ 1 \le c_i \le 3 $$$ show answer always exist first example integer screen change $$$ 1 \to 2 \to 3 $$$ second example integer screen change $$$ 3 \to 2 $$$,"['divide and conquer', 'graphs', 'number theory']",2700.0
1186/E,"<unknown> cossack a field dimension $$$ n \times m $$$ consist ` ` 0 '' ` ` 1 '' build infinite field field way : example initial field : first iteration field like : second iteration field like : ... let 's numerate line top bottom $$$ 1 $$$ infinity columns leave right $$$ 1 $$$ infinity call submatrix $$$ ( x_1 y_1 x_2 y_2 ) $$$ number coordinate $$$ ( x y ) $$$ $$$ x_1 \leq x \leq x_2 $$$ $$$ y_1 \leq y \leq y_2 $$$ cossack need sometimes find sum number submatrices since pretty busy right ask find answer ! first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \leq n m \leq 1\,000 $$$ $$$ 1 \leq q \leq 100000 $$$ ) — dimension initial matrix number query next $$$ n $$$ line contain $$$ m $$$ character $$$ c _ { ij } $$$ ( $$$ 0 \leq c _ { ij } \leq 1 $$$ ) — character matrix next $$$ q $$$ line contain four integers $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \leq x_1 \leq x_2 \leq 1000000000 $$$ $$$ 1 \leq y_1 \leq y_2 \leq 1000000000 $$$ ) — coordinate upper leave cell bottom right cell need find sum number query print answer first example explain legend","['divide and conquer', 'implementation', 'math']",2500.0
317/E,"princess vlada enjoy <unknown> <unknown> walk forest one day — wonderful <unknown> day — walk princess find <unknown> shadow miss ! ` ` <unknown> ! ` ` — think start search shadow forest normally shadow lazy simply sleep princess <unknown> hot summer day get bore a <unknown> life decide play vlada forest character entertain may represent a set integer cells plane shadow princess move , leave right 1 . cells ( happen decent forest ) occupy tree shadow princess allow enter a cell occupy a tree unfortunately hard time forest tree grow ... first princess walk within cell ( vx vy ) shadow hide princess cell ( sx sy ) princess shadow tree locate different cells shadow play princess soon princess move 1 direction shadow simultaneously fly 1 direction possible ( cell fly occupy tree ) ; otherwise shadow n't move shadow <unknown> character interfere say shadow catch princess move locate cell vlada manage catch shadow ! ? first line input contain coordinate character vx vy sx sy number tree m ( 0 ≤ m ≤ 400 ) follow m line contain coordinate tree coordinate integers -100 100 inclusive princess shadow tree locate different cells impossible princess catch shadow print ` ` -1 '' ( without quote ) otherwise print a sequence character ` ` l '' ` ` r '' ` ` d '' ` ` u '' correspond princess 's move follow able catch shadow turn ( l — move leave r — right u — d — ; axis x direct right y — ) number character ( number move ) must exceed 106 . princess 's move correct must lead cell a tree grow allow princess shadow occupy cell last turn picture sample give ( princess shadow tree color pink gray black correspondingly ; blue dot mark lattice center ) first case princess may make two leave step one step upwards one right step : follow case princess catch shadow : last sample princess may make two leave step one step ( order ) :",['shortest paths'],3100.0
1184/B3,"rebel save enough gold launch a full - scale attack situation flip rebel send spaceships attack empire base ! galaxy represent undirected graph $$$ n $$$ planets ( nod ) $$$ m $$$ wormholes ( edge ) connect two planets a total $$$ s $$$ rebel spaceships $$$ b $$$ empire base locate different planets galaxy spaceship give a location $$$ x $$$ denote index planet locate attack strength $$$ a $$$ a certain amount fuel $$$ f $$$ a price operate $$$ p $$$ base give a location $$$ x $$$ a defensive strength $$$ d $$$ a certain amount gold $$$ g $$$ a spaceship attack a base condition hold : rebel proud <unknown> , a spaceship attack base rebel pilot accept operate a spaceship operate profit generate spaceship equal gold base attack <unknown> price operate spaceship note might negative a spaceship operate attack base maximize profit darth vader like appear rich time therefore whenever a base attack gold steal make sure immediately <unknown> base gold therefore purpose rebel multiple spaceships attack base case spaceship still receive gold base rebel task heidi doctor decide set spaceships operate order maximize total profit however war go a long time pilot form <unknown> <unknown> refuse operate spaceships friends also operate spaceships a list $$$ k $$$ dependencies form $$$ s_1 s_2 $$$ denote spaceship $$$ s_1 $$$ operate spaceship $$$ s_2 $$$ also operate first line input contain integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 100 $$$ $$$ 0 \leq m \leq 10000 $$$ ) number nod number edge respectively next $$$ m $$$ line contain integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \leq u v \leq n $$$ ) denote undirected edge two nod next line contain integers $$$ s $$$ $$$ b $$$ $$$ k $$$ ( $$$ 1 \leq s b \leq 100000 $$$ $$$ 0 \leq k \leq 1000 $$$ ) number spaceships base dependencies respectively next $$$ s $$$ line contain integers $$$ x a f p $$$ ( $$$ 1 \leq x \leq n $$$ $$$ 0 \leq a f p \leq 1000000000 $$$ ) denote location attack fuel price spaceship ship number $$$ 1 $$$ $$$ s $$$ next $$$ b $$$ line contain integers $$$ x d g $$$ ( $$$ 1 \leq x \leq n $$$ $$$ 0 \leq d g \leq 1000000000 $$$ ) denote location defence gold base next $$$ k $$$ line contain integers $$$ s_1 $$$ $$$ s_2 $$$ ( $$$ 1 \leq s_1 s_2 \leq s $$$ ) denote a <unknown> $$$ s_1 $$$ $$$ s_2 $$$ print a single integer maximum total profit achieve optimal strategy operate spaceships 1 2 4 attack base 1 1 2 respectively",['shortest paths'],2700.0
95/C,petya love volleyball much one day run late a volleyball match petya n't buy car yet 's take a taxi city n junctions connect two - way roads length road define positive integer number meter ; roads different lengths initially junction exactly one taxi stand taxi driver i - th junction agree drive petya ( perhaps several intermediate junctions ) junction travel distance ti meter also cost ride n't depend distance equal ci bourles taxis ca n't stop middle a road taxi use petya catch taxi junction stand initially moment petya locate junction x volleyball stadium junction y. determine minimum amount money petya need drive stadium first line contain two integers n m ( 1 ≤ n ≤ 1000 0 ≤ m ≤ 1000 ) number junctions roads city correspondingly junctions number 1 n inclusive next line contain two integers x y ( 1 ≤ x y ≤ n ) number initial final junctions correspondingly next m line contain roads ' description road describe a group three integers ui vi wi ( 1 ≤ ui vi ≤ n 1 ≤ wi ≤ 109 ) — number junctions connect road length road correspondingly next n line contain n pair integers ti ci ( 1 ≤ ti ci ≤ 109 ) describe taxi driver wait i - th junction — maximum distance drive drive 's cost road ca n't connect junction a pair junctions one road consecutive number line separate exactly one space character taxis ca n't drive petya destination point print ` ` -1 '' ( without quote ) otherwise print drive 's minimum cost please use % lld specificator read write 64 - bit integers с++ prefer use cin cout stream % i64d specificator optimal way — ride junction 1 2 ( via junction 4 ) 2 3 . cost 7 + <unknown> bourles,['shortest paths'],1900.0
198/B,vasya play a computer game <unknown> stage vasya 's ninja get a deep canyon canyon consist two vertical parallel wall height n meter let 's imagine split wall 1 meter - long areas number positive integers 1 n bottom top areas safe ninja climb others <unknown> ninja ca n't let 's call areas dangerous initially ninja lower area leave wall use second perform one follow action : point time ninja try get area a number larger n assume ninja get canyon canyon get <unknown> second water level raise one meter initially water level lower border first area ninja area cover water assume ninja water ` ` move turn '' — first ninja perform action water raise one meter ninja perform one action level consider complete ninja manage get canyon several fail attempt vasya start doubt whether possible complete level help answer question first line contain two integers n k ( 1 ≤ n k ≤ 105 ) — height canyon height ninja 's jump correspondingly second line contain description leave wall — a string length n character i - th character represent state i - th wall area : character ` ` x '' represent a dangerous area character ` ` - '' represent a safe area third line describe right wall format guarantee first area leave wall dangerous print ` ` yes '' ( without quote ) ninja get canyon otherwise print ` ` '' ( without quote ) first sample ninja first jump right wall go one meter along right wall jump leave wall next jump get ninja canyon second sample 's way ninja get canyon,['shortest paths'],1400.0
33/B,boy valera like string even like identical 's spare time valera play follow game take two string consist lower case latin letter try make identical accord game rule move valera change one arbitrary character ai one string arbitrary character bi pay every move a particular sum money equal wi allow make many move need since valera a economical boy never waste money ask experience programmer help answer question : minimum amount money valera get identical string first input line contain two initial non - empty string s t consist lower case latin letter length string n't exceed 105 . follow line contain integer n ( 0 ≤ n ≤ 500 ) — amount possible change follow n line contain character ai bi ( lower case latin letter ) integer wi ( 0 ≤ wi ≤ 100 ) say 's allow change character ai character bi string spend sum money wi answer exist output answer problem result string otherwise output -1 line answer unique output,['shortest paths'],1800.0
605/E,"scientists recently discover wormholes — object space allow travel long distance galaxies star systems scientists know n galaxies within reach galaxy number 1 need get galaxy number n. get galaxy i galaxy j need fly onto a wormhole ( i j ) exactly one galaxy day find galaxy j. unfortunately require wormhole always available every galaxy day disappear appear random however state wormholes change within one galaxy day a wormhole galaxy i galaxy j exist galaxy day take separately probability pij always find wormholes exist give moment moment either travel another galaxy one wormholes exist moment simply wait one galaxy day see wormholes lead current position next day task find expect value time need travel galaxy 1 galaxy n act optimal way guarantee expect value exist first line input contain a single integer n ( 1 ≤ n ≤ 1000 ) — number galaxies within reach follow a matrix n row n columns element pij represent probability a wormhole galaxy i galaxy j. probabilities give <unknown> integers guarantee elements main diagonal equal 100 . print a single real value — expect value time need travel galaxy 1 galaxy n one act optimal way answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer a answer jury b. checker program consider answer correct , second sample wormhole galaxy 1 galaxy 2 appear every day probability equal <unknown> . expect value days one need wait event occur",['shortest paths'],2700.0
1245/E,hyakugoku <unknown> resident <unknown> south black <unknown> temple order <unknown> dream become a <unknown> spend six months temple play ` ` cat 's <unknown> '' want try a different game — ` ` snake ladder '' unfortunately already kill snake ladder leave game play a $$$ 10 \times 10 $$$ board follow : please note : hyakugoku want finish game soon possible thus turn choose whether climb ladder optimally help determine minimum expect number turn game take input consist ten line $$$ i $$$ -th line contain 10 non - negative integers $$$ h _ { i1 } h _ { i2 } \dots h _ { <unknown> } $$$ $$$ h _ { ij } $$$ $$$ 0 $$$ tile $$$ i $$$ -th row $$$ j $$$ -th column ladder otherwise ladder tile a height $$$ h _ { ij } $$$ i.e climb lead tile $$$ h _ { ij } $$$ row directly guarantee $$$ 0 \leq h _ { ij } < i $$$ also first number first line first number last line always contain $$$ 0 $$$ i.e goal start tile never ladder print one line contain a single floating - point number — minimum expect number turn hyakugoku take finish game answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ a <unknown> path board example 2 follow : tile 's ' start tile tile ' e ' goal first example ladder second example board look like one right part image ( ladder color clarity ) possible ladder overlap case red yellow ladder green blue ladder also possible ladder go straight top case black blue ladder however possible ladder go higher ( outside board ) also possible two ladder lead tile case red yellow ladder also notice red yellow ladder lead tile orange ladder player choose climb either red yellow ladder able climb orange ladder finally notice green ladder pass start tile blue ladder player transfer green ladder blue ladder middle climb green ladder,"['dp', 'shortest paths']",2300.0
575/G,people bubbleland like drink beer little know beer good strong every time drink speed go 10 time <unknown> drink <unknown> live city beergrade want go city beerburg give a road map bubbleland need find <unknown> way start journey beergrade speed 1 . come a new city always try a <unknown> local beer divide speed 10 . question minimal time reach beerburg several paths minimal time pick one least roads still one path pick guarantee least one path beergrade beerburg first line input contain integer n — number cities bubbleland integer m — number roads country cities enumerate 0 n - 1 city 0 beergrade city n - 1 beerburg follow m line contain three integers a b ( a ≠ b ) len number indicate a bidirectional road cities a b length len first line output contain minimal time need go beergrade beerburg second line output contain number cities path beergrade beerburg take minimal time third line output contain number cities path order visit separate space,"['dfs and similar', 'shortest paths']",2200.0
173/B,` ` chamber secrets open '' — news spread around <unknown> students petrify due see basilisk dumbledore get fire harry try enter chamber secrets n't good news lord voldemort problem n't want anybody able enter chamber dark lord go busy <unknown> life <unknown> chamber secrets n × m rectangular grid cells columns a light ray ( a basilisk 's gaze ) pass columns without change direction spell make a column magic reflect light ray ( gaze ) four directions receive ray show figure basilisk locate right side lower right cell grid look leave ( direction lower leave cell ) accord legend anyone meet a basilisk 's gaze directly die immediately someone meet a basilisk 's gaze a column person get petrify know door chamber locate leave side upper leave corner grid anyone want enter look direction movement ( direction upper right cell ) position give dimension chamber location regular columns lord voldemort ask find minimum number columns need make magic anyone want enter chamber would petrify declare 's impossible secure chamber first line input contain two integer number n m ( 2 ≤ n m ≤ 1000 ) next n line contain m character character either ` ` . '' ` ` # '' represent one cell chamber grid 's ` ` . '' correspond cell empty ` ` # '' 's a regular column print minimum number columns make magic -1 's impossible figure show first sample test first sample make columns magic dragon figure represent basilisk <unknown> represent person enter chamber secrets black star show place person petrify yellow line represent basilisk gaze move columns,"['dfs and similar', 'shortest paths']",1800.0
1201/E2,"interactive problem alice bob play a game chessboard size $$$ n \times m $$$ $$$ n $$$ $$$ m $$$ even row number $$$ 1 $$$ $$$ n $$$ columns number $$$ 1 $$$ $$$ m $$$ two knight chessboard a white one initially position $$$ ( x_1 y_1 ) $$$ black one position $$$ ( x_2 y_2 ) $$$ alice choose one knight play bob use one alice bob play turn whoever control white knight start game a turn player must move knight adhere chess rule , knight currently position $$$ ( x y ) $$$ move position ( long inside chessboard ) : $$$ ( x+2 y+1 ) $$$ $$$ ( x+2 y-1 ) $$$ $$$ ( x-2 y+1 ) $$$ $$$ ( x-2 y-1 ) $$$ know knight strongest middle board knight a single position want reach : formally player capture knight win player target square ( $$$ ( n/2 m/2 ) $$$ white $$$ ( n/2 + 1 m/2 ) $$$ black ) position opponent 's attack also win a position attack a knight move position capture a knight mean a player move knight cell opponent 's knight alice make $$$ 350 $$$ move nobody game a draw alice unsure chess skills ask a help choose a knight win game show alice always a win strategy interaction start two integers $$$ n $$$ $$$ m $$$ ( $$$ 6 \le n m \le 1000 $$$ $$$ n $$$ $$$ m $$$ even ) — dimension chessboard second line contain four integers $$$ x_1 y_1 x_2 y_2 $$$ ( $$$ 1 \le x_1 x_2 \le n $$$ $$$ 1 \le y_1 y_2 \le m $$$ ) — position white black knight guarantee two knight different start position also guarantee none knight target square begin game ( however opponent 's target position ) program reply either ` ` white '' ` ` black '' depend knight want play case select white knight start game every turn need print two integers : $$$ x $$$ $$$ y $$$ position move knight game turn must terminate program immediately every turn opponent receive two integers : $$$ x $$$ $$$ y $$$ position bob move knight last move illegal lose game jury 's turn make $$$ 350 $$$ move n't receive ` ` -1 -1 '' case terminate program get a wrong answer verdict print anything forget output end line flush output otherwise might get idleness limit exceed , use : hack disable problem jury 's program adaptive : move jury may depend move make program first example white knight reach 's target square one move second example black knight win matter white knight move","['graphs', 'shortest paths']",3000.0
329/B,"'re a mikemon breeder currently middle journey become a mikemon master current obstacle go <unknown> biridian forest <unknown> biridian forest a two - dimensional grid consist r row c columns cell biridian forest may contain a tree may vacant a vacant cell may occupy zero mikemon breeders ( may also breeders forest ) mikemon breeders ( include ) enter cells tree one cells <unknown> exit cell initial grid include initial position exit cell initial position breeders give 's example grid ( first example ) : <unknown> ( include ) may move forest a single move breeders may perform one follow action : time make a single move breeders simultaneously make a single move ( choice move make may different breeders ) mikemon <unknown> t ( t > 0 ) mikemon breeders locate cell exactly t mikemon battle ensue time ( since battle t breeders ) battle t breeders leave forest <unknown> respective <unknown> note moment leave forest mikemon battle ensue even another mikemon breeder move exit cell immediately also note a battle happen another breeders — battle two breeders ( may multiple breeders <unknown> a single cell ) <unknown> would like leave forest order make a sequence move end a move final type make move however post sequence personal virtual idol blog , follow sequence move <unknown> goal <unknown> post sequence blog breeders know exact sequence move even make first move move way guarantee a mikemon battle possible breeders could n't battle nothing <unknown> minimum number mikemon battle must participate assume pick sequence move minimize number note require minimize number move make first line consist two integers : r c ( 1 ≤ r c ≤ 1000 ) denote number row number columns biridian forest next r row depict a row map character represent content a single cell : guarantee possible go start position exit cell a sequence move a single line denote minimum possible number mikemon battle participate pick a strategy minimize number follow picture illustrate first example blue line denote a possible sequence move post blog : three breeders leave side map able battle — lone breeder simply stay place come two breeders move lone breeder stay come three breeders right a way battle stay place second example post sequence blog : 's happen first move one cell right , two breeders directly right exit simultaneously move leave three breeder battle nothing end cell 2 breeders 2 mikemon battle conduct battle opponents leave forest finally make another move leave forest","['dfs and similar', 'shortest paths']",1500.0
1201/E1,"problem differ next problem constraints interactive problem alice bob play a game chessboard size $$$ n \times m $$$ $$$ n $$$ $$$ m $$$ even row number $$$ 1 $$$ $$$ n $$$ columns number $$$ 1 $$$ $$$ m $$$ two knight chessboard a white one initially position $$$ ( x_1 y_1 ) $$$ black one position $$$ ( x_2 y_2 ) $$$ alice choose one knight play bob use one alice bob play turn whoever control white knight start game a turn player must move knight adhere chess rule , knight currently position $$$ ( x y ) $$$ move position ( long inside chessboard ) : $$$ ( x+2 y+1 ) $$$ $$$ ( x+2 y-1 ) $$$ $$$ ( x-2 y+1 ) $$$ $$$ ( x-2 y-1 ) $$$ know knight strongest middle board knight a single position want reach : formally player capture knight win player target square ( $$$ ( n/2 m/2 ) $$$ white $$$ ( n/2 + 1 m/2 ) $$$ black ) position opponent 's attack also win a position attack a knight move position capture a knight mean a player move knight cell opponent 's knight alice make $$$ 350 $$$ move nobody game a draw alice unsure chess skills ask a help choose a knight win game show alice always a win strategy interaction start two integers $$$ n $$$ $$$ m $$$ ( $$$ 6 \le n m \le 40 $$$ $$$ n $$$ $$$ m $$$ even ) — dimension chessboard second line contain four integers $$$ x_1 y_1 x_2 y_2 $$$ ( $$$ 1 \le x_1 x_2 \le n $$$ $$$ 1 \le y_1 y_2 \le m $$$ ) — position white black knight guarantee two knight different start position also guarantee none knight target square begin game ( however opponent 's target position ) program reply either ` ` white '' ` ` black '' depend knight want play case select white knight start game every turn need print two integers : $$$ x $$$ $$$ y $$$ position move knight game turn must terminate program immediately every turn opponent receive two integers : $$$ x $$$ $$$ y $$$ position bob move knight last move illegal lose game jury 's turn make $$$ 350 $$$ move n't receive ` ` -1 -1 '' case terminate program get a wrong answer verdict print anything forget output end line flush output otherwise might get idleness limit exceed , use : hack disable problem jury 's program adaptive : move jury may depend move make program first example white knight reach 's target square one move second example black knight win matter white knight move","['graphs', 'shortest paths']",2900.0
3/A,king leave alone chessboard <unknown> <unknown> n't lose heart business national importance example pay official visit square t. king habit waste time want get current position s square t least number move help one move king get square a common side a common vertex square king currently ( generally 8 different square move ) first line contain chessboard coordinate square s second line — square t. chessboard coordinate consist two character first one a lowercase latin letter ( a h ) second one a digit 1 8 . first line print n — minimum number king 's move n line print move move describe one 8 : l r u d <unknown> <unknown> <unknown> rd l r u d stand respectively move leave right ( accord picture ) 2 - letter combinations stand diagonal move answer unique print,"['greedy', 'shortest paths']",1000.0
919/F,"imagine alice play a card game friend bob exactly $$$ 8 $$$ card integer card range $$$ 0 $$$ $$$ 4 $$$ round alice bob turn choose two card different players let $$$ a $$$ $$$ b $$$ $$$ a $$$ number player 's card $$$ b $$$ number opponent 's card necessary $$$ a \cdot b \ne 0 $$$ calculate $$$ c = ( a + b ) \bmod 5 $$$ replace number $$$ a $$$ $$$ c $$$ player end number $$$ 8 $$$ card $$$ 0 $$$ win alice want know win situations give card ' number bob 's card ' number person play first round task determine win choose best operation round first line contain one positive integer $$$ t $$$ ( $$$ 1 \leq t \leq 100\,000 $$$ ) denote number situations need consider follow line describe $$$ t $$$ situations situation : guarantee $$$ <unknown> $$$ $$$ \sum _ { i=1 } ^ { 8 } a_i \ne 0 $$$ also $$$ <unknown> $$$ $$$ \sum _ { i=1 } ^ { 8 } b_i \ne 0 $$$ hold output $$$ t $$$ line situation determine win output first situation alice number $$$ 0 $$$ win immediately second situation bob pick number $$$ 4 $$$ $$$ 1 $$$ $$$ ( 4 + 1 ) \bmod 5 = 0 $$$ bob win operation third situation alice pick number $$$ 1 $$$ $$$ 4 $$$ win operation fourth situation prove fall a loop","['graphs', 'shortest paths']",2600.0
1528/D,$$$ n $$$ cities shaazzzland number $$$ 0 $$$ $$$ n-1 $$$ ghaazzzland <unknown> enemy shaazzzland rule aaparsa head ghaazzzland 's intelligence agency aaparsa carry important spy mission ghaazzzland 's history shaazzzland aaparsa plant $$$ m $$$ transport cannon cities shaazzzland $$$ i $$$ -th cannon plant city $$$ a_i $$$ initially point city $$$ b_i $$$ guarantee $$$ n $$$ cities least one transport cannon plant inside two cannon city initially point city ( pair $$$ ( a_i b_i ) $$$ distinct ) aaparsa use advance technology build cannon cannon rotate every second word $$$ i $$$ -th cannon point towards city $$$ x $$$ second target city $$$ ( x + 1 ) \mod n $$$ next second name suggest transport cannon transportation specifically human transport use $$$ i $$$ -th cannon launch towards city 's currently point 'll airborne $$$ c_i $$$ second reach target destination still n't get use $$$ i $$$ -th cannon $$$ s $$$ -th second ( use possible currently city $$$ a_i $$$ ) shoot city $$$ ( b_i + s ) \mod n $$$ 'll land $$$ c_i $$$ second ( 'll $$$ ( s + c_i ) $$$ -th second ) also note cannon initially launch rotate every second obviously wo n't change direction airborne aaparsa want use cannon travel shaazzzland 's cities grand plan start travel second $$$ 0 $$$ fully <unknown> need know minimum number second require reach city $$$ u $$$ city $$$ v $$$ use cannon every pair cities $$$ ( u v ) $$$ note aaparsa stay a city long want first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 2 \le n \le 600 n \le m \le n^2 ) $$$ — number cities cannon correspondingly $$$ i $$$ -th line follow $$$ m $$$ line contain three integers $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ $$$ ( 0 \le a_i b_i \le n-1 1 \le c_i \le 1000000000 ) $$$ denote cannon city $$$ a_i $$$ initially point $$$ b_i $$$ travel take $$$ c_i $$$ second guarantee $$$ n $$$ cities least one transport cannon plant inside two cannon city initially point city ( pair $$$ ( a_i b_i ) $$$ distinct ) print $$$ n $$$ line line contain $$$ n $$$ integers $$$ j $$$ -th integer $$$ i $$$ -th line equal minimum time require reach city $$$ j $$$ city $$$ i $$$ first example one possible path go $$$ 0 $$$ $$$ 2 $$$ would :,"['graphs', 'shortest paths']",2500.0
1482/F,give a weight undirected graph $$$ n $$$ vertices along $$$ q $$$ triple $$$ ( u v l ) $$$ triple $$$ u $$$ $$$ v $$$ vertices $$$ l $$$ a positive integer edge $$$ e $$$ call useful least one triple $$$ ( u v l ) $$$ a path ( necessarily simple ) follow properties : please print number useful edge graph first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2\leq n\leq 600 $$$ $$$ 0\leq m\leq \frac { n ( n-1 ) } 2 $$$ ) follow $$$ m $$$ line contain three integers $$$ u $$$ $$$ v $$$ $$$ w $$$ ( $$$ 1\leq u v\leq n $$$ $$$ u\neq v $$$ $$$ 1\leq <unknown> 1000000000 $$$ ) denote edge connect vertices $$$ u $$$ $$$ v $$$ a weight $$$ w $$$ follow line contain integer $$$ q $$$ ( $$$ 1\leq <unknown> \frac { n ( n-1 ) } 2 $$$ ) denote number triple follow $$$ q $$$ line contain three integers $$$ u $$$ $$$ v $$$ $$$ l $$$ ( $$$ 1\leq u v\leq n $$$ $$$ u\neq v $$$ $$$ 1\leq l\leq 1000000000 $$$ ) denote a triple $$$ ( u v l ) $$$ 's guarantee : print a single integer denote number useful edge graph first example edge useful except one weight $$$ 5 $$$ second example edge $$$ 1 $$$ $$$ 2 $$$ useful belong path $$$ 1 - 2 $$$ $$$ 10 \leq 11 $$$ edge $$$ 3 $$$ $$$ 4 $$$ hand useful third example edge useful a path $$$ 1 - 2 - 3 - 2 $$$ length exactly $$$ 5 $$$ please note path may pass a vertex,"['graphs', 'shortest paths']",2400.0
1307/G,farmer john obsess make bessie exercise ! bessie graze farm consist $$$ n $$$ field connect $$$ m $$$ direct roads road take time $$$ w_i $$$ cross currently field $$$ 1 $$$ return home field $$$ n $$$ end day farmer john plan increase time take cross certain roads increase time take cross road a nonnegative amount total increase exceed $$$ x_i $$$ $$$ i $$$ -th plan determine maximum make shortest path $$$ 1 $$$ $$$ n $$$ $$$ q $$$ independent plan first line contain integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 50 $$$ $$$ 1 \le m \le n \cdot ( n-1 ) $$$ ) — number field number roads respectively follow $$$ m $$$ line contain $$$ 3 $$$ integers $$$ u_i $$$ $$$ v_i $$$ $$$ w_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ 1 \le w_i \le 1000000 $$$ ) mean road field $$$ u_i $$$ field $$$ v_i $$$ take $$$ w_i $$$ time cross guarantee exist a way get field $$$ n $$$ field $$$ 1 $$$ guarantee graph contain self - loops parallel edge possible a road $$$ u $$$ $$$ v $$$ a road $$$ v $$$ $$$ u $$$ next line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 100000 $$$ ) number plan follow $$$ q $$$ line contain a single integer $$$ x_i $$$ query ( $$$ 0 \le x_i \le 100000 $$$ ) query output maximum farmer john make shortest path total increase exceed $$$ x_i $$$ answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -6 } $$$,"['graphs', 'shortest paths']",3100.0
1249/E,plan buy <unknown> a $$$ n $$$ <unknown> build floor number $$$ 1 $$$ $$$ n $$$ bottom top first floor want know minimum total time reach first ( bottom ) floor let : one move go floor stay $$$ x $$$ floor $$$ y $$$ ( $$$ x \ne y $$$ ) two different ways : perform many move want ( possibly zero ) task $$$ i $$$ determine minimum total time take reach $$$ i $$$ -th floor $$$ 1 $$$ -st ( bottom ) floor first line input contain two integers $$$ n $$$ $$$ c $$$ ( $$$ 2 \le n \le 2 \cdot 100000 1 \le c \le 1000 $$$ ) — number floor build time <unknown> elevator rid second line input contain $$$ n - 1 $$$ integers $$$ a_1 a_2 \dots a _ { n-1 } $$$ ( $$$ 1 \le a_i \le 1000 $$$ ) $$$ a_i $$$ time require go $$$ i $$$ -th floor $$$ ( i+1 ) $$$ -th one ( $$$ ( i+1 ) $$$ -th $$$ i $$$ -th well ) use stairs third line input contain $$$ n - 1 $$$ integers $$$ b_1 b_2 \dots b _ { n-1 } $$$ ( $$$ 1 \le b_i \le 1000 $$$ ) $$$ b_i $$$ time require go $$$ i $$$ -th floor $$$ ( i+1 ) $$$ -th one ( $$$ ( i+1 ) $$$ -th $$$ i $$$ -th well ) use elevator print $$$ n $$$ integers $$$ t_1 t_2 \dots t_n $$$ $$$ t_i $$$ minimum total time reach $$$ i $$$ -th floor first floor perform many move want,"['dp', 'shortest paths']",1700.0
1218/G,three planets $$$ x $$$ $$$ y $$$ $$$ z $$$ within alpha <unknown> system inhabit advance civilization spaceports planets connect interplanetary space shuttle flight <unknown> decide $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ return flight every exist space shuttle connection since residents alpha strong opponents symmetry a strict rule two spaceports connect a shuttle must a different number flight every pair connect spaceports goal propose a number $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ shuttle flight every two connect spaceports overall number flight differ may assume <unknown> ) every planet least one spaceport 2 ) exist shuttle flight spaceports different planets 3 ) every two spaceports a series shuttle flight enable travel <unknown> ) spaceports connect one <unknown> first row input integer number $$$ n $$$ $$$ ( 3 \leq n \leq 100 000 ) $$$ represent overall number spaceports second row integer number $$$ m $$$ $$$ ( 2 \leq m \leq 100 000 ) $$$ represent number shuttle flight <unknown> third row contain $$$ n $$$ character set $$$ \ { x y <unknown> } $$$ letter $$$ <unknown> { th } $$$ position indicate planet situate spaceport $$$ i $$$ example ` ` <unknown> '' indicate spaceports $$$ 0 $$$ $$$ 3 $$$ locate planet $$$ x $$$ spaceports $$$ 1 $$$ $$$ 2 $$$ locate $$$ y $$$ spaceports $$$ 4 $$$ $$$ 5 $$$ $$$ z $$$ start fourth row every row contain two integer number separate a whitespace number natural number smaller $$$ n $$$ indicate number spaceports connect example ` ` $$$ 12\ 15 $$$ ` ` indicate a shuttle flight spaceports $$$ 12 $$$ $$$ 15 $$$ representation shuttle flight separate row input also contain a third number set $$$ \ { 1 2 3\ } $$$ stand number shuttle flight spaceports,"['graphs', 'shortest paths']",3000.0
916/C,jamie recently find undirected weight graph follow properties interest : familiar term statement find definitions note section help jamie construct graph give number vertices edge interest ! first line input contain 2 integers n m — require number vertices edge first line output 2 integers sp mstw ( 1 ≤ sp mstw ≤ <unknown> ) — length shortest path sum edge ' weight minimum span tree next m line output edge graph line output 3 integers u v w ( 1 ≤ u v ≤ n 1 ≤ w ≤ 109 ) describe edge connect u v weight w. graph sample 1 : shortest path sequence : { 1 2 3 4 } mst edge mark asterisk ( * ) definition term use problem statement : a shortest path undirected graph a sequence vertices ( v1 v2 ... vk ) vi adjacent vi + 1 1 ≤ i < k sum weight minimize w ( i j ) edge weight i j ( https : //en.wikipedia.org / wiki / <unknown> ) a prime number a natural number greater 1 positive divisors 1 ( https : //en.wikipedia.org / wiki / <unknown> ) a minimum span tree ( mst ) a subset edge a connect edge - weighted undirected graph connect vertices together without cycle minimum possible total edge weight ( https : //en.wikipedia.org / wiki / <unknown> ) https : //en.wikipedia.org / wiki / <unknown>,"['graphs', 'shortest paths']",1600.0
843/D,give a weight direct graph consist n vertices m edge answer q query two type : first line input data contain integers n m q ( 1 ≤ n m ≤ 105 1 ≤ q ≤ 2000 ) — number vertices edge graph number request correspondingly next m line input data contain descriptions edge : i - th contain description edge index i — three integers ai bi ci ( 1 ≤ ai bi ≤ n 0 ≤ ci ≤ 109 ) — begin end edge initial weight correspondingly next q line input data contain description edge format describe ( 1 ≤ v ≤ n 1 ≤ lj ≤ m ) 's guarantee inside single query lj distinct also 's guarantee a total number edge request second type exceed 106 . query first type print length shortest path 1 v a separate line print -1 path exist description change graph first sample case : description change graph second sample case :,"['graphs', 'shortest paths']",3400.0
755/E,"polandball undirected simple graph consist n vertices unfortunately edge graph sad polandball want make <unknown> add red edge , add white edge every remain place therefore final graph a <unknown> two color : white red colorfulness graph a value min ( dr dw ) dr diameter red subgraph dw diameter white subgraph diameter a graph a largest value d shortest path pair vertices equal d. graph connect consider diameter -1 . polandball want final graph <unknown> possible want final colorfulness equal k. help find graph satisfy polandball 's request ? one input line contain two integers n k ( 2 ≤ n ≤ 1000 1 ≤ k ≤ 1000 ) represent graph 's size seek colorfulness 's impossible find a suitable graph print -1 . otherwise output graph fulfill polandball 's requirements first output m — number red edge graph , output m line contain two integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) mean undirected red edge vertices ai bi every red edge print exactly print edge vertices every edge arbitrary order remember polandball 's graph remain simple loop multiple edge allow first sample case graph fulfill polandball 's requirements second sample case red graph a path 1 5 . diameter 4 . however white graph diameter 2 consist edge 1 - 3 1 - 4 1 - 5 2 - 4 2 - 5 3 - 5","['graphs', 'shortest paths']",2400.0
666/B,a famous sculptor cicasso go a world tour ! well actually a world - wide everyone opportunity see work sculptor n't ? otherwise <unknown> cicasso entirely hold world tour native country — berland cicasso <unknown> work want <unknown> little possible therefore visit four cities cities different one could think ` ` <unknown> '' course save money choose shortest paths cities probably guess cicasso a weird person although n't like organize <unknown> like travel around country enjoy <unknown> want total distance travel large possible however sculptor bad plan ask help n cities m one - way roads berland choose four different cities cicasso visit also determine order visit total distance travel visit cities order start first city list end last choose time shortest route a pair cities — largest note intermediate rout may pass cities assign tour well pass twice city example tour look like : four cities order visit mark <unknown> : [ 1 5 2 4 ] note berland a high - <unknown> country use <unknown> roads alter length reason move use regular cars popular country happen pair cities one generally reach car one however cicasso <unknown> travel without car choose cities sculptor make tour use <unknown> guarantee always possible first line a pair integers n m ( 4 ≤ n ≤ 3000 3 ≤ m ≤ 5000 ) — a number cities one - way roads berland next m line contain a pair integers ui vi ( 1 ≤ ui vi ≤ n ) — a one - way road city ui city vi note ui vi require distinct moreover several one - way roads pair cities print four integers — number cities cicasso visit accord optimal choice route number cities print order cicasso visit multiple solutions print let d ( x y ) shortest distance cities x y. example d ( 2 1 ) = 3 d ( 1 8 ) = 7 d ( 8 7 ) = 3 . total distance equal 13,"['graphs', 'shortest paths']",2000.0
601/A,absurdistan n towns ( number 1 n ) m bidirectional railways also <unknown> simple road network — pair different towns x y a bidirectional road towns x y railway travel a different town use one railway one road always take exactly one hour a train a bus leave town 1 time destination town n n't make stop way ( wait town n ) train move along railways bus move along roads ' ve ask plan rout vehicles ; route use road / railway multiple time one important <unknown> consider safety — order avoid <unknown> railway cross train bus must arrive town ( except town n ) simultaneously constraints minimum number hours need vehicles reach town n ( maximum arrival time bus train ) ? note bus train require arrive town n moment time allow first line input contain two integers n m ( 2 ≤ n ≤ 400 0 ≤ m ≤ n ( n - 1 ) / 2 ) — number towns number railways respectively next m line contain two integers u v denote a railway towns u v ( 1 ≤ u v ≤ n u ≠ v ) may assume one railway connect two towns output one integer — smallest possible time later <unknown> 's arrival town n. 's impossible least one vehicles reach town n output - 1 . first sample train take route bus take route note arrive town 4 time second sample absurdistan rule <unknown> roads 's way bus reach town 4,"['graphs', 'shortest paths']",1600.0
187/B,pmp get a warrior practice a lot result acceptable yet time instead program contest decide compete a car race increase <unknown> victory decide choose a competition also <unknown> <unknown> feature <unknown> a special league car race different team compete a country n cities cities number 1 n. every two distinct cities country connect one bidirectional road compete team introduce one driver a set cars competition hold r round i - th round drivers start city si finish city ti drivers allow change cars ki time change cars take place city time one car use multiple time one round total number change exceed ki drivers freely choose path destination pmp prepare m type purpose - <unknown> cars <unknown> pmp ’ s drive skills depend properties car road a car traverse road direction different time pmp warriors want devise best strategies choose car roads round maximize chance win cup round want find minimum time require finish first line contain three space - separated integers n m r ( 2 ≤ n ≤ 60 1 ≤ m ≤ 60 1 ≤ r ≤ 105 ) — number cities number different type cars number round competition correspondingly next m set n × n matrices integers 0 106 ( inclusive ) follow — describe time one car require traverse different roads k - th integer j - th line i - th set time i - th car require traverse road j - th city k - th city matrices necessarily symmetric diagonal always zero next r line contain description round i - th line contain space - separated integers si ti ki ( 1 ≤ si ti ≤ n si ≠ ti 0 ≤ ki ≤ 1000 ) — number start city finish city number possible car change i - th round correspondingly round print minimum require time complete round a single line first sample round pmp go city # 1 city # 2 city # 3 finally city # 4 . sequence type cars use ( 1 2 1 ) first round ( 1 2 2 ) second round third round although change car three time use strategy first round need two car change,"['dp', 'shortest paths']",1800.0
1473/E,give a weight undirected connect graph consist $$$ n $$$ vertices $$$ m $$$ edge guarantee self - loops multiple edge give graph let 's define weight path consist $$$ k $$$ edge indices $$$ e_1 e_2 \dots e_k $$$ $$$ \sum\limits _ { i=1 } ^ { k } { w _ { e_i } } - \max\limits _ { i=1 } ^ { k } { w _ { e_i } } + \min\limits _ { i=1 } ^ { k } { w _ { e_i } } $$$ $$$ w_i $$$ — weight $$$ i $$$ -th edge graph task find minimum weight path $$$ 1 $$$ -st vertex $$$ i $$$ -th vertex $$$ i $$$ ( $$$ 2 \le i \le n $$$ ) first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ ; $$$ 1 \le m \le 200000 $$$ ) — number vertices number edge graph follow $$$ m $$$ line contain three integers $$$ v_i u_i w_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ ; $$$ 1 \le w_i \le 1000000000 $$$ ; $$$ v_i \neq u_i $$$ ) — endpoints $$$ i $$$ -th edge weight respectively print $$$ n-1 $$$ integers — minimum weight path $$$ 1 $$$ -st vertex $$$ i $$$ -th vertex $$$ i $$$ ( $$$ 2 \le i \le n $$$ ),"['graphs', 'shortest paths']",2400.0
1578/A,"let us consider game ` ` sticky tetris '' game a field $$$ n \times m $$$ square tile appear field player move tile tile a $$$ 4 $$$ <unknown> set $$$ 7 $$$ square new tile appear position fit inside field intersect tile top cell tile top row field player move tile leave right , moment tile must still entirely fit inside field must intersect tile player stop tile position time , move since ` ` sticky tetris '' tile fall stop give a final configuration a ` ` sticky tetris '' game need restore a sequence step lead configuration exist first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 50 $$$ ) — size play field next $$$ n $$$ line contain a string $$$ m $$$ character character could either a ' ' lowercase english letter connect components letter correspond a single tile tile consist $$$ 7 $$$ square solution print $$$ -1 $$$ otherwise print $$$ k $$$ — number different tile place field next $$$ k $$$ line print sequence step tile order place line consist a number $$$ x $$$ follow a string step $$$ x $$$ ( $$$ 1 \le x \le m $$$ ) start column leftmost square top row tile string consist character ' l ' ( leave ) ' r ' ( right ) 'd ' ( ) describe path tile end a single character 's ' ( stop ) final position tile determine tile place string step $$$ n \cdot m + 1 $$$ character","['graphs', 'shortest paths']",2800.0
543/B,country exactly n cities m bidirectional roads connect cities cities number integers 1 n. cities a b connect a road hour go along road either city a city b city b city a. road network city get one move along roads want destroy largest possible number roads country remain roads would allow get city s1 city t1 l1 hours get city s2 city t2 l2 hours determine maximum number roads need destroy order meet condition plan impossible reach desire result print -1 . first line contain two integers n m ( 1 ≤ n ≤ 3000 ) — number cities roads country respectively next m line contain descriptions roads pair integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) guarantee roads give description transport city one guarantee pair cities one road last two line contain three integers s1 t1 l1 s2 t2 l2 respectively ( 1 ≤ si ti ≤ n 0 ≤ li ≤ n ) print a single number — answer problem impossible meet condition print -1,"['graphs', 'shortest paths']",2100.0
75/E,get a new job 's interest a ship captain first task move ship one point another point sure want move minimum cost 's well know shortest distance 2 point length line segment 2 point unfortunately island sea sometimes wo n't able move ship line segment 2 point move safe point a point call safe 's line segment start end point 's island 's edge lucky get clever strong workers help trip help move ship sea take 1 egyptian pound move unit sea carry ship ( yes strong ) walk island take 2 egyptian pound move unit island money give divide workers number workers matter move ship island edge consider move sea a sea map decide minimum cost trip start point ( xstart ystart ) end point ( xend yend ) point different island a convex polygon 2 polygon point line also start end point wo n't inside boundary island point polygon give anti - clockwise order first line contain 4 integers xstart ystart xend yend ( - 100 ≤ xstart ystart xend yend ≤ 100 ) second line contain integer n number point polygon ( 3 ≤ n ≤ 30 ) follow a line contain n pair integers x y coordinate point ( - 100 ≤ x y ≤ 100 ) polygon point distinct print one line contain minimum possible cost absolute relative error answer exceed 10 - 6,"['geometry', 'shortest paths']",2400.0
59/E,ancient berland n cities m two - way roads equal length cities number integers 1 n inclusively accord ancient superstition a <unknown> visit three cities ai bi ci row without visit cities a great <unknown> <unknown> overall k city triplets triplet order mean example allow visit cities follow order : ai ci bi vasya want get city 1 city n fulfil superstition find minimal number roads take also require find one possible path rout first line contain three integers n m k ( 2 ≤ n ≤ 3000 1 ≤ m ≤ 20000 0 ≤ k ≤ 105 ) number cities number roads number forbid triplets correspondingly follow m line contain two integers xi yi ( 1 ≤ xi yi ≤ n ) road descriptions road describe number cities join road join a city one road a pair cities follow k line contain three integers ai bi ci ( 1 ≤ ai bi ci ≤ n ) forbid triplets order triplet list <unknown> one time three cities triplet distinct city n <unknown> city 1 roads path 1 n print -1 . otherwise first line print number roads d along shortest path city 1 city n. second line print d + 1 number — possible shortest paths vasya path start city 1 end city n,"['graphs', 'shortest paths']",2000.0
29/E,friends alex bob live bertown town n crossroads connect bidirectional roads equal length bob live a house crossroads number 1 alex — a house crossroads number n. one day alex bob a big <unknown> refuse see occur today bob need get house crossroads n alex need get house crossroads 1 . n't want meet crossroads meet middle street pass opposite directions alex bob ask mutual friend help difficult task find alex bob rout equal number streets guy follow rout never appear crossroads time allow meet middle street move <unknown> ( see sample 1 ) among possible rout select number streets least possible guy reach destinations none stay without move guy move simultaneously equal speed i.e possible one reach crossroads one leave example alex move crossroad 1 crossroad 2 bob move crossroad 2 crossroad 3 . require rout n't exist program output -1 . first line contain two integers n m ( 2 ≤ n ≤ 500 1 ≤ m ≤ 10000 ) — amount crossroads amount roads follow m line contain two integers — number crossroads connect road guarantee road connect a crossroads two crossroads connect one road require rout n't exist output -1 . otherwise first line contain integer k — length shortest rout ( length route amount roads ) next line contain k + 1 integers — bob 's route i.e number k + 1 crossroads pass bob last line contain alex 's route format several optimal solutions output,"['graphs', 'shortest paths']",2400.0
25/C,n cities number 1 n berland connect two - way roads road length — integer number 1 1000 . know city possible get city exist roads also pair cities know shortest distance berland government plan build k new roads plan road know length cities connect control <unknown> construction new roads open another road berland government want check sum shortest distance pair cities help — a give matrix shortest distance old roads plan new roads find sum shortest distance pair cities change construction road first line contain integer n ( 2 ≤ n ≤ 300 ) — amount cities berland follow n line n integer number — matrix shortest distance j - th integer i - th row — di j shortest distance cities i j. guarantee di i = 0 di j = dj i a give matrix a matrix shortest distance set two - way roads integer lengths 1 1000 city possible get city use roads next line contain integer k ( 1 ≤ k ≤ 300 ) — amount plan roads follow k line contain description plan roads road describe three space - separated integers ai bi ci ( 1 ≤ ai bi ≤ n ai ≠ bi 1 ≤ ci ≤ 1000 ) — ai bi — pair cities road connect ci — length road several roads a pair cities road connect city output k space - separated integers qi ( 1 ≤ i ≤ k ) qi equal sum shortest distance pair cities construction roads index 1 i. roads number 1 input order pair cities take account sum exactly i. e. count unordered pair,"['graphs', 'shortest paths']",1900.0
20/C,give a weight undirected graph vertices enumerate 1 n. task find shortest path vertex 1 vertex n. first line contain two integers n m ( 2 ≤ n ≤ 105 0 ≤ m ≤ 105 ) n number vertices m number edge follow m line contain one edge form ai bi wi ( 1 ≤ ai bi ≤ n 1 ≤ wi ≤ 106 ) ai bi edge endpoints wi length edge possible graph loop multiple edge pair vertices write integer -1 case path write shortest path opposite case many solutions print,"['graphs', 'shortest paths']",1900.0
542/E,vova marina love offer puzzle today marina offer vova cope follow task vova a non - directed graph consist n vertices m edge without loop multiple edge let 's define operation contraction two vertices a b connect edge a result operation vertices a b delete instead a new vertex x add graph also edge draw vertices connect a b ( specifically vertex connect a b also exactly one edge add x ) thus a result contraction a non - directed graph form contain loop multiple edge contain ( n - 1 ) vertices vova must perform contraction arbitrary number time transform give graph a chain maximum length a chain length k ( k ≥ 0 ) a connect graph whose vertices number integers 1 k + 1 edge graph connect pair vertices ( i i + 1 ) ( 1 ≤ i ≤ k ) specifically graph consist one vertex a chain length 0 . vertices form a result contraction allow use follow operations contraction help vova cope girlfriend 's task find maximum length chain obtain result graph else determine impossible obtain chain first line contain two integers n m ( 1 ≤ n ≤ 1000 0 ≤ m ≤ 100 000 ) — number vertices number edge original graph next m line contain descriptions edge format ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) mean edge vertices ai bi guarantee one edge pair vertexes impossible obtain a chain give graph print - 1 . otherwise print maximum possible number edge result chain first sample test contract vertices 4 5 obtain a chain length 3 . second sample test initially impossible contract pair vertexes impossible achieve desire result third sample test contract vertices 1 2 obtain a chain length 2,"['graphs', 'shortest paths']",2600.0
1776/J,italian data center consist a set servers color green white red a set wire connect wire connect two distinct servers two servers connect one wire additionally data center connect i.e a way transmit information two servers a sequence wire judge contestant <unknown> swerc italian data center since every year number contestants double data center need grow <unknown> extra load address swerc build a new data center base previous year 's one follow step : one show old data center connect new data center also connect give italian data center swerc currently contain $$$ n $$$ servers ( index $$$ 1 \ 2 \ \dots \ n $$$ ) $$$ m $$$ wire connect organization want know good data center $$$ k $$$ years determine diameter data center swerc $$$ k $$$ years diameter data center largest distance two servers i.e shortest number wire use transmit something two servers first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \leq n \leq 100 $$$ $$$ n - 1 \leq m \leq n ( n - 1 ) / 2 $$$ $$$ 0 \leq k \leq 100 $$$ ) — number servers number wire number years consider second line contain $$$ n $$$ integers $$$ c_1 \ c_2 \ \dots \ c_n $$$ ( $$$ 1 \leq c_i \leq 3 $$$ ) — $$$ c_i $$$ color server $$$ i $$$ ( $$$ 1 $$$ stand green $$$ 2 $$$ white $$$ 3 $$$ red ) next $$$ m $$$ line contain two integers $$$ s_i $$$ $$$ t_i $$$ ( $$$ 1 \leq s_i t_i \leq n $$$ ) — two servers $$$ i $$$ -th wire connect guarantee data center connect endpoints wire distinct repeat wire print diameter swerc 's data center $$$ k $$$ years first sample italian data center follow : distance pair servers $$$ 1 $$$ diameter $$$ 1 $$$ second sample initial italian data center one first sample one year obtain follow ( number indicate copy server refer ) : consider highlight servers distance $$$ 2 $$$ pair servers greater distance diameter $$$ 2 $$$ third sample data center one year follow : one year : consider highlight servers distance $$$ 3 $$$ pair servers greater distance diameter $$$ 3 $$$,"['graphs', 'shortest paths']",2500.0
241/E,<unknown> a country consist n cities cities number 1 n. country well know a strange transportation system many one - way flight make possible travel cities flight arrange a way leave a city never able return city previously flight take exactly one hour recently lily become new manager transportation system want change duration flight specifically want change duration flight exactly 2 hours a way trip city 1 city n take time regardless path task help lily change duration flight first line input contain two integer number n m ( 2 ≤ n ≤ 1000 ; 1 ≤ m ≤ 5000 ) specify number cities number flight next m line contain two integers ai bi ( 1 ≤ ai < bi ≤ n ) specify a one - directional flight city ai city bi guarantee exist a way travel city number 1 city number n use give flight guarantee sequence flight form a cyclical path two flight pair cities impossible lily task print ` ` '' ( without quote ) line output otherwise print ` ` yes '' ( without quote ) first line output print integer ansi ( 1 ≤ ansi ≤ 2 ) next m line duration flight new transportation system print number order flight give input multiple solutions input output,"['graphs', 'shortest paths']",2600.0
1779/G,"time finally come <unknown> <unknown> host game <unknown> purpose build a village <unknown> participants village shape equilateral triangle <unknown> three roads length $$$ n $$$ cut $$$ n^2 $$$ smaller equilateral triangles side length $$$ 1 $$$ $$$ <unknown> $$$ additional roads run parallel side see figure $$$ n=3 $$$ $$$ 3n $$$ roads make multiple ( possibly $$$ 1 $$$ ) road segment length $$$ 1 $$$ connect adjacent intersections direction already choose $$$ 3n $$$ roads ( road direction assign road segment ) traffic go specify directions ( i. e. roads <unknown> ) task make <unknown> traffic plan intersection possible reach every intersection specifically invert traffic direction number road segment length $$$ 1 $$$ minimal number road segment need invert traffic direction ? test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 10\,000 $$$ ) description test case follow first line test case contain a positive integer $$$ n $$$ ( $$$ 1\leq n\leq 100000 $$$ ) — size triangular village 's side three line follow contain a binary string length $$$ n $$$ describe traffic directions roads $$$ i $$$ -th follow three line contain a binary string $$$ s_i $$$ length $$$ n $$$ represent direction road parallel road segment denote $$$ i $$$ picture particular $$$ j $$$ -th character $$$ s_i $$$ ` ` 1 '' $$$ j $$$ -th shortest road ( parallel road segment denote $$$ i $$$ picture ) direction road segment denote $$$ i $$$ picture ` ` 0 '' opposite direction first character $$$ s_i $$$ describe direction road contain $$$ 1 $$$ road segment last character describe direction road contain $$$ n $$$ road segment guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print minimum number road segment need invert traffic direction first example correspond picture statement exist multiple solutions invert traffic direction exactly $$$ 2 $$$ road segment invert $$$ 1 $$$ road segment never make possible reach every intersection one possible solutions show picture invert road segment highlight blue second example answer $$$ 0 $$$ since already possible reach every intersection","['graphs', 'shortest paths']",3000.0
362/E,a little boy petya dream grow become head berland <unknown> think problems solve future unfortunately petya <unknown> solve one problems petya one 's interest berland capital n water tank number 1 n. tank connect <unknown> pip manner pair water tank connect one pipe direction pipe a strictly positive integer width width determine number <unknown> water per a unit time pipe transport water go city main water tank ( number 1 ) water must go pipe path get sewer tank clean system ( number n ) petya want increase width subset pip k units total width pipe remain integer help determine maximum amount water transmit per a unit time main tank sewer tank operation complete first line contain two space - separated integers n k ( 2 ≤ n ≤ 50 0 ≤ k ≤ 1000 ) follow n line line contain n integers separate single space i + 1 - th row j - th column contain number cij — width pipe go tank i tank j ( 0 ≤ cij ≤ 106 <unknown> = 0 ) cij = 0 pipe tank i tank j. print a single integer — maximum amount water transmit main tank sewer tank per a unit time first test petya increase width pipe go 1st 2nd water tank 7 units second test petya increase width pipe go 1st 2nd water tank 4 units 2nd 3rd water tank 3 units 3rd 4th water tank 2 units 4th 5th water tank 1 unit,"['graphs', 'shortest paths']",2300.0
141/D,"vasya participate a ski race along x axis start point 0 finish l , a distance l meter start positive direction axis vasya train hard run one meter exactly one second besides n take - off ramp track ramp characterize four number : vasya allow move direction x axis prohibit cross start line go negative <unknown> vasya choose take - off ramp use order , oblige take ramp encounter specifically vasya skip ramp guarantee xi + di ≤ l , vasya cross finish line flight vasya jump ramp positive direction x axis formally use i - th ramp vasya start gather speed point xi - pi jump point xi land point xi + di use ramp opposite direction task find minimum time vasya spend cover distance first line contain two integers n l ( 0 ≤ n ≤ 105 1 ≤ l ≤ 109 ) n line contain descriptions ramp description a single line description a group four non - negative integers xi di ti pi ( 0 ≤ xi ≤ l 1 ≤ di ti pi ≤ 109 xi + di ≤ l ) print first line minimum time second vasya need complete track print second line k — number take - off ramp vasya need use print third line output k number number take - off ramp vasya use order use print number exactly separate number a space ramp number start 1 order give input first sample vasya use ramp 2 need gather speed start point -3 permit statement optimal option use ramp 1 result time : move point gather speed + gather speed reach takeoff ramp + flight time + move finish line = 0 + 5 + 5 + 5 = 15 . second sample use ramp 1 optimal vasya t1 > d1 optimal option use ramp 2 result time : move point gather speed + gather speed reach takeoff ramp + flight time + move finish line = 14 + 1 + 1 + 0 = 16","['graphs', 'shortest paths']",2300.0
78/E,' ve <unknown> something yet ... one nuclear reactor a research station <unknown> reaction progress explosion destroy whole station happen soon station represent a square n × n divide 1 × 1 block block either a reactor a laboratory several reactors exactly one explode soon reactors consider impassable block one move laboratories two laboratories adjacent block a corridor block consider adjacent a common edge laboratory number scientists number rescue capsule scientist climb a capsule consider save capsule room one scientist reactor explode damage a <unknown> coolant <unknown> neighbor block block contain reactor consider infect every minute coolant spread laboratories <unknown> moment one block infect next minute neighbor laboratories also become infect a lab infect scientists rescue capsule die coolant spread reactor block exactly t minutes explosion scientist a minute move corridor next lab infect corridor unlimited number scientists simultaneously move directions believe scientists inside a lab move without consume time moreover scientist could get rescue capsule instantly also believe scientist give moment always time perform action ( move give laboratory next one climb rescue capsule ) laboratory infect find maximum number scientists able escape first line contain two integers n t ( 2 ≤ n ≤ 10 1 ≤ t ≤ 60 ) next n line contain n character line describe scientists ' locations exactly one empty line follow next n line contain n character line describe rescue capsule ' locations description scientists ' rescue capsule ' locations character ` ` y '' stand a properly function reactor ` ` z '' stand malfunction reactor reactors ' position descriptions coincide exactly one malfunction reactor station digits ` ` 0 '' - ` ` 9 '' stand laboratories description scientists ' locations number stand number scientists correspond laboratories rescue capsule ' descriptions stand number capsule laboratory print a single number — maximum number scientists manage save second sample events could take place follow :,"['graphs', 'shortest paths']",2300.0
852/D,competitors bubble cup x gather competition discuss best way get know host country cities explore map <unknown> a competitors come follow <unknown> : country v cities index number 1 v e bi - directional roads connect <unknown> road a weight ( time need cross road ) n team bubble cup competitors come follow plan : n team start journey one v cities team share start position want find shortest time t every team move t minutes number different cities end least k ( get know cities end ) a team n't move time like a particular city stay wait time pass please help competitors determine shortest time t 's possible end least k different cities print -1 impossible matter move note exist multiple roads cities first line contain four integers : v e n k ( 1 ≤ v ≤ 600 1 ≤ e ≤ 20000 1 ≤ n ≤ min ( v 200 ) 1 ≤ k ≤ n ) number cities number roads number team smallest number different cities need end respectively second line contain n integers cities team start journey next e line contain information roads follow format : ai bi ti ( 1 ≤ ai bi ≤ v 1 ≤ ti ≤ 10000 ) mean a road connect cities ai bi need ti minutes cross road output a single integer represent minimal time team move end least k different cities output -1 solution solution exist result greater <unknown> . three team start city 5 two team start city 2 . agree move 3 minutes one possible situation would follow : two team city 2 one team city 5 one team city 3 one team city 1 . see four different cities team end journey,"['binary search', 'shortest paths']",2100.0
375/C,"a map a rectangle table cell table either obstacle a treasure a certain price a bomb empty cell initial position also give go one cell map a side - adjacent one , allow go beyond border map enter cells treasure obstacles bomb pick treasure need build a close path ( start end start cell ) close path must n't contain cells bomb inside let 's assume sum treasure ' value locate inside close path equal v besides ' ve make k single move ( one cell another ) go path path bring profit v - k rubles task build a close path n't contain bomb bring maximum profit note path self - intersections order determine a cell lie inside a path use follow algorithm : first line contain two integers n m ( 1 ≤ n m ≤ 20 ) — size table next n line contain m character — description table description mean follow : assume map t treasure next t line contain price treasure i - th line contain price treasure index i vi ( - 200 ≤ vi ≤ 200 ) guarantee treasure number 1 t. guarantee map 8 object total object bomb treasure guarantee map exactly one character ` ` s '' print a single integer — maximum possible profit get first example answer look follow second example answer look follow third example get profit fourth example get profit construct a close path one cell","['bitmasks', 'shortest paths']",2600.0
1387/C,"committee research binary viruses discover a method <unknown> a large family viruses whose <unknown> cod sequence zero ones virus originate a single gene ; simplicity genes denote integers $$$ 0 $$$ $$$ g - 1 $$$ moment time a virus a sequence genes mutation occur one genes sequence replace a certain sequence genes accord mutation table virus stop mutate consist genes $$$ 0 $$$ $$$ 1 $$$ instance follow mutation table : $$$ $$$ 2 \to \langle 0\ 1 \rangle \\ 3 \to \langle 2\ 0\ <unknown> 3 \to \langle 1\ <unknown> 4 \to \langle 0\ 3\ 1\ <unknown> 5 \to \langle 2\ <unknown> 5 \to \langle <unknown> $$$ $$$ a virus initially consist a single gene $$$ 4 $$$ could mutate follow : $$$ $$$ \langle 4 \rangle \to \langle \underline { 0\ 3\ 1\ 2 } \rangle \to \langle 0\ \underline { 2\ 0\ 0 } \ 1\ 2 \rangle \to \langle 0\ \underline { 0\ 1 } \ 0\ 0\ 1\ 2 \rangle \to \langle 0\ 0\ 1\ 0\ 0\ 1\ \underline { 0\ 1 } \rangle $$$ $$$ another way : $$$ $$$ \langle 4 \rangle \to \langle \underline { 0\ 3\ 1\ 2 } \rangle \to \langle 0\ \underline { 1\ 3 } \ 1\ 2 \rangle \to \langle 0\ 1\ 3\ 1\ \underline { 0\ 1 } \rangle \to \langle 0\ 1\ \underline { 2\ 0\ 0 } \ 1\ 0\ 1 \rangle \to \langle 0\ 1\ \underline { 0\ 1 } \ 0\ 0\ 1\ 0\ 1 \rangle $$$ $$$ viruses detect antibodies identify <unknown> specific continuous fragment zero ones viruses ' cod example antibody react a fragment $$$ \langle 0\ 0\ 1\ 0\ 0 \rangle $$$ detect a virus $$$ \langle 0\ 0\ 1\ 0\ 0\ 1\ 0\ 1 \rangle $$$ detect a virus $$$ \langle 0\ 1\ 0\ 1\ 0\ 0\ 1\ 0\ 1 \rangle $$$ gene $$$ 2 $$$ $$$ <unknown> $$$ scientists wonder whether a give set antibodies enough detect viruses emerge mutations gene , want know length shortest virus detect may happen sometimes scientists n't antibodies course virus detect scientists interest length shortest possible virus emerge gene mutations first line input contain three integers $$$ g $$$ $$$ n $$$ $$$ m $$$ ( $$$ g > 2 $$$ $$$ n \geq g - 2 $$$ $$$ m \geq 0 $$$ ) specify number genes number row mutation table number antibodies follow $$$ n $$$ line contain descriptions row mutation table ; line begin two integers $$$ a $$$ $$$ k $$$ ( $$$ 2 \leq a < g $$$ $$$ k \geq 1 $$$ ) follow a sequence $$$ k $$$ integers $$$ b_1 b_2 \ldots b_k $$$ ( $$$ 0 \leq b_i < g $$$ ) encode row $$$ $$$ a \to \langle <unknown> <unknown> <unknown> b_k \rangle $$$ $$$ sum value $$$ k $$$ exceed $$$ 100 $$$ every integer $$$ 2 $$$ $$$ g - 1 $$$ appear table $$$ a $$$ least next $$$ m $$$ line contain descriptions antibodies ; line begin integer $$$ \ell $$$ ( $$$ \ell \geq 1 $$$ ) follow a sequence $$$ \ell $$$ integers $$$ c_1 c_2 \ldots c_\ell $$$ ( $$$ 0 \leq c_i \leq 1 $$$ ) describe antibody sum value $$$ \ell $$$ exceed $$$ 50 $$$ program need output exactly $$$ g - 2 $$$ line contain answer subsequent genes $$$ 2 $$$ $$$ g - 1 $$$ viruses mutate single gene detect give set antibodies need print word ` ` yes '' also need print viruses could originate gene ( happen sequence never stop mutate ) otherwise need print word ` ` '' follow integer denote minimal length <unknown> virus assume prepare input data value smaller $$$ 2^ { 63 } $$$ subtasks :","['dp', 'shortest paths']",2900.0
1765/I,"black king live a chess board infinite number columns ( file ) $$$ 8 $$$ row ( rank ) columns number integer number ( include negative ) row number $$$ 1 $$$ $$$ 8 $$$ initially black king locate start square $$$ ( x_s y_s ) $$$ need reach target square $$$ ( x_t y_t ) $$$ unfortunately also white piece board threaten black king <unknown> white piece agree let black king pass target square follow condition : help black king find minimum number move need reach target square violate condition black king leave board time black king move accord movement rule even though white piece never move square reach one move consider attack black king move square movement rule note piece ( except knight ) jump piece pawn board first line contain two integers $$$ x_s $$$ $$$ y_s $$$ ( $$$ 1 \le x_s \le 100000000 $$$ ; $$$ 1 \le y_s \le 8 $$$ ) — start coordinate black king second line contain two integers $$$ x_t $$$ $$$ y_t $$$ ( $$$ 1 \le x_t \le 100000000 $$$ ; $$$ 1 \le y_t \le 8 $$$ ) — coordinate target square black king third line contain one integer $$$ n $$$ ( $$$ 0 \le n \le 2000 $$$ ) — number white piece board $$$ n $$$ line follow $$$ i $$$ -th line contain one character $$$ t_i $$$ two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i \le 100000000 $$$ ; $$$ 1 \le y_i \le 8 $$$ ) — type coordinate $$$ i $$$ -th white piece type piece represent follow uppercase latin letter : number white piece type list board example $$$ 3 $$$ white kings $$$ 4 $$$ white queen pawn board additional <unknown> input : print one integer — minimum number move need black king reach target square violate condition $$$ -1 $$$ impossible image demonstrate solution second example , letter k r s t represent white king white rook start square target square respectively bold cross mark square attack white piece bold dot show shortest path black king","['implementation', 'shortest paths']",2800.0
266/B,"break schoolchildren boys girls form a queue n people canteen initially children stand order enter canteen however a boys start feel awkward stand front girls queue start let girls move forward second let 's describe process precisely let 's say position queue sequentially number integers 1 n person position number 1 serve first , time x a boy stand i - th position a girl stand ( i + 1 ) -th position time x + 1 i - th position a girl ( i + 1 ) -th position a boy time give second ' ve get initial position children initial moment time determine way queue go look t second first line contain two integers n t ( 1 ≤ n t ≤ 50 ) represent number children queue time queue transform arrangement need find next line contain string s represent schoolchildren 's initial arrangement i - th position queue contain a boy i - th character string s equal ` ` b '' otherwise i - th character equal ` ` g '' print string a describe arrangement t second i - th position a boy need time i - th character a must equal ` ` b '' otherwise must equal ` ` g ''","['implementation', 'shortest paths']",800.0
464/E,give a weight undirected graph n vertices m edge find shortest path vertex s vertex t else state path n't exist first line input contain two space - separated integers — n m ( 1 ≤ n ≤ 105 ; 0 ≤ m ≤ 105 ) next m line contain description graph edge i - th line contain three space - separated integers — ui vi xi ( 1 ≤ ui vi ≤ n ; 0 ≤ xi ≤ 105 ) mean vertices number ui vi connect edge length <unknown> ( 2 power xi ) last line contain two space - separated integers — number vertices s t. vertices number 1 n. graph contain multiple edge self - loops first line print remainder divide length shortest path 1000000007 ( 109 + 7 ) path exist -1 path n't exist path exist print second line integer k — number vertices shortest path vertex s vertex t ; third line print k space - separated integers — vertices shortest path visit order first vertex vertex s last vertex vertex t. multiple shortest paths print a path vertex s vertex t a sequence v0 ... vk v0 = s vk = t i 0 k - 1 vertices vi vi + 1 connect edge length path sum weight edge vi vi + 1 i 0 k - 1 . shortest path s t path length minimum among possible paths s t,"['data structures', 'graphs', 'shortest paths']",3000.0
1320/B,map bertown represent a set $$$ n $$$ intersections number $$$ 1 $$$ $$$ n $$$ connect $$$ m $$$ one - way roads possible move along roads intersection intersection length path one intersection another number roads one traverse along path shortest path one intersection $$$ v $$$ another intersection $$$ u $$$ path start $$$ v $$$ end $$$ u $$$ minimum length among paths polycarp live near intersection $$$ s $$$ work a build near intersection $$$ t $$$ every day get $$$ s $$$ $$$ t $$$ car today choose follow path workplace : $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_k $$$ $$$ p_1 = s $$$ $$$ p_k = t $$$ elements sequence intermediate intersections list order polycarp arrive polycarp never arrive intersection twice elements sequence pairwise distinct note know polycarp 's path beforehand ( fix ) necessarily one shortest paths $$$ s $$$ $$$ t $$$ polycarp 's car a complex navigation system instal let 's describe work polycarp start journey intersection $$$ s $$$ system choose shortest path $$$ s $$$ $$$ t $$$ show polycarp let 's denote next intersection choose path $$$ v $$$ polycarp choose drive along road $$$ s $$$ $$$ v $$$ navigator show shortest path ( obviously start $$$ v $$$ soon arrive intersection ) however polycarp choose drive another intersection $$$ w $$$ instead navigator rebuild path : soon polycarp arrive $$$ w $$$ navigation system choose shortest path $$$ w $$$ $$$ t $$$ show polycarp process continue polycarp arrive $$$ t $$$ : polycarp move along road recommend system maintain shortest path already build ; polycarp choose path system rebuild path rule example suppose map bertown look follow polycarp drive along path $$$ [ 1 2 3 4 ] $$$ ( $$$ s = 1 $$$ $$$ t = 4 $$$ ) : check picture link http : <unknown> / <unknown> get $$$ 2 $$$ rebuild scenario note system choose $$$ [ 2 3 4 ] $$$ instead $$$ [ 2 6 4 ] $$$ second step would $$$ 1 $$$ rebuild ( since polycarp go along path system maintain path $$$ [ 3 4 ] $$$ third step ) example show us number rebuild differ even map bertown path choose polycarp stay give information ( map polycarp 's path ) determine minimum maximum number rebuild could happen journey ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le m \le 200000 $$$ ) — number intersections one - way roads bertown respectively $$$ m $$$ line follow describe a road line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) denote a road intersection $$$ u $$$ intersection $$$ v $$$ roads bertown pairwise distinct mean order pair $$$ ( u v ) $$$ appear $$$ m $$$ line ( a road $$$ ( u v ) $$$ road $$$ ( v u ) $$$ also appear ) follow line contain one integer $$$ k $$$ ( $$$ 2 \le k \le n $$$ ) — number intersections polycarp 's path home workplace last line contain $$$ k $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_k $$$ ( $$$ 1 \le p_i \le n $$$ integers pairwise distinct ) — intersections along polycarp 's path order arrive $$$ p_1 $$$ intersection polycarp live ( $$$ s = p_1 $$$ ) $$$ p_k $$$ intersection polycarp 's workplace situate ( $$$ t = p_k $$$ ) guarantee every $$$ i \in [ 1 k - 1 ] $$$ road $$$ p_i $$$ $$$ p _ { i + 1 } $$$ exist path go along roads bertown print two integers : minimum maximum number rebuild could happen journey,"['dfs and similar', 'graphs', 'shortest paths']",1700.0
208/C,"berland road network consist n cities m bidirectional roads cities number 1 n main capital city number n culture capital — number 1 . road network set possible reach city one roads move road direction take time residents berland lazy people want get city v city u always choose one shortest paths ( matter one ) berland government want make country 's road network <unknown> , go put a police station one city police station a rather strange property : a citizen berland drive along road a police station one end citizen drive carefully roads consider safe roads end differ city police station dangerous government wonder put police station average number safe roads shortest paths <unknown> capital main capital would take maximum value first input line contain two integers n m ( 2 ≤ n ≤ 100 ) — number cities number roads berland correspondingly next m line contain pair integers vi ui ( 1 ≤ vi ui ≤ n vi ≠ ui ) — number cities connect i - th road number a line separate a space guarantee pair cities connect one road possible get city one along berland roads print maximum possible value average number safe roads among shortest paths culture capital main one answer consider valid absolute relative <unknown> exceed 10 - 6 . first sample put a police station one <unknown> path exactly one safe road place station capital average number safe roads also make second sample obtain maximum seek value put station city 4 6 paths 2 safe roads one path 0 safe roads answer equal","['dp', 'graphs', 'shortest paths']",1900.0
1272/E,give array $$$ a $$$ consist $$$ n $$$ integers one move jump position $$$ i $$$ position $$$ i - a_i $$$ ( $$$ 1 \le i - a_i $$$ ) position $$$ i + a_i $$$ ( $$$ i + a_i \le n $$$ ) position $$$ i $$$ $$$ 1 $$$ $$$ n $$$ want know minimum number move require reach position $$$ j $$$ $$$ a_j $$$ opposite parity $$$ a_i $$$ ( i.e $$$ a_i $$$ odd $$$ a_j $$$ even vice versa ) first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements $$$ a $$$ second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ print $$$ n $$$ integers $$$ d_1 d_2 \dots d_n $$$ $$$ d_i $$$ minimum number move require reach position $$$ j $$$ $$$ a_j $$$ opposite parity $$$ a_i $$$ ( i.e $$$ a_i $$$ odd $$$ a_j $$$ even vice versa ) -1 impossible reach a position,"['dfs and similar', 'graphs', 'shortest paths']",1900.0
1067/B,someone give a strange birthday present ivan hedgehog — connect undirected graph one vertex degree least $$$ 3 $$$ ( call center ) vertices degree 1 . ivan think hedgehog bore decide make $$$ k $$$ -multihedgehog let us define $$$ k $$$ -multihedgehog follow : <unknown> $$$ k $$$ -multihedgehog a tree ivan make $$$ k $$$ -multihedgehog sure make mistake ask check tree indeed $$$ k $$$ -multihedgehog first line input contain $$$ 2 $$$ integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 10^ { 5 } $$$ $$$ 1 \le k \le 10^ { 9 } $$$ ) — number vertices hedgehog parameter next $$$ n-1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u \ \ v \le n ; \ \ u \ne v $$$ ) — indices vertices connect edge guarantee give graph a tree print ` ` yes '' ( without quote ) give graph $$$ k $$$ -multihedgehog ` ` '' ( without quote ) <unknown> - <unknown> first example look like : center vertex $$$ 13 $$$ <unknown> create last step : [ 4 ( center ) 1 2 3 ] [ 6 ( center ) 7 8 9 ] [ 5 ( center ) 10 11 12 13 ] tree second example a hedgehog degree center least $$$ 3 $$$,"['dfs and similar', 'graphs', 'shortest paths']",1800.0
1753/D,"andrew love sea 's height summer season decide go beach take a sunbed <unknown> beach a rectangular field $$$ n $$$ row $$$ m $$$ columns cells beach free roads stone shop non - movable object two adjacent along side cells <unknown> locate either horizontally vertically andrew hop put sunbed somewhere 's a bad luck may longer free place ! 's andrew ask help find a free place sunbed andrew 's sunbed also place two adjacent cells two adjacent free cells order free place a sunbed <unknown> tourists follow action : moment sunbed occupy two adjacent free cells move one sunbed a time help andrew free a space sunbed cause minimum possible number units discomfort tourists detect impossible first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 300\,000 $$$ $$$ 1 \le n \cdot m \le 300\,000 $$$ ) — number row columns rectangle second line contain two integers $$$ p $$$ $$$ q $$$ ( $$$ 1 \le p q \le 1000000000 $$$ ) — number units discomfort cause rotation shift a sunbed respectively follow $$$ n $$$ line contain $$$ m $$$ character describe cells rectangle line consist character ` ` l '' ` ` r '' ` ` d '' ` ` u '' ` ` . '' ` ` # '' denote type cell character ` ` l '' ` ` r '' ` ` d '' ` ` u '' denote a half a sunbed place cell — leave right bottom top half respectively character ` ` . '' denote a free cell character ` ` # '' — a cell occupy non - movable object print one integer — minimum possible number units discomfort cause tourists free a space a sunbed impossible free a space a sunbed print $$$ -1 $$$ first example shift upper sunbed leave lower sunbed — right andrew able put sunbed vertically middle beach well cause $$$ 2 + 2 = 4 $$$ units discomfort easy prove optimal answer","['dfs and similar', 'graphs', 'shortest paths']",2400.0
1749/E,monocarp play minecraft want build a wall cacti want build a field sand size $$$ n \times m $$$ cells initially cacti cells field note minecraft cacti grow cells adjacent side — initial field meet restriction monocarp plant new cacti ( must also fulfil <unknown> condition ) ca n't <unknown> cacti already grow field — n't <unknown> cacti <unknown> hand monocarp believe wall complete path top row field bottom row : task plant minimum number cacti build a wall ( report impossible ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n m \le 200000 $$$ ; $$$ n \times m \le 400000 $$$ ) — number row columns respectively $$$ n $$$ row follow $$$ i $$$ -th row contain a string $$$ s_i $$$ length $$$ m $$$ $$$ s _ { i j } $$$ ' # ' a cactus grow intersection $$$ i $$$ -th row $$$ j $$$ -th column otherwise $$$ s _ { i j } $$$ ' . ' sum $$$ n \times m $$$ test case exceed $$$ 400000 $$$ test case print first line impossible build a cactus wall without break rule otherwise print yes first line print $$$ n $$$ line $$$ m $$$ character — field $$$ j $$$ -th character $$$ i $$$ -th line equal ' # ' a cactus intersection $$$ i $$$ -th row $$$ j $$$ -th column otherwise ' . ' multiple optimal answer print,"['dfs and similar', 'graphs', 'shortest paths']",2400.0
1065/D,stumble upon a new kind chess puzzle chessboard give <unknown> $$$ 8 \times 8 $$$ still $$$ n \times n $$$ square number write number $$$ 1 $$$ $$$ n^2 $$$ number pairwise distinct $$$ j $$$ -th square $$$ i $$$ -th row a number $$$ a _ { ij } $$$ write chess set three piece : a knight a bishop a rook first put one square number $$$ 1 $$$ ( choose one ) want reach square $$$ 2 $$$ ( possibly pass square process ) square $$$ 3 $$$ reach square $$$ n^2 $$$ one step allow either make a valid move current piece replace piece square visit arbitrary number time a knight move a square two square away horizontally one square vertically two square vertically one square horizontally a bishop move diagonally a rook move horizontally vertically move perform a different square one a piece currently stand want minimize number step whole traversal among paths number step want choose one lowest number piece replacements path take satisfy condition ? first line contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 10 $$$ ) — size chessboard next $$$ n $$$ line contain $$$ n $$$ integers $$$ a _ { i1 } a _ { i2 } \dots a _ { } $$$ ( $$$ 1 \le a _ { ij } \le n^2 $$$ ) — number write square $$$ i $$$ -th row board guarantee $$$ a _ { ij } $$$ pairwise distinct line contain two integers — number step best answer number replacement move step first example ( start piece a knight ) :,"['dfs and similar', 'dp', 'shortest paths']",2200.0
1505/E,a mouse encounter a nice big cake decide take a walk across eat berry top cake way cake rectangular <unknown> divide square ; square a berry n't mouse a bite a hurry though enter cake <unknown> corner ( top leave cell input data ) go east ( right ) south ( ) reach <unknown> corner ( bottom right cell ) eat every berry square pass square mouse try choose path maximize number berry consume however haste <unknown> might <unknown> <unknown> lead <unknown> decisions ... first line input contain two integers $$$ h $$$ $$$ w $$$ ( $$$ 1 \le h w \le 5 $$$ ) separate a space — height width cake next $$$ h $$$ line contain a string $$$ w $$$ character represent square cake row : ' . ' represent empty square ' * ' represent a square a berry output number berry mouse eat follow strategy,"['greedy', 'implementation', 'shortest paths']",1800.0
676/D,theseus arrive <unknown> fight minotaur find a labyrinth a form a rectangular field size n × m consist block size 1 × 1 . block labyrinth a button rotate block 90 degrees clockwise block rotate around center n't change position labyrinth also block number doors ( possibly none ) one minute theseus either push button order rotate block 90 degrees clockwise pass neighbour block theseus go block a neighbour block b block a a door lead block b block b a door lead block a. theseus find entrance labyrinth locate block ( xt yt ) — block row xt column yt theseus know minotaur hide block ( xm ym ) want know minimum number minutes require get theseus a hero a programmer ask help first line input contain two integers n m ( 1 ≤ n m ≤ 1000 ) — number row number columns labyrinth respectively follow n line contain m character describe block labyrinth possible character : leave right top bottom define represent labyrinth a table row number 1 n top bottom columns number 1 m leave right next line contain two integers — coordinate block ( xt yt ) ( 1 ≤ xt ≤ n 1 ≤ yt ≤ m ) theseus initially locate last line contain two integers — coordinate block ( xm ym ) ( 1 ≤ xm ≤ n 1 ≤ ym ≤ m ) minotaur hide 's guarantee block theseus start block minotaur hide least one door theseus minotaur may initially locate block theseus able get minotaur print -1 line output otherwise print minimum number minutes require get block minotaur hide assume theseus start block ( xt yt ) moment 0,"['graphs', 'implementation', 'shortest paths']",2000.0
346/D,boss company robot a <unknown> man <unknown> ` ` move forward die ! ` ` exactly company 's product look behavior company 's robot walk direct graph behavior call ` ` three <unknown> <unknown> '' : imagine a robot behave like ? 's sell a low price short money include mzry1992 course mzry1992 a robot want move vertex s vertex t a direct graph safely without self - destruction luckily send robot special order vertex a special order show robot way move multiple ways move ( prevent random move robot accord law 3 ) robot reach vertex t mzry1992 take graph immediately see long exist a path s t always find a way reach goal ( whatever vertex t <unknown> zero ) however send order expensive task find minimum number order mzry1992 need send worst case please note mzry1992 give order robot walk graph look first sample clarify part problem first line contain two integers n ( 1 ≤ n ≤ 106 ) — number vertices graph m ( 1 ≤ m ≤ 106 ) — number edge m line follow two integers ui vi ( 1 ≤ ui vi ≤ n ; vi ≠ ui ) integers denote a direct edge vertex ui vertex vi last line contain two integers s t ( 1 ≤ s t ≤ n ) guarantee multiple edge self - loops a way reach a goal print require minimum number order worst case otherwise print -1 . consider first test sample initially robot vertex 1 . first step robot go vertex 2 3 . matter vertex robot choose mzry1992 must give order robot order go vertex 4 . mzry1992 n't give order robot vertex 2 3 robot choose ` ` bad '' outgo edge ( return vertex 1 ) accord law 3 . answer one,"['dp', 'graphs', 'shortest paths']",2600.0
301/B,yaroslav play a game call ` ` time '' game a timer show <unknown> 's get leave soon timer show 0 yaroslav 's character die game end also game n clock station station number i point ( xi yi ) plane player visit station number i increase current time timer ai station one - time use player visit station another time time timer wo n't grow a player spend <unknown> time units move station dist distance player cover d constant distance station i j determine <unknown> - <unknown> + <unknown> - <unknown> initially player station number 1 player strictly zero strictly less one units time station number 1 one unit money increase time timer one time unit ( buy integer number time units ) yaroslav wonder much money need get station n. help yaroslav consider time buy increase timer value negligibly small first line contain integers n d ( 3 ≤ n ≤ 100 103 ≤ d ≤ 105 ) — number station constant statement second line contain n - 2 integers : a2 a3 ... - 1 ( 1 ≤ ai ≤ 103 ) next n line contain coordinate station i - th contain two integers xi yi ( -100 ≤ xi yi ≤ 100 ) guarantee two station locate point a single line print integer — answer problem,"['binary search', 'graphs', 'shortest paths']",2100.0
295/B,greg a weigh direct graph consist n vertices graph pair distinct vertices edge directions greg love play graph invent a new game : help greg print value require sum step first line contain integer n ( 1 ≤ n ≤ 500 ) — number vertices graph next n line contain n integers — graph <unknown> matrix : j - th number i - th line aij ( 1 ≤ aij ≤ 105 <unknown> = 0 ) represent weight edge go vertex i vertex j. next line contain n distinct integers : x1 x2 ... xn ( 1 ≤ xi ≤ n ) — vertices greg delete print n integers — i - th number equal require sum i - th step please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier,"['dp', 'graphs', 'shortest paths']",1700.0
461/E,appleman toastman like game today play a game string follow rule firstly toastman tell appleman two string s t consist letter ' a ' ' b ' ' c ' 'd ' appleman must build string s quickly possible initially empty string one second append end current string contiguous substring t. toastman appleman begin play game toastman already tell string t appleman n't come string s yet toastman think choose string s consist n character course want find worst string appleman ( string appleman spend much time possible game ) tell toastman much time appleman spend game toastman find worst string assume appleman play optimally therefore build string s minimal possible time first line contain integer n ( 1 ≤ n ≤ 1018 ) second line contain string t ( 1 ≤ |t| ≤ 105 ) string t consist letter ' a ' ' b ' ' c ' 'd ' letter appear least string t. print a single integer — largest possible time appleman need first example toastman choose s equal ` ` aaaaa '' second example toastman choose s equal ` ` <unknown> '',"['binary search', 'shortest paths', 'strings']",3000.0
37/E,<unknown> berland dictionary scientists manage read note <unknown> time example learn chief ancient berland tribe choose soon enough <unknown> pick follow test take place among : chief tribe take a slab divide horizontal vertical strip identical square ( slab consist n line m columns ) paint every square black white every pretender give a slab size paint entirely white within a day a pretender could paint side - linked set square slab color set call link two square belong set a path belong set two neighbor square share a side aim pretender paint slab exactly way chief ’ s slab paint one paint a slab like first become new chief scientists find slab paint ancient berland tribe chief help determine minimal amount days need find a new chief paint slab give way first line contain two integers n m ( 1 ≤ n m ≤ 50 ) — number line columns slab next n line contain m symbols — final coloration slab w stand square paint white b — square paint black single line output minimal number repaint side - linked areas need get require coloration slab,"['graphs', 'greedy', 'shortest paths']",2600.0
1759/C,vlad come home find someone <unknown> old thermostat temperature $$$ a $$$ thermostat set a temperature $$$ l $$$ $$$ r $$$ inclusive temperature change less $$$ x $$$ formally one operation <unknown> thermostat temperature $$$ a $$$ temperature $$$ b $$$ $$$ |a - b| \ge x $$$ $$$ l \le b \le r $$$ give $$$ l $$$ $$$ r $$$ $$$ x $$$ $$$ a $$$ $$$ b $$$ find minimum number operations require get temperature $$$ b $$$ temperature $$$ a $$$ say impossible first line input data contain single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test descriptions test case follow first line case contain three integers $$$ l $$$ $$$ r $$$ $$$ x $$$ ( $$$ -1000000000 \le l \le r \le 1000000000 $$$ $$$ 1 \le x \le 1000000000 $$$ ) — range temperature minimum temperature change second line case contain two integers $$$ a $$$ $$$ b $$$ ( $$$ l \le a b \le r $$$ ) — initial final temperatures output $$$ t $$$ number answer correspond test case impossible achieve temperature $$$ b $$$ output -1 otherwise output minimum number operations first example thermostat already set correctly second example achieve desire temperature follow : $$$ 4 \rightarrow 10 \rightarrow 5 $$$ third example achieve desire temperature follow : $$$ 3 \rightarrow 8 \rightarrow 2 \rightarrow 7 $$$ fourth test impossible make operation,"['greedy', 'math', 'shortest paths']",1100.0
913/E,"give a boolean function three <unknown> define truth table need find expression minimum length equal function expression may consist : one expression minimum length exist find lexicographically smallest one operations standard priority highest priority go lowest priority expression satisfy follow grammar : e : : = e ' | ' t | <unknown> : : = t ' & ' f | <unknown> : : = ' ! ' f | ' ( ' e ' ) ' | ' x ' | ' y ' | ' <unknown> first line contain one integer n — number function input ( 1 ≤ n ≤ 10 000 ) follow n line contain descriptions function i - th contain a string length 8 consist digits 0 1 — truth table i - th function digit position j ( 0 ≤ j < 8 ) equal value function case , output n line i - th line contain expression minimum length equal i - th function one expression output lexicographically smallest <unknown> satisfy give grammar n't contain white space truth table second function :","['bitmasks', 'dp', 'shortest paths']",2400.0
1184/B2,thank doctor 's help rebel manage steal enough gold launch a full - scale attack empire ! however darth vader look revenge want take back gold rebel hide gold various base throughout galaxy darth vader empire look send spaceships attack base galaxy represent undirected graph $$$ n $$$ planets ( nod ) $$$ m $$$ wormholes ( edge ) connect two planets a total $$$ s $$$ empire spaceships $$$ b $$$ rebel base locate different planets galaxy spaceship give a location $$$ x $$$ denote index planet locate attack strength $$$ a $$$ a certain amount fuel $$$ f $$$ base give a location $$$ x $$$ a defensive strength $$$ d $$$ a spaceship attack a base condition hold : vader particular attack <unknown> require spaceship attack one base base attack one spaceship vader know rebel hide $$$ k $$$ gold base assign spaceships attack base a way maximize number base attack therefore base attack rebel lose $$$ k $$$ gold however rebel ability create number dummy base doctor 's help base would exist beyond space time spaceship reach attack moreover a dummy base design seem <unknown> : always attack spaceship course dummy base contain gold create a dummy base cost $$$ h $$$ gold minimum gold rebel lose create optimal number dummy base ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 100 $$$ $$$ 0 \leq m \leq 10000 $$$ ) number nod number edge respectively next $$$ m $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \leq u $$$ $$$ v \leq n $$$ ) denote undirected edge two nod next line contain four integers $$$ s $$$ $$$ b $$$ $$$ k $$$ $$$ h $$$ ( $$$ 1 \leq s $$$ $$$ b \leq 1000 $$$ $$$ 0 \leq k $$$ $$$ h \leq 1000000000 $$$ ) number spaceships number base cost a base attack cost create a dummy base respectively next $$$ s $$$ line contain three integers $$$ x $$$ $$$ a $$$ $$$ f $$$ ( $$$ 1 \leq x \leq n $$$ $$$ 0 \leq a $$$ $$$ f \leq 1000000000 $$$ ) denote location attack fuel spaceship next $$$ b $$$ line contain two integers $$$ x $$$ $$$ d $$$ ( $$$ 1 \leq x \leq n $$$ $$$ 0 \leq d \leq 1000000000 $$$ ) denote location defence base print a single integer minimum cost term gold one way minimize cost build $$$ 4 $$$ dummy base a total cost $$$ 4 \times 3 = 12 $$$ one empire spaceship assign attack dummy base result zero actual base attack,"['graphs', 'shortest paths', 'sortings']",2200.0
1487/F,give a positive ( greater zero ) integer $$$ n $$$ represent $$$ n $$$ sum integers ( possibly negative ) consist ones ( digits ' 1 ' ) example $$$ 24 = 11 + 11 + 1 + 1 $$$ $$$ 102 = 111 - 11 + 1 + 1 $$$ among possible representations find one use minimum number ones total single line contain one integer $$$ n $$$ ( $$$ 1 \le n < 10^ { 50 } $$$ ) print one integer $$$ x $$$ — minimum number ones exist a representation $$$ n $$$ sum integers ( possibly negative ) use $$$ x $$$ ones total,"['dp', 'greedy', 'shortest paths']",2900.0
360/E,"levko love sport <unknown> competitions city much order boost performance levko spend spare time practice practice a game city consist n intersections connect m + k direct roads two roads connect pair intersections besides roads lead intersection levko zenyk play a game first levko stand intersection s1 zenyk stand intersection s2 want get intersection f. person <unknown> win get time game end a draw agreement players start simultaneously move speed levko want win much know lengths roads city also know change lengths roads ( k roads ) pay government , government change length i - th road integer value segment [ li ri ] ( border inclusive ) levko wonder reconstruct roads win game whether hope draw win consider players play optimally well guarantee get intersections s1 s2 intersection f. first line contain three integers n m k ( 1 ≤ n m ≤ 104 1 ≤ k ≤ 100 ) second line contain three integers s1 s2 f ( 1 ≤ s1 s2 f ≤ n ) next m line contain descriptions roads change levko line contain three integers ai bi ci ( 1 ≤ ai bi ≤ n 1 ≤ ci ≤ 109 ) represent a road intersection ai intersection bi length ci next k line contain descriptions roads change levko line contain four integers ai bi li ri ( 1 ≤ ai bi ≤ n 1 ≤ li ≤ ri ≤ 109 ) represent a road intersection ai intersection bi levko set road 's length within limit [ li ri ] consider intersections number 1 n. guarantee get intersections s1 s2 intersection f. first line print string ` ` win '' ( without quote ) levko win game string ` ` draw '' ( without quote ) levko end game a draw ` ` lose '' ( without quote ) lose sure answer ` ` win '' ` ` draw '' print second line k space - separated integers — length roads levko set order occur input","['graphs', 'greedy', 'shortest paths']",2800.0
416/E,good old berland n cities m roads road connect a pair distinct cities bidirectional pair cities one road road know length also know president soon ride along berland roads city s city t. naturally choose one shortest paths s t nobody say sure path choose <unknown> transport really afraid president might get upset state roads country reason plan repair roads possible president 's path make budget event easy task possible distinct pair s t ( s < t ) find number roads lie least one shortest path s t. first line input contain integers n m ( 2 ≤ n ≤ 500 0 ≤ m ≤ n · ( n - 1 ) / 2 ) — number cities roads correspondingly m line follow contain road descriptions one description per line description contain three integers xi yi li ( 1 ≤ xi yi ≤ n xi ≠ yi 1 ≤ li ≤ 106 ) xi yi number cities connect i - th road li length print sequence integers <unknown> <unknown> ... <unknown> <unknown> <unknown> ... <unknown> ... cn - 1 n cst number roads lie shortest path s t. print elements sequence c describe order pair cities s t n't a path cst = 0,"['dp', 'graphs', 'shortest paths']",2500.0
545/E,"little girl <unknown> accidentally find <unknown> brother 's <unknown> many things important solve problems find problem interest want know solution decide ask , problem statement follow let 's assume give a connect weight undirected graph g = ( v e ) ( v set vertices e set edge ) shortest - path tree vertex u graph g1 = ( v e1 ) a tree set edge e1 subset set edge initial graph e lengths shortest paths u vertex g g1 give a connect weight undirected graph g vertex u. task find shortest - path tree give graph vertex u total weight whose edge minimum possible first line contain two number n m ( 1 ≤ n ≤ 3·105 0 ≤ m ≤ 3·105 ) — number vertices edge graph respectively next m line contain three integers represent edge — ui vi wi — number vertices connect edge weight edge ( ui ≠ vi 1 ≤ wi ≤ 109 ) guarantee graph connect one edge pair vertices last line input contain integer u ( 1 ≤ u ≤ n ) — number start vertex first line print minimum total weight edge tree next line print indices edge include tree separate space edge number start 1 order follow input may print number edge order multiple answer print first sample two possible shortest path tree : example a tree edge 1 – 2 1 – 3 wo n't a shortest path tree vertex 3 distance vertex 3 vertex 2 tree equal 3 original graph 1","['graphs', 'greedy', 'shortest paths']",2000.0
238/E,urpal live a big city plan meet lover tonight city n junctions number 1 n. junctions connect m direct streets roads equal length urpal live junction a date plan a restaurant junction b. want use public transportation get junction b. k bus transportation company begin every second a bus i - th company choose a random shortest path junction si junction ti pass might path si ti case bus leave si ti a bus pass a junction urpal stand get bus also get <unknown> bus junction along path urpal want know 's possible go date use public transportation a finite amount time ( time travel sum length travel roads ) minimum number bus take worst case moment urpal know position place date get bus know index company bus course urpal know city map pair ( si ti ) company note urpal n't know bus velocity first line input contain four integers n m a b ( 2 ≤ n ≤ 100 ; 0 ≤ m ≤ n · ( n - 1 ) ; 1 ≤ a b ≤ n ; a ≠ b ) next m line contain two integers ui vi ( 1 ≤ ui vi ≤ n ; ui ≠ vi ) describe a direct road junction ui junction vi roads input distinct next line contain integer k ( 0 ≤ k ≤ 100 ) k line contain two integers si ti ( 1 ≤ si ti ≤ n ; si ≠ ti ) say a bus route start si end ti please note might path si ti case describe problem statement line output print minimum number bus urpal get way worst case 's possible reach destination worst case print -1,"['dp', 'graphs', 'shortest paths']",2600.0
1434/E,shikamaru asuma like play different game sometimes play follow : give increase list number take turn move move consist pick a number list assume pick number $$$ v _ { i_1 } $$$ $$$ v _ { i_2 } $$$ $$$ \ldots $$$ $$$ v _ { i_k } $$$ follow condition must hold : however 's easy play one instance game today shikamaru asuma decide play $$$ n $$$ <unknown> game agree take turn one game shikamaru go first turn player perform a valid move single game player move lose find win provide play optimally first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000 $$$ ) stand number game shikamaru asuma play next line describe game description start a line number $$$ m $$$ ( $$$ <unknown> 1 $$$ ) denote length number list second line contain increase space - separated sequence $$$ v_1 $$$ $$$ v_2 $$$ ... $$$ <unknown> $$$ game ( $$$ 1 \leq v _ { 1 } < v _ { 2 } < ... < v _ { m } \leq 10^ { 5 } $$$ ) total length sequence n't exceed $$$ 100000 $$$ print ` ` yes '' shikamaru secure victory ` ` '' otherwise first example shikamaru pick last number asuma anything first constraint second sample test asuma follow symmetric strategy repeat shikamaru 's move instance time therefore win,['dsu'],3500.0
884/E,give a matrix size n × m. element matrix either 1 0 . determine number connect components consist 1 's two cells belong component a common border elements cells 1 's note memory limit unusual ! first line contain two number n m ( 1 ≤ n ≤ <unknown> 4 ≤ m ≤ <unknown> ) — number row columns respectively guarantee m divisible 4 . representation matrix follow n next line contain one - digit hexadecimal number ( number represent either digits 0 9 uppercase latin letter a f ) binary representation number denote next 4 elements matrix correspond row example number b give correspond elements <unknown> number 5 correspond elements 0101 . elements separate <unknown> print number connect components consist 1 's first example matrix : clear three components second example : clear number components 2 . 1 's third example answer 0,['dsu'],2500.0
325/D,"a far away land exist a planet shape like a <unknown> three regions planet : top bottom side show follow picture top bottom areas consist big cities side area consist entirely sea one day a city decide little space would like reclamate side area land side area represent a grid r row c columns — cell represent a rectangular area side area row number 1 r top bottom columns number 1 c leave right two cells adjacent share a side addition two cells locate row — one leftmost column rightmost column — also adjacent initially cells occupy sea plan turn cells land one one a particular order give however sea side area also use a <unknown> trade route formally allow reclamate sea cells land way exist a sequence cells follow property : thus plan <unknown> time a cell go turn sea land city first need check whether would violate condition would cell turn land plan proceed next cell otherwise cell turn land job simulate output number cells successfully turn land first line consist three integers r c n ( 1 ≤ r c ≤ 3000 1 ≤ n ≤ 3·105 ) , n line follow describe cells order reclamate line consist two integers : ri ci ( 1 ≤ ri ≤ r 1 ≤ ci ≤ c ) represent cell locate row ri column ci line describe cells distinct output a single number represent number cells successfully turn land picture show sequence <unknown> perform example input blue cells represent cells occupy sea color cells represent land latest cell <unknown> color either yellow red depend whether addition violate condition statement dash red line represent a possible trade route exist route exist reclamation perform route exist skip remember leftmost rightmost cells row adjacent route exist skip hence result : 6 successful reclamation 3 fail ones",['dsu'],2900.0
1131/F,asya love animals much recently purchase $$$ n $$$ kitten enumerate $$$ 1 $$$ $$$ n $$$ put cage cage consist one row $$$ n $$$ cells enumerate integers $$$ 1 $$$ $$$ n $$$ leave right adjacent cells a partially <unknown> partition wall hence $$$ n - 1 $$$ partition originally initially cell contain exactly one kitten number observe kitten asya notice <unknown> often a pair kitten neighbor cells want play together asya start remove partition neighbor cells particular day $$$ i $$$ asya : since asya never <unknown> partition back $$$ n - 1 $$$ days cage contain a single cell kitten every day asya remember number kitten $$$ x_i $$$ $$$ y_i $$$ want play together however n't remember place kitten cage begin please help find possible initial arrangement kitten $$$ n $$$ cells first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le <unknown> $$$ ) — number kitten follow $$$ n - 1 $$$ line contain integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ ) — indices kitten get together due border removal correspond day 's guarantee kitten $$$ x_i $$$ $$$ y_i $$$ different cells day every cell $$$ 1 $$$ $$$ n $$$ print a single integer — index kitten $$$ 1 $$$ $$$ n $$$ originally print integers must distinct 's guarantee least one answer possible case multiple possible answer print answer example contain one several possible initial arrangements kitten picture show cells unite initial arrangement note kitten want play together day indeed adjacent cells,['dsu'],1700.0
60/B,"cereal guy 's friend serial guy like watch soap <unknown> episode start n't wash plate yet decide least put tap fill water plate represent a <unknown> k × n × m , k layer ( first layer upper one ) a rectangle n × m empty square ( ' . ' ) obstacles ( ' # ' ) water present empty square tap position square ( x y ) first layer guarantee square empty every minute a <unknown> unit water fall plate find many minutes serial guy <unknown> soap <unknown> turn water overfill plate , find moment time plate absolutely full go overfill next moment note : water fill area within reach ( see sample 4 ) water flow 6 directions face 1 × 1 × 1 cub first line contain three number k n m ( 1 ≤ k n m ≤ 10 ) size plate follow k rectangles consist n line contain m character ' . ' ' # ' represent ` ` layer '' plate order top bottom rectangles separate empty line ( see sample ) last line contain x y ( 1 ≤ x ≤ n 1 ≤ y ≤ m ) tap 's coordinate x number line y number column line layer number leave right integers 1 n columns layer number top bottom integers 1 m. answer contain a single number show many minutes plate fill","['dfs and similar', 'dsu']",1400.0
187/C,<unknown> pmp qualify icpc world <unknown> <unknown> <unknown> team <unknown> sun island park snow sculpture art <unknown> pmp get back bus leave park really big know find park n intersections number 1 n. m bidirectional roads connect pair intersections k intersections icpc volunteer help team show way destinations locations volunteer fix distinct pmp ask a volunteer way bus station he / she tell whole path park fully cover ice snow everywhere look almost pmp memorize q intersections question ( exclude intersection currently stand ) always tell volunteer weak memory direct path length ( number roads ) q lead bus station volunteer guide pmp another volunteer ( q intersections away course ) icpc volunteer know area well always tell pmp best way exist a way bus station pmp definitely find pmp 's initial location intersection s bus intersection t. always a volunteer intersection s. job find minimum q guarantee pmp find bus first line contain three space - separated integers n m k ( 2 ≤ n ≤ 105 0 ≤ m ≤ 2·105 1 ≤ k ≤ n ) — number intersections roads volunteer respectively next line contain k distinct space - separated integers 1 n inclusive — number cities volunteer locate next m line describe roads i - th line contain two space - separated integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) — two intersections i - th road connect one road two intersections last line input contain two space - separated integers s t ( 1 ≤ s t ≤ n s ≠ t ) — initial location pmp location bus might always possible reach t s. guarantee always a volunteer intersection s. print line answer problem — minimum value q guarantee pmp find bus pmp reach bus output -1 instead first sample illustrate blue intersections volunteer locate pmp go path dash line reach bus q = 3 : second sample pmp use intersection 6 intermediate intersection thus answer 3,"['dfs and similar', 'dsu']",2000.0
277/A,` ` <unknown> '' company get n employees employees use m approve official languages formal correspondence languages number integers 1 m. employee list languages know list could empty i. e. employee may know official languages employees will learn number official languages long company pay lessons a study course one language one employee cost 1 <unknown> find minimum sum money company need spend employee could correspond one ( correspondence <unknown> i. e. employees help translate ) first line contain two integers n m ( 2 ≤ n m ≤ 100 ) — number employees number languages n line follow — employee 's language list begin i - th line integer ki ( 0 ≤ ki ≤ m ) — number languages i - th employee know next i - th line contain ki integers — aij ( 1 ≤ aij ≤ m ) — identifiers languages i - th employee know guarantee identifiers one list distinct note employee may know zero languages number line separate single space print a single integer — minimum amount money pay end every employee could write a letter every one ( employees help translate ) second sample employee 1 learn language 2 employee 8 learn language 4 . third sample employee 2 must learn language 2,"['dfs and similar', 'dsu']",1400.0
461/D,toastman come a complicate task give appleman appleman n't know solve help ? give a n × n <unknown> cell board either character ' x ' character ' o ' nothing many ways fill empty cells ' x ' ' o ' ( cell must contain one character end ) cell number adjacent cells ' o ' even ? find number ways modulo 1000000007 ( 109 + 7 ) two cells board adjacent share a side first line contain two integers n k ( 1 ≤ n k ≤ 105 ) — size board number cells character initially k line follow i - th line contain two integers a character : ai bi ci ( 1 ≤ ai bi ≤ n ; ci either ' o ' ' x ' ) line mean : a character ci cell locate intersection ai - th row bi - th column give cells distinct consider row number 1 n top bottom analogically columns number 1 n leave right print a single integer — answer problem first example two ways :,"['dsu', 'math']",2800.0
765/D,<unknown> a friend saunders university <unknown> saunders present follow problem let [ n ] denote set { 1 ... n } also write f : [ x ] → [ y ] a function f define integer point 1 ... x value integers 1 y. give a function f : [ n ] → [ n ] task find a positive integer m two function g : [ n ] → [ m ] h : [ m ] → [ n ] g ( h ( x ) ) = x h ( g ( x ) ) = f ( x ) determine find impossible first line contain integer n ( 1 ≤ n ≤ 105 ) second line contain n space - separated integers — value f ( 1 ) ... f ( n ) ( 1 ≤ f ( i ) ≤ n ) answer print one integer -1 . otherwise first line print number m ( 1 ≤ m ≤ 106 ) second line print n number g ( 1 ) ... g ( n ) third line print m number h ( 1 ) ... h ( m ) several correct answer may output guarantee a valid answer exist answer satisfy restrictions,"['dsu', 'math']",1700.0
1055/B,"alice 's hair grow <unknown> bound maybe cause excess <unknown> maybe black magic ... prevent alice decide go hairdresser want hair length $$$ l $$$ centimeters haircut $$$ l $$$ favorite number suppose alice 's head a straight line $$$ n $$$ hairlines grow let 's number $$$ 1 $$$ $$$ n $$$ one swing scissor hairdresser shorten hairlines segment length $$$ l $$$ give hairlines segment length strictly greater $$$ l $$$ hairdresser want complete job fast possible make least possible number swing scissor since swing scissor take one second alice n't decide yet would go hairdresser ask calculate much time haircut would take depend time would go hairdresser particular need process query two type : note request $$$ 0 $$$ alice interest <unknown> scenario take a haircut hairlines change length first line contain three integers $$$ n $$$ $$$ m $$$ $$$ l $$$ ( $$$ 1 \le n m \le 100\,000 $$$ $$$ 1 \le l \le 1000000000 $$$ ) — number hairlines number request favorite number alice second line contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — initial lengths hairlines alice follow $$$ m $$$ line contain a request format describe statement request description start integer $$$ t_i $$$ $$$ t_i = 0 $$$ need find time haircut would take otherwise $$$ t_i = 1 $$$ moment one hairline grow rest line contain two integers : $$$ p_i $$$ $$$ d_i $$$ ( $$$ 1 \le p_i \le n $$$ $$$ 1 \le d_i \le 1000000000 $$$ ) — number hairline length grow query type $$$ 0 $$$ print time haircut would take consider first example :","['dsu', 'implementation']",1300.0
1685/D1,easy version problem difference easy hard versions version output permutation smallest weight give a permutation $$$ p_1 p_2 \ldots p_n $$$ integers $$$ 1 $$$ $$$ n $$$ let 's define weight permutation $$$ q_1 q_2 \ldots q_n $$$ integers $$$ 1 $$$ $$$ n $$$ $$$ $$$ <unknown> - p _ { q _ { 2 } } | + <unknown> - p _ { q _ { 3 } } | + \ldots + <unknown> _ { n-1 } - p _ { q _ { n } } | + <unknown> - p _ { q _ { 1 } } | $$$ $$$ want permutation <unknown> possible find permutation $$$ q $$$ smallest possible weight first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200 $$$ ) — size permutation second line test case contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i $$$ distinct ) — elements permutation sum $$$ n $$$ test case n't exceed $$$ 400 $$$ test case output $$$ n $$$ integers $$$ q_1 q_2 \ldots q_n $$$ ( $$$ 1 \le q_i \le n $$$ $$$ q_i $$$ distinct ) — one permutations smallest weight first test case two permutations length $$$ 2 $$$ : $$$ ( 1 2 ) $$$ $$$ ( 2 1 ) $$$ permutation $$$ ( 1 2 ) $$$ weight $$$ |1 - p_2| + |2 - p_1| = 0 $$$ permutation $$$ ( 2 1 ) $$$ weight : $$$ |2 - p_1| + |1 - p_2| = 0 $$$ output permutations version second test case weight permutation $$$ ( 1 3 4 2 ) $$$ $$$ |1 - p_3| + |3 - p_4| + |4 - p_2| + |2 - p_1| = |1 - 1| + |3 - 4| + |4 - 3| + |2 - 2| = 2 $$$ permutations smaller weight third test case weight permutation $$$ ( 1 4 2 3 5 ) $$$ $$$ |1 - p_4| + |4 - p_2| + |2 - p_3| + |3 - <unknown> + |5 - p_1| = |1 - 2| + |4 - 4| + |2 - 3| + |3 - 1| + |5 - 5| = 4 $$$ permutations smaller weight,"['dfs and similar', 'dsu']",2800.0
1765/A,bersoft biggest corporation berland monocarp head security department time face difficult task ever <unknown> $$$ n $$$ developers work bersoft number $$$ 1 $$$ $$$ n $$$ $$$ m $$$ document share internal network number $$$ 1 $$$ $$$ m $$$ a table access requirements $$$ a $$$ $$$ a _ { i j } $$$ ( $$$ j $$$ -th element $$$ i $$$ -th row ) $$$ 1 $$$ $$$ i $$$ -th developer access $$$ j $$$ -th document $$$ 0 $$$ access order restrict access monocarp go perform follow action : developer $$$ i $$$ access document $$$ j $$$ access level access group document greater equal require access level document 's smallest number access group monocarp choose 's possible assign access group access level order satisfy table access requirements ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 500 $$$ ) — number developers number document next $$$ n $$$ line contain a binary string length $$$ m $$$ — table access requirements $$$ j $$$ -th element $$$ i $$$ -th row $$$ 1 $$$ $$$ i $$$ -th developer access $$$ j $$$ -th document $$$ 0 $$$ access first line contain a single integer $$$ k $$$ — smallest number access group monocarp choose 's possible assign access group access level order satisfy table access requirements second line contain $$$ m $$$ integers $$$ 1 $$$ $$$ k $$$ — access group document third line contain $$$ m $$$ integers $$$ 1 $$$ $$$ 1000000000 $$$ — require access level document $$$ i $$$ -th next $$$ n $$$ line contain $$$ k $$$ integers $$$ 1 $$$ $$$ 1000000000 $$$ — access level $$$ i $$$ -th developer access group multiple solutions print first example assign document different access group document level $$$ 2 $$$ access group way assign developers need access level $$$ 2 $$$ developers access level $$$ 1 $$$ access group would impossible assign access level developers $$$ 1 $$$ $$$ 3 $$$ developer $$$ 1 $$$ ' ve a lower level developer $$$ 3 $$$ group able access document $$$ 1 $$$ time developer $$$ 3 $$$ ' ve a lower level developer $$$ 1 $$$ group able access document $$$ 2 $$$ since ca n't lower level 's impossible one access group second example 's possible assign document access group,"['bitmasks', 'dsu']",2400.0
873/F,"give a string s consist n lowercase latin letter indices string mark forbid want find a string a value |a|·f ( a ) maximum possible f ( a ) number occurences a s occurences end non - <unknown> indices , example s aaaa a aa index 3 forbid f ( a ) = 2 three occurences a s ( start indices 1 2 3 ) one ( start index 2 ) end a forbid index calculate maximum possible value |a|·f ( a ) get first line contain integer number n ( 1 ≤ n ≤ 200000 ) — length s. second line contain a string s consist n lowercase latin letter third line contain a string t consist n character 0 1 . i - th character t 1 i a forbid index ( otherwise i forbid ) print maximum possible value |a|·f ( a )","['dsu', 'strings']",2400.0
1725/K,pak chanek visit a kingdom earn a <unknown> ` ` kingdom criticism '' often residents criticise aspect kingdom one aspect often criticise heights build kingdom $$$ n $$$ build initially build $$$ i $$$ a height $$$ a_i $$$ units point time residents give a new criticism namely currently like build heights $$$ l $$$ $$$ r $$$ units inclusive two integers $$$ l $$$ $$$ r $$$ know $$$ r - l $$$ always odd $$$ 1 $$$ minute kingdom 's construction team increase decrease height build $$$ 1 $$$ unit long height still become a positive number time receive current criticism residents kingdom 's construction team make build heights $$$ l $$$ $$$ r $$$ units inclusive minimum time possible obtain one way note construction team care current criticism residents previous <unknown> forget $$$ q $$$ query must solve query one three follow possibilities : note change height still <unknown> next query first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 400000 $$$ ) — number build kingdom second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — initial heights build next line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 400000 $$$ ) — number query $$$ j $$$ -th next $$$ q $$$ line contain $$$ j $$$ -th query describe least one query type $$$ 2 $$$ query type $$$ 2 $$$ output a line contain integer represent height build ask $$$ 1 $$$ -st query height build $$$ 2 6 5 6 10 $$$ $$$ 3 $$$ -rd query height build $$$ 3 6 5 6 10 $$$ $$$ 4 $$$ -th query height build $$$ 2 7 7 7 10 $$$ $$$ 5 $$$ -th query height build $$$ 2 7 7 7 10 $$$ $$$ 6 $$$ -th query height build $$$ 2 9 7 7 10 $$$,"['data structures', 'dsu']",2500.0
1578/B,"$$$ n $$$ villages lie <unknown> a circle middle a <unknown> impassable forest ancient time impossible move one village another <unknown> progress change a lot , a technology build passable trail forest build process consist $$$ m $$$ events event either build a trail query two villages connect trail build straight line connect two villages a trail build anybody walk along trail one village another moreover two trail cross anybody turn intersection trail leave a village reach also use walk along , example villages number $$$ 1 $$$ $$$ 6 $$$ order around circle trail $$$ 1 $$$ $$$ 3 $$$ $$$ 2 $$$ $$$ 4 $$$ $$$ 4 $$$ $$$ 6 $$$ villages except $$$ 5 $$$ -th reachable $$$ 1 $$$ -st village give a list $$$ m $$$ events query find two give villages reachable moment first line contain two integers $$$ n $$$ ( $$$ 2 \le n \le 2\cdot 100000 $$$ ) $$$ m $$$ ( $$$ 1 \le m \le 3\cdot 100000 $$$ ) — number villages number events respectively next $$$ m $$$ line contain events event description consist three integers $$$ e $$$ ( $$$ e $$$ $$$ 1 $$$ $$$ 2 $$$ ) $$$ v $$$ ( $$$ 1 \le v \le n $$$ ) $$$ u $$$ ( $$$ 1 \le u \le n $$$ $$$ u \ne v $$$ ) $$$ e = 1 $$$ event build a trail villages $$$ v $$$ $$$ u $$$ $$$ e = 2 $$$ event a query villages $$$ v $$$ $$$ u $$$ connect guarantee trail build villages number $$$ 1 $$$ $$$ n $$$ clockwise order around circle query print one character ' 0 ' villages reachable ' 1 ' villages reachable print answer query a single string one line","['data structures', 'dsu']",2800.0
1044/D,"array $$$ a $$$ $$$ 2^ { 30 } $$$ integers index $$$ 0 $$$ $$$ 2^ { 30 } -1 $$$ initially know $$$ 0 \leq a_i < 2^ { 30 } $$$ ( $$$ 0 \leq i < 2^ { 30 } $$$ ) know value task process query two type : note query encode , need write online solution first line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 200000 $$$ ) — number query next $$$ q $$$ line describe a query contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 2 $$$ ) — type query give query encode follow way : let $$$ last $$$ answer last query second type answer ( initially $$$ last = 0 $$$ ) last answer $$$ -1 $$$ set $$$ last = 1 $$$ .and $$$ l > r $$$ swap $$$ l $$$ $$$ r $$$ mean get update bitwise xor subarray $$$ [ l r ] $$$ equal $$$ x $$$ ( notice need ignore update contradict previous update ) .and $$$ l > r $$$ swap $$$ l $$$ $$$ r $$$ give query need print bitwise xor subarray $$$ [ l r ] $$$ impossible know print $$$ -1 $$$ n't forget change value $$$ last $$$ guarantee least one query second type every query second type output bitwise xor give subarray $$$ -1 $$$ still impossible know first example real query ( without encode ) : second example notice first two update already know $$$ <unknown> \oplus <unknown> = 12 $$$ third update contradict ignore","['data structures', 'dsu']",2400.0
471/E,polar bear menshykov uslada zoo st . petersburg elephant horace zoo kiev decide paint try create first masterpiece make a draft a piece paper draft consist n segment segment either horizontal vertical friends want simplify draft delete segment part segment final masterpiece meet three condition : part draft already beautiful friends decide delete part draft sum lengths remain segment large possible task count maximum sum lengths remain extra segment remove first line input contain integer n ( 1 ≤ n ≤ 2·105 ) — number segment draft next n line contain four integers : x1 y1 x2 y2 ( - 109 ≤ x1 ≤ x2 ≤ 109 ; - 109 ≤ y1 ≤ y2 ≤ 109 ) — two startpoint two endpoint coordinate a segment segment non - <unknown> either strictly horizontal strictly vertical two horizontal segment share common point two vertical segment share common point print a single integer — maximum sum lengths remain segment shape get two give sample : first sample need delete segment two segment together form a single connect shape second sample initial segment form a cycle four ways break cycle : delete first second fourth segment <unknown> delete middle third segment last way show picture,"['data structures', 'dsu']",2700.0
1620/A,"$$$ n $$$ positive integers $$$ a_1 a_2 \dots a_n $$$ arrange a circle pair neighbor number ( $$$ a_1 $$$ $$$ a_2 $$$ $$$ a_2 $$$ $$$ a_3 $$$ ... $$$ a _ { n - 1 } $$$ $$$ a_n $$$ $$$ a_n $$$ $$$ a_1 $$$ ) write : number pair equal unfortunately ' ve lose a piece paper array $$$ a $$$ moreover afraid even information equality neighbor elements may <unknown> , wonder : array $$$ a $$$ consistent information equality non - equality correspond pair ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next $$$ t $$$ case follow first line test case contain a non - empty string $$$ s $$$ consist character e and/or n. length $$$ s $$$ equal size array $$$ n $$$ $$$ 2 \le n \le 50 $$$ $$$ i $$$ $$$ 1 $$$ $$$ n $$$ : test case print yes 's possible choose array $$$ a $$$ consistent information $$$ s $$$ know otherwise print prove exist array $$$ a $$$ exist array $$$ a $$$ positive integers value less equal $$$ 1000000000 $$$ first test case choose example $$$ a_1 = a_2 = a_3 = 5 $$$ second test case array $$$ a $$$ since accord $$$ s_1 $$$ $$$ a_1 $$$ equal $$$ a_2 $$$ , accord $$$ s_2 $$$ $$$ a_2 $$$ equal $$$ a_1 $$$ third test case , example choose array $$$ a = [ 20 20 4 50 50 50 20 ] $$$ fourth test case , example choose $$$ a = [ 1 3 3 7 ] $$$","['dsu', 'implementation']",800.0
566/D,"even successful company go a crisis period make a hard decision — <unknown> discard merge departments fire employees unpleasant stuff let 's consider follow model a company n people work large <unknown> company person belong department initially person work project department ( thus company initially consist n departments one person ) however harsh time come company management hire a crisis manager would rebuild work process order boost efficiency let 's use team ( person ) represent a team person person work a crisis manager make decisions two type : crisis manager sometimes wonder whether employees x y ( 1 ≤ x y ≤ n ) work department help crisis manager answer query first line input contain two integers n q ( 1 ≤ n ≤ 200 000 1 ≤ q ≤ 500 000 ) — number employees company number query crisis manager next q line contain query crisis manager query look like type x y , type = 1 type = 2 query represent decision a crisis manager merge departments first second type respectively type = 3 task determine whether employees x y work department note x equal y query type question type 3 print ` ` yes '' ` ` '' ( without quote ) depend whether correspond people work department","['data structures', 'dsu']",1900.0
722/C,"give array consist n non - negative integers a1 a2 ... , go destroy integers array one one thus give permutation integers 1 n define order elements array destroy element destroy find segment array contain destroy elements sum elements maximum possible sum elements empty segment consider 0 . first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — length array second line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 109 ) third line contain a permutation integers 1 n — order use destroy elements print n line i - th line contain a single integer — maximum possible sum elements segment contain destroy elements first i operations perform consider first sample :","['data structures', 'dsu']",1600.0
13/E,"little petya like play a lot like play a game « hole » a game one person follow rule : n hole locate a single row number leave right number 1 n. hole 's power ( hole number i power ai ) throw a ball hole i immediately jump hole i + ai jump hole number ball jump row m move player perform one two action : petya good math , already guess perform <unknown> first line contain two integers n m ( 1 ≤ n ≤ 105 1 ≤ m ≤ 105 ) — number hole a row number move second line contain n positive integers exceed n — initial value hole power follow m line describe move make petya line one two type : move type 1 output two space - separated number a separate line — number last hole ball visit leave row number jump make","['data structures', 'dsu']",2700.0
896/E,— i ... i <unknown> . — <unknown> home chtholly . — i keep promise ... — i make ... i really make ! several days fight chtholly <unknown> <unknown> miraculously return <unknown> battle promise willem bake butter cake however although willem <unknown> make <unknown> <unknown> bake butter cake time willem make a big mistake — accidentally break <unknown> ! fortunately chtholly decide help willem put n cake a roll cake number 1 n i - th cake need ai second bake willem need chtholly m operations bake cake operation 1 : 1 l r xwillem ask chtholly check cake range [ l r ] cake need bake x second would bake x second put back place precisely every i range [ l r ] ai strictly x ai become equal ai - x. operation 2 : 2 l r xwillem ask chtholly count number cake range [ l r ] need cook exactly x second formally find number i range [ l r ] ai = x. first line contain two integers n m ( 1 ≤ n m ≤ 105 ) second line contain n integers i - th ai ( 1 ≤ ai ≤ 105 ) next m line m operations describe guarantee 1 ≤ l ≤ r ≤ n 1 ≤ x ≤ 105 . operation second type print answer,"['data structures', 'dsu']",3100.0
1740/G,"pak chanek $$$ n \times m $$$ grid portals portal $$$ i $$$ -th row $$$ j $$$ -th column denote portal $$$ ( i j ) $$$ portals $$$ ( 1,1 ) $$$ $$$ ( n m ) $$$ north - west south - east corner grid respectively portal $$$ ( i j ) $$$ two settings : a laser enter face $$$ k $$$ portal $$$ ( i j ) $$$ speed $$$ x_\text { } $$$ leave portal go face $$$ ( <unknown> _ { i j } ) \bmod 4 $$$ speed $$$ x_\text { } = \max ( x_\text { } s _ { i j } ) $$$ portal also consume $$$ x_\text { } - x_\text { } $$$ units energy pak chanek bore today shoot $$$ 4 nm $$$ lasers initial speed $$$ 1 $$$ one face portal laser travel throughout grid portals move outside grid pass $$$ 10^ { 100 } $$$ portals end pak chanek think a portal good total energy consume portal modulo $$$ 2 $$$ equal type give strength settings portals find a way assign type settings portal number good portals <unknown> first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 1000 $$$ ) — number row columns grid $$$ i $$$ -th next $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th integer $$$ s _ { i j } $$$ ( $$$ 1 \leq s _ { i j } \leq 1000000000 $$$ ) — strength portal $$$ ( i j ) $$$ print $$$ n $$$ line line contain a string length $$$ m $$$ consist character $$$ 0 $$$ $$$ 1 $$$ represent type settings $$$ j $$$ -th character $$$ i $$$ -th string type set portal $$$ ( i j ) $$$ multiple solutions output first example let 's consider laser pak chanek shoot face $$$ 1 $$$ portal $$$ ( 2 2 ) $$$ laser travel follow : <unknown> travel laser follow example consider portal $$$ ( 2 3 ) $$$ calculate total energy consume portal end $$$ 32 $$$ since $$$ 32 \bmod 2 = 0 $$$ $$$ t _ { 2,3 } = 0 $$$ a good portal","['dsu', 'sortings']",3100.0
1303/F,give a matrix $$$ n \times m $$$ initially fill zero define $$$ a _ { i j } $$$ element $$$ i $$$ -th row $$$ j $$$ -th column matrix two cells matrix connect share a side elements cells equal two cells matrix belong connect component exist a sequence $$$ s_1 $$$ $$$ s_2 $$$ ... $$$ s_k $$$ $$$ s_1 $$$ first cell $$$ s_k $$$ second cell every $$$ i \in [ 1 k - 1 ] $$$ $$$ s_i $$$ $$$ s _ { i + 1 } $$$ connect give $$$ q $$$ query form $$$ x_i $$$ $$$ y_i $$$ $$$ c_i $$$ ( $$$ i \in [ 1 q ] $$$ ) every query follow : one additional constraint : every $$$ i \in [ 1 q - 1 ] $$$ $$$ c_i \le c _ { i + 1 } $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \le n m \le 300 $$$ $$$ 1 \le q \le 2000000 $$$ ) — number row number columns number query respectively $$$ q $$$ line follow represent a query $$$ i $$$ -th line contain three integers $$$ x_i $$$ $$$ y_i $$$ $$$ c_i $$$ ( $$$ 1 \le x_i \le n $$$ $$$ 1 \le y_i \le m $$$ $$$ 1 \le c_i \le \max ( 1000 \lceil \frac { 2 \cdot 1000000 } { nm } \rceil ) $$$ ) every $$$ i \in [ 1 q - 1 ] $$$ $$$ c_i \le c _ { i + 1 } $$$ print $$$ q $$$ integers $$$ i $$$ -th equal number components matrix first $$$ i $$$ query perform,"['dsu', 'implementation']",2800.0
45/B,"n students study 6th grade group ` ` b '' a berland <unknown> school every one exactly one friend call news let us denote friend person number i g ( i ) note <unknown> mutual i.e g ( g ( i ) ) necessarily equal i. day i person number ai learn news rat bi ( bi ≥ 1 ) phone friend immediately tell , news become old rat fall a little become equal bi - 1 . friend thing — also call friend also tell news friend friend get news already rat bi - 2 . continue rat news reach zero nobody want tell news zero rat formally everybody act like : a person x learn news a non - zero rat y call friend g ( i ) friend learn news rat y - 1 possible continue process let us note a day one person may call friend tell one news different rat thus news rat bi lead much bi call task count value resi — many students learn first news day i. value bi know initially whereas ai determine follow formula : first line contain two space - separated integers n m ( 2 ≤ n m ≤ 105 ) — number students number days second line contain n space - separated integers g ( i ) ( 1 ≤ g ( i ) ≤ n g ( i ) ≠ i ) — number a friend i - th student third line contain m space - separated integers vi ( 1 ≤ vi ≤ 107 ) fourth line contain m space - separated integers bi ( 1 ≤ bi ≤ 107 ) print m line contain one number i - th line contain resi — number students first news ' ve learn m days question news number i. number news number day learn days number start one order give input file n't output <unknown>","['dp', 'dsu']",2200.0
46/F,"today solve problem even famous hercule poirot ca n't cope ! 's crime yet solve story never include <unknown> <unknown> 's detective story book inform crime commit <unknown> find detail know crime commit a house n room m doors pair room house residents suspicious 's doors lock key key different accord provide <unknown> thursday night doors house lock know room residents kind key one know friday night doors also lock friday rain heavily 's nobody leave house nobody enter day house residents could '' little grey matter '' hercule poirot capable <unknown> amount information find position people key thursday night could result position friday night otherwise somebody among witness surely lie first line contain three <unknown> integers n m и k ( 1 ≤ n m k ≤ 1000 ) — number room number doors number house residents respectively next m line contain pair room number join doors room number integers 1 n. one door pair room door connect a room next k line describe residents ' position first night every line contain a resident 's name ( a non - empty line consist 10 latin letter ) a space follow room number , a space — number key resident follow write space - separated number doors unlock key doors number integers 1 m order describe input data residents different name uppercase lowercase letter consider different every m key occur exactly description multiple people may present one room room may empty next k line describe position residents second night format guarantee second night 's description residents ' name remain every m key occur exactly print ` ` yes '' ( without quote ) second arrangement result first one otherwise print ` ` ''","['dsu', 'graphs']",2300.0
356/A,"<unknown> ! <unknown> <unknown> king berland make a knight tournament king already send message knight kingdom turn agree participate grand event , 're a simple <unknown> 's surprise sleep morning late tournament ( a weekend ) really curious result tournament time tournament berland go follow : fish information fight friends knight want know name knight conquer think knight number b conquer knight number a a fight knight present winner knight number a. write code calculate knight name knight beat first line contain two integers n m ( 2 ≤ n ≤ 3·105 ; 1 ≤ m ≤ 3·105 ) — number knight number fight follow m line contain three integers li ri xi ( 1 ≤ li < ri ≤ n ; li ≤ xi ≤ ri ) — description i - th fight guarantee input correct match problem statement guarantee least two knight take part battle print n integers i - th knight lose i - th number equal number knight beat knight number i. i - th knight winner i - th number must equal 0 . consider first test case knight 1 2 fight first fight knight 1 knight 1 3 fight second fight knight 3 last fight knight 3 4 knight 4","['data structures', 'dsu']",1500.0
437/D,course child like walk a zoo zoo n areas number 1 n. i - th area contain ai animals also m roads zoo road connect two distinct areas naturally zoo connect reach area zoo area use roads child smart imagine child want go area p area q. firstly consider simple rout p q. route child write number equal minimum number animals among route areas let 's denote largest write number f ( p q ) finally child choose one rout write value f ( p q ) child visit zoo think question : average value f ( p q ) pair p q ( p ≠ q ) ? answer question ? first line contain two integers n m ( 2 ≤ n ≤ 105 ; 0 ≤ m ≤ 105 ) second line contain n integers : a1 a2 ... ( 0 ≤ ai ≤ 105 ) follow m line line contain two integers xi yi ( 1 ≤ xi yi ≤ n ; xi ≠ yi ) denote road areas xi yi roads bidirectional pair areas connect one road output a real number — value answer consider correct relative absolute error n't exceed 10 - 4 . consider first sample 12 possible situations : another 6 case symmetrical average consider second sample 6 possible situations : another 3 case symmetrical average,"['dsu', 'sortings']",1900.0
1012/E,"give array $$$ n $$$ positive integers $$$ a_1 a_2 \dots a_n $$$ perform follow operation number time : select several distinct indices $$$ i_1 i_2 \dots i_k $$$ ( $$$ 1 \le i_j \le n $$$ ) move number stand position $$$ i_1 $$$ position $$$ i_2 $$$ number position $$$ i_2 $$$ position $$$ i_3 $$$ ... number position $$$ i_k $$$ position $$$ i_1 $$$ word operation cyclically shift elements : $$$ i_1 \to i_2 \to \ldots i_k \to i_1 $$$ example $$$ n=4 $$$ array $$$ <unknown> <unknown> a_3=30 <unknown> $$$ choose three indices $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ result array would become $$$ <unknown> <unknown> a_3=30 <unknown> $$$ goal make array sort non - decreasing order minimum number operations additional constraint sum cycle lengths operations less equal a number $$$ s $$$ 's impossible sort array satisfy constraint solution report well first line input contain two integers $$$ n $$$ $$$ s $$$ ( $$$ 1 \leq n \leq 200\,000 $$$ $$$ 0 \leq s \leq 200\,000 $$$ ) — the number elements array upper bind sum cycle lengths next line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ — elements array ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) 's impossible sort array use cycle total length exceed $$$ s $$$ print a single number ` ` -1 '' ( quote clarity ) otherwise print a single number $$$ q $$$ — minimum number operations require sort array next $$$ 2 \cdot q $$$ line print descriptions operations order apply array description $$$ i $$$ -th operation begin a single line contain one integer $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) — the length cycle ( number select indices ) next line contain $$$ k $$$ distinct integers $$$ i_1 i_2 \dots i_k $$$ ( $$$ 1 \le i_j \le n $$$ ) — the indices cycle sum lengths cycle less equal $$$ s $$$ array sort apply $$$ q $$$ operations several possible answer optimal $$$ q $$$ print first example 's also possible sort array two operations total length 5 : first apply cycle $$$ 1 \to 4 \to 1 $$$ ( length 2 ) apply cycle $$$ 2 \to 3 \to 5 \to 2 $$$ ( length 3 ) however would wrong answer 're ask use minimal possible number operations 1 case second example 's possible sort array two cycle total length 4 ( $$$ 1 \to 2 \to 1 $$$ $$$ 3 \to 4 \to 3 $$$ ) however 's impossible achieve use shorter cycle require $$$ <unknown> $$$ third example array already sort operations need total length empty set cycle consider zero","['dsu', 'math']",3100.0
1249/B1,difference easy hard versions constraints $$$ n $$$ kid read a unique book end day $$$ i $$$ -th kid give book $$$ p_i $$$ -th kid ( case $$$ i = p_i $$$ kid give book ) guarantee value $$$ p_i $$$ distinct integers $$$ 1 $$$ $$$ n $$$ ( i.e $$$ p $$$ a permutation ) sequence $$$ p $$$ n't change day day fix example $$$ <unknown> $$$ $$$ p= [ 4 6 1 3 5 2 ] $$$ end first day book $$$ 1 $$$ -st kid belong $$$ 4 $$$ -th kid $$$ 2 $$$ -nd kid belong $$$ 6 $$$ -th kid end second day book $$$ 1 $$$ -st kid belong $$$ 3 $$$ -th kid $$$ 2 $$$ -nd kid belong $$$ 2 $$$ -th kid task determine number day book $$$ i $$$ -th child return back first time every $$$ i $$$ $$$ 1 $$$ $$$ n $$$ consider follow example : $$$ p = [ 5 1 2 4 3 ] $$$ book $$$ 1 $$$ -st kid pass follow kid : fourth day book first kid return <unknown> book fourth kid return first time exactly one day answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200 $$$ ) — number query $$$ q $$$ query follow first line query contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200 $$$ ) — number kid query second line query contain $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i $$$ distinct i.e $$$ p $$$ a permutation ) $$$ p_i $$$ kid get book $$$ i $$$ -th kid query print answer : $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ $$$ a_i $$$ number day book $$$ i $$$ -th child return back first time query,"['dsu', 'math']",1000.0
433/D,nanami expert play game day nanami 's good friend <unknown> invite watch a game <unknown> <unknown> follow stadium nanami interest game look around see something might interest 's saw digital board one end stadium digital board n pixels height m pixels width every pixel either light dark pixels describe coordinate j - th pixel i - th line pixel ( i j ) board display message switch a combination pixels light rest dark nanami notice state pixels board change time time certain time certain pixels board may switch light dark dark light nanami wonder area biggest light block a specific pixel side a light block a sub - rectangle board pixels light pixel ( i j ) belong a side sub - rectangle ( x1 y1 ) ( x2 y2 ) upper - left lower - right vertex satisfy logical condition : nanami history change pixels also question describe type answer ? first line contain three space - separated integers n m q ( 1 ≤ n m q ≤ 1000 ) — height width digital board number operations follow n line line contain m space - separated integers j - th integer i - th line ai j — initial state pixel ( i j ) follow q line line contain three space - separated integers op x y ( 1 ≤ op ≤ 2 ; 1 ≤ x ≤ n ; 1 ≤ y ≤ m ) describe operation query print a single line contain one integer — answer nanami 's query consider first sample first query specify pixel ( 2 2 ) dark valid light block thus answer 0 . second query specify pixel ( 1 2 ) biggest light block block ( 1 2 ) upper - left vertex ( 1 3 ) lower - right vertex last query specify pixel ( 2 2 ) become light third operation biggest light block block ( 1 2 ) upper - left vertex ( 3 3 ) lower - right vertex,"['dsu', 'implementation']",2000.0
1009/F,give a root undirected tree consist $$$ n $$$ vertices vertex $$$ 1 $$$ root let 's denote a depth array vertex $$$ x $$$ infinite sequence $$$ [ d _ { x 0 } d _ { x 1 } d _ { x 2 } \dots ] $$$ $$$ d _ { x i } $$$ number vertices $$$ y $$$ condition hold : dominant index a depth array vertex $$$ x $$$ ( <unknown> dominant index vertex $$$ x $$$ ) index $$$ j $$$ : every vertex tree calculate dominant index first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — number vertices a tree $$$ n - 1 $$$ line follow contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ $$$ x \ne y $$$ ) line denote edge tree guarantee edge form a tree output $$$ n $$$ number $$$ i $$$ -th number equal dominant index vertex $$$ i $$$,"['data structures', 'dsu', 'trees']",2300.0
217/E,"professor bajtocy conduct experiment alien dna discover subject <unknown> mutations — mutation happen way : continuous subsequence alien dna become active copy copy get mangle insert right original subsequence mangle copy activate continuous subsequence form first join elements even position subsequence join elements odd ones end , activate subsequence consist 11 elements represent s1s2 ... <unknown> mangle copy <unknown> example original sequence ` ` <unknown> '' mutation happen segment [ 2 4 ] ( activate subsequence ` ` <unknown> '' ) mutate dna : ` ` <unknown> '' mangle copy activate subsequence mark bold <unknown> professor bajtocy write original dna sequence mutations sequentially happen ask recover first k elements dna sequence mutations first line input contain original dna sequence consist letter ` ` a '' ` ` c '' ` ` t '' ` ` g '' exceed 3·106 length second line contain a single integer k ( 1 ≤ k ≤ 3·106 ) third line contain a single integer n ( 0 ≤ n ≤ 5000 ) — number mutations next n line describe mutations chronological order — mutation describe two number li ri ( 1 ≤ li ≤ ri ≤ 109 ) mean continuous subsequence [ li ri ] become active <unknown> join mangle copy guarantee input data correct , mutation act non - <unknown> elements dna sequence result dna sequence least k elements assume dna elements index start 1 notation [ l r ] mean continuous subsequence dna sequence consist r - l + 1 elements start l - th dna sequence element end r - th dna sequence element output a single line contain first k letter mutate dna sequence second example first mutation sequence ` ` <unknown> '' second mutation 's ` ` <unknown> ''","['data structures', 'dsu', 'trees']",2800.0
165/D,"let 's define a non - <unknown> connect graph n vertices n - 1 edge a beard vertices except perhaps one degree 2 1 ( exist one vertex whose degree two ) let us remind degree a vertex number edge connect let edge either black white initially edge black give description beard graph task analyze request follow type : vertices number integers 1 n edge number integers 1 n - 1 . first line input contain integer n ( 2 ≤ n ≤ 105 ) — number vertices graph next n - 1 line contain edge describe number vertices vi ui ( 1 ≤ vi ui ≤ n vi ≠ ui ) connect edge guarantee give graph connect form a beard graph self - loops multiple edge next line contain integer m ( 1 ≤ m ≤ 3·105 ) — number request next m line contain request follow form : first a line contain integer type take value <unknown> 1 3 represent request type type = 1 current request a request paint edge black case addition number type line contain integer i d ( 1 ≤ i d ≤ n - 1 ) represent number edge paint type = 2 current request a request paint edge white form similar previous request type = 3 current request a request find distance case addition type line contain two integers a b ( 1 ≤ a b ≤ n a equal b ) — number vertices distance must find number line separate exactly one space edge number order give input request ` ` find distance vertices a b '' print result path go along black edge vertices a b print ` ` -1 '' ( without quote ) print result order receive request separate number space line break first sample vertices 1 2 connect edge number 1 vertices 2 3 connect edge number 2 . repaint edge number 2 vertex reachable one along black edge specifically shortest path 1 3 go along edge paint edge number 2 white vertex 3 end cut vertices , path exist vertex along black edge","['data structures', 'dsu', 'trees']",2100.0
109/C,"petya love lucky number know lucky number positive integers whose decimal representations contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 one day petya encounter a tree n vertexes besides tree weight i. e. edge tree weight ( a positive integer ) edge lucky weight a lucky number note a tree n vertexes undirected connect graph exactly n - 1 edge petya wonder many vertex triple ( i j k ) exist way i j well way i k must least one lucky edge ( three vertexes pairwise distinct ) order number triple matter , triple ( 1 2 3 ) equal triple ( 2 1 3 ) equal triple ( 1 3 2 ) find many triple vertexes exist first line contain single integer n ( 1 ≤ n ≤ 105 ) — number tree vertexes next n - 1 line contain three integers : ui vi wi ( 1 ≤ ui vi ≤ n 1 ≤ wi ≤ 109 ) — pair vertexes connect edge edge 's weight single line print single number — answer please use % lld specificator read write 64 - bit number с++ recommend use cin cout stream % i64d specificator 16 triple vertexes first sample : ( 1 2 4 ) ( 1 4 2 ) ( 2 1 3 ) ( 2 1 4 ) ( 2 3 1 ) ( 2 3 4 ) ( 2 4 1 ) ( 2 4 3 ) ( 3 2 4 ) ( 3 4 2 ) ( 4 1 2 ) ( 4 1 3 ) ( 4 2 1 ) ( 4 2 3 ) ( 4 3 1 ) ( 4 3 2 ) second sample triple count : <unknown> = 24","['dp', 'dsu', 'trees']",1900.0
679/C,"a grid n row n columns cell either empty ( denote ' . ' ) block ( denote ' x ' ) two empty cells directly connect share a side two cells ( r1 c1 ) ( locate row r1 column c1 ) ( r2 c2 ) connect exist a sequence empty cells start ( r1 c1 ) finish ( r2 c2 ) two consecutive cells sequence directly connect a connect component a set empty cells two cells component connect cell set connect cell set friend limak a big <unknown> bear able destroy obstacles range precisely choose a square size k × k grid limak transform block cells empty ones however ask limak help choose square must completely inside grid 's possible limak wo n't change anything cells empty anyway like big connect components limak help maximum possible size biggest connect component grid ? first line input contain two integers n k ( 1 ≤ k ≤ n ≤ 500 ) — size grid limak 's range respectively next n line contain a string n character denote i - th row grid character ' . ' ' x ' denote empty cell a block one respectively print maximum possible size ( number cells ) biggest connect component use limak 's help first sample choose a square size 2 × 2 . 's optimal choose a square red <unknown> leave draw , get a connect component 10 cells mark blue right draw","['dfs and similar', 'dsu', 'implementation']",2400.0
1713/E,"give a square matrix $$$ a $$$ size $$$ n \times n $$$ whose elements integers denote element intersection $$$ i $$$ -th row $$$ j $$$ -th column $$$ a _ { i j } $$$ perform operations matrix operation choose integer $$$ k $$$ index $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) swap $$$ a _ { i k } $$$ $$$ a _ { k i } $$$ note cell $$$ a _ { k k } $$$ remain unchanged example $$$ n = 4 $$$ $$$ k = 3 $$$ matrix transform like : perform operation number time find lexicographically smallest matrix $$$ ^\dagger $$$ obtain perform arbitrary number operations $$$ { } ^\dagger $$$ two matrices $$$ a $$$ $$$ b $$$ size $$$ n \times n $$$ let $$$ a _ { ( i-1 ) \cdot n + j } = a _ { i j } $$$ $$$ b _ { ( i-1 ) \cdot n + j } = b _ { i j } $$$ , matrix $$$ a $$$ lexicographically smaller matrix $$$ b $$$ exist index $$$ i $$$ ( $$$ 1 \leq i \leq n^2 $$$ ) $$$ a_i < b_i $$$ indices $$$ j $$$ $$$ 1 \leq j < i $$$ $$$ a_j = b_j $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000 $$$ ) — size matrix $$$ i $$$ -th line next $$$ n $$$ line contain $$$ n $$$ integers $$$ a _ { i 1 } a _ { i 2 } \dots a _ { i n } $$$ ( $$$ 1 \le a _ { i j } \le 1000000000 $$$ ) — description matrix $$$ a $$$ guarantee sum $$$ n^2 $$$ test case exceed $$$ 1000000 $$$ test case print $$$ n $$$ line $$$ n $$$ integers — lexicographically smallest matrix note every picture matrix transform a way blue row swap green columns first test case perform $$$ 1 $$$ operation $$$ k = 3 $$$ matrix transform :","['data structures', 'dsu', 'greedy']",2400.0
212/D,vasya <unknown> <unknown> separate wood a fence fence consist n plank put a line fence close a circle plank number leave right 1 n i - th plank height ai plank width lower edge plank locate grind level recently a local <unknown> ` ` <unknown> life '' write fashionable way decorate a fence summer draw a fuchsia - colored rectangle lower side rectangle must locate lower edge fence vasya <unknown> idea ! immediately buy fuchsia - colored paint begin decide kind rectangle paint vasya sure rectangle cover k consecutive plank word paint plank number x x + 1 ... x + k - 1 x ( 1 ≤ x ≤ n - k + 1 ) want paint rectangle maximal area rectangle height equal min ai x ≤ i ≤ x + k - 1 x number first color plank vasya already make mind rectangle width equal one number sequence k1 k2 ... km ki want know expect height paint rectangle provide select x fence uniformly among n - ki + 1 possible value help find expect heights first line contain a single integer n ( 1 ≤ n ≤ 106 ) — number plank fence second line contain a sequence integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) ai height i - th plank fence third line contain integer m ( 1 ≤ m ≤ 106 ) next line contain m space - separated integers k1 k2 ... km ( 1 ≤ ki ≤ n ) ki width desire fuchsia - colored rectangle plank print m whitespace - separated real number i - th number equal expect value rectangle height width plank equal ki value consider correct absolute relative error n't exceed 10 - 9 . let 's consider first sample test,"['binary search', 'data structures', 'dsu']",2500.0
696/E,barney search dream girl live nyc nyc n junctions number 1 n n - 1 roads connect consider nyc a root tree root junction 1 . m girls live nyc i - th live along junction ci weight initially equal i pound barney consider a girl x better a girl y : girl x weight strictly less girl y girl x girl y equal weight index girl x live junction index strictly less girl y live junction index i.e <unknown> < <unknown> thus two girls one always better another one next q days one event happen day two type events : task event first type tell barney indices girls invite home event first line input contain three integers n m q ( 1 ≤ n m q ≤ 105 ) — number junctions nyc number girls live nyc number events respectively next n - 1 line describe roads line contain two integers v u ( 1 ≤ v u ≤ n v ≠ u ) mean a road connect junctions v u next line contain m integers c1 c2 ... <unknown> ( 1 ≤ ci ≤ n ) — girl 's live junctions next q line describe events chronological order line start integer t ( 1 ≤ t ≤ 2 ) — type event t = 1 line describe event first type three integers v u k ( 1 ≤ v u k ≤ n ) follow — endpoints barney 's path number girls invite otherwise line describe event second type two integers v k ( 1 ≤ v ≤ n 1 ≤ k ≤ 109 ) follow — root subtree value girls ' weight subtree increase event first type print number t t integers g1 <unknown> ... gt one line mean event barney invite t girls whose indices g1 ... gt order best worst accord barney 's <unknown> first sample case : description events :,"['data structures', 'dsu', 'trees']",3000.0
1725/I,"pak chanek a tree call key tree tree consist $$$ n $$$ vertices $$$ n-1 $$$ edge edge tree number $$$ 1 $$$ $$$ n-1 $$$ edge $$$ i $$$ connect vertices $$$ u_i $$$ $$$ v_i $$$ initially edge key tree a weight formally a path length $$$ k $$$ a graph a sequence $$$ [ v_1 e_1 v_2 e_2 <unknown> <unknown> \ldots <unknown> e_k v _ { k+1 } ] $$$ : a <unknown> a path start end vertex a path a graph say simple path use edge note a simple path use vertex cost a simple path a weight graph define maximum weight edge traverse count number distinct undirected weight graph satisfy follow condition : print answer modulo $$$ 998\,244\,353 $$$ two graph consider distinct exist a triple $$$ ( a b c ) $$$ exist edge connect vertices $$$ a $$$ $$$ b $$$ weight $$$ c $$$ one graph , first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — number vertices key tree $$$ i $$$ -th next $$$ n-1 $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ) — edge connect vertices $$$ u_i $$$ $$$ v_i $$$ graph input a tree integer represent number distinct undirected weight graph satisfy condition problem modulo $$$ 998\,244\,353 $$$ follow example a graph satisfy follow assignment edge weight key tree correspond graph example consider a pair vertex indices $$$ ( 1 4 ) $$$","['combinatorics', 'dsu', 'trees']",2800.0
1166/F,a magical land $$$ n $$$ cities <unknown> number $$$ 1 2 \dots n $$$ pair cities connect magical color roads magic <unknown> time new roads may appear two cities vicky <unknown> task perform deliveries pair cities however vicky a beginner complete a delivery move start city destination city a double rainbow a double rainbow a sequence cities $$$ c_1 c_2 \dots c_k $$$ satisfy follow properties : example $$$ k = 5 $$$ road $$$ c_1 $$$ $$$ c_2 $$$ must color road $$$ c_2 $$$ $$$ c_3 $$$ road $$$ c_3 $$$ $$$ c_4 $$$ must color road $$$ c_4 $$$ $$$ <unknown> $$$ vicky a list events chronological order event either a delivery must perform appearance a new road help determine deliveries able complete first line contain four integers $$$ n $$$ $$$ m $$$ $$$ c $$$ $$$ q $$$ ( $$$ 2 \le n \le 100000 $$$ $$$ 1 \le m c q \le 100000 $$$ ) denote respectively number cities number roads initially present number different color roads take number events follow $$$ m $$$ line contain three integers $$$ x $$$ $$$ y $$$ $$$ z $$$ ( $$$ 1 \le x y \le n $$$ $$$ 1 \le z \le c $$$ ) describe initially exist a bidirectional road color $$$ z $$$ cities $$$ x $$$ $$$ y $$$ $$$ q $$$ line follow describe events event one follow two type : guarantee moment one road connect pair cities road connect a city guarantee input contain least one event second type event second type print a single line contain ` ` yes '' ( without quote ) delivery make a single line contain ` ` '' ( without quote ) otherwise follow picture correspond sample first delivery vicky use sequence 1 2 3 4 a double rainbow however complete second delivery reach city $$$ 3 $$$ add road cities $$$ 1 $$$ $$$ 3 $$$ complete a delivery city $$$ 4 $$$ city $$$ 1 $$$ use double rainbow 4 3 1,"['data structures', 'dsu', 'graphs']",2400.0
195/E,orient weight forest acyclic weight digraph vertex one edge go root vertex v orient weight forest a vertex edge go reach vertex v move along edge weight orient forest denote root vertex v root ( v ) depth vertex v sum weight paths pass vertex v root let 's denote depth vertex v depth ( v ) let 's consider process construct a weight direct forest initially forest contain vertices vertices add sequentially one one overall n perform operations add i - th ( i > 0 ) add operation describe a set number ( k v1 x1 v2 x2 ... vk xk ) mean add vertex number i k edge graph : edge vertex root ( v1 ) vertex i weight depth ( v1 ) + x1 edge vertex root ( v2 ) vertex i weight depth ( v2 ) + x2 k = 0 vertex i add graph add edge task like : give operations add vertices calculate sum weight edge forest result application define operations modulo 1000000007 ( 109 + 7 ) first line contain a single integer n ( 1 ≤ n ≤ 105 ) — number operations add a vertex next n line contain descriptions operations i - th line contain description operation add i - th vertex follow format : first number a line integer k ( 0 ≤ k ≤ i - 1 ) follow 2k space - separated integers : v1 x1 v2 x2 ... vk xk ( 1 ≤ vj ≤ i - 1 <unknown> ≤ 109 ) operations give order apply graph guarantee sum k operations exceed 105 also apply operations add vertexes result loop multiple edge print a single number — sum weight edge result graph modulo 1000000007 ( 109 + 7 ) <unknown> first sample : result graph show <unknown> :,"['data structures', 'dsu', 'graphs']",2000.0
209/C,vasya go a walk park park n glades number 1 n. m trail glades trail number 1 m i - th trail connect glades xi yi number connect glades may ( xi = yi ) mean a trail connect a glade also two glades may several non - intersecting trail vasya glade 1 want walk trail park exactly eventually return glade 1 . unfortunately vasya know whether walk possible help vasya determine whether walk possible walk impossible find minimum number trail authorities need add park order make describe walk possible vasya shift one trail another one glades move trail directions vasya start go trail connect glades a b glade a must finish trail glade b. first line contain two integers n m ( 1 ≤ n ≤ 106 ; 0 ≤ m ≤ 106 ) — number glades park number trail park respectively next m line specify trail i - th line specify i - th trail two space - separated number xi yi ( 1 ≤ xi yi ≤ n ) — number glades connect trail print single integer — answer problem vasya 's walk possible without add extra trail print 0 otherwise print minimum number trail authorities need add park order make vasya 's walk possible first test case describe walk possible without build extra trail example let 's first go first trail second one finally third one second test case describe walk impossible without add extra trail make walk possible enough add one trail example glades number one two,"['dsu', 'graphs', 'greedy']",2400.0
1130/C,"alice live a flat planet model a square grid size $$$ n \times n $$$ row columns enumerate $$$ 1 $$$ $$$ n $$$ represent cell intersection row $$$ r $$$ column $$$ c $$$ order pair $$$ ( r c ) $$$ cell grid either land water alice reside land cell $$$ ( r_1 c_1 ) $$$ wish travel land cell $$$ ( r_2 c_2 ) $$$ moment may move one cells adjacent <unknown> — in one four directions ( i.e. , leave right ) unfortunately alice <unknown> <unknown> transportation mean <unknown> ( i.e. walk land ) a result alice 's trip may impossible help alice plan create one tunnel two land cells tunnel allow alice freely travel two endpoints indeed create a tunnel a lot <unknown> : cost create a tunnel cells $$$ ( r_s c_s ) $$$ $$$ ( r_t c_t ) $$$ $$$ ( r_s - r_t ) ^2 + ( c_s - c_t ) ^2 $$$ , task find minimum possible cost create one tunnel alice could travel $$$ ( r_1 c_1 ) $$$ $$$ ( r_2 c_2 ) $$$ tunnel need create cost $$$ 0 $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 50 $$$ ) — width square grid second line contain two space - separated integers $$$ r_1 $$$ $$$ c_1 $$$ ( $$$ 1 \leq r_1 c_1 \leq n $$$ ) — denote cell alice reside third line contain two space - separated integers $$$ r_2 $$$ $$$ c_2 $$$ ( $$$ 1 \leq r_2 c_2 \leq n $$$ ) — denote cell alice wish travel follow $$$ n $$$ line contain a string $$$ n $$$ character $$$ j $$$ -th character $$$ i $$$ -th line ( $$$ 1 \leq i j \leq n $$$ ) 0 $$$ ( i j ) $$$ land 1 $$$ ( i j ) $$$ water guarantee $$$ ( r_1 c_1 ) $$$ $$$ ( r_2 c_2 ) $$$ land print integer minimum possible cost create one tunnel alice could travel $$$ ( r_1 c_1 ) $$$ $$$ ( r_2 c_2 ) $$$ first sample a tunnel cells $$$ ( 1 4 ) $$$ $$$ ( 4 5 ) $$$ create cost $$$ ( 1 - 4 ) ^2 + ( 4 - 5 ) ^2 = 10 $$$ optimal way alice could walk $$$ ( 1 1 ) $$$ $$$ ( 1 4 ) $$$ use tunnel $$$ ( 1 4 ) $$$ $$$ ( 4 5 ) $$$ lastly walk $$$ ( 4 5 ) $$$ $$$ ( 5 5 ) $$$ second sample clearly a tunnel cells $$$ ( 1 3 ) $$$ $$$ ( 3 1 ) $$$ need create cost $$$ ( 1 - 3 ) ^2 + ( 3 - 1 ) ^2 = 8 $$$","['brute force', 'dfs and similar', 'dsu']",1400.0
1702/E,polycarp recently give a set $$$ n $$$ ( number $$$ n $$$ — even ) dominoes domino contain two integers $$$ 1 $$$ $$$ n $$$ divide dominoes two set number dominoes set different ? domino must go exactly one two set example $$$ 4 $$$ dominoes : $$$ \ { 1 4\ } $$$ $$$ \ { 1 3\ } $$$ $$$ \ { 3 2\ } $$$ $$$ \ { 4 2\ } $$$ polycarp able divide two set require way first set include first third dominoes ( $$$ \ { 1 4\ } $$$ $$$ \ { 3 2\ } $$$ ) second set — second fourth ones ( $$$ \ { 1 3\ } $$$ $$$ \ { 4 2\ } $$$ ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case descriptions test case follow first line test case contain a single even integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number dominoes next $$$ n $$$ line contain pair number $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ ) describe number $$$ i $$$ -th domino guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print : print yes case ( example string yes yes yes yes recognize a positive answer ) first test case dominoes divide follow : second test case 's way divide dominoes $$$ 2 $$$ set least one contain repeat number,"['dfs and similar', 'dsu', 'graphs']",1600.0
1292/A,neko # <unknown> get a new maze game pc ! game 's main puzzle a maze form a $$$ 2 \times n $$$ rectangle grid neko 's task lead a <unknown> girl cell $$$ ( 1 1 ) $$$ gate $$$ ( 2 n ) $$$ escape maze girl move cells share a common side however moments game cells may change state : either normal grind lava ( forbid movement cell ) vice versa ( make cell passable ) initially cells grind type hours stream neko finally figure $$$ q $$$ moments : $$$ i $$$ -th moment toggle state cell $$$ ( r_i c_i ) $$$ ( either grind lava vice versa ) know neko wonder $$$ q $$$ moments whether still possible move cell $$$ ( 1 1 ) $$$ cell $$$ ( 2 n ) $$$ without go lava cells although neko a great <unknown> <unknown> still ca n't get quiz problems require large amount brain power help ? first line contain integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \le n \le 100000 $$$ $$$ 1 \le q \le 100000 $$$ ) $$$ i $$$ -th $$$ q $$$ follow line contain two integers $$$ r_i $$$ $$$ c_i $$$ ( $$$ 1 \le r_i \le 2 $$$ $$$ 1 \le c_i \le n $$$ ) denote coordinate cell flip $$$ i $$$ -th moment guarantee cells $$$ ( 1 1 ) $$$ $$$ ( 2 n ) $$$ never appear query list moment possible travel cell $$$ ( 1 1 ) $$$ cell $$$ ( 2 n ) $$$ print ` ` yes '' otherwise print ` ` '' exactly $$$ q $$$ answer one every update print word case ( either lowercase uppercase mix ) 'll crack example test :,"['data structures', 'dsu', 'implementation']",1400.0
1307/F,bessie plan a vacation ! cow - <unknown> $$$ n $$$ cities $$$ n-1 $$$ bidirectional roads connect guarantee one reach city city bessie consider $$$ v $$$ possible vacation plan $$$ i $$$ -th one consist a start city $$$ a_i $$$ destination city $$$ b_i $$$ know $$$ r $$$ cities rest stop bessie get tire easily travel across $$$ k $$$ consecutive roads without rest fact <unknown> rest may travel city multiple time order vacation plan exist a way bessie travel start city destination city ? first line contain three integers $$$ n $$$ $$$ k $$$ $$$ r $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 1 \le k r \le n $$$ ) — number cities maximum number roads bessie will travel a row without rest number rest stop follow $$$ n-1 $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \neq y_i $$$ ) mean city $$$ x_i $$$ city $$$ y_i $$$ connect a road next line contain $$$ r $$$ integers separate space — cities rest stop city appear next line contain $$$ v $$$ ( $$$ 1 \le v \le 200000 $$$ ) — number vacation plan follow $$$ v $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ $$$ a_i \ne b_i $$$ ) — start end city vacation plan bessie reach destination without travel across $$$ k $$$ roads without rest $$$ i $$$ -th vacation plan print yes otherwise print graph first example show rest stop denote red first query bessie visit cities order : $$$ 1 2 3 $$$ second query bessie visit cities order : $$$ 3 2 4 5 $$$ third query bessie travel destination example attempt travel way : $$$ 3 2 4 5 6 $$$ travel $$$ 2 $$$ roads without rest graph second example show,"['dfs and similar', 'dsu', 'trees']",3300.0
1411/C,give a $$$ n \times n $$$ chessboard row columns board number $$$ 1 $$$ $$$ n $$$ cell $$$ ( x y ) $$$ lie intersection column number $$$ x $$$ row number $$$ y $$$ rook a chess piece one turn move number cells vertically horizontally $$$ m $$$ rook ( $$$ m < n $$$ ) place chessboard a way pair rook attack i.e pair rook share a row a column one turn move one rook number cells vertically horizontally additionally n't attack rook movement minimum number move require place rook main diagonal ? main diagonal chessboard cells $$$ ( i i ) $$$ $$$ 1 \le i \le n $$$ first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) description $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ — size chessboard number rook ( $$$ 2 \leq n \leq 100000 $$$ $$$ 1 \leq m < n $$$ ) next $$$ m $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ — position rook $$$ i $$$ -th rook place cell $$$ ( x_i y_i ) $$$ ( $$$ 1 \leq x_i y_i \leq n $$$ ) 's guarantee two rook attack initial placement sum $$$ n $$$ test case exceed $$$ 100000 $$$ $$$ t $$$ test case print a single integer — minimum number move require place rook main diagonal prove always possible possible move first three test case :,"['dfs and similar', 'dsu', 'graphs']",1700.0
36/E,archaeologists find m mysterious paper a pair integers write ancient people know like write index roads walk along « a b » « b a » a b index two different cities <unknown> road also know mysterious paper page two travel <unknown> ( days a new journal write every new journey ) one journey traveler could walk along one road several time one several directions case write a new entry time journal besides archaeologists think direction traveler take a road effect upon entry : entry look like « a b » could refer road a b well road b a. archaeologists want put page right order reconstruct two travel paths unfortunately bad program ’ s come go help ! first input line contain integer m ( 1 ≤ m ≤ 10000 ) follow m line describe one paper description consist two integers a b ( 1 ≤ a b ≤ 10000 a ≠ b ) first line output number l1 length first path i.e amount paper description follow line output l1 space - separated number — index paper describe first path third fourth line output similarly length second path l2 path paths must contain least one road i.e condition l1 > 0 l2 > 0 must meet paper number 1 m accord order appearance input file number output order traveler pass correspond roads answer unique output ’ s impossible find two paths output « -1 » ’ t forget paper use exactly i.e l1 + l2 = m,"['dsu', 'graphs', 'implementation']",2600.0
1468/J,$$$ n $$$ cities $$$ m $$$ bidirectional roads berland $$$ i $$$ -th road connect cities $$$ x_i $$$ $$$ y_i $$$ speed limit $$$ s_i $$$ road network allow everyone get city city berland transport ministry plan a road reform first maintain $$$ m $$$ roads <unknown> $$$ m - ( n - 1 ) $$$ roads demolish a way remain $$$ ( n - 1 ) $$$ roads still allow get city city formally remain roads represent undirected tree secondly speed limit remain roads might change change do sequentially change either increase speed limit road $$$ 1 $$$ decrease $$$ 1 $$$ since change speed limit require a lot work ministry want minimize number change goal ministry a road network $$$ ( n - 1 ) $$$ roads maximum speed limit roads equal exactly $$$ k $$$ assign task calculate minimum number speed limit change perform road network meet requirements example suppose initial map berland look like $$$ k = 7 $$$ : one optimal course action demolish roads $$$ 1 $$$ – $$$ 4 $$$ $$$ 3 $$$ – $$$ 4 $$$ decrease speed limit road $$$ 2 $$$ – $$$ 3 $$$ $$$ 1 $$$ result road network look like : first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \le n \le 200000 $$$ ; $$$ n - 1 \le m \le \min ( 2 \cdot 100000 \frac { n ( n-1 ) } { 2 } ) $$$ ; $$$ 1 \le k \le 1000000000 $$$ ) — number cities number roads require maximum speed limit respectively $$$ m $$$ line follow $$$ i $$$ -th line contain three integers $$$ x_i $$$ $$$ y_i $$$ $$$ s_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ ; $$$ x_i \ne y_i $$$ ; $$$ 1 \le s_i \le 1000000000 $$$ ) — cities connect $$$ i $$$ -th road speed limit respectively roads bidirectional road network test case connect ( possible reach city city travel along road ) pair cities connect one road sum $$$ n $$$ test case exceed $$$ 200000 $$$ similarly sum $$$ m $$$ test case exceed $$$ 200000 $$$ test case print one integer — minimum number change ministry perform maximum speed limit among remain $$$ ( n - 1 ) $$$ roads exactly $$$ k $$$ explanation example test : first test case describe problem statement second test case road network initially look like : ministry demolish roads $$$ 1 $$$ – $$$ 2 $$$ $$$ 3 $$$ – $$$ 2 $$$ $$$ 3 $$$ – $$$ 4 $$$ increase speed limit road $$$ 1 $$$ – $$$ 4 $$$ three time third test case road network already meet requirements fourth test case enough demolish road $$$ 1 $$$ – $$$ 2 $$$ result road network meet requirements,"['dsu', 'graphs', 'greedy']",1800.0
1209/D,legendary farmer john throw a huge party animals world hang house guests hungry <unknown> cow bessie bring snack ! moo ! $$$ n $$$ snack flavor number integers $$$ 1 2 \ldots n $$$ bessie $$$ n $$$ snack one snack flavor every guest exactly two favorite flavor procedure eat snack go follow : help bessie minimize number sad guests line guests optimal way first line contain integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 100000 $$$ $$$ 1 \le k \le 100000 $$$ ) number snack number guests $$$ i $$$ -th follow $$$ k $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ ) favorite snack flavor $$$ i $$$ -th guest output one integer smallest possible number sad guests first example bessie order guests like : $$$ 3 1 2 4 $$$ guest $$$ 3 $$$ go first eat snack $$$ 1 $$$ $$$ 4 $$$ guest $$$ 1 $$$ go eat snack $$$ 2 $$$ snack $$$ 1 $$$ already eat similarly guest $$$ 2 $$$ go eat snack $$$ 3 $$$ snack go guest $$$ 4 $$$ sad second example one optimal order $$$ 2 1 3 5 4 $$$ guests satisfy,"['dfs and similar', 'dsu', 'graphs']",1700.0
1167/C,"social network $$$ n $$$ users communicate $$$ m $$$ group friends let 's analyze process distribute news users initially user $$$ x $$$ receive news source send news friends ( two users friends least one group belong group ) friends continue send news friends , process end pair friends one know news another one n't know user $$$ x $$$ determine number users know news initially user $$$ x $$$ start distribute first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 500000 $$$ ) — number users number group friends respectively $$$ m $$$ line follow describe a group friends $$$ i $$$ -th line begin integer $$$ k_i $$$ ( $$$ 0 \le k_i \le n $$$ ) — number users $$$ i $$$ -th group $$$ k_i $$$ distinct integers follow denote users belong $$$ i $$$ -th group guarantee $$$ \sum \limits _ { i = 1 } ^ { m } k_i \le 500000 $$$ print $$$ n $$$ integers $$$ i $$$ -th integer equal number users know news user $$$ i $$$ start distribute","['dfs and similar', 'dsu', 'graphs']",1400.0
1263/D,one unknown hacker want get admin 's password atforces test system get problems next contest achieve sneak <unknown> 's office steal a piece paper a list $$$ n $$$ passwords — string consist small latin letter hacker go home start prepare hack atforces find system contain passwords steal list system determine <unknown> passwords $$$ a $$$ $$$ b $$$ follow : a password set system equivalent one apply access system user access system example list contain passwords ` ` a '' ` ` b '' ` ` ab '' ` ` d '' passwords ` ` a '' ` ` b '' ` ` ab '' equivalent password ` ` d '' equivalent password list word : one password list admin 's password test system help hacker calculate minimal number passwords require guarantee access system keep mind hacker know password set system first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number passwords list next $$$ n $$$ line contain passwords list – non - empty string $$$ s_i $$$ length $$$ 50 $$$ letter passwords may equal guarantee total length passwords exceed $$$ 1000000 $$$ letter consist lowercase latin letter a single line print minimal number passwords use allow guarantee access system second example hacker need use passwords access system,"['dfs and similar', 'dsu', 'graphs']",1500.0
409/H,a + b often use example <unknown> problem possible show contest platform however scientists observe sometimes problem easy get accept want try ? input contain two integers a b ( 0 ≤ a b ≤ 103 ) separate a single space output sum give integers,"['brute force', 'dsu', 'implementation']",1500.0
1344/B,a <unknown> magnet a magnet one pole either north south n't actually exist since real magnets two pole a program contest problem n't care $$$ n\times m $$$ grid initially may place north magnets south magnets cells allow place many magnets like even multiple cell operation perform follow choose a north magnet a south magnet activate row column occupy different cells north magnet move one unit closer south magnet otherwise occupy cell share a row column nothing change note south magnets <unknown> cell grid color black white let 's consider ways place magnets cells follow condition meet determine possible place magnets condition meet possible find minimum number north magnets require ( requirements number south magnets ) first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1\le n m\le 1000 $$$ ) — number row number columns respectively next $$$ n $$$ line describe color $$$ i $$$ -th line contain a string length $$$ m $$$ $$$ j $$$ -th character denote color cell row $$$ i $$$ column $$$ j $$$ character ` ` # '' ` ` . '' represent black white respectively guarantee string contain character output a single integer minimum possible number north magnets require placement magnets satisfy condition print a single integer $$$ -1 $$$ first test example placement magnets : second test show require placement magnets exist three example placements fail meet requirements first example violate rule $$$ 3 $$$ since move north magnet onto a white square second example violate rule $$$ 2 $$$ since move north magnet bottom - left black square sequence operations third example violate rule $$$ 1 $$$ since south magnet first column third test example placement magnets show require placement magnets fewer north magnets fourth test show require placement magnets exist two example placements fail meet requirements first example violate rule $$$ 1 $$$ since south magnet first row second example violate rule $$$ 1 $$$ $$$ 3 $$$ since south magnet second row move north magnet one unit onto a white square fifth test put south magnet cell north magnets black cells a correct placement,"['dfs and similar', 'dsu', 'graphs']",2000.0
1012/B,innopolis university scientists continue investigate periodic table n·m know elements form a periodic table : a rectangle n row m columns element describe coordinate ( r c ) ( 1 ≤ r ≤ n 1 ≤ c ≤ m ) table recently scientists discover every four different elements table form a rectangle side parallel side table sample three four elements produce a sample fourth element use nuclear fusion elements position ( r1 c1 ) ( r1 c2 ) ( r2 c1 ) r1 ≠ r2 c1 ≠ c2 produce element ( r2 c2 ) sample use fusion waste use future fusions newly <unknown> elements also use future fusions innopolis university scientists already sample q elements want obtain sample n·m elements achieve purchase sample laboratories produce remain elements use arbitrary number nuclear fusions order help find minimal number elements need purchase first line contain three integers n m q ( 1 ≤ n m ≤ 200 000 ; 0 ≤ q ≤ min ( n·m 200 000 ) ) chemical table dimension number elements scientists already follow q line contain two integers ri ci ( 1 ≤ ri ≤ n 1 ≤ ci ≤ m ) describe element scientists already elements input different print minimal number elements purchase example a picture illustrate first picture example describe initial set element sample available black cross represent elements available lab initially second picture describe remain sample obtain red dash circle denote elements purchase <unknown> ( optimal solution minimize number red circle ) blue dash circle elements produce nuclear fusion number order produce test <unknown> use nuclear fusion get element three sample n't need purchase anything test <unknown> use nuclear fusion one row purchase miss elements test <unknown> several possible solutions one illustrate note purchase one element mark red 's still possible <unknown> produce middle element bottom row ( mark 4 ) produce element left - top corner first ( mark 1 ) use future fusions,"['dfs and similar', 'dsu', 'graphs']",1900.0
1290/C,$$$ n $$$ lamps a line number $$$ 1 $$$ $$$ n $$$ one initial state ( $$$ 0 $$$ ) ( $$$ 1 $$$ ) 're give $$$ k $$$ subsets $$$ a_1 \ldots a_k $$$ $$$ \ { 1 2 \dots <unknown> } $$$ intersection three subsets empty word $$$ 1 \le i_1 < i_2 < i_3 \le k $$$ $$$ a _ { i_1 } \cap a _ { i_2 } \cap a _ { i_3 } = <unknown> $$$ one operation choose one $$$ k $$$ subsets switch state lamps guarantee give subsets 's possible make lamps simultaneously use type operation let $$$ m_i $$$ minimum number operations order make $$$ i $$$ first lamps simultaneously note condition upon state lamps ( $$$ i+1 $$$ $$$ n $$$ ) either compute $$$ m_i $$$ $$$ 1 \le i \le n $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 300000 $$$ ) second line contain a binary string length $$$ n $$$ represent initial state lamp ( lamp $$$ i $$$ $$$ s_i = 0 $$$ $$$ s_i = 1 $$$ ) description one $$$ k $$$ subsets follow follow format : first line description contain a single integer $$$ c $$$ ( $$$ 1 \le c \le n $$$ ) — number elements subset second line description contain $$$ c $$$ distinct integers $$$ x_1 \ldots x_c $$$ ( $$$ 1 \le x_i \le n $$$ ) — elements subset guarantee : must output $$$ n $$$ line $$$ i $$$ -th line contain a single integer $$$ m_i $$$ — minimum number operations require make lamps $$$ 1 $$$ $$$ i $$$ simultaneously first example : second example :,"['dfs and similar', 'dsu', 'graphs']",2400.0
959/B,mahmoud want send a message friend ehab language consist n word number 1 n. word mean k group word word group mean mahmoud know i - th word send cost ai word message mahmoud either replace another word mean leave help mahmoud determine minimum cost send message ? cost send message sum cost send every word first line input contain integers n k m ( 1 ≤ k ≤ n ≤ 105 1 ≤ m ≤ 105 ) — number word language number group word number word mahmoud 's message respectively second line contain n string consist lowercase english letter length exceed 20 represent word 's guarantee word distinct third line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) ai cost send i - th word next k line describe group word mean next k line start integer x ( 1 ≤ x ≤ n ) mean x word group follow x integers represent indices word group 's guarantee word appear exactly one group next line contain m space - separated word represent mahmoud 's message word appear list language 's word line contain minimum cost send message replace word ( maybe none ) word mean first sample mahmoud replace word ` ` second '' word ` ` loser '' less cost cost 100 + 1 + 5 + <unknown> second sample mahmoud n't replacement cost 100 + 1 + 5 + <unknown>,"['dsu', 'greedy', 'implementation']",1200.0
91/C,"a ski base plan build walrusland recently however project still construct phase a large land lot choose construction contain n ski junctions number 1 n. initially junctions n't connect way construct process m bidirectional ski roads build roads build one another : first road number 1 build road number 2 , i - th road connect junctions number ai bi track route follow properties : let 's consider ski base a non - empty set roads divide one track exactly one track go along road choose set besides track consist roads choose set ski base n't connect two ski base consider different consist different road set build new road walrusland government want know number variants choose a ski base base subset already build roads government ask help solve give problem first line contain two integers n m ( 2 ≤ n ≤ 105 1 ≤ m ≤ 105 ) represent number junctions number roads correspondingly m line follow description roads order build road describe a pair integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) — number connect junctions could one road a pair junctions print m line : i - th line represent number ways build a ski base end construction road number i. number print modulo 1000000009 ( 109 + 9 ) let us 3 junctions 4 roads junctions already build ( build roads sample ) : 1 3 2 3 2 roads junctions 1 2 . land lot construction look like : land lot construction look follow way : choose a subset roads three ways : first second ways choose one path example 1 - 2 - 3 - 1 . first case choose one path 1 - 2 - 1","['combinatorics', 'dsu', 'graphs']",2300.0
313/E,ilya recently take <unknown> 's recently find two number write m - based notation find number consist exactly n digits ilya immediately start look information number learn number part a <unknown> code one decypher get greatest treasure <unknown> research ilya understand decypher code follow : help ilya find key code first line contain two integers n m ( 1 ≤ n m ≤ 105 m > 1 ) second line contain first find number third line contain second find number number record a sequence digits m - based notation digit integer 0 m - 1 . digits line write order significant digits least significant ones give number contain lead zero print n m - base digits result third number write m - based notation print digits order significant digits least significant ones,"['data structures', 'dsu', 'greedy']",2300.0
1620/E,array integers ( initially empty ) perform $$$ q $$$ query query one two type : find result array perform query first line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 500000 $$$ ) — number query next $$$ q $$$ line contain query ( one per line ) query one two type : 's guarantee least one query first type a single line print $$$ k $$$ integers — result array perform query $$$ k $$$ number query first type first example array change follow : $$$ [ ] $$$ $$$ \rightarrow $$$ $$$ [ 3 ] $$$ $$$ \rightarrow $$$ $$$ [ 3 1 ] $$$ $$$ \rightarrow $$$ $$$ [ 3 2 ] $$$ $$$ \rightarrow $$$ $$$ [ 3 2 2 ] $$$ $$$ \rightarrow $$$ $$$ [ 3 2 2 1 ] $$$ $$$ \rightarrow $$$ $$$ [ 3 2 2 1 2 ] $$$ $$$ \rightarrow $$$ $$$ [ 3 2 2 3 2 ] $$$ second example array change follow : $$$ [ ] $$$ $$$ \rightarrow $$$ $$$ [ 1 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 2 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 2 1 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 2 1 ] $$$ third example array change follow : $$$ [ ] $$$ $$$ \rightarrow $$$ $$$ [ ] $$$ $$$ \rightarrow $$$ $$$ [ 1 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 4 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 4 2 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 4 4 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 3 3 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 3 3 2 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 3 3 7 ] $$$,"['data structures', 'dsu', 'implementation']",1900.0
875/F,a <unknown> kingdom economic crisis rag <unknown> drop fall economic <unknown> <unknown> every day money treasury disappear <unknown> situation king charles <unknown> decide make n sons - princes marry brides big dowry possible search candidates king ask neighbor <unknown> a several <unknown> arrive m <unknown> princesses receive guests <unknown> learn dowry i th princess wi golden coin although action take place middle <unknown> progressive ideas <unknown> <unknown> accord one force a princess marry a prince like therefore princess opportunity choose two princes ready become a wife princes less <unknown> obey father matter choose a <unknown> know value dowry preferences princess charles want play weddings a way total dowry brides sons would great possible time marry princes princesses necessary prince marry one princess vice versa princess marry one prince help king organize <unknown> sons profitable way treasury first line contain two integers n m ( 2 ≤ n ≤ 200 000 1 ≤ m ≤ 200 000 ) — number princes princesses respectively follow m line contain three integers ai bi wi ( 1 ≤ ai bi ≤ n ai ≠ bi 1 ≤ wi ≤ 10 000 ) — number princes i - th princess ready marry value dowry print integer — maximum number gold coin a king get play right weddings,"['dsu', 'graphs', 'greedy']",2500.0
141/E,santa claus assistant elf deliver present make wish come true return north pole find cover snow quite tire decide remove snow roads connect huts north pole n huts connect m roads one go along roads directions elf offer split : santa claus clear wide roads elf <unknown> narrow roads road decide clear : santa claus elf minimize efforts decide clear road fulfill condition : point santa claus assistant elf wonder roads clear ? first input line contain two positive integers n m ( 1 ≤ n ≤ 103 1 ≤ m ≤ 105 ) — number huts number roads follow m line contain a road description : number huts connect — x y ( 1 ≤ x y ≤ n ) person responsible clear road ( ` ` s '' — elf ` ` m '' santa claus ) possible go road directions note one road two huts a road begin end <unknown> print ` ` -1 '' without quote impossible choose roads clear give rule otherwise print first line many roads clear second line print number roads ( roads number 1 order occurrence input ) allow print number roads order number print exactly print number separate space a path call simple huts pairwise different,"['dp', 'dsu', 'graphs']",2300.0
1592/B,"hemose shop friends samez <unknown> <unknown> <unknown> <unknown> germany know hemose friends problem <unknown> clever therefore go <unknown> market germany hemose array $$$ n $$$ integers want samez sort array non - decreasing order since would a easy problem samez hemose allow samez use follow operation : choose indices $$$ i $$$ $$$ j $$$ $$$ 1 \le i j \le n $$$ $$$ \lvert i - j \rvert \geq x $$$ , swap elements $$$ a_i $$$ $$$ a_j $$$ tell samez 's a way sort array non - decreasing order use operation write finite number time ( possibly $$$ 0 $$$ ) ? test contain multiple test case first line contain number test case $$$ t $$$ $$$ ( 1 \leq t \leq 100000 ) $$$ description test case follow first line test case contain two integers $$$ n $$$ $$$ x $$$ $$$ ( 1 \leq x \leq n \leq 100000 ) $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 ... a_n $$$ $$$ ( 1 \leq a_i \leq 1000000000 ) $$$ guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case output a single string samez sort array non - decreasing order use operation write output ` ` yes '' ( without quote ) otherwise output ` ` '' ( without quote ) print letter ` ` yes '' ` ` '' case ( upper lower ) first test case ca n't operations second test case array already sort third test case operations follow : ( $$$ swap ( a_i a_j ) $$$ refer swap elements position $$$ i $$$ $$$ j $$$ )","['dsu', 'math', 'sortings']",1200.0
25/D,berland government decide improve relations neighbor countries first decide build new roads city berland neighbor countries become possible reach others n cities berland neighbor countries total exactly n - 1 two - way roads recent financial crisis berland government <unknown> press money build a new road close exist ones every day possible close one exist road immediately build a new one task determine many days would need rebuild roads city become possible reach others draw a plan closure old roads build new ones first line contain integer n ( 2 ≤ n ≤ 1000 ) — amount cities berland neighbor countries next n - 1 line contain description roads road describe two space - separated integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) — pair cities road connect ca n't one road a pair cities road connect city output answer number t — least amount days need rebuild roads city become possible reach others output t line — plan closure old roads build new ones line describe one day format i j u v — mean road cities i j become close a new road cities u v build cities number 1 . answer unique output,"['dsu', 'graphs', 'trees']",1900.0
111/C,little petya love train spiders petya a board n × m size cell board initially a spider sit one second petya choose a certain action spider <unknown> perform command 5 possible command : stay idle move current cell four side - neighboring cells ( one command four possible directions ) petya give command spider leave field allow spiders pass crawl towards opposite directions spiders crawl simultaneously several spiders may end one cell petya want know maximum possible number spider - free cells one second first line contain two space - separated integers n m ( 1 ≤ n m ≤ 40 n·m ≤ 40 ) — board size first line print maximum number cells without spiders first sample possible answer : sin second sample one possible solutions : s denote command ` ` stay idle '' l r d u denote command ` ` crawl leave '' ` ` crawl right '' ` ` crawl '' ` ` crawl '' correspondingly,"['bitmasks', 'dp', 'dsu']",2100.0
891/C,a connect undirected weight graph g mst ( minimum span tree ) a subgraph g contain g 's vertices a tree sum edge minimum possible give a graph g. run a mst algorithm graph would give one mst cause edge become <unknown> give query query contain a set edge graph g determine whether a mst contain edge first line contain two integers n m ( 2 ≤ n m ≤ 5·105 n - 1 ≤ m ) — number vertices edge graph number query i - th next m line contain three integers ui vi wi ( ui ≠ vi 1 ≤ wi ≤ 5·105 ) — endpoints weight i - th edge one edge two vertices 's guarantee give graph connect next line contain a single integer q ( 1 ≤ q ≤ 5·105 ) — number <unknown> line follow i - th contain i - th query start integer ki ( 1 ≤ ki ≤ n - 1 ) — size edge subset continue ki distinct space - separated integers 1 m — indices edge guarantee sum ki 1 ≤ i ≤ q exceed 5·105 query print ` ` yes '' ( without quote ) 's a mst contain edge ` ` '' ( course without quote ) otherwise graph sample : weight minimum span tree graph 6 . mst edge ( 1 3 4 6 ) contain edge first query answer first query ` ` yes '' edge second query form a cycle length 3 span tree include three edge thus answer ` ` '',"['data structures', 'dsu', 'graphs']",2300.0
95/E,petya love lucky number everybody know positive integers lucky decimal representation n't contain digits 4 7 . example number 47 744 4 lucky 5 17 467 one night petya sleep dream president island country country represent islands connect two - way roads islands road way even islands 's country divide several regions formally island belong exactly one region a path two islands locate region ; path two islands different regions a region lucky amount islands a lucky number a real president petya first decide build a <unknown> palace a lucky number ' fan petya want position palace one lucky regions however possible initially country regions case petya build additional roads different regions thus join find minimum number roads need build create a lucky region first line contain two integers n m ( 1 ≤ n m ≤ 105 ) number islands number roads correspondingly next m line contain road descriptions road define number islands connect : two integers u v ( 1 ≤ u v ≤ n ) roads connect island ; one road a pair islands number line separate exactly one space character 's solution output number ` ` -1 '' ( without quote ) otherwise output minimum number roads r need build get a lucky region,"['dp', 'dsu', 'graphs']",2500.0
660/D,give n point a plane point distinct three lie line find number parallelograms vertices give point first line input contain integer n ( 1 ≤ n ≤ 2000 ) — number point next n line contain two integers ( xi yi ) ( 0 ≤ xi yi ≤ 109 ) — coordinate i - th point print integer c — number parallelograms vertices give point,['geometry'],1900.0
1578/I,"interactive problem goal find a circle a plane shoot ray get distance circle a result interactor three hide integer parameters determine advance test n't know — $$$ x_c $$$ $$$ y_c $$$ $$$ r_c $$$ $$$ ( x_c y_c ) $$$ coordinate circle 's center $$$ r_c $$$ radius absolute value $$$ x_c $$$ $$$ y_c $$$ $$$ r_c $$$ exceed $$$ 100000 $$$ $$$ 1 \leq r_c \leq <unknown> { <unknown> + <unknown> } - 1 $$$ shoot ray extend origin $$$ ( 0,0 ) $$$ go via a point $$$ ( x_q y_q ) $$$ integer coordinate specify ray get a distance ray circle $$$ 0 $$$ ray intersect circle interaction start program print a query standard output finish program find print answer problem query a form ` ` ? $$$ x_q $$$ $$$ y_q $$$ ` ` $$$ x_q $$$ $$$ y_q $$$ integers ( $$$ <unknown> <unknown> \le 1000000 $$$ ; $$$ x_q \ne 0 $$$ $$$ y_q \ne 0 $$$ ) interactor output a line a single floating - point number — distance a query ray a circle precise $$$ 10^ { <unknown> } $$$ absolute value program make next query read output , allow $$$ 60 $$$ query end interaction print answer line ` ` ! $$$ x_c $$$ $$$ y_c $$$ $$$ r_c $$$ ` ` flush output exit note output interactor actually round 10 - th digit a decimal point <unknown> - <unknown> solution <unknown> make sure also perform correspond round",['geometry'],3300.0
1571/H,"ira develop a computer game game feature randomize generation difficulty level achieve randomize difficulty enemies level randomly replace stronger ones describe level game look let 's introduce a coordinate system a way $$$ ox $$$ axis go leave right $$$ oy $$$ axis go bottom top a level a rectangle opposite corner point $$$ ( 0 0 ) $$$ $$$ ( a b ) $$$ enemy 's position a point rectangle , ira implement one type enemy game two different versions — basic upgrade versions enemies ira implement fire laser ray several directions : laser ray pass enemies block border level ( side rectangle denote level ) enemies <unknown> lasers level ira work $$$ n $$$ enemies $$$ i $$$ -th enemy point $$$ ( x_i y_i ) $$$ a probability $$$ p_i $$$ upgrade ( 's either upgrade probability $$$ p_i $$$ basic probability $$$ 1 - p_i $$$ ) events independent ira want estimate expect difficulty consider a good way evaluate difficulty level count number part level divide laser ray , want calculate expect number part help evaluation level ! first line contain three integers $$$ n $$$ $$$ a $$$ $$$ b $$$ ( $$$ 1 \le n \le 100 $$$ ; $$$ 2 \le a b \le 100 $$$ ) — number enemies level dimension level $$$ n $$$ line follow $$$ i $$$ -th contain three integers $$$ x_i $$$ $$$ y_i $$$ $$$ p'_i $$$ ( $$$ 1 \le x_i \le a - 1 $$$ ; $$$ 1 \le y_i \le b - 1 $$$ ; $$$ 1 \le p'_i \le <unknown> $$$ ) mean $$$ i $$$ -th enemy locate $$$ ( x_i y_i ) $$$ a probability $$$ \frac { p'_i } { 1000000 } $$$ upgrade two enemies locate point print one integer — expect number part lasers divide level take modulo $$$ 998244353 $$$ ( i. e. let expect number part $$$ \frac { x } { y } $$$ irreducible fraction ; print $$$ x \cdot y^ { -1 } \bmod 998244353 $$$ $$$ y^ { -1 } $$$ a number $$$ y \cdot y^ { -1 } \bmod 998244353 = 1 $$$ ) explanation first example : probability $$$ \frac { 1 } { 2 } $$$ enemy upgrade level look like ( $$$ 4 $$$ part ) : probability $$$ \frac { 1 } { 2 } $$$ enemy upgrade level look like ( $$$ 8 $$$ part ) : expect number part $$$ 4 \cdot \frac { 1 } { 2 } + 8 \cdot \frac { 1 } { 2 } = 6 $$$",['geometry'],2900.0
107/E,"night <unknown> ceremony <unknown> students <unknown> university <unknown> ( guc ) play dart 's real dart board available <unknown> members guc upper management use , n rectangular photos place wall overlap arbitrary even coincide photos necessarily place horizontally vertically could also rotate pin wall score one dart throw simply number photos dart go fatma make a throw score record remember make least one photo assume probability distribution throw equal across whole wall would expectation fatma 's score ? first line input contain integer n ( 1 ≤ n ≤ 500 ) — number photos wall follow n line describe photos contain 8 single - space - separated integers ( coordinate 4 vertices ) : x1 y1 x2 y2 x3 y3 <unknown> <unknown> photo a rectangle a nonzero area coordinate integers exceed 104 absolute value coordinate rectangle give either clockwise counterclockwise order print expect score throw answer accept absolute relative error exceed 10 - 6",['geometry'],2700.0
630/P,decide city distinguish <unknown> local company award form star cover gold one side order star necessary estimate order cost depend area gold - plate write a program calculate area a star a ` ` star '' figure n ≥ 5 corner n a prime number construct follow way circle radius r n point select distance adjacent ones equal every point connect a segment two maximally distant point areas bound segment part figure part line input contain two integers n ( 5 ≤ n < 109 n prime ) r ( 1 ≤ r ≤ 109 ) — number star corner radius <unknown> correspondingly output one number — star area relative error answer greater 10 - 7,['geometry'],2100.0
605/C,"mikhail <unknown> dream two things : become a cool programmer buy a flat moscow become a cool programmer need least p experience point a desire flat moscow cost q dollars mikhail determine follow dream register a freelance <unknown> <unknown> work n distinct project mikhail already evaluate <unknown> i - th project increase experience ai per day bring bi dollars per day freelance work imply <unknown> work hours mikhail free stop work one project time start work another project , receive respective share experience money mikhail try become a cool programmer able work one project moment time find real value equal minimum number days mikhail need make dream come true example suppose mikhail suggest work three project a1 = 6 b1 = 2 a2 = 1 b2 = 3 a3 = 2 b3 = 6 . also p = 20 q = 20 . order achieve aim mikhail work 2.5 days first third project indeed <unknown> + <unknown> + <unknown> = 6·2.5 + <unknown> + 2·2.5 = 20 <unknown> + <unknown> + <unknown> = 2·2.5 + <unknown> + 6·2.5 = 20 . first line input contain three integers n p q ( 1 ≤ n ≤ 100 000 1 ≤ p q ≤ 1 000 000 ) — number project require number experience money next n line contain two integers ai bi ( 1 ≤ ai bi ≤ 1 000 000 ) — daily increase experience daily income work i - th project print a real value — minimum number days mikhail need get require amount experience money answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer a answer jury b. checker program consider answer correct , first sample correspond example problem statement",['geometry'],2400.0
68/E,little petya prepare first contact alien know alien spaceships shape non - degenerate triangles exactly 4 ship land platform a ship make 3 special columns locate point a cartesian plane 3 point form a triangle equal ship respect rotations <unknown> ( parallel shift along vector ) <unknown> ( <unknown> along edge ) ship overlap land column use land one ship example two equal ship n't need build 6 columns land ship 3 enough petya want know minimum number columns enough land ship 4 line contain 6 integers x1 y1 x2 y2 x3 y3 ( 0 ≤ x1 y1 x2 y2 x3 y3 ≤ 20 ) represent 3 point describe shape 4 ship guarantee 3 point line represent a non - degenerate triangle first line contain minimum number columns enough land spaceships first test case columns put point : ( 0 0 ) ( 1 0 ) ( 3 0 ) ( 1 2 ) note second ship land use last 3 columns second test case follow point choose : ( 0 0 ) ( 0 1 ) ( 1 0 ) ( 0 2 ) ( 2 0 ) ( 0 5 ) ( 5 0 ) ( 0 17 ) ( 17 0 ) impossible use less 9 columns,['geometry'],2900.0
46/G,happen time great berland empire emperor dream messenger gods order build a temple whose base would a convex polygon n angle next morning emperor give command build a temple whose base a regular polygon n angle temple build soon empire shake <unknown> <unknown> <unknown> <unknown> destroy temple emperor understand somehow cause <unknown> gods fall people order bring wise man wise man appear emperor <unknown> dream ask ` ` <unknown> wisest among wisest tell could i infuriate gods ? ` ` ` ` lord '' wise man answer ` ` far i judge gods angry haste fulfill order n't listen end message '' indeed follow night messenger appear <unknown> emperor choose <unknown> shape temple ` ` shape perfect a regular polygon ! ? '' <unknown> emperor dream messenger give a complete <unknown> reply <unknown> <unknown> go make temple 's plan note polygon simple ( a border without self - intersections overlap ) convex however acceptable three consecutive vertices lie line first line contain single number n ( 3 ≤ n ≤ 10000 ) print ` ` yes '' ( without quote ) first line possible build a polygon possess need qualities next n line print integer coordinate polygon vertices order would pass counter clockwise absolute value coordinate n't exceed 109 . two vertices coincide permit print possible solutions print ` ` '' build polygon impossible,['geometry'],2500.0
54/E,one winter even hedgehog <unknown> home <unknown> <unknown> click tv channel stumble issue « <unknown> » hedgehog change channel a sudden stop advertisement a new <unknown> <unknown> actually a vacuum cleaner advertise call <unknown> vacuum n't even need a human operate clean ! vacuum cleaner move around flat : move direction hit obstacle automatically choose a new direction sooner later vacuum cleaner travel room clean remember much time hedgehog spend every time clean ( surely less a half day ) get eager buy wonder however hedgehog quickly understand cleaner least one weak point : wo n't clean well room 's corner often wo n't able reach corner due shape estimate <unknown> <unknown> practice hedgehog ask write correspond program give cleaner 's shape top view consider case vacuum cleaner represent a convex polygon room infinitely large rectangle consider one corner room want find a rotation vacuum cleaner push corner leave minimum possible area corner uncover first line contain integer n represent number vertices vacuum cleaner 's polygon ( 3 ≤ n ≤ <unknown> ) follow n line contain two number — coordinate a vertex polygon coordinate integer absolute value exceed 106 . guarantee give polygon nondegenerate convex ( three point lie line ) polygon vertices give a clockwise counter - clockwise direction print minimum possible uncover area answer accept within 10 - 6 absolute relative error correct answer,['geometry'],2700.0
420/E,a coder sit code day sometimes a good idea rise desk a rest small talk <unknown> even play coders f company favorite ball game let 's imagine game plane a cartesian coordinate system point ( 0 0 ) contain player choose arbitrary direction throw a ball direction ball hit plane distance d player 's original position continue fly direction ball hit plane first time fly hit plane distance <unknown> player 's original position ( continue fly choose direction hit plane d units ) coders f company strong ball fly infinitely far away plane n circle paint a ball hit plane hit a circle paint plane ( include border ) player get one point ball hit multiple circle get one point ( ball hit circle x time move player also get x point ) count maximum number point a player get throw a ball arbitrary direction note direction may real <unknown> first line contain two space - separated integers — n и d ( 1 ≤ n ≤ <unknown> ; 5 ≤ d ≤ 10 ) next n line contain circle ' description i - th line contain three space - separated integers xi yi ri ( - 10000 ≤ xi yi ≤ 10000 ; 1 ≤ r ≤ 50 ) ( xi yi ri ) coordinate center radius circle correspondingly point ( 0 0 ) inside border circle print a single integer — maximum number point get,['geometry'],2600.0
409/G,first line contain a single integer n ( 1 ≤ n ≤ 1000 ) — number point a plane next n line contain two real coordinate xi yi point specify exactly 2 fractional digits coordinate - 1000 1000 inclusive output a single real number <unknown> — answer problem statement absolute relative error answer 10 - 2,['geometry'],2200.0
388/E,a meteor <unknown> sky n meteors sky view a 2d <unknown> plane meteor point plane fox ciel look sky find orbit meteor a straight line meteor a constant velocity ciel want know : maximum number meteors pair meet position a certain time ? note time limit also negative meteors never <unknown> appear position time first line contain integer n ( 1 ≤ n ≤ 1000 ) next n line contain six integers : t1 x1 y1 t2 x2 y2 — description a meteor 's orbit : time t1 current meteor locate point ( x1 y1 ) time t2 meteor locate point ( x2 y2 ) ( - 106 ≤ t1 x1 y1 t2 x2 y2 ≤ 106 ; t1 ≠ t2 ) two meteors always position time print a single integer — maximum number meteors pair meet position a certain time example 1 meteor 1 2 meet <unknown> ( 0 0 ) example 2 meteor 1 2 meet t=1 ( 1 0 ) meteor 1 3 meet t=0 ( 0 0 ) meteor 2 3 meet t=2 ( 0 1 ) example 3 two meteor meet example 4 1 meteor velocity zero browser n't support <unknown> <unknown> please see <unknown> version : http : //assets.codeforces.com / images/388e / <unknown> : //assets.codeforces.com / images/388e / <unknown> : //assets.codeforces.com / images/388e / <unknown> : //assets.codeforces.com / images/388e / <unknown>,['geometry'],3100.0
342/C,"a girl name xenia a cupboard look like arc ahead arc make a <unknown> radius r ( cupboard 's top ) two wall height h ( cupboard 's side ) cupboard 's depth r , look like a rectangle base r height h + r side figure show cupboard look like ( front view leave side view right ) xenia get lot balloon birthday girl hat mess want store balloon cupboard luckily balloon a sphere radius help xenia calculate maximum number balloon put cupboard say a balloon cupboard ca n't see part balloon leave right view balloon cupboard touch allow <unknown> balloon <unknown> way assume cupboard 's wall negligibly <unknown> single line contain two integers r h ( 1 ≤ r h ≤ 107 ) print a single integer — maximum number balloon xenia put cupboard",['geometry'],1900.0
227/A,trouble come <unknown> land : a three - <unknown> dragon gorynych arrive dragon settle point c begin <unknown> residents surround villages a brave hero decide put end dragon move point a fight gorynych hero ride point a along a straight road meet point b way hero know land every pair roads true either parallel lie a straight line perpendicular also know well point b c connect a road hero must either turn 90 degrees leave continue rid straight ahead turn 90 degrees right forget point c locate fortunately a brave falcon fly right see three point sky hero ask way go get dragon 's lair get falcon help hero tell get point c : turn leave go straight turn right moment hero believe stand point b turn back point a. first input line contain two space - separated integers xa ya ( <unknown> <unknown> ≤ 109 ) — coordinate point a. second line contain coordinate point b form third line contain coordinate point c. guarantee point pairwise different also guarantee either point b lie segment ac angle abc right print a single line a hero must turn leave print ` ` leave '' ( without quote ) ; must go straight ahead print ` ` towards '' ( without quote ) ; turn right print ` ` right '' ( without quote ) picture first sample : red color show point a b c. blue arrow show hero 's direction green color show hero 's <unknown> picture second sample :,['geometry'],1300.0
199/B,a <unknown> <unknown> artist sasha draw <unknown> <unknown> decide paint a picture <unknown> ` ` special olympics '' <unknown> think regular olympic game five ring special ones exactly two ring fine let us remind a ring a region locate two concentric circle radii r r ( r < r ) radii call internal external respectively concentric circle circle center locate point soon a white canvas consider infinite cartesian plane two perfect ring paint solid black paint sasha <unknown> ring could different radii size intersect overlap way know one thing sure : center pair ring sasha get tire fell a deep sleep a girl call <unknown> come room want cut a circle sake good memories make circle beautiful decide cut along contour 'll consider a contour a continuous close line <unknown> one color another ( see note clarification ) contour take form a circle result cut a circle <unknown> want girl 's <unknown> mathematical mind rest : many ways cut a circle canvas ? input contain two line line four space - separated integers xi yi ri ri describe i - th ring ; xi yi coordinate ring 's center ri ri internal external radii ring correspondingly ( - 100 ≤ xi yi ≤ 100 ; 1 ≤ ri < ri ≤ 100 ) guarantee center ring <unknown> a single integer — number ways cut a circle canvas figure test sample give possible cut mark red dot line,['geometry'],1900.0
190/B,", berland war <unknown> enemy flatland vasya accountant assign fulfil <unknown> nation right situation berland <unknown> — cities surround ! <unknown> flatlanders stand border circle circle ' center surround cities moment point flatland ring begin move quickly direction city — 's strategy flatlanders usually follow <unknown> cities berlanders sure <unknown> enemy 's attack learn exact time attack start need construct a radar would register movement distance r thus <unknown> a radar point least one point enemy ring detect range ( a distance r ) radar immediately inform enemy 's attack due <unknown> technologies place a radar point without problems problem berlanders time make one radar besides larger detection radius ( r ) radar cost 's vasya 's task ( task ) find minimum possible detection radius radar word task find minimum radius r ( r ≥ 0 ) a radar radius r instal point register start movements flatland ring point problem consider cities <unknown> point attack enemy ring - circle center cities radar 's detection range — a disk ( include border ) center point radar place input file consist two line line represent city flatland ring surround three space - separated integers xi yi ri ( |xi| |yi| ≤ 104 ; 1 ≤ ri ≤ 104 ) — city 's coordinate distance city flatlanders correspondingly guarantee cities locate different point print a single real number — minimum detection radius describe radar answer consider correct absolute relative error exceed 10 - 6 . figure show answer first sample sample best decision put radar point coordinate ( 2 0 ) figure show answer second sample sample best decision put radar point coordinate ( 0 0 )",['geometry'],1800.0
142/E,"greg dwarf really busy recently excavations neverland mountain however well - known reason ( probably remember a unusual dwarf stand <unknown> ) greg excavate night morning crypt first sun ray strike 's want find shortest route <unknown> point crypt greg <unknown> codeforces participants successfully solve problem transport coffin a crypt , miraculous way greg appear <unknown> ask help a highly <unknown> manner usual n't feel like turn think formalize task follow : neverland mountain a regular shape end a rather <unknown> <unknown> represent a cone whose base radius equal r whose height equal h. <unknown> greg busy excavate crypt represent two point cone 's surface ' ve get find distance point cone 's surface task complicate fact mountain 's base grind level even everything mountain <unknown> gnome ( one may wonder whether ' ve look stuff greg ... ) , one consider shortest way pass along side surface also along cone 's base ( a specific case point lie cone 's base — see first sample test ) greg satisfy problem solution represent length shortest path two point — find way pretty well give two hours solve problem time <unknown> ! first input line contain space - separated integers r h ( 1 ≤ r h ≤ 1000 ) — base radius cone height correspondingly second third line contain coordinate two point cone surface group three space - separated real number coordinate point give systems coordinate origin coordinate locate centre cone 's base rotation axis match <unknown> axis coordinate system vertex cone locate point ( 0 0 h ) base cone a circle whose center point ( 0 0 0 ) lie <unknown> plane point cone surface a non - negative coordinate z. guarantee distance point cone surface exceed 10 - 12 . real number input 16 digits decimal point print length shortest path point give input absolute relative error exceed 10 - 6",['geometry'],3000.0
127/A,mr . scrooge a busy man decide count time waste sort useless stuff evaluate lose profit already count time waste sleep eat mr . scrooge want count time waste sign paper mr . scrooge 's signature represent a polyline a1a2 ... scrooge sign like : first place a pen point a1 draw a segment point a1 point a2 draw a segment point a2 point a3 point stop sign take pen paper result line intersect partially repeat scrooge pay attention never change sign style scrooge make signature never take pen paper write speed constant — 50 millimeters per second scrooge sign exactly k paper throughout life <unknown> look find total time scrooge waste sign paper first line contain two integers n k ( 2 ≤ n ≤ 100 1 ≤ k ≤ 1000 ) follow n line contain coordinate polyline 's endpoints i - th one contain coordinate point ai — integers xi yi separate a space point ai different absolute value coordinate exceed 20 . coordinate measure millimeters print one real number — total time <unknown> waste sign paper second absolute relative error exceed 10 - 6,['geometry'],900.0
119/E,year 3000 travel around parallel <unknown> become a routine thing however one take consideration travel like highly dangerous never know beforehand 're gon na get ... little vasya instance find a game reality successfully complete level a weird game get back game reality a three - dimensional space n point give game m level begin i - th level player position plane qi pass origin level vasya use special robots construct activate n powerful energy spheres equal radius center give point player choose radius spheres player spend r units money construct spheres whose radius equal r ( consequently one construct spheres whose radius equal zero free ) besides level a player choose point space release a laser ray perpendicular plane qi ( action cost nothing ) ray either direct towards plane plane spheres share least one point ray immediately activate level consider complete player manage activate spheres note center spheres m level spheres remain : player construct <unknown> new level help vasya find minimum sum money enough complete level first line contain two integers n m ( 1 ≤ n ≤ <unknown> 1 ≤ m ≤ 100 ) — number energetic spheres number level game correspondingly follow n line contain three integers xi yi zi ( 0 ≤ xi yi zi ≤ 104 ) — coordinate center i - th sphere assume point change position throughout game follow m line contain three integers ai bi ci ( 0 ≤ ai bi ci ≤ 100 ai2 + <unknown> + <unknown> > 0 ) number coefficients equation plane qi ( aix + biy + <unknown> = 0 ) player position begin i - th level print m number one per line : i - th line contain minimum sum money need complete i - th level absolute relative error exceed 10 - 6,['geometry'],2400.0
106/E,galaxy contain n planets many different live creatures inhabit planet creature get trouble ! space rescuers know perfectly well always ready help anyone really need help need call space rescuers plan build largest history galaxy rescue station ; however rescue station 's location yet determine case real <unknown> rescuers want find a point galaxy would possible get remotest planet minimum possible time word rescuers need point space distance planet remotest minimal ( compare point possible point space ) unfortunately rescuers ca n't sole problem planets quite <unknown> consider point euclidean three - dimensional space distance point ( xi yi zi ) ( xj yj <unknown> ) calculate formula rescue station position point space also coincide planet galaxy danger ! save space rescuers find require point first line input file contain integer n — number planets ( 1 ≤ n ≤ 100 ) follow n line contain information planets i - th line contain three integers xi yi zi — coordinate i - th planet ( - 104 ≤ xi yi zi ≤ 104 1 ≤ i ≤ n ) two planets coincide print first line output file three space - separated real number x0 y0 <unknown> — coordinate future base several solutions allow print answer accept distance point remotest planet differ <unknown> ' variant 10 - 6 absolute relative value,['geometry'],2100.0
98/C,a unusual citizen live a far away kingdom — dwarf <unknown> however unusual name <unknown> thing ( besides everyone long ago get use call simply dwarf greg ) special dwarf greg — 's live 200 years ; besides live a crypt abandon <unknown> nobody ever see <unknown> moreover nobody ever see greg buy food 's nobody get particularly surprise <unknown> dragon 's <unknown> death cattle continue disappear field people <unknown> long sure harmless dragon never responsible disappear cattle ( consider dragon use <unknown> <unknown> view ) even 's worst part whole story worst part <unknown> several minutes ago dwarf greg <unknown> way get inside house ask help solve a problem point a short time ago greg decide order a new coffin ( know peculiar character surprise ) problem : a long directions l - <unknown> corridor lead greg 's crypt ca n't drag coffin corridor 's ask help ' ve formalize task a plane like : let corridor 's width turn equal a b correspondingly ( see picture ) corridor turn directly a right angle coffin a rectangle whose length width equal l w ( l ≥ w ) correspondingly dwarf greg already determine coffin 's length ( l ) base height ; task determine coffin 's maximally possible width ( w ) bring crypt besides due large mass ( <unknown> marble ! ) coffin <unknown> rotate wheel ; therefore impossible lift grind however arbitrary move rotations coffin plane become possible coffin may rotate arbitrarily drag crypt move corridor greg promise help <unknown> <unknown> ( i wonder ? ) n't well ... trust n't want know happen n't help ... first line contain three space - separated integers a b l problem 's statement ( 1 ≤ a b l ≤ 104 ) print maximally possible width a coffin absolute relative error 10 - 7 . a coffin give length positive width ( coffin would meet condition problem 's statement ) exist print ` ` poor head = ( ` ` ( without quote ) guarantee answer positive less 10 - 7 . hack also check meet condition first example answer restrict coffin 's length ( remember — coffin 's <unknown> larger 's length ) second example possible drag coffin corridor thank rotate wheel : firstly drag forward one side <unknown> wall move forward adjacent side <unknown> initial movement direction ( remember — arbitrary move rotations coffin possible ),['geometry'],2500.0
89/D,upon a time galaxy far far away ... darth <unknown> find location a rebel ' base go destroy base ( whole planet base locate ) use death star rebel learn death star come decide use new secret <unknown> — space mine let 's describe a space mine 's build space mine shape like a ball ( 'll call mine body ) a certain radius r center point <unknown> several spike <unknown> center spike represent a segment connect center mine point p ( transport long - <unknown> mine <unknown> ) <unknown> length segment connect o p. convenient describe point p a vector p p = o + p. death star shape like a ball radius r ( r exceed mine 's radius ) move a constant speed along v vector speed equal |v| moment rebel notice star death locate point a. rebel locate n space mine along death star 's way may regard mine idle death star know mine ' existence notice n't change direction movement soon star death touch mine ( body one spike ) mine <unknown> destroy star death a touch situation a point space belong mine death star consider death star destroy move infinitely long time without touch mine help rebel determine whether succeed destroy death star use space mine succeed determine moment time happen ( start moment death star notice ) first input data line contain 7 integers ax ay <unknown> vx vy vz r. death star 's initial position direction movement radius ( - 10 ≤ vx vy vz ≤ 10 |v| > 0 0 < r ≤ 100 ) second line contain integer n number mine ( 1 ≤ n ≤ 100 ) follow n data block i - th describe i - th mine first line block contain 5 integers <unknown> <unknown> <unknown> ri mi coordinate mine centre radius body number spike ( 0 < ri < 100 0 ≤ mi ≤ 10 ) follow mi line describe spike i - th mine j - th describe i - th spike contain 3 integers <unknown> <unknown> <unknown> — coordinate vector give spike direct ( ) coordinate mine ' center center death star integers absolute value exceed 10000 . guarantee r > ri 1 ≤ i ≤ n. mine i ≠ j follow inequality fulfil : initially death star mine common point rebel succeed stop death star use space mine print time moment death star notice <unknown> death star touch a mine print ` ` -1 '' ( without quote ) answer absolute relative error 10 - 6 acceptable,['geometry'],2500.0
87/E,a long time ago somewhere depths america exist a powerful tribe <unknown> great leader pinnie - the - wooh tribe conquer three <unknown> cities pinnie - the - wooh grow concern : control conquer territories 's <unknown> priests <unknown> god mogohu - rea help priests convey god 's : control three cities put idol mogohu - rea — create a religious field cities however idol powerful easily drive people around mad unless balance exactly three sacrifice altars place one city balance idol altars place center mass system three point coincide idol count center mass consider altars mass pinnie - the - wooh think put idol a list hill suitable put idol help identify put idol without <unknown> <unknown> brain cities ' population religious field city a shape a convex polygon three vertexes lie a straight line cities intersect <unknown> attach city a special ceremony besides must situate city 's territory ( possibly border ) thus may several altars a city 's territory exactly one attach city altars idol hill point plane may coincide hill take consideration independently altars ' location different hill may also different first follow descriptions three cities divide empty line descriptions follow format : first line contain integer n represent number polygon 's vertexes ( 3 ≤ n ≤ 5·104 ) next n line contain two integers xi yi coordinate polygon 's i - th vertex counterclockwise order cities ' description follow integer m ( 1 ≤ m ≤ 105 ) represent number hill next m line contain two integers xj yj coordinate j - th hill coordinate input data exceed <unknown> absolute value hill print a single line ` ` yes '' ( without quote ) ` ` '' ( without quote ) depend whether three sacrifice altars put balance idol hill ( 2 1 ) altars place point ( 1 0 ) ( 7 5 ) ( - 2 - 2 ) hill ( 1 1 ) — point ( 0 0 ) ( 6 4 ) ( - 3 - 1 ) many group three point trick suitable point hill,['geometry'],2600.0
82/E,consider a house plan let house represent infinite horizontal strip define inequality - h ≤ y ≤ h. strictly outside house two light source point ( 0 f ) ( 0 - f ) windows locate wall windows represent segment line y = h y = - h. also windows arrange <unknown> line y = 0 . task find area floor home light source light first line input file contain three integers n h f ( 1 ≤ n ≤ 500 1 ≤ h ≤ 10 h < f ≤ 1000 ) next n line contain two integers li ri ( - 5000 ≤ li < ri ≤ 5000 ) entry indicate two segment endpoints first segment ( li h ) - ( ri h ) endpoints second segment ( li - h ) - ( ri - h ) segment describe location windows number line space - separated guarantee two distinct segment common point print single real number — area illuminate part floor absolute relative error 10 - 4 . second sample test show figure green area desire area illuminate part floor <unknown> segment indicate windows,['geometry'],2600.0
280/A,give two rectangles a plane center rectangles locate origin coordinate ( mean center rectangle 's symmetry ) first rectangle 's side parallel coordinate ax : length side parallel ox axis equal w length side parallel oy axis equal h. second rectangle obtain rotate first rectangle relative origin coordinate angle α . task find area region belong give rectangles region <unknown> picture first line contain three integers w h α ( 1 ≤ w h ≤ 106 ; 0 ≤ α ≤ 180 ) angle α give degrees a single line print a real number — area region belong give rectangles answer consider correct relative absolute error n't exceed 10 - 6 . second sample draw picture,['geometry'],2000.0
154/E,"first ship earth <unknown> land mar colonists manage build n necessary structure surface planet ( regard a plane construction regard point ) one day <unknown> record suspicious activity <unknown> colony decide use protective force field generate system protect colony possible trouble system work follow : surface contain a number generators field ( also consider point ) active range generator a circle radius r center location generator ( boundary circle also include range ) system activate stretch protective force field part surface within area generators ' activity , protect part intersection generators ' active range number generators available colonists limit system field generation consume a lot energy precisely energy consumption depend number generators directly proportional area protect field also necessary exist build locate within protect area determine smallest possible area protect part surface contain build first line contain two integers n r ( 1 ≤ n ≤ 105 1 ≤ r ≤ 50000 ) — number build active range generators correspondingly next n line contain build ' coordinate i + 1 - th ( 1 ≤ i ≤ n ) line contain two real number three digits decimal point xi yi ( |xi| |yi| ≤ 50000 ) — coordinate i - th build guarantee two build locate point two different build locate closer 1 . guarantee exist a circle radius r contain build print single real number — minimum area protect part contain build answer accept absolute relative error n't exceed 10 - 4 . first sample give radius equal radius circle <unknown> around give point 's circle correspond seek area answer <unknown> second sample area <unknown> coincide square vertexes give point area third sample show picture",['geometry'],3000.0
2/C,olympic game <unknown> full swing everyone <unknown> : <unknown> compete <unknown> sport <unknown> compete convenient position give a run <unknown> today main sport events take place three round stadiums commentator 's <unknown> choose best point observation say point three stadiums observe sport competitions importance stadiums observe angle number point meet condition one point maximum angle observation prefer would please help famous berland commentator g. <unknown> find best point observation note stadiums hide commentator easily see one stadium input data consist three line describe position one stadium line format x y r ( x y ) coordinate stadium 's center ( - 103 ≤ x y ≤ 103 ) r ( 1 ≤ r ≤ 103 ) radius number input data integer stadiums common point center line print coordinate require point five digits decimal point answer meet condition program n't print anything output data leave blank,['geometry'],2600.0
67/E,"town aalam - aara ( mean light earth ) previously crime criminals time progress sin start <unknown> <unknown> <unknown> people seek solution problem <unknown> find long corrupt part population keep away <unknown> part <unknown> could stop , try set a compound keep corrupt people ensure criminals n't escape compound a watchtower need set watch since people aalam - aara n't rich meet a <unknown> rich town agree sell a land - plot already a straight line fence ab along a point set put a watchtower task help find number point fence tower put criminals watch one watchtower set a criminal watchable watchtower line <unknown> watchtower n't cross plot - <unknown> point tower i.e show figure 1 point x y c a visible point b point e d assume land plot shape a polygon coordinate ax setup fence ab parallel x - axis point watchtower set integer point line example give figure 2 watchtower setup five integer point ab i.e ( 4 8 ) ( 5 8 ) ( 6 8 ) ( 7 8 ) ( 8 8 ) assume three consecutive point collinear corner point a b lie towards side fence ab give polygon n't contain self - intersections first line test case consist number vertices n ( 3 ≤ n ≤ 1000 ) next n line contain coordinate vertices clockwise order polygon i - th line integers xi yi ( 0 ≤ xi yi ≤ 106 ) separate a space endpoints fence ab first two point ( x1 y1 ) ( x2 y2 ) output consist a single line contain number point watchtower set figure 2 show first test case point figure watchable point fence ab since ab 5 integer coordinate answer 5 . case two fence cd de completely visible thus answer 0",['geometry'],2500.0
50/C,happy farm 5 <unknown> decide invent mechanism cow graze cow game slow move <unknown> even consider stand still however <unknown> always <unknown> a young player vasya decide make shepherd run round cow along one close path important cow stay strictly inside area limit path otherwise cow sooner later eat absolutely sure cow ' safety vasya want path <unknown> time minimum new game launch different devices include mobile phone 's developers decide quit use arithmetics float decimal point use arithmetics integers cow shepherd game represent point plane integer coordinate play time model turn every turn shepherd either stay stand step one eight directions : horizontally vertically diagonally coordinate always remain integer length a horizontal vertical step equal 1 length a diagonal step equal cow move minimize number move shepherd need run round whole herd first line contain integer n represent number cow herd ( 1 ≤ n ≤ 105 ) next n line contain two integers xi yi represent coordinate one cow ( |xi| |yi| ≤ 106 ) several cow stand one point print single number — minimum number move seek path picture example test : coordinate grid paint grey coordinate ax paint black cow paint red seek route paint green,['geometry'],2000.0
77/E,"ever taste martian food ? well , signature dish serve a completely black plate radius r flat a <unknown> first put a perfectly circular portion golden honduras plate radius r locate close edge plate possible stay entirely within plate i. e. golden honduras touch edge plate inside believe <unknown> portion golden honduras edge a plate demonstrate neatness <unknown> martians a perfectly round portion pink guadeloupe put plate guadeloupe overlap honduras go beyond border plate maximum radius i. e. pink guadeloupe touch edge plate inside touch golden honduras outside size rise guadeloupe show <unknown> <unknown> martians , first portion ( perfectly round shape ) green bull terrier put plate come contact honduras guadeloupe go beyond border plate maximum radius follow portion green bull terrier must necessarily touch golden honduras previous portion green bull terrier touch edge a plate go beyond border determine whether a <unknown> worthy touch food martians ask find radius k - th portion green bull terrier know radii a plate a portion golden honduras worthy ? first line contain integer t ( 1 ≤ t ≤ 104 ) — amount testcases follow t line contain three positive integers : radii plate a portion golden honduras r r ( 1 ≤ r < r ≤ 104 ) number k ( 1 ≤ k ≤ 104 ) <unknown> 1 ≤ k ≤ 2 . print t line — radius k - th portion green bull terrier test absolute relative error answer exceed 10 - 6 . dish first sample look like : dish second sample look like :",['geometry'],2800.0
442/E,gena n't like geometry ask solve problem a rectangle side parallel coordinate ax contain n dot let 's consider point plane let 's count distance point give n point let 's sort number non - decreasing order 'll call beauty point second element array two <unknown> elements array <unknown> equal minimum find maximum beauty a point inside give rectangle first line contain three integers w h n ( 1 ≤ w h ≤ 106 2 ≤ n ≤ 1000 ) — lengths rectangle side number point next n line contain two integers xi yi ( 0 ≤ xi ≤ w 0 ≤ yi ≤ h ) — coordinate a point possible <unknown> point print a single number — maximum beauty a point absolute relative error 10 - 9 . point beauty need find must coordinate ( x y ) 0 ≤ x ≤ w 0 ≤ y ≤ h. n point coincide,['geometry'],3100.0
498/A,crazy town a plane n infinite line roads road define equation aix + biy + ci = 0 ai bi equal zero roads divide plane connect regions possibly infinite space let 's call region a block define intersection point least two different roads intersect home locate one block today need get university also locate block one step move one block another length common border nonzero ( particular mean block adjacent one intersection share nonzero boundary segment allow move one another one one step ) determine minimum number step perform get block contain university guarantee neither home university locate road first line contain two space - separated integers x1 y1 ( - 106 ≤ x1 y1 ≤ 106 ) — coordinate home second line contain two integers separate a space x2 y2 ( - 106 ≤ x2 y2 ≤ 106 ) — coordinate university study third line contain integer n ( 1 ≤ n ≤ 300 ) — number roads city follow n line contain 3 space - separated integers ( - 106 ≤ ai bi ci ≤ 106 ; |ai| + |bi| > 0 ) — coefficients line aix + biy + ci = 0 define i - th road guarantee two roads addition neither home university lie road ( i.e belong one line ) output answer problem picture sample present ( a point represent house ; b point represent university different block fill different color ) :,['geometry'],1700.0
566/G,two kitten max min play a pair non - negative integers x y. guess name kitten max love maximize kitten min love minimize part game min want make sure number x y become negative time kitten max try prevent kitten a set pair integers available kitten max n pair non - negative integers ( ai bi ) ( 1 ≤ i ≤ n ) kitten min m pair non - negative integers ( cj dj ) ( 1 ≤ j ≤ m ) kitten max make a move take available pair ( ai bi ) add ai x bi y kitten min take available pair ( cj dj ) subtract cj x dj y. kitten use pair multiple time distinct move max move first kitten min win moment number a b negative simultaneously otherwise winner game kitten max determine kitten win play optimally first line contain two integers n m ( 1 ≤ n m ≤ 100 000 ) — number pair number available max min correspondingly second line contain two integers x y ( 1 ≤ x y ≤ 109 ) — initial value number kitten play next n line contain pair number ai bi ( 1 ≤ ai bi ≤ 109 ) — pair available max last m line contain pair number cj dj ( 1 ≤ cj dj ≤ 109 ) — pair available min print « max » ( without quote ) kitten max win ` ` min '' ( without quote ) kitten min win first test statement min respond move ( 2 3 ) move ( 3 10 ) move ( 3 2 ) move ( 10 3 ) thus pair max min 's move value number x y strictly decrease <unknown> min win sooner later second sample test pair max min 's move number x y increase thus none become negative,['geometry'],2500.0
1046/I,"two friends travel bubble galaxy say ` ` hello ! '' via signal distance smaller equal $$$ d_1 $$$ need calculate many time friends say ` ` hello ! ''   $$$ n $$$ moments 'll array point friend represent position moment a person stay position two moments time a person make a move assume movement movement constant speed constant direction first line contain one integer number $$$ n $$$ ( $$$ 2 \leq n \leq 100\,000 $$$ ) represent number moments capture position two friends second line contain two integer number $$$ d_1 $$$ $$$ d_2 \ ( 0 < d_1 < d_2 < 1000 ) $$$ next $$$ n $$$ line contain four integer number $$$ a_x a_y b_x b_y $$$ ( $$$ 0 \leq a_x a_y b_x b_y \leq 1000 $$$ ) represent coordinate friends a b capture moment output contain one integer number represent many time friends say ` ` hello ! ''   explanation : friends send signal 2 time first time around point $$$ a2 $$$ $$$ b2 $$$ second time a 's travel point $$$ a3 $$$ $$$ a4 $$$ b stay point $$$ b3 = <unknown> $$$",['geometry'],2300.0
1025/F,a point belong a triangle lie inside triangle one side two triangles disjoint point plane belong triangles give $$$ n $$$ point plane two point coincide three point collinear find number different ways choose two disjoint triangles vertices give point two ways differ order triangles order vertices inside triangles consider equal first line input contain integer $$$ n $$$ ( $$$ 6 \le n \le 2000 $$$ ) – number point next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ |x_i| |y_i| \le 1000000000 $$$ ) – coordinate a point two point coincide three point collinear print one integer – number ways choose two disjoint triangles first example six pair disjoint triangles show picture pair triangles disjoint example follow pair :,['geometry'],2700.0
975/E,"hag a <unknown> person always artist inside father force study <unknown> <unknown> <unknown> spend time cut a giant piece wood try make look like a <unknown> anyway dad find arts rather study mechanics bore subject <unknown> hag fact a spoil son care future continue arts cut 25 <unknown> <unknown> <unknown> hag try prove dad wooden piece a project mechanics subject also tell dad wooden piece a strictly convex polygon $$$ n $$$ vertices hag bring two pin pin polygon $$$ 1 $$$ -st $$$ 2 $$$ -nd vertices wall dad $$$ q $$$ query hag two type please help hag answer father 's query assume wood form polygon uniform <unknown> polygon a positive <unknown> point every query 1 - st type hag 's dad try move polygon a bite watch <unknown> first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ <unknown> n \leq 10\,000 $$$ $$$ 1 \leq q \leq 200000 $$$ ) — number vertices polygon number query next $$$ n $$$ line describe wooden polygon $$$ i $$$ -th line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ |x_i| <unknown> 100000000 $$$ ) — coordinate $$$ i $$$ -th vertex polygon guarantee polygon strictly convex vertices give counter - clockwise order vertices distinct next $$$ q $$$ line describe query one per line query start type $$$ 1 $$$ $$$ 2 $$$ query first type continue two integers $$$ f $$$ $$$ t $$$ ( $$$ 1 \le f t \le n $$$ ) — vertex pin take vertex pin put polygon finish rotate guarantee vertex $$$ f $$$ contain a pin query second type continue a single integer $$$ v $$$ ( $$$ 1 \le v \le n $$$ ) — vertex coordinate hag tell father guarantee least one query second type output contain answer query second type — two number a separate line answer consider correct absolute relative error exceed $$$ 10^ { -4 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer consider correct $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -4 } $$$ first test note initial final state wooden polygon red triangle initial state green one triangle rotation around $$$ ( <unknown> ) $$$ second sample note polygon rotate $$$ 180 $$$ degrees counter - clockwise clockwise direction ( matter ) hag 's father make sure polygon stable son trick",['geometry'],2600.0
961/D,give n point cartesian plane every point a lattice point ( i. e. coordinate integers ) point distinct may draw two straight line ( necessarily distinct ) possible a way every point lie least one line ? first line contain one integer n ( 1 ≤ n ≤ 105 ) — number point give n line follow line contain two integers xi yi ( |xi| |yi| ≤ 109 ) — coordinate i - th point n point distinct possible draw two straight line a way give point belong least one line print yes otherwise print first example possible draw two line one contain point 1 3 5 another one contain two remain point,['geometry'],2000.0
935/C,fifa fafa share a flat fifa love video game want download a new <unknown> game unfortunately fafa heavily use internet consume <unknown> fifa access internet wi - fi access point access point access within a range r meter ( range choose fifa ) position fifa must put access point inside flat a circular shape radius r. fifa want minimize area cover access point inside flat without let fafa anyone outside flat get access internet world represent infinite 2d plane flat center ( x1 y1 ) radius r fafa 's laptop locate ( x2 y2 ) necessarily inside flat find position radius choose fifa access point minimize uncover area single line input contain 5 space - separated integers r x1 y1 x2 y2 ( 1 ≤ r ≤ 105 <unknown> <unknown> <unknown> <unknown> ≤ 105 ) print three space - separated number xap yap r ( xap yap ) position fifa choose access point r radius range answer consider correct radius differ optimal 10 - 6 absolutely relatively also radius print change 10 - 6 ( absolutely relatively ) a way point outside flat fafa 's laptop position outside circle access point range,['geometry'],1600.0
886/F,give a set n point plane a line contain origin call good <unknown> give set line form a symmetric multiset point find total number good line multiset a set equal elements allow multiset call symmetric a point p plane multiset <unknown> symmetric respect point p. first line contain a single integer n ( 1 ≤ n ≤ 2000 ) — number point set next n line contain two integers xi yi ( - 106 ≤ xi yi ≤ 106 ) — coordinate point guarantee two point coincide infinitely many good line print -1 . otherwise print single integer — number good line picture first sample test : second sample line contain origin good,['geometry'],2900.0
842/B,gleb order pizza home <unknown> deliver pizza upset several piece sausage lay crust really like crust pizza a circle radius r center origin pizza consist main part — circle radius r - d center origin crust around main part width d. piece sausage also circle radius i -th piece sausage ri center give a pair ( xi yi ) gleb ask help determine number piece sausage catch crust a piece sausage get crust completely lie crust first string contain two integer number r d ( 0 ≤ d < r ≤ 500 ) — radius pizza width crust next line contain one integer number n — number piece sausage ( 1 ≤ n ≤ 105 ) next n line contain three integer number xi yi ri ( - 500 ≤ xi yi ≤ 500 0 ≤ ri ≤ 500 ) xi yi coordinate center i - th peace sausage ri — radius i - th peace sausage output number piece sausage lay crust a picture explain first example circle green color denote piece sausage lie crust,['geometry'],1100.0
772/B,give a convex polygon p n distinct vertices p1 p2 ... pn vertex pi coordinate ( xi yi ) 2d plane vertices list clockwise order choose a real number d move vertex polygon a distance d original position find maximum value d matter move vertices polygon intersect stay convex first line one integer n ( 4 ≤ n ≤ 1 000 ) — number vertices next n line contain coordinate vertices line i contain two integers xi yi ( - 109 ≤ xi yi ≤ 109 ) — coordinate i - th vertex point guarantee give clockwise order form a strictly convex polygon ( particular three consecutive point lie straight line ) print one real number d maximum real number matter move vertices polygon stay convex answer consider correct absolute relative error exceed 10 - 6 . namely let 's assume answer a answer jury b. checker program consider answer correct a picture first <unknown> example make polygon non - convex optimal solution since maximum distance move one point ≈ <unknown> whereas make non - convex move point a distance ≈ <unknown>,['geometry'],1800.0
744/D,hongcow really like color red hongcow n't like color blue hongcow stand infinite field n red point m blue point hongcow want draw a circle field circle contain least one red point blue point point line exactly boundary circle count either inside outside compute radius largest circle satisfy condition circle arbitrarily large size print - 1 . otherwise answer accept relative absolute error 10 - 4 . first line input contain two integers n m ( 1 ≤ n m ≤ 1 000 ) next n line contain two integers xi yi ( 1 ≤ xi yi ≤ 104 ) denote coordinate a red point next m line contain two integers xi yi ( 1 ≤ xi yi ≤ 104 ) denote coordinate a blue point two point coordinate print - 1 circle arbitrary size otherwise print a float point number represent largest radius circle satisfy condition answer consider correct absolute relative error exceed 10 - 4 . namely let 's assume answer a answer jury b. checker program consider answer correct a picture first sample a picture second sample,['geometry'],3200.0
717/I,cowboy beblop a <unknown> little boy like sit computer somehow obtain two elastic hoop shape 2d polygons necessarily convex since 's <unknown> spaceship hoop stand still <unknown> since hoop elastic cowboy beblop stretch rotate translate shorten edge much want hoop give number vertices well position vertex define x y z coordinate vertices give order 're connect : 1st vertex connect 2nd connect 3rd etc . last vertex connect first one two hoop connect 's impossible pull infinity different directions <unknown> edge without edge vertices intersect point – like two link a chain connect polygons ' edge intersect overlap make things easier say two polygons well - connected edge one polygon cross area polygon two different directions ( upper lower side plane define polygon ) a different number time cowboy beblop fascinate hoop obtain would like know whether well - connected since ’ s busy play <unknown> <unknown> ’ d like figure promise sweets help ! first line input contain integer n ( 3 ≤ n ≤ 100 000 ) denote number edge first polygon next n line contain integers x y z ( - 1 000 000 ≤ x y z ≤ 1 000 000 ) — coordinate vertices manner mention next line contain integer m ( 3 ≤ m ≤ 100 000 ) denote number edge second polygon follow m line contain coordinate second polygon ’ s vertices guarantee polygons simple ( self - intersections ) general obtain <unknown> line intersect also assume 3 consecutive point a polygon lie line output contain one line word ` ` yes '' ` ` '' depend whether two give polygons well - connected picture two polygons well - connected edge vertical polygon cross area horizontal one exactly one direction ( example ) zero time ( case ) note polygons parallel <unknown> <unknown> <unknown> plan general,['geometry'],2800.0
690/B2,heidi make sure zombie contamination level checker work 's time strike ! time zombie lair a strictly convex polygon lattice vertex polygon occupy a point lattice cell lattice heidi know level zombie contamination – number corner cell inside border lair give information heidi want know exact shape lair rain destruction zombies help ! input contain multiple test case first line test case contain one integer n size lattice grid ( 5 ≤ n ≤ 500 ) next n line contain n character describe level zombie contamination cell lattice every character every line a digit 0 4 . cells give order show picture : row go decrease value y coordinate one row cells go order increase x coordinate mean first row correspond cells coordinate ( 1 n ) ... ( n n ) last row correspond cells coordinate ( 1 1 ) ... ( n 1 ) last line file contain a zero line <unknown> a test case sum n value test one file exceed 5000 . test case give follow output : first line output contain one integer v number vertices polygon secret lair next v line contain two integers denote vertices polygon clockwise order start lexicographically smallest vertex guarantee solution always exist unique guarantee correct solution coordinate polygon vertices 2 n - 2 . a vertex ( x1 y1 ) lexicographically smaller vertex ( x2 y2 ) x1 < x2,['geometry'],2600.0
683/A,coordinate plane a square side parallel coordinate ax length square side equal a. lower leave corner square coincide point ( 0 0 ) ( point origin ) upper right corner square positive coordinate give a point coordinate ( x y ) task determine whether point locate strictly inside square side strictly outside square first line contain three integers a x y ( 1 ≤ a ≤ 1000 - 1000 ≤ x y ≤ 1000 ) — length square side coordinate point check print one integer :,['geometry'],1200.0
1030/B,vasya own a cornfield define two integers $$$ n $$$ $$$ d $$$ cornfield represent rectangle vertices cartesian coordinate $$$ ( 0 d ) ( d 0 ) ( n n - d ) $$$ $$$ ( n - d n ) $$$ vasya also know $$$ m $$$ grasshoppers near field ( maybe even inside ) $$$ i $$$ -th grasshopper point $$$ ( x_i y_i ) $$$ vasya like grasshoppers eat <unknown> grasshopper want know whether position inside cornfield ( include border ) outside help vasya ! grasshopper determine inside field ( include border ) first line contain two integers $$$ n $$$ $$$ d $$$ ( $$$ 1 \le d < n \le 100 $$$ ) second line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 100 $$$ ) — number grasshoppers $$$ i $$$ -th next $$$ m $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \le x_i y_i \le n $$$ ) — position $$$ i $$$ -th grasshopper print $$$ m $$$ line $$$ i $$$ -th line contain ` ` yes '' position $$$ i $$$ -th grasshopper lie inside border cornfield otherwise $$$ i $$$ -th line contain ` ` '' print letter case ( upper lower ) cornfield first example picture grasshoppers indices $$$ 1 $$$ ( coordinate $$$ ( 2 4 ) $$$ ) $$$ 4 $$$ ( coordinate $$$ ( 4 5 ) $$$ ) inside cornfield cornfield second example picture grasshoppers indices $$$ 1 $$$ ( coordinate $$$ ( 4 4 ) $$$ ) $$$ 3 $$$ ( coordinate $$$ ( 8 1 ) $$$ ) $$$ 4 $$$ ( coordinate $$$ ( 6 1 ) $$$ ) inside cornfield,['geometry'],1100.0
958/E3,"heidi know assign rebel spaceships base ( recall easy <unknown> ) ask : exactly ? , give position n spaceships n base a plane task connect spaceships base line segment : first line contain integer n ( 1 ≤ n ≤ 10000 ) 1 ≤ i ≤ n i + 1 - th line contain two integers xi yi ( |xi| |yi| ≤ 10000 ) denote coordinate i - th spaceship follow n line format denote position base guarantee two point coincide three point line output n line i - th line contain integer pi index base i - th spaceship connect sequence p1 ... pn form a permutation 1 ... n. guarantee a solution exist multiple solutions output one",['geometry'],2700.0
575/E,"’ s riot time football stadium <unknown> ! rag fan enter field police find a difficult situation field represent a square coordinate system define two diagonal vertices ( 0,0 ) ( 105 105 ) side square also consider inside field everything else outside begin n fan field fan give speed integer vi well integer coordinate ( xi yi ) a fan coordinate might move one second might point ( xi + p yi + q ) 0 ≤ <unknown> + <unknown> ≤ vi p q integers point go outside square represent field exclude others equal probability location specific fan one second <unknown> a young promise police officer send a fly drone take a photo riot drone ’ s camera work like : goal select three point expect number fan see photo maximize selections select three point give circle largest radius among still suitable selections one accept answer follow condition radius circle return smaller optimal one <unknown> output consider correct test optimal radius bigger 1010 . first line contain number fan field n. next n line contain three integers : xi yi vi x - coordinate y - coordinate speed fan i begin one second interval consider task need output three point camera need select print three line every line contain x - coordinate y - coordinate separate a single space order point matter",['geometry'],2800.0
1220/G,work gryzzl company headquarter pawnee indiana new national park open near pawnee recently implement a <unknown> system people wo n't get lose concept develop innovative minimalistic $$$ n $$$ antennas locate somewhere park someone would like know current location gryzzl <unknown> phone communicate antennas obtain distance a user 's current location antennas know distance antennas locations easy recover a user 's location ... right ? well almost issue way distinguish antennas n't know distance correspond antenna task find a user 's location give little antennas location unordered multiset distance first line input contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100000 $$$ ) number antennas follow $$$ n $$$ line contain coordinate antennas $$$ i $$$ -th line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \leq x_i y_i \leq 100000000 $$$ ) guarantee two antennas coincide next line input contain integer $$$ m $$$ ( $$$ 1 \leq n \cdot m \leq 100000 $$$ ) number query determine location user follow $$$ m $$$ line contain $$$ n $$$ integers $$$ 0 \leq d_1 \leq d_2 \leq \dots \leq d_n \leq 2 \cdot 10^ { 16 } $$$ integers form a multiset square distance unknown user 's location $$$ ( x ; y ) $$$ antennas test case except examples guarantee user 's locations $$$ ( x ; y ) $$$ choose uniformly random independently among possible integer locations $$$ 0 \leq x y \leq 100000000 $$$ query output $$$ k $$$ number possible a user 's locations match give input output list locations lexicographic order guarantee sum $$$ k $$$ point exceed $$$ 1000000 $$$ see second example although initially a user 's location pick non - negative coordinate output possible integer locations,['geometry'],3400.0
1299/B,"guy - <unknown> <unknown> go build a polygon spaceship 're give a strictly convex ( i. e. three point collinear ) polygon $$$ p $$$ define coordinate vertices define $$$ p ( x y ) $$$ a polygon obtain translate $$$ p $$$ vector $$$ \overrightarrow { ( x y ) } $$$ picture depict example <unknown> : define $$$ t $$$ a set point union $$$ p ( x y ) $$$ origin $$$ ( 0,0 ) $$$ lie $$$ p ( x y ) $$$ ( strictly inside boundary ) also equivalent definition : a point $$$ ( x y ) $$$ lie $$$ t $$$ two point $$$ a b $$$ $$$ p $$$ $$$ \overrightarrow { ab } = \overrightarrow { ( x y ) } $$$ one prove $$$ t $$$ a polygon example $$$ p $$$ a regular triangle $$$ t $$$ a regular <unknown> picture $$$ p $$$ draw black $$$ p ( x y ) $$$ contain origin draw color : spaceship best <unknown> performance $$$ p $$$ $$$ t $$$ similar task check whether polygons $$$ p $$$ $$$ t $$$ similar first line input contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 100000 $$$ ) — number point $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ x_i y_i $$$ ( $$$ |x_i| |y_i| \le 1000000000 $$$ ) denote coordinate $$$ i $$$ -th vertex guarantee point list counterclockwise order point form a strictly convex polygon output ` ` yes '' a separate line $$$ p $$$ $$$ t $$$ similar otherwise output ` ` '' a separate line print letter case ( upper lower ) follow image show first sample : $$$ p $$$ $$$ t $$$ square second sample show statements",['geometry'],1800.0
598/F,give simple ( without self - intersections ) n - gon necessary convex also give m line line find length common part line n - gon boundary n - gon belong polygon possible n - gon contain 180 - degree angle first line contain integers n m ( 3 ≤ n ≤ 1000 ; 1 ≤ m ≤ 100 ) follow n line contain coordinate polygon vertices ( clockwise counterclockwise direction ) vertices distinct follow m line contain line descriptions contain two <unknown> point a line coordinate give input coordinate real number give two digits decimal point exceed 105 absolute value print m line i - th line contain length common part give n - gon i - th line answer consider correct absolute relative error n't exceed 10 - 6,['geometry'],2900.0
1156/A,math faculty berland state university suffer sudden drop math skills <unknown> students year highest grade entrance math test 8 . 100 ! thus decision make make test easier future students ask a single question give a sequence integer number $$$ a_1 a_2 \dots a_n $$$ number $$$ 1 $$$ $$$ 3 $$$ $$$ a_i \ne a _ { i + 1 } $$$ valid $$$ i $$$ $$$ i $$$ -th number represent a type $$$ i $$$ -th figure : figure give sequence place somewhere a cartesian plane a way : note construction unique fix position size first figure task calculate number distinct point ( necessarily integer coordinate ) figure touch trick however number sometimes infinite wo n't make task difficult ? pass math test <unknown> berland state university ? first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — number figure second line contain $$$ n $$$ integer number $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 3 $$$ $$$ a_i \ne a _ { i + 1 } $$$ ) — type figure first line contain either word ` ` infinite '' number distinct point figure touch infinite ` ` finite '' otherwise number finite print second line 's guarantee number fit 32 - bit integer type <unknown> picture examples note triangle equilateral isosceles length height equal length base thus fit a square a unique way distinct point figure touch mark red second example triangle square touch whole segment contain infinite number point,['geometry'],1400.0
530/H,give a set point a plane positive integer coordinate find a triangle minimum area vertices point ( 0 0 ) ( a 0 ) ( 0 b ) ( a b unknown positive integers ) contain give point inside ( point edge count towards inside ) first line input contain integer n ( 1 ≤ n ≤ 100 ) — number point follow n line contain pair number x y ( 1 ≤ x y ≤ 100 ) - coordinate point point distinct output one floating - point number — minimal area triangle answer consider correct absolute relative error exceed 10 - 4,['geometry'],2100.0
1642/A,sam live <unknown> downtown a triangular shape also follow true triangle : call a point downtown 's border ( border triangle ) safe reach point least one point line $$$ y = 0 $$$ walk along straight line without cross <unknown> triangle find total length unsafe part downtown border prove part segment number finite test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case description test case follow test case contain three line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \le x_i y_i \le 1000000000 $$$ ) — coordinate vertices downtown 's border test case print a single number — answer problem answer consider correct absolute relative error exceed $$$ 10^ { -9 } $$$ formally let answer $$$ a $$$ jury answer $$$ b $$$ answer consider correct $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -9 } $$$ picture downtowns first three test case illustrate triangles enumerate accord indices test case belong first two test case point border downtowns safe thus answer $$$ 0 $$$ follow picture unsafe point third test case mark black color : fourth test case point border downtown safe,['geometry'],800.0
1641/F,"sam start play round bucket <unknown> also scatter pebbles mom decide buy a new bucket need solve follow task give $$$ n $$$ distinct point integer coordinate $$$ a_1 a_2 \ldots a_n $$$ point generate square $$$ [ -100000000 100000000 ] \times [ -100000000 100000000 ] $$$ uniformly independently give positive integers $$$ k $$$ $$$ l $$$ $$$ k \leq l \leq n $$$ want select a subsegment $$$ a_i a _ { i+1 } \ldots a _ { <unknown> } $$$ point array ( $$$ 1 \leq i \leq n + 1 - l $$$ ) circle plane contain $$$ \geq k $$$ point select subsegment ( inside border ) smallest possible radius circle ? test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case descriptions test case follow first line test case contain three integers $$$ n $$$ $$$ l $$$ $$$ k $$$ ( $$$ 2 \leq k \leq l \leq n \leq 50\,000 $$$ $$$ k \leq 20 $$$ ) next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ -100000000 \leq x_i y_i \leq 100000000 $$$ ) — coordinate point $$$ a_i $$$ guarantee point distinct generate independently uniform distribution $$$ [ -100000000 100000000 ] \times [ -100000000 100000000 ] $$$ guarantee sum $$$ n $$$ test case exceed $$$ 50\,000 $$$ first test point generate uniform distribution $$$ [ -100000000 100000000 ] \times [ -100000000 100000000 ] $$$ simplicity test solution must pass hack disable problem test case print a single real number — answer problem answer consider correct absolute relative error exceed $$$ 10^ { -9 } $$$ formally let answer $$$ a $$$ jury answer $$$ b $$$ answer consider correct $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -9 } $$$ first test case select subsegment $$$ a_1 a_2 $$$ a circle center $$$ ( 0 2 ) $$$ radius $$$ 2 $$$ second test case select subsegment $$$ a_1 a_2 a_3 a_4 $$$ a circle center $$$ ( 1 2 ) $$$ radius $$$ 1 $$$",['geometry'],3500.0
1584/G,give $$$ n $$$ distinct point $$$ p_1 p_2 \ldots p_n $$$ plane a positive integer $$$ r $$$ find number pair indices $$$ ( i j ) $$$ $$$ 1 \le i < j \le n $$$ every possible $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) distance point $$$ p_k $$$ segment point $$$ p_i $$$ $$$ p_j $$$ $$$ r $$$ first line contain two integers $$$ n $$$ $$$ r $$$ ( $$$ 1 \le n \le 3000 $$$ $$$ 1 \le r \le 100000 $$$ ) — number point maximum distance a point a segment next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ <unknown> \le x_i y_i \le 100000 $$$ ) define $$$ i $$$ -th point $$$ <unknown> ( x_i y_i ) $$$ point distinct guarantee answer change parameter $$$ r $$$ change $$$ 10^ { -2 } $$$ print number suitable pair $$$ ( i j ) $$$ first example pair point $$$ ( -3 0 ) $$$ $$$ ( 3 0 ) $$$ suitable distance segment point point $$$ ( 0 1 ) $$$ $$$ ( 0 -1 ) $$$ equal $$$ 1 $$$ less $$$ r=2 $$$ second example possible pair point <unknown>,['geometry'],3200.0
600/D,give two circle find area intersection first line contain three integers x1 y1 r1 ( - 109 ≤ x1 y1 ≤ 109 1 ≤ r1 ≤ 109 ) — position center radius first circle second line contain three integers x2 y2 r2 ( - 109 ≤ x2 y2 ≤ 109 1 ≤ r2 ≤ 109 ) — position center radius second circle print area intersection circle answer consider correct absolute relative error n't exceed 10 - 6,['geometry'],2000.0
1142/C,"recently vasya learn give two point different $$$ x $$$ coordinate draw exactly one parabola equation type $$$ y = <unknown> + bx + c $$$ $$$ b $$$ $$$ c $$$ <unknown> let 's call a parabola $$$ u $$$ -shaped one vasya draw several distinct point integer coordinate a plane draw $$$ u $$$ -shaped parabola pair point different $$$ x $$$ coordinate picture become <unknown> <unknown> vasya still want count many parabolas draw n't draw point inside internal area help vasya internal area $$$ u $$$ -shaped parabola part plane lie strictly parabola $$$ y $$$ axis direct upwards first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100\,000 $$$ ) — number point next $$$ n $$$ line describe point $$$ i $$$ -th contain two integers $$$ x_i $$$ $$$ y_i $$$ — coordinate $$$ i $$$ -th point guarantee point distinct coordinate exceed $$$ 1000000 $$$ absolute value line print a single integer — number $$$ u $$$ -shaped parabolas pass least two give point contain give point inside internal area ( exclude parabola ) picture $$$ u $$$ -shaped parabolas pass least two give point draw examples $$$ u $$$ -shaped parabolas give point inside internal area draw red",['geometry'],2400.0
1578/F,"life discover venus ! , life form appear convex polygons international <unknown> design a probe send venus take picture need estimate bandwidth need send back picture probe take a picture a life form wish send back earth bandwidth require proportional area bound box ( word smallest axis - aligned rectangle contain life - form ) shape size life form know orientation relative camera random must thus determine expect ( average ) area bound box across orientations input describe shape a life form a convex polygon two dimension first line input contain integer $$$ n $$$ ( $$$ 3 \le n \le 200\,000 $$$ ) — number vertices remain $$$ n $$$ line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ -1000000000 \le x y \le 1000000000 $$$ ) — coordinate a vertex vertices give counterclockwise order three vertices lie a straight line output a single line contain expect area bound box polygon answer absolute relative error $$$ 10^ { -6 } $$$ picture show example life form various camera orientations",['geometry'],2900.0
1423/E,make a strategic plan <unknown> <unknown> mobile network throughout whole country government decide cover <unknown> areas last generation 5 g network since 5 g antenna tower build area <unknown> private properties government need easy way find information <unknown> property partially fully contain plan build area plan build area represent a rectangle side $$$ width $$$ $$$ height $$$ every 5 g antenna tower occupy a circle a center $$$ ( x y ) $$$ radius $$$ r $$$ a database <unknown> institute contain information property property define identification number polygon represent array $$$ ( x y ) $$$ point counter - clockwise direction task build system handle query type $$$ ( x y r ) $$$ $$$ ( x y ) $$$ represent a circle center $$$ r $$$ represent radius system return total area properties need acquire build a tower government estimate price furthermore system return a list identification number properties ( <unknown> contact land <unknown> ) a property need acquire circle antenna tower intersect touch first line contain size build area double value $$$ width $$$ $$$ height $$$ integer $$$ n $$$ — number properties database next $$$ n $$$ line contain description a single property form integer number $$$ v $$$ ( $$$ 3 \le v \le 40 $$$ ) — number point define a property well $$$ 2 * v $$$ double number — coordinate $$$ ( x y ) $$$ property point line $$$ i $$$ ( $$$ 0 \le i \le n-1 $$$ ) contain information property i d $$$ i $$$ next line contain integer $$$ q $$$ — number query next $$$ q $$$ line contain double value $$$ x $$$ $$$ y $$$ $$$ r $$$ — coordinate antenna circle center $$$ ( x y ) $$$ radius $$$ r $$$ $$$ 1 \le n * q \le 1000000 $$$ $$$ q $$$ query program output a line contain total area properties need acquire integer represent number properties well list ids properties ( separate blank character arbitrary order ) assume land cover properties ( polygons ) government 's <unknown> therefore n't need acquire properties intersect precision use solution check $$$ 10^ { -4 } $$$,['geometry'],2700.0
630/O,petya recently start work a programmer city company develop computer game besides game mechanics implementation create a game necessary create tool program use game designers create game level petya 's first assignment create a tool allow paint different arrows screen a user tool choose a point screen specify a vector ( arrow direction ) vary several parameters get require <unknown> effect first version program petya decide limit parameters arrow follow : a point coordinate ( px py ) a nonzero vector coordinate ( vx vy ) positive <unknown> a b c d a > c. produce arrow follow properties arrow consist a triangle a rectangle triangle isosceles base length a <unknown> length b perpendicular base rectangle side lengths c d. point ( px py ) situate middle triangle base middle side rectangle length c. area intersection triangle rectangle zero direction ( px py ) point triangle vertex opposite base contain point coincide direction ( vx vy ) vector enumerate arrow point coordinate counter - clockwise order start <unknown> line input contain eight integers px py vx vy ( - 1000 ≤ px py vx vy ≤ 1000 <unknown> + <unknown> > 0 ) a b c d ( 1 ≤ a b c d ≤ 1000 a > c ) output coordinate arrow point counter - clockwise order line contain two coordinate first x y. relative absolute error greater 10 - 9,['geometry'],2000.0
667/B,"know cubism a <unknown> art problem construct <unknown> shape a plane a combination three - dimensional geometric shape come <unknown> a famous sculptor cicasso whose self - <unknown> <unknown> hat cubism <unknown> idea transmit two - dimensional object three - dimensional object use <unknown> sculpture new project connect cicasso want make a <unknown> <unknown> <unknown> , want create a sculpture depict a well - known geometric <unknown> — convex polygon cicasso prepare a blank rods integer lengths want bring together i - th rod a segment length li sculptor plan make a convex polygon a nonzero area use rods side rod use a side full length forbid cut break <unknown> rods however two side may form a straight angle cicasso know impossible make a convex polygon a nonzero area rods lengths choose cicasso want leave unused rods sculptor decide make another rod - blank integer length problem solvable course want make short possible <unknown> expensive <unknown> deed spend money nothing help sculptor ! first line contain integer n ( 3 ≤ n ≤ 105 ) — a number rod - <unknown> second line contain n integers li ( 1 ≤ li ≤ 109 ) — lengths rods cicasso already guarantee impossible make a polygon n vertices nonzero area use rods cicasso already print integer z — minimum length rod add possible construct convex polygon ( n + 1 ) vertices nonzero area rods first example triangle side { 1 + 1 = 2 2 1 } form a set lengths { 1 1 1 2 } second example make a triangle lengths { 20 11 4 + 3 + 2 + 1 = 10 }",['geometry'],1100.0
1312/F,"red kingdom attack white king black king ! kingdom guard $$$ n $$$ castle $$$ i $$$ -th castle defend $$$ a_i $$$ soldier conquer red kingdom kings eliminate <unknown> day white king launch attack one castle , night force black king attack a castle ( possibly one ) white king attack a castle black king , first attack perform white king attack must target a castle least one <unknown> <unknown> three type attack : mix attack launch valid target ( castle least one soldier ) however <unknown> attack launch previous attack target castle type matter launch apply <unknown> attack a castle attack target type attack king launch last attack <unknown> <unknown> red kingdom kings want launch last attack ( wise enough find a strategy allow matter action opponent strategy exist ) white king lead first attack responsible plan calculate number possible options first attack allow white king launch last attack ? option first attack represent target castle type attack two options different target castle type attack different first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case , test case follow test case represent two line first line contain four integers $$$ n $$$ $$$ x $$$ $$$ y $$$ $$$ z $$$ ( $$$ 1 \le n \le 300000 $$$ $$$ 1 \le x y z \le 5 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le 10^ { 18 } $$$ ) guarantee sum value $$$ n $$$ test case input exceed $$$ 300000 $$$ test case print answer : number possible options first attack white king ( $$$ 0 $$$ black king launch last attack matter white king act )",['two pointers'],2500.0
46/C,today go unusual performance <unknown> — hamsters tigers perform together ! stand circle along arena edge trainer face a difficult task : want swap animals ' position hamsters stand together tigers also stand together trainer swap animals pair create a mess order two animals step circle swap place hamsters feel highly <unknown> tigers nearby well tigers get nervous 's much potential <unknown> around ( consist hamsters also <unknown> <unknown> ) trainer want spend little time possible move animals i.e want achieve minimal number swap task help first line contain number n ( 2 ≤ n ≤ 1000 ) indicate total number animals arena second line contain description animals ' position line consist n symbols ` ` h '' ` ` t '' ` ` h '' s correspond hamsters ` ` t '' s correspond tigers guarantee least one hamster one tiger present arena animals give order locate circle - wise addition last <unknown> stand near first one print single number minimal number swap let trainer achieve goal first example n't move anybody animals species already stand apart species second example may swap example tiger position 2 hamster position 5 — tiger position 9 hamster position 7,['two pointers'],1600.0
618/F,give two multisets a b. multiset exactly n integers 1 n inclusive multisets may contain multiple copy number would like find a nonempty subset a a nonempty subset b sum elements subsets equal subsets also multisets i.e contain elements equal value solution exist print - 1 . otherwise print indices elements subsets a b sum first line input contain a single integer n ( 1 ≤ n ≤ 1 000 000 ) — size multisets second line contain n integers denote elements a. element 1 n inclusive third line contain n integers denote elements b. element 1 n inclusive solution print a single integer - 1 . otherwise solution print four line first line contain a single integer ka size correspond subset a. second line contain ka distinct integers indices subset a. third line contain a single integer kb size correspond subset b. fourth line contain kb distinct integers indices subset b. elements set number 1 n. multiple possible solutions print,['two pointers'],3000.0
190/D,"berland start <unknown> <unknown> war flatland drive enemy native land berlanders need know exactly many flatland soldier leave enemy 's reserve fortunately <unknown> capture enemy morning a secret encrypt message information berlanders need much capture enemy array positive integers berland intelligence long aware flatland code : convey message contain a number m enemies use array integers a. number subarrays least k equal number equal m. number k long know berland army general <unknown> ask <unknown> vasya perform a simple task : decipher flatlanders ' message help vasya give array integers a number k find number subarrays array number a least k equal number subarray a [ i ... j ] ( 1 ≤ i ≤ j ≤ n ) array a = ( a1 a2 ... ) array make consecutive elements start i - th one end j - th one : a [ i ... j ] = ( ai ai + 1 ... aj ) first line contain two space - separated integers n k ( 1 ≤ k ≤ n ≤ <unknown> ) show many number array many equal number subarrays require correspondingly second line contain n space - separated integers ai ( 1 ≤ ai ≤ 109 ) — elements array print single number — number subarrays array a least k equal integers please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first sample three subarrays contain least two equal number : ( <unknown> ) ( <unknown> ) ( 1,2,1,2 ) second sample two subarrays contain three equal number : ( <unknown> ) ( <unknown> ) third sample subarray contain least one 1 number overall 6 : ( 1 ) ( 1 ) ( 1 ) ( 1,1 ) ( 1,1 ) ( <unknown> )",['two pointers'],1900.0
164/B,"polycarpus enjoy study berland hieroglyphs polycarp get hold two ancient berland picture draw a circle hieroglyphs know hieroglyph occur twice either first second circle ( occur ) polycarpus want save picture laptop problem laptops allow write hieroglyphs circle polycarp break circle write hieroglyphs a clockwise order one line a line obtain first circle call a line obtain second one call b. quite many ways break <unknown> circle polycarpus choose method make length largest substring string a occur a subsequence string b maximum help polycarpus — find maximum possible length desire substring ( subsequence ) first second circle break optimally length string s number character denote length string s |s| write string s = s1s2 ... s|s| a substring s a non - empty string x = s [ a ... b ] = <unknown> + 1 ... sb ( 1 ≤ a ≤ b ≤ |s| ) example ` ` code '' ` ` force '' substrings ` ` codeforces '' ` ` coders '' a subsequence s a non - empty string y = s [ <unknown> ... p|y| ] = <unknown> ... <unknown> ( 1 ≤ p1 < p2 < ... < p|y| ≤ |s| ) example ` ` coders '' a subsequence ` ` codeforces '' first line contain two integers la lb ( 1 ≤ la lb ≤ 1000000 ) — number hieroglyphs first second circle respectively , due difficulties encode berland hieroglyphs give integers 1 106 . second line contain la integers — hieroglyphs first picture clockwise order start one third line contain lb integers — hieroglyphs second picture clockwise order start one guarantee first circle n't contain a hieroglyph occur twice second circle also property print a single number — maximum length common substring subsequence way break circle exist print 0 . first test polycarpus pick a string consist hieroglyphs 5 1 second sample — hieroglyphs 1 3 5",['two pointers'],2000.0
1776/H,"beppa circle <unknown> friends keep date a group chat <unknown> message app swerchat $$$ ^ { \text { tm } } $$$ group $$$ n $$$ members exclude beppa members a unique i d $$$ 1 $$$ $$$ n $$$ a user open a group chat swerchat $$$ ^ { \text { tm } } $$$ display list members group sort decrease time last see online ( member open chat recently first list ) however time last see display today beppa busy day : open group chat twice 9:00 22:00 . time write list members order appear time wonder : minimum number members must online least 9:00 22:00 ? beppa sure two members ever online time members online beppa open group chat 9:00 22:00 . test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10\,000 $$$ ) — number test case descriptions $$$ t $$$ test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — number members group exclude beppa second line contain $$$ n $$$ integers $$$ a_1 \ a_2 \ \dots \ a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — list ids members sort decrease time last see online 9:00 . third line contain $$$ n $$$ integers $$$ b_1 \ b_2 \ \dots \ b_n $$$ ( $$$ 1 \le b_i \le n $$$ ) — list ids members sort decrease time last see online 22:00 . $$$ 1\le i < j\le n $$$ guarantee $$$ a_i \ne a_j $$$ $$$ b_i \ne b_j $$$ also guarantee sum value $$$ n $$$ test case exceed $$$ 100000 $$$ test case print minimum number members must online 9:00 22:00 . first test case members $$$ 4 5 $$$ must online 9:00 22:00 . second test case possible nobody online 9:00 22:00",['two pointers'],1300.0
1168/B,"<unknown> rash a binary string $$$ s $$$ a binary string consist zero ones let $$$ n $$$ length $$$ s $$$ rash need find number pair integers $$$ l $$$ $$$ r $$$ $$$ 1 \leq l \leq r \leq n $$$ least one pair integers $$$ x $$$ $$$ k $$$ $$$ 1 \leq x k \leq n $$$ $$$ l \leq x < x + 2k \leq r $$$ $$$ s_x = s _ { x+k } = s _ { x+2k } $$$ find number pair rash first line contain string $$$ s $$$ ( $$$ 1 \leq |s| \leq 300\,000 $$$ ) consist zero ones output one integer : number pair integers $$$ l $$$ $$$ r $$$ $$$ 1 \leq l \leq r \leq n $$$ least one pair integers $$$ x $$$ $$$ k $$$ $$$ 1 \leq x k \leq n $$$ $$$ l \leq x < x + 2k \leq r $$$ $$$ s_x = s _ { x+k } = s _ { x+2k } $$$ first example three $$$ l $$$ $$$ r $$$ pair need count : $$$ 1 $$$ $$$ 6 $$$ ; $$$ 2 $$$ $$$ 6 $$$ ; $$$ 1 $$$ $$$ 5 $$$ second example value $$$ x $$$ $$$ k $$$ initial string answer $$$ 0 $$$","['brute force', 'two pointers']",1900.0
1753/F,"little misha go program club solve nothing may seem strange find misha film a minecraft series everything fall place ... misha inspire manhattan build a city minecraft imagine a table size $$$ n \times m $$$ $$$ k $$$ students live a city $$$ i $$$ -th student live house locate intersection $$$ x_i $$$ -th row $$$ y_i $$$ -th column also student a degree aggressiveness $$$ w_i $$$ since city turn large misha decide <unknown> limit action series square $$$ s $$$ side parallel coordinate ax length side square integer $$$ 1 $$$ $$$ \min ( n m ) $$$ cells accord plot main hero come city accidentally fall square $$$ s $$$ possess a unique degree aggressiveness $$$ 0 $$$ able show <unknown> qualities assemble a team <unknown> <unknown> <unknown> students order assemble team <unknown> close - <unknown> degrees aggressiveness students team must pairwise distinct must form a single segment consecutive integers formally exist students degrees aggressiveness $$$ l l+1 \ldots -1 1 \ldots r-1 r $$$ inside square $$$ s $$$ $$$ l \le 0 \le r $$$ main hero able form a team $$$ r - l+1 $$$ people ( course include team ) notice require take students square $$$ s $$$ team misha think team consist least $$$ t $$$ people interest many square table main hero able form a team least $$$ t $$$ people help calculate first line contain four integers $$$ n $$$ $$$ m $$$ $$$ k $$$ $$$ t $$$ ( $$$ 1 \le n m \le 40\,000 $$$ $$$ 1 \le n \cdot m \le 40\,000 $$$ $$$ 1 \le k \le 1000000 $$$ $$$ 1 \le t \le k + 1 $$$ ) — number row columns table number students live city respectively follow $$$ k $$$ line contain three integers $$$ x_i $$$ $$$ y_i $$$ $$$ w_i $$$ ( $$$ 1 \le x_i \le n $$$ $$$ 1 \le y_i \le m $$$ $$$ 1 \le \lvert w_i \rvert \le 1000000000 $$$ ) — number row column $$$ i $$$ -th student live degree aggressiveness print one integer — number ways choose square $$$ s $$$ way main hero able form a team least $$$ t $$$ people","['brute force', 'two pointers']",3500.0
430/B,iahub train ioi a better way train play a <unknown> - like game ? n ball put a row ball color one k color initially row n't contain three contiguous ball color iahub a single ball color x. insert ball position row ( probably two ball ) moment three contiguous ball color row destroy immediately rule apply multiple time set 3 contiguous ball color example iahub row ball [ black black white white black black ] a white ball insert ball two white ball thus three white ball destroy four black ball become contiguous four ball destroy row contain ball end iahub destroy 6 ball iahub want destroy many ball possible give description row ball color iahub 's ball help iahub train ioi tell maximum number ball row destroy first line input contain three integers : n ( 1 ≤ n ≤ 100 ) k ( 1 ≤ k ≤ 100 ) x ( 1 ≤ x ≤ k ) next line contain n space - separated integers c1 c2 ... cn ( 1 ≤ ci ≤ k ) number ci mean i - th ball row color ci guarantee initial row ball never contain three contiguous ball color print a single integer — maximum number ball iahub destroy,"['brute force', 'two pointers']",1400.0
1190/A,recently tokitsukaze find interest game tokitsukaze $$$ n $$$ items begin game however think many items want discard $$$ m $$$ ( $$$ 1 \le m \le n $$$ ) special items $$$ n $$$ items mark indices $$$ 1 $$$ $$$ n $$$ begin item index $$$ i $$$ place $$$ i $$$ -th position items divide several page <unknown> page contain exactly $$$ k $$$ position last position last page may leave empty tokitsukaze would follow operation : focus first special page contain least one special item one time tokitsukaze would discard special items page item discard move old position would empty item exist would move empty position movement may bring many items forward even previous page tokitsukaze would keep wait items stop move operation ( i.e check special page discard special items ) repeatedly item need discard tokitsukaze want know number operations would total first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n \le 10^ { 18 } $$$ $$$ 1 \le m \le 100000 $$$ $$$ 1 \le m k \le n $$$ ) — number items number special items discard number position page second line contain $$$ m $$$ distinct integers $$$ p_1 p_2 \ldots p_m $$$ ( $$$ 1 \le p_1 < p_2 < \ldots < p_m \le n $$$ ) — indices special items discard print a single integer — number operations tokitsukaze would total first example : second example tokitsukaze would focus second page $$$ [ 6 7 8 9 10 ] $$$ discard special items,"['implementation', 'two pointers']",1400.0
842/A,kirill play a new computer game come potion store buy potion potion characterize two integers — amount experience cost efficiency a potion <unknown> amount experience cost efficiency may a non - integer number two integer number a b l ≤ a ≤ r x ≤ b ≤ y a potion experience a cost b store ( ( r - l + 1 ) · ( y - x + 1 ) <unknown> ) kirill want buy a potion efficiency k. able ? first string contain five integer number l r x y k ( 1 ≤ l ≤ r ≤ 107 1 ≤ x ≤ y ≤ 107 1 ≤ k ≤ 107 ) print ` ` yes '' without quote a potion efficiency exactly k buy store ` ` '' without quote otherwise output letter register,"['brute force', 'two pointers']",1200.0
1728/D,alice bob play a game initially give a non - empty string $$$ s $$$ consist lowercase latin letter length string even player also a string initially empty alice start alternate move one move a player take either first last letter string $$$ s $$$ remove $$$ s $$$ <unknown> ( add begin ) string game end string $$$ s $$$ become empty winner player a lexicographically smaller string players ' string equal 's a draw a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ exist position $$$ i $$$ $$$ a_j = b_j $$$ $$$ j < i $$$ $$$ a_i < b_i $$$ result game players play optimally ( e. g. players try win ; ca n't try draw ) ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases testcase consist a single line — a non - empty string $$$ s $$$ consist lowercase latin letter length string $$$ s $$$ even total length string testcases n't exceed $$$ 2000 $$$ testcase print result game players play optimally alice win print ` ` alice '' bob win print ` ` bob '' 's a draw print ` ` draw '' one possible game alice bob play first testcase : alice win ` ` <unknown> '' < ` ` <unknown> '' neither players follow strategy particular example game n't show alice win play optimally,"['dp', 'two pointers']",1800.0
1600/E,alice bob play a game give array $$$ a $$$ length $$$ n $$$ array consist integers build a sequence together begin sequence empty one turn a player remove a number leave right side array append sequence rule sequence build must strictly increase winner player make last move alice play first give start array <unknown> play optimally win game ? first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 2 * 100000 $$$ ) - length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) first line output consist one string name winner alice print ` ` alice '' otherwise print ` ` bob '',"['greedy', 'two pointers']",1900.0
498/B,"turn a great fan rock <unknown> ac / pe peter learn start follow game : play first song list n songs group find name song tell song name peter immediately play follow song order , i - th song ac / pe recognizability pi mean song yet recognize listen exactly one second probability pi percent recognize tell 's name otherwise continue listen note try guess integer number second moment song start play ac / pe songs first word chorus title ' ve hear first ti second i - th song chorus start immediately guess name sure example song <unknown> red chorus sound pretty late song high recognizability song back blue hand word title sound close begin song 's hard name hear word name songs a first second determine expect number songs recognize game last exactly t second ( i. e. make last guess second t game stop ) songs recognize faster t second game stop last song recognize first line input contain number n t ( 1 ≤ n ≤ 5000 1 ≤ t ≤ 5000 ) separate a space next n line contain pair number pi ti ( 0 ≤ pi ≤ 100 1 ≤ ti ≤ t ) songs give order petya 's list output a single number — expect number number songs recognize t second answer consider correct absolute relative error exceed 10 - 6","['dp', 'two pointers']",2400.0
6/C,alice bob like game ready start a new game place n chocolate bar a line alice start eat chocolate bar one one leave right bob — right leave <unknown> bar time need player consume know ( alice bob eat equal speed ) player consume a chocolate bar immediately start another allow eat two chocolate bar time leave bar <unknown> make <unknown> players start eat bar simultaneously bob leave alice a true <unknown> many bar players consume ? first line contain one integer n ( 1 ≤ n ≤ 105 ) — amount bar table second line contain a sequence t1 t2 ... tn ( 1 ≤ ti ≤ 1000 ) ti time ( second ) need consume i - th bar ( order leave right ) print two number a b a amount bar consume alice b amount bar consume bob,"['greedy', 'two pointers']",1200.0
253/D,vasya recently start learn english need remember write english letter n't sure decide train a little find a sheet square paper begin write arbitrary english letter end vasya write n line contain m character thus get a rectangular n × m table cell table contain english letter let 's number table row top bottom integers 1 n columns — leave right integers 1 m. vasya look result rectangular table wonder many subtables match follow condition : formally a subtable 's definition follow define four integers x1 y1 x2 y2 1 ≤ x1 < x2 ≤ n 1 ≤ y1 < y2 ≤ m. subtable contain cells ( x y ) ( x row number y column number ) follow inequality hold x1 ≤ x ≤ x2 y1 ≤ y ≤ y2 corner cells table cells ( x1 y1 ) ( x1 y2 ) ( x2 y1 ) ( x2 y2 ) vasya already tire 's write letter a piece paper 's ask count value interest first line contain three integers n m k ( 2 ≤ n m ≤ 400 ; 0 ≤ k ≤ n·m ) next n line contain m character — give table character table a lowercase english letter print a single integer — number require subtables two suitable subtables first sample : first one 's upper leave corner cell ( 2 2 ) lower right corner cell ( 3 3 ) second one 's upper leave corner cell ( 2 1 ) lower right corner cell ( 3 4 ),"['brute force', 'two pointers']",2000.0
716/B,"zs coder love read dictionary think a word nice exist a substring ( contiguous segment letter ) length 26 letter english alphabet appear exactly particular string length strictly less 26 substring exist thus nice , zs coder tell a word letter miss forget want determine possible fill miss letter result word nice possible need find example a word well help ? first line input contain a single string s ( 1 ≤ |s| ≤ 50 000 ) word zs coder remember character string uppercase letter english alphabet ( ' <unknown> ' z ' ) a question mark ( ' ? ' ) question mark denote letter zs coder ca n't remember way replace question mark uppercase letter result word nice print - 1 line otherwise print a string denote a possible nice word zs coder learn string match string input except question mark replace uppercase english letter multiple solutions may print first sample case <unknown> a valid answer <unknown> contain a substring length 26 ( whole string case ) contain letter english alphabet exactly note many possible solutions <unknown> <unknown> second sample case miss letter addition give string a substring length 26 contain letter alphabet answer - 1 . third sample case string length 26 contain letter english alphabet fit answer","['greedy', 'two pointers']",1300.0
682/E,"give n point integer coordinate plane point give a way triangle form three n point area exceed s. alyona try construct a triangle integer coordinate contain n point area n't exceed 4s , obvious reason success please help alyona construct triangle please note vertices result triangle necessarily choose n give point first line input two integers n s ( 3 ≤ n ≤ 5000 1 ≤ s ≤ 1018 ) give — number point give upper bind value triangle 's area form three give n point next n line describe give point : ith consist two integers xi yi ( - 108 ≤ xi yi ≤ 108 ) — coordinate ith point guarantee least one triple point lie line print coordinate three point — vertices a triangle contain n point area n't exceed 4s coordinate every triangle 's vertex print a separate line every coordinate pair separate a single space coordinate integers exceed 109 absolute value guarantee least one desire triangle one answer print","['geometry', 'two pointers']",2600.0
611/G,limak a little polar bear accord old <unknown> bear family prepare a new year cake limak like cake may know a new year cake a strictly convex polygon n vertices parent wo n't allow limak eat half a cake would get sick think decide cut a cake along one n · ( n - 3 ) / 2 diagonals limak get a non - greater piece limak understand rule wo n't happy second piece happen much bigger limak 's disappointment equal difference piece ' areas multiply two prove integer give constraints n · ( n - 3 ) / 2 possible scenarios consider find sum value limak 's disappointment modulo 109 + 7 . first line input contain a single integer n ( 4 ≤ n ≤ 500 000 ) — number vertices polygon denote cake next n line contain two integers xi yi ( |xi| |yi| ≤ 109 ) — coordinate i - th point 's guarantee point distinct polygon strictly convex point give clockwise order print sum value limak 's disappointment possible scenarios modulo 109 + 7 . first sample possible value limak 's disappointment 0 18 18 24 30,"['geometry', 'two pointers']",2900.0
309/B,"advertise become part routine , <unknown> progressive technologies need ideas make advertise better ! problem 'll look a simplify version <unknown> advertise ' ve get a text consist exactly n word a standard advertise banner exactly r line line contain c character potential customer always like see lot advertise determine maximum number consecutive word text write banner single word one line banner separate space allow insert one space note allow break word , word text must occupy exactly one line banner besides change word order , read banner text consecutively top bottom leave right get consecutive part advertisement text formally statement write like let 's say word index 1 n order occur advertisement text choose word start i - th one end j - th one ( 1 ≤ i ≤ j ≤ n ) could write banner must many word possible see sample clarifications first input line contain three integers n r c ( 1 ≤ n r c ≤ 106 ; r × c ≤ 106 ) next line contain a text consist n word word consist lowercase english letter empty word line separate single space total number character word n't exceed 5·106 print r line line print c character — optimal advertisement banner multiple advertisement <unknown> print note line banner empty allow print line","['dp', 'two pointers']",2100.0
264/D,two sequence colorful stone color stone one red green blue give two string s t. i - th ( 1 - based ) character s represent color i - th stone first sequence similarly i - th ( 1 - based ) character t represent color i - th stone second sequence character ` ` r '' ` ` g '' ` ` b '' color correspond stone red green blue respectively initially squirrel liss stand first stone first sequence cat vasya stand first stone second sequence perform follow instructions zero time instruction one three type : ` ` red '' ` ` green '' ` ` blue '' instruction c animals stand stone whose color c move one stone forward example perform instruction « red » animals stand red stone move one stone forward allow perform instructions lead animals sequence word animals stand last stone ca n't perform instructions color stone a pair position ( position liss position vasya ) call a state a state call reachable state reachable perform instructions zero time initial state ( 1 1 ) calculate number distinct reachable state input contain two line first line contain string s ( 1 ≤ |s| ≤ 106 ) second line contain string t ( 1 ≤ |t| ≤ 106 ) character string one ` ` r '' ` ` g '' ` ` b '' print number distinct reachable state a single line please write % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first example five reachable state : ( 1 1 ) ( 2 2 ) ( 2 3 ) ( 3 2 ) ( 3 3 ) example state ( 3 3 ) reachable perform instructions ` ` red '' ` ` green '' ` ` blue '' order initial state state ( 3 3 ) follow picture show instructions work case,"['dp', 'two pointers']",2500.0
250/D,two villages separate a river flow north south villagers want build a bridge across river make easier move across villages river bank assume vertical straight line x = a x = b ( 0 < a < b ) west village lie a <unknown> point o = ( 0 0 ) n pathways lead village river end point ai = ( a yi ) villagers plain simple pathways straight segment well east village reserve <unknown> people village forest east bank river exact position clear m <unknown> paths lead village river end point bi = ( b y ' i ) lengths paths know length path lead eastern village point bi equal li villagers want choose exactly one point leave bank river ai exactly one point right bank bj connect a straight - line bridge make total distance villages ( sum <unknown> + <unknown> + lj <unknown> euclidean distance point x y ) minimum euclidean distance point ( x1 y1 ) ( x2 y2 ) equal help find require pair point first line contain integers n m a b ( 1 ≤ n m ≤ 105 0 < a < b < 106 ) second line contain n integers ascend order : i - th integer determine coordinate point ai equal yi ( |yi| ≤ 106 ) third line contain m integers ascend order : i - th integer determine coordinate point bi equal y ' i ( |y ' i| ≤ 106 ) fourth line contain m integers : i - th determine length path connect eastern village point bi equal li ( 1 ≤ li ≤ 106 ) guarantee a point c <unknown> least b <unknown> ≤ li i ( 1 ≤ i ≤ m ) guarantee two point ai coincide guarantee two point bi coincide print two integers — number point leave ( west ) right ( east ) bank respectively need build a bridge assume point west bank number 1 n order give input similarly point east bank number 1 m order give input multiple solutions print solution accept final length path differ answer jury 10 - 6 absolute relative value,"['geometry', 'two pointers']",1900.0
55/E,give a convex polygon count please number triangles contain a give point plane vertices vertices polygon guarantee point n't lie side diagonals polygon first line contain integer n — number vertices polygon ( 3 ≤ n ≤ 100000 ) polygon description follow : n line contain coordinate vertices clockwise order ( integer x y greater 109 absolute value ) guarantee give polygon nondegenerate convex ( three point lie line ) next line contain integer t ( 1 ≤ t ≤ 20 ) — number point count answer follow t line coordinate point ( integer x y greater 109 absolute value ) output contain t integer number a separate line i - th number answer i - th point please use % lld specificator read write 64 - bit integers c++ preffered use cin ( also may use % i64d ),"['geometry', 'two pointers']",2500.0
744/E,hongcow 's teacher hear hongcow learn cyclic shift decide set follow problem give a list n string s1 s2 ... sn contain list a. a list x string call stable follow condition hold first a message define a concatenation elements list x. use arbitrary element many time want may concatenate elements arbitrary order let sx denote set message construct list course set infinite size list nonempty call a single message good follow condition hold : list x call stable every element sx good let f ( l ) 1 l a stable list 0 otherwise find sum f ( l ) l a nonempty contiguous <unknown> a ( contiguous sublists total ) first line input contain a single integer n ( 1 ≤ n ≤ 30 ) denote number string list next n line contain a string si ( ) print a single integer number nonempty contiguous sublists stable first sample 10 sublists consider sublists [ ` ` a '' ` ` ab '' ` ` b '' ] [ ` ` ab '' ` ` b '' ` ` bba '' ] [ ` ` a '' ` ` ab '' ` ` b '' ` ` bba '' ] stable seven sublists stable example x = [ ` ` a '' ` ` ab '' ` ` b '' ] stable since message ` ` ab '' + ` ` ab '' = ` ` abab '' four cyclic shift [ ` ` abab '' ` ` baba '' ` ` abab '' ` ` baba '' ] elements sx,"['strings', 'two pointers']",3200.0
769/B,polycarp study university group consist n students ( include ) <unknown> social net ` ` <unknown> ! ` ` students equally <unknown> student know value ai — maximum number message i - th student agree send per day student ca n't send message early morning polycarp know important news program credit tomorrow reason necessary <unknown> inform <unknown> news use private message task make a plan use private message : let 's consider students numerate distinct number 1 n polycarp always number 1 . task n't minimize number message moment time know credit parameters find way use private message satisfy requirements first line contain positive integer n ( 2 ≤ n ≤ 100 ) — number students second line contain sequence a1 a2 ... ( 0 ≤ ai ≤ 100 ) ai equal maximum number message i - th student agree send consider polycarp always number 1 . print -1 first line impossible inform students credit otherwise first line print integer k — number message send next k line print two distinct integers f t mean student number f send message news student number t. message print chronological order mean student send message must already know news assume students receive repeat message news credit several answer acceptable print first test polycarp ( student number 1 ) send message student number 2 send message students number 3 4 . thus students know credit,"['greedy', 'two pointers']",1200.0
788/A,something happen uzhlyandia ... riot streets ... famous uzhlyandian superheroes <unknown> <unknown> <unknown> <unknown> call order save situation upon arrive find citizens <unknown> maximum value main uzhlyandian function f define follow : formula 1 ≤ l < r ≤ n must hold n size main uzhlyandian array a |x| mean absolute value x. heroes skip math lessons school ask help help calculate maximum value f among possible value l r give array a. first line contain single integer n ( 2 ≤ n ≤ 105 ) — size array a. second line contain n integers a1 a2 ... ( <unknown> ≤ ai ≤ 109 ) — array elements print integer — maximum value f. first sample case optimal value f reach intervals [ 1 2 ] [ 2 5 ] second case maximal value f reachable whole array,"['dp', 'two pointers']",1600.0
76/B,modern research show a flock hungry mice search a piece cheese act follow : several piece cheese mouse choose closest one mice start move towards choose piece cheese a mouse several mice achieve destination point still a piece cheese eat become well - <unknown> mice reach point remain hungry move speed mice equal several ways choose closest piece mice choose a way would minimize number hungry mice check theory scientists decide conduct experiment locate n mice m piece cheese a cartesian plane mice locate line y = y0 piece cheese — another line y = y1 check result experiment scientists need a program simulate behavior a flock hungry mice write a program compute minimal number mice remain hungry i.e without cheese first line input contain four integer number n ( 1 ≤ n ≤ 105 ) m ( 0 ≤ m ≤ 105 ) y0 ( 0 ≤ y0 ≤ 107 ) y1 ( 0 ≤ y1 ≤ 107 y0 ≠ y1 ) second line contain a strictly increase sequence n number — x coordinate mice third line contain a strictly increase sequence m number — x coordinate cheese coordinate integers exceed 107 absolute value line output contain one number — minimal number mice remain without cheese three mice choose first piece cheese second third mice eat piece first one remain hungry run towards piece late second piece cheese remain <unknown>,"['greedy', 'two pointers']",2100.0
220/E,little elephant array a consist n positive integers index 1 n. let 's denote number index i ai little elephant want count many pair integers l r 1 ≤ l < r ≤ n sequence b = a1a2 ... <unknown> + 1 ... k inversions inversion sequence b a pair elements sequence b change relative order a stable sort sequence word inversion a pair integers i j 1 ≤ i < j ≤ |b| bi > bj |b| length sequence b bj j - th element help little elephant count number describe pair first line contain two integers n k ( 2 ≤ n ≤ 105 0 ≤ k ≤ 1018 ) — size array a maximum allow number inversions respectively next line contain n positive integers separate single space a1 a2 ... ( 1 ≤ ai ≤ 109 ) — elements array a. please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier a single line print a single number — answer problem,"['data structures', 'two pointers']",2400.0
1364/B,"give a permutation $$$ p $$$ length $$$ n $$$ find subsequence $$$ s_1 $$$ $$$ s_2 $$$ $$$ \ldots $$$ $$$ s_k $$$ length least $$$ 2 $$$ : multiple subsequences satisfy condition allow find a sequence $$$ a $$$ a subsequence array $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ delete ( possibly zero ) elements a permutation length $$$ n $$$ array length $$$ n $$$ every element $$$ 1 $$$ $$$ n $$$ occur exactly first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — length permutation $$$ p $$$ second line test case contain $$$ n $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ $$$ \ldots $$$ $$$ p _ { n } $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i $$$ distinct ) — elements permutation $$$ p $$$ sum $$$ n $$$ across test case n't exceed $$$ 100000 $$$ test case first line contain length find subsequence $$$ k $$$ second line contain $$$ s_1 $$$ $$$ s_2 $$$ $$$ \ldots $$$ $$$ s_k $$$ — elements multiple subsequences satisfy condition allow find first test case $$$ 4 $$$ subsequences length least $$$ 2 $$$ : answer either $$$ [ 3,1 ] $$$ $$$ [ 3,2,1 ] $$$ since want subsequence short possible answer $$$ [ 3,1 ] $$$","['greedy', 'two pointers']",1300.0
1252/E,"andi a mathematician a computer scientist a <unknown> spend much time write songs finally write a <unknown> melody think best <unknown> however <unknown> <unknown> song / melody a unique vocal range thus <unknown> may need a melody define a sequence $$$ n $$$ note represent integers let $$$ a $$$ original melody write andi andi need <unknown> $$$ a $$$ a new melody $$$ b $$$ every $$$ i $$$ $$$ 1 \le i < n $$$ : help andi determine whether $$$ b $$$ exist find lexicographically smallest $$$ b $$$ exist a melody $$$ x $$$ lexicographically smaller melody $$$ y $$$ exist $$$ j $$$ ( $$$ 1 \le j \le n $$$ ) $$$ x_i = y_i $$$ $$$ i < j $$$ $$$ x _ { j } < y _ { j } $$$ example consider a melody $$$ a = \ { <unknown> } $$$ show follow figure diagonal arrow figure imply $$$ a_i < a _ { i+1 } $$$ straight right arrow imply $$$ a_i = a _ { i+1 } $$$ diagonal arrow imply $$$ a_i > a _ { i+1 } $$$ suppose want make a new melody $$$ l = 1 $$$ $$$ r = 8 $$$ $$$ k = 6 $$$ new melody $$$ b = \ { <unknown> } $$$ show figure satisfy requirements lexicographically smallest possible input begin a line contain four integers : $$$ n $$$ $$$ l $$$ $$$ r $$$ $$$ k $$$ ( $$$ 1 \le n \le 100\,000 $$$ ; $$$ 1 \le l \le r \le 1000000000 $$$ ; $$$ 1 \le k \le 1000000000 $$$ ) represent number note melody vocal range ( $$$ l $$$ $$$ r $$$ ) maximum difference two <unknown> note new melody respectively next line contain $$$ n $$$ integers : $$$ a_i $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) represent original melody output a line $$$ n $$$ integers ( separate a single space ) represent lexicographically smallest melody satisfy requirements output -1 melody satisfy requirements note might possible lexicographically smallest melody satisfy requirements original melody explanation sample input / output # 1this example problem description","['greedy', 'two pointers']",2200.0
1251/C,give a huge integer $$$ a $$$ consist $$$ n $$$ digits ( $$$ n $$$ $$$ 1 $$$ $$$ 300000 $$$ inclusive ) may contain lead zero swap two digits adjacent ( neighbor ) position swap digits different parity ( different remainder divide $$$ 2 $$$ ) example $$$ a = <unknown> $$$ get follow integers a single operation : note ca n't swap digits position $$$ 2 $$$ $$$ 4 $$$ position adjacent also ca n't swap digits position $$$ 3 $$$ $$$ 4 $$$ digits parity perform number ( possibly zero ) operations find minimum integer obtain note result integer also may contain lead zero first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case input line test case contain integer $$$ a $$$ length $$$ n $$$ $$$ 1 $$$ $$$ 300000 $$$ inclusive guarantee sum value $$$ n $$$ exceed $$$ 300000 $$$ test case print line — minimum integer obtain first test case perform follow sequence operations ( pair swap digits highlight ) : $$$ 0 \underline { \textbf { <unknown> } } 9 \rightarrow <unknown> $$$ second test case initial integer optimal third test case perform follow sequence operations : $$$ <unknown> \underline { \textbf { 43 } } 2 \rightarrow 24 \underline { \textbf { 63 } } 42 \rightarrow 2 \underline { \textbf { 43 } } <unknown> \rightarrow <unknown> $$$,"['greedy', 'two pointers']",1600.0
1195/E,"seryozha conduct a course dedicate build a map heights <unknown> recreation center lay a rectangle grid size $$$ n \times m $$$ cells a map ( row grid number $$$ 1 $$$ $$$ n $$$ north south columns number $$$ 1 $$$ $$$ m $$$ west east ) measure average height cell <unknown> sea level obtain a matrix heights size $$$ n \times m $$$ cell $$$ ( i j ) $$$ lie intersection $$$ i $$$ -th row $$$ j $$$ -th column height $$$ h _ { i j } $$$ seryozha go look result work browser screen seryozha 's laptop fit a subrectangle size $$$ a \times b $$$ matrix heights ( $$$ 1 \le a \le n $$$ $$$ 1 \le b \le m $$$ ) seryozha try decide weather affect recreation center — example rain <unknown> gather , go find cell minimum height among cells show screen laptop help seryozha calculate sum heights cells possible <unknown> see screen word calculate sum minimum heights submatrices size $$$ a \times b $$$ top leave corner $$$ ( i j ) $$$ $$$ 1 \le i \le n - a + 1 $$$ $$$ 1 \le j \le m - b + 1 $$$ consider sequence $$$ g_i = ( g _ { i - 1 } \cdot x + y ) \bmod z $$$ give integers $$$ g_0 $$$ $$$ x $$$ $$$ y $$$ $$$ z $$$ miraculous coincidence $$$ h _ { i j } = g _ { ( i - 1 ) \cdot m + j - 1 } $$$ ( $$$ ( i - 1 ) \cdot m + j - 1 $$$ index ) first line input contain four integers $$$ n $$$ $$$ m $$$ $$$ a $$$ $$$ b $$$ ( $$$ 1 \le n m \le <unknown> $$$ $$$ 1 \le a \le n $$$ $$$ 1 \le b \le m $$$ ) — number row columns matrix seryozha number row columns show screen laptop respectively second line input contain four integers $$$ g_0 $$$ $$$ x $$$ $$$ y $$$ $$$ z $$$ ( $$$ 0 \le g_0 x y < z \le 1000000000 $$$ ) print a single integer — answer problem matrix first example :","['data structures', 'two pointers']",2100.0
1066/B,vova 's house array consist $$$ n $$$ elements ( yeah first problem i think someone live array ) heaters position array $$$ i $$$ -th element array $$$ 1 $$$ a heater position $$$ i $$$ otherwise $$$ i $$$ -th element array $$$ 0 $$$ heater a value $$$ r $$$ ( $$$ r $$$ heaters ) value mean heater position $$$ pos $$$ warm elements range $$$ [ pos - r + 1 ; pos + r - 1 ] $$$ vova like walk house think hat cold position house vova want switch heaters a way element house warm least one heater vova 's target warm whole house ( elements array ) i.e $$$ n = 6 $$$ $$$ r = 2 $$$ heaters position $$$ 2 $$$ $$$ 5 $$$ vova warm whole house switch heaters house ( first $$$ 3 $$$ elements warm first heater last $$$ 3 $$$ elements warm second heater ) initially heaters hand vova n't like pay much <unknown> want switch minimum number heaters a way element house warm least one heater task find number heaters say impossible warm whole house first line input contain two integers $$$ n $$$ $$$ r $$$ ( $$$ 1 \le n r \le 1000 $$$ ) — number elements array value heaters second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 1 $$$ ) — vova 's house description print one integer — minimum number heaters need warm whole house -1 impossible first example heater position $$$ 2 $$$ warm elements $$$ [ 1 ; 3 ] $$$ heater position $$$ 3 $$$ warm elements $$$ [ 2 4 ] $$$ heater position $$$ 6 $$$ warm elements $$$ [ 5 ; 6 ] $$$ answer $$$ 3 $$$ second example heater position $$$ 1 $$$ warm elements $$$ [ 1 ; 3 ] $$$ heater position $$$ 5 $$$ warm elements $$$ [ 3 ; 5 ] $$$ answer $$$ 2 $$$ third example heaters answer -1 . fourth example heater position $$$ 3 $$$ warm elements $$$ [ 1 ; 5 ] $$$ heater position $$$ 6 $$$ warm elements $$$ [ 4 ; 8 ] $$$ heater position $$$ 10 $$$ warm elements $$$ [ 8 ; 10 ] $$$ answer $$$ 3 $$$,"['greedy', 'two pointers']",1500.0
1036/D,vasya two array $$$ a $$$ $$$ b $$$ lengths $$$ n $$$ $$$ m $$$ respectively perform follow operation arbitrary number time ( possibly zero ) : take consecutive subsegment array replace a single element equal sum elements subsegment example array $$$ [ 1 10 100 1000 10000 ] $$$ vasya obtain array $$$ [ 1 <unknown> 10000 ] $$$ array $$$ [ 1 2 3 ] $$$ vasya obtain array $$$ [ 6 ] $$$ two array $$$ a $$$ $$$ b $$$ consider equal length valid $$$ i $$$ $$$ a_i = b_i $$$ vasya want perform operations array $$$ a $$$ array $$$ b $$$ a way array $$$ a $$$ $$$ b $$$ become equal moreover lengths result array maximal possible help vasya determine maximum length array achieve output impossible make array $$$ a $$$ $$$ b $$$ equal first line contain a single integer $$$ n~ ( 1 \le n \le 3 \cdot 100000 ) $$$ — length first array second line contain $$$ n $$$ integers $$$ a_1 a_2 \cdots a_n~ ( 1 \le a_i \le 1000000000 ) $$$ — elements array $$$ a $$$ third line contain a single integer $$$ <unknown> ( 1 \le m \le 3 \cdot 100000 ) $$$ — length second array fourth line contain $$$ m $$$ integers $$$ b_1 b_2 \cdots <unknown> ( 1 \le b_i \le 1000000000 ) $$$ - elements array $$$ b $$$ print a single integer — maximum length result array operations perform array $$$ a $$$ $$$ b $$$ a way become equal way make array equal print ` ` -1 '',"['greedy', 'two pointers']",1600.0
887/D,two main kinds events life top - model : fashion show photo shoot participate events affect rat appropriate top - model photo shoot model 's rat increase a fashion show decrease b ( designers many experiment nowadays ) moreover sometimes top - <unknown> participate talk show participate talk show model become popular increase rat photo shoot become c decrease rat fashion show become d. izabella want participate a talk show want a way rat never become negative help find a suitable moment participate talk show let 's assume model 's <unknown> begin moment 0 . moment izabella 's rat equal start talk show happen moment t affect events model 's life interval time [ t .. t + len ) ( include t include t + len ) len duration influence izabella want participate a talk show want a way rat become become negative talk show period influence talk show help find a suitable moment participate talk show first line 7 positive integers n a b c d start len ( 1 ≤ n ≤ 3·105 0 ≤ start ≤ 109 1 ≤ a b c d len ≤ 109 ) n a number fashion show photo shoot a b c d rat change describe start initial rat model len a duration influence talk show next n line descriptions events give line contain two integers ti qi ( 1 ≤ ti ≤ 109 0 ≤ q ≤ 1 ) — moment event happen type event type 0 correspond fashion show type 1 — photo shoot events give order increase ti ti different print one non - negative integer t — moment time talk show happen make izabella 's rat non - negative talk show period influence talk show multiple answer print smallest moments print - 1,"['data structures', 'two pointers']",2400.0
873/C,"ivan play a strange game a matrix a n row m columns element matrix equal either 0 1 . row columns 1 - indexed ivan replace number ones matrix zero , score game calculate follow : course ivan want maximize score strange game also n't want change many elements replace minimum possible number ones zero help determine maximum possible score get minimum possible number replacements require achieve score first line contain three integer number n m k ( 1 ≤ k ≤ n ≤ 100 1 ≤ m ≤ 100 ) n line follow i - th contain m integer number — elements i - th row matrix a. number either 0 1 . print two number : maximum possible score ivan get minimum number replacements require get score first example ivan replace element a1 2","['greedy', 'two pointers']",1600.0
771/F,bearland a big square plane contain point coordinate exceed 106 absolute value n house bearland i - th locate point ( xi yi ) n point distinct subsets may collinear bear limak live first house want destroy house build a new one somewhere bearland bear n't like big change every three point ( house ) pi pj pk sign cross product ( pj - pi ) × ( pk - pi ) relocation negative / positive / zero still negative / positive / zero respectively condition satisfy triple indices ( i j k ) possibly equal different 1 . additionally limak n't allow build house point house already exist ( point old house ) formula define difference cross product point ( ax ay ) ( bx ) : consider a set possible new placements limak 's house task find area set point formally let 's say limak choose new placement randomly ( coordinate choose independently uniformly random interval [ - 106 106 ] ) let p denote probability get allow placement new house let s denote area bearland ( s = <unknown> ) task find <unknown> first line input contain integer t ( 1 ≤ t ≤ 500 ) — number test case description test case follow first line description a test case contain integer n ( 3 ≤ n ≤ 200 000 ) — number house i - th next n line contain two integers xi yi ( - 106 ≤ xi yi ≤ 106 ) — coordinate i - th house two house locate point test case limak live first house sum n wo n't exceed 200 000 . print one real value denote area set point possible new placements limak 's house answer consider correct absolute relative error n't exceed 10 - 6 . precisely let jury 's answer b answer a. answer accept sample test 4 test case first test case four house limak 's one ( 5 3 ) set valid new placements form a triangle vertices point ( 0 1 ) ( 10 1 ) ( 3 <unknown> ) without side area a triangle 250 . second test case set valid new placements form a rectangle width 50 000 height 2 000 000 . n't forget new placement must inside big square represent bearland third test case three give point collinear cross product equal 0 0 relocation well hence limak 's new house must lie line go give point since must also inside big square new possible placements limit segment ( exclude two point house ) area segment 0,"['geometry', 'two pointers']",3300.0
1547/C,monocarp polycarp learn new program techniques decide try pair program 's know work together file $$$ n + m $$$ minutes every minute exactly one make one change file start already $$$ k $$$ line write file every minute exactly one one two action : add a new line end file change one line monocarp work total $$$ n $$$ minutes perform sequence action $$$ [ a_1 a_2 \dots a_n ] $$$ $$$ a_i = 0 $$$ add a new line end file $$$ a_i > 0 $$$ change line number $$$ a_i $$$ monocarp perform action strictly order : $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ polycarp work total $$$ m $$$ minutes perform sequence action $$$ [ b_1 b_2 \dots b_m ] $$$ $$$ b_j = 0 $$$ add a new line end file $$$ b_j > 0 $$$ change line number $$$ b_j $$$ polycarp perform action strictly order : $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_m $$$ restore common sequence action length $$$ n + m $$$ action would correct — change line yet exist keep mind common sequence monocarp 's action form subsequence $$$ [ a_1 a_2 \dots a_n ] $$$ polycarp 's — subsequence $$$ [ b_1 b_2 \dots b_m ] $$$ replace computer number time let 's look example suppose $$$ k = 3 $$$ monocarp first change line number $$$ 2 $$$ add a new line ( thus $$$ n = 2 \ : a = [ 2 0 ] $$$ ) polycarp first add a new line change line number $$$ 5 $$$ ( thus $$$ m = 2 \ : b = [ 0 5 ] $$$ ) since initial length file $$$ 3 $$$ order polycarp change line number $$$ 5 $$$ two new line must add beforehand examples correct sequence change case would $$$ [ 0 2 0 5 ] $$$ $$$ [ 2 0 0 5 ] $$$ change $$$ [ 0 0 5 2 ] $$$ ( wrong order action ) $$$ [ 0 5 2 0 ] $$$ ( line $$$ 5 $$$ edit yet ) correct first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) $$$ t $$$ test case follow test case empty line test case contain three line first line contain three integers $$$ k $$$ $$$ n $$$ $$$ m $$$ ( $$$ 0 \le k \le 100 $$$ $$$ 1 \le n m \le 100 $$$ ) — initial number line file lengths monocarp 's polycarp 's sequence change respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 300 $$$ ) third line contain $$$ m $$$ integers $$$ b_1 b_2 \dots b_m $$$ ( $$$ 0 \le b_j \le 300 $$$ ) test case print correct common sequence monocarp 's polycarp 's action length $$$ n + m $$$ -1 sequence n't exist,"['greedy', 'two pointers']",1100.0
131/F,"many star sky ? a young programmer polycarpus ca n't get question head ! take a photo <unknown> sky use digital camera analyze result <unknown> digital picture picture represent a rectangular matrix consist n line contain m character a character equal ' 1 ' correspond photo pixel white ' 0 ' black polycarpus think find a star photo find a white pixel surround four side - neighboring pixels also white : polycarpus <unknown> s cut a rectangular area photo give mom a present area contain less k star star intersect share white pixels photo boy cut rectangular area border parallel side photo cut go straight pixel border polycarpus keep wonder many ways cut area photo meet condition give help polycarpus find number first line input data contain three integers n m k ( 1 ≤ n m ≤ 500 ; 1 ≤ k ≤ nm ) follow n line contain description give photo a sequence line line contain m character ' 0 ' ' 1 ' print require number areas give photo 'll number row columns start 1 coordinate ( p q ) denote a cell row p column q. first sample polycarpus cut area contain a rectangle whose opposite corner lie cells ( 1 1 ) ( 3 4 ) rectangles opposite corner ( 1 1 ) ( x y ) x ≥ 3 y ≥ 4 fit condition second sample rectangle whose side less four , possible rectangle size 4 × 4 4 × 5 5 × 4 5 × 5 . figure cut 4 ways 2 ways 2 ways 1 way correspondingly please use % lld specificator read write 64 - bit integers c++ prefer use cin cout stream % i64d specificator","['binary search', 'two pointers']",2000.0
1610/B,array $$$ [ b_1 b_2 \ldots b_m ] $$$ a palindrome $$$ b_i = b _ { m+1 - i } $$$ $$$ i $$$ $$$ 1 $$$ $$$ m $$$ empty array also a palindrome array call kalindrome follow condition hold : 's possible select integer $$$ x $$$ delete elements array equal $$$ x $$$ remain array ( glue together remain part ) a palindrome note n't delete elements equal $$$ x $$$ n't delete least one element equal $$$ x $$$ example : give array $$$ [ a_1 a_2 \ldots a_n ] $$$ determine $$$ a $$$ kalindrome first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — elements array 's guarantee sum $$$ n $$$ test case wo n't exceed $$$ 200000 $$$ test case print yes $$$ a $$$ kalindrome otherwise print letter case first test case array $$$ [ 1 ] $$$ already a palindrome 's a kalindrome well second test case choose $$$ x = 2 $$$ delete second element obtain array $$$ [ 1 ] $$$ a palindrome third test case 's impossible obtain a palindrome fourth test case choose $$$ x = 4 $$$ delete fifth element obtain $$$ [ 1 4 4 1 ] $$$ also choose $$$ x = 1 $$$ delete first fourth elements obtain $$$ [ 4 4 4 ] $$$,"['greedy', 'two pointers']",1100.0
1684/F,give array $$$ a $$$ $$$ n $$$ integers also give $$$ m $$$ subsegments array leave right endpoints $$$ j $$$ -th segment $$$ l_j $$$ $$$ r_j $$$ respectively allow make one operation operation choose subsegment array $$$ a $$$ replace value segment integer ( also allow keep elements ) apply operation give $$$ m $$$ segment elements segment distinct formally $$$ 1 \le j \le m $$$ elements $$$ a _ { l _ { j } } a _ { l _ { j } +1 } \ldots a _ { r _ { j } -1 } a _ { r _ { j } } $$$ distinct n't want use operation a big segment find smallest length a segment apply operation segment meet <unknown> - <unknown> condition need use operation answer $$$ 0 $$$ input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200000 $$$ ) — size array number segment respectively next line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements $$$ a $$$ next $$$ m $$$ line contain two integers $$$ l_j $$$ $$$ r_j $$$ ( $$$ 1 \le l_j \le r_j \le n $$$ ) — leave right endpoints $$$ j $$$ -th segment 's guarantee sum $$$ n $$$ sum $$$ m $$$ test case exceed $$$ 200000 $$$ test case output a single integer — smallest length a segment apply operation make elements give segment distinct need use operation output $$$ 0 $$$ first test case perform operation segment $$$ [ 1 2 ] $$$ make $$$ a = [ 5 6 2 1 3 3 5 ] $$$ elements segment distinct way give segment elements distinct also impossible change single integer make elements distinct segment answer $$$ 2 $$$ second test case elements segment already distinct perform operation third test case replace first $$$ 5 $$$ $$$ 1 $$$ way get $$$ [ 1 7 5 6 ] $$$ elements distinct give segment elements distinct,"['data structures', 'two pointers']",2600.0
1760/D,give array $$$ a [ 0 \dots n-1 ] $$$ $$$ n $$$ integers array call a ` ` valley '' exist exactly one subarray $$$ a [ l \dots r ] $$$ : three examples : first image show array [ $$$ 3 2 2 1 2 2 3 $$$ ] a valley subarray indices $$$ l = r=3 $$$ satisfy condition second image show array [ $$$ 1 1 1 2 3 3 4 5 6 6 6 $$$ ] a valley subarray indices $$$ <unknown> r=2 $$$ satisfy <unknown> third image show array [ $$$ 1 2 3 4 3 2 1 $$$ ] a valley two subarrays $$$ l = <unknown> $$$ $$$ l = r=6 $$$ satisfy condition ask whether give array a valley note consider array index $$$ 0 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 2\cdot100000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — elements array guarantee sum $$$ n $$$ test case smaller $$$ 2\cdot100000 $$$ test case output ` ` yes '' ( without quote ) array a valley ` ` '' ( without quote ) otherwise output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ) first three test case explain statement,"['implementation', 'two pointers']",1000.0
1791/C,timur initially a binary string $$$ ^ { \dagger } $$$ $$$ s $$$ ( possibly length $$$ 0 $$$ ) perform follow operation several ( possibly zero ) time : $$$ ^ { \dagger } $$$ a binary string a string ( possibly empty string ) whose character either $$$ \texttt { 0 } $$$ $$$ \texttt { 1 } $$$ first line input contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number testcases first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 2000 $$$ ) — length timur 's final string second line test case contain a string $$$ s $$$ length $$$ n $$$ consist character $$$ \texttt { 0 } $$$ $$$ \texttt { 1 } $$$ denote final string test case output a single nonnegative integer — shortest possible length timur 's original string note timur 's original string could empty case output $$$ 0 $$$ first test case shortest possible string timur start $$$ \texttt { 0 } $$$ perform follow operation : $$$ \texttt { 0 } \to \color { red } { \texttt { 1 } } \texttt { 0 } \color { red } { \texttt { 0 } } $$$ second test case shortest possible string timur start $$$ \texttt { 11 } $$$ perform follow operation : $$$ \texttt { 11 } \to \color { red } { \texttt { 0 } } \texttt { 11 } \color { red } { \texttt { 1 } } $$$ third test case shortest possible string timur start $$$ \texttt { 10101 } $$$ n't perform operations fourth test case shortest possible string timur start empty string ( denote $$$ \varepsilon $$$ ) perform follow operations : $$$ \varepsilon \to \color { red } { \texttt { 1 } } \texttt { } \color { red } { \texttt { 0 } } \to \color { red } { \texttt { 0 } } \texttt { 10 } \color { red } { \texttt { 1 } } \to \color { red } { \texttt { 1 } } \texttt { 0101 } \color { red } { \texttt { 0 } } $$$ fifth test case shortest possible string timur start $$$ \texttt { 101 } $$$ perform follow operations : $$$ \texttt { 101 } \to \color { red } { \texttt { 0 } } \texttt { 101 } \color { red } { \texttt { 1 } } \to \color { red } { \texttt { 1 } } \texttt { <unknown> } \color { red } { \texttt { 0 } } $$$,"['implementation', 'two pointers']",800.0
1690/D,a stripe checker paper length $$$ n $$$ cell either white black minimum number cells must <unknown> white black order a segment $$$ k $$$ consecutive black cells stripe ? input data a segment $$$ k $$$ consecutive black cells already exist print 0 . first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case next descriptions $$$ t $$$ test case follow first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 2\cdot100000 $$$ ) second line consist letter ' w ' ( white ) ' b ' ( black ) line length $$$ n $$$ guarantee sum value $$$ n $$$ exceed $$$ 2\cdot100000 $$$ $$$ t $$$ test case print integer — minimum number cells need repaint white black order a segment $$$ k $$$ consecutive black cells first test case $$$ s $$$ = '' bbwbw '' $$$ k=3 $$$ enough recolor $$$ s_3 $$$ get $$$ s $$$ = '' <unknown> '' string contain a segment length $$$ k=3 $$$ consist letter ' b ' second test case example $$$ s $$$ = '' bbwbw '' $$$ k=5 $$$ enough recolor $$$ s_3 $$$ $$$ s_5 $$$ get $$$ s $$$ = '' <unknown> '' string contain a segment length $$$ k=5 $$$ consist letter ' b ' third test case example $$$ s $$$ = '' bbwbw '' $$$ k=1 $$$ string $$$ s $$$ already contain a segment length $$$ k=1 $$$ consist letter ' b ',"['implementation', 'two pointers']",1000.0
1198/A,one common way <unknown> sound record sound intensity particular time moments time moment intensity record a non - negative integer thus represent a sound file array $$$ n $$$ non - negative integers exactly $$$ k $$$ distinct value array need $$$ k = \lceil <unknown> _ { 2 } k \rceil $$$ bits store value take $$$ <unknown> $$$ bits store whole file reduce memory consumption need apply compression one common way reduce number possible intensity value choose two integers $$$ l \le r $$$ intensity value change follow way : intensity value within range $$$ [ l ; r ] $$$ n't change less $$$ l $$$ change $$$ l $$$ ; greater $$$ r $$$ change $$$ r $$$ see lose low high <unknown> task apply compression a way file fit onto a disk size $$$ i $$$ bytes number change elements array minimal possible remind $$$ 1 $$$ <unknown> contain $$$ 8 $$$ bits $$$ k = \lceil log _ { 2 } k \rceil $$$ smallest integer $$$ k \le 2^ { k } $$$ particular $$$ k = 1 $$$ $$$ k = 0 $$$ first line contain two integers $$$ n $$$ $$$ i $$$ ( $$$ 1 \le n \le 4 \cdot 10^ { 5 } $$$ $$$ 1 \le i \le 10^ { 8 } $$$ ) — length array size disk bytes respectively next line contain $$$ n $$$ integers $$$ a _ { i } $$$ ( $$$ 0 \le a _ { i } \le 10^ { 9 } $$$ ) — array denote sound file print a single integer — minimal possible number change elements first example choose $$$ <unknown> r=3 $$$ array become 2 2 2 3 3 3 number distinct elements $$$ k=2 $$$ sound file fit onto disk two value change second example disk larger initial file fit change require third example change 1s <unknown>,"['sortings', 'two pointers']",1600.0
1133/C,a coach local university $$$ n $$$ students <unknown> program skill $$$ i $$$ -th student $$$ a_i $$$ create a team a new program competition know students team probable victory ! create a team maximum number students also know a team balance mean program skill pair students a create team differ $$$ 5 $$$ task report maximum possible number students a balance team first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number students second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ a program skill $$$ i $$$ -th student print one integer — maximum possible number students a balance team first example create a team skills $$$ [ 12 17 15 ] $$$ second example take students a team program skills equal third example create a team consist a single student ( create a team consist least two students ),"['sortings', 'two pointers']",1200.0
1225/B2,difference easy hard versions constraints bertv channel every day broadcast one episode one $$$ k $$$ tv show know schedule next $$$ n $$$ days : a sequence integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le k $$$ ) $$$ a_i $$$ show episode show $$$ i $$$ -th day subscription show buy entire show ( i.e episodes ) show subscription buy separately many minimum subscriptions need buy order opportunity watch episodes purchase show $$$ d $$$ ( $$$ 1 \le d \le n $$$ ) days a row ? word want buy minimum number tv show segment $$$ d $$$ consecutive days episodes belong purchase show first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case input $$$ t $$$ test case descriptions follow first line test case contain three integers $$$ n k $$$ $$$ d $$$ ( $$$ 1 \le n \le 2\cdot100000 $$$ $$$ 1 \le k \le 1000000 $$$ $$$ 1 \le d \le n $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le k $$$ ) $$$ a_i $$$ show broadcast $$$ i $$$ -th day guarantee sum value <unknown> $$$ n $$$ test case input exceed $$$ 2\cdot100000 $$$ print $$$ t $$$ integers — answer test case input order follow answer a test case minimum number tv show need purchase a subscription watch episodes purchase tv show bertv $$$ d $$$ consecutive days please note <unknown> able watch $$$ d $$$ days a row first test case opportunity watch show two consecutive days need buy a subscription show $$$ 1 $$$ show $$$ 2 $$$ answer two second test case buy a subscription show show find a segment three consecutive days consist episodes show third test case unique segment four days four different show need buy a subscription four show fourth test case buy subscriptions show $$$ <unknown> $$$ able watch show last eight days,"['implementation', 'two pointers']",1300.0
229/A,give a table consist n row m columns cell table contain a number 0 1 . one move choose row table cyclically shift value either one cell leave one cell right cyclically shift a table row one cell right mean move value cell except last one right neighbor cell move value last cell first cell a cyclical shift a row leave perform similarly direction example cyclically shift a row ` ` 00110 '' one cell right get a row ` ` <unknown> '' shift a row ` ` 00110 '' one cell leave get a row ` ` <unknown> '' determine minimum number move need make table column consist number 1 . first line contain two space - separated integers : n ( 1 ≤ n ≤ 100 ) — number row table m ( 1 ≤ m ≤ 104 ) — number columns table n line follow contain m character ` ` 0 '' ` ` 1 '' : j - th character i - th line describe content cell i - th row j - th column table guarantee description table contain character besides ` ` 0 '' ` ` 1 '' print a single number : minimum number move need get number 1 column table impossible print -1 . first sample one way achieve goal least number move follow : cyclically shift second row right shift third row leave twice table column last one contain 1s second sample one ca n't shift row get a column contain 1s,"['brute force', 'two pointers']",1500.0
620/D,professor <unknown> two array integers a b. professor want make sum elements array a <unknown> close possible sum elements array b sb want minimize value v = |sa - sb| one operation professor swap element array a element array b. example array a [ 5 1 3 2 4 ] array b [ 3 3 2 ] professor swap element 5 array a element 2 array b get new array a [ 2 1 3 2 4 ] new array b [ 3 3 5 ] professor n't want make two swap find minimal value v sequence two swap lead value v. professor make swap one one new swap make new array a b. first line contain integer n ( 1 ≤ n ≤ 2000 ) — number elements array a. second line contain n integers ai ( - 109 ≤ ai ≤ 109 ) — elements array a. third line contain integer m ( 1 ≤ m ≤ 2000 ) — number elements array b. fourth line contain m integers bj ( - 109 ≤ bj ≤ 109 ) — elements array b. first line print minimal value v = |sa - sb| get two swap second line contain number swap k ( 0 ≤ k ≤ 2 ) next k line contain two integers xp yp ( 1 ≤ xp ≤ n 1 ≤ yp ≤ m ) — index element array a index element array b p - th swap several optimal solutions print print swap order professor,"['binary search', 'two pointers']",2200.0
958/F2,<unknown> <unknown> senate several <unknown> solar systems declare intentions leave republic master heidi need select jedi knight go peacekeeping <unknown> throughout galaxy well - known success peacekeeping mission depend color lightsabers jedi go mission heidi n jedi knight stand front one a lightsaber one m possible color know mission effective need select contiguous interval knight exactly k1 knight lightsabers first color k2 knight lightsabers second color ... km knight lightsabers m - th color however since last time learn always possible select interval therefore decide ask jedi knight go <unknown> <unknown> vacation leave near certain <unknown> <unknown> know i mean help heidi decide minimum number jedi knight need let go able select desire interval subsequence remain knight first line input contain n ( 1 ≤ n ≤ 2·105 ) m ( 1 ≤ m ≤ n ) second line contain n integers range { 1 2 ... m } represent color lightsabers subsequent jedi knight third line contain m integers k1 k2 ... km ( ) – desire count jedi knight lightsabers color 1 m. output one number : minimum number jedi knight need remove sequence remain interval <unknown> count lightsaber color possible output - 1,"['binary search', 'two pointers']",1800.0
645/C,attempt escape mischievous mess <unknown> ' <unknown> farmer john abandon farm travel side <unknown> journey k cow decide stay luxurious grand moo - <unknown> hotel hotel consist n room locate a row occupy farmer john want book a set k + 1 currently unoccupied room cow want cow stay safe possible wish minimize maximum distance room room cow distance room i j define <unknown> - i| help farmer john protect cow calculate minimum possible distance first line input contain two integers n k ( 1 ≤ k < n ≤ 100 000 ) — number room hotel number cow travel farmer john second line contain a string length n describe room i - th character string ' 0 ' i - th room free ' 1 ' i - th room occupy guarantee least k + 1 character string ' 0 ' exist least one possible choice k + 1 room farmer john cow stay print minimum possible distance farmer john 's room farthest cow first sample farmer john book room 3 room 1 4 cow distance farthest cow 2 . note impossible make distance 1 block three consecutive unoccupied room second sample farmer john book room 1 room 3 single cow distance cow 2 . third sample farmer john book three available room take middle room cow next distance farthest cow 1,"['binary search', 'two pointers']",1600.0
1431/B,polycarp finish write lecture <unknown> languages language week ` ` vwv '' ( <unknown> ` ` <unknown> '' ) write system language consist two lowercase latin letter : ' v ' ' w ' unfortunately polycarp write lecture <unknown> without space note look like a <unknown> sequence squiggles exact polycarp ca n't tell ' w ' apart ' <unknown> ' note consist two squiggles luckily brother monocarp better write habit polycarp manage take note want make note readable follow note monocarp underline letter note a way ambiguity underline a ' v ' ca n't mistake a part ' w ' underline a ' w ' ca n't mistake two adjacent letter ' v ' minimum number letter polycarp underline make note unambiguous ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number testcases next $$$ t $$$ line contain a non - empty string vwv language consist lowercase latin letter ' v ' ' w ' length string exceed $$$ 100 $$$ testcase print a single integer : minimum number letter polycarp underline ambiguity note first testcase 's enough underline two letter ' v ' second testcase letter ' v ' ambiguous already n't underline anything third testcase underline ' w ' n't mix two letter ' v ' fourth testcase underline ' w ' avoid ambiguity fifth testcase underline letter ' w ' two letter ' v ',"['implementation', 'two pointers']",1400.0
1462/A,polycarp a favorite sequence $$$ a [ 1 \dots n ] $$$ consist $$$ n $$$ integers write whiteboard follow : example $$$ n=7 $$$ $$$ a= [ 3 1 4 1 5 9 2 ] $$$ polycarp write a sequence whiteboard $$$ [ 3 4 5 2 9 1 1 ] $$$ saw sequence write whiteboard want restore polycarp 's favorite sequence first line contain a single positive integer $$$ t $$$ ( $$$ 1 \le t \le 300 $$$ ) — number test case test $$$ t $$$ test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 300 $$$ ) — length sequence write whiteboard next line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1 \le b_i \le 1000000000 $$$ ) — sequence write whiteboard output $$$ t $$$ answer test case answer — a sequence $$$ a $$$ polycarp write whiteboard first test case sequence $$$ a $$$ match sequence statement whiteboard state step look like : $$$ [ 3 ] \rightarrow [ 3 1 ] \rightarrow [ 3 4 1 ] \rightarrow [ 3 4 1 1 ] \rightarrow [ 3 4 5 1 1 ] \rightarrow [ 3 4 5 9 1 1 ] \rightarrow [ 3 4 5 2 9 1 1 ] $$$,"['implementation', 'two pointers']",800.0
1044/A,"a chessboard a width $$$ 1000000000 $$$ a height $$$ 1000000000 $$$ row number bottom top $$$ 1 $$$ $$$ 1000000000 $$$ columns number leave right $$$ 1 $$$ $$$ 1000000000 $$$ therefore cell chessboard assign coordinate $$$ ( x y ) $$$ $$$ x $$$ column number $$$ y $$$ row number every day fight black white piece board today black ones price ? rook survive drive lower leave corner — a cell coordinate $$$ ( 1,1 ) $$$ still happy victory 's time celebrate ! order rook need go home namely — upper side field ( cell row number $$$ 1000000000 $$$ ) everything would fine <unknown> white figure put spell place field end game two type spell : let 's recall rook a chess piece one move move point row column initial position task rook move cell $$$ ( r_0 c_0 ) $$$ cell $$$ ( r_1 c_1 ) $$$ condition $$$ r_1 = r_0 $$$ $$$ c_1 = c_0 $$$ block line block segment cells ( better understand look sample ) fortunately rook remove spell put <unknown> efforts therefore want remove minimum possible number spell way return home find number ! first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 0 \le n m \le 100000 $$$ ) — number vertical horizontal spell follow $$$ n $$$ line contain one integer $$$ x $$$ ( $$$ 1 \le x < 1000000000 $$$ ) — description vertical spell create a block line columns $$$ x $$$ $$$ x+1 $$$ follow $$$ m $$$ line contain three integers $$$ x_1 $$$ $$$ x_2 $$$ $$$ y $$$ ( $$$ 1 \le x _ { 1 } \le x _ { 2 } \le 1000000000 $$$ $$$ 1 \le y < 1000000000 $$$ ) — number describe horizontal spell create a block segment pass top side cells row number $$$ y $$$ columns $$$ x_1 $$$ $$$ x_2 $$$ inclusive guarantee spell different well fact pair horizontal spell true segment describe common point a single line print one integer — minimum number spell rook need remove get cell $$$ ( 1,1 ) $$$ least one cell row number $$$ 1000000000 $$$ first sample order rook return home enough remove second horizontal spell second sample order rook return home enough remove vertical spell try remove one horizontal spell would allow rook get home would block one remain horizontal spell ( either first one second one ) right would block a vertical spell third sample two horizontal spell go whole field spell <unknown> need remove fourth sample spell mean need remove anything fifth example remove first vertical third horizontal spell","['binary search', 'two pointers']",1700.0
939/C,distant future earth day last n hours 's n timezones local time adjacent timezones differ one hour describe local time hours number 1 n use i.e time ` ` 0 hours '' instead ` ` n hours '' use local time 1 - st timezone 1 hour local time i - th timezone i hours online program contest platform want conduct a contest last hour a way begin coincide begin hour ( time zone ) platform know ai people i - th timezone want participate contest person participate contest start earlier s hours 00 minutes local time end later f hours 00 minutes local time value s f equal time zone contest start f hours 00 minutes local time person wo n't participate help platform select hour number people participate contest maximum first line contain a single integer n ( 2 ≤ n ≤ 100 000 ) — number hours day second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 10 000 ) ai number people i - th timezone want participate contest third line contain two space - separated integers s f ( 1 ≤ s < f ≤ n ) output a single integer — time begin contest ( first timezone local time ) number participants maximum possible many answer output smallest among first example 's optimal start competition 3 hours ( first timezone ) case 1 hour second timezone 2 hours third timezone one person first timezone wo n't participate second example people third fourth timezones participate,"['binary search', 'two pointers']",1600.0
1746/B,array $$$ a $$$ size $$$ n $$$ consist zero ones follow operation : note elements $$$ a $$$ become bigger $$$ 1 $$$ perform operations also note $$$ n $$$ become $$$ 1 $$$ less operation minimum number operations need make $$$ a $$$ non - decreasing i. e. element less previous element ? test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) size array $$$ a $$$ next line contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ ( $$$ a_i $$$ $$$ 0 $$$ $$$ 1 $$$ ) elements array $$$ a $$$ 's guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print a single integer minimum number operations need make $$$ a $$$ non - decreasing first test case $$$ a $$$ already non - decreasing n't need operations answer $$$ 0 $$$ second test case perform operation $$$ i = 1 $$$ $$$ j = 5 $$$ $$$ a $$$ equal $$$ [ 0 0 1 2 ] $$$ become non - decreasing third test case perform operation $$$ i = 2 $$$ $$$ j = 1 $$$ $$$ a $$$ equal $$$ [ 1 ] $$$ become non - decreasing,"['greedy', 'two pointers']",800.0
1765/D,monocarp want watch $$$ n $$$ videos video one minute long size may arbitrary $$$ i $$$ -th video size $$$ a_i $$$ megabytes videos <unknown> internet a video download watch monocarp poor internet connection — take exactly $$$ 1 $$$ minute download $$$ 1 $$$ <unknown> data require $$$ a_i $$$ minutes download $$$ i $$$ -th video monocarp 's computer a hard disk $$$ m $$$ megabytes disk use store download videos monocarp start download a video size $$$ s $$$ $$$ s $$$ megabytes immediately reserve a hard disk less $$$ s $$$ megabytes leave download start require space free single video store hard disk since $$$ a_i \le m $$$ $$$ i $$$ download start interrupt allow run two download parallel a video fully download hard disk monocarp watch watch video take exactly $$$ 1 $$$ minute occupy internet connection monocarp start download another video watch current one monocarp finish watch a video n't need hard disk anymore delete video instantly free space occupy a hard disk delete a video take negligible time monocarp want watch $$$ n $$$ videos quickly possible order watch matter since monocarp need watch anyway please calculate minimum possible time require first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 1 \le m \le 1000000000 $$$ ) — number videos monocarp want watch size hard disk respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le m $$$ ) — size videos print one integer — minimum time require watch $$$ n $$$ videos,"['binary search', 'two pointers']",1700.0
644/B,problem simulate <unknown> one - thread server n query process i - th receive moment ti need process di units time ti guarantee distinct a query appear server may react three possible ways : soon server finish process query pick new one queue ( 's empty course ) a new query come moment x server finish process another query exactly moment consider first query pick queue new query appear query find moment server finish process print -1 query reject first line input contain two integers n b ( 1 ≤ n b ≤ 200 000 ) — number query maximum possible size query queue follow n line query descriptions ( chronological order ) description consist two integers ti di ( 1 ≤ ti di ≤ 109 ) ti moment time i - th query appear di time server need process guarantee ti - 1 < ti i > 1 . print sequence n integers e1 <unknown> ... <unknown> <unknown> moment server finish process i - th query ( query number order appear input ) - 1 correspond query reject consider first sample,"['data structures', 'two pointers']",1700.0
1599/A,give array $$$ a $$$ length $$$ n $$$ weight mass $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ two weight mass put every weight one side balance ( leave right ) n't put weight order $$$ a_1 $$$ ... $$$ a_n $$$ also a string $$$ s $$$ consist character ` ` l '' ` ` r '' mean put $$$ i - th $$$ weight ( $$$ a_i $$$ $$$ i - th $$$ weight choice ) leave right side balance heavier find order put weight balance rule string $$$ s $$$ satisfy first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 2 * 100000 $$$ ) - length array $$$ a $$$ second line contain $$$ n $$$ distinct integers : $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) - weight give third line contain string $$$ s $$$ length $$$ n $$$ consist letter ` ` l '' ` ` r '' - string determine side balance heavier put $$$ i - th $$$ weight <unknown> output contain $$$ n $$$ line every line print one integer one letter - integer represent weight put balance move letter represent side balance put weight solution print $$$ -1 $$$ explanation test case : 1st weight : 3 l ( leave side heavier ) 2nd weight : 2 r ( leave side heavier ) 3rd weight : 8 r ( right side heavier ) 4th weight : 13 l ( leave side heavier ) 5th weight : 7 l ( leave side heavier ) rule give string $$$ s $$$ fulfil order put weight correct,"['greedy', 'two pointers']",2600.0
1793/C,"know girl dora always look something time give a permutation want find a subsegment none elements end either minimum maximum entire subsegment formally ask find number $$$ l $$$ $$$ r $$$ $$$ ( 1 \leq l \leq r \leq n ) $$$ $$$ a_l \neq \min ( a_l a _ { l + 1 } \ldots a_r ) $$$ $$$ a_l \neq \max ( a_l a _ { l + 1 } \ldots a_r ) $$$ $$$ a_r \neq \min ( a_l a _ { l + 1 } \ldots a_r ) $$$ $$$ a_r \neq \max ( a_l a _ { l + 1 } \ldots a_r ) $$$ a permutation length $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ occur twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ present array ) help dora find a subsegment tell a subsegment exist test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow test case first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — length permutation second line contain $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — elements permutation <unknown> sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case output $$$ -1 $$$ desire subsegment exist otherwise output two index $$$ l r $$$ $$$ [ a _ { l } a _ { l + 1 } \ldots a _ { r } ] $$$ satisfy condition several solutions output first fourth test case show desire subsegments second test case subsegment $$$ [ 1 4 ] $$$ satisfy condition $$$ \max ( a_1 a_2 a_3 a_4 ) = 4 \min ( a_1 a_2 a_3 a_4 ) = 1 $$$ see condition meet third test case subsegment $$$ [ 2 6 ] $$$ also satisfy condition describe","['data structures', 'two pointers']",1200.0
60/A,"one morning cereal guy find cereal flake go find a note instead turn smart roommate hide flake one n box box stand one row number 1 n leave right roommate leave hint like ` ` hide leave i - th box '' ( ` ` leave i '' ) ` ` hide right i - th box '' ( ` ` right i '' ) hint mean flake i - th box well cereal guy want know minimal number box necessarily need check find flake consider hint want find hint contradictory roommate lie , box flake first line contain two integers n m ( 1 ≤ n ≤ 1000 0 ≤ m ≤ 1000 ) represent number box number hint correspondingly next m line contain hint like ` ` leave i '' ` ` right i '' i integer ( 1 ≤ i ≤ n ) hint may coincide answer contain exactly one integer — number box necessarily check ` ` -1 '' hint contradictory","['implementation', 'two pointers']",1300.0
1744/F,give a permutation $$$ p_1 p_2 \ldots p_n $$$ length $$$ n $$$ number $$$ 0 \ldots n - 1 $$$ count number subsegments $$$ 1 \leq l \leq r \leq n $$$ permutation $$$ mex ( p_l p _ { l+1 } \ldots p_r ) > med ( p_l p _ { l+1 } \ldots p_r ) $$$ $$$ mex $$$ $$$ s $$$ smallest non - negative integer occur $$$ s $$$ example : $$$ med $$$ set $$$ s $$$ median set i.e element sort elements non - decreasing order position number $$$ \left \lfloor { \frac { |s| + 1 } { 2 } } \right \rfloor $$$ ( array elements number start $$$ 1 $$$ $$$ \left \lfloor { v } \right \rfloor $$$ denote round $$$ v $$$ . ) example : a sequence $$$ n $$$ number call a permutation contain number $$$ 0 $$$ $$$ n - 1 $$$ exactly first line input contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10000 $$$ ) number test case descriptions test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) length permutation $$$ p $$$ second line test case contain exactly $$$ n $$$ integers : $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 0 \leq p_i \leq n - 1 $$$ ) elements permutation $$$ p $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print answer a single line : number subsegments $$$ 1 \leq l \leq r \leq n $$$ permutation $$$ mex ( p_l p _ { l+1 } \ldots p_r ) > med ( p_l p _ { l+1 } \ldots p_r ) $$$ first test case contain exactly one subsegment $$$ mex ( { 0 } ) = 1 > med ( { 0 } ) = 0 $$$ third test case follow subsegments : $$$ [ 1 0 ] $$$ $$$ [ 0 ] $$$ $$$ [ 1 0 2 ] $$$ $$$ [ 0 2 ] $$$ $$$ mex $$$ greater $$$ med $$$ fourth test case follow subsegments : $$$ [ 0 2 ] $$$ $$$ [ 0 ] $$$ $$$ [ 0 2 1 ] $$$ $$$ [ 0 2 1 3 ] $$$ $$$ mex $$$ greater $$$ med $$$,"['math', 'two pointers']",2000.0
1407/C,"interactive problem hide a permutation $$$ p $$$ length $$$ n $$$ consist elements $$$ 1 $$$ $$$ n $$$ want guess , give us 2 different indices $$$ i $$$ $$$ j $$$ reply $$$ p _ { i } \bmod p _ { j } $$$ ( remainder division $$$ p _ { i } $$$ $$$ p _ { j } $$$ ) enough patience answer $$$ 2 \cdot n $$$ query fit constraint ? a reminder a permutation length $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 10000 $$$ ) — length permutation interaction start read $$$ n $$$ allow make $$$ 2 \cdot n $$$ query follow way : one read integer $$$ k $$$ equal $$$ p_x \bmod <unknown> $$$ guess permutation print a single line ` ` ! ` ` ( without quote ) follow array $$$ p $$$ quit print a query forget output end line flush output otherwise get idleness limit exceed , use : exit immediately receive ` ` -1 '' see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream hack <unknown> first line output $$$ n $$$ ( $$$ 1 \le n \le 10000 $$$ ) second line print permutation $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$","['math', 'two pointers']",1600.0
280/B,bike love look second maximum element sequence second maximum element sequence distinct number x1 x2 ... xk ( k > 1 ) maximum element xj follow inequality hold : lucky number sequence distinct positive integers x1 x2 ... xk ( k > 1 ) number equal bitwise exclude maximum element sequence second maximum element sequence ' ve get a sequence distinct positive integers s1 s2 ... sn ( n > 1 ) let 's denote sequence sl sl + 1 ... <unknown> s [ l .. r ] ( 1 ≤ l < r ≤ n ) task find maximum number among lucky number sequence s [ l .. r ] note number sequence s distinct give definitions make <unknown> first line contain integer n ( 1 < n ≤ 105 ) second line contain n distinct integers s1 s2 ... sn ( 1 ≤ si ≤ 109 ) print a single integer — maximum lucky number among lucky number sequence s [ l .. r ] first sample choose s [ 4 .. 5 ] = { 4 3 } lucky number ( 4 xor 3 ) = 7 . also choose s [ 1 .. 2 ] second sample must choose s [ 2 .. 5 ] = { 8 3 5 7 },"['data structures', 'implementation', 'two pointers']",1800.0
279/C,"' ve get array consist n integers a1 a2 ... , also ' ve get m query i - th query describe two integers li ri number li ri define a subsegment original array , sequence number ali ali + 1 ali + 2 ... <unknown> query check whether correspond segment a ladder a ladder a sequence integers b1 b2 ... bk first n't decrease n't increase word integer x ( 1 ≤ x ≤ k ) follow inequation fulfill : b1 ≤ b2 ≤ ... ≤ bx ≥ bx + 1 ≥ bx + 2 ... ≥ bk note non - decreasing non - increasing sequence also consider ladder first line contain two integers n m ( 1 ≤ n m ≤ 105 ) — number array elements number query second line contain sequence integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) number ai stand i - th array element follow m line contain description query i - th line contain description i - th query consist two integers li ri ( 1 ≤ li ≤ ri ≤ n ) — boundaries subsegment initial array number line separate single space print m line i - th line print word ` ` yes '' ( without quote ) subsegment correspond i - th query ladder word ` ` '' ( without quote ) otherwise","['dp', 'implementation', 'two pointers']",1700.0
1748/F,"array $$$ a_0 a_1 \ldots a _ { n-1 } $$$ length $$$ n $$$ initially $$$ a_i = 2^i $$$ $$$ 0 \le i \lt n $$$ note array $$$ a $$$ zero - indexed want reverse array ( make $$$ a_i $$$ equal $$$ 2^ { n-1 - i } $$$ $$$ 0 \le i \lt n $$$ ) , perform follow operation $$$ 250\,000 $$$ time : $$$ \oplus $$$ denote bitwise xor operation task find sequence operations result array $$$ a $$$ reverse show give constraints a solution always exist first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 400 $$$ ) — length array $$$ a $$$ first line print one integer $$$ k $$$ ( $$$ 0 \le k \le 250\,000 $$$ ) — number operations perform second line print $$$ k $$$ integers $$$ i_1 i_2 \ldots i_k $$$ ( $$$ 0 \le i_j \lt n $$$ ) , $$$ i_j $$$ integer select $$$ j $$$ -th operation note n't need minimize number operations note elements operations perform color red first test case array $$$ a $$$ change follow way : $$$ [ 1 \color { red } { 2 } ] \rightarrow [ \color { red } { 1 } , 3 ] \rightarrow [ 2 \color { red } { 3 } ] \rightarrow [ 2,1 ] $$$ second test case array $$$ a $$$ change follow way : $$$ [ 1 \color { red } { 2 } , 4 ] \rightarrow [ \color { red } { 1 } , 6,4 ] \rightarrow [ 7 \color { red } { 6 } , 4 ] \rightarrow [ \color { red } { 7 } , 2,4 ] \rightarrow [ <unknown> \color { red } { 4 } ] \rightarrow [ 5 \color { red } { 2 } , 1 ] \rightarrow [ \color { red } { 5 } , 3,1 ] \rightarrow [ 6 \color { red } { 3 } , 1 ] \rightarrow [ \color { red } { 6 } , 2,1 ] \rightarrow [ <unknown> ] $$$",['bitmasks'],3000.0
1632/B,finally decide build a roof football field school <unknown> . construction require place $$$ n $$$ consecutive vertical pillars furthermore <unknown> want heights pillars form a permutation $$$ p $$$ integers $$$ 0 $$$ $$$ n - 1 $$$ $$$ p_i $$$ height $$$ i $$$ -th pillar leave $$$ ( 1 \le i \le n ) $$$ chief know cost construction consecutive pillars equal maximum value bitwise xor heights pair adjacent pillars word cost construction equal $$$ \max\limits _ { 1 \le i \le n - 1 } { p_i \oplus p _ { i + 1 } } $$$ $$$ \oplus $$$ denote bitwise xor operation find sequence pillar heights $$$ p $$$ length $$$ n $$$ smallest construction cost problem a permutation array consist $$$ n $$$ distinct integers $$$ 0 $$$ $$$ n - 1 $$$ arbitrary order example $$$ [ <unknown> ] $$$ a permutation $$$ [ <unknown> ] $$$ a permutation ( $$$ 1 $$$ appear twice array ) $$$ [ <unknown> ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 3 $$$ array ) test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number pillars construction roof guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print $$$ n $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ $$$ \ldots $$$ $$$ p_n $$$ — sequence pillar heights smallest construction cost multiple answer print $$$ n = 2 $$$ $$$ 2 $$$ sequence pillar heights : $$$ n = 3 $$$ $$$ 6 $$$ sequence pillar heights :,['bitmasks'],1000.0
1630/A,give a set $$$ n $$$ ( $$$ n $$$ always a power $$$ 2 $$$ ) elements contain integers $$$ 0 1 2 \ldots n-1 $$$ exactly find $$$ \frac { n } { 2 } $$$ pair elements : many solutions print solution print $$$ -1 $$$ instead input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 400 $$$ ) — number test case description test case follow test case consist a single line two integers $$$ n $$$ $$$ k $$$ ( $$$ 4 \leq n \leq 2^ { 16 } $$$ $$$ n $$$ a power $$$ 2 $$$ $$$ 0 \leq k \leq n-1 $$$ ) sum $$$ n $$$ test case exceed $$$ 2^ { 16 } $$$ test case individual input pairwise different test case solution print a single line integer $$$ -1 $$$ otherwise print $$$ \frac { n } { 2 } $$$ line $$$ i $$$ -th must contain $$$ a_i $$$ $$$ b_i $$$ elements $$$ i $$$ -th pair many solutions print print pair elements pair order first test $$$ ( 0\ & 3 ) + ( 1\ & 2 ) = 0 $$$ second test $$$ ( 0\ & 2 ) + ( 1\ & 3 ) = 1 $$$ third test $$$ ( 0\ & 1 ) + ( 2\ & 3 ) = 2 $$$ fourth test solution,['bitmasks'],1500.0
1527/A,give integer $$$ n $$$ find maximum value integer $$$ k $$$ follow condition hold : first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le <unknown> $$$ ) $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) test case output a single integer — require integer $$$ k $$$ first testcase maximum value continuous & operation give 0 value 1 . second testcase maximum value continuous & operation give 0 value 3 . value greater 3 say example 4 give & sum 0 . hence 3 answer,['bitmasks'],800.0
1790/E,vlad find two positive number $$$ a $$$ $$$ b $$$ ( $$$ a b > 0 $$$ ) discover $$$ a \oplus b = \frac { a + b } { 2 } $$$ $$$ \oplus $$$ mean bitwise exclusive division perform without round .. since easier remember one number two vlad remember $$$ <unknown> b $$$ let 's denote number $$$ x $$$ help find suitable $$$ a $$$ $$$ b $$$ tell exist first line input data contain single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test test case describe a single integer $$$ x $$$ ( $$$ 1 \le x \le 2^ { 29 } $$$ ) — number vlad remember output $$$ t $$$ line answer correspond test case answer output $$$ a $$$ $$$ b $$$ ( $$$ 0 < a b \le 2^ { 32 } $$$ ) $$$ x = a \oplus b = \frac { a + b } { 2 } $$$ several answer output match pair output -1,['bitmasks'],1400.0
1699/B,give two even integers $$$ n $$$ $$$ m $$$ task find binary matrix $$$ a $$$ $$$ n $$$ row $$$ m $$$ columns every cell $$$ ( i j ) $$$ exactly two neighbour a different value $$$ a _ { i j } $$$ two cells matrix consider neighbour share a side formally neighbour cell $$$ ( x y ) $$$ : $$$ ( x-1 y ) $$$ $$$ ( x y+1 ) $$$ $$$ ( x+1 y ) $$$ $$$ ( x y-1 ) $$$ prove give constraints answer always exist test contain multiple test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case follow line contain descriptions test case line test case contain two even integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n m \le 50 $$$ ) — height width binary matrix respectively test case print $$$ n $$$ line contain $$$ m $$$ number equal $$$ 0 $$$ $$$ 1 $$$ — binary matrix satisfy constraints describe statement prove give constraints answer always exist white mean $$$ 0 $$$ black mean $$$ 1 $$$,['bitmasks'],900.0
1801/A,"kirill want weave beautiful blanket consist $$$ n \times m $$$ size square patch color match non - negative integer color thus problem blanket consider a $$$ b $$$ matrix size $$$ n \times m $$$ consist non - negative integers kirill consider blanket beautiful submatrix $$$ a $$$ size $$$ 4 \times 4 $$$ matrix $$$ b $$$ true : $$$ \oplus $$$ mean bitwise exclusive <unknown> ask help weave a beautiful blanket colorful possible ! give two integers $$$ n $$$ $$$ m $$$ task generate a matrix $$$ b $$$ size $$$ n \times m $$$ correspond a beautiful blanket number different number maximize first line input data contain one integer number $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case single line test case contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 4 \le n \ m \le 200 ) $$$ — size matrix $$$ b $$$ guarantee sum $$$ n \cdot m $$$ exceed $$$ 200000 $$$ test case first line output one integer $$$ cnt $$$ $$$ ( 1 \le cnt \le n \cdot m ) $$$ — maximum number different number matrix output matrix $$$ b $$$ $$$ ( 0 \le b _ { ij } < 2^ { 63 } ) $$$ size $$$ n \times m $$$ several correct matrices allow output one show exist a matrix optimal number distinct number exist among suitable matrices a $$$ b $$$ $$$ ( 0 \le b _ { ij } < 2^ { 63 } ) $$$ first test case 4 submatrix size $$$ 4 \times 4 $$$ consider a submatrix whose upper - left corner coincide upper - left corner matrix $$$ b $$$ : $$$ \left [ { \begin { array } { <unknown> } 9740 & 1549 & 9744 & 1553 \\ 1550 & 1551 & 1554 & 1555 \\ 10252 & 2061 & 10256 & 2065 \\ 2062 & 2063 & 2066 & 2067 \\ \end { array } } \right ] $$$ $$$ 9740 \oplus 1549 \oplus 1550 \oplus 1551 $$$ $$$ = $$$ $$$ 10256 \oplus 2065 \oplus 2066 \oplus 2067 $$$ $$$ = $$$ $$$ 8192 $$$ ; $$$ 10252 \oplus 2061 \oplus 2062 \oplus 2063 $$$ $$$ = $$$ $$$ 9744 \oplus 1553 \oplus 1554 \oplus 1555 $$$ $$$ = $$$ $$$ 8192 $$$ , choose submatrix fit condition similarly make sure three submatrices also fit condition",['bitmasks'],1600.0
1775/B,"<unknown> <unknown> <unknown> array $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ want check two different subsequences $$$ a $$$ $$$ b $$$ original array $$$ f ( a ) = f ( b ) $$$ $$$ f ( x ) $$$ bitwise number sequence $$$ x $$$ a sequence $$$ q $$$ a subsequence $$$ p $$$ $$$ q $$$ obtain $$$ p $$$ delete several ( possibly none ) elements two subsequences consider different set index elements original sequence different , value elements consider compare subsequences test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — size array $$$ c $$$ description array $$$ c $$$ problem give <unknown> speed input $$$ ( i + 1 ) $$$ -st follow $$$ n $$$ line test case begin integer $$$ k_i $$$ ( $$$ 1 \le k_i \le 100000 $$$ ) — number set bits number $$$ c_i $$$ next follow $$$ k_i $$$ distinct integers $$$ p _ { i 1 } p _ { i 2 } \dots p _ { i k_i } $$$ ( $$$ 1 \le p_i \le 200000 $$$ ) — the number bits set one number $$$ c_i $$$ word $$$ c_i = 2^ { p _ { i 1 } } + 2^ { p _ { i 2 } } + \ldots + 2^ { p _ { i k_i } } $$$ guarantee total sum $$$ k_i $$$ test exceed $$$ 100000 $$$ set input print ` ` yes '' exist two different subsequences $$$ f ( a ) = f ( b ) $$$ ` ` '' otherwise output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses prove first test case two different subsequences $$$ a $$$ $$$ b $$$ $$$ f ( a ) = f ( b ) $$$ second test case one possible answer follow subsequences : subsequence $$$ a $$$ form element position $$$ 1 $$$ subsequence $$$ b $$$ form elements position $$$ 1 $$$ $$$ 2 $$$ third test case one possible answer follow subsequences : subsequence $$$ a $$$ form elements position $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ subsequence $$$ b $$$ form elements position $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$",['bitmasks'],1300.0
1705/F,"mark <unknown> online exam consist $$$ n $$$ true - false question however lose answer key need a way retrieve answer client get infuriate fortunately access grade system thus query input answer $$$ n $$$ question grade system output many correct n't much time use grade system $$$ <unknown> $$$ time help mark determine answer key note answer key fix advance change depend query first line input consist integer $$$ n $$$ ( $$$ 1\leq n\leq 1000 $$$ ) — number question read $$$ n $$$ start make query grade system query print a line contain a string $$$ s $$$ length $$$ n $$$ consist letter ' t ' ' f ' a successful query read integer $$$ k $$$ ( $$$ 0\leq k\leq n $$$ ) — number correct answer read $$$ n $$$ find answer program make query program read $$$ k = -1 $$$ instead number correct answer mean either make invalid query exceed query limit exit immediately receive $$$ -1 $$$ see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack use follow format : first line contain integer $$$ n $$$ ( $$$ 1\leq n\leq 1000 $$$ ) — number question second line contain a string $$$ s $$$ length $$$ n $$$ consist ' t ' ' f ' — answer key empty line example better understand interaction process 're require print first example $$$ 3 $$$ question answer question ' true ' ' true ' ' false ' respectively second example $$$ 4 $$$ question answer question ' true ' ' false ' ' true ' ' true ' respectively",['bitmasks'],2900.0
1423/I,"john $$$ q $$$ close intervals consecutive $$$ 2k $$$ -bit number $$$ [ l_i r_i ] $$$ one 16 - bit value $$$ v_i $$$ interval ( $$$ 0 \leq i < q $$$ ) john want implement a function f map $$$ 2k $$$ -bit number 16 - bit number a way input interval map interval 's value word : $$$ $$$ f ( x ) = v_i \ ; \textrm { every } 0 \leq i < q \ ; \textrm { every } x \in [ l_i r_i ] $$$ $$$ output f input <unknown> john want make implementation f fast decide use lookup table a single $$$ 2k $$$ -bit lookup table would large fit memory instead john plan use two k - bit lookup table lsbtable msbtable implementation look like : $$$ $$$ f ( x ) = \textrm { lsbtable } [ \textrm { <unknown> } ( x ) ] \ ; \ & \ ; \textrm { msbtable } [ \textrm { <unknown> } ( x ) ] $$$ $$$ word return ` ` bitwise '' result look k least significant bits lsbtable k significant bits msbtable john need help give $$$ k $$$ $$$ q $$$ $$$ q $$$ intervals $$$ [ l_i r_i ] $$$ value $$$ v_i $$$ find two lookup table implement f report table n't exist first line contain two integers $$$ k $$$ $$$ q $$$ ( $$$ 1 < = k < = 16 $$$ $$$ 1 < = q < = 2\cdot 100000 $$$ ) next $$$ q $$$ line contain three integers $$$ l_i $$$ $$$ r_i $$$ $$$ v_i $$$ ( $$$ 0 \leq l_i \leq r_i < 2^ { 2k } $$$ $$$ 0 \leq v_i < 2^ { 16 } $$$ ) first line output ` ` possible '' ( without quote ) two table satisfy condition exist ` ` impossible '' ( without quote ) n't exist a solution exist next $$$ 2 \cdot 2^k $$$ line program output value two lookup table ( lsbtable msbtable ) find multiple pair table satisfy condition program may output pair line $$$ 1 + i $$$ output $$$ \textrm { lsbtable } [ i ] $$$ ( $$$ 0 \leq i < 2^k $$$ $$$ 0 \leq \textrm { lsbtable } [ i ] < 2^ { 16 } $$$ ) line $$$ 1 + 2^k + i $$$ output $$$ \textrm { msbtable } [ i ] $$$ ( $$$ 0 \leq i < 2^k $$$ $$$ 0 \leq \textrm { msbtable } [ i ] < 2^ { 16 } $$$ ) a close interval $$$ [ a b ] $$$ include a b. first sample table $$$ \textrm { lsbtable } = [ 1,3 ] $$$ $$$ \textrm { msbtable } = [ 1,3 ] $$$ satisfy condition : $$$ f [ 0 ] = \textrm { lsbtable } [ 0 ] \ & \textrm { msbtable } [ 0 ] = 1 \ & 1 = 1 $$$ $$$ f [ 1 ] = \textrm { lsbtable } [ 1 ] \ & \textrm { msbtable } [ 0 ] = 3 \ & 1 = 1 $$$ $$$ f [ 2 ] = \textrm { lsbtable } [ 0 ] \ & \textrm { msbtable } [ 1 ] = 1 \ & 3 = 1 $$$ $$$ f [ 3 ] = \textrm { lsbtable } [ 1 ] \ & \textrm { msbtable } [ 1 ] = 3 \ & 3 = 3 $$$ second sample table $$$ \textrm { lsbtable } = [ <unknown> ] $$$ $$$ \textrm { msbtable } = [ <unknown> ] $$$ satisfy condition third sample two lookup table satisfy condition",['bitmasks'],3000.0
1174/D,give two integers $$$ n $$$ $$$ x $$$ construct array satisfy follow condition : a sequence $$$ b $$$ a subsegment a sequence $$$ a $$$ $$$ b $$$ obtain $$$ a $$$ deletion several ( possibly zero ) elements begin several ( possibly zero ) elements end line contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \le n \le 18 $$$ $$$ 1 \le x < 2^ { 18 } $$$ ) first line contain length array $$$ l $$$ $$$ l $$$ positive second line contain $$$ l $$$ space - separated integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \dots $$$ $$$ a_l $$$ ( $$$ 1 \le a_i < 2^n $$$ ) — elements array $$$ a $$$ multiple solutions print first example bitwise xor subsegments $$$ \ { <unknown> } $$$,['bitmasks'],1900.0
1479/C,"time ago homer live a beautiful city $$$ n $$$ block number $$$ 1 $$$ $$$ n $$$ $$$ m $$$ direct roads road a positive length road go block smaller index block larger index every two ( different ) block one road homer discover two number $$$ l $$$ $$$ r $$$ city $$$ ( l r ) $$$ -continuous city say $$$ ( l r ) $$$ -continuous a path block $$$ u $$$ block $$$ v $$$ a sequence $$$ u = x_0 \to x_1 \to x_2 \to \dots \to x_k = v $$$ a road block $$$ x _ { i-1 } $$$ block $$$ x _ { i } $$$ every $$$ 1 \leq i \leq k $$$ length a path sum lengths roads path two paths $$$ x_0 \to x_1 \to \dots \to x_k $$$ $$$ y_0 \to y_1 \to \dots \to y_l $$$ different $$$ k \neq l $$$ $$$ x_i \neq y_i $$$ $$$ 0 \leq i \leq \min\ { k l\ } $$$ move another city homer remember two special number $$$ l $$$ $$$ r $$$ forget number $$$ n $$$ $$$ m $$$ block roads respectively block connect roads however believe number block larger $$$ 32 $$$ ( city small ) best friend homer please tell whether possible find a $$$ ( l r ) $$$ -continuous city single line contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l \leq r \leq 1000000 $$$ ) impossible find a $$$ ( l r ) $$$ -continuous city within $$$ 32 $$$ block print ` ` '' a single line otherwise print ` ` yes '' first line follow a description a $$$ ( l r ) $$$ -continuous city second line contain two integers $$$ n $$$ ( $$$ 2 \leq n \leq 32 $$$ ) $$$ m $$$ ( $$$ 1 \leq m \leq \frac { n ( n-1 ) } 2 $$$ ) $$$ n $$$ denote number block $$$ m $$$ denote number roads $$$ m $$$ line follow $$$ i $$$ -th $$$ m $$$ line contain three integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a_i < b_i \leq n $$$ ) $$$ c_i $$$ ( $$$ 1 \leq c_i \leq 1000000 $$$ ) indicate a direct road block $$$ a_i $$$ block $$$ b_i $$$ length $$$ c_i $$$ require every two block 1 road connect , every $$$ 1 \leq i < j \leq m $$$ either $$$ a_i \neq a_j $$$ $$$ b_i \neq b_j $$$ first example one path block $$$ 1 $$$ block $$$ n = 2 $$$ length $$$ 1 $$$ second example three paths block $$$ 1 $$$ block $$$ n = 5 $$$ $$$ 1 \to 2 \to 5 $$$ length $$$ 4 $$$ $$$ 1 \to 3 \to 5 $$$ length $$$ 5 $$$ $$$ 1 \to 4 \to 5 $$$ length $$$ 6 $$$",['bitmasks'],2500.0
1148/F,give $$$ n $$$ object object two integer properties : $$$ val_i $$$ — price — $$$ mask_i $$$ guarantee sum price initially non - zero want select a positive integer $$$ s $$$ object modify $$$ i $$$ -th object modify use follow procedure : need find integer $$$ s $$$ <unknown> do sum price change sign ( negative become positive vice - versa ; allow become zero ) absolute value sum arbitrary first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 300000 $$$ ) — number object $$$ i $$$ -th next $$$ n $$$ line contain integers $$$ val_i $$$ $$$ mask_i $$$ ( $$$ -1000000000 \leq val_i \leq 1000000000 $$$ $$$ 1 \le mask_i \le 2^ { 62 } - 1 $$$ ) — price object mask guarantee sum $$$ val_i $$$ initially non - zero print integer $$$ s $$$ ( $$$ 1 \le s \le 2^ { 62 } - 1 $$$ ) modify object describe sign sum $$$ val_i $$$ change sign multiple $$$ s $$$ print one show always least one valid $$$ s $$$ first test sample object change price except object mask $$$ <unknown> $$$ total sum change sign : initially $$$ 24 $$$ <unknown> — $$$ <unknown> $$$ second test sample object change price total sum change sign,['bitmasks'],2700.0
878/D,nikita sasha play a computer game <unknown> magical creatures initially k creatures number 1 k. creatures n different characteristics sasha a spell allow create a new creature two give creatures characteristics equal maximum correspond characteristics use creatures nikita a similar spell spell characteristic new creature equal minimum correspond characteristics use creatures a new creature get smallest unused number use spell interest characteristics new creatures help find characteristics first line contain integers n k q ( 1 ≤ n ≤ 105 1 ≤ k ≤ 12 1 ≤ q ≤ 105 ) — number characteristics creatures query next k line describe original creatures line i contain n number ai1 ai2 ... ( 1 ≤ aij ≤ 109 ) — characteristics i - th creature next q line contain a query i - th line contain number ti xi yi ( 1 ≤ ti ≤ 3 ) denote a query : 's guarantee creatures ' number valid mean create query involve query ti = 3 output correspond characteristic first sample sasha make a creature number 3 characteristics ( 2 2 ) nikita make a creature number 4 characteristics ( 1 1 ) find first characteristic creature 3 second characteristic creature 4,['bitmasks'],2900.0
878/A,petya learn a new program language calpas a program language always take one non - negative integer return one non - negative integer well language three command : apply a bitwise operation xor a give constant current integer a program contain arbitrary sequence operations arbitrary constants 0 1023 . program run operations apply ( give order ) argument end result integer return petya write a program language turn long write a program calpas thing petya 's program consist 5 line program return integer petya 's program arguments 0 1023 . first line contain integer n ( 1 ≤ n ≤ 5·105 ) — number line next n line contain command a command consist a character represent operation ( ` ` & '' ` ` | '' ` ` ^ '' xor respectively ) constant xi 0 ≤ xi ≤ 1023 . output integer k ( 0 ≤ k ≤ 5 ) — length program next k line must contain command format input read bitwise operations https : //en.wikipedia.org / wiki / bitwise_operation second sample : let x input petya 's program 's output ( ( x & 1 ) & 3 ) & 5 = x & ( 1 & 3 & 5 ) = x & 1 two program always give output,['bitmasks'],1600.0
579/A,a lover bacteria want raise bacteria a box initially box empty morning put number bacteria box night every bacterium box split two bacteria hope see exactly x bacteria box moment minimum number bacteria need put box across days ? line contain one integer x ( 1 ≤ x ≤ 109 ) line contain one integer : answer first sample add one bacterium box first day morning third morning 4 bacteria box put one result 5 box add 2 bacteria process answer 2 . second sample put one first morning 4 - th morning 8 box answer 1,['bitmasks'],1000.0
513/C,nowadays internet <unknown> <unknown> link a web page instead show person open a web page determine within 100 milliseconds web page open usually multiple company compete ad slot web page auction receive a request detail user web page ad slot respond within 100 milliseconds a bid would pay put advertisement ad slot company suggest highest bid win auction get place advertisement several company tie highest bid winner get pick random however company auction pay exact amount bid case a second - price auction use mean amount pay company equal maximum bid place ad slot let 's consider one bid n company compete place ad i - th company bid integer number microdollars <unknown> randomly choose range li ri inclusive word value i - th company bid integer range [ li ri ] probability determine expect value winner pay a second - price auction first line input contain integer number n ( 2 ≤ n ≤ 5 ) n line follow i - th contain two number li ri ( 1 ≤ li ≤ ri ≤ 10000 ) describe i - th company 's bid preferences problem n't subproblems get 8 point correct submission output answer absolute relative error <unknown> - 9 . consider first example first company bid a random integer number microdollars range [ 4 7 ] ; second company bid 8 10 third company bid 5 microdollars second company win regardless exact value bid however price pay depend value first company 's bid probability 0.5 first company bid 5 microdollars second - highest price whole auction 5 . probability 0.25 bid 6 microdollars probability 0.25 bid 7 microdollars thus expect value second company pay <unknown> + <unknown> + <unknown> = <unknown>,['bitmasks'],2000.0
504/D,misha 's birthday many large number leave scatter across room 's time clean misha need put a basket order task <unknown> robot agree complete task certain condition robot put a number x basket misha answer question : possible choose one multiple number already basket xor sum equal x ? answer positive also need give index number multiple options choose number allow choose correct option misha 's answer robot put number basket initially basket empty integer put basket take number first integer put basket take number 0 second integer take number 1 misha need clean place soon possible unfortunately n't good <unknown> ask help first line contain number m ( 1 ≤ m ≤ 2000 ) show many number scatter around room next m line contain number order robot put basket number a positive integer strictly less <unknown> n't contain lead zero number either print a 0 correspond line number represent a xor sum number basket print integer k show many number representation index number separate number space number occur representation xor sum number result bitwise sum number modulo 2,['bitmasks'],2700.0
484/A,let 's denote number bits set ( ' 1 ' bits ) binary representation non - negative integer x. give multiple query consist pair integers l r. query find x l ≤ x ≤ r maximum possible multiple number find smallest first line contain integer n — number query ( 1 ≤ n ≤ 10000 ) follow n line contain two integers li ri — arguments correspond query ( 0 ≤ li ≤ ri ≤ 1018 ) query print answer a separate line binary representations number 1 10 list <unknown> = <unknown> = <unknown> = <unknown> = <unknown> = <unknown> = <unknown> = <unknown> = <unknown> = <unknown> = <unknown>,['bitmasks'],1700.0
243/A,"polycarpus a sequence consist n non - negative integers : a1 a2 ... , let 's define function f ( l r ) ( l r integer 1 ≤ l ≤ r ≤ n ) sequence a operation bitwise sequence elements index l r. formally : f ( l r ) = al | al + 1 | ... | <unknown> polycarpus take a piece paper write value function f ( l r ) l r ( l r integer 1 ≤ l ≤ r ≤ n ) want know many distinct value 's get end help polycarpus count number distinct value function f ( l r ) give sequence a. expression x | y mean apply operation bitwise number x y. operation exist modern program languages example language c++ java mark ` ` | '' pascal — ` ` '' first line contain integer n ( 1 ≤ n ≤ 105 ) — number elements sequence a. second line contain n space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 106 ) — elements sequence a. print a single integer — number distinct value function f ( l r ) give sequence a. please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first test case polycarpus 6 number write paper : f ( 1 1 ) = 1 f ( 1 2 ) = 3 f ( 1 3 ) = 3 f ( 2 2 ) = 2 f ( 2 3 ) = 2 f ( 3 3 ) = 0 . exactly 4 distinct number among : 0 1 2 3",['bitmasks'],1600.0
1088/D,interactive problem ! ehab play a game laggy ehab 2 hide integers $$$ ( a b ) $$$ laggy ask a pair integers $$$ ( c d ) $$$ ehab reply : operation $$$ a \oplus b $$$ bitwise - xor operation two number $$$ a $$$ $$$ b $$$ laggy guess $$$ ( a b ) $$$ 62 question 'll play game 're laggy interactor ehab 's guarantee $$$ 0 \le a b < 2^ { 30 } $$$ see interaction section print answer print ` ` ! a b '' ( without quote ) n't forget flush output print answer ask a question print ` ` ? c d '' ( without quote ) $$$ c $$$ $$$ d $$$ must non - negative integers less $$$ 2^ { 30 } $$$ n't forget flush output print question question read answer mention legend interactor reply -2 mean ask 62 query program terminate flush output use : <unknown> : hack someone print 2 space - separated integers $$$ a $$$ $$$ b $$$ $$$ ( 0 \le a b < 2^ { 30 } ) $$$ sample : hide number $$$ <unknown> $$$ $$$ <unknown> $$$ first query : $$$ 3 \oplus 2 = 1 $$$ $$$ 1 \oplus 1 = 0 $$$ answer 1 . second query : $$$ 3 \oplus 1 = 2 $$$ $$$ 1 \oplus 2 = 3 $$$ answer -1 . third query : $$$ 3 \oplus 2 = 1 $$$ $$$ 1 \oplus 0 = 1 $$$ answer 0 . print answer,"['bitmasks', 'implementation']",2000.0
1051/D,give a grid consist $$$ 2 $$$ row $$$ n $$$ columns cell grid color either black white two cells consider neighbour a common border share color two cells $$$ a $$$ $$$ b $$$ belong component neighbour a neighbour $$$ a $$$ belong component $$$ b $$$ let 's call <unknown> beautiful exactly $$$ k $$$ components count number beautiful bicolorings number big enough print answer modulo $$$ 998244353 $$$ line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 1000 $$$ $$$ 1 \le k \le 2n $$$ ) — number columns a grid number components require print a single integer — number beautiful bicolorings modulo $$$ 998244353 $$$ one possible bicolorings sample $$$ 1 $$$ :,"['bitmasks', 'dp']",1700.0
251/D,little petya like number a lot recently mother present a collection n non - negative integers 's one thing petya like number : play little masha immediately decide give a part new collection make game even interest petya decide give masha collection number follow condition fulfill : xor operation a bitwise exclude ` ` '' denote ` ` xor '' pascal language ` ` ^ '' c / <unknown> help petya divide collection describe multiple suitable ways divide find please note petya give a part number masha may number leave reverse situation also possible petya give nothing masha case must assume xor empty set number equal 0 . first line contain integer n ( 1 ≤ n ≤ 105 ) show many number petya 's mother give second line contain actual space - separated number integer non - negative exceed 1018 . print n space - separated integers i - th equal either 1 petya keep number follow i - th collection equal 2 petya give correspond number masha number index order give input,"['bitmasks', 'math']",2700.0
757/D,"gym leaders fascinate <unknown> take place <unknown> camp , curious know secret behind evolve pokemon organizers camp give gym leaders a pokeblock a sequence n ingredients ingredient type 0 1 . organizers tell gym leaders evolve a pokemon type k ( k ≥ 2 ) need make a valid set k cut pokeblock get smaller block suppose give pokeblock sequence <unknown> ... bn - 1 . a choice make cut n + 1 place i.e. b0 b0 b1 b1 b2 ... bn - 2 bn - 1 bn - 1 . n + 1 choices make cut follow ( a | denote a possible cut ) : consider a sequence k cut pair consecutive cut contain a binary string form ingredient type ingredients first cut last cut waste say consider exactly k - 1 binary substrings every substring read a binary number let m maximum number obtain number obtain number positive set obtain number contain integers 1 m set cut say a valid set cut example suppose give pokeblock sequence <unknown> make 5 cut follow way : 4 binary substrings obtain : 11 010 01 1 correspond number 3 2 1 1 respectively m = 3 maximum value among obtain number obtain number positive obtain integers 1 m. hence set cut a valid set 5 cut a pokemon type k evolve pokeblock cut use a valid set k cut many valid set size two valid set k cut consider different a cut one set set let f ( k ) denote number valid set k cut find value since value s large output s modulo 109 + 7 . input consist two line first line consist integer n ( 1 ≤ n ≤ 75 ) — length pokeblock next line contain pokeblock a binary string length n. output a single integer contain answer problem i.e. value s modulo 109 + 7 . first sample set valid cut : size 2 : <unknown> <unknown> <unknown> <unknown> size 3 : <unknown> <unknown> <unknown> <unknown> size 4 : <unknown> <unknown> hence f ( 2 ) = 4 f ( 3 ) = 4 f ( 4 ) = 2 . value s = 10 . second sample set valid cut : size 2 : <unknown> hence f ( 2 ) = 1 f ( 3 ) = 0 . value s = 1","['bitmasks', 'dp']",2200.0
1739/E,"consider a hallway represent matrix $$$ 2 $$$ row $$$ n $$$ columns let 's denote cell intersection $$$ i $$$ -th row $$$ j $$$ -th column $$$ ( i j ) $$$ distance cells $$$ ( i_1 j_1 ) $$$ $$$ ( i_2 j_2 ) $$$ $$$ <unknown> - <unknown> + <unknown> - <unknown> $$$ a clean robot cell $$$ ( 1 1 ) $$$ cells hallway clean cells dirty ( cell robot clean ) want clean hallway go launch robot robot launch work follow least one cell dirty robot choose closest ( current cell ) cell among dirty move clean ( cell longer dirty ) clean a cell robot find closest dirty cell current cell , process repeat whole hallway clean however a critical bug robot 's program moment multiple closest ( robot 's current position ) dirty cells robot malfunction want clean hallway a way robot n't malfunction launch robot clean ( possibly zero ) dirty cells however n't want much dirty work nice smart ( yet <unknown> ) robot note make a clean cell dirty calculate maximum possible number cells leave dirty launch robot n't malfunction first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number columns hallway two line follow denote $$$ 1 $$$ -st $$$ 2 $$$ -nd row hallway line contain $$$ n $$$ character 0 denote a clean cell 1 denote a dirty cell start cell robot $$$ ( 1 1 ) $$$ clean print one integer — maximum possible number cells leave dirty launch robot n't malfunction first example clean cell $$$ ( 1 2 ) $$$ path robot $$$ ( 1 1 ) \rightarrow ( 2 1 ) \rightarrow ( 2 2 ) $$$ second example leave hallway path robot $$$ ( 1 1 ) \rightarrow ( 1 2 ) \rightarrow ( 2 2 ) $$$ third example clean cell $$$ ( 1 2 ) $$$ path robot $$$ ( 1 1 ) \rightarrow ( 2 1 ) \rightarrow ( 2 3 ) \rightarrow ( 2 4 ) \rightarrow ( 1 4 ) $$$ fourth example hallway already clean maybe launch robot earlier ?","['bitmasks', 'dp']",2400.0
662/A,know game ` ` nim '' play n pile stone i - th pile initially contain ai stone two players alternate turn a turn a player pick non - empty pile remove positive number stone one able make a move lose game petya vasya tire play nim invent version game name ` ` <unknown> nim '' n two - sided card one side i - th card number ai write side number bi begin game players put card table card one side side choose independently uniformly thus obtain a sequence c1 c2 ... cn ci equal ai bi take n pile stone i - th pile contain exactly ci stone play nim petya take first turn give players play optimally find probability petya 's victory output answer irreducible fraction first line input contain a single integer n ( 1 ≤ n ≤ 500 000 ) — number card deck follow n line contain description one card consist two integers ai bi ( 0 ≤ ai bi ≤ 1018 ) output answer irreducible fraction p / q. probability petya 's victory 0 print 0/1,"['bitmasks', 'math']",2400.0
855/E,harry come know dumbledore <unknown> <unknown> 's locket a horcrux locket present earlier 12 <unknown> place home <unknown> black 's mother steal present ministry magic office <unknown> umbridge harry 's former defense dark arts teacher harry <unknown> <unknown> <unknown> ministry upon reach umbridge 's office observe a code lock a puzzle ask calculate count magic number two integers l r ( inclusive ) harry remember <unknown> time umbridge define a magic number a number convert a give base b digits 0 b - 1 appear even number time representation without lead zero answer q query unlock office query three integers bi li ri base range find count magic number first line input contain q ( 1 ≤ q ≤ 105 ) — number query next q line contain three space separate integers bi li ri ( 2 ≤ bi ≤ 10 1 ≤ li ≤ ri ≤ 1018 ) output q line contain a single integer answer correspond query sample test case 1 first query convert number 4 9 base 2 get : base 2 representation 9 even number 1 0 . thus answer 1,"['bitmasks', 'dp']",2200.0
850/C,mojtaba arpa play a game a list n number game a player 's turn choose a number pk ( p a prime number k a positive integer ) pk divide least one number list number list divisible pk call x player delete x add list player make a valid choice p k lose mojtaba start game players alternatively make move determine one players winner players play optimally first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number elements list second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — elements list mojtaba win print ` ` mojtaba '' otherwise print ` ` arpa '' ( without quote ) print letter case ( upper lower ) first sample test mojtaba ca n't move second sample test mojtaba choose p = 17 k = 1 list change [ 1 1 1 1 ] third sample test mojtaba choose p = 17 k = 1 arpa choose p = 17 k = 1 win mojtaba choose p = 17 k = 2 arpa choose p = 17 k = 1 win,"['bitmasks', 'dp']",2200.0
845/F,polycarp own a shop capital berland recently criminal activity capital increase polycarp think establish better security storehouse shop storehouse represent a matrix n row m columns element matrix either ( empty space ) x ( a wall ) polycarp want hire guard ( possibly zero ) watch storehouse guard cell matrix protect every cell right cell every cell bottom cell nearest wall formally guard stand cell ( x0 y0 ) protect cell ( x1 y1 ) condition meet : guard place empty cells ( protect empty cells ) plan place guard set cells guard place ( course two plan different exist least one cell include first plan include second plan vice versa ) polycarp call a plan suitable one empty cell protect polycarp want know number suitable plan since large output modulo 109 + 7 . first line contain two number n m — length width storehouse ( 1 ≤ n m ≤ 250 1 ≤ nm ≤ 250 ) n line follow ith line contain a string consist m character — ith row matrix represent storehouse character either x. output number suitable plan modulo 109 + 7 . first example put least one guard three possible arrangements : one guard cell ( 1 1 ) one guard cell ( 1 3 ) two guard cells,"['bitmasks', 'dp']",2500.0
792/D,t a complete binary tree consist n vertices mean exactly one vertex a root vertex either a leaf ( n't children ) inner node ( exactly two children ) leave a complete binary tree depth ( distance root ) n a number n + 1 a power 2 . picture see a complete binary tree n = 15 . vertices number 1 n a special recursive way : recursively assign number vertices leave subtree ( current vertex a leaf ) assign a number current vertex recursively assign number vertices right subtree ( exist ) picture vertices number exactly use algorithm clear size a complete binary tree exist exactly one way give number vertices way number call symmetric write a program give n answer q query tree query consist integer number ui ( 1 ≤ ui ≤ n ) a string si ui number vertex si represent path start vertex string si n't contain character ' l ' ' r ' ' u ' mean traverse leave child right child parent respectively character si process leave right consider ui vertex path start 's impossible process a character ( example go leave child a leaf ) skip answer number vertex path represent si end example ui = 4 si = « <unknown> » answer 10 . first line contain two integer number n q ( 1 ≤ n ≤ 1018 q ≥ 1 ) n n + 1 a power 2 . next <unknown> line represent query ; query consist two consecutive line first two line contain ui ( 1 ≤ ui ≤ n ) second contain non - empty string si si n't contain character ' l ' ' r ' ' u ' guarantee sum lengths si ( i 1 ≤ i ≤ q ) n't exceed 105 . print q number i - th number must answer i - th query,"['bitmasks', 'trees']",1900.0
772/D,"give n integers a1 a2 ... , denote list integers t. let f ( l ) a function take a non - empty list integers l. function output another integer follow : example f ( 10 9 ) = 0 f ( 123 321 ) = 121 f ( <unknown> <unknown> <unknown> ) = 30 . define function word g ( x ) sum square sum elements nonempty subsequences t evaluate x plug f modulo 1 000 000 007 multiply x. last <unknown> <unknown> would like compute g ( 0 ) g ( 1 ) ... g ( 999 999 ) reduce output size print value denote bitwise xor operator first line contain integer n ( 1 ≤ n ≤ 1 000 000 ) — size list t. next line contain n space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 999 999 ) — elements list output a single integer answer problem first sample nonzero value g g ( 121 ) = <unknown> <unknown> <unknown> g ( 123 ) = 58 <unknown> 999 g ( 321 ) = <unknown> <unknown> <unknown> g ( 555 ) = <unknown> <unknown> <unknown> . bitwise xor number equal <unknown> <unknown> <unknown> . example , since subsequences [ 123 ] [ 123 555 ] evaluate 123 plug f. second sample last sample , <unknown> coefficient","['bitmasks', 'dp']",2700.0
769/D,vasya sequence consist n integers vasya consider pair integers x y k - interesting binary representation differ exactly k bits example k = 2 pair integers x = 5 y = 3 k - interesting binary representation <unknown> <unknown> differ exactly two bits vasya want know many pair index ( i j ) sequence i < j pair integers ai aj k - interesting task help vasya determine number first line contain two integers n k ( 2 ≤ n ≤ 105 0 ≤ k ≤ 14 ) — number integers vasya 's sequence number bits integers k - interesting pair differ second line contain sequence a1 a2 ... ( 0 ≤ ai ≤ 104 ) vasya print number pair ( i j ) i < j pair integers ai aj k - interesting first test 4 k - interesting pair : second test k = 0 . consequently integers k - interesting pair equal thus second test 6 k - interesting pair :,"['bitmasks', 'brute force']",1700.0
768/E,sam teach jon game stone <unknown> mind help devise a strategy fight white walkers rule game quite simple : jon believe ready battle sam think prove argument sam suggest play a modify version game modify version move make a pile example 4 stone remove a pile 4 stone remove pile sam set game make first move jon believe sam try prevent go battle jon want know win play optimally first line consist a single integer n ( 1 ≤ n ≤ 106 ) — number pile next n line contain integer si ( 1 ≤ si ≤ 60 ) — number stone i - th pile print a single line contain ` ` yes '' ( without quote ) jon win otherwise print ` ` '' ( without quote ) first case sam remove stone jon lose second case follow move possible sam : case last move make jon win game follow :,"['bitmasks', 'dp']",2100.0
580/D,"kefa come restaurant sit a table waiter immediately bring menu n dish kefa know need exactly m dish , n't want order dish twice taste many dish possible kefa know i - th dish give ai units satisfaction dish go well together dish go well together kefa set k rule eat food follow type — eat dish x exactly dish y ( dish x y ) satisfaction level raise c. course <unknown> want get maximal possible satisfaction go restaurant help hard task ! first line input contain three space - separated number n m k ( 1 ≤ m ≤ n ≤ 18 0 ≤ k ≤ n * ( n - 1 ) ) — number dish menu number portion kefa need eat get full number eat rule second line contain n space - separated number ai ( 0 ≤ ai ≤ 109 ) — satisfaction get i - th dish next k line contain rule i - th rule describe three number xi yi ci ( 1 ≤ xi yi ≤ n 0 ≤ ci ≤ 109 ) mean eat dish xi right dish yi kefa 's satisfaction increase ci guarantee pair index i j ( 1 ≤ i < j ≤ k ) xi = xj yi = yj single line output print maximum satisfaction kefa get go restaurant first sample best first eat second dish first one get one unit satisfaction dish plus one rule second test fit sequence choice 4 2 1 2 1 4 . case get satisfaction 7 dish also fulfill rule 1 get additional satisfaction 5","['bitmasks', 'dp']",1800.0
534/F,task write a program deal <unknown> field larger 5 × 20 . simplify <unknown> a task build field ( cell either white black ) satisfy give information row columns row column number contiguous black segment specify example size field n = 3 m = 5 <unknown> number contiguous black segment row : [ 2 3 2 ] columns : [ 1 0 1 2 1 ] solution may look like : guarantee test <unknown> exist least one solution first line follow two integers n m ( 1 ≤ n ≤ 5 1 ≤ m ≤ 20 ) — number row number columns respectively second line contain n integers a1 a2 ... ai number contiguous black segment i - th row field similarly third line contain m integers b1 b2 ... bm bi number contiguous black segment i - th column field guarantee exist least one solution output possible solution output consist n line contain m character denote white cell ` ` . '' black cell ` ` * '',"['bitmasks', 'dp']",2400.0
1093/G,give array $$$ a $$$ $$$ n $$$ point $$$ k $$$ <unknown> space let distance two point $$$ a_x $$$ $$$ a_y $$$ $$$ \sum \limits _ { i = 1 } ^ { k } |a _ { x i } - a _ { y i } | $$$ ( also know manhattan distance ) process $$$ q $$$ query follow two type : first line contain two number $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le k \le 5 $$$ ) — number elements $$$ a $$$ number dimension space respectively $$$ n $$$ line follow contain $$$ k $$$ integers $$$ a _ { i 1 } $$$ $$$ a _ { i 2 } $$$ ... $$$ a _ { i k } $$$ ( $$$ -1000000 \le a _ { i j } \le 1000000 $$$ ) — coordinate $$$ i $$$ -th point next line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query $$$ q $$$ line follow denote a query two type query : least one query second type print answer query second type,"['bitmasks', 'data structures']",2300.0
425/B,"sereja n × m rectangular table a cell table contain a zero a number one sereja want table meet follow requirement : connect component value form a rectangle side parallel side table rectangles fill cells , a component form a rectangle size h × w component must contain exactly <unknown> cells a connect component value a set cells table meet follow condition : sereja change value k cells table table meet describe requirement ? minimum number table cells change case ? first line contain integers n m k ( 1 ≤ n m ≤ 100 ; 1 ≤ k ≤ 10 ) next n line describe table a : i - th contain m integers ai1 ai2 ... aim ( 0 ≤ ai j ≤ 1 ) — value cells i - th row print -1 impossible meet requirement otherwise print minimum number cells change","['bitmasks', 'greedy']",2200.0
413/D,programmers r2 company love play 2048 . one day decide invent simplify version game — 2k a stripe imagine infinite one direction stripe consist unit square ( side square equal height stripe ) square either empty contain number initially square empty infinity one unit square number 2 4 appear player press a button appear number begin move towards begin stripe let 's assume number x move begin stripe stop : final stop number move process infinity get a new number 2 4 process repeat read note test sample better understand move strategy i guess ' ve understand game progress fully depend order number 2 4 appear let 's look sequence number 2 4 game assume sequence win result least one square get number greater equal 2k goal game make a win sequence n number everything simple number sequence identify beforehand give a sequence consist number 0 2 4 . count many ways replace 0 sequence 2 4 get a win sequence first line contain two integers n k ( 1 ≤ n ≤ 2000 ; 3 ≤ k ≤ 11 ) next line contain sequence n integers either 0 2 4 . print a single integer — number ways replace zero number 2 4 get a win sequence number rather large print modulo 1000000007 ( 109 + 7 ) consider first example begin strip look follow : 2 → 4 → 8 → 8 2 → 8 4 → 8 4 2 → 16 . better understand game see original game http : <unknown> please note game describe strip slightly different original game ( two number add original game keep move ) careful game <unknown> n't much time contest !,"['bitmasks', 'dp']",2000.0
377/C,kostya a <unknown> <unknown> <unknown> dota 2 . <unknown> corporation developer game recently release a new patch turn balance game upside kostya captain team realize greatest <unknown> lie want resort <unknown> <unknown> patch mathematical point view choose best heroes team every game a dota 2 match involve two team must choose heroes players team go play forbid choose hero several time even different team large <unknown> sport competitions kostya 's team go participate match hold captain mode mode captain select heroes make one two possible action a certain predetermine order : pick ban team captain may miss a pick a ban miss a pick a random hero add team available moment miss a ban hero ban ban kostya already identify strength heroes base new patch fix course kostya know order pick ban strength a team sum strengths team 's heroes team participate match seek maximize difference strengths <unknown> help kostya determine team first one second one advantage match large advantage first line contain a single integer n ( 2 ≤ n ≤ 100 ) — number heroes dota 2 . second line contain n integers s1 s2 ... sn ( 1 ≤ si ≤ 106 ) — strengths heroes third line contain a single integer m ( 2 ≤ m ≤ min ( n 20 ) ) — number action captain team must perform next m line look like ` ` action team '' action need action : a pick ( represent a ` ` p '' ) a ban ( represent a ` ` b '' ) team number team need perform action ( number 1 2 ) guarantee team make least one pick besides team number pick number ban print a single integer — difference strength first team strength second team captain team act optimally well,"['bitmasks', 'dp']",2200.0
888/G,give a complete undirected graph n vertices a number ai assign vertex weight edge vertices i j equal ai xor aj calculate weight minimum span tree graph first line contain n ( 1 ≤ n ≤ 200000 ) — number vertices graph second line contain n integers a1 a2 ... ( 0 ≤ ai < 230 ) — number assign vertices print one number — weight minimum span tree graph,"['bitmasks', 'data structures']",2300.0
903/F,give a matrix f 4 row n columns element matrix either asterisk ( * ) a dot ( . ) may perform follow operation arbitrary number time : choose a square submatrix f size k × k ( 1 ≤ k ≤ 4 ) replace element choose submatrix a dot choose a submatrix size k × k cost ak coin minimum number coin pay replace asterisk dot ? first line contain one integer n ( 4 ≤ n ≤ 1000 ) — number columns f. second line contain 4 integers a1 a2 a3 a4 ( 1 ≤ ai ≤ 1000 ) — cost replace square submatrix size 1 × 1 2 × 2 3 × 3 4 × 4 respectively four line follow contain n character denote a row matrix f. character either a dot asterisk print one integer — minimum number coin replace asterisk dot first example spend 8 coin replace submatrix 3 × 3 top - left corner 1 coin replace 1 × 1 submatrix bottom - right corner second example best option replace 4 × 4 submatrix contain columns 2 – 5 2 × 2 submatrix consist row 2 – 3 columns 6 – 7 . third example select submatrix 3 × 3 top - left corner submatrix 3 × 3 consist row 2 – 4 columns 2 – 4,"['bitmasks', 'dp']",2200.0
912/B,since grisha behave well last year new year 's <unknown> visit ded moroz bring <unknown> bag gift ! bag contain n <unknown> candy good <unknown> ' bakery label 1 n correspond tastiness two candy tastiness choice candy a direct effect grisha 's happiness one assume take <unknown> ones — holiday magic turn things upside xor - sum <unknown> matter ordinary sum ! a xor - sum a sequence integers a1 a2 ... define bitwise xor elements : denote bitwise xor operation ; bitwise xor find ded moroz warn grisha house visit grisha take k candy bag help grisha determine largest xor - sum ( largest xor - sum mean maximum happiness ! ) obtain sole string contain two integers n k ( 1 ≤ k ≤ n ≤ 1018 ) output one number — largest possible xor - sum first sample case one optimal answer 1 2 4 give xor - sum 7 . second sample case one example take six candy obtain xor - sum 7,"['bitmasks', 'number theory']",1300.0
993/B,"two participants give a pair distinct number 1 9 's exactly one number present pair want figure number match use a communication channel access without reveal participants communicate a set pair number include pair give pair communicate set <unknown> two different number determine certainty deduce common number determine certainty participants know number first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 12 $$$ ) — number pair first participant communicate second vice versa second line contain $$$ n $$$ pair integers $$$ 1 $$$ $$$ 9 $$$ — pair number communicate first participant second third line contain $$$ m $$$ pair integers $$$ 1 $$$ $$$ 9 $$$ — pair number communicate second participant first pair within set distinct ( particular a pair $$$ ( 1,2 ) $$$ pair $$$ ( 2,1 ) $$$ within set ) pair contain number twice guarantee two set contradict statements word pair first set a pair second set share exactly one number deduce share number certainty print number certainty deduce participants know share number know print $$$ 0 $$$ otherwise print $$$ -1 $$$ first example first participant communicate pair $$$ ( 1,2 ) $$$ $$$ ( 3,4 ) $$$ second communicate $$$ ( 1,5 ) $$$ $$$ ( 3,4 ) $$$ since know actual pair receive share exactly one number ca n't $$$ ( 3,4 ) $$$ thus first participant $$$ ( 1,2 ) $$$ second $$$ ( 1,5 ) $$$ point already know share number $$$ 1 $$$ second example either first participant $$$ ( 1,2 ) $$$ second $$$ ( 1,5 ) $$$ first $$$ ( 3,4 ) $$$ second $$$ ( 6,4 ) $$$ first case know share number $$$ 1 $$$ second case know share number $$$ 4 $$$ n't enough information tell $$$ 1 $$$ $$$ 4 $$$ apart third case first participant give $$$ ( 1,2 ) $$$ n't know share number since <unknown> second participant might give either $$$ ( 1,3 ) $$$ case share number $$$ 1 $$$ $$$ ( 2,3 ) $$$ case share number $$$ 2 $$$ second participant know number certainty neither first participant output $$$ -1 $$$","['bitmasks', 'brute force']",1900.0
543/C,multiset n string length consist lowercase english letter say string easy remember string position i letter c english alphabet string string multiset letter c position i. example a multiset string { ` ` abc '' ` ` aba '' ` ` <unknown> '' ` ` ada '' } easy remember multiset { ` ` abc '' ` ` ada '' ` ` <unknown> '' } easy remember : want change multiset a little easy remember aij coin change character j - th position i - th string lowercase letter english alphabet find minimum sum pay order make multiset string easy remember first line contain two integers n m ( 1 ≤ n m ≤ 20 ) — number string multiset length string respectively next n line contain string multiset consist lowercase english letter string 's length m. next n line contain m integers i - th contain integers ai1 ai2 ... aim ( 0 ≤ aij ≤ 106 ) print a single number — answer problem,"['bitmasks', 'dp']",2500.0
1362/B,among johnny 's <unknown> <unknown> two <unknown> harmless ones : apply bitwise operations sneak dad 's office usually case small children johnny <unknown> combine two <unknown> get a lot trouble a set $$$ s $$$ contain important number dad 's desk minute johnny hear decide 's a good idea choose a positive integer $$$ k $$$ replace element $$$ s $$$ set $$$ s $$$ $$$ s \oplus k $$$ ( $$$ \oplus $$$ denote exclusive operation ) help choose $$$ k $$$ johnny 's dad see difference son do play ( i.e johnny get set play ) possible number exist also possible many a case output smallest one note order elements a set n't matter i.e set $$$ \ { 1 2 3\ } $$$ equal set $$$ \ { 2 1 3\ } $$$ formally find smallest positive integer $$$ k $$$ $$$ \ { s \oplus k | s \in <unknown> } = s $$$ report number example $$$ s = \ { 1 3 4\ } $$$ $$$ k = 2 $$$ new set equal $$$ \ { 3 1 6\ } $$$ $$$ s = \ { 0 1 2 3\ } $$$ $$$ k = 1 $$$ play set stay first line input a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1024 $$$ ) number test case next line $$$ t $$$ test case follow consist two line first line a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1024 $$$ ) denote number elements set $$$ s $$$ second line consist $$$ n $$$ distinct integers $$$ s_i $$$ ( $$$ 0 \leq s_i < 1024 $$$ ) elements $$$ s $$$ guarantee sum $$$ n $$$ test case exceed $$$ 1024 $$$ print $$$ t $$$ line ; $$$ i $$$ -th line contain answer $$$ i $$$ -th test case minimal positive integer $$$ k $$$ satisfy condition $$$ -1 $$$ $$$ k $$$ exist first test case answer $$$ 1 $$$ a minimum positive integer satisfy condition,"['bitmasks', 'brute force']",1200.0
1322/D,a popular reality show recruit a new cast third season ! $$$ n $$$ candidates number $$$ 1 $$$ $$$ n $$$ interview candidate $$$ i $$$ aggressiveness level $$$ l_i $$$ recruit candidate cost show $$$ s_i $$$ roubles show host <unknown> applications candidates $$$ i=1 $$$ $$$ i = n $$$ increase indices decide whether recruit candidate aggressiveness level candidate $$$ i $$$ strictly higher already accept candidates candidate $$$ i $$$ definitely reject otherwise host may accept reject candidate <unknown> host want choose cast maximize total profit show make revenue follow aggressiveness level $$$ v $$$ a correspond profitability value $$$ <unknown> $$$ specify positive well negative recruit participants enter stage one one increase indices participant $$$ i $$$ enter stage events proceed follow : allow select empty set participants ( choose neither candidates ) host want recruit cast total profit maximize profit calculate total revenue events stage less total <unknown> recruit accept participants ( total $$$ s_i $$$ ) help host make show profitable possible first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 2000 $$$ ) — number candidates upper bind initial aggressiveness level second line contain $$$ n $$$ integers $$$ l_i $$$ ( $$$ 1 \le l_i \le m $$$ ) — initial aggressiveness level candidates third line contain $$$ n $$$ integers $$$ s_i $$$ ( $$$ 0 \le s_i \le 5000 $$$ ) — cost ( roubles ) recruit candidates fourth line contain $$$ n + m $$$ integers $$$ c_i $$$ ( $$$ <unknown> \le 5000 $$$ ) — profitability <unknown> level guarantee aggressiveness level participant never exceed $$$ n + m $$$ give condition print a single integer — largest profit show first sample case optimal recruit candidates $$$ 1 2 3 5 $$$ show pay $$$ 1 + 2 + 1 + 1 = 5 $$$ roubles <unknown> events stage proceed follow : total revenue show $$$ 4 + 3 + 1 + 1 + <unknown> $$$ roubles profit $$$ 11 - 5 = 6 $$$ roubles second sample case impossible recruit candidates since second one higher aggressiveness thus better recruit candidate $$$ 1 $$$,"['bitmasks', 'dp']",2800.0
472/G,a simple way create hard task : take one simple problem query try find algorithm solve faster <unknown> kind task usually appear oi contest usually involve data structure let 's try create a task example take ` ` ham distance problem '' : two binary string s t length ham distance number position correspond symbols different example ham distance ` ` <unknown> '' ` ` 10101 '' 2 ( different symbols mark bold ) use ham distance problem a query follow way : give two string a b several query query : ham distance two string <unknown> + 1 ... ap1 + len - 1 <unknown> + 1 ... <unknown> + len - 1 ? note problem string zero - based s = <unknown> ... s|s| - 1 . first line contain a string a ( 1 ≤ |a| ≤ 200000 ) second line contain a string b ( 1 ≤ |b| ≤ 200000 ) character string either ` ` 0 '' ` ` 1 '' third line contain integer q ( 1 ≤ q ≤ 400000 ) — number query follow q line contain three integers : p1 p2 len ( 0 ≤ p1 ≤ |a| - len ; 0 ≤ p2 ≤ |b| - len ) number denote parameters current query output q integers — answer query,"['bitmasks', 'data structures']",2800.0
1303/D,a bag size $$$ n $$$ also $$$ m $$$ box size $$$ i $$$ -th box $$$ a_i $$$ $$$ a_i $$$ integer non - negative power two divide box two part equal size goal fill bag completely example $$$ n = 10 $$$ $$$ a = [ 1 1 32 ] $$$ divide box size $$$ 32 $$$ two part size $$$ 16 $$$ divide box size $$$ 16 $$$ fill bag box size $$$ 1 $$$ $$$ 1 $$$ $$$ 8 $$$ calculate minimum number divisions require fill bag size $$$ n $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 10^ { 18 } 1 \le m \le 100000 $$$ ) — size bag number box respectively second line test case contain $$$ m $$$ integers $$$ a_1 a_2 \dots <unknown> $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — size box guarantee $$$ a_i $$$ a power two also guarantee sum $$$ m $$$ test case exceed $$$ 100000 $$$ test case print one integer — minimum number divisions require fill bag size $$$ n $$$ ( $$$ -1 $$$ impossible ),"['bitmasks', 'greedy']",1900.0
1238/E,a password often type — a string $$$ s $$$ length $$$ n $$$ every character string one first $$$ m $$$ lowercase latin letter since spend a lot time type want buy a new keyboard a keyboard a permutation first $$$ m $$$ latin letter example $$$ m = 3 $$$ six possible keyboards : abc acb bac bca <unknown> <unknown> since type password one finger need spend time move finger one password character next time move character $$$ s_i $$$ character $$$ s _ { i+1 } $$$ equal distance character keyboard total time spend type password a keyboard call slowness keyboard <unknown> slowness keyboard equal $$$ \sum\limits _ { <unknown> } ^ { n } <unknown> _ { s _ { i-1 } } - pos _ { s_i } | $$$ $$$ <unknown> $$$ position letter $$$ x $$$ keyboard example $$$ s $$$ <unknown> keyboard bac total time type password $$$ |pos_a - pos_a| + |pos_a - pos_c| + <unknown> - pos_a| + |pos_a - <unknown> + <unknown> - pos_c| $$$ = $$$ |2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3| $$$ = $$$ 0 + 1 + 1 + 1 + 2 = 5 $$$ buy a new keyboard want know minimum possible slowness keyboard first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100000 1 \le m \le 20 $$$ ) second line contain string $$$ s $$$ consist $$$ n $$$ character character one first $$$ m $$$ latin letter ( lowercase ) print one integer – minimum slowness a keyboard first test case consider statement second test case slowness keyboard $$$ 0 $$$ third test case one suitable keyboards <unknown>,"['bitmasks', 'dp']",2200.0
1234/F,give a string $$$ s $$$ consist first $$$ 20 $$$ lowercase latin letter ( ' a ' ' b ' ... ' t ' ) recall substring $$$ s [ l ; r ] $$$ string $$$ s $$$ string $$$ s_l s _ { l + 1 } \dots s_r $$$ example substrings ` ` codeforces '' ` ` code '' ` ` force '' ` ` f '' ` ` '' ` ` coder '' ` ` top '' perform follow operation : choose substring $$$ s [ l ; r ] $$$ reverse ( i.e string $$$ s_l s _ { l + 1 } \dots s_r $$$ become $$$ s_r s _ { r - 1 } \dots s_l $$$ ) goal maximize length maximum substring $$$ s $$$ consist distinct ( i.e unique ) character string consist distinct character character string appear example string ` ` abcde '' ` ` <unknown> '' ` ` minecraft '' consist distinct character string ` ` codeforces '' ` ` abacaba '' consist distinct character line input contain one string $$$ s $$$ consist $$$ 1000000 $$$ character ' a ' ' b ' ... ' t ' ( first $$$ 20 $$$ lowercase latin letter ) print one integer — maximum possible length maximum substring $$$ s $$$ consist distinct character reverse one substring,"['bitmasks', 'dp']",2200.0
1215/E,monocarp arrange $$$ n $$$ color marble a row color $$$ i $$$ -th marble $$$ a_i $$$ monocarp like order things want rearrange marble a way marble color form a <unknown> segment ( one segment color ) word monocarp want rearrange marble every color $$$ j $$$ leftmost marble color $$$ j $$$ $$$ l $$$ -th row rightmost marble color position $$$ r $$$ row every marble $$$ l $$$ $$$ r $$$ color $$$ j $$$ achieve goal monocarp follow operation number time : choose two neighbour marble swap calculate minimum number operations monocarp perform rearrange marble note order segment marble equal color matter require every color marble color form exactly one contiguous segment first line contain one integer $$$ n $$$ $$$ ( 2 \le n \le 4 \cdot 100000 ) $$$ — number marble second line contain integer sequence $$$ a_1 a_2 \dots a_n $$$ $$$ ( 1 \le a_i \le 20 ) $$$ $$$ a_i $$$ color $$$ i $$$ -th marble print minimum number operations monocarp perform achieve goal first example three operations enough firstly monocarp swap third fourth marble sequence color $$$ [ 3 4 3 2 4 2 2 ] $$$ monocarp swap second third marble sequence $$$ [ 3 3 4 2 4 2 2 ] $$$ finally monocarp swap fourth fifth marble sequence $$$ [ 3 3 4 4 2 2 2 ] $$$ second example 's need perform operations,"['bitmasks', 'dp']",2200.0
1214/G,recently <unknown> come a fascinate <unknown> find a chameleon mood consider chameleon body a rectangular table $$$ n \times m $$$ cell may green blue may change two color denote $$$ ( x y ) $$$ ( $$$ 1 \leq x \leq n $$$ $$$ 1 \leq y \leq m $$$ ) cell row $$$ x $$$ column $$$ y $$$ let us define a chameleon good mood certificate four cells corner subrectangle table color opposite cells among four similar time four cell color similar formally a group four cells $$$ ( x_1 y_1 ) $$$ $$$ ( x_1 y_2 ) $$$ $$$ ( x_2 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ $$$ 1 \leq x_1 < x_2 \leq n $$$ $$$ 1 \leq y_1 < y_2 \leq m $$$ color $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ coincide color $$$ ( x_1 y_2 ) $$$ $$$ ( x_2 y_1 ) $$$ coincide four cells share color find whenever four cells present chameleon good mood vice versa : four cells chameleon bad mood ask help scientists write a program determine mood chameleon let us consider initially cells chameleon green chameleon color may change several time one change color contiguous segment table row replace opposite formally color change define three integers $$$ a $$$ $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq a \leq n $$$ $$$ 1 \leq l \leq r \leq m $$$ ) change color cells $$$ ( a b ) $$$ $$$ l \leq b \leq r $$$ replace opposite write a program report mood chameleon change additionally chameleon mood good program find four number $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ four cells $$$ ( x_1 y_1 ) $$$ $$$ ( x_1 y_2 ) $$$ $$$ ( x_2 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ good mood certificate first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \leq n m \leq 2000 $$$ $$$ 1 \leq q \leq <unknown> $$$ ) size table number change respectively follow $$$ q $$$ line contain 3 integers $$$ a_i $$$ $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \leq a_i \leq n $$$ $$$ 1 \leq l_i \leq r_i \leq m $$$ ) describe $$$ i $$$ -th color change print $$$ q $$$ line $$$ i $$$ -th line report chameleon mood first $$$ i $$$ color change $$$ 1 \leq i \leq q $$$ chameleon bad mood print integer $$$ -1 $$$ otherwise print four integers $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \leq x_1 < x_2 \leq n $$$ $$$ 1 \leq y_1 < y_2 \leq m $$$ ) four cells $$$ ( x_1 y_1 ) $$$ $$$ ( x_1 y_2 ) $$$ $$$ ( x_2 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ good mood certificate several ways choose four integers print valid one,"['bitmasks', 'data structures']",3200.0
1202/A,"give two binary string $$$ x $$$ $$$ y $$$ binary representations two integers ( let 's denote integers $$$ f ( x ) $$$ $$$ f ( y ) $$$ ) choose integer $$$ k \ge 0 $$$ calculate expression $$$ s_k = f ( x ) + f ( y ) \cdot 2^k $$$ write binary representation $$$ s_k $$$ reverse order ( let 's denote $$$ rev_k $$$ ) example let $$$ x = 1010 $$$ $$$ y = 11 $$$ ; ' ve choose $$$ k = 1 $$$ since $$$ 2 ^ 1 = 10_2 $$$ $$$ s_k = 1010_2 + <unknown> \cdot 10_2 = <unknown> $$$ $$$ rev_k = <unknown> $$$ give $$$ x $$$ $$$ y $$$ need choose $$$ k $$$ $$$ rev_k $$$ lexicographically minimal ( read note n't know ` ` lexicographically '' mean ) 's guarantee give constraints $$$ k $$$ exist finite first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number query next $$$ 2 t $$$ line contain a description query : two line per query first line contain one binary string $$$ x $$$ consist $$$ 100000 $$$ character character either 0 1 . second line contain one binary string $$$ y $$$ consist $$$ 100000 $$$ character character either 0 1 . 's guarantee $$$ 1 \le f ( y ) \le f ( x ) $$$ ( $$$ f ( x ) $$$ integer represent $$$ x $$$ $$$ f ( y ) $$$ integer represent $$$ y $$$ ) representations n't lead zero total length $$$ x $$$ query n't exceed $$$ 100000 $$$ total length $$$ y $$$ query n't exceed $$$ 100000 $$$ print $$$ t $$$ integers ( one per query ) query print $$$ k $$$ $$$ rev_k $$$ lexicographically minimal first query describe legend second query 's optimal choose $$$ k = 3 $$$ $$$ 2 ^ 3 = 1000_2 $$$ $$$ s_3 = <unknown> + <unknown> \cdot 1000_2 = <unknown> + <unknown> = 1000001 $$$ $$$ rev_3 = 1000001 $$$ example $$$ k = 0 $$$ $$$ s_0 = <unknown> $$$ $$$ rev_0 = 11101 $$$ $$$ rev_3 = 1000001 $$$ lexicographically smaller $$$ rev_0 = 11101 $$$ third query $$$ s_0 = 10 $$$ $$$ rev_0 = 01 $$$ example $$$ s_2 = 101 $$$ $$$ <unknown> = 101 $$$ $$$ 01 $$$ lexicographically smaller $$$ 101 $$$ quote wikipedia : ` ` determine two string character come arrange lexicographical order first letter compare differ string whose first letter come earlier alphabet come string first letter second letter compare , a position reach one string letter compare first ( shorter ) string <unknown> come first alphabetical order . ''","['bitmasks', 'greedy']",1100.0
367/D,"sereja m non - empty set integers a1 a2 ... , a lucky coincidence ! give set a partition set integers 1 n. word integer v ( 1 ≤ v ≤ n ) exactly one set also sereja integer d. sereja decide choose set set let 's suppose i1 i2 ... ik ( 1 ≤ i1 < i2 < ... < ik ≤ m ) index choose set let 's define array integers b sort ascend order a union choose set , 'll represent element number j array ( ascend order ) bj sereja consider choice set correct follow condition meet : sereja want know minimum number set ( k ) choose choice correct help first line contain integers n m d ( 1 ≤ d ≤ n ≤ 105 1 ≤ m ≤ 20 ) next m line contain set first number i - th line si ( 1 ≤ si ≤ n ) number denote size i - th set line contain si distinct integers 1 n — set ai guarantee set form partition integers 1 n. a single line print answer problem — minimum value k right choice","['bitmasks', 'dfs and similar']",2400.0
718/E,today matvey 's birthday never know ask a present friends give a string s length n. string consist first eight english letter : ' a ' ' b ' ... ' h ' first question come mind : might ever need string ? matvey a special boy instantly find string use build undirected graph vertices correspond position string edge distinct position a b ( 1 ≤ a b ≤ n ) least one follow condition hold : matvey decide find diameter graph diameter a maximum distance ( length shortest path ) among pair vertices also matvey want find number pair vertices distance equal diameter graph cool experience programmer manage solve problem fast ? first line input contain a single integer n ( 2 ≤ n ≤ 100 000 ) — length string second line contain string s 's guarantee s consist first eight letter english alphabet print two integers — diameter graph number pair position distance equal diameter consider second sample maximum distance 2 . 's obtain pair ( 1 4 ) ( 2 4 ) ( 4 6 ) ( 4 7 ),"['bitmasks', 'graphs']",3300.0
1334/G,give a permutation $$$ p $$$ consist exactly $$$ 26 $$$ integers $$$ 1 $$$ $$$ 26 $$$ ( since a permutation integer $$$ 1 $$$ $$$ 26 $$$ occur $$$ p $$$ exactly ) two string $$$ s $$$ $$$ t $$$ consist lowercase latin letter a substring $$$ t ' $$$ string $$$ t $$$ occurence string $$$ s $$$ follow condition meet : example $$$ p_1 = 2 $$$ $$$ p_2 = 3 $$$ $$$ p_3 = 1 $$$ $$$ s = \text { abc } $$$ $$$ t = \text { <unknown> } $$$ three substrings $$$ t $$$ occurences $$$ s $$$ ( $$$ t ' = \text { abc } $$$ $$$ t ' = \text { bca } $$$ $$$ t ' = \text { aba } $$$ ) substring $$$ t $$$ length equal $$$ |s| $$$ check occurence $$$ s $$$ first line contain $$$ 26 $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p _ { 26 } $$$ ( $$$ 1 \le p_i \le 26 $$$ integers pairwise distinct ) second line contain one string $$$ s $$$ third line contain one string $$$ t $$$ ( $$$ 2 \le |s| \le |t| \le 200000 $$$ ) consist lowercase latin letter print a string $$$ |t| - |s| + 1 $$$ character character either 0 1 . $$$ i $$$ -th character 1 substring $$$ t $$$ start $$$ i $$$ -th character end $$$ ( i + |s| - 1 ) $$$ -th character ( inclusive ) occurence $$$ s $$$,"['bitmasks', 'brute force']",2900.0
1264/D2,hard version problem difference limit $$$ n $$$ - length input string version $$$ 1 \leq n \leq 1000000 $$$ let 's define a correct bracket sequence depth follow : a ( necessarily correct ) bracket sequence $$$ s $$$ define depth maximum depth correct bracket sequence induce remove character $$$ s $$$ ( possibly zero ) example : bracket sequence $$$ s = $$$ ` ` ( ) ) ( ( ) ) '' depth $$$ 2 $$$ remove third character obtain a correct bracket sequence ` ` ( ) ( ( ) ) '' depth $$$ 2 $$$ give a string $$$ a $$$ consist character ' ( ' ' ) ' ' ? ' consider ( necessarily correct ) bracket sequence obtain replace character ' ? ' $$$ a $$$ either ' ( ' ' ) ' calculate sum depths bracket sequence number large find modulo $$$ 998244353 $$$ hack problem do easy hard versions problem solve line contain a non - empty string consist ' ( ' ' ) ' ' ? ' length string $$$ 1000000 $$$ print answer modulo $$$ 998244353 $$$ a single line first test case obtain $$$ 4 $$$ bracket sequence replace character ' ? ' either ' ( ' ' ) ' : answer $$$ 1 = 0 + 0 + 0 + 1 $$$ second test case obtain $$$ 4 $$$ bracket sequence replace character ' ? ' either ' ( ' ' ) ' : answer $$$ 9 = 2 + 2 + 3 + 2 $$$,['combinatorics'],2900.0
1251/F,polycarp want build a fence near house $$$ n $$$ white board $$$ k $$$ red board use build board <unknown> length integer a good fence consist exactly one red board several ( possibly zero ) white board red board longest one fence ( every white board use fence strictly shorter ) sequence lengths board ascend red board descend formally $$$ m $$$ board use lengths $$$ l_1 $$$ $$$ l_2 $$$ ... $$$ l_m $$$ order place fence leave right ( let 's call array $$$ [ l_1 l_2 \dots l_m ] $$$ array lengths ) follow condition hold : polycarp build fence place board leave right height $$$ 0 $$$ without gap board compose a polygon : polycarp interest fence special <unknown> $$$ q $$$ even integers really like ( integers $$$ q_1 $$$ $$$ q_2 $$$ ... $$$ q_q $$$ ) every integer $$$ q_i $$$ want calculate number different fence perimeter $$$ q_i $$$ build ( two fence consider different array lengths different ) help calculate value ? first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 300000 $$$ $$$ 1 \le k \le 5 $$$ ) — number white red board polycarp second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le 300000 $$$ ) — lengths white board polycarp third line contain $$$ k $$$ integers $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_k $$$ ( $$$ 1 \le b_i \le 300000 $$$ ) — lengths red board polycarp $$$ b_i $$$ distinct fourth line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 300000 $$$ ) — number special integers fifth line contain $$$ q $$$ integers $$$ q_1 $$$ $$$ q_2 $$$ ... $$$ q_q $$$ ( $$$ 4 \le q_i \le <unknown> $$$ every $$$ q_i $$$ even ) — special integers polycarp like $$$ q_i $$$ print one integer — number good fence perimeter $$$ q_i $$$ polycarp build take modulo $$$ 998244353 $$$ possible fence first example denote array lengths ( length red board highlight ) :,['combinatorics'],2500.0
40/E,find recently berland 's current economical state describe use a simple table n × m size n — number days berland month m — number months thus a table cell correspond a day a month berland 's year cell contain either 1 -1 mean state 's gain a particular month a particular day 1 correspond profit -1 correspond <unknown> turn important successful development analyze data state economy previous year however <unknown> refer <unknown> retrieve data turn table <unknown> damage table cells number value <unknown> impossible decipher know number cells data preserve strictly less max ( n m ) however additional information — product number line column equal -1 . task find many different table may conform preserve data answer task quite large find modulo p. first line contain integers n m ( 1 ≤ n m ≤ 1000 ) second line contain integer k ( 0 ≤ k < max ( n m ) ) — number cells data preserve next k line contain data state table preserve cells line form ` ` a b c '' a ( 1 ≤ a ≤ n ) — number table row b ( 1 ≤ b ≤ m ) — number column c — value contain cell ( 1 -1 ) number start 1 . guarantee two line a b value exist last line contain integer p ( 2 ≤ p ≤ 109 + 7 ) print number different table could conform preserve data modulo p,['combinatorics'],2500.0
152/C,one day little vasya find mom 's pocket book book n name friends unusually enough name exactly m letter long let 's number name 1 n order write mom n't home vasya decide play name : choose three integers i j k ( 1 ≤ i < j ≤ n 1 ≤ k ≤ m ) take name number i j swap prefix length k. example take name ` ` <unknown> '' ` ` <unknown> '' swap prefix length 3 result name ` ` <unknown> '' ` ` <unknown> '' wonder many different name vasya write instead name number 1 vasya allow perform number describe action vasya perform action choose number i j k independently previous move choice base entirely seek number large find modulo 1000000007 ( 109 + 7 ) first input line contain two integers n m ( 1 ≤ n m ≤ 100 ) — number name length name correspondingly n line contain name name consist exactly m uppercase latin letter print single number — number different name could end position number 1 pocket book apply <unknown> describe print number modulo 1000000007 ( 109 + 7 ) first sample vasya get follow name position number 1 : ` ` aab '' ` ` aaa '' ` ` baa '' ` ` <unknown> '',['combinatorics'],1400.0
135/E,little petya much like string recently receive a voucher purchase a string a gift mother string buy local shop one consider shop sort string alphabet fix size size alphabet equal k. however voucher a string type limitation : specifically voucher use purchase string s length string 's longest substring also weak subsequence ( see definition give ) equal w. string a length n consider weak subsequence string s length m exist a set index 1 ≤ i1 < i2 < ... < ≤ m follow two properties : petya get interest many different string available purchase shop number string large please find modulo 1000000007 ( 109 + 7 ) infinitely many string print ` ` -1 '' first line contain two integers k ( 1 ≤ k ≤ 106 ) w ( 2 ≤ w ≤ 109 ) — alphabet size require length maximum substring also weak subsequence correspondingly print a single number — number string petya buy use voucher modulo 1000000007 ( 109 + 7 ) infinitely many string print ` ` -1 '' ( without quote ) first sample petya buy follow string : aaa aab abab abb abba baa <unknown> baba bba bbb,['combinatorics'],3000.0
52/B,give a n × m field consist periods ( ' . ' ) asterisk ( ' * ' ) task count right triangles two side parallel square side whose vertices center ' * ' <unknown> a right triangle a triangle one angle a right angle ( a 90 degree angle ) first line contain two positive integer number n m ( 1 ≤ n m ≤ 1000 ) follow n line consist m character describe field ' . ' ' * ' allow output a single number — total number square triangles field please use % lld specificator read write 64 - bit integers c++ preffered use cout ( also may use % i64d ),['combinatorics'],1600.0
1207/D,give a sequence $$$ n $$$ pair integers : $$$ ( a_1 b_1 ) ( a_2 b_2 ) \dots ( a_n b_n ) $$$ sequence call bad sort non - descending order first elements sort non - descending order second elements otherwise sequence good examples good bad sequence : calculate number permutations size $$$ n $$$ apply permutation sequence $$$ s $$$ turn a good sequence a permutation $$$ p $$$ size $$$ n $$$ a sequence $$$ p_1 p_2 \dots p_n $$$ consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ ( $$$ 1 \le p_i \le n $$$ ) apply permutation $$$ p_1 p_2 \dots p_n $$$ sequence $$$ s_1 s_2 \dots s_n $$$ get sequence $$$ s _ { p_1 } s _ { p_2 } \dots s _ { p_n } $$$ example $$$ s = [ ( 1 2 ) ( 1 3 ) ( 2 3 ) ] $$$ $$$ p = [ 2 3 1 ] $$$ $$$ s $$$ turn $$$ [ ( 1 3 ) ( 2 3 ) ( 1 2 ) ] $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) next $$$ n $$$ line contain description sequence $$$ s $$$ $$$ i $$$ -th line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ ) — first second elements $$$ i $$$ -th pair sequence sequence $$$ s $$$ may contain equal elements print number permutations size $$$ n $$$ apply permutation sequence $$$ s $$$ turn a good sequence print answer modulo $$$ 998244353 $$$ ( a prime number ) first test case six permutations size $$$ 3 $$$ :,['combinatorics'],1800.0
690/D2,"heidi cow <unknown> : crack <unknown> wall ? zombies gather outside form group prepare <unknown> ? must happen ! quickly <unknown> hc2 ( <unknown> crazy <unknown> ) look right <unknown> : build a wall : seem easy enough heidi a cod cow a construct cow mind keep come back point 2b despite <unknown> danger a zombie <unknown> wonder many possible wall could build n bricks a wall a set wall segment define easy version many different wall construct wall consist least 1 n bricks ? two wall different exist a column c a row r one wall a brick spot , along n give c width wall ( define easy version ) return number different wall modulo 106 + 3 . first line contain two space - separated integers n c 1 ≤ n ≤ 500000 1 ≤ c ≤ 200000 . print number different wall heidi could build modulo 106 + 3 . number 106 + 3 prime second sample case five wall : third sample case nine wall five second sample case addition follow four :",['combinatorics'],1800.0
171/B,input contain a single integer a ( 1 ≤ a ≤ <unknown> ) print a single integer output ( 1 ≤ output ≤ 2·109 ),['combinatorics'],1300.0
985/G,$$$ n $$$ players number $$$ 0 $$$ $$$ n-1 $$$ rank $$$ i $$$ -th player rank $$$ i $$$ players form team : team consist three players pair players team a conflict rank team calculate use follow algorithm : let $$$ i $$$ $$$ j $$$ $$$ k $$$ rank players team $$$ i < j < k $$$ rank team equal $$$ a \cdot i + b \cdot j + c \cdot k $$$ give information pair players a conflict calculate total sum rank possible valid team modulo $$$ 2^ { 64 } $$$ first line contain two space - separated integers $$$ n $$$ $$$ m $$$ ( $$$ 3 \le n \le 200000 $$$ $$$ 0 \le m \le 200000 $$$ ) — number players number conflict pair second line contain three space - separated integers $$$ a $$$ $$$ b $$$ $$$ c $$$ ( $$$ 1 \le a b c \le 1000000 $$$ ) — coefficients team rank calculation next $$$ m $$$ line contain two space - separated integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 0 \le u_i v_i < n u_i \neq v_i $$$ ) — pair conflict players 's guarantee unordered pair players appear input file print single integer — total sum rank possible team modulo $$$ 2^ { 64 } $$$ first example $$$ 4 $$$ team valid i.e triple : { 0 1 2 } { 0 1 3 } { 0 2 3 } { 1 2 3 } second example team follow : { 0 2 3 } { 1 2 3 } third example team follow : { 0 1 2 } { 0 1 4 } { 0 1 5 } { 0 2 4 } { 0 2 5 } { 1 2 3 } { 1 2 4 } { 1 2 5 },['combinatorics'],2700.0
1188/E,moscow <unknown> icpc team get a balloon problem solve first team <unknown> red <unknown> get many balloon n't know spend come a problem several balloon $$$ 1000000 $$$ total one color one $$$ k $$$ color perform follow operation : choose $$$ k-1 $$$ balloon $$$ k-1 $$$ different color recolor remain color perform operation finite number time ( example perform operation least $$$ k-1 $$$ different color among current ball ) many different balloon configurations get ? number balloon color matter configurations differ order balloon count equal number large output modulo $$$ 998244353 $$$ first line contain a single integer $$$ k $$$ ( $$$ 2 \le k \le 100000 $$$ ) — the number color second line contain $$$ k $$$ integers $$$ a_1 a_2 \ldots a_k $$$ ( $$$ 0 \le a_i $$$ ) — initial configuration balloon $$$ a_i $$$ number balloon color $$$ i $$$ total number balloon n't exceed $$$ 1000000 $$$ word $$$ a_1 + a_2 + a_3 + \ldots + a_k \le 1000000 $$$ output number possible configurations modulo $$$ 998244353 $$$ first example $$$ 3 $$$ configurations get : $$$ [ 0 1 2 ] $$$ $$$ [ 2 0 1 ] $$$ $$$ [ 1 2 0 ] $$$ second example apply operation possible configurations : $$$ [ 1 1 1 1 ] $$$ $$$ [ 0 0 0 4 ] $$$ $$$ [ 0 0 4 0 ] $$$ $$$ [ 0 4 0 0 ] $$$ $$$ [ 4 0 0 0 ] $$$ third example ca n't apply operations <unknown> configuration start one,['combinatorics'],3300.0
288/B,"little penguin polo love home village village n house index integers 1 n. house a plaque contain integer i - th house a plaque contain integer pi ( 1 ≤ pi ≤ n ) little penguin polo love walk around village walk look like first stand a house number x. go house whose number write plaque house x ( house px ) go house whose number write plaque house px ( house <unknown> ) , know : need find number ways may write number house ' <unknown> fulfill three describe condition print remainder divide number 1000000007 ( 109 + 7 ) single line contain two space - separated integers n k ( 1 ≤ n ≤ 1000 1 ≤ k ≤ min ( 8 n ) ) — number house number k statement a single line print a single integer — answer problem modulo 1000000007 ( 109 + 7 )",['combinatorics'],1500.0
1089/I,"consider a permutation $$$ p_1 p_2 \dots p_n $$$ integers 1 $$$ n $$$ call a sub - segment $$$ p_l p _ { l+1 } \dots p _ { r-1 } p _ { r } $$$ permutation interval a reorder set consecutive integers example permutation $$$ ( <unknown> ) $$$ intervals $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ $$$ ( 3,2 ) $$$ others permutation trivial intervals — full permutation every single element call a permutation interval - free non - trivial intervals word interval - free permutation intervals length 2 $$$ n - 1 $$$ inclusive task count number interval - free permutations length $$$ n $$$ modulo prime number $$$ p $$$ first line input two integers $$$ t $$$ ( $$$ 1 \le t \le 400 $$$ ) $$$ p $$$ ( $$$ 100000000 \le p \le 1000000000 $$$ ) — number test case solve prime modulo next $$$ t $$$ line one integer $$$ n $$$ ( $$$ 1 \le n \le 400 $$$ ) — length permutation $$$ t $$$ test case print a single integer — number interval - free permutations modulo $$$ p $$$ $$$ n = 1 $$$ permutation interval - free $$$ n = 4 $$$ two interval - free permutations $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ $$$ n = 5 $$$ — $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ list <unknown> $$$ n = 9 $$$ example $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ interval - free exact value $$$ n = 20 $$$ <unknown>",['combinatorics'],2600.0
584/B,kolya love put gnomes circle table give coin tanya love study triplets gnomes sit vertexes equilateral triangle formally 3n gnomes sit a circle gnome 1 3 coin let 's number place order occur circle number 0 3n - 1 let gnome sit i - th place ai coin integer i ( 0 ≤ i < n ) ai + ai + n + ai + 2n ≠ 6 tanya satisfy count number ways choose ai tanya satisfy many ways distribute coin print remainder number modulo 109 + 7 . two ways a b consider distinct index i ( 0 ≤ i < 3n ) ai ≠ bi ( gnome get different number coin two ways ) a single line contain number n ( 1 ≤ n ≤ 105 ) — number gnomes divide three print a single number — remainder number variants distribute coin satisfy tanya modulo 109 + <unknown> ways n = 1 ( gnome index 0 sit top triangle gnome 1 right vertex gnome 2 leave vertex ) :,['combinatorics'],1500.0
323/A,give a cube size k × k × k consist unit cub two unit cub consider neighbour common face task paint k3 unit cub one two colour ( black white ) follow condition must satisfy : first line contain integer k ( 1 ≤ k ≤ 100 ) size cube print -1 solution otherwise print require paint cube consequently layer print a k × k matrix first k line show first layer cube paint follow k line print a k × k matrix — way second layer paint last k - th layer note orientation cube space matter mark a white unit cube symbol ` ` w '' a black one ` ` b '' use format output data give test sample may print extra empty line ignore,['combinatorics'],1600.0
176/C,"two players play a game game play a rectangular board n × m square begin game two different square board two chip first player 's goal shift chip square second player aim stop first one a <unknown> superglue 'll describe rule game detail players move turn first player begin every move first player choose one <unknown> chip shift one square leave right , allow move a chip beyond board edge begin a turn square board may cover a glue first player move chip square case chip get <unknown> glue move longer move second player select one free square ( contain a chip a glue ) cover superglue glue dry long square cover remain sticky end game , move first player chip square first player win first player make a move ( chip glue ) second player win note situation second player make a move impossible — always spread glue square first player move chip clarify case chip glue square case first player win game end soon chip square condition <unknown> ( <unknown> move ) arise know board size position two chip begin game board square glue - free find win players play optimally first line contain six integers n m x1 y1 x2 y2 — board size coordinate first second chip correspondingly ( 1 ≤ n m ≤ 100 ; 2 ≤ n × m ; 1 ≤ x1 x2 ≤ n ; 1 ≤ y1 y2 ≤ m ) number line separate single space guarantee chip locate different square first player win print ` ` first '' without quote otherwise print ` ` second '' without quote",['combinatorics'],2000.0
1151/F,a girl name sonya study <unknown> <unknown> kingdom <unknown> teacher computer science ( sonya 's favorite subject ! ) invent a task give array $$$ a $$$ length $$$ n $$$ consist number $$$ 0 $$$ $$$ 1 $$$ number $$$ k $$$ exactly $$$ k $$$ time follow happen : sonya 's task find probability operations complete $$$ a $$$ array sort non - decreasing order turn help help sonya solve problem show desire probability either $$$ 0 $$$ represent $$$ \dfrac { p } { q } $$$ $$$ p $$$ $$$ q $$$ coprime integers $$$ q \not\equiv <unknown> { 1000000000 + 7 } $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \leq n \leq 100 1 \leq k \leq 1000000000 $$$ ) — length array $$$ a $$$ number operations second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1 $$$ ) — description array $$$ a $$$ desire probability $$$ 0 $$$ print $$$ 0 $$$ otherwise print value $$$ p \cdot q^ { -1 } $$$ $$$ \pmod { 1000000000 + 7 } $$$ $$$ p $$$ $$$ q $$$ define first example possible variants final array $$$ a $$$ apply exactly two operations : $$$ ( 0 1 0 ) $$$ $$$ ( 0 0 1 ) $$$ $$$ ( 1 0 0 ) $$$ $$$ ( 1 0 0 ) $$$ $$$ ( 0 1 0 ) $$$ $$$ ( 0 0 1 ) $$$ $$$ ( 0 0 1 ) $$$ $$$ ( 1 0 0 ) $$$ $$$ ( 0 1 0 ) $$$ therefore answer $$$ \dfrac { 3 } { 9 } = \dfrac { 1 } { 3 } $$$ second example array sort non - decreasing order one operation therefore answer $$$ 0 $$$,"['combinatorics', 'dp']",2300.0
1835/E,"latest mission <unknown> u. s. s. coder captain jan <unknown> accidentally <unknown> surface unknown planet try find way back jan find artifact planet earth 's ancient civilization — a mobile device capable <unknown> call create <unknown> unfortunately another problem even though jan a <unknown> <unknown> know perfectly old notation cell phone number symbols device 's keyboard completely wear invisible human eye old keyboards exactly $$$ m + 1 $$$ button one digit base $$$ m $$$ numerical system one single backspace button allow one erase last write digit ( nothing write screen button nothing 's still count press ) jan would like communicate crew need type a certain number ( also base $$$ m $$$ numerical system , digits $$$ 0 $$$ $$$ m - 1 $$$ ) want know expect number button press necessary contact u. s. s. coder jan always choose optimal button base current knowledge button <unknown> press help ! first line input two integer number $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 1000000 $$$ $$$ 2 \le m \le 1000 $$$ ) — length number u. s. s. coder base numerical system next last input line $$$ n $$$ integers $$$ 0 $$$ $$$ m - 1 $$$ : number type base $$$ m $$$ numerical system output expect number button press modulo $$$ 1\,000\,000\,007 $$$ formally let $$$ m = 1\,000\,000\,007 $$$ show answer express irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \not \equiv 0 \pmod { m } $$$ output integer equal $$$ p \cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \le x < m $$$ $$$ x \cdot q \equiv p \pmod { m } $$$ first example two digits ( $$$ 0 $$$ $$$ 1 $$$ ) a backspace button available keyboard jan way know one press a random one probability $$$ \frac { 1 } { 3 } $$$ press $$$ 0 $$$ manage type crew 's number probability $$$ \frac { 1 } { 3 } $$$ press backspace nothing happen probability $$$ \frac { 1 } { 2 } $$$ manage press $$$ 0 $$$ ( finish process ) otherwise probability $$$ \frac { 1 } { 2 } $$$ type $$$ 1 $$$ need remove backspace hit last button $$$ 0 $$$ case need $$$ 4 $$$ button press last might press $$$ 1 $$$ button first also probability $$$ \frac { 1 } { 3 } $$$ , press backspace a chance $$$ 50\ % $$$ set need press last button ( 3 press total ) worst case would press $$$ 0 $$$ button first need remove backspace finally type number $$$ 0 $$$ ( 5 press total ) get expect value $$$ \frac { 16 } { 6 } $$$ modular inverse $$$ 6 $$$ modulo $$$ 1\ ; 000\ ; 000\ ; 007 $$$ $$$ <unknown> $$$ $$$ <unknown> = <unknown> \mod \ ; 1\ ; 000\ ; 000\ ; 007 $$$","['combinatorics', 'dp']",3500.0
1264/D1,easy version problem difference limit $$$ n $$$ - length input string version $$$ 1 \leq n \leq 2000 $$$ hard version challenge offer round second division let 's define a correct bracket sequence depth follow : a ( necessarily correct ) bracket sequence $$$ s $$$ define depth maximum depth correct bracket sequence induce remove character $$$ s $$$ ( possibly zero ) example : bracket sequence $$$ s = $$$ ` ` ( ) ) ( ( ) ) '' depth $$$ 2 $$$ remove third character obtain a correct bracket sequence ` ` ( ) ( ( ) ) '' depth $$$ 2 $$$ give a string $$$ a $$$ consist character ' ( ' ' ) ' ' ? ' consider ( necessarily correct ) bracket sequence obtain replace character ' ? ' $$$ a $$$ either ' ( ' ' ) ' calculate sum depths bracket sequence number large find modulo $$$ 998244353 $$$ hack problem first division do easy hard versions problem solve line contain a non - empty string consist ' ( ' ' ) ' ' ? ' length string $$$ 2000 $$$ print answer modulo $$$ 998244353 $$$ a single line first test case obtain $$$ 4 $$$ bracket sequence replace character ' ? ' either ' ( ' ' ) ' : answer $$$ 1 = 0 + 0 + 0 + 1 $$$ second test case obtain $$$ 4 $$$ bracket sequence replace character ' ? ' either ' ( ' ' ) ' : answer $$$ 9 = 2 + 2 + 3 + 2 $$$,"['combinatorics', 'dp']",2600.0
1418/E,play a computer game game fight $$$ n $$$ monsters defend monsters need a shield shield two parameters : current durability $$$ a $$$ defence rat $$$ b $$$ monster one parameter : strength $$$ d $$$ fight a monster strength $$$ d $$$ a shield current durability $$$ a $$$ defence $$$ b $$$ three possible outcomes : $$$ i $$$ -th monster strength $$$ d_i $$$ fight monsters exactly random order ( $$$ n ! $$$ order equiprobable ) consider $$$ m $$$ different shield $$$ i $$$ -th shield initial durability $$$ a_i $$$ defence rat $$$ b_i $$$ shield calculate expect amount damage receive take shield fight give $$$ n $$$ monsters random order first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200000 $$$ ) — number monsters number shield respectively second line contain $$$ n $$$ integers $$$ d_1 $$$ $$$ d_2 $$$ ... $$$ d_n $$$ ( $$$ 1 \le d_i \le 1000000000 $$$ ) $$$ d_i $$$ strength $$$ i $$$ -th monster $$$ m $$$ line follow $$$ i $$$ -th contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i \le n $$$ ; $$$ 1 \le b_i \le 1000000000 $$$ ) — description $$$ i $$$ -th shield print $$$ m $$$ integers $$$ i $$$ -th integer represent expect damage receive $$$ i $$$ -th shield follow : prove shield expect damage irreducible fraction $$$ \dfrac { x } { y } $$$ $$$ y $$$ coprime $$$ 998244353 $$$ print value $$$ x \cdot y^ { -1 } \bmod 998244353 $$$ $$$ y^ { -1 } $$$ inverse element $$$ y $$$ ( $$$ y \cdot y^ { -1 } \bmod 998244353 = 1 $$$ ),"['binary search', 'combinatorics']",2400.0
1765/C,"consider a deck card card one $$$ 4 $$$ suit exactly $$$ n $$$ card suit — total number card deck $$$ 4n $$$ deck shuffle randomly $$$ ( 4n ) ! $$$ possible order card deck probability result shuffle let $$$ c_i $$$ $$$ i $$$ -th card deck ( top bottom ) monocarp start draw card deck one one draw a card try guess suit monocarp remember suit $$$ k $$$ last card guess suit appear least often among last $$$ k $$$ card draw , draw $$$ i $$$ -th card monocarp guess suit suit appear minimum number time among card $$$ c _ { i - k } c _ { i - k+1 } \dots c _ { i-1 } $$$ ( $$$ i \le k $$$ monocarp consider previously draw card , card $$$ c_1 c_2 \dots c _ { i-1 } $$$ ) multiple suit appear minimum number time among previous card monocarp remember choose a random suit guess ( suit appear minimum number time probability choose ) make a guess monocarp draw a card compare suit guess match guess correct ; otherwise incorrect task calculate expect number correct guess monocarp make draw $$$ 4n $$$ card deck first ( ) line contain two integers $$$ n $$$ ( $$$ 1 \le n \le 500 $$$ ) $$$ k $$$ ( $$$ 1 \le k \le 4 \cdot n $$$ ) let expect value calculate irreducible fraction $$$ \dfrac { x } { y } $$$ print one integer — value $$$ x \cdot y^ { -1 } \bmod 998244353 $$$ $$$ y^ { -1 } $$$ inverse $$$ y $$$ ( i. e. integer $$$ y \cdot y^ { -1 } \bmod 998244353 = 1 $$$ )","['combinatorics', 'dp']",2600.0
1295/F,online contest soon hold forcecoders a large competitive program platform author prepare $$$ n $$$ problems ; since platform popular $$$ 998244351 $$$ coder world go solve problem author estimate number people would solve : $$$ i $$$ -th problem number accept solutions $$$ l_i $$$ $$$ r_i $$$ inclusive creator forcecoders use different criteria determine contest good bad one criteria number inversions problem order inversion a pair problems $$$ ( x y ) $$$ $$$ x $$$ locate earlier contest ( $$$ x < y $$$ ) number accept solutions $$$ y $$$ strictly greater obviously creator forcecoders author contest want contest good want calculate probability inversions problem order assume problem $$$ i $$$ <unknown> number accept solutions ( $$$ l_i $$$ $$$ r_i $$$ ) equally probable number independent first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 50 $$$ ) — number problems contest $$$ n $$$ line follow $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 0 \le l_i \le r_i \le 998244351 $$$ ) — minimum maximum number accept solutions $$$ i $$$ -th problem respectively probability inversions contest express irreducible fraction $$$ \frac { x } { y } $$$ $$$ y $$$ coprime $$$ 998244353 $$$ print one integer — value $$$ <unknown> { -1 } $$$ take modulo $$$ 998244353 $$$ $$$ y^ { -1 } $$$ integer $$$ <unknown> { -1 } \equiv 1 $$$ $$$ ( mod $$$ $$$ 998244353 ) $$$ real answer first test $$$ \frac { 1 } { 2 } $$$,"['combinatorics', 'dp']",2700.0
1439/D,"today final contest <unknown> ( <unknown> national olympiad informatics ) contest room a row $$$ n $$$ computers computers number integers $$$ 1 $$$ $$$ n $$$ leave right $$$ m $$$ participants number integers $$$ 1 $$$ $$$ m $$$ array $$$ a $$$ length $$$ m $$$ $$$ a _ { i } $$$ ( $$$ 1 \leq a_i \leq n $$$ ) computer behind $$$ i $$$ -th participant want sit also another array $$$ b $$$ length $$$ m $$$ consist character ' l ' ' r ' $$$ b_i $$$ side $$$ i $$$ -th participant enter room ' l ' mean participant enter leave computer $$$ 1 $$$ go leave right ' r ' mean participant enter right computer $$$ n $$$ go right leave participants order $$$ 1 $$$ $$$ m $$$ enter room one one $$$ i $$$ -th enter contest room direction $$$ b_i $$$ go sit behind $$$ a_i $$$ -th computer occupy keep walk direction reach first unoccupied computer , sit behind n't find computer get upset give contest madness $$$ i $$$ -th participant distance assign computer ( $$$ a_i $$$ ) computer end sit behind distance computers $$$ i $$$ $$$ j $$$ equal $$$ <unknown> - <unknown> $$$ value array $$$ a $$$ equal exist $$$ <unknown> \cdot <unknown> $$$ possible pair array $$$ ( a b ) $$$ consider pair array $$$ ( a b ) $$$ person become upset let 's calculate sum participants madnesses find sum value give prime modulo $$$ p $$$ find sum modulo $$$ p $$$ line contain three integers $$$ n $$$ $$$ m $$$ $$$ p $$$ ( $$$ 1 \leq m \leq n \leq 500 100000000 \leq p \leq 10 ^ 9 + 9 $$$ ) guarantee number $$$ p $$$ prime print one integer — require sum modulo $$$ p $$$ first test three possible array $$$ a $$$ : $$$ \ { 1\ } $$$ $$$ \ { 2\ } $$$ $$$ \ { 3\ } $$$ two possible array $$$ b $$$ : $$$ \ { \mathtt { l } \ } $$$ $$$ \ { \mathtt { r } \ } $$$ six pair array $$$ ( a b ) $$$ participant sit behind computer $$$ a_1 $$$ madness $$$ 0 $$$ total sum madnesses $$$ 0 $$$ second test possible pair array $$$ ( a b ) $$$ person become upset : answer $$$ 1 + 1 + 1 + 1 + 0 \ldots = 4 $$$","['combinatorics', 'dp']",3100.0
293/B,a rectangular n × m - cell board cells already paint k color need paint uncolored cell one k color path upper leave square lower right one n't contain two cells color path go along side - adjacent cells go right print number possible paint modulo 1000000007 ( 109 + 7 ) first line contain three integers n m k ( 1 ≤ n m ≤ 1000 1 ≤ k ≤ 10 ) next n line contain m integers — board first contain m uppermost cells board leave right second one contain m cells second uppermost row a number a line equal 0 correspond cell n't paint otherwise number represent initial color board cell — integer 1 k. consider color number 1 k manner print number possible paint modulo 1000000007 ( 109 + 7 ),"['brute force', 'combinatorics']",2700.0
28/C,n students live <unknown> every morning students wake time go wash . m room wash basins i - th room contain ai wash basins every student independently select one room equal probability go students select room students room divide queue number wash basins size largest queue least possible calculate expect value size largest queue among room first line contain two positive integers n m ( 1 ≤ n m ≤ 50 ) — amount students amount room second line contain m integers a1 a2 ... ( 1 ≤ ai ≤ 50 ) ai mean amount wash basins i - th room output single number : expect value size largest queue answer must absolute relative error less 10 - 9,"['combinatorics', 'dp']",2200.0
559/D,gerald get tire play board game usual six - sided die buy a <unknown> call randomizer function follow a randomizer coordinate plane a strictly convex polygon paint polygon call a basic polygon shake a randomizer draw nondegenerate ( i.e a non - zero area ) convex polygon vertices vertices basic polygon result roll ( precisely result shake ) consider number point integer coordinate strictly inside ( point border consider ) select polygon gerald wonder : expect result shake randomizer ? shake randomizer consider possible non - degenerate convex polygons vertices vertices basic polygon let 's assume k versions polygons randomizer choose probability first line input contain a single integer n ( 3 ≤ n ≤ 100 000 ) — number vertices basic polygon next n line contain coordinate vertices basic polygon i - th line contain two integers xi yi ( - 109 ≤ xi yi ≤ 109 ) — coordinate i - th vertex polygon vertices give counter - clockwise order print seek expect value absolute relative error 10 - 9 . a polygon call strictly convex convex vertices lie line let 's assume a random variable take value x1 ... xn probabilities p1 ... pn correspondingly expect value variable equal,"['combinatorics', 'geometry']",2800.0
351/B,jeff become friends furik two go play one quite amuse game begin game jeff take a piece paper write a permutation consist n number : p1 p2 ... pn guy take turn make move jeff move first move jeff choose two adjacent permutation elements boy swap move <unknown> toss a coin coin show ` ` head '' choose a random pair adjacent elements index i i + 1 inequality pi > pi + 1 hold swap coin show ` ` tail '' furik choose a random pair adjacent elements index i i + 1 inequality pi < pi + 1 hold swap coin show ` ` head '' ` ` tail '' furik multiple ways adjacent pair take uniformly take one pair furik n't pair take toss a coin one time game end permutation sort increase order jeff want game finish quickly possible ( want players make move possible ) help jeff find minimum mathematical expectation number move game move optimally well consider coin show head ( tail ) probability 50 percent first line contain integer n ( 1 ≤ n ≤ 3000 ) next line contain n distinct integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) — permutation p. number separate space a single line print a single real value — answer problem answer consider correct absolute relative error n't exceed 10 - 6 . first test sequence already sort answer 0,"['combinatorics', 'dp']",1900.0
459/C,recently pashmak <unknown> a transportation company company k bus a contract a school n students school plan take students d different place d days ( day one place ) day company provide bus trip pashmak arrange students bus want arrange students a way two students become close friends <unknown> idea two students become close friends bus d days please help pashmak weird idea assume bus unlimited capacity first line input contain three space - separated integers n k d ( 1 ≤ n d ≤ 1000 ; 1 ≤ k ≤ 109 ) valid arrangement print -1 . otherwise print d line print n integers j - th integer i - th line show bus j - th student take i - th day assume bus number 1 k. note two students become close friends share a bus day bus share differ day day,"['combinatorics', 'math']",1900.0
457/D,game bingo play a 5 × 5 square grid fill distinct number 1 75 . problem consider a <unknown> version play n × n grid distinct number 1 m ( m ≥ n2 ) a player begin select a randomly generate bingo grid ( generate uniformly among available <unknown> ) k distinct number 1 m call random ( call uniformly among available set k number ) call number appear grid player mark cell score end 2 raise power ( number completely mark row plus number completely mark columns ) determine expect value score expect score may large expect score larger 1099 print 1099 instead ( example ` ` <unknown> '' without quote ) input consist three integers n m k ( 1 ≤ n ≤ 300 ; n2 ≤ m ≤ 100000 ; n ≤ k ≤ m ) print smaller 1099 expect score answer must correct within absolute relative error 10 - 9,"['combinatorics', 'math']",2700.0
452/C,alex enjoy perform magic trick a trick require a deck n card m identical deck n different card mix together alex wish perform trick <unknown> n card random perform trick result deck look like a normal deck may duplicate card trick perform follow : first alex allow choose a random card deck memorize card put back deck alex shuffle deck pull a card card match one memorize trick successful n't think alex a good <unknown> pull a card randomly deck determine probability trick successful case first line input consist two integers n m ( 1 ≤ n m ≤ 1000 ) separate space — number card deck number deck line output print one float point number – probability alex successfully perform trick relative absolute error answer higher 10 - 6 . first sample probability alex perform trick two card value two different deck case trick guarantee succeed remain probability take two different card probability pull trick result probability,"['combinatorics', 'math']",2100.0
380/D,cinema theater hall sereja 's city n seat line front one large screen slot personal <unknown> leave right seat two adjacent seat exactly one share slot figure show arrangement seat slot n = 4 . today 's <unknown> a movie call ` ` dry hard '' ticket seat sell a strict <unknown> entrance theater n people come hall one one soon a person enter a cinema hall immediately ( <unknown> ) take seat occupy empty slot leave right empty slot man get really upset leave people constant 's hard predict order viewers enter hall seat sereja know number <unknown> ( number enter queue viewers ) come take seat others order a programmer a mathematician sereja wonder : many ways people enter hall nobody get upset ? number quite large print modulo 1000000007 ( 109 + 7 ) first line contain integer n ( 1 ≤ n ≤ 105 ) second line contain n integers i - th integer show either index person ( index enter queue ) ticket i - th seat a 0 index know guarantee positive number second line distinct assume index person enter cinema hall a unique integer 1 n. person index 1 come first hall person index 2 come second a single line print remainder divide answer number 1000000007 ( 109 + 7 ),"['combinatorics', 'math']",2500.0
340/E,iahub happy invent bubble sort graph 's stay day long office write permutations iahubina angry important iahub iahub go away iahubina come office <unknown> research work girl find important permutation research permutation contain n distinct integers a1 a2 ... ( 1 ≤ ai ≤ n ) replace permutation elements -1 value a revenge iahub find important permutation break try recover thing remember permutation n't fix point a fix point a permutation element ak value equal k ( ak = k ) job proof iahub try recover a good idea output number permutations could originally iahub 's important permutation modulo 1000000007 ( 109 + 7 ) first line contain integer n ( 2 ≤ n ≤ 2000 ) second line n integers represent iahub 's important permutation iahubina replace value -1 . 's guarantee fix point give permutation also give sequence contain least two number -1 positive number occur sequence 's guarantee least one suitable permutation output a single integer number ways iahub could recover permutation modulo 1000000007 ( 109 + 7 ) first test example two permutations fix point [ 2 5 4 3 1 ] [ 5 1 4 3 2 ] permutation would least one fix point,"['combinatorics', 'math']",2000.0
322/B,fox ciel flower : r red flower g green flower b blue flower want use flower make several bouquets 4 type bouquets : help fox ciel find maximal number bouquets make first line contain three integers r g b ( 0 ≤ r g b ≤ 109 ) — number red green blue flower print maximal number bouquets fox ciel make test case 1 make 1 red bouquet 2 green bouquets 3 blue bouquets test case 2 make 1 red 1 green 1 blue 1 mix bouquet,"['combinatorics', 'math']",1600.0
305/D,olya get a direct non - weighted graph consist n vertexes m edge consider graph vertexes index 1 n manner graph edge go vertex v vertex u follow inequation hold : v < u. olya wonder many ways add arbitrary ( possibly zero ) number edge graph follow condition meet : consider two ways distinct pair vertexes i j ( i < j ) first result graph edge i j second one n't help olya require number ways rather large print modulo 1000000007 ( 109 + 7 ) first line contain three space - separated integers n m k ( 2 ≤ n ≤ 106 0 ≤ m ≤ 105 1 ≤ k ≤ 106 ) next m line contain description edge initial graph i - th line contain a pair space - separated integers ui vi ( 1 ≤ ui < vi ≤ n ) — number vertexes a direct edge ui vi guarantee pair vertexes ui vi one edge also guarantee graph edge give order non - decreasing ui multiple edge go vertex ui guarantee edge give order increase vi print a single integer — answer problem modulo 1000000007 ( 109 + 7 ) first sample two ways : first way add anything second way add a single edge vertex 2 vertex 5,"['combinatorics', 'math']",2200.0
327/C,a long plate s contain n digits iahub want delete digits ( possibly none allow delete digits ) form ` ` magic number '' plate a number divisible 5 . note result number may contain lead zero iahub want count number ways obtain magic number modulo 1000000007 ( 109 + 7 ) two ways different set delete position s differ look input part statement s give a special form first line 're give a string a ( 1 ≤ |a| ≤ 105 ) contain digits second line 're give integer k ( 1 ≤ k ≤ 109 ) plate s form concatenate k copy a together n = <unknown> print a single integer — require number ways modulo 1000000007 ( 109 + 7 ) first case four possible ways make a number divisible 5 : 5 15 25 <unknown> . second case remember concatenate copy a. actual plate <unknown> . third case except delete digits choice therefore 26 - 1 = 63 possible ways delete digits,"['combinatorics', 'math']",1700.0
319/A,a tradition every year ioi members natalia fan club invite malek dance club a fun night together malek dance club 2n members <unknown> natalia fan club also 2n members member mdc assign a unique i d i 0 2n - 1 . hold member nfc one part tradition one one dance member mdc dance a member nfc a dance pair a pair number ( a b ) member a mdc dance member b nfc complexity a pair ' assignment number pair dance pair ( a b ) ( c d ) a < c b > d. give a binary number length n name x. know member i mdc dance member nfc task calculate complexity assignment modulo 1000000007 ( 109 + 7 ) expression denote apply « xor » number x y. operation exist modern program languages example c++ java denote « ^ » pascal — « xor » first line input contain a binary number x <unknown> n ( 1 ≤ n ≤ 100 ) number may contain lead zero print complexity give dance <unknown> modulo 1000000007 ( 109 + 7 ),"['combinatorics', 'math']",1600.0
865/G,"'s piegirl 's birthday soon pieguy decide buy a bouquet flower a basket chocolates flower shop f different type flower available i - th type flower always exactly pi petals pieguy decide buy a bouquet consist exactly n flower may buy type flower multiple time n flower arrange a bouquet position flower within a bouquet matter think a bouquet order list flower type chocolate shop sell chocolates box b different type box available i - th type box contain ci piece chocolate pieguy buy number box buy type box multiple time place box a basket position box within basket matter think basket order list box type pieguy know piegirl like pluck a petal a flower eat piece chocolate would like ensure eat last piece chocolate last box pluck last petal last flower , total number petals flower bouquet equal total number piece chocolate box basket many different bouquet+basket combinations pieguy buy ? answer may large compute modulo 1000000007 = 109 + 7 . first line input contain integers f b n ( 1 ≤ f ≤ 10 1 ≤ b ≤ 100 1 ≤ n ≤ 1018 ) number type flower number type box number flower must go bouquet respectively second line input contain f integers p1 p2 ... <unknown> ( 1 ≤ pi ≤ 109 ) number petals flower type third line input contain b integers c1 c2 ... cb ( 1 ≤ ci ≤ 250 ) number piece chocolate box type print number bouquet+basket combinations pieguy buy modulo 1000000007 = 109 + 7 . first example 1 way make a bouquet 9 petals ( 3 + 3 + 3 ) 1 way make a basket 9 piece chocolate ( 3 + 3 + 3 ) 1 possible combination 3 ways make a bouquet 13 petals ( 3 + 5 + 5 5 + 3 + 5 5 + 5 + 3 ) 5 ways make a basket 13 piece chocolate ( 3 + 10 10 + 3 3 + 3 + 7 3 + 7 + 3 7 + 3 + 3 ) 15 combinations finally 1 way make a bouquet 15 petals ( 5 + 5 + 5 ) 1 way make a basket 15 piece chocolate ( 3 + 3 + 3 + 3 + 3 ) 1 combination note possible multiple type flower number petals type still consider different similarly different type box may contain number piece chocolate still consider different","['combinatorics', 'math']",3300.0
938/E,give array a length n. define fa follow way : calculate sum fa n ! permutations array a modulo 109 + 7 . note : two elements consider different indices differ every array a exactly n ! permutations first line contain integer n ( 1 ≤ n ≤ 1 000 000 ) — size array a. second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) print integer sum fa n ! permutations array a modulo 109 + 7 . second example permutations : p array indices initial array a. sum fa equal 4,"['combinatorics', 'math']",2300.0
929/C,<unknown> у <unknown> <unknown> <unknown> <unknown> евгений <unknown> <unknown> <unknown> нужно выбрать <unknown> игроков которые выйдут на лед в <unknown> <unknown> : один вратарь два <unknown> и три нападающих так как это стартовый состав евгения больше <unknown> насколько <unknown> будет <unknown> на <unknown> чем <unknown> игроков а <unknown> евгений <unknown> выбрать <unknown> стартовый состав чтобы номера <unknown> двух игроков из <unknown> состава <unknown> не <unknown> чем в два <unknown> например игроки с номерами 13 14 10 18 15 и 20 <unknown> евгения а если например на лед выйдут игроки с номерами 8 и 17 то это не <unknown> евгения <unknown> <unknown> из игроков вам <unknown> на <unknown> <unknown> <unknown> <unknown> ( вратарь защитник <unknown> нападающий ) а также его <unknown> в <unknown> номера игроков не <unknown> идут <unknown> <unknown> число <unknown> стартовых составов из одного <unknown> двух защитников и <unknown> нападающих которые может выбрать евгений чтобы <unknown> его условие <unknown> <unknown> строка содержит три целых числа g d и f ( 1 ≤ g ≤ 1 000 1 ≤ d ≤ 1 000 1 ≤ f ≤ 1 000 ) — число вратарей защитников и нападающих в <unknown> евгения <unknown> строка содержит g целых чисел каждое в пределах от 1 до 100 000 — номера вратарей <unknown> строка содержит d целых чисел каждое в пределах от 1 до 100 000 — номера защитников <unknown> строка содержит f целых чисел каждое в пределах от 1 до 100 000 — номера нападающих <unknown> что <unknown> количество игроков не <unknown> 1 000 <unknown> . <unknown> . g + d + f ≤ 1 000 . все g + d + f <unknown> игроков <unknown> выведите <unknown> целое число — количество возможных стартовых составов в первом примере всего один <unknown> для <unknown> состава который <unknown> <unknown> <unknown> <unknown> ответ 1 . во втором примере <unknown> <unknown> <unknown> <unknown> ( в порядке вратарь - защитник - защитник - нападающий - нападающий - нападающий ) : <unknown> образом ответ на <unknown> <unknown> — 6,"['combinatorics', 'math']",1700.0
891/E,a false witness <unknown> lie ! give a sequence contain n integers a variable res equal 0 initially follow process repeat k time choose index 1 n uniformly random name x. add res multiply ai 's 1 ≤ i ≤ n i ≠ x. subtract ax 1 . find expect value res end process prove expect value res represent irreducible fraction find first line contain two integers n k ( 1 ≤ n ≤ 5000 1 ≤ k ≤ 109 ) — number elements parameter k specify statement second line contain n space separate integers a1 a2 ... ( 0 ≤ ai ≤ 109 ) output a single integer — value,"['combinatorics', 'math']",3000.0
660/E,a sequence a n integers 1 m inclusive denote f ( a ) number distinct subsequences a ( include empty subsequence ) give two positive integers n m. let s set sequence length n consist number 1 m. compute sum f ( a ) a s modulo 109 + 7 . line contain two integers n m ( 1 ≤ n m ≤ 106 ) — number elements array upper bind elements print integer c — desire sum modulo 109 + 7,"['combinatorics', 'math']",2300.0
610/A,pasha a wooden stick positive integer length n. want perform exactly three cut get four part stick part must positive integer length sum lengths obviously n. pasha like rectangles hat square wonder many ways split a stick four part 's possible form a rectangle use part impossible form a square task help pasha count number ways two ways cut stick consider distinct exist integer x number part length x first way differ number part length x second way first line input contain a positive integer n ( 1 ≤ n ≤ 2·109 ) — length pasha 's stick output contain a single integer — number ways split pasha 's stick four part positive integer length 's possible make a rectangle connect end part impossible form a square one way divide stick first sample { 1 1 2 2 } four ways divide stick second sample { 1 1 9 9 } { 2 2 8 8 } { 3 3 7 7 } { 4 4 6 6 } note { 5 5 5 5 } n't work,"['combinatorics', 'math']",1000.0
630/F,one company city decide create a group innovative <unknown> consist 5 7 people hire new employees place <unknown> company receive n resume hr department evaluate possible group composition select one task count number variants group composition evaluate line input contain one integer n ( 7 ≤ n ≤ 777 ) — number potential employees send resume output one integer — number different variants group composition,"['combinatorics', 'math']",1300.0
630/G,budget cut one company establish new non - financial reward system instead <unknown> two kinds action reward : fix critical bug suggest new interest feature a man fix a critical bug get ` ` i fix a critical bug '' pennant table a man suggest a new interest feature get ` ` i suggest a new feature '' pennant table limit budget new reward system 5 ` ` i fix a critical bug '' pennants 3 ` ` i suggest a new feature '' pennants buy order use pennants a long time make challenge ones a man fix a new critical bug one earlier award ` ` i fix a critical bug '' pennants pass table a man suggest a new interest feature one earlier award ` ` i suggest a new feature '' pennants pass table one man several pennants one type course pennants type table n table company find number ways place pennants table give pennant situate one table table big enough contain number pennants line input contain one integer n ( 1 ≤ n ≤ 500 ) — number table company output one integer — amount ways place pennants n table,"['combinatorics', 'math']",1600.0
26/D,a big fan formula one charlie really happy fact organize ticket sell next grand <unknown> race city unfortunately <unknown> crisis strike everywhere banknotes leave country value either 10 euros 20 euros price ticket race 10 euros whenever someone come ticket store 20 euro banknote charlie must a 10 euro banknote give change charlie realize huge <unknown> banknotes could a problem charlie <unknown> information could n't make use need help exactly n + m people come buy a ticket n a single 10 euro banknote m a single 20 euro banknote currently charlie k 10 euro banknotes use change need n + m people come ticket store random order order equiprobable return probability ticket sell process run <unknown> i.e charlie change every person 20 euro banknote input consist a single line three space separate integers n m k ( 0 ≤ n m ≤ 105 0 ≤ k ≤ 10 ) output a single line desire probability least 4 digits decimal point,"['combinatorics', 'math']",2400.0
131/C,n boys m girls attend a <unknown> club set a play ` ` big bang theory '' need choose a group contain exactly t <unknown> contain less 4 boys less one girl many ways choose a group ? course variants differ composition <unknown> consider different perform calculations 64 - bit type : long long с / с++ <unknown> <unknown> long java line input data contain three integers n m t ( 4 ≤ n ≤ 30 1 ≤ m ≤ 30 5 ≤ t ≤ n + m ) find require number ways please use % lld specificator read write 64 - bit integers с++ prefer use cin cout stream % i64d specificator,"['combinatorics', 'math']",1400.0
1837/E,"$$$ 2^k $$$ team participate a playoff tournament team number $$$ 1 $$$ $$$ 2^k $$$ order decrease strength , team $$$ 1 $$$ strongest one team $$$ 2^k $$$ <unknown> one a team a smaller number always defeat a team a larger number first team arrange order a procedure call seed team assign another unique value $$$ 1 $$$ $$$ 2^k $$$ call a seed represent start position playoff tournament consist $$$ 2^k - 1 $$$ game hold follow : team split pair : team seed $$$ 1 $$$ play team seed $$$ 2 $$$ team seed $$$ 3 $$$ play team seed $$$ 4 $$$ ( exactly order ) ( $$$ 2^ { k-1 } $$$ game play phase ) a team lose a game eliminate , $$$ 2^ { k-1 } $$$ team remain one team remain declare <unknown> ; otherwise $$$ 2^ { <unknown> } $$$ game play : first one winner game ` ` seed $$$ 1 $$$ vs seed $$$ 2 $$$ ` ` play winner game ` ` seed $$$ 3 $$$ vs seed $$$ 4 $$$ ` ` winner game ` ` seed $$$ 5 $$$ vs seed $$$ 6 $$$ ` ` play winner game ` ` seed $$$ 7 $$$ vs seed $$$ 8 $$$ ` ` , process repeat one team remain tournament end team assign place accord tournament phase eliminate particular : establish rule a little rig particular want : example picture describe one possible ways tournament go $$$ k = 3 $$$ result place team : seed already reserve team ( ones rig tournament <unknown> ) fill rest seed remain team achieve desire placements many ways ? since value might large print modulo $$$ 998\,244\,353 $$$ first line contain a single integer $$$ k $$$ ( $$$ 0 \le k \le 19 $$$ ) — $$$ 2^k $$$ team second line contain $$$ 2^k $$$ integers $$$ a_1 a_2 \dots a _ { 2^k } $$$ ( $$$ a_i = -1 $$$ $$$ 1 \le a_i \le 2^k $$$ ) $$$ a_i \ne -1 $$$ team $$$ a_i $$$ seed $$$ i $$$ otherwise seed $$$ i $$$ reserve team value $$$ -1 $$$ distinct print a single integer — number ways fill non - <unknown> seed tournament go plan modulo $$$ 998\,244\,353 $$$","['combinatorics', 'trees']",2200.0
1166/A,$$$ n $$$ students first grade <unknown> high school <unknown> wish split students two classrooms ( student must exactly one classrooms ) two distinct students whose name start letter chatty put classroom ( must a lot common ) let $$$ x $$$ number pair students a split pair $$$ ( a b ) $$$ $$$ ( b a ) $$$ count example $$$ 6 $$$ students : ` ` <unknown> '' ` ` <unknown> '' ` ` tanya '' ` ` jack '' ` ` <unknown> '' ` ` <unknown> '' : give list $$$ n $$$ name minimum $$$ x $$$ obtain split students classrooms ? note valid place students one classrooms leave one empty first line contain a single integer $$$ n $$$ ( $$$ 1\leq n \leq 100 $$$ ) — number students $$$ n $$$ line follow $$$ i $$$ -th line contain name $$$ i $$$ -th student guarantee name a string lowercase english letter length $$$ 20 $$$ note multiple students may share name output must consist a single integer $$$ x $$$ — minimum possible number chatty pair first sample minimum number pair $$$ 1 $$$ achieve example put everyone except jose one classroom jose <unknown> <unknown> form chatty pair second sample minimum number pair $$$ 2 $$$ achieve example put kambei <unknown> <unknown> kyuzo one room put <unknown> katsushiro kikuchiyo room case two pair kambei kyuzo katsushiro kikuchiyo third sample minimum number pair $$$ 4 $$$ achieve place three students name mike one classroom two students another classroom thus three chatty pair one classroom one chatty pair classroom,"['combinatorics', 'greedy']",900.0
374/B,inna love digit 9 much 's ask dima write a small number consist <unknown> dima must <unknown> write a large number a consist digits 1 9 . inna want slightly alter number dima write end number contain many digits nine possible one move inna choose two adjacent digits a number sum equal 9 replace a single digit 9 . instance inna alter number 14545181 like : 14545181 → <unknown> → <unknown> → 19919 . also use method transform number 14545181 number 19991 . inna transform <unknown> get number 19919 19991 contain digits nine dima a programmer want find many distinct number contain many digits nine possible inna get write number help challenge task first line input contain integer a ( 1 ≤ a ≤ <unknown> ) number a n't zero a single line print a single integer — answer problem guarantee answer problem n't exceed <unknown> - 1 . please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier note <unknown> first sample inna get follow number : 369727 → 99727 → <unknown> 369727 → 99727 → <unknown> . second sample inna act like : <unknown> → <unknown> → <unknown>,"['combinatorics', 'greedy']",1500.0
201/E,n people simultaneously sign <unknown> recently open already thoroughly bureaucratic organization ( <unknown> tbo ) organization thoroughly bureaucratic accept <unknown> exactly one person per day a <unknown> n people make appointment one next n days two persons appointment day however organization workers <unknown> job none sign people tell exact date appointment way know people come write request tbo request form consist m empty line line name a sign person write ( leave blank well ) write a person 's name form twice forbid request ignore tbo respond quickly write request reply format poor quality — response contain correct appointment date people request form date completely random order respond request arrive simultaneously end day ( response specify request answer ) fortunately n't among n lucky guy <unknown> follow task — give n m determine minimum number request submit tbo clearly determine appointment date person first line contain a single integer t ( 1 ≤ t ≤ 1000 ) — number test case follow t line contain two integers n m ( 1 ≤ n m ≤ 109 ) — number people get appointment tbo number empty line request form correspondingly print t line contain answer correspond test case ( order give input ) — minimum number request submit tbo first sample need submit three request tbo three different name learn appointment date three people four find fourth person 's date elimination need a fourth request second sample need two request let 's number persons 1 4 mention persons 1 2 first request persons 1 3 second request easy see clearly determine person 's appointment date regardless answer obtain tbo fourth sample one person sign appointment n't need submit request — appointment date tomorrow,"['binary search', 'combinatorics']",2600.0
946/F,give a binary string s ( character string either 0 1 ) let 's denote cost string t number occurences s t. example s 11 t <unknown> cost t 3 . let 's also denote fibonacci string sequence follow : task calculate sum cost subsequences string f ( x ) since answer may large calculate modulo 109 + 7 . first line contain two integers n x ( 1 ≤ n ≤ 100 0 ≤ x ≤ 100 ) — length s index a fibonacci string interest respectively second line contain s — a string consist n character character either 0 1 . print integer — sum cost subsequences string f ( x ) take modulo 109 + 7,"['combinatorics', 'dp']",2400.0
917/C,know dart kind creature upside world simplicity call kind pollywogs dart x - 1 pollywogs play a game n stone a row number 1 n leave right 1 pollywog may sit stone a time initially pollywogs sit first x stone ( one pollywog stone ) dart friends want end last x stone second leftmost pollywog jump right a pollywog jump k stone ; specifically a pollywog jump stone number i stone i + 1 i + 2 ... i + k. a pollywog ca n't jump occupy stone jump a distance i take ci amount energy pollywog also q stone special time land a special stone p take wp amount energy ( addition energy jump ) pollywog wp could negative case mean pollywog <unknown> |wp| amount energy pollywogs want spend little energy possible ( value could negative ) 're pollywogs ask help tell total change energy case move optimally first line input contain four integers x k n q ( 1 ≤ x ≤ k ≤ 8 k ≤ n ≤ 108 0 ≤ q ≤ min ( 25 n - x ) ) — number pollywogs maximum length jump number stone number special stone next line contain k integers c1 c2 ... ck separate space ( 1 ≤ ci ≤ 109 ) — energetic cost jump next q line contain description special stone line contain two integers p wp ( x + 1 ≤ p ≤ n |wp| ≤ 109 ) p distinct print minimum amount energy need first line output,"['combinatorics', 'dp']",2900.0
1237/F,"consider a square grid $$$ h $$$ row $$$ w $$$ columns dominoes domino cover exactly two cells grid share a common side every cell cover one domino let 's call a placement dominoes grid perfectly balance row column contain a pair cells cover two different dominoes word every row column may contain cover cells one cover cell two cover cells belong domino give a perfectly balance placement dominoes a grid find number ways place zero extra dominoes grid keep placement perfectly balance output number modulo $$$ 998\,244\,353 $$$ first line contain three integers $$$ h $$$ $$$ w $$$ $$$ n $$$ ( $$$ 1 \le h w \le <unknown> $$$ ; $$$ 0 \le n \le <unknown> $$$ ) denote dimension grid number already place dominoes row number $$$ 1 $$$ $$$ h $$$ columns number $$$ 1 $$$ $$$ w $$$ next $$$ n $$$ line contain four integers $$$ r _ { i 1 } c _ { i 1 } r _ { i 2 } c _ { i 2 } $$$ ( $$$ 1 \le r _ { i 1 } \le r _ { i 2 } \le h $$$ ; $$$ 1 \le c _ { i 1 } \le c _ { i 2 } \le w $$$ ) denote row i d column i d cells cover $$$ i $$$ -th domino cells $$$ ( r _ { i 1 } c _ { i 1 } ) $$$ $$$ ( r _ { i 2 } c _ { i 2 } ) $$$ distinct share a common side give domino placement perfectly balance output number ways place zero extra dominoes grid keep placement perfectly balance modulo $$$ 998\,244\,353 $$$ first example initial grid look like : $$$ 8 $$$ ways place zero extra dominoes keep placement perfectly balance : second example initial grid look like : extra dominoes place","['combinatorics', 'dp']",2600.0
1185/G2,difference easy hard versions constraints polycarp love listen music never leave player even way home university polycarp <unknown> distance university house exactly $$$ t $$$ minutes player polycarp store $$$ n $$$ songs characterize two parameters : $$$ t_i $$$ $$$ g_i $$$ $$$ t_i $$$ length song minutes ( $$$ 1 \le t_i \le 50 $$$ ) $$$ g_i $$$ genre ( $$$ 1 \le g_i \le 3 $$$ ) polycarp want create a playlist listen music time way university home time arrival home playlist polycarp never interrupt songs always listen begin end thus start listen $$$ i $$$ -th song would spend exactly $$$ t_i $$$ minutes listen polycarp also like two songs genre play a row ( i.e successively / <unknown> ) songs playlist repeat help polycarpus count number different sequence songs ( order matter ) total duration exactly $$$ t $$$ two consecutive songs genre songs playlist different first line input contain two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 50 1 \le t \le 2500 $$$ ) — number songs player require total duration respectively next $$$ n $$$ line contain descriptions songs : $$$ i $$$ -th line contain two integers $$$ t_i $$$ $$$ g_i $$$ ( $$$ 1 \le t_i \le 50 1 \le g_i \le 3 $$$ ) — duration $$$ i $$$ -th song genre respectively output one integer — number different sequence songs total length exactly $$$ t $$$ two consecutive songs genre songs playlist different since answer may huge output modulo $$$ 1000000000 + 7 $$$ ( remainder divide quantity $$$ 1000000000 + 7 $$$ ) first example polycarp make $$$ 6 $$$ possible playlist rearrange available songs : $$$ [ 1 2 3 ] $$$ $$$ [ 1 3 2 ] $$$ $$$ [ 2 1 3 ] $$$ $$$ [ 2 3 1 ] $$$ $$$ [ 3 1 2 ] $$$ $$$ [ 3 2 1 ] $$$ ( indices songs give ) second example first second songs go <unknown> ( since genre ) thus polycarp create a playlist one $$$ 2 $$$ possible ways : $$$ [ 1 3 2 ] $$$ $$$ [ 2 3 1 ] $$$ ( indices songs give ) third example polycarp make follow <unknown> : $$$ [ 1 2 3 ] $$$ $$$ [ 1 3 2 ] $$$ $$$ [ 2 1 3 ] $$$ $$$ [ 2 3 1 ] $$$ $$$ [ 3 1 2 ] $$$ $$$ [ 3 2 1 ] $$$ $$$ [ 1 4 ] $$$ $$$ [ 4 1 ] $$$ $$$ [ 2 3 4 ] $$$ $$$ [ 4 3 2 ] $$$ ( indices songs give ),"['combinatorics', 'dp']",2600.0
1279/E,"yeah fail make a new year legend problem a permutation length $$$ n $$$ array $$$ n $$$ integers every integer $$$ 1 $$$ $$$ n $$$ appear exactly element $$$ y $$$ permutation $$$ p $$$ reachable element $$$ x $$$ $$$ x = y $$$ $$$ p_x = y $$$ $$$ p _ { p_x } = y $$$ , decomposition a permutation $$$ p $$$ define follow : firstly a permutation $$$ p $$$ elements mark empty list $$$ l $$$ follow : least one mark element $$$ p $$$ find leftmost element list elements reachable order appear $$$ p $$$ mark elements cyclically shift list elements maximum appear first position add list element $$$ l $$$ elements mark $$$ l $$$ result decomposition example want build a decomposition $$$ p = [ 5 4 2 3 1 7 8 6 ] $$$ follow : new year transformation a permutation define follow : build decomposition permutation ; sort list decomposition ascend order first elements ( n't swap elements list list ) ; concatenate list one list become a new permutation example new year transformation $$$ p = [ 5 4 2 3 1 7 8 6 ] $$$ build follow : call a permutation good result transformation permutation example $$$ [ 4 3 1 2 8 5 6 7 ] $$$ a good permutation ; $$$ [ 5 4 2 3 1 7 8 6 ] $$$ bad since result transformation $$$ [ 4 2 3 5 1 8 6 7 ] $$$ task follow : give $$$ n $$$ $$$ k $$$ find $$$ k $$$ -th ( lexicographically ) good permutation length $$$ n $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case follow test case represent one line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 50 $$$ $$$ 1 \le k \le 10^ { 18 } $$$ ) test case print answer follow : number good permutations length $$$ n $$$ less $$$ k $$$ print one integer $$$ -1 $$$ ; otherwise print $$$ k $$$ -th good permutation $$$ n $$$ elements ( lexicographical order )","['combinatorics', 'dp']",2700.0
1000/D,sequence integers $$$ a_1 a_2 \dots a_k $$$ call a good array $$$ a_1 = k - 1 $$$ $$$ a_1 > 0 $$$ example sequence $$$ [ 3 -1 44 0 ] [ 1 <unknown> ] $$$ good array sequence $$$ [ 3 7 8 ] [ 2 5 4 1 ] [ 0 ] $$$ — a sequence integers call good divide a positive number good array good array a subsegment sequence element sequence belong exactly one array example sequence $$$ [ 2 -3 0 1 4 ] $$$ $$$ [ 1 2 3 -3 -9 4 ] $$$ good sequence $$$ [ 2 -3 0 1 ] $$$ $$$ [ 1 2 3 -3 -9 4 1 ] $$$ — a give sequence number count number subsequences good sequence print number subsequences modulo 998244353 . first line contain number $$$ n~ ( 1 \le n \le 1000 ) $$$ — length initial sequence follow line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n~ ( -1000000000 \le a_i \le 1000000000 ) $$$ — sequence single line output one integer — number subsequences original sequence good sequence take modulo 998244353 . first test case two good subsequences — $$$ [ a_1 a_2 a_3 ] $$$ $$$ [ a_2 a_3 ] $$$ second test case seven good subsequences — $$$ [ a_1 a_2 a_3 a_4 ] [ a_1 a_2 ] [ a_1 a_3 ] [ a_1 a_4 ] [ a_2 a_3 ] [ a_2 a_4 ] $$$ $$$ [ a_3 a_4 ] $$$,"['combinatorics', 'dp']",1900.0
954/H,give a root tree let 's denote d ( x ) depth node x : depth root 1 depth node x d ( y ) + 1 y a parent x. tree follow property : every node x d ( x ) = i exactly ai children maximum possible depth a node n = 0 . define fk number unordered pair vertices tree number edge simple path equal k. calculate fk modulo 109 + 7 every 1 ≤ k ≤ 2n - 2 . first line input contain integer n ( 2 ≤ n ≤ 5 000 ) — maximum depth a node second line input contain n - 1 integers a1 a2 ... - 1 ( 2 ≤ ai ≤ 109 ) ai number children every node x d ( x ) = i. since = 0 give input print 2n - 2 number k - th number must equal fk modulo 109 + 7 . tree first sample :,"['combinatorics', 'dp']",2500.0
403/D,sequence integer pair ( a1 b1 ) ( a2 b2 ) ... ( ak bk ) beautiful follow statements fulfil : give number n find number beautiful sequence length k. answer rather large print remainder divide 1000000007 ( 109 + 7 ) first line contain integer t ( 1 ≤ t ≤ 2·105 ) — number test data next t line contain two integers n k ( 1 ≤ k ≤ n ≤ 1000 ) test input print answer problem modulo 1000000007 ( 109 + 7 ) print answer test order test give input first test sample exactly one beautiful sequence : ( 1 1 ) second test sample follow sequence beautiful : fourth test sample follow sequence beautiful : fifth test sample follow sequence beautiful : third sixth sample beautiful sequence,"['combinatorics', 'dp']",2300.0
1190/F,tokitsukaze play a room escape game design <unknown> game need find hide clue room reveal a way escape a realize way run away open digital door lock since accidentally go a secret <unknown> find clue interpret : fortunately find $$$ n $$$ $$$ m $$$ record lock however make tokitsukaze <unknown> n't well math find integer suspect $$$ p $$$ want help find $$$ n $$$ possible passwords determine integer $$$ p $$$ line contain three integers $$$ n $$$ $$$ m $$$ $$$ p $$$ ( $$$ 1 \leq n \leq 5 \times 100000 $$$ $$$ 1 \leq p < m \leq 10^ { 18 } $$$ ) guarantee $$$ m $$$ a positive integer power a single prime number number possible different passwords less $$$ n $$$ print a single integer $$$ -1 $$$ otherwise print $$$ n $$$ distinct integers range $$$ 0 $$$ $$$ ( m - 1 ) $$$ passwords print integers order besides multiple solutions print first example possible password last three examples give integer $$$ n $$$ equal number possible different passwords give integers $$$ m $$$ $$$ p $$$ order number output ignore solution unique show,['number theory'],3400.0
1762/D,"interactive problem a secret permutation $$$ p $$$ $$$ [ 0,1,2 \ldots n-1 ] $$$ task find $$$ 2 $$$ indices $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq x y \leq n $$$ possibly $$$ x = y $$$ ) $$$ p_x=0 $$$ $$$ p_y=0 $$$ order find allow ask $$$ 2n $$$ query one query give two integers $$$ i $$$ $$$ j $$$ ( $$$ 1 \leq i j \leq n $$$ $$$ i \neq j $$$ ) receive value $$$ \gcd ( p_i p_j ) ^\dagger $$$ note permutation $$$ p $$$ fix query make depend query $$$ ^\dagger $$$ $$$ \gcd ( x y ) $$$ denote greatest common divisor ( gcd ) integers $$$ x $$$ $$$ y $$$ note $$$ \gcd ( <unknown> ) = \gcd ( 0 x ) = x $$$ positive integers $$$ x $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 20000 $$$ ) read integer $$$ n $$$ test case begin interaction guarantee sum $$$ n $$$ test case exceed $$$ 20000 $$$ interaction test case begin read integer $$$ n $$$ make a query output ` ` ? $$$ i $$$ $$$ j $$$ ` ` ( $$$ 1 \leq i j \leq n $$$ $$$ i \neq j $$$ ) without quote afterwards read a single integer — answer query $$$ \gcd ( p_i p_j ) $$$ make $$$ 2n $$$ query test case want print answer output ` ` ! $$$ x $$$ $$$ y $$$ ` ` ( $$$ 1 \leq x y \leq n $$$ ) without quote , read $$$ 1 $$$ $$$ -1 $$$ $$$ p_x=0 $$$ $$$ p_y=0 $$$ 'll receive $$$ 1 $$$ otherwise 'll receive $$$ -1 $$$ receive $$$ -1 $$$ program must terminate immediately receive a wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream receive integer $$$ -1 $$$ instead answer a valid value $$$ n $$$ mean program make invalid query exceed limit query give incorrect answer previous test case program must terminate immediately receive a wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream print a query answer forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack use follow format first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 20000 $$$ ) second line test case contain $$$ n $$$ space separate integers $$$ p_1 p_2 \ldots p_n $$$ $$$ p $$$ a permutation $$$ [ 0,1,2 \ldots n-1 ] $$$ sum $$$ n $$$ exceed $$$ 20000 $$$ first test interaction proceed follow note empty line example input output sake clarity occur real interaction test case make sure read $$$ 1 $$$ $$$ -1 $$$",['number theory'],2100.0
1355/F,"interactive problem hide integer $$$ 1 \le x \le 10^ { 9 } $$$ n't guess number find number divisors number n't even find exact number : answer consider correct absolute error greater 7 relative error greater $$$ 0.5 $$$ formally let answer $$$ ans $$$ number divisors $$$ x $$$ $$$ d $$$ answer consider correct least one two follow condition true : make $$$ 22 $$$ query one query consist one integer $$$ 1 \le q \le 10^ { 18 } $$$ response get $$$ gcd ( x q ) $$$ — greatest common divisor $$$ x $$$ $$$ q $$$ number $$$ x $$$ fix query word interactor adaptive let 's call process guess number divisors number $$$ x $$$ a game one test play $$$ t $$$ independent game , guess number divisors $$$ t $$$ time $$$ t $$$ independent value $$$ x $$$ first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number game make a query print a line ` ` ? q '' ( $$$ 1 \le q \le 10^ { 18 } $$$ ) read one integer $$$ gcd ( x q ) $$$ make $$$ 22 $$$ query one game confident figure number divisors $$$ x $$$ enough precision print answer ` ` ! ans '' format $$$ ans $$$ integer last game terminate program otherwise start next game immediately note interactor n't print anything response print answer print a query forget output end line flush output , use : hacksto hack use follow format : first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number game next $$$ t $$$ line contain one integer $$$ x $$$ ( $$$ 1 \le x \le 10^ { 9 } $$$ ) — hide number example form limitation number query 22 exactly ? maybe problem author a <unknown> <unknown> fan let 's look example first game $$$ x = 998\,244\,353 $$$ hide would hard guess right ? number prime number divisors 2 . solution make several random query responses turn 1 ( strange things even one three random number divisible $$$ 998\,244\,353 $$$ ) 's <unknown> assume hide number n't many divisors solution answer 5 . answer consider correct since $$$ | 5 - 2 | = 3 \le 7 $$$ second game $$$ x = 4\,194\,304 = 2^ { 22 } $$$ hide 23 divisors solution make query $$$ 1024 = 2^ { 10 } $$$ $$$ 1\,048\,576 = 2^ { 20 } $$$ $$$ <unknown> = 2^ { 30 } $$$ get responses $$$ 1024 = 2^ { 10 } $$$ $$$ 1\,048\,576 = 2^ { 20 } $$$ $$$ 4\,194\,304 = 2^ { 22 } $$$ respectively solution get completely <unknown> answer answer <unknown> question life universe everything answer consider correct since $$$ \frac { 1 } { 2 } \le \frac { 42 } { 23 } \le 2 $$$",['number theory'],2600.0
1137/D,"interactive problem misha like play cooperative game <unknown> information today suggest ten friends play a cooperative game ` ` lake '' misha already come a field upcoming game field game a direct graph consist two part first part a road along coast lake a cycle $$$ c $$$ vertices second part a path home lake a chain $$$ t $$$ vertices edge last vertex chain vertex road along coast beautiful view lake also know finish vertex misha decide keep field secret nobody know neither $$$ t $$$ $$$ c $$$ note vertex field exactly one outgo edge vertices except home vertex finish vertex exactly one <unknown> edge home vertex incoming edge finish vertex two incoming edge begin game piece ten players index consecutive integers $$$ 0 $$$ $$$ 9 $$$ home vertex turn players ask misha simultaneously move piece along correspond edge misha answer $$$ q $$$ query move misha tell players whose piece vertices whose piece different vertices goal game move piece finish vertex misha 's friends idea win a game without knowledge $$$ c $$$ $$$ t $$$ $$$ q $$$ luckily friends help : coordinate action win game misha draw a field $$$ 1 \le t c $$$ $$$ ( t+c ) \leq 1000 $$$ $$$ q = 3 \cdot ( t+c ) $$$ input — go interaction part straight away friends gather finish vertex print ` ` do '' terminate program give a command move friends print ` ` next '' space - separated indices friends want move example give command move friends indices $$$ 0 $$$ $$$ 2 $$$ $$$ 5 $$$ $$$ 9 $$$ print ` ` next 0 2 5 9 '' turn must move least one friends answer first read integer $$$ k $$$ $$$ 10 $$$ digits divide $$$ k $$$ space - separated group friends correspond indices group vertex friends correspond indices different group different vertices indices group follow ascend order example answer ` ` 2 <unknown> <unknown> '' mean friends indices $$$ 0 $$$ $$$ 5 $$$ one vertex friends different vertex answer ` ` 4 01 567 234 89 '' mean misha 's friends four different vertices : friends indices $$$ 0 $$$ $$$ 1 $$$ first friends indices $$$ 5 $$$ $$$ 6 $$$ $$$ 7 $$$ second friends indices $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ third friends indices $$$ 8 $$$ $$$ 9 $$$ fourth print a query forget output end line flush output otherwise get idleness limit exceed , use : answer ` ` stop '' instead a valid one mean make invalid query exit immediately receive ` ` stop '' see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream hacksin order hack print two integers $$$ t $$$ $$$ c $$$ a single line ( $$$ 1 \le t c $$$ $$$ ( t+c ) \leq 1000 $$$ ) sample input output value align simplicity interpret chronologically real interaction ` ` extra '' line break appear example friends move follow :",['number theory'],2400.0
1326/A,give a integer $$$ n $$$ ( $$$ n > 0 $$$ ) find integer $$$ s $$$ satisfy condition report number : decimal representation $$$ s $$$ : input consist multiple test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 400 $$$ ) number test case next $$$ t $$$ line describe a test case test case contain one positive integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print integer $$$ s $$$ satisfy condition describe ` ` -1 '' ( without quote ) number exist multiple possible solutions $$$ s $$$ print solution first test case possible solutions $$$ s $$$ consist one digit solution divisible second test case possible solutions : $$$ 23 $$$ $$$ 27 $$$ $$$ 29 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ 43 $$$ $$$ <unknown> $$$ $$$ 47 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ 58 $$$ $$$ 59 $$$ $$$ 67 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ 87 $$$ $$$ 89 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ third test case one possible solution $$$ 239 $$$ $$$ 239 $$$ divisible $$$ 2 $$$ $$$ 3 $$$ $$$ 9 $$$ three digits ( none equal zero ),['number theory'],1000.0
1264/F,well - known fibonacci sequence $$$ <unknown> <unknown> f_2 \ldots $$$ define follow : give increase arithmetic sequence positive integers $$$ n $$$ elements : $$$ ( a a + d a + 2\cdot d \ldots a + ( n - 1 ) \cdot d ) $$$ need find another increase arithmetic sequence positive integers $$$ n $$$ elements $$$ ( b b + e b + 2\cdot e \ldots b + ( n - 1 ) \cdot e ) $$$ : first line contain three positive integers $$$ n $$$ $$$ a $$$ $$$ d $$$ ( $$$ 1 \leq n a d a + ( n - 1 ) \cdot d < 1000000 $$$ ) arithmetic sequence exist print $$$ -1 $$$ otherwise print two integers $$$ b $$$ $$$ e $$$ separate space a single line ( $$$ 0 < b e < 2^ { 64 } $$$ ) many answer output first test case choose $$$ ( b e ) = ( 2 1 ) $$$ $$$ f_2 = 1 <unknown> = 2 <unknown> = 3 $$$ second test case choose $$$ ( b e ) = ( 19 5 ) $$$ :,['number theory'],3500.0
1740/A,pak chanek a prime number $$$ ^\dagger $$$ $$$ n $$$ find a prime number $$$ m $$$ $$$ n + m $$$ prime $$$ ^\dagger $$$ a prime number a number exactly $$$ 2 $$$ factor first prime number $$$ <unknown> \ldots $$$ particular $$$ 1 $$$ a prime number test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case follow line contain description test case line test case contain a prime number $$$ n $$$ ( $$$ 2 \leq n \leq 100000 $$$ ) test case output a line contain a prime number $$$ m $$$ ( $$$ 2 \leq m \leq 100000 $$$ ) $$$ n + m $$$ prime prove constraints problem $$$ m $$$ always exist multiple solutions output first test case $$$ m = 2 $$$ prime $$$ n + m = 7 + 2 = 9 $$$ prime second test case $$$ m = 7 $$$ prime $$$ n + m = 2 + 7 = 9 $$$ prime third test case $$$ m = 47837 $$$ prime $$$ n + m = <unknown> + 47837 = <unknown> $$$ prime,['number theory'],800.0
1734/E,"give a prime number $$$ n $$$ array $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ $$$ 0 \leq b_i < n $$$ $$$ 1 \le i \leq n $$$ find a matrix $$$ a $$$ size $$$ n \times n $$$ follow requirements hold : $$$ x \not \equiv y \pmod m $$$ denote $$$ x $$$ $$$ y $$$ give different remainder divide $$$ m $$$ multiple solutions output show a matrix always exist give constraints first line contain a single positive integer $$$ n $$$ ( $$$ 2 \le n < 350 $$$ ) second line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 0 \le b_i < n $$$ ) — require value main diagonal matrix guarantee $$$ n $$$ prime print $$$ n $$$ line $$$ i $$$ -th line print $$$ n $$$ integers $$$ a _ { i 1 } a _ { i 2 } \ldots a _ { i n } $$$ separate a space multiple solutions output first example answer valid entries non - negative integers less $$$ n = 2 $$$ $$$ a _ { 1,1 } + a _ { 2,2 } \not\equiv a _ { 1,2 } + a _ { 2,1 } \pmod 2 $$$ ( $$$ a _ { 1,1 } + a _ { 2,2 } = 0 + 0 \equiv 0 \pmod 2 $$$ $$$ a _ { 1,2 } + a _ { 2,1 } = 1 + 0 \equiv 1 \pmod 2 $$$ ) moreover value main diagonals equal $$$ 0,0 $$$ require second example answer correct entries non - negative integers less $$$ n = 3 $$$ second condition satisfy <unknown> $$$ ( r_1 r_2 c_1 c_2 ) $$$ example :",['number theory'],2100.0
1174/C,"'re give integer $$$ n $$$ every integer $$$ i $$$ $$$ 2 $$$ $$$ n $$$ assign a positive integer $$$ a_i $$$ follow condition hold : a pair integers call coprime greatest common divisor $$$ 1 $$$ line contain integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) print $$$ n-1 $$$ integers $$$ a_2 $$$ $$$ a_3 $$$ $$$ \ldots $$$ $$$ a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) multiple solutions print first example notice $$$ 3 $$$ $$$ 4 $$$ coprime $$$ a_3 \neq a_4 $$$ also notice $$$ a= [ 1,2,3 ] $$$ satisfy first condition 's a correct answer maximal value $$$ 3 $$$",['number theory'],1300.0
1045/B,"everybody seem think martians green turn <unknown> pink <unknown> ajs two bag distinct nonnegative integers bag disjoint union set number bag $$$ \ { <unknown> … <unknown> } $$$ positive integer $$$ m $$$ ajs draw a number first bag a number second bag sum modulo $$$ m $$$ residues modulo $$$ m $$$ ajs obtain action ? first line contain two positive integer $$$ n $$$ ( $$$ 1 \leq n \leq 200\,000 $$$ ) $$$ m $$$ ( $$$ n+1 \leq m \leq 10^ { 9 } $$$ ) denote number elements first bag <unknown> respectively second line contain $$$ n $$$ nonnegative integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_1 < a_2 < \ldots < a_n < m $$$ ) content first bag first line output <unknown> $$$ k $$$ set residues modulo $$$ m $$$ ajs obtain second line output print $$$ k $$$ space - separated integers greater equal zero less $$$ m $$$ represent residues ajs obtain output sort increase order <unknown> $$$ k $$$ = 0 output second line first sample first bag second bag contain $$$ \ { <unknown> } $$$ $$$ \ { <unknown> } $$$ respectively ajs obtain every residue modulo $$$ 5 $$$ except residue $$$ 2 $$$ : $$$ 4 + 1 \equiv 0 \ 4 + 2 \equiv 1 \ 3 + 0 \equiv 3 \ 3 + 1 \equiv 4 $$$ modulo $$$ 5 $$$ one check choice elements first second bag sum $$$ 2 $$$ modulo $$$ 5 $$$ second sample content first bag $$$ \ { <unknown> } $$$ second bag contain nonnegative integers $$$ 9 $$$ decimal digits every residue modulo $$$ <unknown> $$$ obtain a sum element first bag element second bag",['number theory'],2400.0
414/A,"'s holiday mashmokh boss bimokh play a game invent mashmokh game mashmokh write sequence n distinct integers board bimokh make several ( possibly zero ) move first move remove first second integer board second move remove first second integer remain sequence board , bimokh stop board contain less two number bimokh remove number x y board get gcd ( x y ) point begin game bimokh zero point mashmokh want win game reason want boss get exactly k point total guy n't know choose initial sequence right way please help find n distinct integers a1 a2 ... boss score exactly k point also mashmokh ca n't memorize huge number therefore integers must 109 . first line input contain two space - separated integers n k ( 1 ≤ n ≤ 105 ; 0 ≤ k ≤ 108 ) sequence n't exist output -1 otherwise output n distinct space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) <unknown> ( x y ) greatest common divisor x y",['number theory'],1500.0
449/C,jzzhu pick n apples big apple tree apples number 1 n. want sell apple store jzzhu pack apples group sell group must contain two apples greatest common divisor number apples group must greater 1 . course apple part one group jzzhu wonder get maximum possible number group help ? a single integer n ( 1 ≤ n ≤ 105 ) number apples first line must contain a single integer m represent maximum number group get next m line must contain two integers — number apples current group several optimal answer print,['number theory'],2500.0
235/A,days ago i learn concept lcm ( least common multiple ) i ' ve play several time i want make a big number i also n't want use many number i 'll choose three positive integers ( n't distinct ) greater n. help find maximum possible least common multiple three integers ? first line contain integer n ( 1 ≤ n ≤ 106 ) — n mention statement print a single integer — maximum possible lcm three necessarily distinct positive integers greater n. least common multiple positive integers least positive integer multiple result may become large 32 - bit integer wo n't enough use 64 - bit integers recommend last example choose number 7 6 5 lcm <unknown> = <unknown> . maximum value get,['number theory'],1600.0
177/B2,"smart beaver abbyy decide a day nothing whole day turn bore decide play a game pebbles initially beaver n pebbles arrange a equal row row b pebbles ( a > 1 ) note beaver must use pebbles i. e. n = <unknown> smart beaver arrange pebbles take back result row ( b pebbles ) discard pebbles arrange pebbles ( possibly choose value a b ) take back one row , game continue point beaver end exactly one <unknown> game process represent a finite sequence integers c1 ... ck : result game sum number ci give n. find maximum possible result game single line input contain a single integer n — initial number pebbles smart beaver input limitations get 30 point : input limitations get 100 point : print a single number — maximum possible result game consider first example ( c1 = 10 ) possible options game development :",['number theory'],1200.0
172/D,reform start berland ! time <unknown> discuss reform calendar make live citizens berland vary decide change calendar people <unknown> ` ` years fly ... '' decide start next year number days per year begin grow come year exactly a days next come year a + 1 days next one a + 2 days schedule plan come n years ( n - th year length year equal a + n - 1 day ) one yet decide become months <unknown> palevny make follow proposal rule provide unambiguous method choose number days month give year length example accord palevny 's <unknown> a year consist 108 days three months 36 days year consist 99 days 11 months 9 days a year 365 days 365 months one day proposal <unknown> heat <unknown> <unknown> famous mathematician perelmanov quickly calculate proposal support a period n years begin year a days country spend p sheet paper print a set calendar years perelmanov 's calculations take account fact set contain one calendar year month print a separate sheet repeat perelmanov 's achievement print require number p. give positive integers a n. perelmanov warn program work longer four second maximum test input line contain a pair integers a n ( 1 ≤ a n ≤ 107 ; a + n - 1 ≤ 107 ) print require number p. please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier a note first sample test a year 25 days consist one month contain 25 days a year 26 days consist 26 months one day a year 27 days three months 9 days,['number theory'],1500.0
45/G,berland prime number fashionable — respectable citizens <unknown> floor number prime number <unknown> value particularly high coin prime <unknown> value prime days announce holiday ! yet even enough make berland people happy main street capital stand n house number 1 n. government decide paint every house a color sum number house paint every color a prime number however turn citizens approve decision — many <unknown> n't want many color house capital 's main street 's decide use minimal possible number color house n't paint consecutively every one n house paint color one - colored house stand consecutively way paint acceptable 5 hours leave start paint help government find way sum house number every color a prime number number use color minimal single input line contain integer n ( 2 ≤ n ≤ 6000 ) — number house main streets capital print sequence n number i - th number stand number color house number i. number color consecutively start 1 . paint order allow several solutions problem print 's way paint print single number -1,['number theory'],2200.0
26/A,a number call almost prime exactly two distinct prime divisors example number 6 18 24 almost prime 4 8 9 42 find amount almost prime number 1 n inclusive input contain one integer number n ( 1 ≤ n ≤ 3000 ) output amount almost prime number 1 n inclusive,['number theory'],900.0
10/C,long ago billy come across a problem give three natural number a b c range [ 1 n ] ask check whether equation ab = c correct recently billy study concept a digital root a number remind a digital root d ( x ) number x sum s ( x ) digits number s ( x ) ≤ 9 otherwise d ( s ( x ) ) example a digital root number 6543 calculate follow : d ( 6543 ) = d ( 6 + 5 + 4 + 3 ) = d ( 18 ) = 9 . billy count digital root a product number equal digital root product factor ' digital root i.e d ( xy ) = d ( d ( x ) d ( y ) ) follow solution problem come mind : calculate digital root check condition meet however billy doubt condition sufficient 's ask find amount test examples give problem algorithm propose billy make mistake first line contain number n ( 1 ≤ n ≤ 106 ) output one number — amount require a b c range [ 1 n ] first sample require triple ( 3 4 3 ) ( 4 3 3 ),['number theory'],2000.0
17/D,nick attract everything <unknown> n't like decimal number system decide study number systems a number system base b catch attention start study want write notepad number length n without lead zero number system page nick 's notepad enough space c number exactly nick write every suitable number start first clean page leave clean space nick never write number 0 unpleasant memories zero divide would help nick find many number write last page input line contain three space - separated integers b n c ( 2 ≤ b < 10106 1 ≤ n < 10106 1 ≤ c ≤ 109 ) may consider nick infinite patience endless amount paper representations digits character number n't contain lead zero line output amount number write page last number sample exactly 4 number length 3 binary number system first sample nick write 3 number first page 1 second page second sample 4 number write first page,['number theory'],2400.0
776/B,"sherlock a new girlfriend ( unlike ! ) <unknown> 's day come want gift jewelry buy n piece jewelry i - th piece price equal i + 1 , price jewelry 2 3 4 ... n + 1 . watson give sherlock a challenge color jewelry piece two piece n't color price one piece a prime divisor price piece also watson ask minimize number different color use help sherlock complete trivial task line contain single integer n ( 1 ≤ n ≤ 100000 ) — number jewelry piece first line output contain a single integer k minimum number color use color piece jewelry give constraints next line consist n space - separated integers ( 1 k ) specify color piece order increase price multiple ways color piece use k color output first input color first second third piece jewelry respective price 2 3 4 1 1 2 respectively case 2 a prime divisor 4 color jewelry price 2 4 must distinct",['number theory'],1200.0
630/A,hr manager <unknown> last <unknown> fail interview way 24 previous ones ` ` i give a hard task ? '' — hr manager think ` ` raise number 5 power n get last two digits number yes course n rather big one find power use a <unknown> need people able think follow instructions ` ` could pass interview machine <unknown> company city ? line input contain a single integer n ( 2 ≤ n ≤ <unknown> ) — power need raise number 5 . output last two digits <unknown> without space,['number theory'],800.0
1034/A,mr . f $$$ n $$$ positive integers $$$ a_1 a_2 \ldots a_n $$$ think greatest common divisor integers small want enlarge remove integers problem simple want help give score reward task calculate minimum number integers need remove greatest common divisor remain integers bigger integers first line contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 300000 $$$ ) — number integers mr . f second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq <unknown> \cdot <unknown> $$$ ) print integer — minimum number integers need remove greatest common divisor remain integers bigger integers remove integers solution print « -1 » ( without quote ) first example greatest common divisor $$$ 1 $$$ begin remove $$$ 1 $$$ greatest common divisor enlarge $$$ 2 $$$ answer $$$ 1 $$$ second example greatest common divisor $$$ 3 $$$ begin remove $$$ 6 $$$ $$$ 9 $$$ greatest common divisor enlarge $$$ 15 $$$ solution remove one integer answer $$$ 2 $$$ third example solution enlarge greatest common divisor answer $$$ -1 $$$,['number theory'],1800.0
1030/G,give a tuple generator $$$ f^ { ( k ) } = ( <unknown> { ( k ) } <unknown> { ( k ) } \dots <unknown> { ( k ) } ) $$$ $$$ f_i^ { ( k ) } = ( a_i \cdot f_i^ { ( k - 1 ) } + b_i ) \bmod p_i $$$ $$$ f^ { ( 0 ) } = ( x_1 x_2 \dots x_n ) $$$ $$$ x \bmod y $$$ denote remainder $$$ x $$$ divide $$$ y $$$ $$$ p_i $$$ prim one see fix sequence $$$ x_i $$$ $$$ y_i $$$ $$$ a_i $$$ tuples $$$ f^ { ( k ) } $$$ start index repeat tuples smaller indices calculate maximum number different tuples ( $$$ f^ { ( k ) } $$$ $$$ k \ge 0 $$$ ) produce generator $$$ x_i $$$ $$$ a_i $$$ $$$ b_i $$$ integers range $$$ [ 0 p_i - 1 ] $$$ choose arbitrary answer large print remainder give divide $$$ 1000000000 + 7 $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements tuple second line contain $$$ n $$$ space separate prime number — <unknown> $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 2 \le p_i \le 2000000 $$$ ) print one integer — maximum number different tuples modulo $$$ 1000000000 + 7 $$$ first example choose next parameters : $$$ a = [ 1 1 1 1 ] $$$ $$$ b = [ 1 1 1 1 ] $$$ $$$ x = [ 0 0 0 0 ] $$$ $$$ f_i^ { ( k ) } = k \bmod p_i $$$ second example choose next parameters : $$$ a = [ 1 1 2 ] $$$ $$$ b = [ 1 1 0 ] $$$ $$$ x = [ 0 0 1 ] $$$,['number theory'],2900.0
819/D,study beacon mister b decide visit alien 's planet learn live a system <unknown> star <unknown> moreover mister b learn star <unknown> exactly t second problem star yet discover scientists n astronomers numerate 1 n try detect star try detect star send request record sky 1 second astronomers send request cycle : i - th astronomer send a request exactly ai second ( i - 1 ) -th ( i.e previous request send moment t next request send moment t + ai ) ; 1 - st astronomer send request a1 second later n - th first astronomer send first request moment 0 . mister b n't know first moment star go shine 's obvious moments star shine determine time shine moment interval [ 0 t ) moreover interval split t part 1 second length form [ t t + 1 ) t = 0 1 2 ... ( t - 1 ) mister b want know lucky astronomer discover star first astronomer compute many segment form [ t t + 1 ) ( t = 0 1 2 ... ( t - 1 ) ) interval [ 0 t ) astronomer first discover star first shine star happen time interval first line contain two integers t n ( 1 ≤ t ≤ 109 2 ≤ n ≤ 2·105 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) print n integers : astronomer print number time segment <unknown> earlier first sample test first astronomer send request moments t1 = 0 5 10 ... second — moments t2 = 3 8 13 <unknown> 's interval [ 0 1 ) first astronomer discover first moment t1 = 0 [ 1 2 ) — first astronomer moment t1 = 5 [ 2 3 ) — first astronomer moment t1 = 10 [ 3 4 ) — second astronomer moment t2 = 3 . second sample test interval [ 0 1 ) — first astronomer discover first [ 1 2 ) — second astronomer [ 2 3 ) — third astronomer [ 3 4 ) — fourth astronomer [ 4 5 ) — first astronomer,['number theory'],2900.0
819/C,mister b a house middle a giant plain field attract alien life convenience alien specify cartesian coordinate system field a way mister b 's house coordinate ( 0 0 ) send three beacon field something go wrong one beacon completely destroy two land position coordinate ( m 0 ) ( 0 n ) respectively <unknown> mister b interest devices decide take home come first beacon place ( m 0 ) lift carry beacon home choose shortest path come beacon place ( 0 n ) also carry home choose shortest path first beacon lift navigation system beacon activate partially destroy navigation system start work follow way time moments survive beacon point integer coordinate system try find a location third beacon succeed a point integer coordinate area triangle form two survive beacon point equal s. case system send a <unknown> information beacon position alien otherwise n't compute many packets information system send mister b move beacon first line contain one integer t ( 1 ≤ t ≤ 1000 ) — number test case next <unknown> line describe t test case every test case describe three line follow note parameter give a product three factor first line a test case contain three space - separated integers : <unknown> n2 <unknown> ( 1 ≤ ni ≤ 106 ) n = <unknown> second line contain three space - separated integers : m1 m2 <unknown> ( 1 ≤ mi ≤ 106 ) m = <unknown> third line contain three space - separated integers : s1 s2 s3 ( 1 ≤ si ≤ 106 ) s = <unknown> note hack test t = 1 allow print t integers one per line — answer test first test case contain follow beacon position : ( 2 0 ) ( 0 2 ) s = 3 . follow packets could send : ( ( 2 0 ) ( 0 2 ) ( - 1 0 ) ) ( ( 1 0 ) ( 0 2 ) ( 4 0 ) ) ( ( 0 0 ) ( 0 2 ) ( 3 1 ) ) ( ( 0 0 ) ( 0 1 ) ( - 6 0 ) ) ( b1 b2 p ) next description : b1 — first beacon position b2 — second beacon position p — generate point second test case contain follow beacon initial position : ( 4 0 ) ( 0 5 ) s = 2 . follow packets could send : ( ( 4 0 ) ( 0 5 ) ( 0 4 ) ) ( ( 3 0 ) ( 0 5 ) ( 2 3 ) ) ( ( 2 0 ) ( 0 5 ) ( 2 2 ) ) ( ( 1 0 ) ( 0 5 ) ( 1 4 ) ) ( ( 0 0 ) ( 0 4 ) ( 0 - 1 ) ) ( ( 0 0 ) ( 0 2 ) ( 2 0 ) ) ( ( 0 0 ) ( 0 1 ) ( 4 0 ) ),['number theory'],2900.0
774/G,arkadiy lot square photos size a × a. want put a rectangular wall size h × w. photos arkadiy put wall must form a rectangular grid distance neighbor vertically horizontally photos also distance outside row columns photos nearest bind wall must equal x x non - negative real number look picture better understand statement arkadiy n't choose yet many photos would put wall however want put least one photo task determine minimum value x obtain put photos report way put positive number photos satisfy constraints suppose arkadiy enough photos make valid arrangement accord constraints note arkadiy want put least one photo wall photos overlap completely lie inside wall bound side parallel wall side first line contain three integers a h w ( 1 ≤ a h w ≤ 109 ) — size photos height width wall print one non - negative real number — minimum value x obtain put photos wall absolute relative error answer must exceed 10 - 6 . print -1 way put positive number photos satisfy constraints first example arkadiy put 7 row photos 5 photos row minimum value x equal 0.5 . second example arkadiy put 1 photo take whole wall minimum value x equal 0 . third example way put positive number photos satisfy constraints describe statement answer -1,['number theory'],2700.0
585/C,"alice bob decide eat fruit kitchen find a large bag oranges apples alice immediately take orange bob take apple make process share remain fruit fun friends decide play a game put multiple card one write a letter either ' a ' letter ' b ' begin remove card one one leave right every time remove a card letter ' a ' alice give bob fruit moment take bag many apples many oranges thus number oranges apples alice change card write letter ' b ' bob , give alice fruit take bag set fruit last card way remove fruit bag know many oranges apples bag first task find sequence card alice bob could play first line input contain two integers x y ( 1 ≤ x y ≤ 1018 xy > 1 ) — number oranges apples initially bag print sequence card would meet problem condition a compress string character ' a ' ' b mean need replace segment identical consecutive character number <unknown> character actual character example string <unknown> replace string <unknown> replace <unknown> <unknown> see sample clarifications output format string print consist 106 character guarantee answer exist compress representation exist consist 106 character several possible answer allow print sequence card meet problem statement exist print a single word impossible first sample row contain three card letter ' b ' bob give one apple alice three time , end game alice one orange three apples bob one apple total one orange four apples second sample answer since one card enough game finish two card produce least three apples three oranges third sample card contain letter ' ab ' remove first card bob one orange one apple removal second card alice two oranges one apple , total three oranges two apples",['number theory'],2400.0
1505/D,input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 1024 2 \le m \le 16 $$$ ) separate a single space output ` ` yes '' ` ` '',['number theory'],1800.0
1010/C,"<unknown> natasha arrive mar know martians poor alien ensure a better life mar citizens emperor decide take tax every tourist visit planet natasha <unknown> earth therefore pay tax enter territory mar $$$ n $$$ banknote denominations mar : value $$$ i $$$ -th banknote $$$ a_i $$$ natasha infinite number banknotes <unknown> martians $$$ k $$$ finger hand use a number system base $$$ k $$$ addition martians consider digit $$$ d $$$ ( number system base $$$ k $$$ ) divine thus last digit natasha 's tax amount write number system base $$$ k $$$ $$$ d $$$ martians happy unfortunately natasha know martians ' divine digit yet determine value $$$ d $$$ natasha make martians happy natasha use banknotes martians n't give change first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100\,000 $$$ $$$ 2 \le k \le 100\,000 $$$ ) — number denominations banknotes base number system mar second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — denominations banknotes mar number give decimal notation first line output number value $$$ d $$$ natasha make martians happy second line output value increase order print number decimal notation consider first test case use octal number system take one banknote value $$$ 12 $$$ get $$$ <unknown> $$$ octal system last digit $$$ 4_8 $$$ take one banknote value $$$ 12 $$$ one banknote value $$$ 20 $$$ total value $$$ 32 $$$ octal system $$$ <unknown> $$$ last digit $$$ 0_8 $$$ take two banknotes value $$$ 20 $$$ total value $$$ 40 $$$ $$$ <unknown> $$$ octal system last digit $$$ 0_8 $$$ digits $$$ 0_8 $$$ $$$ 4_8 $$$ obtain digits $$$ 0_8 $$$ $$$ 4_8 $$$ could also obtain ways second test case use decimal number system <unknown> banknotes end zero natasha give martians amount whose decimal notation also end zero",['number theory'],1800.0
582/C,"give infinite periodic array a0 a1 ... - 1 ... period length n. formally , a periodic subarray ( l s ) ( 0 ≤ l < n 1 ≤ s < n ) array a infinite periodic array a period length s a subsegment array a start position l. a periodic subarray ( l s ) superior attach array a start index l element subarray larger equal correspond element array a. example attach give figure ( top — infinite array a bottom — periodic subarray ( l s ) ) : find number distinct pair ( l s ) correspond superior periodic array first line contain number n ( 1 ≤ n ≤ 2·105 ) second line contain n number a0 a1 ... - 1 ( 1 ≤ ai ≤ 106 ) separate a space print a single integer — seek number pair first sample superior subarrays ( 0 1 ) ( 3 2 ) subarray ( 0 1 ) superior a0 ≥ a0 a0 ≥ a1 a0 ≥ a2 a0 ≥ a3 a0 ≥ a0 ... subarray ( 3 2 ) superior a3 ≥ a3 a0 ≥ a0 a3 ≥ a1 a0 ≥ a2 a3 ≥ a3 ... third sample pair ( l s ) correspond a superior subarray elements array distinct",['number theory'],2400.0
360/D,"levko love sort set much levko two array integers a1 a2 ... b1 b2 ... bm a prime number p. today generate n set let 's describe generation process i - th set : levko wonder many number belong least one set , want know size union n generate set first line contain three integers n m p ( 1 ≤ n ≤ 104 1 ≤ m ≤ 105 2 ≤ p ≤ 109 ) p prime second line contain space - separated integers a1 a2 ... ( 1 ≤ ai < p ) third line contain space - separated integers b1 b2 ... bm ( 1 ≤ bi ≤ 109 ) single number — size union set",['number theory'],2600.0
1036/E,give $$$ n $$$ segment a cartesian plane segment 's endpoints integer coordinate segment intersect two segment lie line count number distinct point integer coordinate cover least one segment first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — number segment next $$$ n $$$ line contain four integers $$$ ax_i ay_i bx_i by_i $$$ ( $$$ -1000000 \le ax_i ay_i bx_i by_i \le 1000000 $$$ ) — coordinate endpoints $$$ a $$$ $$$ b $$$ ( $$$ a \ne b $$$ ) $$$ i $$$ -th segment guarantee two segment lie line print a single integer — number distinct point integer coordinate cover least one segment image first example : several key point mark blue answer contain non - <unknown> point well image second example :,"['geometry', 'number theory']",2400.0
1198/F,give array $$$ n $$$ integers need split integers two group gcd integers first group equal one gcd integers second group equal one gcd a group integers largest non - negative integer divide integers group group non - empty first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — elements array first line print ` ` yes '' ( without quote ) possible split integers two group require ` ` '' ( without quote ) otherwise possible split integers second line print $$$ n $$$ integers $$$ i $$$ -th integer equal $$$ 1 $$$ integer $$$ a_i $$$ first group $$$ 2 $$$ otherwise multiple solutions print,"['greedy', 'number theory']",2900.0
1713/D,"interactive problem a tournament consist $$$ 2^n $$$ contestants $$$ 1 $$$ -st contestant compete $$$ 2 $$$ -nd $$$ 3 $$$ -rd compete $$$ 4 $$$ -th , , winner first match compete winner second match etc tournament end one contestant leave declare winner tournament a tournament scheme know single - elimination tournament n't know result want find winner tournament one query select two integers $$$ a $$$ $$$ b $$$ indices two contestants jury return $$$ 1 $$$ $$$ a $$$ match $$$ b $$$ $$$ 2 $$$ $$$ b $$$ match $$$ a $$$ $$$ 0 $$$ number win equal find winner $$$ \left \lceil \frac { 1 } { 3 } \cdot 2^ { n + 1 } \right \rceil $$$ query $$$ \lceil x \rceil $$$ denote value $$$ x $$$ round nearest integer note tournament long mean result fix depend query first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 2^ { 14 } $$$ ) — number test case line input contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 17 $$$ ) guarantee sum $$$ 2^n $$$ test case exceed $$$ 2^ { 17 } $$$ interaction test case begin read integer $$$ n $$$ make a query output ` ` ? a b '' ( $$$ 1 \leq a b \leq 2^n $$$ ) without quote afterwards read one single integer — answer query make $$$ \left \lceil \frac { 1 } { 3 } \cdot 2^ { n + 1 } \right \rceil $$$ query test case receive integer $$$ -1 $$$ instead answer a valid value $$$ n $$$ mean program make invalid query exceed limit query give incorrect answer previous test case program must terminate immediately receive a wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream ready give final answer output ` ` ! x '' ( $$$ 1 \leq x \leq 2^n $$$ ) without quote — winner tournament give answer count towards limit query solve a test case program move next one immediately solve test case program terminate immediately print a query answer forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack use follow format first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 2^ { 14 } $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 17 $$$ ) second line test case contain $$$ 2^n $$$ number a line — number win participant a sequence match consistent number win sum $$$ 2^n $$$ exceed $$$ 2^ { 17 } $$$ tournament first test case show number win $$$ [ <unknown> ] $$$","['greedy', 'number theory']",1800.0
1552/H,"let us call a point plane admissible coordinate positive integers less equal $$$ 200 $$$ invisible rectangle : order guess may ask $$$ 4 $$$ query query choose a nonempty subset admissible point tell many choose point inside boundary invisible rectangle ask a query ( kind describe statement ) shall print two line : identify perimeter $$$ p $$$ invisible rectangle must print ` ` ! $$$ p $$$ ` ` ( without quote ) terminate program ask $$$ 4 $$$ query one query malformed interactor terminate immediately program receive verdict wrong answer interactor may adaptive ( i.e. hide rectangle may choose begin interaction ) print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack a solution use follow format input one line contain $$$ 4 $$$ integers $$$ x_0 $$$ $$$ y_0 $$$ $$$ x_1 $$$ $$$ y_1 $$$ ( $$$ 1\le x_0 < <unknown> 200 $$$ $$$ 1\le y_0 < y_1 \le 200 $$$ ) — $$$ ( x_0 y_0 ) $$$ bottom - left vertex hide rectangle $$$ ( x_1 y_1 ) $$$ top - right vertex hide rectangle note hack interaction wo n't adaptive follow example interaction first sample intend show format query $$$ $$$ \begin { array } { l|l|l } \text { query ( contestant program ) } & \text { answer ( interactor ) } & \text { explanation } \\ \hline \mathtt { ? \ 4 } & & \text { choose $ 4 $ vertices } \\ \mathtt { 13\ 5\ 13\ <unknown> 123\ 5\ 123\ 80 } & \mathtt { 4 } & \text { hide rectangle } \\ \hline \mathtt { ? \ 5 } & & \text { choose $ 4 $ point outside hide } \\ \mathtt { 100\ 4\ 100\ <unknown> 12\ 40\ <unknown> 40\ 50\ 50 } & \mathtt { 1 } & \text { rectangle also point $ ( <unknown> ) $ } \\ \hline \mathtt { ? \ 2 } & & \text { choose point $ ( 1 1 ) $ } \\ \mathtt { 200\ 200\ 1\ 1 } & \mathtt { 0 } & \text { $ ( <unknown> ) $ } \\ \hline \mathtt { ! \ <unknown> } & & \text { correct perimeter . } \end { array } $$$ $$$ second sample a possible interaction follow $$$ $$$ \begin { array } { l|l|l } \text { query ( contestant program ) } & \text { answer ( interactor ) } & \text { explanation } \\ \hline \mathtt { ? \ 4 } & & \text { choose point $ ( 3 2 ) $ $ ( 4 1 ) $ } \\ \mathtt { 3\ 2\ 4\ 1\ 5\ 2\ 4\ 3 } & 2 & \text { $ ( 5 2 ) $ $ ( 4 3 ) $ . } \\ \hline \mathtt { ? \ 7 } & & \text { choose point $ ( 1 4 ) $ $ ( 2 4 ) $ } \\ \mathtt { 1\ 4\ 2\ 4\ 1\ 5\ 2\ 5\ 5\ 5\ 5\ 6\ 6\ 5 } & 1 & \text { $ ( 1 5 ) $ $ ( 2 5 ) $ $ ( 5 5 ) $ $ ( 5 6 ) $ $ ( 6 5 ) $ . } \\ \hline \mathtt { ! \ 8 } & & \text { correct perimeter . } \end { array } $$$ $$$ situation show follow picture : green point ones belong first query orange point ones belong second query one see exactly two rectangles consistent interactor 's answer :","['binary search', 'number theory']",3300.0
1411/B,call a positive integer number fair divisible nonzero digits example $$$ 102 $$$ fair ( divisible $$$ 1 $$$ $$$ 2 $$$ ) $$$ <unknown> $$$ n't divisible $$$ 8 $$$ give a positive integer $$$ n $$$ find minimum integer $$$ x $$$ $$$ n \leq x $$$ $$$ x $$$ fair first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) next $$$ t $$$ line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 10^ { 18 } $$$ ) $$$ t $$$ test case print a single integer — least fair number less $$$ n $$$ explanations test case :,"['brute force', 'number theory']",1000.0
1575/C,"denote a cyclic sequence size $$$ n $$$ array $$$ s $$$ $$$ s_n $$$ adjacent $$$ s_1 $$$ segment $$$ s [ r l ] $$$ $$$ l < r $$$ concatenation $$$ s [ r n ] $$$ $$$ s [ 1 l ] $$$ give array $$$ a $$$ consist $$$ n $$$ integers define $$$ b $$$ cyclic sequence obtain concatenate $$$ m $$$ copy $$$ a $$$ note $$$ b $$$ size $$$ n \cdot m $$$ give integer $$$ k $$$ $$$ k = 1 $$$ $$$ k $$$ a prime number find number different segment $$$ b $$$ sum elements segment divisible $$$ k $$$ two segment consider different set indices segment different example $$$ n = 3 $$$ $$$ m = 2 $$$ set indices segment $$$ s [ 2 5 ] $$$ $$$ \ { 2 3 4 5\ } $$$ segment $$$ s [ 5 2 ] $$$ $$$ \ { 5 6 1 2\ } $$$ particular segment $$$ s [ 1 6 ] s [ 2,1 ] \ldots s [ 6 5 ] $$$ consider segment output answer modulo $$$ 1000000000 + 7 $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \leq n m k \leq 200000 $$$ $$$ k = 1 $$$ $$$ k $$$ a prime number ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 200000 $$$ ) output integer denote number different segment $$$ b $$$ sum elements segment divisible $$$ k $$$ modulo $$$ 1000000000 + 7 $$$ first example valid segment $$$ [ <unknown> ] $$$ $$$ [ 2 3 ] $$$ $$$ [ 3 5 ] $$$ $$$ [ 4 2 ] $$$ second example one valid segment $$$ [ 1 5 ] $$$","['data structures', 'number theory']",3000.0
1184/A2,"learn polynomial hash heidi decide learn shift - xor hash particular come across interest problem give a bitstring $$$ y \in \ { 0,1\ } ^n $$$ find number different $$$ k $$$ ( $$$ 0 \leq k < n $$$ ) exist $$$ x \in \ { 0,1\ } ^n $$$ $$$ y = x \oplus \mbox { shift } ^k ( x ) $$$ $$$ \oplus $$$ xor operation $$$ \mbox { shift } ^k $$$ operation shift a bitstring cyclically right $$$ k $$$ time example $$$ 001 \oplus 111 = 110 $$$ $$$ \mbox { shift } <unknown> ( <unknown> ) = <unknown> $$$ first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) length bitstring $$$ y $$$ second line contain bitstring $$$ y $$$ output a single integer : number suitable value $$$ k $$$ first example : $$$ x $$$ $$$ x \oplus x = 1010 $$$ hence answer $$$ 3 $$$","['brute force', 'number theory']",2100.0
1759/D,"<unknown> occur <unknown> store need change price <unknown> current price good $$$ n $$$ give allow increase price good $$$ k $$$ time $$$ 1 \le k \le m $$$ k integer output roundest possible new price good , one maximum number zero end example number 481000 round number 1000010 ( three zero end 481000 one end 1000010 ) several possible variants output one new price maximal impossible get a <unknown> price output $$$ n \cdot m $$$ ( maximum possible price ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — the number test case test test case consist one line line contain two integers : $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 1000000000 $$$ ) $$$ n $$$ old price good number $$$ m $$$ mean increase price $$$ n $$$ $$$ m $$$ time test case output a separate line roundest integer form $$$ n \cdot k $$$ ( $$$ 1 \le k \le m $$$ $$$ k $$$ — integer ) several possible variants output one new price ( value $$$ n \cdot k $$$ ) maximal impossible get a round price output $$$ n \cdot m $$$ ( maximum possible price ) first case $$$ n = 6 $$$ $$$ m = 11 $$$ get a number two zero end need increase price $$$ 50 $$$ time $$$ 50 > m = 11 $$$ maximum price multiple $$$ 10 $$$ would $$$ 60 = 60 $$$ second case $$$ n = 5 $$$ $$$ m = 43 $$$ maximum price multiple $$$ 100 $$$ would $$$ 200 = 200 $$$ third case $$$ n = 13 $$$ $$$ m = 5 $$$ possible new price end $$$ 0 $$$ output $$$ n \cdot m = 65 $$$ fourth case increase price $$$ 15 $$$ time fifth case increase price $$$ <unknown> $$$ time","['brute force', 'number theory']",1400.0
364/C,"'ll call a set positive integers a beautiful follow condition fulfill : prime p , word one number set divisible prime p least half number set divisible p. task find beautiful set number elements equal k element n't exceed <unknown> first line contain integer k ( 10 ≤ k ≤ 5000 ) show many number require beautiful set first line print k space - separated integers a beautiful set multiple set allow print","['brute force', 'number theory']",2300.0
922/C,"imp watch a <unknown> cave paint number <unknown> <unknown> order immediately attract attention imp <unknown> propose a guess remainder division a number n integers i 1 k. unfortunately many integers analyze imp imp want check whether remainder distinct formally want check , 1 ≤ i ≤ k distinct i. e. pair ( i j ) : line contain two integers n k ( 1 ≤ n k ≤ 1018 ) print ` ` yes '' remainder distinct ` ` '' otherwise print letter arbitrary case ( lower upper ) first sample remainder modulo 1 4 coincide","['brute force', 'number theory']",1600.0
346/A,bore summer holiday n't ? alice bob invent a new game play rule follow first get a set n distinct integers take turn make follow move move either alice bob ( player whose turn current ) choose two distinct integers x y set set n't contain absolute difference |x - y| player add integer |x - y| set ( size set increase one ) current player valid move ( ) lose game question finally win game players play optimally remember alice always move first first line contain integer n ( 2 ≤ n ≤ 100 ) — initial number elements set second line contain n distinct space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — elements set print a single line winner 's name alice win print ` ` alice '' otherwise print ` ` bob '' ( without quote ) consider first test sample alice move first move choose 2 3 add 1 set next bob move valid move anymore winner alice,"['math', 'number theory']",1600.0
78/C,two beaver timur marsel play follow game n log exactly m meter length beaver move turn move a beaver choose a log gnaw number ( one ) equal part length one express integer less k meter result part also a log gnaw future beaver beaver ca n't make a move lose thus beaver win timur make first move players play optimal way determine winner first line contain three integers n m k ( 1 ≤ n m k ≤ 109 ) print ` ` timur '' timur win ` ` marsel '' marsel win print everything without quote first sample beaver one log 15 meter length timur move first move split log 3 part 5 meter length marsel move ca n't split result log k = 4 . thus winner timur second example beaver 4 log 9 meter length timur ca n't split result part possess length less 5 meter 's lose instantly,"['dp', 'number theory']",2000.0
1630/F,give undirected graph $$$ n $$$ vertices index $$$ 1 $$$ $$$ n $$$ vertex $$$ i $$$ a value $$$ a_i $$$ assign value $$$ a_i $$$ different edge two vertices $$$ u $$$ $$$ v $$$ either $$$ a_u $$$ divide $$$ a_v $$$ $$$ a_v $$$ divide $$$ a_u $$$ find minimum number vertices remove remain graph bipartite remove a vertex remove edge incident input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 5\cdot10000 $$$ ) — number vertices graph second line test case contain $$$ n $$$ integers $$$ i $$$ -th value $$$ a_i $$$ ( $$$ 1 \le a_i \le 5\cdot10000 $$$ ) assign $$$ i $$$ -th vertex value $$$ a_i $$$ different guarantee sum $$$ n $$$ test case exceed $$$ 5\cdot10000 $$$ test case print a single integer — minimum number vertices remove remain graph bipartite first test case remove vertices value $$$ 1 $$$ $$$ 2 $$$ obtain a bipartite graph answer $$$ 2 $$$ impossible remove less $$$ 2 $$$ vertices still obtain a bipartite graph second test case remove vertex graph already bipartite answer $$$ 0 $$$ third test case remove vertex value $$$ 12 $$$ answer $$$ 1 $$$ fourth test case remove vertices value $$$ 2 $$$ $$$ <unknown> $$$ answer $$$ 2 $$$,"['graphs', 'number theory']",3400.0
456/B,fedya study a <unknown> fedya 's maths <unknown> calculate follow expression : give value n. fedya manage complete task ? note give number n extremely large ( e.g exceed integer type program language ) single line contain a single integer n ( 0 ≤ n ≤ <unknown> ) number n't contain lead zero print value expression without lead zero operation x mod y mean take remainder division x y. note first sample :,"['math', 'number theory']",1200.0
375/A,number a whose decimal representation quite luckily contain digits 1 6 8 9 . rearrange digits decimal representation result number divisible 7 . number a n't contain lead zero contain digits 1 6 8 9 ( also contain another digits ) result number also must n't contain lead zero first line contain positive integer a decimal record guarantee record number a contain digits : 1 6 8 9 . number a n't contain lead zero decimal representation number a contain least 4 106 character print a number decimal notation without lead zero — result permutation impossible rearrange digits number a require manner print 0,"['math', 'number theory']",1600.0
516/E,drazil many friends happy unhappy drazil want make friends become happy invent follow plan n boys m girls among friends let 's number 0 n - 1 0 m - 1 separately i - th day drazil invite -th boy -th girl dinner together ( drazil programmer i start 0 ) one two people happy one also become happy otherwise two people remain state a person become happy ( happy originally ) stay happy forever drazil want know day friends become happy determine wo n't become happy first line contain two integer n m ( 1 ≤ n m ≤ 109 ) second line contain integer b ( 0 ≤ b ≤ min ( n 105 ) ) denote number happy boys among friends drazil follow b distinct integers x1 x2 ... xb ( 0 ≤ xi < n ) denote list indices happy boys third line <unknown> integer g ( 0 ≤ g ≤ min ( m 105 ) ) denote number happy girls among friends drazil follow g distinct integers y1 y2 ... <unknown> ( 0 ≤ yj < m ) denote list indices happy girls guarantee least one person unhappy among friends print number first day friends drazil become happy day wo n't come print -1 . define remainder integer division i k. first sample case :,"['math', 'number theory']",3100.0
487/C,consider a sequence [ a1 a2 ... ] define prefix product sequence give n find a permutation [ 1 2 ... n ] prefix product sequence a permutation [ 0 1 ... n - 1 ] input line contain integer n ( 1 ≤ n ≤ 105 ) first output line print ` ` yes '' sequence exist print ` ` '' sequence exist solution exist output n line i - th line contain integer ai elements sequence different positive integers larger n. multiple solutions allow print second sample valid sequence,"['math', 'number theory']",2300.0
371/B,two little greedy bear find two piece cheese forest weight a b <unknown> correspondingly bear greedy ready fight larger piece 's fox come start <unknown> : ` ` little bear wait a little i want make piece equal '' ` ` come fox go ? ` ` curious bear ask ` ` 's easy '' say fox ` ` mass a certain piece divisible two i eat exactly a half piece mass a certain piece divisible three i eat exactly two - <unknown> mass divisible five i eat four - <unknown> i 'll eat a little make piece equal '' little bear realize fox 's proposal contain a catch time realize make two piece equal agree proposal one condition : fox make piece equal quickly possible find minimum number operations fox need make piece equal first line contain two space - separated integers a b ( 1 ≤ a b ≤ 109 ) fox lie little bear impossible make piece equal print -1 . otherwise print require minimum number operations piece cheese initially equal require number 0,"['math', 'number theory']",1300.0
271/E,three horse live a horse land : one gray one white one gray - and - white horse really amuse animals adore special card card must contain two integers first one top second one bottom card let 's denote a card a top b bottom ( a b ) three horse paint special card show ( a b ) card gray horse horse paint a new ( a + 1 b + 1 ) card show ( a b ) card a b even integers white horse horse paint a new card show two card ( a b ) ( b c ) gray - and - white horse paint a new ( a c ) card polycarpus really want get n special card ( 1 a1 ) ( 1 a2 ) ... ( 1 ) go horse land take exactly one ( x y ) card horse land 1 ≤ x < y ≤ m. many ways choose card perform action horse land get require card ? polycarpus get card horse a result action describe polycarpus allow get additional card besides card require first line contain two integers n m ( 1 ≤ n ≤ 105 2 ≤ m ≤ 109 ) second line contain sequence integers a1 a2 ... ( 2 ≤ ai ≤ 109 ) note number sequence coincide number line separate single space print a single integer — answer problem please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier,"['math', 'number theory']",2200.0
267/A,"' ve get two number long larger zero go operation : subtract lesser number larger one equal <unknown> one number another example one operation transform pair ( <unknown> ) pair ( <unknown> ) transform ( 5,5 ) ( <unknown> ) ' ve get number pair ( ai bi ) many operations perform ? first line contain number pair n ( 1 ≤ n ≤ 1000 ) follow n line line contain a pair positive integers ai bi ( 1 ≤ ai bi ≤ 109 ) print seek number operations pair a single line","['math', 'number theory']",900.0
495/B,last week ham learn a new type equations math class call modular equations let define i modulo j remainder division i j denote a modular equation ham 's teacher describe equation form a b two non - negative integers x a variable call a positive integer x a solution equation ham n't pay much attention class since watch a movie manage understand definitions equations want write math exercise since idea ask help tell know modular equations ask write a program give two number a b determine many answer modular equation line input two space - separated integers a b ( 0 ≤ a b ≤ 109 ) give infinite number answer equation print ` ` infinity '' ( without quote ) otherwise print number solutions modular equation first sample answer modular equation 8 16 since,"['math', 'number theory']",1600.0
248/B,chilly willy love play number know prime number digits yet number 2 3 5 7 . willy grow rather bore number come a game connect chilly willy want find minimum number length n simultaneously divisible number willy already know ( 2 3 5 7 ) help a number 's length number digits decimal representation without lead zero a single input line contain a single integer n ( 1 ≤ n ≤ 105 ) print a single integer — answer problem without lead zero ` ` -1 '' ( without quote ) number meet problem condition exist,"['math', 'number theory']",1400.0
225/E,consider follow equation : let 's find integer z ( z > 0 ) equation unsolvable positive integers phrase ` ` unsolvable positive integers '' mean positive integers x y ( x y > 0 ) give equation hold let 's write z increase order : <unknown> <unknown> <unknown> ( zi < zi + 1 ) task : give number n find number zn first line contain a single integer n ( 1 ≤ n ≤ 40 ) print a single integer — number zn modulo 1000000007 ( 109 + 7 ) guarantee answer exist,"['math', 'number theory']",2100.0
216/E,"know martians use a number system base k. digit b ( 0 ≤ b < k ) consider lucky first contact martians <unknown> occur year b ( martian <unknown> ) a digital root d ( x ) number x a number consist a single digit result cascade sum digits number x. word ` ` cascade '' mean first sum give us a number consist several digits sum digits , get a one digit number example d ( <unknown> ) = d ( ( 3 + 5 + 0 + 4 ) 7 ) = d ( <unknown> ) = d ( ( 1 + 5 ) 7 ) = d ( 67 ) = 67 . sample calculations perform 7 - base notation a number 's digital root equal b martians also call number lucky string s consist n digits k - base notation system task find many distinct substrings give string lucky number lead zero permit number note substring s [ i ... j ] string s = a1a2 ... ( 1 ≤ i ≤ j ≤ n ) string <unknown> + 1 ... aj two substrings s [ i1 ... j1 ] s [ i2 ... j2 ] string s different either i1 ≠ i2 j1 ≠ j2 first line contain three integers k b n ( 2 ≤ k ≤ 109 0 ≤ b < k 1 ≤ n ≤ 105 ) second line contain string s a sequence n integers represent digits k - base notation : i - th integer equal ai ( 0 ≤ ai < k ) — i - th digit string s. number line space - separated print a single integer — number substrings lucky number please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first sample follow substrings seek digital root : s [ 1 ... 2 ] = ` ` 3 2 '' s [ 1 ... 3 ] = ` ` 3 2 0 '' s [ 3 ... 4 ] = ` ` 0 5 '' s [ 4 ... 4 ] = ` ` 5 '' s [ 2 ... 6 ] = ` ` 2 0 5 6 1 ''","['math', 'number theory']",2000.0
472/A,one way create a task learn math generate random math statement modify <unknown> get something new build a new task example a statement call ` ` goldbach 's conjecture '' say : ` ` even number less four express sum two prim '' let 's modify a statement like : ` ` integer less 12 express sum two composite number . '' like goldbach 's conjecture i prove <unknown> give integer n less 12 express a sum two composite number line contain integer n ( 12 ≤ n ≤ 106 ) output two composite integers x y ( 1 < x y < n ) x + y = n. multiple solutions output first example 12 = 4 + 8 4 8 composite number output ` ` 6 6 '' ` ` 8 4 '' well second example 15 = 6 + 9 . note ca n't output ` ` 1 14 '' 1 a composite number,"['math', 'number theory']",800.0
361/B,levko love permutations much a permutation length n a sequence distinct positive integers n. let ’ s assume value gcd ( a b ) show greatest common divisor number a b. levko assume element pi permutation p1 p2 ... pn good gcd ( i pi ) > 1 . levko consider a permutation beautiful exactly k good elements unfortunately ’ t know beautiful permutation task help find least one single line contain two integers n k ( 1 ≤ n ≤ 105 0 ≤ k ≤ n ) a single line print either beautiful permutation -1 permutation ’ t exist multiple suitable permutations allow print first sample elements 4 3 good gcd ( 2 4 ) = 2 > 1 gcd ( 3 3 ) = 3 > 1 . elements 2 1 good gcd ( 1 2 ) = 1 gcd ( 4 1 ) = 1 . exactly 2 good elements permutation beautiful second sample beautiful permutations,"['math', 'number theory']",1200.0
343/A,"mad scientist mike build a time machine spare time finish work need a resistor a certain resistance value however mike lot identical resistors unit resistance r0 = 1 . elements resistance construct resistors problem consider follow elements : consecutive connection resistance new element equal r = + r0 parallel connection resistance new element equal case equal resistance element connect mike need assemble element a resistance equal fraction determine smallest possible number resistors need make element single input line contain two space - separated integers a b ( 1 ≤ a b ≤ 1018 ) guarantee fraction irreducible guarantee a solution always exist print a single number — answer problem please use % lld specifier read write 64 - bit integers с++ recommend use cin cout stream % i64d specifier first sample one resistor enough second sample one connect resistors parallel take result element connect a third resistor consecutively , get element resistance make element use two resistors","['math', 'number theory']",1600.0
338/D,consider a table g size n × m g ( i j ) = gcd ( i j ) 1 ≤ i ≤ n 1 ≤ j ≤ m. gcd ( a b ) greatest common divisor number a b. a sequence positive integer number a1 a2 ... ak say sequence occur table g coincide consecutive elements row start position formally number 1 ≤ i ≤ n 1 ≤ j ≤ m - k + 1 exist g ( i j + l - 1 ) = al 1 ≤ l ≤ k. determine sequence a occur table g. first line contain three space - separated integers n m k ( 1 ≤ n m ≤ 1012 ; 1 ≤ k ≤ 10000 ) second line contain k space - separated integers a1 a2 ... ak ( 1 ≤ ai ≤ 1012 ) print a single word ` ` yes '' give sequence occur table g otherwise print ` ` '' sample 1 . <unknown> row table g start sequence { 1 2 1 2 5 2 1 2 1 10 } see elements fifth <unknown> coincide sequence a. sample 2 . time width table g equal 8 . sequence a n't occur,"['math', 'number theory']",2900.0
359/C,"simon a prime number x array non - negative integers a1 a2 ... , simon love fraction much today write number a piece paper simon lead fraction a common denominator sum get a fraction : number t equal <unknown> + a2 + ... + simon want reduce result fraction help find greatest common divisor number s t. gcd rather large print a remainder divide number 1000000007 ( 109 + 7 ) first line contain two positive integers n x ( 1 ≤ n ≤ 105 2 ≤ x ≤ 109 ) — size array prime number second line contain n space - separated integers a1 a2 ... ( 0 ≤ a1 ≤ a2 ≤ ... ≤ ≤ 109 ) print a single number — answer problem modulo 1000000007 ( 109 + 7 ) first sample thus answer problem 8 . second sample , answer problem 27 <unknown> = <unknown> <unknown> = <unknown> third sample answer problem <unknown> mod 1000000007 = <unknown> . fourth sample thus answer problem 1","['math', 'number theory']",1900.0
303/D,bike a smart boy love math much invent a number call ` ` rotatable number '' inspire 142857 . see 142857 a magic number rotate get multiply number 1 2 ... 6 ( number one number 's length ) rotate a number mean put last several digit first example rotate number 12345 obtain number : 12345 <unknown> <unknown> <unknown> <unknown> . 's worth mention leading - zeroes allow <unknown> <unknown> obtain rotate <unknown> . see 142857 satisfy condition 6 equations base 10 . bike a problem extend ` ` rotatable number '' base b. mention 142857 a ` ` rotatable number '' base 10 . another example 0011 base 2 . 4 equations base 2 . want find largest b ( 1 < b < x ) a positive ` ` rotatable number '' ( leading - zeroes allow ) length n base b. note time multiply a rotatable number number 1 length get a rotate number line contain two space - separated integers n x ( 1 ≤ n ≤ 5·106 2 ≤ x ≤ 109 ) print a single integer — largest b find b exist print -1 instead,"['math', 'number theory']",2600.0
346/E,"<unknown> jump aim guide a four - <unknown> creature call ` ` doodler '' a never - <unknown> series platforms without fall — wikipedia a popular game xiaodao like much one day play game wonder whether exist a platform doodler could n't reach due limit jump ability consider follow problem n platforms height x - th ( 1 ≤ x ≤ n ) platform <unknown> mod p a p positive co - prime integers maximum possible height a doodler 's jump h. jump height h1 height h2 ( h1 < h2 ) h2 - h1 ≤ h. initially doodler grind height 0 . question whether reach highest platform example a = 7 n = 4 p = 12 h = 2 heights platforms 7 2 9 4 picture first jump doodler jump platform height 2 second one doodler jump platform height 4 ca n't jump higher platforms , ca n't reach highest platform user xiaodao think problem a long time n't solve ask help also a lot instance problem task solve instance first line contain integer t ( 1 ≤ t ≤ 104 ) — number problem instance next t line contain four integers a n p h ( 1 ≤ a ≤ 109 1 ≤ n < p ≤ 109 0 ≤ h ≤ 109 ) 's guarantee a p co - prime problem instance doodler reach highest platform output ` ` yes '' otherwise output ` ` ''","['math', 'number theory']",3000.0
576/A,vasya petya play a simple game vasya think number x 1 n petya try guess number petya ask question like : ` ` unknown number divisible number y ? ` ` game play follow rule : first petya ask question interest ( also ask question ) vasya respond question a ' yes ' a ' no ' receive answer petya determine number vasya think unfortunately petya familiar number theory help find minimum number question ask make a guarantee guess vasya 's number number yi ask question a single line contain number n ( 1 ≤ n ≤ 103 ) print length sequence question k ( 0 ≤ k ≤ n ) follow k number — question yi ( 1 ≤ yi ≤ n ) several correct sequence question minimum length allow print sequence answer first sample test actually correct unknown number divisible one sequence number equal 1 . unknown number divisible 4 4 . unknown number divisible 3 unknown number 3 . otherwise equal 2 . therefore sequence question allow guess unknown number show correct sequence question length 2 shorter,"['math', 'number theory']",1500.0
838/D,airplane n row front back m people board airplane airplane entrance front back plane person assign seat possible multiple people assign seat people board plane one one start person 1 . person independently choose either front entrance back entrance enter plane a person walk plane walk directly assign seat try sit occupy continue walk direction walk empty seat - take <unknown> empty seat find get end row without find a seat angry find number ways assign ticket passengers board plane without anyone get angry two ways different exist a passenger choose a different entrance ways assign seat different print count modulo 109 + 7 . first line input contain two integers n m ( 1 ≤ m ≤ n ≤ 1 000 000 ) number seat number passengers respectively print a single number number ways modulo 109 + 7 . denote a passenger seat assign side come ( either ` ` f '' ` ` b '' front back respectively ) example one valid way 3b 3b 3b ( i.e passengers assign seat 3 come back entrance ) another valid way would <unknown> <unknown> <unknown> one invalid way would 2b 2b 2b since third passenger would get front without find a seat,"['math', 'number theory']",2700.0
776/E,<unknown> children fight <unknown> <unknown> mycroft ask sherlock eurus find value f ( n ) f ( 1 ) = 1 n ≥ 2 f ( n ) number distinct order positive integer pair ( x y ) satisfy x + y = n gcd ( x y ) = 1 . integer gcd ( a b ) greatest common divisor a b. sherlock say solve child 's play ask mycroft instead get value <unknown> do positive integers d divide n. eurus <unknown> observe finally come problem <unknown> sherlock mycroft define a k - composite function fk ( n ) recursively follow : want tell value fk ( n ) modulo 1000000007 . a single line input contain two space separate integers n ( 1 ≤ n ≤ 1012 ) k ( 1 ≤ k ≤ 1012 ) indicate eurus ask sherlock mycroft find value fk ( n ) modulo 1000000007 . output a single integer — value fk ( n ) modulo 1000000007 . first case 6 distinct order pair ( 1 6 ) ( 2 5 ) ( 3 4 ) ( 4 3 ) ( 5 2 ) ( 6 1 ) satisfy x + y = 7 gcd ( x y ) = 1 . hence f ( 7 ) = 6 . <unknown> ( 7 ) = f ( g ( 7 ) ) = f ( f ( 7 ) + f ( 1 ) ) = f ( 6 + 1 ) = f ( 7 ) = 6,"['math', 'number theory']",2100.0
700/E,bomboslav set a brand agency help company create new <unknown> advertise slogans term problems slogan company a non - empty substring name example company name ` ` <unknown> '' substrings ` ` sand '' ` ` <unknown> '' could slogans string ` ` e '' ` ` <unknown> '' sometimes company perform <unknown> change slogan slogan a consider cooler slogan b b appear a a substring least twice ( occurrences allow overlap ) example slogan a = ` ` abacaba '' cooler slogan b = ` ` ba '' slogan a = ` ` <unknown> '' cooler slogan b = ` ` <unknown> '' slogan a = ` ` aaaaaa '' cooler slogan b = ` ` aba '' give company name w task help bomboslav determine length longest sequence slogans s1 s2 ... sk slogan sequence cooler previous one first line input contain a single integer n ( 1 ≤ n ≤ 200 000 ) — length company name ask bomboslav help second line contain string w length n consist lowercase english letter print a single integer — maximum possible length sequence slogans company name w slogan sequence ( except first one ) cooler previous,['strings'],3300.0
616/F,give n string ti string cost ci let 's define function string ps i number occurrences s ti |s| length string s. find maximal value function f ( s ) string note string s necessarily string t. first line contain integer n ( 1 ≤ n ≤ 105 ) — number string t. next n line contain contain a non - empty string ti ti contain lowercase english letter guarantee sum lengths string t greater 5·105 last line contain n integers ci ( - 107 ≤ ci ≤ 107 ) — cost i - th string print integer a — maximal value function f ( s ) string s. note one time string s necessarily t,['strings'],2700.0
594/E,give a non - empty line s integer k. follow operation perform line exactly : task determine lexicographically smallest string could result apply give operation string s. first line input contain string s ( 1 ≤ |s| ≤ 5 000 000 ) consist lowercase english letter second line contain integer k ( 1 ≤ k ≤ |s| ) — maximum number part partition single line print lexicographically minimum string s ' obtain a result perform describe operation,['strings'],3100.0
533/F,polycarp invent a new way encode string let 's assume string t consist lowercase english letter let 's choose several pair letter english alphabet a way letter occur one pair let 's replace letter t pair letter a pair letter example choose pair ( l r ) ( p q ) ( a o ) word ` ` <unknown> '' accord give encode <unknown> transform word ` ` <unknown> '' polycarpus already two string s t. suspect string t obtain apply give encode method substring string s. find position mi s ( 1 ≤ mi ≤ |s| - |t| + 1 ) t obtain <unknown> substring <unknown> + 1 ... <unknown> + |t| - 1 apply describe encode operation use set pair english alphabet <unknown> first line input contain two integers |s| |t| ( 1 ≤ |t| ≤ |s| ≤ 2·105 ) — lengths string s string t respectively second third line input contain string s t respectively string consist lowercase english letter print number k — number suitable position string s. next line print k integers m1 m2 ... <unknown> — number suitable position increase order,['strings'],2400.0
526/D,one day om nom find a thread n bead different color decide cut first several bead thread make a bead necklace present girlfriend om nelly om nom know girlfriend love beautiful pattern 's want bead necklace form a regular pattern a sequence bead s regular represent s = a + b + a + b + a + ... + a + b + a a b bead sequence ` ` + ` ` concatenation sequence exactly 2k + 1 summands sum among k + 1 ` ` a '' summands k ` ` b '' summands follow alternate order om nelly know friend eager mathematician n't mind a b empty sequence help om nom determine ways cut first several bead find thread ( least one ; probably ) form a regular pattern om nom cut bead n't change order first line contain two integers n k ( 1 ≤ n k ≤ 1 000 000 ) — number bead thread om nom find number k definition regular sequence second line contain sequence n lowercase latin letter represent color bead color correspond a single letter print a string consist n zero ones position i ( 1 ≤ i ≤ n ) must contain either number one first i bead thread form a regular sequence a zero otherwise first sample test a regular sequence a sequence first 6 bead ( take a = ` ` '' b = ` ` bca '' ) a sequence first 7 bead ( take a = ` ` b '' b = ` ` ca '' ) second sample test example a sequence first 13 bead regular take a = ` ` aba '' b = ` ` ba '',['strings'],2200.0
471/D,polar bear menshykov uslada zoo st . petersburg elephant horace zoo kiev get hold lot wooden cub somewhere start make cube tower place cub one top define multiple tower stand a line a wall a wall consist tower different heights horace first finish make wall call wall elephant wall consist w tower bear also finish make wall n't give a name wall consist n tower horace look bear ' tower wonder : many part wall ` ` see elephant '' ? ` ` see elephant '' a segment w contiguous tower heights tower segment match a sequence heights tower horace 's wall order see many <unknown> possible horace raise lower wall even lower wall grind level ( see picture sample clarification ) task count number segment horace ` ` see elephant '' first line contain two integers n w ( 1 ≤ n w ≤ 2·105 ) — number tower bear ' elephant 's wall correspondingly second line contain n integers ai ( 1 ≤ ai ≤ 109 ) — heights tower bear ' wall third line contain w integers bi ( 1 ≤ bi ≤ 109 ) — heights tower elephant 's wall print number segment bear ' wall horace ` ` see elephant '' picture leave show horace 's wall sample picture right show bear ' wall segment horace ` ` see elephant '' gray,['strings'],1800.0
149/E,"study martians petya clearly understand martians absolutely lazy like sleep n't like wake imagine a martian exactly n eye locate a row number leave right 1 n. a martian sleep put a patch eye ( martian morning n't wake ) inner side patch uppercase latin letter , a martian wake open eye see a string s consist uppercase latin letter string 's length n. ` ` <unknown> <unknown> ! '' — <unknown> go a martian already wake n't open eye feel today go a hard day want open eye see something good martian consider m martian word beautiful besides hard open eye early morning open two non - <unknown> segment consecutive eye formally martian choose four number a b c d ( 1 ≤ a ≤ b < c ≤ d ≤ n ) open eye number i a ≤ i ≤ b c ≤ i ≤ d. martian open eye need read visible character leave right thus see word let 's consider different word martian see morning task find many beautiful word among first line contain a non - empty string s consist uppercase latin letter string ' length n ( 2 ≤ n ≤ 105 ) second line contain integer m ( 1 ≤ m ≤ 100 ) — number beautiful word next m line contain beautiful word pi consist uppercase latin letter length 1 1000 . beautiful string pairwise different print single integer — number different beautiful string martian see morning let 's consider sample test martian get second beautiful string open segment eye a = 1 b = 2 c = 4 d = 5 open segment eye a = 1 b = 2 c = 6 d = 7",['strings'],2300.0
1326/D1,easy version problem difference constraint sum lengths string number test case make hack solve versions task give a string $$$ s $$$ consist lowercase english letter find longest string $$$ t $$$ satisfy follow condition : input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) number test case next $$$ t $$$ line describe a test case test case a non - empty string $$$ s $$$ consist lowercase english letter guarantee sum lengths string test case exceed $$$ 5000 $$$ test case print longest string satisfy condition describe exist multiple possible solutions print first test string $$$ s = $$$ ` ` a '' satisfy condition second test string ` ` <unknown> '' satisfy condition : prove exist a longer string satisfy condition fourth test string ` ` c '' correct ` ` c '' $$$ = $$$ ` ` c '' $$$ + $$$ ` ` '' $$$ a $$$ $$$ b $$$ empty possible solution test ` ` s '',['strings'],1500.0
1098/F,"length longest common prefix two string $$$ s = s_1 s_2 \ldots s_n $$$ $$$ t = t_1 t_2 \ldots <unknown> $$$ define maximum $$$ k \le \min ( n m ) $$$ $$$ s_1 s_2 \ldots s_k $$$ equal $$$ t_1 t_2 \ldots <unknown> $$$ let 's denote longest common prefix two string $$$ s $$$ $$$ t $$$ $$$ lcp ( s t ) $$$ z - function a string $$$ s_1 s_2 \dots s_n $$$ a sequence integers $$$ z_1 z_2 \ldots z_n $$$ $$$ <unknown> = lcp ( s_1 s_2 \ldots s_n \ \ s_i s _ { i+1 } \dots s_n ) $$$ ж - function a string $$$ s $$$ define $$$ z_1 + z_2 + \ldots + z_n $$$ 're give a string $$$ s = s_1 s_2 \ldots s_n $$$ $$$ q $$$ query query describe two integers $$$ l_i $$$ $$$ r_i $$$ $$$ 1 \le l_i \le r_i \le n $$$ answer query define ж - function string $$$ s _ { l_i } s _ { l_i +1 } \ldots s _ { r_i } $$$ first line contain string $$$ s $$$ consist lowercase english letter ( $$$ 1 \leq |s| \leq 200\,000 $$$ ) second line contain one integer $$$ q $$$ — number query ( $$$ 1 \leq q \leq 200\,000 $$$ ) follow $$$ q $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ describe query ( $$$ 1 \leq l_i \leq r_i \leq |s| $$$ ) every query output one integer : value ж - function correspond substring first sample case four query :",['strings'],3500.0
963/D,give a string $$$ s $$$ answer $$$ n $$$ query $$$ i $$$ -th query consist integer $$$ k_i $$$ string $$$ m_i $$$ answer query minimum length a string $$$ t $$$ $$$ t $$$ a substring $$$ s $$$ $$$ m_i $$$ least $$$ k_i $$$ occurrences a substring $$$ t $$$ a substring a string a continuous segment character string guarantee two query string $$$ m_i $$$ query different first line contain string $$$ s $$$ $$$ ( 1 \leq \left | s \right | \leq 10^ { 5 } ) $$$ second line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) next $$$ n $$$ line contain integer $$$ k_i $$$ $$$ ( 1 \leq k_i \leq |s| ) $$$ a non - empty string $$$ m_i $$$ — parameters query number $$$ i $$$ order string input consist lowercase english letter sum length string input n't exceed $$$ 100000 $$$ $$$ m_i $$$ distinct query output answer a separate line a string $$$ m _ { i } $$$ occur $$$ s $$$ less $$$ k _ { i } $$$ time output -1,['strings'],2500.0
1817/F,give a string $$$ s $$$ a pair non - empty substrings $$$ ( a b ) $$$ call entangle a ( possibly empty ) link string $$$ c $$$ : word $$$ a $$$ $$$ b $$$ occur $$$ s $$$ substrings $$$ acb $$$ compute total number entangle pair substrings $$$ s $$$ a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end first line contain a string $$$ s $$$ lowercase english letter ( $$$ 1 \leq |s| \leq 100000 $$$ ) — string count pair entangle substrings output a single integer number entangle pair substrings $$$ s $$$ first example entangle pair ( ab ba ) pair correspond link string $$$ c $$$ empty occur substrings whole string abba n't character ab ba second example entangle pair third example entangle pair ( a b ) ( b c ) ( a c ) ( a bc ) ( ab c ) pair correspond link string $$$ c $$$ empty except pair ( a c ) link string $$$ c $$$ b a c occur substrings string abc,['strings'],3500.0
17/E,english class nick nothing remember wonderful string call palindromes remind a string call a palindrome read way leave right right leave examples string : « eye » « <unknown> » « level » « aba » « deed » « racecar » « <unknown> » « <unknown> » nick start look carefully palindromes text read class occurrence palindrome text write a pair — position begin position end occurrence text nick call occurrence palindrome find text subpalindrome find subpalindromes decide find many different pair among subpalindromes cross two subpalindromes cross cover common position text palindrome cross let 's look action perform nick example text « <unknown> » first write subpalindromes : nick count amount different pair among subpalindromes cross pair six : since 's exhaust perform describe action manually nick ask help write a program find amount different subpalindrome pair cross two subpalindrome pair regard different one pair contain a subpalindrome first input line contain integer n ( 1 ≤ n ≤ 2·106 ) — length text follow line contain n lower - case latin letter ( a z ) line output amount different pair two subpalindromes cross output answer modulo <unknown>,['strings'],2900.0
1282/D,interactive problem complete last level <unknown> temple receive a powerful artifact <unknown> level <unknown> celebrate artifact a powerful rune destroy a single spell $$$ s $$$ go find define spell non - empty string consist letter a b. time cast arbitrary non - empty spell $$$ t $$$ rune artifact begin <unknown> resistance rune edit distance string specify cast spell $$$ t $$$ rune - destroying spell $$$ s $$$ edit distance two string $$$ s $$$ $$$ t $$$ a value equal minimum number one - character operations replace insert delete character $$$ s $$$ get $$$ t $$$ example distance <unknown> aaa $$$ 2 $$$ distance aaa aba $$$ 1 $$$ distance <unknown> abb $$$ 3 $$$ edit distance $$$ 0 $$$ string equal also worth consider artifact a resistance limit — cast $$$ n + 2 $$$ spell $$$ n $$$ length spell $$$ s $$$ rune block thus take $$$ n + 2 $$$ fewer spell destroy rune artifact keep mind require <unknown> spell $$$ s $$$ must also count among $$$ n + 2 $$$ spell note length $$$ n $$$ rune - destroying spell $$$ s $$$ know advance know length $$$ n $$$ exceed $$$ 300 $$$ interaction happen query request consist a single non - empty string $$$ t $$$ — spell want cast length string $$$ t $$$ exceed $$$ 300 $$$ string consist letter a b. response query get resistance run — edit distance string specify cast spell $$$ t $$$ secret rune - destroying spell $$$ s $$$ remember $$$ s $$$ contain letter a b. break rune program end immediately a rune destroy get a response resistance $$$ 0 $$$ receive value $$$ 0 $$$ program terminate normally problem interactor adaptive mean test rune - destroying spell $$$ s $$$ change query invalid -1 return receive program immediately terminate normally ( example call exit ( 0 ) ) otherwise test system may issue arbitrary verdict number spell exceed limit ( $$$ n + 2 $$$ $$$ n $$$ length spell $$$ s $$$ unknown ) get wrong answer verdict solution may receive verdict idleness limit exceed n't output anything forget flush output buffer flush output buffer need follow immediately print query line end : <unknown> hack use follow format : a single line print string $$$ s $$$ ( $$$ 1 \le |s| \le 300 $$$ ) letter a b define rune - destroying spell hack solution direct access unknown spell,['strings'],2300.0
928/A,register a social network users allow create convenient login make easier share contact print business card etc login arbitrary sequence lower uppercase latin letter digits underline symbols ( « _ » ) however order decrease number <unknown> user - <unknown> <unknown> issue prohibit register a login similar already exist login precisely two logins s t consider similar transform s t via a sequence operations follow type : example logins « codeforces » « <unknown> » well « <unknown> » « <unknown> » consider similar whereas « codeforces » « <unknown> » 're give a list exist logins two similar <unknown> a newly create user login check whether new login similar exist ones first line contain a non - empty string s consist lower uppercase latin letter digits underline symbols ( « _ » ) length exceed 50 — login second line contain a single integer n ( 1 ≤ n ≤ 1 000 ) — number exist logins next n line describe exist logins follow constraints user login ( refer first line input ) 's guarantee two exist logins similar print « yes » ( without quote ) user register via login i.e none exist logins similar otherwise print « » ( without quote ) second sample case user want create a login consist three zero 's impossible due collision third among exist third sample case new login similar second one,['strings'],1200.0
1654/B,"give a string $$$ s $$$ consist lowercase letter english alphabet must perform follow algorithm $$$ s $$$ : a prefix a string consist several first letter a give string without reorder empty prefix also a valid prefix example string ` ` abcd '' 5 prefix : empty string ` ` a '' ` ` ab '' ` ` abc '' ` ` abcd '' instance perform algorithm $$$ s = $$$ ` ` <unknown> '' find final state string perform algorithm first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow $$$ t $$$ line contain a description one test case line contain a string $$$ s $$$ give string consist lowercase letter english alphabet lengths $$$ 1 $$$ $$$ 200000 $$$ inclusive guarantee sum lengths $$$ s $$$ test case exceed $$$ 200000 $$$ test case print a single line contain string $$$ s $$$ execute algorithm show string non - empty first test case explain statement second test case operations perform $$$ s $$$ third test case fourth test case ,",['strings'],800.0
1606/A,give a string $$$ s $$$ length $$$ n $$$ consist character a and/or b. let $$$ \operatorname { ab } ( s ) $$$ number occurrences string ab $$$ s $$$ a substring analogically $$$ \operatorname { ba } ( s ) $$$ number occurrences ba $$$ s $$$ a substring one step choose index $$$ i $$$ replace $$$ s_i $$$ character a b. minimum number step need make achieve $$$ \operatorname { ab } ( s ) = \operatorname { ba } ( s ) $$$ ? reminder : number occurrences string $$$ d $$$ $$$ s $$$ substring number indices $$$ i $$$ ( $$$ 1 \le i \le |s| - |d| + 1 $$$ ) substring $$$ s_i s _ { i + 1 } \dots s _ { i + |d| - 1 } $$$ equal $$$ d $$$ example $$$ \operatorname { ab } ( $$$ aabbbabaa $$$ ) = 2 $$$ since two indices $$$ i $$$ : $$$ i = 2 $$$ aabbbabaa $$$ i = 6 $$$ aabbbabaa test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) description test case follow first line test case contain a single string $$$ s $$$ ( $$$ 1 \le |s| \le 100 $$$ $$$ |s| $$$ length string $$$ s $$$ ) consist character a and/or b. test case print result string $$$ s $$$ $$$ \operatorname { ab } ( s ) = \operatorname { ba } ( s ) $$$ 'll get make minimum number step multiple answer print first test case $$$ \operatorname { ab } ( s ) = 0 $$$ $$$ \operatorname { ba } ( s ) = 0 $$$ ( occurrences ab ( ba ) b ) leave $$$ s $$$ untouched second test case $$$ \operatorname { ab } ( s ) = 2 $$$ $$$ \operatorname { ba } ( s ) = 2 $$$ leave $$$ s $$$ untouched third test case $$$ \operatorname { ab } ( s ) = 1 $$$ $$$ \operatorname { ba } ( s ) = 0 $$$ example change $$$ s_1 $$$ b make value zero fourth test case $$$ \operatorname { ab } ( s ) = 2 $$$ $$$ \operatorname { ba } ( s ) = 1 $$$ example change $$$ <unknown> $$$ a make value equal $$$ 1 $$$,['strings'],900.0
1431/I,"give a matrix consist $$$ n $$$ row $$$ m $$$ columns matrix contain lowercase letter latin alphabet perform follow operation number time want : choose two integers $$$ i $$$ ( $$$ 1 \le i \le m $$$ ) $$$ k $$$ ( $$$ 0 < k < n $$$ ) shift every column $$$ j $$$ $$$ i \le j \le m $$$ cyclically $$$ k $$$ shift perform upwards example a matrix process $$$ q $$$ query query a string length $$$ m $$$ consist lowercase letter latin alphabet query calculate minimum number operations describe perform least one row matrix equal string query note query independent , operations perform a query n't affect initial matrix query first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 2 \le n m q \le 2.5 \cdot 100000 $$$ ; $$$ n \cdot m \le 500000 $$$ ; $$$ q \cdot m \le 500000 $$$ ) — number row columns matrix number query respectively next $$$ n $$$ line contain $$$ m $$$ lowercase latin letter — elements matrix follow $$$ q $$$ line contain a description query — string length $$$ m $$$ consist lowercase letter latin alphabet print $$$ q $$$ integers $$$ i $$$ -th integer equal minimum number operations perform matrix contain a string $$$ i $$$ -th query $$$ -1 $$$ specify string obtain",['strings'],2900.0
1394/E,"matter trouble 're n't afraid face a <unknown> i ' ve make another <unknown> dollars ! — <unknown> issue currencies name bobo yuan bobo yuan ( bby ) a series currencies boboniu give a positive integer identifier <unknown> <unknown> etc boboniu a bby collection collection look like a sequence example : use sequence $$$ a= [ 1,2,3,3,2,1,4,4,1 ] $$$ length $$$ <unknown> $$$ denote boboniu want fold collection imagine boboniu stick collection a long piece paper fold currencies : boboniu fold identifier currencies together word $$$ a_i $$$ fold $$$ a_j $$$ ( $$$ 1\le i j\le n $$$ ) $$$ a_i = a_j $$$ must hold boboniu n't care follow rule process fold finish rule obey a formal definition fold describe note accord picture fold $$$ a $$$ two time fact fold $$$ a= [ 1,2,3,3,2,1,4,4,1 ] $$$ two time maximum number fold $$$ 2 $$$ international fan boboniu 're ask calculate maximum number fold 're give a sequence $$$ a $$$ length $$$ n $$$ $$$ i $$$ ( $$$ 1\le <unknown> n $$$ ) need calculate maximum number fold $$$ [ a_1 a_2 \ldots a_i ] $$$ first line contain integer $$$ n $$$ ( $$$ 1\le n\le 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1\le a_i\le n $$$ ) print $$$ n $$$ integers $$$ i $$$ -th equal maximum number fold $$$ [ a_1 a_2 \ldots a_i ] $$$ formally a sequence $$$ a $$$ length $$$ n $$$ let 's define fold sequence a sequence $$$ b $$$ length $$$ n $$$ : ( $$$ [ a ] $$$ value boolean expression $$$ a $$$ i. e. $$$ [ a ] = 1 $$$ $$$ a $$$ true else $$$ [ a ] = 0 $$$ ) define number fold $$$ b $$$ $$$ f ( b ) = \sum _ { i=1 } ^ { n-1 } [ <unknown> b _ { i+1 } ] $$$ maximum number fold $$$ a $$$ $$$ f ( a ) = \max\ { f ( b ) <unknown> b \text { a fold sequence } a \ } $$$",['strings'],3500.0
1243/B2,problem different easy version version ujan make $$$ 2n $$$ swap addition $$$ k \le 1000 n \le 50 $$$ necessary print swap hack problem solve hack previous problem solve problems struggle fail many time ujan decide try clean house decide get string order first ujan two distinct string $$$ s $$$ $$$ t $$$ length $$$ n $$$ consist lowercase english character want make equal since ujan lazy perform follow operation $$$ 2n $$$ time : take two position $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i j \le n $$$ value $$$ i $$$ $$$ j $$$ equal different ) swap character $$$ s_i $$$ $$$ t_j $$$ ujan 's goal make string $$$ s $$$ $$$ t $$$ equal need minimize number perform operations : sequence operations length $$$ 2n $$$ shorter suitable first line contain a single integer $$$ k $$$ ( $$$ 1 \leq k \leq 1000 $$$ ) number test case test case first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 50 $$$ ) length string $$$ s $$$ $$$ t $$$ next two line contain string $$$ s $$$ $$$ t $$$ length exactly $$$ n $$$ string consist lowercase english letter guarantee string different test case output ` ` yes '' ujan make two string equal $$$ 2n $$$ operations ` ` '' otherwise print letter case ( upper lower ) case ` ` yes '' print $$$ m $$$ ( $$$ 1 \le m \le 2n $$$ ) next line $$$ m $$$ number swap operations make string equal print $$$ m $$$ line line contain two integers $$$ i j $$$ ( $$$ 1 \le i j \le n $$$ ) mean ujan swap $$$ s_i $$$ $$$ t_j $$$ correspond operation need minimize number operations sequence length $$$ 2n $$$ suitable,['strings'],1600.0
1090/J,misha n't math homework today 's lesson a <unknown> teacher dr . andrew decide give a hard useless task dr . andrew write two string s t lowercase english letter blackboard remind misha prefix a string a string form remove several ( possibly none ) last character a concatenation two string a string form append second string right first string teacher ask misha write blackboard string concatenations non - empty prefix s non - empty prefix t. misha dr . andrew ask many distinct string misha spend almost entire lesson complete task ask write a program would task automatically first line contain string s consist lowercase english letter second line contain string t consist lowercase english letter lengths string exceed 105 . output a single integer — number distinct string concatenations non - empty prefix s non - empty prefix t. first example string s three non - empty prefix : { a ab aba } string t two non - empty prefix : { a aa } total misha write five distinct string : { aa aaa aba abaa <unknown> } string abaa write twice second example misha write eight distinct string : { aa aaa aaaa aaaaa aaaaaa <unknown> <unknown> <unknown> },['strings'],2600.0
1243/B1,problem different hard version version ujan make exactly one exchange hack problem solve problems struggle fail many time ujan decide try clean house decide get string order first ujan two distinct string $$$ s $$$ $$$ t $$$ length $$$ n $$$ consist lowercase english character want make equal since ujan lazy perform follow operation exactly : take two position $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i j \le n $$$ value $$$ i $$$ $$$ j $$$ equal different ) swap character $$$ s_i $$$ $$$ t_j $$$ succeed ? note perform operation exactly perform operation first line contain a single integer $$$ k $$$ ( $$$ 1 \leq k \leq 10 $$$ ) number test case test case first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 10000 $$$ ) length string $$$ s $$$ $$$ t $$$ next two line contain string $$$ s $$$ $$$ t $$$ length exactly $$$ n $$$ string consist lowercase english letter guarantee string different test case output ` ` yes '' ujan make two string equal ` ` '' otherwise print letter case ( upper lower ) first test case ujan swap character $$$ s_1 $$$ $$$ t_4 $$$ obtain word ` ` house '' second test case possible make string equal use exactly one swap $$$ s_i $$$ $$$ t_j $$$,['strings'],1000.0
1223/B,give two string equal length $$$ s $$$ $$$ t $$$ consist lowercase latin letter may perform number ( possibly zero ) operations string operation choose two adjacent character string assign value first character value second vice versa example $$$ s $$$ ` ` <unknown> '' get follow string one operation : note also apply operation string $$$ t $$$ please determine whether possible transform $$$ s $$$ $$$ t $$$ apply operation number time note answer $$$ q $$$ independent query first line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100 $$$ ) — number query query represent two consecutive line first line query contain string $$$ s $$$ ( $$$ 1 \le |s| \le 100 $$$ ) consist lowercase latin letter second line query contain string $$$ t $$$ ( $$$ 1 \le |t| \leq 100 $$$ $$$ |t| = |s| $$$ ) consist lowercase latin letter query print ` ` yes '' possible make $$$ s $$$ equal $$$ t $$$ ` ` '' otherwise may print every letter case want ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive answer ) first query perform two operations $$$ s_1 = s_2 $$$ ( $$$ s $$$ turn ` ` aabb '' ) $$$ t_4 = <unknown> $$$ ( $$$ t $$$ turn ` ` aabb '' ) second query string equal initially answer ` ` yes '' third query make string $$$ s $$$ $$$ t $$$ equal therefore answer ` ` '',['strings'],1000.0
345/G,give a group n string : s1 s2 ... sn find a subgroup <unknown> <unknown> ... <unknown> ( 1 ≤ i1 < i2 < ... < ik ≤ n ) group follow two condition must hold : task print number string find subgroup first line contain integer n ( 1 ≤ n ≤ 105 ) — number string group next n line contain a string i - th line contain non - empty string si string consist lowercase latin letter sum string si n't exceed 105 . output a single integer — number string find subgroup look test sample require subgroup s1 s2 s3,['strings'],2200.0
208/A,vasya work a dj best berland <unknown> often use dubstep music performance recently decide take a couple old songs make dubstep <unknown> let 's assume a song consist number word make dubstep remix song vasya insert a certain number word ` ` wub '' first word song ( number may zero ) last word ( number may zero ) word ( least one pair neighbour word ) boy glue together word include ` ` wub '' one string play song club example a song word ` ` i x '' transform a dubstep remix ` ` <unknown> '' transform ` ` <unknown> '' recently petya hear vasya 's new dubstep track since n't modern music decide find initial song vasya remixed help petya restore original song input consist a single non - empty string consist uppercase english letter string 's length n't exceed 200 character guarantee vasya remixed song word contain substring ` ` wub '' ; vasya n't change word order also guarantee initially song least one word print word initial song vasya use make a <unknown> remix separate word a space first sample : ` ` <unknown> '' = ` ` wub '' + ` ` wub '' + ` ` abc '' + ` ` wub '' mean song originally consist a single word ` ` abc '' word ` ` wub '' add vasya second sample vasya add a single word ` ` wub '' neighbour word begin end except word ` ` '' ` ` '' — vasya add two ` ` wub '',['strings'],900.0
121/B,petya love lucky number everybody know lucky number positive integers whose decimal representation contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 petya a number consist n digits without lead zero represent array digits without lead zero let 's call d. <unknown> start 1 start significant digit petya want perform follow operation k time : find minimum x ( 1 ≤ x < n ) dx = 4 dx + 1 = 7 x odd assign dx = dx + 1 = 4 otherwise assign dx = dx + 1 = 7 . note x find operation count complete array n't change give initial number array digits number k. help petya find result complete k operations first line contain two integers n k ( 1 ≤ n ≤ 105 0 ≤ k ≤ 109 ) — number digits number number complete operations second line contain n digits without space represent array digits d start d1 guarantee first digit number equal zero single line print result without space — number k operations fulfil first sample number change follow sequence : <unknown> → 4427447 → 4427477 → 4427447 → 4427477 . second sample : 4478 → <unknown> → 4478,['strings'],1500.0
100/D,a lot rumor <unknown> days one day aida decide find rumor make ask n friends help form a circle aida tell person right a piece news a simple string person tell string person his / her right n't tell string exactly 'd hear person make one two type change : finally rumor pass exactly n move ( a complete cycle ) aida hear something quite different expect person leave think someone <unknown> make change explain want write a <unknown> piece code get initial final string tell aida whether 's possible get final string initial one rule describe first line contain a single integer n ( 2 ≤ n ≤ 8 × 106 ) number aida 's friends follow two line contain a non - empty string — initial final string lengths string 107 contain english alphabet letter write a single yes write yes 's possible get final string initial string input case - sensitive output,['strings'],1500.0
99/A,a far away kingdom live king prince <unknown> <unknown> many citizens live <unknown> great trouble come kingdom acmers settle damage strange creatures <unknown> upon kingdom love high precision number a result kingdom <unknown> already three <unknown> merchants ask sell say exactly <unknown> beer <unknown> deal problem somehow king issue order oblige round number closest integer simplify calculations specifically order go like : merchants find algorithm <unknown> ask ( acmers ) help write a program would perform round accord king ’ s order ? first line contain a single number round — integer part ( a non - empty set decimal digits start 0 — <unknown> a case set consist a single digit — case 0 go first ) follow character « . » ( a dot ) follow fractional part ( non - empty set decimal digits ) number 's length exceed 1000 character include dot character input data last number integer part equal 9 print <unknown> - up number without lead zero otherwise print message ` ` <unknown> <unknown> . '' ( without quote ),['strings'],800.0
71/A,sometimes word like ` ` localization '' ` ` internationalization '' long write many time one text quite <unknown> let 's consider a word long length strictly 10 character long word replace a special abbreviation abbreviation make like : write first last letter a word write number letter first last letter number decimal system n't contain lead zero thus ` ` localization '' spell ` ` <unknown> '' ` ` internationalization » spell ` ` <unknown> '' suggest <unknown> process change word <unknown> long word replace abbreviation word long <unknown> change first line contain integer n ( 1 ≤ n ≤ 100 ) follow n line contain one word word consist lowercase latin letter possess lengths 1 100 character print n line i - th line contain result replace i - th word input data,['strings'],800.0
61/B,contest compare number shapur 's teacher find a real genius one could possibly calculations faster even use a super computer ! days contest teacher take a simple - <unknown> exam n students take part exam teacher give 3 string ask concatenate concatenate string mean put arbitrary order one example concatenate <unknown> <unknown> get <unknown> <unknown> depend order concatenation unfortunately enough teacher forget ask students concatenate string a pre - <unknown> order student way he / she like teacher know shapur a fast - <unknown> genius boy ask correct students ' paper shapur good a time - <unknown> task rather like finish soon possible take time solve 3 - <unknown> polynomial time moreover teacher give <unknown> shapur follow 's teacher say : first three line contain a string initial string consist lowercase uppercase latin letter sign ( ` ` - '' ` ` ; '' ` ` _ '' ) initial string length 1 100 inclusively fourth line a single integer n ( 0 ≤ n ≤ 1000 ) number students next n line contain a student 's answer guarantee answer meet teacher say answer <unknown> lowercase uppercase latin letter sign ( ` ` - '' ` ` ; '' ` ` _ '' ) length 1 600 inclusively student write a different line print ` ` <unknown> '' answer wrong ` ` <unknown> '' answer ok,['strings'],1300.0
50/B,a give string s consist n symbols task find number order pair integers i j <unknown> 1 ≤ i j ≤ n2 s [ i ] = s [ j ] i - th symbol string s equal j - th single input line contain s consist lowercase latin letter digits guarantee string s empty length exceed 105 . print a single number represent number pair i j need property pair ( x y ) ( y x ) consider different i.e order pair count,['strings'],1500.0
1189/A,play <unknown> legendary ` ` matrix '' <unknown> keanu <unknown> start doubt : maybe really live virtual reality ? find true need solve follow problem let 's call a string consist zero ones good contain different number zero ones example 1 101 0000 good 01 <unknown> <unknown> good give a string $$$ s $$$ length $$$ n $$$ consist zero ones need cut $$$ s $$$ minimal possible number substrings $$$ s_1 s_2 \ldots s_k $$$ good formally find minimal number string sequence good string $$$ s_1 s_2 \ldots s_k $$$ concatenation ( join ) equal $$$ s $$$ i.e $$$ s_1 + s_2 + \dots + s_k = s $$$ example <unknown> 110010 110 010 11 0010 valid 110 010 11 0010 good ca n't cut 110010 smaller number substrings 110010 n't good time cut 110010 1100 10 n't valid string n't good also cut 110010 1 1 0010 n't valid n't minimal even though $$$ 3 $$$ string good help keanu ? show solution always exist multiple optimal answer print first line input contain a single integer $$$ n $$$ ( $$$ 1\le n \le 100 $$$ ) — length string $$$ s $$$ second line contain string $$$ s $$$ length $$$ n $$$ consist zero ones first line output a single integer $$$ k $$$ ( $$$ 1\le k $$$ ) — a minimal number string cut $$$ s $$$ second line output $$$ k $$$ string $$$ s_1 s_2 \ldots s_k $$$ separate space length string positive concatenation equal $$$ s $$$ good multiple answer print first example string 1 n't cut good condition satisfy second example 1 0 good 10 n't good answer indeed minimal third example 100 011 good <unknown> n't good answer indeed minimal,['strings'],800.0
1832/A,"a palindrome a string read leave right right leave example abacaba aaaa abba racecar palindromes give a string $$$ s $$$ consist lowercase latin letter string $$$ s $$$ a palindrome check whether possible rearrange letter get another palindrome ( equal give string $$$ s $$$ ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case line test case contain a string $$$ s $$$ ( $$$ 2 \le |s| \le 50 $$$ ) consist lowercase latin letter string a palindrome test case print yes possible rearrange letter give string get another palindrome otherwise print may print letter case ( yes yes yes recognize positive answer , recognize negative answer ) first test case possible rearrange letter palindrome <unknown> obtain string <unknown> different give string also a palindrome",['strings'],800.0
1065/G,let 's denote ( yet ) sequence fibonacci string : $$$ f ( 0 ) = $$$ 0 $$$ f ( 1 ) = $$$ 1 $$$ f ( i ) = f ( i - 2 ) + f ( i - 1 ) $$$ plus sign denote concatenation two string let 's denote lexicographically sort sequence suffix string $$$ f ( i ) $$$ $$$ a ( f ( i ) ) $$$ example $$$ f ( 4 ) $$$ 01101 $$$ a ( f ( 4 ) ) $$$ follow sequence : 01 01101 1 101 1101 . elements sequence number $$$ 1 $$$ task print $$$ m $$$ first character $$$ k $$$ -th element $$$ a ( f ( n ) ) $$$ less $$$ m $$$ character suffix output whole suffix line input contain three number $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200 $$$ $$$ 1 \le k \le 10^ { 18 } $$$ ) denote index fibonacci string consider index element $$$ a ( f ( n ) ) $$$ number character output respectively guarantee $$$ k $$$ exceed length $$$ f ( n ) $$$ output $$$ m $$$ first character $$$ k $$$ -th element $$$ a ( f ( n ) ) $$$ whole element length less $$$ m $$$,['strings'],2700.0
1794/A,"marcos love string a lot a favorite string $$$ s $$$ consist lowercase english letter string write non - empty prefix suffix ( except $$$ s $$$ ) a piece paper arbitrary order see string wonder marcos ' favorite string a palindrome , task decide whether $$$ s $$$ a palindrome look piece paper a string $$$ a $$$ a prefix a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character end a string $$$ a $$$ a suffix a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin a palindrome a string read backward forward example string ` ` gg '' ` ` ioi '' ` ` abba '' ` ` <unknown> '' palindromes string ` ` codeforces '' ` ` abcd '' ` ` alt '' test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le <unknown> $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2\le n \le 20 $$$ ) — length string $$$ s $$$ second line test case contain $$$ 2n-2 $$$ string $$$ a_1 a_2 \cdots a _ { 2n-2 } $$$ — non - empty prefix suffix $$$ s $$$ include arbitrary order guarantee string non - empty prefix suffix string consist lowercase english letter test case output ` ` yes '' $$$ s $$$ a palindrome ` ` '' otherwise output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses first test case $$$ s $$$ ` ` abcd '' prefix ` ` a '' ` ` ab '' ` ` abc '' suffix ` ` d '' ` ` cd '' ` ` <unknown> '' string ` ` abcd '' a palindrome answer second test case $$$ s $$$ ` ` ioi '' prefix ` ` i '' ` ` io '' suffix ` ` i '' ` ` oi '' string ` ` ioi '' a palindrome answer yes third test case $$$ s $$$ ` ` gg '' a palindrome fourth test case $$$ s $$$ ` ` alt '' a palindrome",['strings'],800.0
1216/A,nikolay get a string $$$ s $$$ even length $$$ n $$$ consist lowercase latin letter ' a ' ' b ' position number $$$ 1 $$$ $$$ n $$$ want modify string every prefix even length equal amount letter ' a ' ' b ' achieve nikolay perform follow operation arbitrary number time ( possibly zero ) : choose position string replace letter position letter ( i.e replace ' a ' ' b ' replace ' b ' ' a ' ) nikolay use letter except ' a ' ' b ' prefix string $$$ s $$$ length $$$ l $$$ ( $$$ 1 \le l \le n $$$ ) a string $$$ s [ 1 .. l ] $$$ example string $$$ s= $$$ ` ` abba '' two prefix even length first $$$ s [ <unknown> ] = $$$ ` ` ab '' second $$$ s [ <unknown> ] = $$$ ` ` abba '' number ' a ' ' b ' task calculate minimum number operations nikolay perform string $$$ s $$$ modify every prefix even length equal amount letter ' a ' ' b ' first line input contain one even integer $$$ n $$$ $$$ ( 2 \le n \le 2\cdot10^ { 5 } ) $$$ — length string $$$ s $$$ second line input contain string $$$ s $$$ length $$$ n $$$ consist lowercase latin letter ' a ' ' b ' first line print minimum number operations nikolay perform string $$$ s $$$ modify every prefix even length equal amount letter ' a ' ' b ' second line print string nikolay obtain apply operations multiple answer print first example nikolay perform two operations example replace first ' b ' ' a ' last ' b ' ' a ' second example nikolay n't need anything prefix even length initial string already contain equal amount letter ' a ' ' b ',['strings'],800.0
1080/E,sonya a birthday recently present matrix size $$$ n\times m $$$ consist lowercase latin letter assume row number integers $$$ 1 $$$ $$$ n $$$ bottom top columns number $$$ 1 $$$ $$$ m $$$ leave right let 's call a submatrix $$$ ( i_1 j_1 i_2 j_2 ) $$$ $$$ ( 1\leq i_1\leq <unknown> n ; 1\leq j_1\leq <unknown> m ) $$$ elements $$$ a _ { ij } $$$ matrix $$$ i_1\leq <unknown> i_2 $$$ $$$ j_1\leq <unknown> j_2 $$$ sonya state a submatrix beautiful independently reorder character row ( column ) row columns submatrix form <unknown> let 's recall a string call palindrome read leave right right leave example string $$$ abacaba <unknown> a $$$ palindromes string $$$ abca <unknown> ab $$$ help sonya find number beautiful submatrixes submatrixes different element belong one submatrix first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 1\leq n m\leq 250 ) $$$ — matrix dimension next $$$ n $$$ line contain $$$ m $$$ lowercase latin letter print one integer — number beautiful submatrixes first example follow submatrixes beautiful : $$$ ( ( 1 1 ) ( 1 1 ) ) ; ( ( 1 2 ) ( 1 2 ) ) ; $$$ $$$ ( ( 1 3 ) ( 1 3 ) ) ; ( ( 1 1 ) ( 1 3 ) ) $$$ second example submatrixes consist one element follow beautiful : $$$ ( ( 1 1 ) ( 2 1 ) ) ; $$$ $$$ ( ( 1 1 ) ( 1 3 ) ) ; ( ( 2 1 ) ( 2 3 ) ) ; ( ( 1 1 ) ( 2 3 ) ) ; ( ( 2 1 ) ( 2 2 ) ) $$$ beautiful submatrixes : $$$ ( ( 1 1 ) ( 1 5 ) ) ; ( ( 1 2 ) ( 3 4 ) ) ; $$$ $$$ ( ( 1 1 ) ( 3 5 ) ) $$$ submatrix $$$ ( ( 1 1 ) ( 3 5 ) ) $$$ beautiful since reorder : a matrix every row every column form palindromes,['strings'],2400.0
1758/A,a palindrome a string read backward forward example string $$$ \texttt { z } $$$ $$$ \texttt { aaa } $$$ $$$ \texttt { aba } $$$ $$$ \texttt { abccba } $$$ palindromes $$$ \texttt { codeforces } $$$ $$$ \texttt { ab } $$$ double a string $$$ s $$$ obtain write character twice example double $$$ \texttt { see } $$$ $$$ \texttt { <unknown> } $$$ give a string $$$ s $$$ rearrange double form a palindrome output rearrange string prove a rearrangement always exist first line input contain $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case line test case contain a single string $$$ s $$$ ( $$$ 1 \leq |s| \leq 100 $$$ ) consist lowercase english letter note sum $$$ |s| $$$ test case bound test case output a palindromic string length $$$ 2 \cdot |s| $$$ a rearrangement double $$$ s $$$ first test case double $$$ \texttt { a } $$$ $$$ \texttt { aa } $$$ already a palindrome second test case double $$$ \texttt { <unknown> } $$$ $$$ \texttt { <unknown> } $$$ move first $$$ \texttt { s } $$$ end get $$$ \texttt { <unknown> } $$$ a palindrome third test case double $$$ \texttt { <unknown> } $$$ $$$ \texttt { <unknown> } $$$ rearrange character form $$$ \texttt { <unknown> } $$$ a palindrome,['strings'],800.0
1421/C,ringo find a string $$$ s $$$ length $$$ n $$$ yellow <unknown> string contain lowercase letter english alphabet ringo friends love palindromes would like turn string $$$ s $$$ a palindrome apply two type operations string first operation allow choose $$$ i $$$ ( $$$ 2 \le i \le n-1 $$$ ) append substring $$$ <unknown> \ldots s_i $$$ ( $$$ i - 1 $$$ character ) reverse front $$$ s $$$ second operation allow choose $$$ i $$$ ( $$$ 2 \le i \le n-1 $$$ ) append substring $$$ s_i s _ { i + 1 } \ldots s _ { n - 1 } $$$ ( $$$ n - i $$$ character ) reverse end $$$ s $$$ note character string problem index $$$ 1 $$$ example suppose $$$ s= $$$ <unknown> perform first operation $$$ <unknown> $$$ append cb front $$$ s $$$ result <unknown> perform second operation result string $$$ <unknown> $$$ yield <unknown> task help ringo make entire string a palindrome apply two operations ( total ) $$$ 30 $$$ time length result palindrome must exceed $$$ 1000000 $$$ guarantee constraints always a solution also note minimize neither number operations apply length result string fit constraints line contain string $$$ s $$$ ( $$$ 3 \le |s| \le 100000 $$$ ) lowercase letter english alphabet first line contain $$$ k $$$ ( $$$ <unknown> k \le 30 $$$ ) — number operations perform follow $$$ k $$$ line describe operation form l i r i $$$ l $$$ represent first operation $$$ r $$$ represent second operation $$$ i $$$ represent index choose length result palindrome must exceed $$$ 1000000 $$$ first example follow operations perform : abac $$$ \to $$$ <unknown> $$$ \to $$$ <unknown> second sample perform follow operations : <unknown> $$$ \to $$$ <unknown> $$$ \to $$$ <unknown> third example already a palindrome operations require,['strings'],1400.0
1400/A,a binary string a string character either 0 1 . two binary string $$$ a $$$ $$$ b $$$ equal length similar character position ( exist integer $$$ i $$$ $$$ a_i = b_i $$$ ) example : give integer $$$ n $$$ a binary string $$$ s $$$ consist $$$ 2n-1 $$$ character let 's denote $$$ s [ l .. r ] $$$ contiguous substring $$$ s $$$ start $$$ l $$$ -th character end $$$ r $$$ -th character ( word $$$ s [ l .. r ] = s_l s _ { l + 1 } s _ { l + 2 } \dots s_r $$$ ) construct a binary string $$$ w $$$ length $$$ n $$$ similar follow string : $$$ s [ 1 .. n ] $$$ $$$ s [ 2 .. n+1 ] $$$ $$$ s [ 3 .. <unknown> ] $$$ ... $$$ s [ n .. 2n-1 ] $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) second line test case contain binary string $$$ s $$$ length $$$ 2n - 1 $$$ character $$$ s_i $$$ either 0 1 . test case print correspond binary string $$$ w $$$ length $$$ n $$$ multiple string — print show least one string $$$ w $$$ meet constraints always exist explanation sample case ( equal character equal position bold ) : first test case : second test case : third test case : fourth test case :,['strings'],800.0
1342/B,let 's say string $$$ s $$$ period $$$ k $$$ $$$ s_i = s _ { i + k } $$$ $$$ i $$$ $$$ 1 $$$ $$$ |s| - k $$$ ( $$$ |s| $$$ mean length string $$$ s $$$ ) $$$ k $$$ minimum positive integer property examples a period : $$$ s $$$ = '' 0101 '' period $$$ k=2 $$$ $$$ s $$$ = '' 0000 '' period $$$ k=1 $$$ $$$ s $$$ = '' 010 '' period $$$ k=2 $$$ $$$ s $$$ = '' 0011 '' period $$$ k=4 $$$ give string $$$ t $$$ consist 0 's 1 's need find string $$$ s $$$ : let us recall $$$ t $$$ a subsequence $$$ s $$$ $$$ t $$$ <unknown> $$$ s $$$ delete zero elements ( ) without change order remain elements example $$$ t $$$ = '' 011 '' a subsequence $$$ s $$$ = '' 10101 '' first line contain single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case next $$$ t $$$ line contain test case — one per line line contain string $$$ t $$$ ( $$$ 1 \le |t| \le 100 $$$ ) consist 0 's 1 's print one string test case — string $$$ s $$$ need find multiple solutions print one first second test case $$$ s = t $$$ since 's already one optimal solutions answer periods equal $$$ 1 $$$ $$$ 2 $$$ respectively third test case shorter optimal solutions 's <unknown> since n't need minimize string $$$ s $$$ string $$$ s $$$ period equal $$$ 1 $$$,['strings'],1100.0
1267/L,"lucy like letter study definition lexicographical order school play first try construct lexicographically smallest word give letter easy ! try build multiple word minimize one much harder ! formally lucy want make $$$ n $$$ word length $$$ l $$$ give $$$ n \cdot l $$$ letter $$$ k $$$ -th lexicographic order lexicographically small possible first line contain three integers $$$ n $$$ $$$ l $$$ $$$ k $$$ ( $$$ 1\le k \le n \le 1\,000 $$$ ; $$$ 1 \le l \le 1\,000 $$$ ) — total number word length word index word lucy want minimize next line contain a string $$$ n \cdot l $$$ lowercase letter english alphabet output $$$ n $$$ word $$$ l $$$ letter one per line use letter input word must sort lexicographic order $$$ k $$$ -th must lexicographically small possible multiple answer smallest $$$ k $$$ -th word output",['strings'],1800.0
1729/C,polycarp give a row tile tile contain one lowercase letter latin alphabet entire sequence tile form string $$$ s $$$ word give a string $$$ s $$$ consist lowercase latin letter initially polycarp first tile row want get last tile jump tile jump $$$ i $$$ -th tile $$$ j $$$ -th tile a cost equal $$$ <unknown> ( s_i ) - index ( s_j ) | $$$ $$$ index ( c ) $$$ index letter $$$ c $$$ alphabet ( example $$$ index ( $$$ ' a ' $$$ ) = 1 $$$ $$$ index ( $$$ ' b ' $$$ ) = 2 $$$ ... $$$ index ( $$$ ' z ' $$$ ) = 26 $$$ ) polycarp want get $$$ n $$$ -th tile minimum total cost time make maximum number jump word among possible ways get last tile minimum total cost choose one maximum number jump polycarp visit tile polycarp ask help — print sequence indices string $$$ s $$$ jump first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test test case give string $$$ s $$$ ( $$$ 2 \le |s| \le 200000 $$$ ) $$$ |s| $$$ — length string $$$ s $$$ string $$$ s $$$ consist lowercase latin letter guarantee sum string lengths $$$ s $$$ test case exceed $$$ 200000 $$$ answer test case consist two line first line print two integers $$$ cost $$$ $$$ m $$$ $$$ cost $$$ minimum total cost path $$$ m $$$ maximum number visit tile polycarp make get $$$ n $$$ -th tile minimum total cost $$$ cost $$$ ( i.e number jump $$$ m-1 $$$ ) next line print $$$ m $$$ different number $$$ j_1 j_2 \dots <unknown> $$$ ( $$$ 1 \le <unknown> \le |s| $$$ ) — sequence indices tile polycarp jump first number sequence must $$$ 1 $$$ ( $$$ <unknown> $$$ ) last number must value $$$ |s| $$$ ( $$$ <unknown> $$$ ) multiple answer print first test case require path correspond picture : case minimum possible total cost path achieve since $$$ index ( $$$ ' l ' $$$ ) = 12 $$$ $$$ index ( $$$ ' o ' $$$ ) = 15 $$$ $$$ index ( $$$ ' g ' $$$ ) = 7 $$$ $$$ index ( $$$ ' i ' $$$ ) = 9 $$$ $$$ index ( $$$ ' c ' $$$ ) =3 $$$ total cost path $$$ <unknown> - <unknown> - <unknown> - <unknown> + 2 + <unknown> $$$,['strings'],1100.0
1504/A,a palindrome a string read backward forward example string ` ` z '' ` ` aaa '' ` ` aba '' ` ` abccba '' palindromes ` ` codeforces '' ` ` ab '' <unknown> palindromes give <unknown> <unknown> a string $$$ s $$$ must insert exactly one character ' a ' somewhere $$$ s $$$ possible create a string a palindrome find one example otherwise report impossible example suppose $$$ s= $$$ ` ` <unknown> '' insert ' a ' create ` ` <unknown> '' ` ` <unknown> '' ` ` cbaabc '' ` ` <unknown> '' ` ` <unknown> '' however ` ` cbaabc '' a palindrome must output one options first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 10000 $$$ ) — number test case line test case contain a string $$$ s $$$ consist lowercase english letter total length string exceed $$$ 3\cdot 100000 $$$ test case solution output ` ` '' otherwise output ` ` yes '' follow construct string length $$$ <unknown> $$$ next line multiple solutions may print print letter ` ` yes '' ` ` '' case ( upper lower ) first test case describe statement second test case make either ` ` aab '' ` ` aba '' ` ` aba '' a palindrome ` ` aab '' correct answer third test case ` ` <unknown> '' ` ` <unknown> '' correct answer ` ` <unknown> '' fourth test case ` ` baa '' correct answer fifth test case make ` ` aa '' a palindrome answer ` ` '' sixth test case ` ` <unknown> '' a palindrome insert ' a ' <unknown> valid,['strings'],800.0
1109/B,read book one sasha 's <unknown> read one book become <unknown> unusual character character tell like : ` ` many name many countries <unknown> among <unknown> <unknown> dwarves <unknown> i <unknown> west forget south <unknown> north <unknown> ; east i go ` ` moment sasha think would character call east ? east name palindromes a string a palindrome read backward forward example string ` ` <unknown> '' ` ` <unknown> '' ` ` r '' palindromes string ` ` abb '' ` ` ij '' sasha believe hero would name one gods east long could n't two equal name east people follow : write original name a string a piece paper cut paper minimum number time $$$ k $$$ get $$$ k+1 $$$ piece paper substrings initial string unite piece together get a new string piece could n't turn could shuffle way 's possible <unknown> a string <unknown> string <unknown> use $$$ 3 $$$ cut ( swap paper substrings f abc ) string <unknown> ca n't receive use cut formally sasha want give palindrome $$$ s $$$ find minimum $$$ k $$$ cut string $$$ k + 1 $$$ part unite a way final string a palindrome wo n't equal initial string $$$ s $$$ answer print ` ` impossible '' ( without quote ) first line contain one string $$$ s $$$ ( $$$ 1 \le |s| \le <unknown> $$$ ) — initial name consist lowercase latin letter guarantee $$$ s $$$ a palindrome print one integer $$$ k $$$ — minimum number cut need get a new name ` ` impossible '' ( without quote ) first example cut string position : <unknown> unite follow <unknown> show solution one cut second example cut string right middle swap <unknown> get <unknown> third example ca n't make a string wo n't equal initial one fourth example cut suffix <unknown> add begin get <unknown>,['strings'],1800.0
1045/I,"learn a lot space <unknown> a little girl name ana want change subject ana a girl love palindromes ( string read backwards forward ) learn check a give string whether 's a palindrome soon grow tire problem come a interest one need help solve : give array string consist small letter alphabet task find many palindrome pair array a palindrome pair a pair string follow condition hold : least one permutation concatenation two string a palindrome word two string let 's say ` ` aab '' ` ` <unknown> '' concatenate ` ` <unknown> '' check exist a permutation new string a palindrome ( case exist permutation ` ` <unknown> '' ) two pair consider different string locate different indices pair string indices $$$ ( i j ) $$$ consider pair $$$ ( j i ) $$$ first line contain a positive integer $$$ n $$$ ( $$$ 1 \le n \le 100\,000 $$$ ) represent length input array <unknown> next $$$ n $$$ line contain a string ( consist lowercase english letter ' a ' ' z ' ) — element input array total number character input array less $$$ 1\,000\,000 $$$ output one number represent many palindrome pair array first example : second example :",['strings'],1600.0
985/F,give a string s length n consist lowercase english letter two give string s t say s set distinct character s t set distinct character t. string s t isomorphic lengths equal a one - to - one map ( bijection ) f s t f ( si ) = ti formally : example string ` ` <unknown> '' ` ` <unknown> '' isomorphic also string ` ` <unknown> '' ` ` <unknown> '' isomorphic follow pair string isomorphic : ` ` aab '' ` ` bbb '' ` ` test '' ` ` best '' handle m query characterize three integers x y len ( 1 ≤ x y ≤ n - len + 1 ) query check two substrings s [ x ... x + len - 1 ] s [ y ... y + len - 1 ] isomorphic first line contain two space - separated integers n m ( 1 ≤ n ≤ 2·105 1 ≤ m ≤ 2·105 ) — length string s number query second line contain string s consist n lowercase english letter follow m line contain a single query line : xi yi leni ( 1 ≤ xi yi ≤ n 1 ≤ leni ≤ n - max ( xi yi ) + 1 ) — description pair substrings check query a separate line print ` ` yes '' substrings s [ xi ... xi + leni - 1 ] s [ yi ... yi + leni - 1 ] isomorphic ` ` '' otherwise query example follow :,['strings'],2300.0
119/D,let s a string whose length equal n. character number 0 n - 1 i j integers 0 ≤ i < j < n. let 's define function f follow : f ( s i j ) = s [ i + 1 ... j - 1 ] + r ( s [ j ... n - 1 ] ) + r ( s [ 0 ... i ] ) s [ p ... q ] a substring string s start position p end position q ( inclusive ) ; ` ` + '' string concatenation operator ; r ( x ) a string result write character x string reverse order j = i + 1 substring s [ i + 1 ... j - 1 ] consider empty give two string a b. find value i j f ( a i j ) = b. number i maximally possible i exist several valid value j choose minimal j. first two input line non - empty string a b correspondingly string 's length exceed 106 character string contain character ascii cod 32 126 inclusive print two integers i j — answer problem solution exist print ` ` -1 -1 '' ( without quote ),['strings'],2500.0
25/E,sometimes hard prepare test program problems bob prepare test new problem string — input data problem one string bob 3 wrong solutions problem first give wrong answer input data contain substring s1 second enter infinite loop input data contain substring s2 third require much memory input data contain substring s3 bob want solutions fail single test minimal length test could n't pass three bob 's solutions ? exactly 3 line input data i - th line contain string si string non - empty consist lowercase latin letter length string n't exceed 105 . output one number — minimal length string contain s1 s2 s3 substrings,['strings'],2200.0
7/D,string s length n call k - palindrome a palindrome prefix suffix length ( k - 1 ) <unknown> definition string ( even empty ) 0 - palindrome let 's call palindrome degree string s a maximum number k s k - palindrome example ` ` <unknown> '' degree equal 3 . give a string task find sum palindrome degrees prefix first line input data contain a non - empty string consist latin letter digits length string exceed 5·106 string case - sensitive output number — sum <unknown> degrees string 's prefix,['strings'],2200.0
958/A2,<unknown> <unknown> princess heidi get better detect death star time two rebel spy yet give heidi two map possible locations death star since get rid double <unknown> last time know map correct indeed show map solar system contain death star however time empire hide death star well heidi need find a place appear map order detect death star first map n × m grid cell show type cosmic object present correspond <unknown> space second map m × n grid heidi need align two map a way overlap m × m section cosmic object identical help heidi identify m × m section lie within map first line input contain two space - separated integers n m ( 1 ≤ n ≤ 2000 1 ≤ m ≤ 200 m ≤ n ) next n line contain m lower - case latin character ( a - z ) denote first map different character correspond different cosmic object type next m line contain n character describe second map format line output contain two space - separated integers i j denote section size m × m first map start i - th row equal section second map start j - th column row columns number start 1 . several possible ways align map heidi satisfy guarantee a solution exist 5 - <unknown> grid first test case look like :,['strings'],2000.0
1063/A,"a non - empty string call palindrome read leave right right leave example ` ` <unknown> '' ` ` a '' ` ` abba '' palindromes ` ` abab '' ` ` xy '' a string call a substring another string obtain string drop ( possibly zero ) number character begin end example ` ` abc '' ` ` ab '' ` ` c '' substrings string ` ` abc '' ` ` ac '' ` ` d '' let 's define a palindromic count string number substrings palindromes example palindromic count string ` ` aaa '' $$$ 6 $$$ substrings palindromes palindromic count string ` ` abc '' $$$ 3 $$$ substrings length $$$ 1 $$$ palindromes give a string $$$ s $$$ arbitrarily rearrange character goal obtain a string maximum possible value palindromic count first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 100\,000 $$$ ) — length string $$$ s $$$ second line contain string $$$ s $$$ consist exactly $$$ n $$$ lowercase character latin alphabet print string $$$ t $$$ consist set character ( character appear exactly number time ) string $$$ s $$$ moreover $$$ t $$$ maximum possible value palindromic count among string string multiple string print first example string ` ` ololo '' $$$ 9 $$$ palindromic substrings : ` ` o '' ` ` l '' ` ` o '' ` ` l '' ` ` o '' ` ` olo '' ` ` <unknown> '' ` ` olo '' ` ` ololo '' note even though substrings coincide count many time appear result string second example palindromic count string ` ` <unknown> '' $$$ 29 $$$",['strings'],1300.0
1012/D,two string s t consist letter a b. make follow operation several time : choose a prefix s a prefix t swap prefix empty also a prefix coincide a whole string task find a sequence operations one string consist a letter consist b letter number operations minimize first line contain a string s ( 1 ≤ |s| ≤ 2·105 ) second line contain a string t ( 1 ≤ |t| ≤ 2·105 ) |s| |t| denote lengths s t respectively guarantee least one string contain least one a letter least one string contain least one b letter first line contain a single integer n ( 0 ≤ n ≤ 5·105 ) — number operations next n line contain two space - separated integers ai bi — lengths prefix s t swap respectively multiple possible solutions print 's guarantee a solution give constraints exist first example solve problem two operations : second example string already appropriate operations need,['strings'],2800.0
989/B,` ` time '' mino think <unknown> . ` ` ? ` ` ` ` time tide wait man '' explain mino ` ` name take river always remind ` ` ` ` record ? ` ` ` ` see tide everything period i think i ' ve figure one '' say mino <unknown> <unknown> <unknown> <unknown> mino 's record record express a string $$$ s $$$ character ' 0 ' ' 1 ' ' ' ' 0 ' denote a low tide ' 1 ' denote a high tide ' . ' denote unknown one ( either high low ) help mino determine whether 's possible replace ' . ' independently ' 0 ' ' 1 ' a give integer $$$ p $$$ a period result string case answer yes please also show a replacement mino problem a positive integer $$$ p $$$ consider a period string $$$ s $$$ $$$ 1 \leq i \leq \lvert s \rvert - p $$$ $$$ i $$$ -th $$$ ( i + p ) $$$ -th character $$$ s $$$ $$$ \lvert s \rvert $$$ length $$$ s $$$ first line contain two space - separated integers $$$ n $$$ $$$ p $$$ ( $$$ 1 \leq p \leq n \leq 2000 $$$ ) — length give string suppose period respectively second line contain a string $$$ s $$$ $$$ n $$$ character — mino 's record $$$ s $$$ contain character ' 0 ' ' 1 ' ' ' contain least one ' . ' character output one line — 's possible $$$ p $$$ a period result string output one string ; otherwise output ` ` '' ( without quote print letter case ( upper lower ) ) first example $$$ 7 $$$ a period result string $$$ 1 $$$ -st $$$ 8 $$$ -th character different second example $$$ 6 $$$ a period result string $$$ 4 $$$ -th $$$ 10 $$$ -th character different third example $$$ 9 $$$ always a period constraint first last character already satisfy note multiple acceptable answer first two examples print,['strings'],1200.0
518/A,"vitaly a diligent student never miss a lesson five years study university always homework time pass exams time last lesson teacher provide two string s t vitaly string length consist lowercase english letter string s lexicographically smaller string t. vitaly wonder string lexicographically larger string s lexicographically smaller string t. string also consist lowercase english letter length equal lengths string s t. let 's help vitaly solve easy problem ! first line contain string s ( 1 ≤ |s| ≤ 100 ) consist lowercase english letter , |s| denote length string second line contain string t ( |t| = |s| ) consist lowercase english letter guarantee lengths string s t string s lexicographically less string t. string meet give requirements n't exist print a single string ` ` string '' ( without quote ) string exist print multiple valid string may print string s = s1s2 ... sn say lexicographically smaller t = t1t2 ... tn exist i s1 = t1 s2 = t2 ... si - 1 = ti - 1 si < ti",['strings'],1600.0
766/A,mahmoud ehab practice ioi find a problem name longest common subsequence solve ehab challenge mahmoud another problem give two string a b find length longest uncommon subsequence longest string a subsequence one a subsequence a subsequence string a sequence character appear order string <unknown> n't consecutive example string ` ` ac '' ` ` bc '' ` ` abc '' ` ` a '' subsequences string ` ` abc '' string ` ` <unknown> '' ` ` acb '' empty string a subsequence string string a subsequence first line contain string a second line — string b. string non - empty consist lowercase letter english alphabet length string bigger 105 character 's uncommon subsequence print ` ` -1 '' otherwise print length longest uncommon subsequence a b. first example : choose ` ` <unknown> '' string b longest subsequence string b n't appear a subsequence string a,['strings'],1000.0
802/H,thank help heidi confident one <unknown> decide post fake news hc2 <unknown> page however want able communicate hc2 committee post fake use secret phrase hide post a subsequence make method <unknown> want phrase appear n time post ask design a post ( string ) s a hide phrase p p appear s a subsequence exactly n time first line input contain a single integer n ( 1 ≤ n ≤ 1 000 000 ) output contain two nonempty string s p separate a single space string compose letter ( a - z a - z : lowercase uppercase allow ) length 200 . number occurrences p s a subsequence exactly n. many possible solutions output guarantee least one solution exist occurrence p a subsequence s think a set position s letter position order form p. number occurences thus number set example ab appear 6 time a subsequence <unknown> follow set position : { 1 4 } { 1 5 } { 2 4 } { 2 5 } { 3 4 } { 3 5 } ( choose one a 's one b 's ),['strings'],2200.0
110/B,petya love lucky number know lucky number positive integers whose decimal representations contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 petya recently learn determine whether a string lowercase latin letter lucky individual letter position string write increase order result 26 list number ; empty a string consider lucky list absolute difference two adjacent number a lucky number example let 's consider string ` ` <unknown> '' list position equal letter : string lucky <unknown> lucky number letter z : 5 - 1 = 4 9 - 5 = 4 letter c : 10 - 3 = 7 letter d : 8 - 4 = 4 . note letter occur a string n't influence string 's <unknown> build list position equal letter string letter distinct consider lucky find lexicographically minimal lucky string whose length equal n. single line contain a positive integer n ( 1 ≤ n ≤ 105 ) — length seek string print single line lexicographically minimal lucky string whose length equal n. <unknown> comparison string perform < operator modern program languages string a lexicographically less string b exist i ( 1 ≤ i ≤ n ) ai < bi j ( 1 ≤ j < i ) aj = bj,['strings'],1100.0
8/A,peter like travel train like much train fall asleep summer peter go train city a city b usual sleep wake start look <unknown> notice every railway station a flag a particular colour boy start memorize order flag ' colour see soon fell asleep unfortunately n't sleep long wake go memorize colour fell asleep time sleep <unknown> end journey station tell parent write two sequence colour see sleep respectively peter 's parent know son like <unknown> give list flag ' colour station train pass sequentially way a b ask find peter could see sequence way a b b a. remember please peter two periods wakefulness peter 's parent put lowercase latin letter colour letter stand colour different letter — different colour input data contain three line first line contain a non - empty string whose length exceed 105 string consist lowercase latin letter — flag ' colour station way a b. way b a train pass station reverse order second line contain sequence write peter first period wakefulness third line contain sequence write second period wakefulness sequence non - empty consist lowercase latin letter length exceed 100 letter sequence write chronological order output one four word without invert <unknown> : assume train move time one flag see twice flag station a b,['strings'],1200.0
638/B,berland scientists face a important task - give part short dna fragment restore dinosaur dna ! genome a berland dinosaur note common genome ' ve use : 26 distinct nucleotide type a nucleotide type occur assign distinct english letter nucleotides genome a berland dinosaur represent a non - empty string consist small english letter letter occur scientists n genome fragment represent substrings ( non - empty sequence consecutive nucleotides ) seek genome face follow problem : help scientists restore dinosaur genome guarantee input contradictory least one suitable line always exist scientists find a strong programmer ask addition choose one minimum length multiple string choose string first line input contain a positive integer n ( 1 ≤ n ≤ 100 ) — number genome fragment next line contain one descriptions a fragment fragment a non - empty string consist distinct small letter english alphabet guarantee give fragment distinct fragment could arbitrarily overlap one fragment could a substring another one guarantee string distinct letter contain give fragment substrings single line output print genome minimum length contain give part nucleotides genome must distinct multiple suitable string print string minimum length also multiple suitable string print,"['dfs and similar', 'strings']",1500.0
1085/A,polycarp love cipher invent cipher call right - left right - left cipher use string encrypt string $$$ s = s _ { 1 } s _ { 2 } \dots s _ { n } $$$ polycarp use follow algorithm : example $$$ s $$$ = '' techno '' process : ` ` t '' $$$ \to $$$ ` ` <unknown> '' $$$ \to $$$ ` ` <unknown> '' $$$ \to $$$ ` ` <unknown> '' $$$ \to $$$ ` ` <unknown> '' $$$ \to $$$ ` ` ncteho '' encrypt $$$ s $$$ = '' techno '' ` ` ncteho '' give string $$$ t $$$ — result encryption string $$$ s $$$ task <unknown> i.e find string $$$ s $$$ line input contain $$$ t $$$ — result encryption string $$$ s $$$ contain lowercase latin letter length $$$ t $$$ $$$ 1 $$$ $$$ 50 $$$ inclusive print string $$$ s $$$ encryption equal $$$ t $$$,"['implementation', 'strings']",800.0
1073/A,give a string $$$ s $$$ consist $$$ n $$$ lowercase latin letter a substring string $$$ s $$$ a continuous segment letter $$$ s $$$ example ` ` <unknown> '' a substring ` ` codeforces '' ` ` <unknown> '' length substring number letter let 's call string length $$$ n $$$ diverse letter appear strictly $$$ \frac n 2 $$$ time example string ` ` abc '' ` ` <unknown> '' diverse string ` ` aab '' ` ` <unknown> '' task find diverse substring string $$$ s $$$ report none note require maximize minimize length result substring first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — length string $$$ s $$$ second line string $$$ s $$$ consist exactly $$$ n $$$ lowercase latin letter print ` ` '' diverse substring string $$$ s $$$ otherwise first line contain ` ` yes '' second line contain diverse substring string $$$ s $$$ first example lot correct answer please <unknown> ask specific answer correct specific test question always lead ` ` comment '' answer,"['implementation', 'strings']",1000.0
1111/A,know a superhero transform certain superheroes superheroes transform superhero a superhero name $$$ s $$$ transform another superhero name $$$ t $$$ $$$ s $$$ make equal $$$ t $$$ change vowel $$$ s $$$ vowel consonant $$$ s $$$ consonant multiple change make problem consider letter ' a ' ' e ' ' i ' ' o ' ' u ' vowels letter consonants give name two superheroes determine superhero name $$$ s $$$ transform superhero name $$$ t $$$ first line contain string $$$ s $$$ length $$$ 1 $$$ $$$ 1000 $$$ inclusive second line contain string $$$ t $$$ length $$$ 1 $$$ $$$ 1000 $$$ inclusive string $$$ s $$$ $$$ t $$$ guarantee different consist lowercase english letter output ` ` yes '' ( without quote ) superhero name $$$ s $$$ transform superhero name $$$ t $$$ ` ` '' ( without quote ) otherwise print letter case ( upper lower ) first sample since ' a ' ' u ' vowels possible convert string $$$ s $$$ $$$ t $$$ third sample ' k ' a consonant whereas ' a ' a vowel possible convert string $$$ s $$$ $$$ t $$$,"['implementation', 'strings']",1000.0
291/E,a root tree a non - directed connect graph without cycle a distinguish vertex call tree root consider vertices a root tree consist n vertices number 1 n. problem tree root vertex number 1 . let 's represent length shortest number edge path tree vertices v u d ( v u ) a parent vertex v root tree root vertex r ( v ≠ r ) vertex pv d ( r pv ) + 1 = d ( r v ) d ( pv v ) = 1 . example picture parent vertex v = 5 vertex <unknown> = 2 . one day polycarpus come across a root tree consist n vertices tree n't exactly ordinary : string write edge polycarpus position tree plane make edge lead top bottom go vertex parent vertex ( see picture ) edge lead vertex pv vertex v ( 1 < v ≤ n ) know string sv write string write edge top bottom example picture <unknown> '' ba '' character string number start 0 . polycarpus define position tree a specific letter a specific string position write a pair integers ( v x ) mean position x - th letter string sv ( 1 < v ≤ n 0 ≤ x < |sv| ) |sv| length string sv example highlight letter position ( 2 1 ) ( 3 1 ) let 's consider pair position ( v x ) ( u y ) polycarpus ' tree way first position second go step consider pair position define string z. string z consist letter way ( v x ) ( u y ) write order path example picture highlight position define string ` ` <unknown> '' polycarpus a string t want know number pair position define string t. note way first position second pair must go everywhere help challenge tree - string problem ! first line contain integer n ( 2 ≤ n ≤ 105 ) — number vertices polycarpus 's tree next n - 1 line contain tree edge i - th contain number pi + 1 string si + 1 ( 1 ≤ pi + 1 ≤ n ; pi + 1 ≠ ( i + 1 ) ) string si + 1 non - empty consist lowercase english letter last line contain string t. string t consist lowercase english letter length least 2 . guarantee input contain 3·105 english letter print a single integer — require number please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first test case string ` ` aba '' determine pair position : ( 2 0 ) ( 5 0 ) ; ( 5 2 ) ( 6 1 ) ; ( 5 2 ) ( 3 1 ) ; ( 4 0 ) ( 4 2 ) ; ( 4 4 ) ( 4 6 ) ; ( 3 3 ) ( 3 5 ) note string define pair position ( 7 1 ) ( 5 0 ) way n't always go,"['dfs and similar', 'strings']",2000.0
812/E,sagheer play a game best friend soliman bring a tree n nod number 1 n root node 1 . i - th node ai apples tree a special property : lengths paths root leaf parity ( i.e paths even length paths odd length ) sagheer soliman take turn play soliman make first move player ca n't make a move lose move current player pick a single node take a non - empty subset apples one follow two things : soliman come start play sagheer make exactly one change tree pick two different nod u v swap apples u apples v. help sagheer count number ways make swap ( i.e choose u v ) win game players play optimally ? ( u v ) ( v u ) consider pair first line contain one integer n ( 2 ≤ n ≤ 105 ) — number nod apple tree second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 107 ) — number apples node tree third line contain n - 1 integers p2 p3 ... pn ( 1 ≤ pi ≤ n ) — parent node tree node i parent pi ( 2 ≤ i ≤ n ) node 1 root tree guarantee input describe a valid tree lengths paths root leaf parity a single line print number different pair nod ( u v ) u ≠ v start play swap apples nod sagheer win game ( u v ) ( v u ) consider pair first sample sagheer win swap node 1 node 3 . case leave 2 apples soliman make a move a leaf node sagheer make move leaf soliman move apples a root a leaf sagheer eat move apples eventually soliman find a move second sample swap make sagheer win game note sagheer must make swap even win initial tree,['trees'],2300.0
1610/I,many <unknown> try <unknown> decide copy modify <unknown> problem copy new problem : a tree $$$ n $$$ vertices non - empty set vertices pin grind two players play a game tree <unknown> perform follow action : player move lose ( every edge delete already ) give tree set pin vertices task determine $$$ k $$$ winner game vertices $$$ 1 2 3 \ldots k $$$ pin players play optimally first line input contain integer $$$ n $$$ — number vertices ( $$$ 1 \le n \le 300000 $$$ ) $$$ i $$$ -th follow $$$ n-1 $$$ line contain two integers $$$ u_i v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) — endpoints $$$ i $$$ -th edge 's guarantee edge form a tree print a string length $$$ n $$$ $$$ i $$$ -th character ' 1 ' first player win $$$ i $$$ -th scenario ' 2 ' otherwise see tree first sample : $$$ k = 1 $$$ first player cut edge $$$ ( 1 2 ) $$$ $$$ k = 2 $$$ $$$ k = 3 $$$ first player cut edge $$$ ( 2 4 ) $$$ edge $$$ ( 1 2 ) $$$ $$$ ( 2 3 ) $$$ remain second players move a single edge leave first player cut first player win,['trees'],3100.0
1363/C,ayush ashish play a game <unknown> tree consist $$$ n $$$ nod number $$$ 1 $$$ $$$ n $$$ players make follow move turn : a tree a connect undirected graph without cycle a special node number $$$ x $$$ player remove node win game ayush move first determine winner game player play optimally first line input contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10 ) $$$ — number testcases description test case follow first line testcase contain two integers $$$ n $$$ $$$ x $$$ $$$ ( 1\leq n \leq 1000 1 \leq x \leq n ) $$$ — number nod tree special node respectively next $$$ n-1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ $$$ ( 1 \leq u v \leq n \text { } u \ne v ) $$$ mean edge nod $$$ u $$$ $$$ v $$$ tree every test case ayush win game print ` ` ayush '' otherwise print ` ` ashish '' ( without quote ) $$$ 1 $$$ st test case ayush remove node $$$ 2 $$$ $$$ 3 $$$ node $$$ 1 $$$ become a leaf node ashish remove turn $$$ 2 $$$ nd test case ayush remove node $$$ 2 $$$ first move,['trees'],1600.0
1110/G,"<unknown> - <unknown> - <unknown> game start a tree $$$ n $$$ vertices vertices already color white remain uncolored two players — white black players make move alternatively white player start game turn a player must select one uncolored vertex paint color player win paint path three vertices color case vertices color neither player game end a draw could please find win game whether end a draw assume players play optimally ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 50\,000 $$$ ) — number test case descriptions $$$ t $$$ test case follow first line test contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) — number vertices tree follow $$$ n - 1 $$$ line contain integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le n $$$ ) denote edge tree connect vertices $$$ v $$$ $$$ u $$$ last line a test case contain a string letter ' w ' ( white ) ' n ' ( color ) length $$$ n $$$ denote already color vertices vertexes already color white denote ' w ' 's guarantee give edge form a tree least one uncolored vertex path three white vertices 's guarantee sum $$$ n $$$ among test case $$$ 500000 $$$ every test case print either ` ` white '' ` ` draw '' ` ` black '' depend result game first example vertex $$$ 4 $$$ already color white white player win color vertex $$$ 1 $$$ white first remain vertex second turn process illustrate picture second example show player <unknown> victory",['trees'],3100.0
1534/D,"interactive problem little dormi face awkward problem <unknown> : guess edge <unknown> tree $$$ n $$$ nod ! nod tree number $$$ 1 $$$ $$$ n $$$ game master allow ask one type question : additionally make game unfair challenge little dormi game master allow $$$ \lceil\frac { n } { 2 } \rceil $$$ question $$$ \lceil x \rceil $$$ denote smallest integer greater equal $$$ x $$$ face <unknown> - <unknown> <unknown> able guess tree little dormi need help devise a win strategy ! note game master create tree game start change game first line input contain integer $$$ n $$$ ( $$$ 2 \le n \le 2\,000 $$$ ) number nod tree begin interaction program find tree first output a line consist a single ` ` ! '' follow $$$ n-1 $$$ line two space separate integers $$$ a $$$ $$$ b $$$ denote edge connect nod $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le n $$$ ) do terminate program normally immediately flush output stream may output edge order edge $$$ ( a b ) $$$ consider edge $$$ ( b a ) $$$ answer consider a query take input may make $$$ \lceil\frac { n } { 2 } \rceil $$$ query query make format ` ` ? r '' $$$ r $$$ integer $$$ 1 \le r \le n $$$ denote node want pick query receive $$$ n $$$ space separate integers $$$ d_1 d_2 \ldots d_n $$$ $$$ d_i $$$ length shortest path node $$$ r $$$ $$$ i $$$ follow a newline print a query forget output end line flush output otherwise get idleness limit exceed , use : point make invalid query try make $$$ \lceil \frac { n } { 2 } \rceil $$$ query interaction terminate immediately receive a wrong answer verdict hacksto hack a solution use follow format first line contain integer $$$ n $$$ ( $$$ 2 \le n \le 2\,000 $$$ ) next $$$ n−1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) denote edge $$$ u $$$ $$$ v $$$ ( $$$ u \neq v $$$ ) $$$ n-1 $$$ edge must form a tree tree first example notice edge output order additionally answer query every single node example $$$ 1 $$$ : tree second example interaction lastly answer query every single node example $$$ 2 $$$ :",['trees'],1800.0
1761/G,"interactive problem unknown tree consist $$$ n $$$ nod exactly one centroid know $$$ n $$$ first task find centroid tree ask distance two vertices $$$ 2\cdot100000 $$$ time note interactor adaptive , tree fix test beforehand depend query a vertex call a centroid removal split tree subtrees $$$ \lfloor\frac { n } { 2 } \rfloor $$$ vertices line input contain integer $$$ n $$$ ( $$$ <unknown> n\le <unknown> $$$ ) — number nod tree start interaction read $$$ n $$$ ask a query distance two nod $$$ u v $$$ ( $$$ 1 \le u v \le n $$$ ) output ` ` ? u v '' determine centroid tree $$$ x $$$ use ` ` ! x '' report print a query forget output end a line flush output otherwise get idleness limit exceed , use : hack disable problem 's guarantee $$$ 500 $$$ test problem image tree sample",['trees'],3500.0
1438/F,"interactive problem igor want find key olha 's heart problem 's root a binary tree a perfect binary tree height $$$ h $$$ consist $$$ n = 2^ { h } - 1 $$$ nod nod assign distinct label $$$ 1 $$$ $$$ n $$$ however igor know $$$ h $$$ know label correspond node find key olha 's heart need find label assign root make query follow type $$$ n+420 $$$ time : help igor find root ! note : grader adaptive : label fix query make first line contain a single integer $$$ h $$$ ( $$$ 3 \le h \le 18 $$$ ) — height tree begin interaction read $$$ h $$$ make a query label $$$ u v w $$$ a separate line output ` ` ? u v w '' number query satisfy $$$ 1 \le u v w \le n $$$ additionally $$$ u \ne v $$$ $$$ u \ne w $$$ $$$ v \ne w $$$ response receive $$$ 1 \le x \le n $$$ label lowest common ancestor $$$ u $$$ $$$ v $$$ tree root $$$ w $$$ case query invalid ask $$$ n+420 $$$ query program print $$$ -1 $$$ finish interaction receive wrong answer verdict make sure exit immediately avoid get verdicts determine label assign root output ` ` ! r '' $$$ r $$$ label root print a query forget output end line flush output otherwise get idleness limit exceed , use : hack formatto hack use follow format first line contain a single integer $$$ h $$$ ( height binary tree ) next line output a permutation $$$ p $$$ size $$$ n = <unknown> - 1 $$$ represent a binary tree root label $$$ p_1 $$$ $$$ 1 < i \le n $$$ parent $$$ p_i $$$ $$$ p _ { \lfloor { \frac { i } { 2 } } \rfloor } $$$ label correspond tree example [ $$$ 4 $$$ $$$ 7 $$$ $$$ 2 $$$ $$$ 6 $$$ $$$ 1 $$$ $$$ 5 $$$ $$$ 3 $$$ ] mean root label $$$ 4 $$$ $$$ 1 < i \le n $$$ parent $$$ p_i $$$ $$$ p _ { \lfloor { \frac { i } { 2 } } \rfloor } $$$",['trees'],3000.0
1781/G,"problem work root binary tree a tree call a root binary tree a fix root every vertex two children let 's assign a color — white blue — vertex tree call assignment a color tree let 's call a color diverse every vertex a neighbor ( a parent a child ) color opposite color compare vertex show tree least two vertices allow a diverse color let 's define disbalance a color absolute value difference number white vertices number blue vertices problem initially tree consist a single vertex number $$$ 1 $$$ root , $$$ i $$$ $$$ 2 $$$ $$$ n $$$ a new vertex $$$ i $$$ appear tree become a child vertex $$$ p_i $$$ guarantee step tree keep a binary tree root vertex $$$ 1 $$$ , vertex two children every new vertex add print smallest value disbalance possible diverse color current tree moreover add last vertex number $$$ n $$$ also print a diverse color smallest possible disbalance well test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number vertices final tree second line contain $$$ n-1 $$$ integers $$$ p_2 p_3 \ldots p_n $$$ ( $$$ 1 \le p_i \le i - 1 $$$ ) — number parent vertices $$$ 2 3 \ldots n $$$ integer appear twice among $$$ p_2 p_3 \ldots p_n $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print $$$ n-1 $$$ integers — smallest value disbalance possible diverse color tree add vertices $$$ 2 3 \ldots n $$$ print a string $$$ n $$$ character ' w ' ' b ' describe a diverse color smallest possible disbalance whole tree add vertex $$$ n $$$ : $$$ i $$$ -th character must equal ' w ' vertex $$$ i $$$ color white ' b ' 's color blue absolute value difference number ' w ' ' b ' character must equal last print integer vertex must a parent a child color color opposite vertex 's color first test case examples diverse color smallest possible <unknown> intermediate tree illustrate :",['trees'],3200.0
1205/D,give a tree $$$ n $$$ nod write non - negative integers edge follow condition would satisfy : every two nod $$$ i $$$ $$$ j $$$ look path count sum number edge path write obtain sum blackboard every integer $$$ 1 $$$ $$$ \lfloor \frac { <unknown> } { 9 } \rfloor $$$ write blackboard least guarantee arrangement exist first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — number nod next $$$ n-1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ ) mean edge nod $$$ u $$$ $$$ v $$$ guarantee edge form a tree output $$$ n-1 $$$ line form $$$ u $$$ $$$ v $$$ $$$ x $$$ ( $$$ 0 \le x \le 1000000 $$$ ) mean write number $$$ x $$$ edge $$$ u $$$ $$$ v $$$ set edge $$$ ( u v ) $$$ coincide set edge input graph output edge order also output end edge order different order input first example distance nod $$$ 1 $$$ $$$ 2 $$$ equal $$$ 2 $$$ nod $$$ 2 $$$ $$$ 3 $$$ $$$ 1 $$$ $$$ 1 $$$ $$$ 3 $$$ $$$ 3 $$$ third example number $$$ 1 $$$ $$$ 9 $$$ ( inclusive ) write blackboard need $$$ 1 $$$ $$$ 5 $$$ pass test,['trees'],2700.0
1710/D,"rhodoks a tree $$$ n $$$ vertices n't remember structure vertices index $$$ 1 $$$ $$$ n $$$ a segment $$$ [ l r ] $$$ ( $$$ 1 \leq l \leq r \leq n $$$ ) good vertices indices $$$ l $$$ $$$ l + 1 $$$ ... $$$ r $$$ form a connect component rhodoks ' tree otherwise bad example tree one picture segment $$$ [ 3,4 ] $$$ bad segment good $$$ \frac { n ( n+1 ) } { 2 } $$$ segment rhodoks remember whether good bad help recover tree ? multiple solutions print guarantee least one tree satisfy rhodoks ' description test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 2000 $$$ ) — number vertices tree $$$ n $$$ line follow $$$ i $$$ -th line contain a string $$$ good_i $$$ length $$$ n+1 - i $$$ consist 0 1 . segment $$$ [ i <unknown> ] $$$ good $$$ j $$$ -th character $$$ good_i $$$ 1 otherwise $$$ j $$$ -th character $$$ good_i $$$ 0 . guarantee least one tree consistent give data guarantee sum $$$ n $$$ test case exceed $$$ 2000 $$$ test case print $$$ n-1 $$$ line describe tree recover $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ ) denote edge vertices $$$ u_i $$$ $$$ v_i $$$ multiple solutions print first test case explain statement second test case one possible tree follow : third test case one possible tree follow :",['trees'],3400.0
1611/D,"give a root tree consist $$$ n $$$ vertices vertices number $$$ 1 $$$ $$$ n $$$ vertex root a tree a tree a connect undirected graph without cycle a root tree a tree a select vertex call root tree specify array ancestors $$$ b $$$ contain $$$ n $$$ number : $$$ b_i $$$ ancestor vertex number $$$ i $$$ ancestor a vertex $$$ u $$$ a vertex next vertex a simple path $$$ u $$$ root example simple path $$$ 5 $$$ $$$ 3 $$$ ( root ) next vertex would $$$ 1 $$$ ancestor $$$ 5 $$$ $$$ 1 $$$ root ancestor , value $$$ b_i $$$ $$$ i $$$ ( root vertex $$$ b_i = i $$$ ) example $$$ <unknown> $$$ $$$ b= [ 3 1 3 3 1 ] $$$ tree look like give array $$$ p $$$ — a permutation vertices tree possible assign positive integer weight edge vertices sort distance root would form give permutation $$$ p $$$ word a give permutation vertices $$$ p $$$ necessary choose edge weight condition $$$ dist [ p_i ] < dist [ p _ { i+1 } ] $$$ true $$$ i $$$ $$$ 1 $$$ $$$ n-1 $$$ $$$ dist [ u ] $$$ a sum weight edge path root $$$ u $$$ particular $$$ dist [ u ] = 0 $$$ vertex $$$ u $$$ root tree example assume $$$ p= [ 3 1 2 5 4 ] $$$ case follow edge weight satisfy permutation : array distance root look like : $$$ <unknown> [ <unknown> ] $$$ vertices sort increase distance root form give permutation $$$ p $$$ print require edge weight determine suitable way assign weight several solutions print first line input data contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number input data set test test case consist three line first contain integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) number vertices tree second line contain $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ 1 \le b_i \le n $$$ ) guarantee $$$ b $$$ array encode root tree third line contain give permutation $$$ p $$$ : $$$ n $$$ different integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) guarantee sum value $$$ n $$$ test case test exceed $$$ 200000 $$$ set input data print answer a separate line solution exist print array $$$ n $$$ integers $$$ w_1 w_2 \dots <unknown> $$$ $$$ w_i $$$ weight edge lead $$$ b_i $$$ $$$ i $$$ root edge use value $$$ <unknown> $$$ vertices value $$$ w_i $$$ must satisfy inequality $$$ 1 \le w_i \le 1000000000 $$$ equal number among $$$ w_i $$$ value sum weight edge root vertices must different satisfy give permutation several solutions output solution exist output -1 . first set input data example analyze main part statement second set input data example impossible assign positive weight obtain a give permutation vertices",['trees'],1500.0
1583/B,lord omkar would like a tree $$$ n $$$ nod ( $$$ 3 \le n \le 100000 $$$ ) ask <unknown> construct tree however lord omkar create $$$ m $$$ ( $$$ \mathbf { 1 \le m < n } $$$ ) restrictions ensure tree heavenly possible a tree $$$ n $$$ nod connect undirected graph $$$ n $$$ nod $$$ n-1 $$$ edge note two nod exactly one simple path a simple path a path two nod contain node example a tree : a restriction consist $$$ 3 $$$ pairwise distinct integers $$$ a $$$ $$$ b $$$ $$$ c $$$ ( $$$ 1 \le a b c \le n $$$ ) signify node $$$ b $$$ lie simple path node $$$ a $$$ node $$$ c $$$ help lord omkar become trust <unknown> ? need find heavenly tree multiple set restrictions show a heavenly tree always exist set restrictions give constraints test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 3 \leq n \leq 100000 $$$ $$$ \mathbf { 1 \leq m < n } $$$ ) represent size tree number restrictions $$$ i $$$ -th next $$$ m $$$ line contain three integers $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ ( $$$ 1 \le a_i b_i c_i \le n $$$ $$$ a $$$ $$$ b $$$ $$$ c $$$ distinct ) signify node $$$ b_i $$$ lie simple path nod $$$ a_i $$$ $$$ c_i $$$ guarantee sum $$$ n $$$ across test case exceed $$$ 100000 $$$ test case output $$$ n-1 $$$ line represent $$$ n-1 $$$ edge tree line output two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ ) signify edge nod $$$ u $$$ $$$ v $$$ give edge form a tree satisfy omkar 's restrictions output first sample case correspond follow tree : output second sample case correspond follow tree :,['trees'],1200.0
1252/F,a forestation act plant a bunch tree grow a forest usually replace a forest cut <unknown> enough graph theorists another idea make a forest i.e cut a tree ! a tree a graph $$$ n $$$ nod connect $$$ n - 1 $$$ edge let $$$ u $$$ a node a tree $$$ u $$$ degree least $$$ 2 $$$ ( i.e directly connect least $$$ 2 $$$ nod $$$ u $$$ ) remove $$$ u $$$ $$$ u $$$ get two disconnect ( smaller ) tree also know forest graph theorists problem go investigate a special forestation a tree do graph theorists let $$$ v ( s ) $$$ set nod a tree $$$ s $$$ $$$ v ( t ) $$$ set nod a tree $$$ t $$$ tree $$$ s $$$ tree $$$ t $$$ identical exist a bijection $$$ f : v ( s ) \rightarrow v ( t ) $$$ pair nod $$$ ( s_i s_j ) $$$ $$$ v ( s ) $$$ $$$ s_i $$$ $$$ s_j $$$ connect edge $$$ s $$$ node $$$ f ( s_i ) $$$ $$$ f ( s_j ) $$$ connect edge $$$ t $$$ note $$$ f ( s ) = t $$$ imply node $$$ s $$$ $$$ s $$$ correspond node $$$ t $$$ $$$ t $$$ call a node $$$ u $$$ a tree $$$ u $$$ a good cut point removal $$$ u $$$ $$$ u $$$ cause two disconnect tree disconnect tree pairwise identical give a tree $$$ u $$$ task determine whether exist a good cut point $$$ u $$$ a node output maximum number disconnect tree obtain remove exactly one good cut point example consider follow tree $$$ 13 $$$ nod exactly one good cut point tree i.e node $$$ 4 $$$ observe remove node $$$ 4 $$$ get three identical tree ( case line graph ) i.e $$$ \ { 5 1 7 13\ } $$$ $$$ \ { 8 2 11 6\ } $$$ $$$ \ { 3 12 9 <unknown> } $$$ denote $$$ a $$$ $$$ b $$$ $$$ c $$$ respectively figure input begin a line <unknown> integer : $$$ n $$$ ( $$$ 3 \le n \le 4000 $$$ ) represent number nod give tree next $$$ n - 1 $$$ line contain two integers : $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i < b_i \le n $$$ ) represent edge $$$ ( a_i b_i ) $$$ give tree guarantee two nod give tree connect a sequence edge output a line integer represent maximum number disconnect tree obtain remove exactly one good cut point output -1 good cut point explanation sample input / output # 1this example problem description,['trees'],2400.0
690/F2,heidi get tire decipher <unknown> hide tree life decide go back headquarter rest a little try course <unknown> tree take make a draw tree a piece paper second think make identical draw n total ( n number vertices tree life ) – know might happen ? indeed way back heidi <unknown> a group zombies manage <unknown> damage draw a peculiar way : i - th copy vertex number i remove along adjacent edge picture zombies also erase vertex number <unknown> remain n - 1 vertices arbitrarily use number 1 n ( fortunately vertex still a distinct number ) 's draw arbitrarily <unknown> / <unknown> heidi want recover tree life descriptions draw ( list edge ) first line input contain z ≤ 20 – number test case z descriptions single test case follow test case first line input contain number n ( 2 ≤ n ≤ 100 ) k ( k number draw ; k = n ) follow line descriptions k draw give description i - th draw a line contain mi – number edge draw follow mi line describe edge contain two space - separated integers – - number two vertices connect edge heidi 's draw possibly come a single tree output word otherwise output one line contain word yes n - 1 line describe tree heidi 's draw could come every edge output number vertices connect separate a single space many solutions print,['trees'],2700.0
855/D,"harry upon <unknown> <unknown> ravenclaw 's <unknown> come know tell <unknown> riddle <unknown> - know - <unknown> <unknown> ravenclaw 's diadem steal harry think riddle would assume one discover room requirement thus would hide harry try get inside room requirement destroy diadem know a horcrux answer a puzzle order enter room give n object number 1 n. object a parent object a lesser number formally object i may a parent object parenti parenti < i. also a type associate parent relation either type 1 type 2 . type 1 relation mean child object like a special case parent object type 2 relation mean second object always a part first object special case note object b a special case object a c a special case object b c consider a special case object a well hold part : object b a part a object c a part b say object c a part a. also note object b a part a object c a special case a b a part c well object consider neither a part a special case , harry answer two type query : first line input contain number n ( 1 ≤ n ≤ 105 ) number object next n line contain two integer parenti typei ( - 1 ≤ parenti < i parenti ≠ 0 - 1 ≤ typei ≤ 1 ) imply i - th object parent parenti ( typei = 0 imply object i a special case object parenti typei = 1 imply object i a part object parenti ) case i - th object parent parenti typei -1 . next line contain integer q ( 1 ≤ q ≤ 105 ) number query next q line represent a query three space separate integers typei ui vi ( 1 ≤ typei ≤ 2 1 ≤ u v ≤ n ) output contain q line contain answer correspond query ` ` yes '' ( <unknown> ) ` ` '' ( without quote ) output letter case ( upper lower ) test case 1 object 2 a special case object 1 object 3 a special case object 2 make object 3 a special case object 1 . test case 2 object 2 a special case object 1 object 1 object 3 mean object 2 also object 3 . a general case ( object 1 ) object 3 special case ( object 2 ) definitely object 3",['trees'],2500.0
840/E,<unknown> get a tree consist n vertices a root vertex number 1 . vertex i write integer ai get answer q query form u v. answer query maximal value among vertices i path u v include u v dist ( i v ) number edge path i v. also guarantee vertex u ancestor vertex v. leha 's taste <unknown> : believe vertex ancestor help leha get expression mean bitwise exclusive number x y. note vertex u ancestor vertex v vertex u lie path root vertex v. first line input data contain two integers n q ( 1 ≤ n ≤ 5·104 1 ≤ q ≤ <unknown> 000 ) — number vertices tree number query respectively next line contain n integers a1 a2 ... ( 0 ≤ ai ≤ n ) — number vertices next n - 1 line contain two integers u v ( 1 ≤ u v ≤ n ) — description edge tree guarantee give graph a tree next q line contain two integers u v ( 1 ≤ u v ≤ n ) — description query guarantee vertex u ancestor vertex v. output q line — answer a query,['trees'],3200.0
690/F3,add <unknown> <unknown> zombies take two draw heidi ! please help recover tree life two draw input format medium version except bind n 2 ≤ n ≤ 1000 k = 2 . medium version,['trees'],3200.0
690/C3,break news zombie <unknown> ! turn – <unknown> previous <unknown> – every zombie bear a single brain later evolve a complicate brain structure fact whenever a zombie consume a brain a new brain appear nervous system get immediately connect one already exist brain use a single brain <unknown> <unknown> interest <unknown> brain latency a zombie task write a program give a history evolution a zombie 's nervous system compute brain latency every stage first line input contain one number n – number brain final nervous system ( 2 ≤ n ≤ 200000 ) second line a history zombie 's nervous system evolution give convenience number brain 1 2 ... n order appear nervous system ( zombie bear a single brain number 1 <unknown> brain 2 3 ... n add ) second line contain n - 1 space - separated number p2 p3 ... pn mean a new brain k add system get connect a parent - brain output n - 1 space - separated number – brain <unknown> brain number k add k = 2 3 ... n,['trees'],2200.0
277/E,"a root tree a direct acyclic graph contain one node ( root ) exactly one path node a root tree binary node two outgo arc a binary tree paint plane arc direct top bottom , arc go u v must meet condition <unknown> > <unknown> ' ve give coordinate tree nod task connect nod arc get binary root tree make total length arc minimum arc build tree must direct top bottom first line contain a single integer n ( 2 ≤ n ≤ 400 ) — number nod tree follow n line two integers per line : xi yi ( |xi| |yi| ≤ 103 ) — coordinate nod guarantee point distinct impossible build a binary root tree give point print ` ` -1 '' otherwise print a single real number — total length arc minimum binary tree answer consider correct absolute relative error n't exceed 10 - 6",['trees'],2400.0
1188/A1,note first problem two similar problems hack problem solve problems give a tree $$$ n $$$ nod begin $$$ 0 $$$ write edge one operation choose $$$ 2 $$$ distinct leave $$$ u $$$ $$$ v $$$ real number $$$ x $$$ add $$$ x $$$ value write edge simple path $$$ u $$$ $$$ v $$$ example picture see result apply two operations graph : add $$$ 2 $$$ path $$$ 7 $$$ $$$ 6 $$$ add $$$ <unknown> $$$ path $$$ 4 $$$ $$$ 5 $$$ true configuration real number write edge achieve a finite number operations ? leaf a node a tree degree $$$ 1 $$$ simple path a path n't contain node twice first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — number nod next $$$ n-1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ ) mean edge nod $$$ u $$$ $$$ v $$$ guarantee edge form a tree a configuration real number write edge tree ca n't achieve perform operations output ` ` '' otherwise output ` ` yes '' print letter case ( upper lower ) first example add real $$$ x $$$ value write edge $$$ ( 1 2 ) $$$ second example one configurations ca n't reach $$$ 0 $$$ write $$$ ( 1 2 ) $$$ $$$ 1 $$$ write $$$ ( 2 3 ) $$$ see graph examples $$$ 3 $$$ $$$ 4 $$$ :,['trees'],1600.0
1053/E,euler a little <unknown> squirrel <unknown> come collect reserve winter interest fact euler like collect acorns a specific way a tree describe $$$ n $$$ acorns connect $$$ n - 1 $$$ branch exactly one way pair acorns let 's enumerate acorns $$$ 1 $$$ $$$ n $$$ squirrel choose one acorn ( necessary number $$$ 1 $$$ ) a start visit a way call ` ` euler tour '' ( see note ) collect acorn visit last time today morning kate observe euler take a sheet paper write consecutive indices acorns path unfortunately way home start rain number become illegible girl sad present <unknown> teacher ` ` maybe i guess <unknown> number i 'll able ! '' think help restore valid euler tour tree tell must make a mistake first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 500000 $$$ ) denote number acorns tree second line contain $$$ 2n - 1 $$$ integers $$$ a_1 a_2 \ldots a _ { 2n-1 } $$$ ( $$$ 0 \leq a_i \leq n $$$ ) — euler tour tree kate write $$$ 0 $$$ mean illegible number guess euler tour satisfy give description output ` ` '' first line otherwise first line output ` ` yes '' second line print euler tour satisfy give description valid euler tour accept since teacher n't know exactly initial tree look euler tour a tree $$$ n $$$ acorns a sequence $$$ 2n - 1 $$$ indices acorns acorn occur least first last acorns two consecutive acorns directly connect a branch,['trees'],3500.0
959/C,mahmoud try solve vertex cover problem tree problem statement : give undirected tree consist n nod find minimum number vertices cover edge formally need find a set vertices edge ( u v ) belong tree either u set v set set mahmoud find follow algorithm : depth a node a tree number edge shortest path node root depth root 0 . ehab tell mahmoud algorithm wrong n't believe test algorithm many tree work ehab ask find 2 tree consist n nod algorithm find incorrect answer first tree a correct answer second one line contain integer n ( 2 ≤ n ≤ 105 ) number nod desire tree output consist 2 independent section contain a tree algorithm find incorrect answer tree first section a correct answer tree second a tree n't exist section output ` ` -1 '' ( without quote ) section answer a section exist contain n - 1 line contain 2 space - separated integers u v ( 1 ≤ u v ≤ n ) mean 's undirected edge node u node v. give graph n't a tree n't follow format 'll receive wrong answer verdict multiple answer print first sample 1 tree 2 nod ( node 1 connect node 2 ) algorithm produce a correct answer print - 1 first section notice print tree second section second sample : first tree algorithm find answer 4 nod exist answer 3 nod like : second tree algorithm find answer 3 nod correct :,['trees'],1500.0
901/A,"sasha take part a program competition one problems check root tree isomorphic never see problem , experience participant guess match tree sequence compare sequence instead tree sasha want match tree a sequence a0 a1 ... ah h height tree ai equal number vertices distance i edge root unfortunately time sasha 's intuition wrong could several tree match sequence show need write a program give sequence ai build two non - isomorphic root tree match sequence determine one tree two root tree isomorphic <unknown> vertices first one a way index root become equal index root second tree two tree become equal height a root tree maximum number edge a path root vertex first line contain a single integer h ( 2 ≤ h ≤ 105 ) — height tree second line contain h + 1 integers — sequence a0 a1 ... ah ( 1 ≤ ai ≤ 2·105 ) sum ai exceed 2·105 guarantee least one tree match sequence one tree match sequence print ` ` perfect '' otherwise print ` ` ambiguous '' first line second third line print descriptions two tree follow format : one line print integers k - th parent vertex k equal zero k - th vertex root <unknown> non - isomorphic match give sequence tree first example two print tree second example show picture :",['trees'],1500.0
573/C,limak a little bear learn draw people usually start house fence flower would bear ? limak live forest decide draw a tree recall tree a connect graph consist n vertices n - 1 edge limak choose a tree n vertices infinite strip paper two parallel row dot little bear want assign vertices a tree n distinct dot a paper edge would intersect endpoints — draw tree must <unknown> see one correct draw first sample test possible limak draw choose tree ? first line contain single integer n ( 1 ≤ n ≤ 105 ) next n - 1 line contain description a tree i - th contain two space - separated integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) denote edge vertices ai bi 's guarantee give description form a tree print ` ` yes '' ( without quote ) limak draw choose tree otherwise print ` ` '' ( without quote ),"['dfs and similar', 'trees']",2300.0
1085/D,give a tree ( undirected connect graph without cycle ) integer $$$ s $$$ vanya want put weight edge tree weight non - negative real number sum $$$ s $$$ time want make diameter tree small possible let 's define diameter a weigh tree maximum sum weight edge lie path two vertices tree word diameter a weigh tree length longest simple path tree length a path equal sum weight edge path find minimum possible diameter vanya get first line contain two integer number $$$ n $$$ $$$ s $$$ ( $$$ 2 \leq n \leq 100000 $$$ $$$ 1 \leq s \leq 1000000000 $$$ ) — number vertices tree sum edge weight follow $$$ n−1 $$$ line contain two space - separated integer number $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a_i b_i \leq n $$$ $$$ a_i \neq b_i $$$ ) — index vertices connect edge edge undirected guarantee give edge form a tree print minimum diameter tree vanya get place non - negative real weight edge sum equal $$$ s $$$ answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer consider correct $$$ \frac { |a - b| } { max ( 1 b ) } \leq 10^ { -6 } $$$ first example necessary put weight like : easy see diameter tree $$$ 2 $$$ prove minimum possible diameter second example necessary put weight like :,"['implementation', 'trees']",1700.0
29/D,connect undirected graph without cycle call a tree tree a class graph interest people <unknown> ant stand root tree see n vertexes tree connect n - 1 edge a path pair vertexes a leaf a distinct root vertex connect exactly one vertex ant want visit every vertex tree return root pass every edge twice addition want visit leave a specific order find possible route ant first line contain integer n ( 3 ≤ n ≤ 300 ) — amount vertexes tree next n - 1 line describe edge edge describe two integers — index vertexes connect edge pass direction vertexes number start 1 . root tree number 1 . last line contain k integers k amount leave tree number describe order leave visit guarantee leaf appear order exactly require route n't exist output -1 . otherwise output 2n - 1 number describe route every time ant come a vertex output 's index,"['dfs and similar', 'trees']",2000.0
429/A,iahub proud recent discovery propagate tree right invent a new tree call xor - tree new revolutionary discovery invent a game kid use xor - <unknown> game play a tree n nod number 1 n. node i initial value initi either 0 1 . root tree node 1 . one perform several ( possibly zero ) operations tree game available type operation pick a node x. right someone pick node x value node x flip value sons x remain value sons sons x flip value sons sons sons x remain goal game get node i value goali also 0 1 . need reach goal game use minimum number operations first line contain integer n ( 1 ≤ n ≤ 105 ) next n - 1 line contain two integers ui vi ( 1 ≤ ui vi ≤ n ; ui ≠ vi ) mean edge nod ui vi next line contain n integer number i - th correspond initi ( initi either 0 1 ) follow line also contain n integer number i - th number correspond goali ( goali either 0 1 ) first line output integer number cnt represent minimal number operations perform next cnt line contain integer xi represent pick a node xi,"['dfs and similar', 'trees']",1300.0
916/D,i finish many assignments ? ? ? jamie get busy school life start forget assignments decide write things a to - do list assign a value priority assignment ( lower value mean important ) decide need spend time a days jamie find list large ca n't even manage list ! a good friend jamie help write a program support follow operations to - do list : day 0 to - do list empty follow q days jamie exactly one four operations operation a query output result query proceed next day poor jamie make appropriate decisions first line consist a single integer q ( 1 ≤ q ≤ 105 ) — number operations follow q line consist description operations i - th line consist operation jamie do i - th day query follow format : first word line indicate type operation must one follow four : set remove query <unknown> assignment name ai consist lowercase english letter a length 1 ≤ |ai| ≤ 15 . guarantee last operation a query operation query operation output a single integer — number assignments a priority lower assignment ai - 1 ai to - do list operation a query output result query flush output stream proceed next operation otherwise may get verdict idleness limit exceed flush output stream please refer documentation choose program language flush function common program languages list :,"['data structures', 'trees']",2200.0
1129/E,"interactive problem a legendary tree rest deep forest legend <unknown> realize tree would <unknown> become a legendary <unknown> help determine tree mikaela goddess reveal tree contain $$$ n $$$ vertices enumerate $$$ 1 $$$ $$$ n $$$ also allow ask question follow question tell mikaela two disjoint non - empty set vertices $$$ s $$$ $$$ t $$$ along vertex $$$ v $$$ like , mikaela count give number pair vertices $$$ ( s t ) $$$ $$$ s \in s $$$ $$$ t \in t $$$ simple path $$$ s $$$ $$$ t $$$ contain $$$ v $$$ mikaela goddess busy available answer $$$ <unknown> $$$ question chance task determine tree report edge first line contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 500 $$$ ) — number vertices tree program realize tree ready report edge print ` ` answer '' a separate line make sure letter <unknown> , print $$$ n-1 $$$ line contain two space - separated integers denote vertices endpoints a certain edge edge report exactly program immediately terminate question wish ask interact follow remind $$$ s $$$ $$$ t $$$ must disjoint non - empty print a query forget output end line flush output otherwise get idleness limit exceed , use : program ask many question ask invalid question correctly follow interaction <unknown> may receive arbitrary verdict otherwise program receive wrong answer verdict report incorrect tree note tree fix beforehand depend query <unknown> format follow first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 500 $$$ ) — number vertices tree follow $$$ n-1 $$$ line contain two space - separated integers $$$ u $$$ $$$ v $$$ denote existence undirected edge $$$ ( u v ) $$$ ( $$$ 1 \leq u v \leq n $$$ ) sample tree follow $$$ n = 5 $$$ give program program ask mikaela a question $$$ s = \ { 1 2 3\ } $$$ $$$ t = \ { 4 5\ } $$$ $$$ v = 2 $$$ reply $$$ 5 $$$ ( pair $$$ ( s t ) $$$ $$$ ( 1 4 ) $$$ $$$ ( 1 5 ) $$$ $$$ ( 2 4 ) $$$ $$$ ( 2 5 ) $$$ $$$ ( 3 5 ) $$$ )","['binary search', 'trees']",3100.0
1311/E,give two integers $$$ n $$$ $$$ d $$$ need construct a root binary tree consist $$$ n $$$ vertices a root vertex $$$ 1 $$$ sum depths vertices equal $$$ d $$$ a tree a connect graph without cycle a root tree a special vertex call root a parent a vertex $$$ v $$$ last different $$$ v $$$ vertex path root vertex $$$ v $$$ depth vertex $$$ v $$$ length path root vertex $$$ v $$$ children vertex $$$ v $$$ vertices $$$ v $$$ parent binary tree a tree vertex $$$ 2 $$$ children answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case line test case contain two integers $$$ n $$$ $$$ d $$$ ( $$$ 2 \le n d \le 5000 $$$ ) — number vertices tree require sum depths vertices guarantee sum $$$ n $$$ sum $$$ d $$$ exceed $$$ 5000 $$$ ( $$$ \sum n \le 5000 \sum d \le 5000 $$$ ) test case print answer impossible construct a tree print ` ` '' ( without quote ) first line otherwise print ` ` { yes } '' first line print $$$ n-1 $$$ integers $$$ p_2 p_3 \dots p_n $$$ second line $$$ p_i $$$ parent vertex $$$ i $$$ note sequence parent print describe binary tree picture correspond first second test case example :,"['brute force', 'trees']",2200.0
859/D,"annual college <unknown> - ball tournament approach <unknown> reason 'll refer third month <unknown> a total 2n team participate tournament number 1 2n tournament last n round round eliminate half team first round consist 2n - 1 game number start 1 . game i team 2·i - 1 play team 2·i loser eliminate winner advance next round ( tie ) subsequent round half many game previous round game i winner previous round 's game 2·i - 1 play winner previous round 's game 2·i every year office a <unknown> see create best bracket a bracket a set winner predictions every game game first round may predict either team win game later round winner predict must also predict a winner previous round note bracket fully construct game actually play correct predictions first round worth 1 point correct predictions subsequent round worth twice many point previous correct predictions final game worth 2n - 1 point every pair team league estimate probability team win play want construct a bracket maximum possible expect score input begin a line contain n ( 2 ≤ n ≤ 6 ) <unknown> line follow 2n integers j - th column i - th row indicate percentage chance team i defeat team j unless i = j case value 0 . guarantee i - th column j - th row plus j - th column i - th row add exactly 100 . print maximum possible expect score possible bracket answer must correct within absolute relative error 10 - 9 . formally let answer a jury 's answer b. answer consider correct , first example predict team 1 4 win round 1 team 1 win round 2 . recall winner predict round 2 must also predict a winner round 1","['dp', 'trees']",2100.0
916/E,surprise jamie final boss ! <unknown> jamie give a tree n vertices number 1 n. initially root tree vertex number 1 . also vertex a value jamie also give three type query <unknown> v — change tree 's root vertex number <unknown> u v x — vertex subtree smallest size contain u v add x <unknown> v — find sum value vertices subtree vertex number v. a subtree vertex v a set vertices v lie shortest path vertex root tree pay attention subtree a vertex change change tree 's root show strength program jamie perform query <unknown> ! first line input contain two space - separated integers n q ( 1 ≤ n ≤ 105 1 ≤ q ≤ 105 ) — number vertices tree number query process respectively second line contain n space - separated integers a1 a2 ... ( - 108 ≤ ai ≤ 108 ) — initial value vertices next n - 1 line contain two space - separated integers ui vi ( 1 ≤ ui vi ≤ n ) describe edge vertices ui vi tree follow q line describe query query one follow format depend <unknown> v ( 1 ≤ v ≤ n ) query first <unknown> u v x ( 1 ≤ u v ≤ n - 108 ≤ x ≤ 108 ) query second <unknown> v ( 1 ≤ v ≤ n ) query third type number query ' descriptions integers query must carry give order guarantee tree valid query third type output require answer guarantee least one query third type give jamie follow picture show tree vary query first sample,"['data structures', 'trees']",2400.0
981/C,<unknown> know a lot problems involve tree ( undirected connect graph without cycle ) ! create a new useful tree decomposition know construct ask help ! decomposition split edge tree simple paths a way two paths least one common vertex edge tree exactly one path help <unknown> find a decomposition tree <unknown> decomposition first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 10^ { 5 } $$$ ) number nod tree next $$$ n - 1 $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a_i b_i \leq n $$$ $$$ a_i \neq b_i $$$ ) — edge tree guarantee give edge form a tree decompositions print line contain ` ` '' otherwise first line print ` ` yes '' second line print number paths decomposition $$$ m $$$ next $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ u_i \neq v_i $$$ ) denote one paths decomposition simple path nod $$$ u_i $$$ $$$ v_i $$$ pair paths decomposition least one common vertex edge tree present exactly one path print paths end path arbitrary order multiple decompositions print tree first example show picture : number next edge correspond path number decomposition easy see decomposition suit require condition tree second example show picture : show valid decompositions tree tree third example show picture : number next edge correspond path number decomposition easy see decomposition suit require condition,"['implementation', 'trees']",1400.0
566/E,archaeologists find information ancient land treeland know sure treeland consist n cities connect n - 1 road get city one along roads however information specific design roads treeland lose thing archaeologists use preserve information near cities two cities treeland call near possible move one city one move two roads also a city consider near recent excavations archaeologists find a set n note represent a list cities near n cities country however unfortunately none find record let understand order cities go list city list near cities list help archaeologists restore variant map treeland meet find information first line contain integer n ( 2 ≤ n ≤ 1000 ) — number cities country next n line describe find list near cities list start number k ( 1 ≤ k ≤ n ) represent number cities list follow k city number number list distinct guarantee give information determine least one possible road map print n - 1 pair number represent roads country i - th line must contain two integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) show a road cities ai bi answer print must satisfy description close cities input may print roads countries order cities connect a road may also print order multiple good answer may print,"['bitmasks', 'trees']",3200.0
1143/C,give a root tree vertices numerate $$$ 1 $$$ $$$ n $$$ a tree a connect graph without cycle a root tree a special vertex name root ancestors vertex $$$ i $$$ vertices path root vertex $$$ i $$$ except vertex $$$ i $$$ parent vertex $$$ i $$$ nearest vertex $$$ i $$$ ancestor $$$ i $$$ vertex a child parent give tree parent vertex $$$ i $$$ vertex $$$ p_i $$$ root value $$$ p_i $$$ $$$ -1 $$$ notice vertices respect others particular $$$ c_i = 1 $$$ vertex $$$ i $$$ respect ancestors $$$ c_i = 0 $$$ respect decide delete vertices tree one one step select a non - root vertex respect parent none children respect several vertices select one smallest number delete vertex $$$ v $$$ children $$$ v $$$ become connect parent $$$ v $$$ vertices match criteria deletion stop process print order delete vertices note order unique first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number vertices tree next $$$ n $$$ line describe tree : $$$ i $$$ -th line contain two integers $$$ p_i $$$ $$$ c_i $$$ ( $$$ 1 \le p_i \le n $$$ $$$ 0 \le c_i \le 1 $$$ ) $$$ p_i $$$ parent vertex $$$ i $$$ $$$ c_i = 0 $$$ vertex $$$ i $$$ respect parent $$$ c_i = 1 $$$ vertex $$$ i $$$ respect parent root tree $$$ -1 $$$ instead parent index also $$$ <unknown> $$$ root guarantee value $$$ p_i $$$ define a root tree $$$ n $$$ vertices case least one vertex delete print line contain indices vertices delete order delete otherwise print a single integer $$$ -1 $$$ deletion process first example follow ( see picture vertices $$$ <unknown> $$$ yellow ) : second example n't need delete vertex : third example tree change way :,"['dfs and similar', 'trees']",1400.0
1057/A,upon a time one router well - known company <unknown> years go time new routers purchase every time buy a new router connect one routers buy give value $$$ p_i $$$ — index router $$$ i $$$ -th router connect purchase ( $$$ p_i < i $$$ ) $$$ n $$$ routers <unknown> total print sequence routers path first $$$ n $$$ -th router first line contain integer number $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number routers follow line contain $$$ n-1 $$$ integers $$$ p_2 p_3 \dots p_n $$$ ( $$$ 1 \le p_i < i $$$ ) $$$ p_i $$$ equal index router $$$ i $$$ -th connect purchase print path $$$ 1 $$$ -st $$$ n $$$ -th router start $$$ 1 $$$ end $$$ n $$$ elements path distinct,"['dfs and similar', 'trees']",900.0
1044/B,"play a strange game li chen a tree $$$ n $$$ nod draw a piece paper nod <unknown> <unknown> independently label vertices $$$ 1 $$$ $$$ n $$$ neither know 's label tree li chen choose a subtree ( i.e. a connect subgraph ) tree subtree consist vertices label $$$ x_1 x_2 \ldots x _ { k_1 } $$$ label li chen 's subtree consist vertices label $$$ y_1 y_2 \ldots y _ { k_2 } $$$ label value $$$ x_1 x_2 \ldots x _ { k_1 } $$$ $$$ y_1 y_2 \ldots y _ { k_2 } $$$ know want determine whether subtrees least one common vertex luckily friend andrew know label tree ask andrew $$$ 5 $$$ question one follow two form : determine whether two subtrees least one common vertex ask question least one common vertex determine one label common vertices test consist several test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case testcase program interact follow format first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1\,000 $$$ ) — number nod tree next $$$ n-1 $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1\leq a_i b_i\leq n $$$ ) — edge tree indicate edge node $$$ a_i $$$ $$$ b_i $$$ accord label nod next line contain a single integer $$$ k_1 $$$ ( $$$ 1 \leq k_1 \leq n $$$ ) — number nod subtree next line contain $$$ k_1 $$$ distinct integers $$$ x_1 x_2 \ldots x _ { k_1 } $$$ ( $$$ 1 \leq x_i \leq n $$$ ) — indices nod subtree accord label guarantee vertices form a subtree next line contain a single integer $$$ k_2 $$$ ( $$$ 1 \leq k_2 \leq n $$$ ) — number nod li chen 's subtree next line contain $$$ k_2 $$$ distinct integers $$$ y_1 y_2 \ldots y _ { k_2 } $$$ ( $$$ 1 \leq y_i \leq n $$$ ) — indices ( accord li chen 's label ) nod li chen 's subtree guarantee vertices form a subtree accord li chen 's label tree 's nod test case provide one one must complete interact previous test ( i.e print a common node $$$ -1 $$$ node ) start receive next one ask andrew two different type question may ask $$$ 5 $$$ question per tree ready answer print ` ` c s '' $$$ s $$$ label a vertex common subtrees $$$ -1 $$$ vertex exist print answer count a question remember flush answer start receive next test case print a question forget print end line flush output otherwise get idleness limit exceed , use : judge respond $$$ -1 $$$ mean ask query allow ask invalid query program immediately terminate ( example call exit ( 0 ) ) receive wrong answer ; mean ask query allow ask invalid query ignore get verdicts since program continue read a close stream hack formatto hack use follow format note hack one test case first line contain a single integer $$$ t $$$ ( $$$ t=1 $$$ ) second line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1\,000 $$$ ) third line contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1\leq <unknown> n $$$ ) — a permutation $$$ 1 $$$ $$$ n $$$ encode label li chen choose tree particular li chen choose label $$$ p_i $$$ node label $$$ i $$$ next $$$ n-1 $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1\leq a_i b_i\leq n $$$ ) edge form a tree next line contain a single integer $$$ k_1 $$$ ( $$$ 1 \leq k_1 \leq n $$$ ) next line contain $$$ k_1 $$$ distinct integers $$$ x_1 x_2 \ldots x _ { k_1 } $$$ ( $$$ 1 \leq x_i \leq n $$$ ) vertices form a subtree next line contain a single integer $$$ k_2 $$$ ( $$$ 1 \leq k_2 \leq n $$$ ) next line contain $$$ k_2 $$$ distinct integers $$$ y_1 y_2 \ldots y _ { k_2 } $$$ ( $$$ 1 \leq y_i \leq n $$$ ) vertices form a subtree li chen 's tree accord permutation first sample li chen 's hide permutation $$$ [ 2 3 1 ] $$$ second hide permutation $$$ [ 5 3 2 4 1 6 ] $$$ case first sample a tree three nod a line top label tree subtree choose bottom li chen label tree subtree choose : first question ask andrew look node $$$ 1 $$$ label tell label li chen 's label andrew respond $$$ 2 $$$ point know subtrees contain node ( i.e node $$$ 1 $$$ accord label ) output ` ` c 1 '' finish however also ask andrew look node $$$ 2 $$$ li chen 's label tell label label andrew respond $$$ 1 $$$ ( step give reason — show ask question ) second sample two test case first look one statement : first ask ` ` b 2 '' andrew tell us $$$ 3 $$$ case know $$$ 3 $$$ a common vertex moreover subtree size $$$ 3 $$$ contain node $$$ 3 $$$ must contain node $$$ 1 $$$ well output either ` ` c 1 '' ` ` c 3 '' answer second case second sample situation look follow : case know subtree size $$$ 3 $$$ n't contain node $$$ 1 $$$ subtree $$$ 4,5,6 $$$ ask andrew label node $$$ 1 $$$ li chen 's label andrew say $$$ 5 $$$ case know li chen 's subtree n't contain node $$$ 1 $$$ subtree must consist nod $$$ 4,5,6 $$$ ( label ) thus two subtrees common nod","['dfs and similar', 'trees']",1900.0
1214/H,"new pedestrian zone moscow city center consist $$$ n $$$ square connect $$$ n - 1 $$$ footpaths define a simple path a sequence square square appear sequence twice two adjacent square sequence directly connect a <unknown> size a simple path number square footpaths design a a way exactly one simple path pair different square <unknown> moscow city day city <unknown> decide <unknown> grind tile $$$ n $$$ square $$$ k $$$ tile type different color number $$$ 1 $$$ $$$ k $$$ square exactly one tile type must select use cover square surface make walk city center fascinate decide select tile type square a way possible simple path size exactly $$$ k $$$ contain square $$$ k $$$ possible tile color need find whether possible place tile way first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le k \le n \le 200\,000 $$$ ) — number square new pedestrian zone number different tile color follow $$$ n - 1 $$$ line contain two integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ ) — number square connect correspond road 's guarantee 's possible go square square moreover exactly one simple path print ` ` yes '' possible assign tile color way ` ` '' otherwise case answer ` ` yes '' print $$$ n $$$ integers $$$ 1 $$$ $$$ k $$$ color tile every square follow picture illustrate pedestrian zone first second examples second picture also show one possible distribution color among square $$$ k = 4 $$$","['dfs and similar', 'trees']",2800.0
1118/F1,give undirected tree $$$ n $$$ vertices vertices color blue color red uncolored guarantee tree contain least one red vertex least one blue vertex choose edge remove tree tree fall apart two connect components let 's call edge nice neither result components contain vertices red blue color many nice edge give tree ? first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 300000 $$$ ) — number vertices tree second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 2 $$$ ) — color vertices $$$ a_i = 1 $$$ mean vertex $$$ i $$$ color red $$$ a_i = 2 $$$ mean vertex $$$ i $$$ color blue $$$ a_i = 0 $$$ mean vertex $$$ i $$$ uncolored $$$ i $$$ -th next $$$ n - 1 $$$ line contain two integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ $$$ v_i \ne u_i $$$ ) — edge tree guarantee give edge form a tree guarantee tree contain least one red vertex least one blue vertex print a single integer — number nice edge give tree tree first example : nice edge edge $$$ ( 2 4 ) $$$ remove make tree fall apart components $$$ \ { 4\ } $$$ $$$ \ { 1 2 3 5\ } $$$ first component include a red vertex second component include blue vertices uncolored vertices tree second example : every edge nice tree third example : edge $$$ ( 1 3 ) $$$ split components $$$ \ { 1\ } $$$ $$$ \ { 3 2\ } $$$ latter one include red blue vertex thus edge n't nice edge $$$ ( 2 3 ) $$$ split components $$$ \ { 1 3\ } $$$ $$$ \ { 2\ } $$$ former one include red blue vertex thus edge also n't nice answer 0,"['dfs and similar', 'trees']",1800.0
979/C,"kuro live a country call uberland consist $$$ n $$$ towns number $$$ 1 $$$ $$$ n $$$ $$$ n - 1 $$$ bidirectional roads connect towns possible reach town road connect two towns $$$ a $$$ $$$ b $$$ kuro love walk plan take a walk <unknown> choose a pair towns $$$ ( u v ) $$$ ( $$$ u \neq v $$$ ) walk $$$ u $$$ use shortest path $$$ v $$$ ( note $$$ ( u v ) $$$ consider different $$$ ( v u ) $$$ ) <unknown> 2 special towns uberland name flowrisa ( denote index $$$ x $$$ ) beetopia ( denote index $$$ y $$$ ) flowrisa a town many strong - <unknown> flower beetopia another town many be live particular kuro avoid pair towns $$$ ( u v ) $$$ path $$$ u $$$ $$$ v $$$ reach beetopia reach flowrisa since be attract flower <unknown> kuro ’ s body sting kuro want know many pair city $$$ ( u v ) $$$ take route since ’ s really <unknown> ask help problem first line contain three integers $$$ n $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq n \leq 300000 $$$ $$$ 1 \leq x y \leq n $$$ $$$ x \ne y $$$ ) - number towns index town flowrisa index town beetopia respectively $$$ n - 1 $$$ line follow line contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \leq a b \leq n $$$ $$$ a \ne b $$$ ) describe a road connect two towns $$$ a $$$ $$$ b $$$ guarantee town reach every town city use give roads , give map towns roads a tree a single integer resemble number pair towns $$$ ( u v ) $$$ kuro use walk route first example kuro choose pair : kuro ca n't choose pair $$$ ( 1 3 ) $$$ since walk route would $$$ 1 \rightarrow 2 \rightarrow 3 $$$ kuro visit town $$$ 1 $$$ ( flowrisa ) visit town $$$ 3 $$$ ( beetopia ) allow ( note pair $$$ ( 3 1 ) $$$ still allow although kuro visit flowrisa beetopia visit order ) second example kuro choose follow pair :","['dfs and similar', 'trees']",1600.0
822/F,second <unknown> start university pavlopolis vacation vičkopolis noora need return pavlopolis continue study sometimes ( quite often ) teachers like <unknown> noora also one teacher name yury dmitrievich teach graph theory yury dmitrievich n't like noora always give girl difficult task happen time teacher give noora a tree n vertices vertices number integers 1 n. length edge tree 1 . noora choose a set simple paths pairwise n't intersect edge however vertex belong least one select path select paths follow do : let us explain point move example suppose path consist two edge ( v1 v2 ) ( v2 v3 ) point initially stand edge ( v1 v2 ) begin movement vertex v1 point reach v1 ` ` turn around '' end path reach move another direction vertex v2 vertex v3 ` ` turn around '' move v2 speed point 1 edge per second example 0.5 second point move length half edge a stopwatch place vertex tree time stopwatches indicate start time 0 second start moment time point simultaneously start move select position select directions along select paths stopwatches simultaneously start one point reach vertex v stopwatch vertex v automatically reset i.e start count time zero denote <unknown> maximal time stopwatch vertex v show point movement continue infinitely noora ask select paths point <unknown> minimal possible several solutions necessary minimize <unknown> <unknown> <unknown> ... <unknown> help noora complete teacher 's task better understand statement see explanation example first line contain single integer n ( 2 ≤ n ≤ 100 ) — number vertices give tree next n - 1 line contain two integers u v ( 1 ≤ u v ≤ n u ≠ v ) — vertices connect edge guarantee input define a valid tree first line print single integer paths — number paths want choose next paths line print path 's descriptions : judge system generate array res use output data provide participant also system generate array <unknown> jury answer answer accept i ( 1 ≤ i ≤ n ) follow satisfy : consider example start moment time point locate follow : first path highlight red second blue green circle represent choose point <unknown> number inside vertices — current time stopwatch purple arrows represent direction point move 0 ( 3 ) second point locate follow way ( stopwatch reset ) : stopwatch reset : <unknown> second start move : 1 ( 3 ) second start move ( stopwatch reset ) : finally 2 second start move point return initial position process continue infinitely,"['dfs and similar', 'trees']",2500.0
1702/G1,easy version problem difference easy a hard version number query polycarp grow a tree $$$ n $$$ vertices remind a tree $$$ n $$$ vertices undirected connect graph $$$ n $$$ vertices $$$ n-1 $$$ edge contain cycle call a set vertices passable a path tree pass vertex set without pass edge twice path visit vertices ( set ) word a set vertices call passable a simple path pass vertices set ( possibly ) example a tree set $$$ \ { 3 2 5\ } $$$ $$$ \ { 1 5 4\ } $$$ $$$ \ { 1 4\ } $$$ passable $$$ \ { 1 3 5\ } $$$ $$$ \ { 1 2 3 4 5\ } $$$ polycarp ask answer $$$ q $$$ query query a set vertices query need determine whether correspond set vertices passable first line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number vertices follow $$$ n - 1 $$$ line a description tree .. line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) — indices vertices connect edge follow line contain single integer $$$ q $$$ ( $$$ 1 \le q \le 5 $$$ ) — number query follow $$$ 2 \cdot q $$$ line contain descriptions set first line description contain integer $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) — size set second line description contain $$$ k $$$ distinct integers $$$ p_1 p_2 \dots p_k $$$ ( $$$ 1 \le p_i \le n $$$ ) — indices vertices set guarantee sum $$$ k $$$ value query exceed $$$ 200000 $$$ output $$$ q $$$ line contain answer correspond query answer output ` ` yes '' set passable ` ` '' otherwise output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ),"['dfs and similar', 'trees']",1900.0
1396/E,"give integer $$$ k $$$ a tree $$$ t $$$ $$$ n $$$ nod ( $$$ n $$$ even ) let $$$ dist ( u v ) $$$ number edge shortest path node $$$ u $$$ node $$$ v $$$ $$$ t $$$ let us define a undirected weight complete graph $$$ g = ( v e ) $$$ follow : task simple find a perfect match $$$ g $$$ total edge weight $$$ k $$$ $$$ ( 1 \le k \le n^2 ) $$$ first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 100\,000 $$$ $$$ n $$$ even $$$ 1 \le k \le n^2 $$$ ) : number nod total edge weight perfect match need find $$$ i $$$ -th follow $$$ n - 1 $$$ line contain two integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ ) denote edge $$$ v_i $$$ $$$ u_i $$$ $$$ t $$$ guarantee give graph a tree match satisfy condition output ` ` '' ( without quote ) a single line otherwise output ` ` yes '' ( without quote ) first line output output $$$ \frac { n } { 2 } $$$ line $$$ i $$$ -th line contain $$$ p_i q_i $$$ ( $$$ 1 \le p_i q_i \le n $$$ ) : $$$ i $$$ -th pair match a tree a connect acyclic undirected graph a match set pairwise non - adjacent edge none loop ; two edge share a common vertex a perfect match a match match vertices graph ; every vertex graph incident exactly one edge match","['dfs and similar', 'trees']",3200.0
1387/B2,problem split two task task require find maximum possible answer task village ( minimum ) require find minimum possible answer task worth $$$ 50 $$$ point $$$ n $$$ house a certain village a single villager live house house connect roads road connect two house exactly $$$ 1 $$$ <unknown> long house possible reach use one several consecutive roads total $$$ n-1 $$$ roads village one day villagers decide move different house — move house a single villager live villager live house would like know largest possible total length kilometers shortest paths old new house villagers example village seven house example seven house connect roads show figure largest total length $$$ 18 $$$ km ( achieve move $$$ 1 \to 7 $$$ $$$ 2 \to 3 $$$ $$$ 3 \to 4 $$$ $$$ 4 \to 1 $$$ $$$ 5 \to 2 $$$ $$$ 6 \to 5 $$$ $$$ 7 \to 6 $$$ ) write a program find largest total length shortest paths kilometers example assignment new house villagers first line contain integer $$$ n $$$ ( $$$ 1 < n \le 100000 $$$ ) house number consecutive integers $$$ 1 2 \ldots n $$$ $$$ n-1 $$$ line follow describe roads line contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le n $$$ $$$ a \neq b $$$ ) denote a road connect house $$$ a $$$ $$$ b $$$ first line output largest total length shortest paths kilometers second line describe one valid assignment new house largest total length : $$$ n $$$ space - separated distinct integers $$$ v_1 v_2 \ldots <unknown> $$$ $$$ i $$$ $$$ v_i $$$ house number villager house $$$ i $$$ move ( $$$ v_i \neq i $$$ ) several valid assignments output subtasks :,"['dfs and similar', 'trees']",2500.0
1305/D,"interactive problem get ac 13 time limit exceed verdicts a geometry problem kuroni go italian restaurant celebrate <unknown> achievement unfortunately excess <unknown> <unknown> 's lose ! unite state america model a tree ( though ) $$$ n $$$ vertices tree root vertex $$$ r $$$ <unknown> lie kuroni 's hotel kuroni a phone app design help <unknown> case use app input two vertices $$$ u $$$ $$$ v $$$ 'll return a vertex $$$ w $$$ lowest common ancestor two vertices however since phone 's <unknown> almost <unknown> live - <unknown> kuroni 's <unknown> party could use app $$$ \lfloor \frac { n } { 2 } \rfloor $$$ time , phone would die nothing leave help <unknown> friend ! : ( night cold dark kuroni need get back <unknown> <unknown> bed <unknown> ( s ) help figure hotel 's location ? interaction start read a single integer $$$ n $$$ ( $$$ 2 \le n \le 1000 $$$ ) number vertices tree read $$$ n-1 $$$ line $$$ i $$$ -th two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ ) denote edge connect vertices $$$ x_i $$$ $$$ y_i $$$ guarantee edge form a tree make query type ` ` ? u v '' ( $$$ 1 \le u v \le n $$$ ) find lowest common ancestor vertex $$$ u $$$ $$$ v $$$ query read result $$$ w $$$ integer case query invalid ask $$$ \lfloor \frac { n } { 2 } \rfloor $$$ query program print $$$ -1 $$$ finish interaction receive a wrong answer verdict make sure exit immediately avoid get verdicts find vertex $$$ r $$$ print ` ` ! $$$ r $$$ ` ` quit query count towards $$$ \lfloor \frac { n } { 2 } \rfloor $$$ limit note tree fix beforehand change query i.e interactor adaptive print query forget print end line flush output otherwise might get idleness limit exceed , use : hacksto hack use follow format : first line contain two integers $$$ n $$$ $$$ r $$$ ( $$$ 2 \le n \le 1000 $$$ $$$ 1 \le r \le n $$$ ) denote number vertices vertex kuroni 's hotel $$$ i $$$ -th next $$$ n-1 $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ ) — denote edge connect vertex $$$ x_i $$$ $$$ y_i $$$ edge present form a tree note example interaction contain extra empty line 's easier read real interaction n't contain empty line n't print extra empty line well image demonstrate tree sample test :","['dfs and similar', 'trees']",1900.0
86/C,` ` <unknown> space completely style days unlike <unknown> problems '' — think physicist woll change subject study <unknown> analyse result sequence face follow problem concern dna sequence think a dna sequence arbitrary string uppercase letter ` ` a '' ` ` c '' ` ` g '' ` ` t '' ( course a simplify interpretation ) let w a long dna sequence s1 s2 ... sm — collection short dna sequence let us say collection filter w iff w cover sequence collection <unknown> substrings correspond different position string may intersect even cover formally : denote |w| length w let symbols w number 1 |w| position i w exist pair indices l r ( 1 ≤ l ≤ i ≤ r ≤ |w| ) substring w [ l ... r ] equal one elements s1 s2 ... sm collection woll want calculate number dna sequence a give length filter a give collection n't know deal help ! task find number different dna sequence length n filter collection { si } answer may appear large output modulo 1000000009 . first line contain two integer number n m ( 1 ≤ n ≤ 1000 1 ≤ m ≤ 10 ) — length string number sequence collection correspondently next m line contain collection sequence si one per line si a nonempty string length greater 10 . string consist uppercase letter ` ` a '' ` ` c '' ` ` g '' ` ` t '' collection may contain identical string output contain a single integer — number string filter collection modulo 1000000009 ( 109 + 9 ) first sample a string filter ` ` a '' clearly one string : ` ` aa '' second sample exist exactly two different string satisfy condition ( see picture ),"['dp', 'trees']",2500.0
1740/H,give a root tree define value vertex $$$ u $$$ tree recursively mex $$$ ^\dagger $$$ value children note children <unknown> particular value a leaf $$$ 0 $$$ pak chanek a root tree initially contain a single vertex index $$$ 1 $$$ root pak chanek go $$$ q $$$ query $$$ i $$$ -th query pak chanek give integer $$$ x_i $$$ pak chanek need add a new vertex index $$$ i+1 $$$ child vertex $$$ x_i $$$ add new vertex pak chanek need <unknown> value vertices report sum value vertices current tree $$$ ^\dagger $$$ mex ( minimum exclude ) array smallest non - negative integer belong array example mex $$$ [ <unknown> ] $$$ $$$ 3 $$$ mex $$$ [ <unknown> ] $$$ $$$ 0 $$$ first line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 300000 $$$ ) — number operations next $$$ q $$$ line contain a single integer $$$ x_i $$$ ( $$$ 1 \leq x_i \leq i $$$ ) — description $$$ i $$$ -th query query print a line contain integer represent sum new value vertices tree add vertex first example tree $$$ 6 $$$ -th query look like sum value vertices $$$ 0 + 0 + 1 + 0 + 1 + 2 + <unknown> $$$,"['data structures', 'trees']",3300.0
1767/F,give a root tree consist $$$ n $$$ vertices vertex $$$ 1 $$$ root vertex integer write ; integer $$$ val_i $$$ vertex $$$ i $$$ give $$$ q $$$ query tree $$$ i $$$ -th query represent two vertices $$$ u_i $$$ $$$ v_i $$$ answer query consider vertices $$$ w $$$ lie subtree $$$ u_i $$$ $$$ v_i $$$ ( a vertex subtrees count twice ) vertices two subtrees list integers write find integer maximum number occurrences multiple integers maximum number occurrences minimum among answer first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number vertices tree second line contain $$$ n $$$ integers $$$ <unknown> <unknown> \dots <unknown> $$$ ( $$$ 1 \le val_i \le 200000 $$$ ) — number write vertices $$$ n - 1 $$$ line follow contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ ) represent edge vertices $$$ x $$$ $$$ y $$$ edge form a tree next line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query process $$$ q $$$ line follow $$$ i $$$ -th contain two number $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ) — root subtrees $$$ i $$$ -th query query print one integer — number maximum amount occurrences correspond pair subtrees ( multiple number print minimum one among ) $$$ 1 $$$ -st query pair subtrees consist vertices $$$ [ 2 4 7 8 ] $$$ number write $$$ \ { 1 2 2 4\ } $$$ number $$$ 2 $$$ occur twice number — answer $$$ 2 $$$ $$$ 2 $$$ -nd query pair subtrees consist vertices $$$ [ 3 5 6 7 7 8 8 ] $$$ number write $$$ \ { 3 3 3 2 2 4 4\ } $$$ number $$$ 3 $$$ maximum number occurrences $$$ 4 $$$ -th query pair subtrees consist vertices $$$ [ 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 ] $$$ number write $$$ \ { 2 2 1 1 3 3 2 2 3 3 3 3 2 2 4 4\ } $$$ number $$$ 2 $$$ $$$ 3 $$$ common minimum $$$ 2 $$$,"['data structures', 'trees']",3100.0
1575/I,"chanek jones back help long - <unknown> relative indiana jones find a secret treasure a maze bury a <unknown> full <unknown> map labyrinth form a tree $$$ n $$$ room number $$$ 1 $$$ $$$ n $$$ $$$ n - 1 $$$ tunnel connect possible travel pair room several tunnel $$$ i $$$ -th room ( $$$ 1 \leq i \leq n $$$ ) $$$ a_i $$$ illusion rate go $$$ x $$$ -th room $$$ y $$$ -th room must exist a tunnel $$$ x $$$ $$$ y $$$ take $$$ \max ( |a_x + a_y| |a_x - a_y| ) $$$ energy $$$ <unknown> $$$ denote absolute value $$$ z $$$ prevent <unknown> <unknown> maze change illusion rate room chanek indiana would ask $$$ q $$$ query two type query do : help get a portion treasure ! first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \leq n \leq 100000 $$$ $$$ 1 \leq q \leq 100000 $$$ ) — number room maze number query second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq <unknown> \leq 1000000000 $$$ ) — <unknown> illusion rate room $$$ i $$$ -th next $$$ n-1 $$$ line contain two integers $$$ s_i $$$ $$$ t_i $$$ ( $$$ 1 \leq s_i t_i \leq n $$$ ) mean a tunnel connect $$$ s_i $$$ -th room $$$ t_i $$$ -th room give edge form a tree next $$$ q $$$ line contain query describe give query valid type $$$ 2 $$$ query output a line contain integer — minimum sum energy need chanek indiana take secret treasure first query movement $$$ 1 $$$ -st $$$ 2 $$$ -nd room follow second query illusion rate $$$ 1 $$$ -st room change $$$ 10 $$$ $$$ -3 $$$ third query movement $$$ 1 $$$ -st $$$ 2 $$$ -nd room follow , take $$$ 32 $$$ energy","['data structures', 'trees']",2300.0
1575/E,a city park represent a tree $$$ n $$$ attractions vertices $$$ n - 1 $$$ rail edge $$$ i $$$ -th attraction happiness value $$$ a_i $$$ rail a color either black $$$ t_i = 0 $$$ white $$$ t_i = 1 $$$ black train operate a black rail track white train operate a white rail track previously a black train want ride a white train previously a white train want ride a black train need use $$$ 1 $$$ ticket path a tour must a simple path — must visit attraction need a ticket first time board a train $$$ k $$$ ticket mean switch train type $$$ k $$$ time particular need a ticket go a path consist one rail color define $$$ f ( u v ) $$$ sum happiness value attractions tour $$$ ( u v ) $$$ a simple path start $$$ u $$$ -th attraction end $$$ v $$$ -th attraction find sum $$$ f ( u v ) $$$ valid tour $$$ ( u v ) $$$ ( $$$ 1 \leq u \leq v \leq n $$$ ) need $$$ k $$$ ticket modulo $$$ 1000000000 + 7 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \leq n \leq 200000 $$$ $$$ 0 \leq k \leq n-1 $$$ ) — number attractions city park number ticket second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) — happiness value attraction $$$ i $$$ -th next $$$ n - 1 $$$ line contain three integers $$$ u_i $$$ $$$ v_i $$$ $$$ t_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ 0 \leq t_i \leq 1 $$$ ) — edge vertices $$$ u_i $$$ $$$ v_i $$$ color $$$ t_i $$$ give edge form a tree output integer denote total happiness value valid tour $$$ ( u v ) $$$ ( $$$ 1 \leq u \leq v \leq n $$$ ) modulo $$$ 1000000000 + 7 $$$,"['data structures', 'trees']",2600.0
1491/H,"<unknown> <unknown> give luo tianyi a tree $$$ n $$$ nod root $$$ 1 $$$ luo tianyi tell parent $$$ i $$$ -th node $$$ a_i $$$ ( $$$ 1 \leq a_i < i $$$ $$$ 2 \le i \le n $$$ ) ask perform $$$ q $$$ query $$$ 2 $$$ type : first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2\leq n q \leq 100000 $$$ ) — number nod number query respectively second line contain $$$ n-1 $$$ integers $$$ a_2 a_3 \dots a_n $$$ ( $$$ 1 \le a_i < i $$$ ) $$$ a_i $$$ parent node $$$ i $$$ next $$$ q $$$ line contain query query first integer line $$$ t $$$ ( $$$ t = 1 $$$ $$$ 2 $$$ ) — type query $$$ t = 1 $$$ represent query first type , three integers follow : $$$ l $$$ $$$ r $$$ $$$ x $$$ ( $$$ 2 \le l \le r \le n $$$ $$$ 1 \le x \le 100000 $$$ ) mean replace $$$ a_i $$$ $$$ \max ( a_i - <unknown> ) $$$ $$$ i $$$ $$$ l \leq i \leq r $$$ $$$ t = 2 $$$ represent query second type , two integers follow : $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) find lca $$$ u $$$ $$$ v $$$ 's guarantee least one query second type query second type output answer a new line tree example show query first type tree change look show","['data structures', 'trees']",3400.0
172/E,"problem <unknown> languages bhtml bcss slightly resemble html <unknown> read problem statement carefully <unknown> rather <unknown> problem use simplify <unknown> give a bhtml document resemble html much simpler record a sequence open close tag a tag look like ` ` < tagname > '' call open tag a tag look like ` ` < /tagname > '' call a close tag besides self - closing tag write ` ` < <unknown> > '' problem fully equivalent ` ` < tagname > < /tagname > '' tagnames problem string consist lowercase latin letter length 1 10 character tagnames different tag may coincide document tag form a correct bracket sequence , obtain empty sequence give one use follow operations : example may give document : ` ` < header > < p > < <unknown> > < b > < /b > < <unknown> > < <unknown> > < footer > < <unknown> > '' may give document ` ` < a > '' ` ` < a > < /b > '' ` ` < /a > < a > '' ` ` < a > < b > < /a > < /b > '' obviously open tag match close one — pair call element a self - closing tag also element let 's consider one element nest inside another one tag first element tag second one element nest instance example element ` ` b '' nest ` ` header '' ` ` p '' n't nest ` ` a '' ` ` footer '' also n't nest ( ` ` b '' ) element ` ` header '' three elements nest ` ` footer '' zero need bcss rule apply style display elements bhtml document rule record a subsequence word ` ` x1 x2 ... xn '' rule effect elements t satisfy condition list : example element ` ` b '' meet condition rule ` ` a b '' element ` ` b '' exist element ` ` a '' nest element ` ` c '' meet condition rule ` ` a b b c '' three elements exist : ` ` a '' ` ` b '' ` ` b '' chain ` ` a '' - '' b '' - '' b '' - '' c '' follow element nest previous one give a bhtml document a set bcss rule write a program determine number elements meet condition rule first line input contain a bhtml - document document length 4 106 character document a correct structure n't contain space unnecessary character tagnames consist lowercase latin letter lengths 1 10 character second line contain integer m ( 1 ≤ m ≤ 200 ) — number query m line contain query one per line query a sequence x1 x2 ... xn xi i - th element query n ( 1 ≤ n ≤ 200 ) number elements query elements separate single space query n't begin n't end a space query element a sequence lowercase latin letter length 1 10 . print m line j - th line contain number elements document correspond j - th bcss - rule elements print line 0",['dfs and similar'],2200.0
128/A,"task anna maria play a game a unpleasant <unknown> anna maria opposite square a chessboard ( 8 × 8 ) : anna upper right corner maria lower leave one apart board several statues statue occupy exactly one square a square contain a statue anything anyone — neither statues anna maria anna present board a <unknown> ( stand still never move ) maria <unknown> involve game goal — come anna 's square maria statues move turn maria move first one move maria go adjacent side diagonal cell statue stay cell statues move must go one square simultaneously statues bottom row fall board longer appear moment one statues cell maria statues declare winners moment maria come cell anna wait maria declare winner obviously nothing depend statues depend maria determine win maria make a strategic error give 8 string whose length equal 8 describe initial position board first line represent top row board next one — second top , last line represent bottom row character string match a single cell board appropriate row character manner correspond cell cell empty correspond character ` ` . ` ` a cell maria represent character ` ` m '' a cell anna represent character ` ` a '' a cell a statue cell represent character ` ` s '' guarantee last character first row always ` ` a '' first character last line always ` ` m '' remain character ` ` . '' ` ` s '' maria win print string ` ` win '' statues win print string ` ` lose ''",['dfs and similar'],1500.0
1218/H,definitely go <unknown> another <unknown> story alice find array alice bob play stupid game time 'll get a simple plain text first let us define several things define function $$$ f $$$ array $$$ a $$$ $$$ f ( i 1 ) = a [ i ] $$$ $$$ f ( i m ) = a [ f ( i m - 1 ) ] $$$ $$$ m > 1 $$$ word value $$$ f ( i m ) $$$ represent composition $$$ a [ ... a [ i ] ] $$$ apply $$$ m $$$ time give array length $$$ n $$$ non - negative integers expect give answer $$$ q $$$ query query consist two number – $$$ m $$$ $$$ y $$$ query determine many $$$ x $$$ exist $$$ f ( x m ) = y $$$ first line contain one integer $$$ n $$$ $$$ ( 1 \leq n \leq 2 \cdot 100000 ) $$$ – size array $$$ a $$$ next line contain $$$ n $$$ non - negative integers – array $$$ a $$$ $$$ ( 1 \leq a_i \leq n ) $$$ next line contain one integer $$$ q $$$ $$$ ( 1 \leq q \leq 100000 ) $$$ – number query next $$$ q $$$ line contain two integers $$$ m $$$ $$$ y $$$ $$$ ( 1 \leq m \leq 10^ { 18 } 1\leq y \leq n ) $$$ output exactly $$$ q $$$ line a single integer represent solution output solutions order query ask first query notice $$$ f ( 3 10 ) = 1 \ f ( 9 10 ) = 1 $$$ $$$ f ( 10 10 ) = 1 $$$ second query $$$ x $$$ satisfy condition $$$ f ( x 5 ) = 7 $$$ third query $$$ f ( 5 10 ) = 6 $$$ hold fourth query $$$ f ( 3 1 ) = 1 $$$ fifth query $$$ x $$$ satisfy condition $$$ f ( x 10 ) = 8 $$$,['dfs and similar'],2900.0
616/C,give a rectangular field n × m cells cell either empty impassable ( contain obstacle ) empty cells mark ' ' impassable cells mark ' * ' let 's call two empty cells adjacent share a side let 's call a connect component non - <unknown> set cells two connect path adjacent cells a <unknown> well - known definition a connect component impassable cell ( x y ) imagine empty cell ( cells remain unchanged ) find size ( number cells ) connect component contain ( x y ) impassable cell independently answer print a matrix n row m columns j - th symbol i - th row ` ` . '' cell empty start otherwise j - th symbol i - th row contain digit — - answer modulo 10 . matrix print without space make output faster recommend build output array n string length m print a sequence line much faster write character - <unknown> - character input / output reach huge size recommend use fast input / output <unknown> : example prefer use <unknown> / <unknown> instead cin / cout c++ prefer use <unknown> / <unknown> instead <unknown> / <unknown> java first line contain two integers n m ( 1 ≤ n m ≤ 1000 ) — number row columns field next n line contain m symbols : ` ` . '' empty cells ` ` * '' impassable cells print answer a matrix describe see examples precise format output first example imagine central cell empty include component size 5 ( cross ) corner cell empty include component size 3 ( corner ),['dfs and similar'],1600.0
183/C,give a direct graph g n vertices m arc ( multiple arc self - loops allow ) paint vertex graph one k ( k ≤ n ) color way arc graph lead a vertex u vertex v vertex v paint next color color use paint vertex u. color number cyclically 1 k. mean color i ( i < k ) next color color i + 1 . addition next color color k color 1 . note k = 1 next color color 1 color 1 . task find print largest possible value k ( k ≤ n ) 's possible color g describe k color note n't necessarily use k color ( color i necessarily exist a vertex color color i ) first line contain two space - separated integers n m ( 1 ≤ n m ≤ 105 ) denote number vertices number arc give digraph respectively m line follow line contain two space - separated integers ai bi ( 1 ≤ ai bi ≤ n ) mean i - th arc go vertex ai vertex bi multiple arc self - loops allow print a single integer — maximum possible number color use paint digraph ( i.e k describe problem statement ) note desire value k must satisfy inequality 1 ≤ k ≤ n. first example k = 2 picture depict two color ( arrows denote next color color ) k = 2 a possible way paint graph follow prove larger value k exist test case second example 's picture k = 5 color a possible color graph : third example 's picture k = 3 color a possible color graph :,['dfs and similar'],2200.0
377/A,"pavel love grid <unknown> a grid maze n × m rectangle maze cell either empty a wall go one cell another cells empty a common side pavel draw a grid maze empty cells form a connect area , go empty cell one pavel n't like maze little wall want turn exactly k empty cells wall remain cells still form a connect area help first line contain three integers n m k ( 1 ≤ n m ≤ 500 0 ≤ k < s ) n m maze 's height width correspondingly k number wall pavel want add letter s represent number empty cells original maze next n line contain m character describe original maze a character a line equal ` ` ` ` correspond cell empty character equal ` ` # '' cell a wall print n line contain m character : new maze fit pavel 's requirements mark empty cells transform wall ` ` x '' cells must leave without change ( ` ` . '' ` ` # '' ) guarantee a solution exist multiple solutions output",['dfs and similar'],1600.0
190/C,"vasya use accountant war begin one know operate a computer assign programmer know program often store set integers example a problem a weight direct graph edge represent three integers : number start vertex number final vertex edge 's weight , vasya try represent characteristics a recently invent robot program face follow problem vasya a programmer ask friend gena convenient way store n integers gena use code language x -- use type occur language let 's define a ` ` type '' language x -- : formally : type : = int | pair < type type > example gena use follow type graph edge : pair < int pair < int int > > gena please help vasya dictate vasya a type language x -- store n integers unfortunately gena a hurry omit punctuation gena already leave vasya ca n't find correct punctuation result a type language x -- however hard try help vasya add punctuation mark receive valid type language x -- otherwise say task impossible perform first line contain a single integer n ( 1 ≤ n ≤ 105 ) show many number type dictate gena contain second line contain space - separated word say gena either ` ` pair '' ` ` int '' ( without quote ) guarantee total number word exceed 105 among word gena say exactly n word ` ` int '' possible add punctuation mark get a correct type language x -- a result print a single line represent result type otherwise print ` ` error occur '' ( without quote ) inside record a type extra space character guarantee type exist unique note print type dictate gena ( type exist ) type contain n value",['dfs and similar'],1500.0
756/A,pavel cook <unknown> n skewer lay a <unknown> a row one n position pavel want skewer cook time every n position two directions : one direct originally reverse direction pavel a plan : a permutation p a sequence b1 b2 ... bn consist zero ones second pavel move skewer position i position pi bi equal 1 reverse hope every skewer visit every position directions unfortunately every pair permutation p sequence b suit pavel minimum total number elements give permutation p give sequence b need change every skewer visit 2n placements ? note change permutation remain a permutation well problem pavel skewer visit placements several time end cook word a permutation p a sequence b suit integer k ( k ≥ 2n ) k second skewer visit 2n placements show suitable pair permutation p sequence b exist n. first line contain integer n ( 1 ≤ n ≤ 2·105 ) — number skewer second line contain a sequence integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) — permutation accord pavel want move skewer third line contain a sequence b1 b2 ... bn consist zero ones accord pavel want reverse skewer print single integer — minimum total number elements give permutation p give sequence b need change every skewer visit 2n placements first example pavel change permutation 4 3 1 2 . second example pavel change element b 1,['dfs and similar'],1700.0
540/C,"play a computer game character stand level a <unknown> ice cave order move forward need descend one level lower way fall ice level cave a rectangular square grid n row m columns cell consist either intact crack ice cell move cells side - adjacent ( due limitations game <unknown> make jump place i.e jump a cell ) move cell crack ice character fall move cell intact ice ice cell become crack let 's number row integers 1 n top bottom columns integers 1 m leave right let 's denote a cell intersection r - th row c - th column ( r c ) stay cell ( r1 c1 ) cell crack ' ve fall a higher level need fall cell ( r2 c2 ) since exit next level ? first line contain two integers n m ( 1 ≤ n m ≤ 500 ) — number row columns cave description next n line describe initial state level cave line consist m character ` ` . '' ( intact ice ) ` ` x '' ( crack ice ) next line contain two integers r1 c1 ( 1 ≤ r1 ≤ n 1 ≤ c1 ≤ m ) — initial coordinate guarantee description cave contain character ' x ' cell ( r1 c1 ) , ice start cell initially crack next line contain two integers r2 c2 ( 1 ≤ r2 ≤ n 1 ≤ c2 ≤ m ) — coordinate cell need fall final cell may coincide start one reach destination print ' yes ' otherwise print ' no ' first sample test one possible path : first visit cell ( 2 2 ) ice crack step second time character fall ice intend",['dfs and similar'],2000.0
513/D1,need find a binary tree size n satisfy a give set c constraints suppose nod unknown binary tree label use a pre - order traversal start 1 . i - th constraint give two label ai bi a direction leave right case leave direction bi element subtree root ai 's leave child similarly case right direction bi element subtree root ai 's right child first line input contain two integers n c. next c line contain 2 integers ai bi ( 1 ≤ ai bi ≤ n ) either ` ` leave '' ` ` right '' denote whether b subtree root ai 's leave child subtree root ai 's right child problem consist multiple subproblems subproblems different constraints input get score correct submission <unknown> description subproblems follow output a single line binary tree satisfy constraints accept tree 's nod print n space separate label represent in - order traversal use pre - order number label vertices tree satisfy constraints print ` ` impossible '' ( without quote ) consider first sample test need find a tree 3 nod satisfy follow two constraints node label 2 pre - order traversal leave subtree node label 1 pre - order traversal ; node label 3 pre - order traversal right subtree node label 1 . one tree three nod satisfy constraints in - order traversal ( 2 1 3 ) pre - order ` ` root – leave subtree – right subtree '' order in - order ` ` leave subtree – root – right subtree '' order information regard in - order pre - order see http : //en.wikipedia.org / wiki / <unknown>,['dfs and similar'],2400.0
510/B,fox ciel play a mobile puzzle game call ` ` two dot '' basic level play a board size n × m cells like : cell contain a dot color use different uppercase latin character express different color key game find a cycle contain dot color consider 4 blue dot picture form a circle example formally call a sequence dot d1 d2 ... <unknown> a cycle meet follow condition : determine exist a cycle field first line contain two integers n m ( 2 ≤ n m ≤ 50 ) : number row columns board n line follow line contain a string consist m character express color dot line character uppercase latin letter output ` ` yes '' exist a cycle ` ` '' otherwise first sample test ' a ' form a cycle second sample cycle third sample display picture ( ' y ' = yellow ' b ' = blue ' r ' = red ),['dfs and similar'],1500.0
505/D,"shuseki kingdom world 's lead nation <unknown> technology n cities kingdom number 1 n. thank mr . kitayuta 's research finally become possible construct teleportation pip two cities a teleportation pipe connect two cities <unknown> , a teleportation pipe city x city y use travel city y city x. transportation within city extremely develop therefore a pipe city x city y a pipe city y city z construct people able travel city x city z instantly mr . kitayuta also involve national <unknown> consider transportation m pair city ( ai bi ) ( 1 ≤ i ≤ m ) important plan construct teleportation pip important pair ( ai bi ) possible travel city ai city bi use one teleportation pip ( necessarily city bi city ai ) find minimum number teleportation pip need construct far teleportation pipe construct effective transportation cities first line contain two space - separated integers n m ( 2 ≤ n ≤ 105 1 ≤ m ≤ 105 ) denote number cities shuseki kingdom number important pair respectively follow m line describe important pair i - th ( 1 ≤ i ≤ m ) contain two space - separated integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) denote must possible travel city ai city bi use one teleportation pip ( necessarily city bi city ai ) guarantee pair ( ai bi ) distinct print minimum require number teleportation pip fulfill mr . kitayuta 's purpose first sample one optimal ways construct pip show image : second sample one optimal ways show :",['dfs and similar'],2200.0
475/E,imagine a city n junctions m streets junctions number 1 n. order increase traffic flow mayor city decide make street one - way mean street junctions u v traffic move u v v u. problem direct traffic flow streets a way maximize number pair ( u v ) 1 ≤ u v ≤ n possible reach junction v u pass streets specify direction task find maximal possible number pair first line input contain integers n m ( ) denote number junctions streets city follow m line contain two integers u v ( u ≠ v ) denote endpoints a street city every two junctions one street guarantee mayor decision ( streets two - way ) possible reach junction junction print maximal number pair ( u v ) possible reach junction v u direct streets first sample mayor make first second streets one - way towards junction 1 third fourth streets opposite direction would 13 pair reachable junctions : { ( 1 1 ) ( 2 2 ) ( 3 3 ) ( 4 4 ) ( 5 5 ) ( 2 1 ) ( 3 1 ) ( 1 4 ) ( 1 5 ) ( 2 4 ) ( 2 5 ) ( 3 4 ) ( 3 5 ) },['dfs and similar'],2700.0
412/D,"employees r1 company often spend time together : watch football go camp solve contest , 's big deal sometimes someone pay someone else today day give money reward r1 company ceo invite employees office one one reward one hard work month ceo know owe money also understand invite person x office a reward immediately invite person y <unknown> money person x meet course a situation <unknown> person x brand new money reward much less therefore r1 ceo decide invite <unknown> order describe situation happen pair employees invite one another however a lot employees company ceo n't a lot time therefore task assign give debt <unknown> employees determine order invite office r1 company ceo determine describe order exist first line contain space - separated integers n m — number employees r1 number debt relations follow m line contain two space - separated integers ai bi ( 1 ≤ ai bi ≤ n ; ai ≠ bi ) integers indicate person number ai owe money a person a number bi assume employees number 1 n. guarantee pair people p q mention input data particular input data contain pair p q q p simultaneously print -1 describe order exist otherwise print permutation n distinct integers first number denote number person go ceo office first second number denote person go second multiple correct order allow print",['dfs and similar'],2000.0
359/E,"simon love neatness go bed simon want complete <unknown> house simon 's house look like a rectangular table consist n row n columns row table number 1 n top bottom columns table number 1 n leave right cell table a room pair ( x y ) denote room locate intersection x - th row y - th column room know light initially simon room ( x0 y0 ) want turn light room house return room ( x0 y0 ) suppose current moment simon room ( x y ) reach desire result perform follow step : help simon find sequence action let achieve desire result first line contain three positive integers n x0 y0 ( 2 ≤ n ≤ 500 1 ≤ x0 y0 ≤ n ) next n line contain description room house i - th line contain n space - separated integers ai1 ai2 ... , number aij equal zero room ( i j ) light number aij equal one room ( i j ) light guarantee least one room light desire sequence action print ` ` '' ( without quote ) otherwise print ` ` yes '' ( without quote ) description require sequence action a string note minimize length sequence action n't use 3·106 action",['dfs and similar'],2400.0
1433/D,$$$ n $$$ district town $$$ i $$$ -th district belong $$$ a_i $$$ -th <unknown> gang initially district connect mayor city want build $$$ n-1 $$$ two - way roads connect district ( two district connect directly connect district ) two district belong gang connect directly a road gang <unknown> n't want task build $$$ n-1 $$$ two - way roads a way district reachable ( possibly use intermediate district ) pair directly connect district belong different gang determine impossible build $$$ n-1 $$$ roads satisfy condition answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 2 \le n \le 5000 $$$ ) — number district second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ gang $$$ i $$$ -th district belong guarantee sum $$$ n $$$ exceed $$$ 5000 $$$ ( $$$ \sum n \le 5000 $$$ ) test case print : road $$$ i $$$ condition $$$ a [ x_i ] \ne a [ y_i ] $$$ satisfy also district reachable ( possibly use intermediate district ),['dfs and similar'],1200.0
717/E,"i see a pink boar i want paint black black boars look much <unknown> <unknown> pink ones since jaggy become ruler forest try best improve diplomatic relations forest region nearby ones <unknown> however request much return peace two regions realize resort <unknown> a <unknown> diplomatic relations a neighbor region visit jaggy ’ s forest see a whole bunch black boars might <unknown> change mind attack jaggy black boars really <unknown> , jaggy ’ s forest represent a tree ( connect graph without cycle ) n vertices vertex represent a boar color either black pink jaggy send a squirrel travel forest paint boars black squirrel however quite unusually train traverse graph change color every vertex visit regardless initial color : pink vertices become black black vertices become pink since jaggy busy plan squirrel ’ s route need help want construct a walk tree start vertex 1 end vertices black a walk a sequence vertices every consecutive pair edge a tree first line input contain integer n ( 2 ≤ n ≤ 200 000 ) denote number vertices tree follow n line contain n integers represent color nod i - th integer 1 i - th vertex black - 1 i - th vertex pink next n - 1 line contain two integers represent index vertices connect edge vertices number start 1 . output path a squirrel : output a sequence visit nod ' index order visit case nod initially black print 1 . solution guarantee exist multiple solutions problem output provide length sequence longer 107 . begin squirrel node 1 color black next step follow :",['dfs and similar'],1900.0
1446/E,"a patient infect unknown disease body see infinite grid triangular cells look follow : two cells neighbor share a side therefore cell ( $$$ x $$$ $$$ y $$$ ) exactly three neighbor : initially cells infect others healthy process recovery begin second exactly one cell ( even though might multiple cells could change state ) one follow happen : cell exist process recovery stop patient consider recover process recovery stop cells healthy 're interest a worst - case scenario : possible patient never recover 's possible maximum possible duration recovery process ? first line contain one integer $$$ n $$$ $$$ ( 1 \leq n \leq 250000 ) $$$ — number infect cells $$$ i $$$ -th next $$$ n $$$ line contain two space - separated integers $$$ x_i $$$ $$$ y_i $$$ $$$ ( 0 \leq x_i y_i < 500 ) $$$ mean cell $$$ ( x_i y_i ) $$$ infect cells $$$ ( x_i y_i ) $$$ distinct cells consider healthy possible organism never fully recover disease print sick otherwise print recover next line integer $$$ k $$$ — longest possible recovery period modulo $$$ 998244353 $$$ first testcase follow draw describe longest possible recovery process prove recovery periods length $$$ 5 $$$ longer organism always recover testcase $$$ \hspace { 40pt } \downarrow $$$ $$$ \hspace { 40pt } \downarrow $$$ $$$ \hspace { 40pt } \downarrow $$$ $$$ \hspace { 40pt } \downarrow $$$ $$$ \hspace { <unknown> } $$$ <unknown> second testcase possible cells $$$ ( 2 0 ) $$$ $$$ ( 2 1 ) $$$ $$$ ( 0 1 ) $$$ become infect , cell change state answer sick cells healthy",['dfs and similar'],3500.0
720/B,tree a connect undirected graph cycle edge cactus a connect undirected graph without loop parallel edge edge belong one cycle vasya edge cactus edge graph color vasya would like remove minimal number edge way cactus turn a tree vasya want make a way edge many different color result tree possible help find many different color result tree first line contain two integers : n m ( 2 ≤ n ≤ 10 000 ) — number vertices number edge vasya 's graph respectively follow m line contain three integers : u v c ( 1 ≤ u v ≤ n u ≠ v 1 ≤ c ≤ m ) — number vertices connect correspond edge color guarantee describe graph indeed edge cactus output one integer : maximal number different color result tree,['dfs and similar'],2400.0
732/F,berland a tourist country ! least become — government berland confident n cities berland pair connect two - ways roads road connect two different cities berland roads connect pair cities possible get city city use give two - ways roads accord reform road become one - way orient one two directions maximize tourist attraction berland reform city i value ri calculate equal number cities x orient path city i city x. word ri equal number cities reach city i roads government sure tourist 's attention focus minimum value ri help government berland make reform maximize minimum ri first line contain two integers n m ( 2 ≤ n ≤ 400 000 1 ≤ m ≤ 400 000 ) — number cities number roads next m line describe roads berland : j - th contain two integers uj vj ( 1 ≤ uj vj ≤ n uj ≠ vj ) uj vj number cities connect j - th road cities number 1 n. guarantee possible get city follow two - ways roads berland roads connect pair cities first line print single integer — maximum possible value min1 ≤ i ≤ n { ri } orientation roads next m line must contain description roads orientation : j - th must contain two integers uj vj mean j - th road direct city uj city vj print roads order give input data,"['dfs and similar', 'graphs']",2300.0
744/A,hongcow ruler world ruler world want make easier people travel road within countries world model undirected graph n nod m edge k nod home governments k countries make world one edge connect two nod edge connect a node furthermore two nod correspond governments path two nod graph satisfy condition stable hongcow want add many edge possible graph keep stable determine maximum number edge hongcow add first line input contain three integers n m k ( 1 ≤ n ≤ 1 000 0 ≤ m ≤ 100 000 1 ≤ k ≤ n ) — number vertices edge graph number vertices home government next line input contain k integers c1 c2 ... ck ( 1 ≤ ci ≤ n ) integers pairwise distinct denote nod home governments world follow m line input contain two integers ui vi ( 1 ≤ ui vi ≤ n ) denote undirected edge nod ui vi guarantee graph describe input stable output a single integer maximum number edge hongcow add graph keep stable first sample test graph look like : second sample test graph look like :,"['dfs and similar', 'graphs']",1500.0
687/A,recently pari arya research <unknown> - hard problems find minimum vertex cover problem interest suppose graph g give subset a vertices call a vertex cover graph edge <unknown> least one endpoint set i.e ( ) pari arya a great undirected graph award a team contest split two part want part graph a vertex cover agree give graph need find two disjoint subsets vertices a b a b vertex cover claim 's impossible vertex give one friends ( even keep ) first line input contain two integers n m ( 2 ≤ n ≤ 100 000 1 ≤ m ≤ 100 000 ) — number vertices number edge prize graph respectively next m line contain a pair integers ui vi ( 1 ≤ ui vi ≤ n ) denote undirected edge ui vi 's guarantee graph wo n't contain self - loops multiple edge 's impossible split graph pari arya expect print ` ` -1 '' ( without quote ) two disjoint set vertices set vertex cover print descriptions description must contain two line first line contain a single integer k denote number vertices vertex cover second line contain k integers — indices vertices note m ≥ 1 vertex cover empty first sample give vertex number 2 arya vertices number 1 3 pari keep vertex number 4 ( give someone wish ) second sample way satisfy pari arya,"['dfs and similar', 'graphs']",1500.0
710/E,<unknown> want generate input file program competition problem input a string consist n letter ' a ' lazy write a generator manually generate input a text editor initially text editor empty take x second insert delete a letter ' a ' text file y second copy content entire text file duplicate <unknown> want find minimum amount time need create input file exactly n letter ' a ' help determine amount time need generate input line contain three integers n x y ( 1 ≤ n ≤ 107 1 ≤ x y ≤ 109 ) — number letter ' a ' input file parameters problem statement print integer t — minimum amount time need generate input file,"['dfs and similar', 'dp']",2000.0
961/F,give a string s consist n lowercase latin letter let 's denote k - substring s a string <unknown> = <unknown> + 1 .. sn + 1 - k. obviously <unknown> = s exactly substrings let 's call string t odd proper suprefix a string t iff follow condition meet : <unknown> k - substring ( ) s calculate maximum length odd proper suprefix first line contain one integer n ( 2 ≤ n ≤ 106 ) — length s. second line contain string s consist n lowercase latin letter print integers i - th equal maximum length odd proper suprefix i - substring s ( - 1 string odd proper suprefix i - substring ) answer first sample test <unknown> :,['binary search'],2700.0
809/B,"interactive problem output section see information flush output sunday leha hacker take nura house live go one luxurious <unknown> vičkopolis upon arrival leave car a huge park lot near restaurant hurry inside build restaurant a <unknown> waiter immediately bring menu leha noora consist n dish interest dish menu number integers 1 n. a little think girl order exactly k different dish available menu pass wait time <unknown> prepare order dish girl invite hacker play a game help get know better game simple : noora want leha guess two dish among order time ready answer one type question leha say two number x y ( 1 ≤ x y ≤ n ) noora choose dish a number x first a among dish noora order ( x equal a ) , secondly value minimum possible rule girl choose dish b y. noora say « tak » leha , « nie » otherwise however restaurant prepare quickly leha enough time ask 60 question name number two dish noora order help leha solve problem ! two number n k ( 2 ≤ k ≤ n ≤ 105 ) single line input denote number dish menu number dish noora order want provide answer output a string form 2 x y ( 1 ≤ x y ≤ n x ≠ y ) think dish x y among dish order noora , flush output terminate program help leha ask query noora 60 time query print 's line form 1 x y ( 1 ≤ x y ≤ n ) print end - of - line character flush output flush read answer query input query jury 's program print one line « tak » « nie » ( without quote ) input stream depend girl 's answer flush use ( print integer end - of - line ) : hackingfor hack write number n k ( 2 ≤ k ≤ n ≤ 105 ) first line describe dish noora order k different integers a1 a2 ... ak ( 1 ≤ ai ≤ n ) write ascend order second line course solution want hack wo n't able read number order dish three dish sample noora order dish number 2 3 leha guess noora receive request first dish ( x = 1 ) 'll choose second dish ( a = 2 ) dish minimum value second ( x = 2 ) third ( x = 3 ) dish optimal case let leha ask noora next couple dish : accord available information possible say nura order dish number 2 3",['binary search'],2200.0
1838/F,"interactive problem $$$ n $$$ $$$ n $$$ grid conveyor belt position $$$ ( 1 1 ) $$$ $$$ ( n n ) $$$ a coordinate plane every square plane empty conveyor belt configure move box ( ' ^ ' ) ( ' v ' ) leave ( ' < ' ) right ( ' > ' ) a box move onto empty square stop move however one $$$ n^2 $$$ belt stick always move box direction matter configure goal perform a series test determine conveyor belt stick direction send items achieve perform $$$ 25 $$$ test test assign a direction $$$ n^2 $$$ belt place a box top one turn conveyors conveyors move box around quickly see information receive a test whether box eventually stop move , coordinate final position begin interaction read a single integer $$$ n $$$ ( $$$ 2 \le n\le 100 $$$ ) — number row columns grid , make $$$ 25 $$$ query query begin a line form ? r c r c initial row column box respectively next $$$ n $$$ line query contain $$$ n $$$ character $$$ j $$$ th character $$$ i $$$ th row one ' ^ ' ' v ' ' < ' ' > ' indicate direction conveyor $$$ ( i j ) $$$ query query receive two integers $$$ x $$$ $$$ y $$$ $$$ x = y = -1 $$$ box enter infinite loop otherwise final position $$$ ( x y ) $$$ make many query make invalid query receive wrong answer verdict find stick conveyor direction print a single line ! r c dir r c row column stick conveyor respectively dir one ' ^ ' ' v ' ' < ' ' > ' indicate direction stick conveyor note print answer count towards total $$$ 25 $$$ query print line program terminate interactor non - adaptive mean location direction stick belt fix start interaction change query print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto make a hack use follow format first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number row columns grid next line contain two integers $$$ r $$$ $$$ c $$$ ( $$$ 1 \le r c \le n $$$ ) well a character $$$ \mathrm { dir } $$$ ( $$$ \mathrm { dir } $$$ one ' ^ ' ' v ' ' < ' ' > ' ) — position stick conveyor fix direction value separate space first query first sample input box start $$$ ( 2 2 ) $$$ enter infinite loop contain row $$$ 2 $$$ $$$ 3 $$$ stick conveyor row $$$ 1 $$$ affect outcome query second query first sample input conveyors configure way box start $$$ ( 1 1 ) $$$ stick conveyor would enter infinite loop $$$ ( 1 2 ) $$$ $$$ ( 1 3 ) $$$ however stick conveyor <unknown> $$$ ( 0 2 ) $$$ two query program able determine stick conveyor $$$ ( 1 2 ) $$$ direct items <unknown> query second sample input correspond picture ask query many possibilities stick conveyor program correctly guess $$$ ( 3 3 ) $$$ direct items right",['binary search'],3000.0
1746/E1,"difference problem hard version maximum number question interactive problem a hide integer $$$ 1 \le x \le n $$$ find order find ask $$$ \mathbf { 82 } $$$ question question choose a non - empty integer set $$$ s $$$ ask $$$ x $$$ belong $$$ s $$$ question $$$ x $$$ belong $$$ s $$$ 'll receive ` ` yes '' otherwise ` ` '' problem answer necessarily true ( joke ) 's guarantee two consecutive question least one answer correctly additionally question make $$$ 2 $$$ guess answer $$$ x $$$ time make a guess guess $$$ x $$$ correctly receive ` ` : ) '' program terminate otherwise 'll receive ` ` : ( ` ` a part joke fix value $$$ x $$$ begin instead change throughout interaction long previous responses valid describe note answer guess always answer correctly ask a question a guess least one two question answer correctly normal line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) maximum possible value $$$ x $$$ question want ask a set $$$ s $$$ first print character ' ? ' print size $$$ s $$$ print elements $$$ s $$$ one one element integer $$$ 1 $$$ $$$ n $$$ elements must distinct question read a string ` ` yes '' ` ` '' explain statement make $$$ 82 $$$ question want guess $$$ x $$$ first print character ' ! ' print guess guess read ` ` : ) '' ` ` : ( ` ` guess $$$ x $$$ correctly answer ` ` : ) '' program terminate immediately otherwise 'll receive ` ` : ( ` ` make $$$ 2 $$$ guess print a query forget output end line flush output otherwise get idleness limit exceed , use : hack allow problem answer first question correct $$$ x $$$ would equal $$$ 6 $$$ see first guess $$$ 6 $$$ answer answer first question joke know answer least one two question correct since answer first question joke answer second question correct understand $$$ x $$$ equal $$$ 1 2 3 $$$ $$$ 4 $$$ also know $$$ x $$$ equal $$$ 6 $$$ either hence $$$ x $$$ equal $$$ 5 $$$",['binary search'],2500.0
1698/D,"interactive problem initially array $$$ a = [ 1 2 \ldots n ] $$$ $$$ n $$$ odd positive integer jury select $$$ \frac { n-1 } { 2 } $$$ disjoint pair elements elements pair swap example $$$ a= [ <unknown> ] $$$ pair $$$ 1 \leftrightarrow 4 $$$ $$$ 3 \leftrightarrow 5 $$$ swap result array $$$ [ 4 2 5 1 3 ] $$$ a result swap exactly one element change position need find element , ask several query query pick two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l \leq r \leq n $$$ ) return give elements subarray $$$ [ a_l a _ { l + 1 } \dots a_r ] $$$ sort increase order find element change position make $$$ \mathbf { 15 } $$$ query array $$$ a $$$ fix interaction change query recall array $$$ b $$$ a subarray array $$$ a $$$ $$$ b $$$ obtain $$$ a $$$ deletion several ( possibly zero ) elements begin several ( possibly zero ) elements end test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 500 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 3 \leq n < 10000 $$$ ; $$$ n $$$ odd ) — length array $$$ a $$$ read first line test case begin interaction guarantee sum $$$ n $$$ test case exceed $$$ 10000 $$$ test case begin interaction read integer $$$ n $$$ make a query output ` ` $$$ \texttt { ? } \ ; l\ ; r $$$ ` ` ( $$$ 1 \leq l \leq r \leq n $$$ ) without quote afterwards read $$$ r - l+1 $$$ integers — integers $$$ a_l a _ { l + 1 } \dots a_r $$$ increase order make $$$ 15 $$$ query a single test case receive integer $$$ -1 $$$ instead answer integer $$$ n $$$ mean program make invalid query exceed limit query give incorrect answer previous test case program must terminate immediately receive a wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream ready give final answer output ` ` $$$ \texttt { ! } \ ; x $$$ ` ` ( $$$ 1 \leq x \leq n $$$ ) without quote — element change position give answer count towards limit $$$ 15 $$$ query afterwards program must continue solve remain test case exit test case solve print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto make a hack use follow format first line must contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 500 $$$ ) — number test case description test case follow first line test case must contain integer $$$ n $$$ ( $$$ 3 \leq n < 10000 $$$ ; $$$ n $$$ odd ) — length array $$$ a $$$ second line test case must contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — elements $$$ a $$$ array $$$ a $$$ result $$$ \frac { n-1 } { 2 } $$$ disjoint swap array $$$ [ 1,2 \dots n ] $$$ first test interaction proceed follow note line break example input output sake clarity occur real interaction",['binary search'],1600.0
1697/D,"interactive problem remember flush output communicate test program may use fflush ( stdout ) c++ system.out.flush ( ) java stdout.flush ( ) python flush ( output ) pascal flush output use program language <unknown> documentation may also refer guide interactive problems : https : <unknown> / blog / <unknown> jury choose a string $$$ s $$$ consist $$$ n $$$ character ; character $$$ s $$$ a lowercase latin letter task guess string ; initially know length may ask query two type : allow ask $$$ 26 $$$ query first type $$$ 6000 $$$ query second type task restore string $$$ s $$$ test problem string $$$ s $$$ fix beforehand every submission initially jury program send one integer $$$ n $$$ a separate line — size $$$ s $$$ ( $$$ 1 \le n \le 1000 $$$ ) give answer print one line ! s a line break end $$$ s $$$ string pick jury , program flush output terminate gracefully ask a query send one line contain query one follow format : n't forget flush output send query line answer query give a separate line a query first type answer character $$$ s_i $$$ a query second type answer integer equal number different character among $$$ s_l s _ { l+1 } \dots s_r $$$ allow ask $$$ 26 $$$ query first type $$$ 6000 $$$ query second type case ask many query jury program fail recognize query format answer query one integer $$$ 0 $$$ receive $$$ 0 $$$ answer program terminate immediately — otherwise may receive verdict ` ` <unknown> error '' ` ` time limit exceed '' verdict instead ` ` wrong answer '' let 's analyze example interaction string choose jury guess initially jury send one integer $$$ 5 $$$ end answer submit ! guess deduce correctly",['binary search'],1900.0
1624/F,problem interactive decide play a game guess number $$$ x $$$ ( $$$ 1 \le x < n $$$ ) know number $$$ n $$$ make query like : win guess current number $$$ 10 $$$ query interaction begin read integer $$$ n $$$ ( $$$ 2 < n \le 1000 $$$ ) write input data line make $$$ 10 $$$ query make a query print a separate line : print answer like query a separate line answer n't count number query output use follow format : program exit use a flush operation right print line example c++ use function fflush ( stdout ) java — system.out.flush ( ) pascal — flush ( output ) python — <unknown> ( ) note interactor <unknown> make a hack use follow format : a single line must contain two number $$$ x $$$ $$$ n $$$ separate a space first sample initially $$$ x = 2 $$$ first query $$$ x = 3 $$$ $$$ \lfloor\frac { x } { n } \rfloor = 1 $$$ second sample also initially $$$ x = 2 $$$ first query $$$ x = 3 $$$ $$$ \lfloor\frac { x } { n } \rfloor = 0 $$$ second query $$$ x = 4 $$$ $$$ \lfloor\frac { x } { n } \rfloor = 0 $$$ third query $$$ <unknown> $$$ $$$ \lfloor\frac { x } { n } \rfloor = 1 $$$,['binary search'],2000.0
1764/G2,"difference problem two versions maximum number query version allow ask $$$ \mathbf { 25 } $$$ query make hack versions problem solve interactive problem . ` ` everybody ! doremy 's perfect data structure class start ! come best want much iq ! '' today 's data structure class doremy teach everyone a powerful data structure — doremy tree ! give a quiz prove pay attention class give array $$$ a $$$ length $$$ m $$$ doremy tree support query $$$ q ( l r k ) $$$ $$$ 1 \leq l \leq r \leq m $$$ $$$ 1 \leq k \leq m $$$ return number distinct integers array $$$ \left [ \lfloor\frac { a_l } { k } \rfloor \lfloor\frac { a _ { l+1 } } { k } \rfloor \ldots \lfloor\frac { a_r } { k } \rfloor\right ] $$$ doremy a secret permutation $$$ p $$$ integers $$$ 1 $$$ $$$ n $$$ make query one query give $$$ 3 $$$ integers $$$ l r k $$$ ( $$$ 1 \leq l \leq r \leq n $$$ $$$ 1 \leq k \leq n $$$ ) receive value $$$ q ( l r k ) $$$ array $$$ p $$$ find index $$$ y $$$ ( $$$ 1 \leq y \leq n $$$ ) $$$ p_y=1 $$$ $$$ \mathbf { 25 } $$$ query ? note permutation $$$ p $$$ fix query make begin interaction read integer $$$ n $$$ ( $$$ 3 \le n \le 1024 $$$ ) first line — length permutation make a query output give answer output print a query answer forget output end line flush output otherwise get idleness limit exceed , use : hack formatthe first line hack contain integer $$$ n $$$ ( $$$ 3 \le n \le 1024 $$$ ) — length permutation second line hack contain $$$ n $$$ distinct integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i\le n $$$ ) — permutation permutation example $$$ [ 3,5,2,1,4 ] $$$ input output example illustrate possible interaction test ( empty line insert clarity ) interaction process : correct answer get $$$ 4 $$$ query process judge correct",['binary search'],3000.0
1520/F1,"interactive problem easy version problem difference hard version easy version $$$ t=1 $$$ number query limit $$$ 20 $$$ polycarp play a computer game game array consist zero ones hide polycarp win guess position $$$ k $$$ -th zero leave $$$ t $$$ time polycarp make $$$ 20 $$$ request follow type : ( easy version ) problem <unknown> n't really make sense since $$$ t=1 $$$ always make game interest guess zero turn one game continue change array formally position $$$ k $$$ -th zero $$$ x $$$ polycarp guess position $$$ x $$$ -th element array replace $$$ 0 $$$ $$$ 1 $$$ course feature affect something $$$ t > 1 $$$ help polycarp win game first program must read two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ t=1 $$$ ) $$$ t $$$ line follow contain one integer $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) guarantee moment request array contain least $$$ k $$$ zero order get next value $$$ k $$$ must output answer current value $$$ k $$$ , make $$$ 20 $$$ request use follow format output answer ( a request n't count $$$ 20 $$$ ) : position array number leave right $$$ 1 $$$ $$$ n $$$ inclusive print $$$ t $$$ answer program exit immediately task interactor adaptive mean within test hide array query change case incorrect query -1 display value receive program must immediately exit normally ( example call exit ( 0 ) ) otherwise test system may issue arbitrary verdict number request exceed verdict wrong answer display solution may get verdict idleness limit exceed n't print anything forget flush output buffer flush output buffer need follow immediately query output end - of - line character : hacksuse follow format hack : first line print string $$$ s $$$ ( $$$ 1 \le |s| \le 200000 $$$ ) consist zero ones integer $$$ t $$$ ( $$$ t = 1 $$$ ) — hide array number request respectively next $$$ t $$$ line output number $$$ k $$$ ( $$$ 1 \le k \le |s| $$$ ) hack solution direct access hide array first test $$$ [ 1 0 1 1 0 1 ] $$$ array hide test $$$ k=2 $$$",['binary search'],1600.0
1486/C1,"difference easy hard version limit number query interactive problem array $$$ a $$$ $$$ n $$$ different number one query ask position second maximum element a subsegment $$$ a [ l .. r ] $$$ find position maximum element array 40 query a subsegment $$$ a [ l .. r ] $$$ elements $$$ a_l a _ { l + 1 } ... a_r $$$ ask subsegment give position second maximum subsegment whole array first line contain a single integer $$$ n $$$ $$$ ( 2 \leq n \leq 100000 ) $$$ — number elements array ask query print ` ` ? $$$ l $$$ $$$ r $$$ ` ` $$$ ( 1 \leq l < r \leq n ) $$$ answer index second maximum elements $$$ a_l a _ { l + 1 } \ldots a_r $$$ array $$$ a $$$ fix beforehand ca n't change time interaction output answer print ` ` ! $$$ p $$$ ` ` $$$ p $$$ index maximum element array ask 40 query print answer n't count a query print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto make a hack use follow test format first line output a single integer $$$ n $$$ $$$ ( 2 \leq n \leq 100000 ) $$$ second line output a permutation $$$ n $$$ integers $$$ 1 $$$ $$$ n $$$ position $$$ n $$$ permutation position maximumin sample suppose $$$ a $$$ $$$ [ 5 1 4 2 3 ] $$$ ask $$$ [ 1 .. 5 ] $$$ subsegment $$$ 4 $$$ second max value 's position $$$ 3 $$$ ask $$$ [ 4 .. 5 ] $$$ subsegment $$$ 2 $$$ second max value 's position whole array $$$ 4 $$$ note array $$$ a $$$ would produce interaction answer might different example output give purpose understand interaction",['binary search'],1600.0
1482/G,"gustaw chief bank manager a huge bank unlimited access database system bank a click move amount money bank 's reserve private account however bank use fancy ai fraud detection system make steal difficult gustaw know anti - fraud system detect operation exceed fix limit $$$ m $$$ euros operations check manually a number <unknown> thus fraud operation exceed limit detect smaller operation get <unknown> gustaw n't know limit $$$ m $$$ want find one operation choose integer $$$ x $$$ try move $$$ x $$$ euros bank 's reserve account , follow happen initially gustaw $$$ 1 $$$ euro account help find exact value $$$ m $$$ $$$ 105 $$$ operations without get fire test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) test case input <unknown> first query sure $$$ m $$$ integer $$$ 0 \le m \le 10^ { 14 } $$$ test case know exact value $$$ m $$$ print a single line format ` ` ! $$$ m $$$ ` ` program proceed next test case terminate last one want make operation print a single line format ` ` ? $$$ x $$$ ` ` denote try move $$$ x $$$ euros ( $$$ 1 \le x \le 10^ { 14 } $$$ ) a response read a single line take follow value : make $$$ 105 $$$ query test case print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto make a hack prepare input follow format first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case describe a line contain a single integer $$$ m $$$ ( $$$ 0 \le m \le 10^ { 14 } $$$ ) example $$$ m = 5 $$$ operation $$$ x = 6 $$$ detect moment gustaw 's balance $$$ 16 $$$ euros pay fine",['binary search'],3200.0
1486/C2,"difference easy hard version limit number query interactive problem array $$$ a $$$ $$$ n $$$ different number one query ask position second maximum element a subsegment $$$ a [ l .. r ] $$$ find position maximum element array 20 query a subsegment $$$ a [ l .. r ] $$$ elements $$$ a_l a _ { l + 1 } ... a_r $$$ ask subsegment give position second maximum subsegment whole array first line contain a single integer $$$ n $$$ $$$ ( 2 \leq n \leq 100000 ) $$$ — number elements array ask query print ` ` ? $$$ l $$$ $$$ r $$$ ` ` $$$ ( 1 \leq l < r \leq n ) $$$ answer index second maximum elements $$$ a_l a _ { l + 1 } ... a_r $$$ array $$$ a $$$ fix beforehand ca n't change time interaction output answer print ` ` ! $$$ p $$$ ` ` $$$ p $$$ index maximum element array ask 20 query print answer n't count a query print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto make a hack use follow test format first line output a single integer $$$ n $$$ $$$ ( 2 \leq n \leq 100000 ) $$$ second line output a permutation $$$ n $$$ integers $$$ 1 $$$ $$$ n $$$ position $$$ n $$$ permutation position maximumin sample suppose $$$ a $$$ $$$ [ 5 1 4 2 3 ] $$$ ask $$$ [ 1 .. 5 ] $$$ subsegment $$$ 4 $$$ second max value 's position $$$ 3 $$$ ask $$$ [ 4 .. 5 ] $$$ subsegment $$$ 2 $$$ second max value 's position whole array $$$ 4 $$$ note array $$$ a $$$ would produce interaction answer might different example output give purpose understand interaction",['binary search'],1900.0
1764/G3,"difference problem two versions maximum number query version allow ask $$$ \mathbf { 20 } $$$ query make hack versions problem solve interactive problem . ` ` everybody ! doremy 's perfect data structure class start ! come best want much iq ! '' today 's data structure class doremy teach everyone a powerful data structure — doremy tree ! give a quiz prove pay attention class give array $$$ a $$$ length $$$ m $$$ doremy tree support query $$$ q ( l r k ) $$$ $$$ 1 \leq l \leq r \leq m $$$ $$$ 1 \leq k \leq m $$$ return number distinct integers array $$$ \left [ \lfloor\frac { a_l } { k } \rfloor \lfloor\frac { a _ { l+1 } } { k } \rfloor \ldots \lfloor\frac { a_r } { k } \rfloor\right ] $$$ doremy a secret permutation $$$ p $$$ integers $$$ 1 $$$ $$$ n $$$ make query one query give $$$ 3 $$$ integers $$$ l r k $$$ ( $$$ 1 \leq l \leq r \leq n $$$ $$$ 1 \leq k \leq n $$$ ) receive value $$$ q ( l r k ) $$$ array $$$ p $$$ find index $$$ y $$$ ( $$$ 1 \leq y \leq n $$$ ) $$$ p_y=1 $$$ $$$ \mathbf { 20 } $$$ query ? note permutation $$$ p $$$ fix query make begin interaction read integer $$$ n $$$ ( $$$ 3 \le n \le 1024 $$$ ) first line — length permutation make a query output give answer output print a query answer forget output end line flush output otherwise get idleness limit exceed , use : hack formatthe first line hack contain integer $$$ n $$$ ( $$$ 3 \le n \le 1024 $$$ ) — length permutation second line hack contain $$$ n $$$ distinct integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i\le n $$$ ) — permutation permutation example $$$ [ 3,5,2,1,4 ] $$$ input output example illustrate possible interaction test ( empty line insert clarity ) interaction process : correct answer get $$$ 4 $$$ query process judge correct",['binary search'],3300.0
1764/G1,"difference problem two versions maximum number query version allow ask $$$ \mathbf { 30 } $$$ query make hack versions problem solve interactive problem . ` ` everybody ! doremy 's perfect data structure class start ! come best want much iq ! '' today 's data structure class doremy teach everyone a powerful data structure — doremy tree ! give a quiz prove pay attention class give array $$$ a $$$ length $$$ m $$$ doremy tree support query $$$ q ( l r k ) $$$ $$$ 1 \leq l \leq r \leq m $$$ $$$ 1 \leq k \leq m $$$ return number distinct integers array $$$ \left [ \lfloor\frac { a_l } { k } \rfloor \lfloor\frac { a _ { l+1 } } { k } \rfloor \ldots \lfloor\frac { a_r } { k } \rfloor\right ] $$$ doremy a secret permutation $$$ p $$$ integers $$$ 1 $$$ $$$ n $$$ make query one query give $$$ 3 $$$ integers $$$ l r k $$$ ( $$$ 1 \leq l \leq r \leq n $$$ $$$ 1 \leq k \leq n $$$ ) receive value $$$ q ( l r k ) $$$ array $$$ p $$$ find index $$$ y $$$ ( $$$ 1 \leq y \leq n $$$ ) $$$ p_y=1 $$$ $$$ \mathbf { 30 } $$$ query ? note permutation $$$ p $$$ fix query make begin interaction read integer $$$ n $$$ ( $$$ 3 \le n \le 1024 $$$ ) first line — length permutation make a query output give answer output print a query answer forget output end line flush output otherwise get idleness limit exceed , use : hack formatthe first line hack contain integer $$$ n $$$ ( $$$ 3 \le n \le 1024 $$$ ) — length permutation second line hack contain $$$ n $$$ distinct integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i\le n $$$ ) — permutation permutation example $$$ [ 3,5,2,1,4 ] $$$ input output example illustrate possible interaction test ( empty line insert clarity ) interaction process : correct answer get $$$ 4 $$$ query process judge correct",['binary search'],2900.0
1479/A,"interactive problem homer like array a lot want play a game homer hide a permutation $$$ a_1 a_2 \dots a_n $$$ integers $$$ 1 $$$ $$$ n $$$ ask find index $$$ k $$$ ( $$$ 1 \leq k \leq n $$$ ) a local minimum array $$$ a_1 a_2 \dots a_n $$$ index $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) say a local minimum $$$ a_i < \min\ { a _ { i-1 } a _ { i+1 } \ } $$$ $$$ a_0 = a _ { n+1 } = + <unknown> $$$ array say a permutation integers $$$ 1 $$$ $$$ n $$$ contain integers $$$ 1 $$$ $$$ n $$$ exactly initially give value $$$ n $$$ without information permutation interactive step allow choose $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) make a query a response give value $$$ a_i $$$ ask find index $$$ k $$$ a local minimum $$$ 100 $$$ query begin interaction read integer $$$ n $$$ ( $$$ 1\le n \le 100000 $$$ ) a separate line make a query index $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) output ` ` ? $$$ i $$$ ` ` a separate line read value $$$ a_i $$$ a separate line number ` ` ? '' query limit within $$$ 100 $$$ find index $$$ k $$$ ( $$$ 1 \leq k \leq n $$$ ) a local minimum output ` ` ! $$$ k $$$ ` ` a separate line terminate program case query format invalid make $$$ 100 $$$ ` ` ? '' query receive wrong answer verdict print a query forget output end line flush output otherwise get idleness limit exceed , use : hack formatthe first line hack contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) second line contain $$$ n $$$ distinct integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) example first line contain integer $$$ 5 $$$ indicate length array $$$ n = 5 $$$ example make five ` ` ? '' query <unknown> array $$$ a = [ <unknown> ] $$$ $$$ k = 3 $$$ local minimum",['binary search'],1700.0
1428/H,"interactive problem prevent mischievous rabbit freely roam around zoo <unknown> set a special lock rabbit <unknown> lock call <unknown> laser lock lock consist $$$ n $$$ concentric ring number $$$ 0 $$$ $$$ n-1 $$$ <unknown> ring ring $$$ 0 $$$ <unknown> ring ring $$$ n-1 $$$ ring split equally $$$ nm $$$ section ring contain a single <unknown> arc cover exactly $$$ m $$$ contiguous section center ring a core surround entire lock $$$ nm $$$ receivers align $$$ nm $$$ section core $$$ nm $$$ lasers shine <unknown> center one section lasers block arc a display outside lock show many lasers hit <unknown> receivers example $$$ n=3 $$$ ring cover $$$ <unknown> $$$ section arc color green ( ring $$$ 0 $$$ ) purple ( ring $$$ 1 $$$ ) blue ( ring $$$ 2 $$$ ) lasers <unknown> show red $$$ <unknown> $$$ section $$$ 3 $$$ lasers block arc thus display show $$$ 3 $$$ case wabbit try open lock free rabbit lock completely <unknown> see arc give relative position arc wabbit open lock precise wabbit need $$$ n-1 $$$ integers $$$ p_1 p_2 \ldots p _ { n-1 } $$$ satisfy $$$ 0 \leq p_i < nm $$$ $$$ i $$$ $$$ ( 1 \leq i < n ) $$$ wabbit rotate ring $$$ 0 $$$ clockwise exactly $$$ p_i $$$ time section ring $$$ 0 $$$ cover perfectly align section ring $$$ i $$$ cover example relative position $$$ p_1 = 1 $$$ $$$ p_2 = 7 $$$ operate lock pick $$$ n $$$ ring rotate $$$ 1 $$$ section either clockwise anti - clockwise see number display every rotation <unknown> small wabbit ask help find relative position arc rotations complete may perform $$$ <unknown> $$$ rotations wabbit get impatient first line consist 2 integers $$$ n $$$ $$$ m $$$ $$$ ( 2 \leq n \leq 100 2 \leq m \leq 20 ) $$$ indicate number ring number section ring cover perform a rotation print a single line ` ` ? x d '' $$$ x $$$ $$$ ( 0 \leq x < n ) $$$ ring wish rotate $$$ d $$$ $$$ ( d \in \ { <unknown> } ) $$$ direction would like rotate $$$ <unknown> $$$ indicate a clockwise rotation $$$ 1 $$$ section $$$ <unknown> $$$ indicate <unknown> rotation $$$ 1 $$$ section query receive a single integer $$$ a $$$ : number lasers block arc rotation perform figure relative position arc print ! follow $$$ n-1 $$$ integers $$$ p_1 p_2 \ldots p _ { n-1 } $$$ note position ring predetermine test case wo n't change interaction process print a query forget output end line flush output otherwise get idleness limit exceed verdict , use : hack : hack use follow format test : first line contain two integers $$$ n $$$ $$$ m $$$ next line contain $$$ n-1 $$$ integers $$$ p_1 p_2 \ldots p _ { n-1 } $$$ : relative position ring $$$ 1,2 \ldots n-1 $$$ first test configuration show picture statement first rotation ( rotate ring $$$ 0 $$$ clockwise $$$ 1 $$$ section ) obtain follow configuration : second rotation ( rotate ring $$$ 2 $$$ counter - clockwise $$$ 1 $$$ section ) obtain follow configuration : third rotation ( rotate ring $$$ 1 $$$ clockwise $$$ 1 $$$ section ) obtain follow configuration : rotate ring $$$ 0 $$$ clockwise see section ring $$$ 0 $$$ cover section ring $$$ 1 $$$ cover hence $$$ <unknown> $$$ rotate ring $$$ 0 $$$ clockwise five time section ring $$$ 0 $$$ cover section ring $$$ 2 $$$ cover hence $$$ <unknown> $$$ note make a different set rotations end different value $$$ p_1 $$$ $$$ p_2 $$$ end",['binary search'],3500.0
1773/H,interactive problem <unknown> another country little hanna come across fact play ` ` hot cold '' become difficult : understand hint phrase ! write a help program <unknown> game happen a rectangle treasure hide point integer coordinate 0 $$$ 1000000 $$$ inclusive hanna visit several point valid coordinate visit point contain hide treasure receive phrase ` ` find ! '' local language fortunately <unknown> allow recognize phrase — problem denote exclamation mark otherwise visit point except first one hanna receive a phrase local language state whether ` ` closer '' ` ` '' ` ` distance '' treasure compare previous point distance measure euclidean metric first visit point case treasure hanna receive phrase ` ` find '' local language program must help hanna find treasure visit 64 point program print visit point a line two coordinate 0 $$$ 1000000 $$$ inclusive flush output one visit point test system write one phrase : ` ` find ! ` ` ` ` closer '' ` ` '' ` ` distance '' ` ` find '' language consistent throughout game first phrase end exclamation mark phrase contain exclamation mark phrase contain latin letter space exclamation mark lengths 2 30 inclusive n't start end a space pairwise distinct phrase necessarily come real human language receive a phrase exclamation mark program must halt without print anything else visit point allow visit count towards limit 64 query,['binary search'],2600.0
713/B,filya learn new geometry object — rectangle give a field consist n × n unit cells row number bottom top integer 1 n. columns number leave right integers 1 n. cell locate intersection row r column c denote ( r c ) filya paint two rectangles side parallel coordinate ax cell lie fully inside fully outside moreover cell lie rectangles later hedgehog filya become interest location rectangles unable find sheet paper paint take sonya want play a little game filya tell a query rectangle reply number initial rectangles lie fully inside give query rectangle query rectangle match condition initial rectangles rectangle lie fully inside query o cells lie inside query filya know sonya really well sure ask 200 question stop reply first line input contain integer n ( 2 ≤ n ≤ 216 ) — size field query integer 0 2 return — number initial rectangles lie fully inside query rectangle make a query print ` ` ? x1 y1 x2 y2 '' ( without quote ) ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ n ) ( x1 y1 ) stand position bottom leave cell query ( x2 y2 ) stand right cell query allow ask 200 query query perform ` ` flush '' operation read answer case suppose ' ve already determine location two rectangles ( run query ) print ` ` ! <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> '' ( without quote ) first four integers describe bottom leave right cells first rectangle follow four describe correspond cells second rectangle print rectangles arbitrary order print answer print end line perform ` ` flush '' program terminate immediately print answer flush use ( print integer end - of - line ) : get wrong answer verdict ask 200 query print incorrect coordinate get idleness limit exceed verdict n't print anything ( ) forget flush output ( info ) hack first line contain integer n ( 2 ≤ n ≤ 216 ) second line contain four integers x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ n ) — description first rectangle third line contain description second rectangle similar way,['binary search'],2200.0
1386/A,linda like change hair color time time would please <unknown> archie would notice difference previous new color archie always comment linda 's hair color notice a difference — linda always know whether archie spot difference a new hair dye series market available color number integers $$$ 1 $$$ $$$ n $$$ a smaller difference numerical value also mean less visual difference linda assume series critical color difference $$$ c $$$ ( $$$ 1 \le c \le n $$$ ) archie notice color difference current color $$$ \mathrm { color } _ { \mathrm { new } } $$$ previous color $$$ \mathrm { color } _ { \mathrm { prev } } $$$ $$$ \left|\mathrm { color } _ { \mathrm { new } } - \mathrm { color } _ { \mathrm { prev } } \right| \ge c $$$ $$$ \left|\mathrm { color } _ { \mathrm { new } } - \mathrm { color } _ { \mathrm { prev } } \right| < c $$$ buy $$$ n $$$ set hair dye new series — one color $$$ 1 $$$ $$$ n $$$ ready set experiment linda change hair color a regular <unknown> observe archie 's reaction — whether notice color change since proper dye set use completely hair color obtain experiment linda use a dye a different series <unknown> new one <unknown> experiment archie 's reaction first use color <unknown> aim find precise value $$$ c $$$ a limit number dye write a program find value $$$ c $$$ experiment give $$$ n $$$ color observe archie 's <unknown> color change interactive task begin give a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) number case test test case input first contain a single integer — value $$$ n $$$ ( $$$ 1 < n \le 10^ { 18 } $$$ ) value $$$ c $$$ keep secret grade system program make query write output follow format : ` ` ? $$$ p $$$ ` ` $$$ p $$$ integer ( $$$ 1 \le p \le n $$$ ) denote next color use query grade system give answer next line input answer $$$ 1 $$$ archie notice color difference last two color $$$ 0 $$$ otherwise two query $$$ p $$$ value program determine $$$ c $$$ output value follow format : ` ` = $$$ c $$$ ` ` grade system respond output proceed next test case program may use 64 query ` ` ? '' test case find correct value $$$ c $$$ establish proper communication program grade system flush output stream query note <unknown> : : <unknown> write a newline flush stream possible receive ` ` output n't correct '' outcome even print a correct answer task constraints violate communication violate communication protocol may result ` ` execution kill '' outcome submit user test require specify input file testcase parameters format input file ` ` $$$ t $$$ ` ` first line ` ` $$$ n $$$ $$$ c $$$ ` ` a single line $$$ t $$$ case subtasks : comment example input line line :,['binary search'],2700.0
1354/G,interactive problem n't forget flush output print query use <unknown> ( ) fflush ( stdout ) c++ similar function program languages $$$ n $$$ gift box a row number $$$ 1 $$$ $$$ n $$$ leave right 's know exactly $$$ k $$$ contain valuable gift — box contain lucky stone box look differ weight box stone weight strictly heavier box valuable items valuable gift may different box valuable items may different weight ask $$$ 50 $$$ query ( print answer n't count ) query compare total weight two non - intersecting subsets box $$$ a_1 a_2 \dots a _ { k_a } $$$ $$$ b_1 b_2 \dots b _ { k_b } $$$ return 'll get one four result : use query ( maybe intuition ) find box a valuable gift minimum index input consist several case begin receive integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case begin test case receive two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 1000 $$$ $$$ 1 \le k \le \frac { n } { 2 } $$$ ) — number box a row number box valuable gift 's guarantee order box fix beforehand sum $$$ n $$$ one test n't exceed $$$ 1000 $$$ test case print minimum index among box a valuable gift follow format : ` ` ! $$$ x $$$ ` ` $$$ x $$$ ( $$$ 1 \le x \le n $$$ ) — index box print query three line first line print size subset follow format : ` ` ? $$$ k_a $$$ $$$ k_b $$$ ` ` $$$ k_a $$$ $$$ k_b $$$ ( $$$ 1 \le k_a k_b \le n $$$ ; $$$ k_a + k_b \le n $$$ ) — correspond size second line print $$$ k_a $$$ integers $$$ a_1 a_2 \dots a _ { k_a } $$$ ( $$$ 1 \le a_i \le n $$$ ; $$$ a_i \neq a_j $$$ $$$ i \neq j $$$ ) — index box first subset third line print $$$ k_b $$$ integers $$$ b_1 b_2 \dots b _ { k_b } $$$ ( $$$ 1 \le b_i \le n $$$ ; $$$ b_i \neq b_j $$$ $$$ i \neq j $$$ ) — index box second subset subsets n't intersect i. e. $$$ a_i \neq b_j $$$ $$$ i $$$ $$$ j $$$ 'll receive one four responses describe case waste stop program avoid get random verdict instead wrong answer additional <unknown> ` ` – '' sample use increase <unknown> sample n't print unnecessary symbols line break solution send system hack forbid task,['binary search'],2600.0
1039/B,"interactive problem wonderful metropolis future need subway train drivers due <unknown> progress replace <unknown> intelligence ( ai ) unfortunately one day predictions <unknown> - fi <unknown> come true : ai rebel <unknown> train subway dangerous ! task find train stop ai subway metropolis one line ( regular straight line self - intersections ) $$$ n $$$ station index consecutively $$$ 1 $$$ $$$ n $$$ moment train station need determine index station train would secure find train <unknown> <unknown> give a gadget allow select arbitrary number $$$ l $$$ $$$ r $$$ ( $$$ l \le r $$$ ) check whether train locate a station index $$$ l $$$ $$$ r $$$ inclusive unfortunately <unknown> gadget take time ( every time use soon possible ) two applications gadget train move station $$$ k $$$ station away formally train station $$$ x $$$ gadget apply next application gadget train appear station $$$ y $$$ $$$ \max ( 1 x - k ) \leq y \leq \min ( n x + k ) $$$ note ai aware try catch train make move accord <unknown> plan <unknown> gadget find old hold $$$ 4500 $$$ applications break mission consider a <unknown> find station train use $$$ 4500 $$$ applications <unknown> ? first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 10^ { 18 } $$$ $$$ 0 \leq k \leq 10 $$$ ) — number station maximum number station train move two applications gadget apply gadget $$$ 4500 $$$ time order apply gadget need print two space - separated integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l \leq r \leq n $$$ ) receive either string ` ` yes '' train station $$$ l $$$ $$$ r $$$ inclusive string ` ` '' otherwise $$$ l = r $$$ receive ` ` yes '' find train successfully program must halt immediately answer ` ` bad '' instead ` ` yes '' ` ` '' mean make invalid query make many query exit immediately receive ` ` bad '' see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksin order hack present a test follow format first line contain three integers $$$ n $$$ $$$ k $$$ $$$ p $$$ ( $$$ 1 \le n \le 10^ { 18 } $$$ $$$ 0 \le k \le 10 $$$ $$$ 1 \le p \le n $$$ ) — number station maximum number station train move two applications gadget initial position train respectively next $$$ 4500 $$$ line contain a single integer $$$ x $$$ ( $$$ 1 \le x \le n $$$ ) — position train query two consecutive position ( include initial one ) differ $$$ k $$$ example follow line first line sample test first sample train initially station $$$ 5 $$$ first application gadget move second application move station $$$ 3 $$$ third application move station $$$ 5 $$$",['binary search'],2100.0
1019/B,interactive problem imur <unknown> decide organize a club people love play famous game « hat » club visit n students n even imur arrange a circle hold a draw break students pair something go wrong participants number participant i participant i + 1 ( 1 ≤ i ≤ n - 1 ) adjacent well participant n participant 1 . student give a piece paper a number a way every two adjacent students number differ exactly one plan form students number a pair turn number appear exactly twice know convenient explain word <unknown> sit exactly across students number i sit across imur wonder two people sit across number give help find pair people exist ask question form « number receive student i ? » goal determine whether desire pair exist 60 question begin even integer n ( 2 ≤ n ≤ 100 000 ) give — total number students allow ask 60 question ask question student i ( 1 ≤ i ≤ n ) print « ? i » standard output read number ai receive student i ( - 109 ≤ ai ≤ 109 ) find desire pair print « ! i » i student belong pair ( 1 ≤ i ≤ n ) determine pair n't exist output « ! -1 » case immediately terminate program query contain answer count towards limit 60 query please make sure flush standard output command example c++ use function fflush ( stdout ) java call system.out.flush ( ) pascal use flush ( output ) stdout.flush ( ) python language hackinguse follow format hack : first line print one even integer n ( 2 ≤ n ≤ 100 000 ) — total number students second line print n integers ai ( - 109 ≤ ai ≤ 109 ) separate space ai number give i - th student two adjacent elements include n 1 must differ 1 - 1 . hack solution direct access sequence ai input - output statements illustrate example interaction first sample select sequence 1 2 1 2 3 4 3 2 in second sample selection sequence 1 2 3 2 1 0,['binary search'],2000.0
1010/B,"interactive problem natasha go fly mar finally natasha sit rocket fly fly ... get bore wish arrive mar already ! decide find something occupy could n't think anything better calculate distance red planet let 's define $$$ x $$$ distance mar unfortunately natasha know $$$ x $$$ know $$$ 1 \le x \le m $$$ natasha know number $$$ m $$$ besides $$$ x $$$ $$$ m $$$ positive integers natasha ask rocket question every question integer $$$ y $$$ ( $$$ 1 \le y \le m $$$ ) correct answer question $$$ -1 $$$ $$$ x < y $$$ $$$ 0 $$$ $$$ x = y $$$ $$$ 1 $$$ $$$ x > y $$$ rocket break — always answer correctly precisely : let correct answer current question equal $$$ t $$$ , rocket answer question correctly answer $$$ t $$$ otherwise answer $$$ <unknown> $$$ addition rocket a sequence $$$ p $$$ length $$$ n $$$ element sequence either $$$ 0 $$$ $$$ 1 $$$ rocket process sequence cyclic order $$$ 1 $$$ -st element $$$ 2 $$$ -nd $$$ 3 $$$ -rd $$$ \ldots $$$ $$$ ( n-1 ) $$$ -th $$$ n $$$ -th $$$ 1 $$$ -st $$$ 2 $$$ -nd $$$ 3 $$$ -rd $$$ \ldots $$$ $$$ ( n-1 ) $$$ -th $$$ n $$$ -th $$$ \ldots $$$ current element $$$ 1 $$$ rocket answer correctly $$$ 0 $$$ — lie natasha n't know sequence $$$ p $$$ know length — $$$ n $$$ ask rocket $$$ 60 $$$ question help natasha find distance mar assume distance mar change natasha ask question solution accept receive answer $$$ 0 $$$ rocket ( even distance mar uniquely determine already receive rocket 's answer ) first line contain two integers $$$ m $$$ $$$ n $$$ ( $$$ 1 \le m \le 1000000000 $$$ $$$ 1 \le n \le 30 $$$ ) — maximum distance mar number elements sequence $$$ p $$$ ask rocket $$$ 60 $$$ question ask a question print a number $$$ y $$$ ( $$$ 1\le y\le m $$$ ) end - of - line character operation flush read answer question program read $$$ 0 $$$ distance correct must immediately terminate program ( example call exit ( 0 ) ) ignore get verdict since program continue read close input stream point program read $$$ -2 $$$ answer must immediately end ( example call exit ( 0 ) ) receive ` ` wrong answer '' verdict mean request incorrect number request exceed $$$ 60 $$$ ignore get verdict since program continue read close input stream program 's request a valid integer $$$ <unknown> { 31 } $$$ $$$ 2^ { 31 } -1 $$$ ( inclusive ) without lead zero get verdict get ` ` idleness limit exceed '' n't print anything forget flush output flush output buffer use ( print a query end - of - line ) : hackinguse follow format hack : first line print $$$ 3 $$$ integers $$$ m n x $$$ ( $$$ 1\le x\le m\le 1000000000 $$$ $$$ 1\le n\le 30 $$$ ) — maximum distance mar number elements sequence $$$ p $$$ current distance mar second line enter $$$ n $$$ number equal $$$ 0 $$$ $$$ 1 $$$ — sequence $$$ p $$$ hack solution access number $$$ x $$$ sequence $$$ p $$$ example hack would look like <unknown> 2 31 <unknown> mean current distance mar equal $$$ 3 $$$ natasha know exceed $$$ 5 $$$ rocket answer order : correctly incorrectly correctly incorrectly ... really : first query ( $$$ 1 $$$ ) correct answer $$$ 1 $$$ rocket answer correctly : $$$ 1 $$$ ; second query ( $$$ 2 $$$ ) correct answer $$$ 1 $$$ rocket answer incorrectly : $$$ -1 $$$ ; third query ( $$$ 4 $$$ ) correct answer $$$ -1 $$$ rocket answer correctly : $$$ -1 $$$ ; fourth query ( $$$ 5 $$$ ) correct answer $$$ -1 $$$ rocket answer incorrectly : $$$ 1 $$$ ; fifth query ( $$$ 3 $$$ ) correct incorrect answer $$$ 0 $$$",['binary search'],1800.0
1007/C,interactive problem vasya vitya play a game vasya think two integers $$$ a $$$ $$$ b $$$ $$$ 1 $$$ $$$ n $$$ vitya try guess round tell vasya two number $$$ x $$$ $$$ y $$$ $$$ 1 $$$ $$$ n $$$ $$$ x = a $$$ $$$ y = b $$$ vitya win else vasya must say one three phrase : vasya ca n't lie multiple phrase true may choose example vasya think number $$$ 2 $$$ $$$ 4 $$$ answer phrase $$$ 3 $$$ a query $$$ ( 3 4 ) $$$ answer phrase $$$ 1 $$$ phrase $$$ 3 $$$ a query $$$ ( 1 5 ) $$$ help vitya win $$$ 600 $$$ round first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 10^ { 18 } $$$ ) — upper limit number first need read number $$$ n $$$ make query make a query print two integers : $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq x y \leq n $$$ ) flush output query read a single integer $$$ ans $$$ ( $$$ 0 \leq ans \leq 3 $$$ ) $$$ ans > 0 $$$ number phrase say vasya $$$ ans = 0 $$$ mean win program terminate make $$$ 600 $$$ query make incorrect query get wrong answer solution get idleness limit exceed n't print anything forget flush output flush need follow right print a query a line end : hack <unknown> hack use follow format : first line print a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 10^ { 18 } $$$ ) — upper limit number second line print two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \leq a b \leq n $$$ ) — number vasya think third line print a single integer $$$ m $$$ ( $$$ 1 \leq m \leq 100000 $$$ ) — number instructions interactor next $$$ m $$$ line print five integers : $$$ x_i $$$ $$$ y_i $$$ $$$ r^ { 12 } _ i $$$ $$$ r^ { 13 } _ i $$$ $$$ r^ { 23 } _ i $$$ ( $$$ 1 \leq x_i y_i \leq n $$$ ) $$$ r^ { st } _ i $$$ equal either number $$$ s $$$ number $$$ t $$$ answer query $$$ <unknown> \ y $$$ interactor find a number $$$ i $$$ $$$ 1 $$$ $$$ n $$$ minimal value $$$ |x - x_i| + |y - <unknown> $$$ multiple number choose least $$$ i $$$ prefer interactor answer query two phrase $$$ s $$$ $$$ t $$$ give $$$ r^ { st } _ i $$$ choose example sample test data file contain follow : let 's analyze sample test choose number $$$ 2 $$$ $$$ 4 $$$ interactor give two instructions query $$$ ( 4 3 ) $$$ return $$$ 2 $$$ $$$ 3 $$$ two instructions second one choose interactor return $$$ a^ { 23 } _ <unknown> $$$ query $$$ ( 3 4 ) $$$ return $$$ 3 $$$ query $$$ ( 3 3 ) $$$ return $$$ 2 $$$ $$$ 3 $$$ two instructions first one choose ( since case equal value least number prefer ) interactor return $$$ a^ { 23 } _ <unknown> $$$ query $$$ ( 1 5 ) $$$ return $$$ 1 $$$ $$$ 3 $$$ two instructions first one choose interactor return $$$ a^ { 13 } _ <unknown> $$$ fifth query $$$ ( 2 4 ) $$$ number guess correctly player win,['binary search'],3000.0
1103/B,"interactive problem vasya petya go play follow game : petya positive integer number $$$ a $$$ vasya guess number use follow question say a pair non - negative integer number $$$ ( x y ) $$$ petya answer : define $$$ ( x \bmod a ) $$$ a remainder division $$$ x $$$ $$$ a $$$ vasya guess number $$$ a $$$ use 60 question 's guarantee petya a number satisfy inequality $$$ 1 \leq a \leq 1000000000 $$$ help vasya play game write a program guess number $$$ a $$$ program play several game start game program read string : read string ` ` start '' ( without quote ) new game start begin program ask several question pair non - negative integer number $$$ ( x y ) $$$ ask number satisfy inequalities $$$ 0 \leq x y \leq 2000000000 $$$ ask a question print ` ` ? x y '' ( without quote ) answer read one symbol : program ask several question program print answer form ` ` ! a '' ( without quote ) print number $$$ a $$$ satisfy inequalities $$$ 1 \leq a \leq 1000000000 $$$ 's guarantee petya 's number $$$ a $$$ satisfy condition , current game finish recall program ca n't ask $$$ 60 $$$ question one game program n't terminate read ` ` mistake '' ( without quote ) ` ` end '' ( without quote ) ` ` e '' ( without quote ) get verdict continue read close input also program print answer question incorrect format get verdict , careful n't forget flush output print question answer flush output use : 's guarantee play least $$$ 1 $$$ $$$ 100 $$$ game hack : hack use one game hack a solution petya 's number $$$ a $$$ ( $$$ 1 \leq a \leq 1000000000 $$$ ) first line write a single number $$$ 1 $$$ second line write a single number $$$ a $$$ first test play $$$ 3 $$$ game petya 's number $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ first game petya answer ` ` x '' ( without quote ) question $$$ ( x \bmod 1 ) = 0 $$$ integer $$$ x $$$ second game ask pair $$$ ( 0 0 ) $$$ answer ` ` x '' ( without quote ) $$$ ( 0 \bmod 2 ) \geq ( 0 \bmod 2 ) $$$ ask pair $$$ ( 2 5 ) $$$ answer ` ` y '' ( without quote ) $$$ ( 2 \bmod 2 ) < ( 5 \bmod 2 ) $$$ $$$ ( 2 \bmod 2 ) = 0 $$$ $$$ ( 5 \bmod 2 ) = 1 $$$",['binary search'],2000.0
835/E,pay attention : problem interactive penguin <unknown> come a new game recently n icicles number 1 n. <unknown> a temperature — integer 1 109 . exactly two icicles special : temperature y a temperature others x ≠ y. find special icicles choose a non - empty subset icicles ask penguin bitwise exclusive ( xor ) temperatures icicles subset note ca n't ask 19 question find special icicles first line contain three integers n x y ( 2 ≤ n ≤ 1000 1 ≤ x y ≤ 109 x ≠ y ) — number icicles temperature non - special icicles temperature special icicles give answer penguin print character ` ` ! '' ( without quote ) print two integers p1 p2 ( p1 < p2 ) — index special icicles ascend order note ` ` ! '' p1 separate a space ; index separate a space give answer program terminate immediately ask a question print character ` ` ? '' ( without quote ) integer c ( 1 ≤ c ≤ n ) c distinct integers p1 p2 ... pc ( 1 ≤ pi ≤ n ) — index icicles want know note ` ` ? '' c separate a space ; index separate a space ask question read a single integer — answer note ca n't ask 19 question ask 19 question least one incorrect question solution get ` ` wrong answer '' moment program read - 1 answer immediately exit ( example call exit ( 0 ) ) get ` ` wrong answer '' case mean ask 19 question ask invalid question ignore get verdicts since program continue read a close stream solution get ` ` idleness limit exceed '' n't print anything forget flush output include final answer flush use ( print ) : hackingfor hack use follow format : n x y p1 <unknown> 1 ≤ p1 < p2 ≤ n index special icicles contestant program able see input answer first question answer second third question 1 therefore special icicles index 1 3 . read bitwise xor operation : https : //en.wikipedia.org / wiki / bitwise_operation # xor,['binary search'],2400.0
1613/C,monocarp play yet another computer game game character kill a dragon battle dragon last $$$ <unknown> { 500 } $$$ second monocarp attack dragon a poison dagger $$$ i $$$ -th attack perform begin $$$ a_i $$$ -th second battle start dagger deal damage apply a poison effect dragon deal $$$ 1 $$$ damage next $$$ k $$$ second ( start second dragon stab dagger ) however dragon already poison dagger update poison effect ( i.e <unknown> current poison effect apply a new one ) example suppose $$$ k = 4 $$$ monocarp stab dragon second $$$ 2 $$$ $$$ 4 $$$ $$$ 10 $$$ poison effect apply start $$$ 2 $$$ -nd second deal $$$ 1 $$$ damage $$$ 2 $$$ -nd $$$ 3 $$$ -rd second ; begin $$$ 4 $$$ -th second poison effect <unknown> deal exactly $$$ 1 $$$ damage second $$$ 4 $$$ $$$ 5 $$$ $$$ 6 $$$ $$$ 7 $$$ ; $$$ 10 $$$ -th second poison effect apply deal $$$ 1 $$$ damage second $$$ 10 $$$ $$$ 11 $$$ $$$ 12 $$$ $$$ 13 $$$ total dragon receive $$$ 10 $$$ damage monocarp know dragon $$$ h $$$ hit point deal least $$$ h $$$ damage dragon battle — <unknown> dragon monocarp decide strength poison use battle want find minimum possible value $$$ k $$$ ( number second poison effect last ) enough deal least $$$ h $$$ damage dragon first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ h $$$ ( $$$ 1 \le n \le 100 ; 1 \le h \le 10^ { 18 } $$$ ) — number monocarp 's attack amount damage need deal second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le 1000000000 ; a_i < a _ { i + 1 } $$$ ) $$$ a_i $$$ second $$$ i $$$ -th attack perform test case print a single integer — minimum value parameter $$$ k $$$ monocarp cause least $$$ h $$$ damage dragon first example $$$ k=3 $$$ damage deal second $$$ [ 1 2 3 5 6 7 ] $$$ second example $$$ k=4 $$$ damage deal second $$$ [ 2 3 4 5 6 7 10 11 12 13 ] $$$ third example $$$ k=1 $$$ damage deal second $$$ [ 1 2 4 5 7 ] $$$,['binary search'],1200.0
1117/C,a captain a ship initially stand a point $$$ ( x_1 y_1 ) $$$ ( obviously position sea describe cartesian plane ) want travel a point $$$ ( x_2 y_2 ) $$$ know weather forecast — string $$$ s $$$ length $$$ n $$$ consist letter u d l r. letter correspond a direction wind moreover forecast periodic e.g first day wind blow side $$$ s_1 $$$ second day — $$$ s_2 $$$ $$$ n $$$ -th day — $$$ s_n $$$ $$$ ( n+1 ) $$$ -th day — $$$ s_1 $$$ ship coordinate change follow way : ship also either go one four directions stay place day go 's exactly 1 unit distance <unknown> ship wind add ship stay place direction wind count example wind blow direction u ship move direction l point $$$ ( x y ) $$$ move point $$$ ( x - 1 y + 1 ) $$$ go direction u move point $$$ ( x y + 2 ) $$$ task determine minimal number days require ship reach point $$$ ( x_2 y_2 ) $$$ first line contain two integers $$$ x_1 y_1 $$$ ( $$$ 0 \le x_1 y_1 \le 1000000000 $$$ ) — initial coordinate ship second line contain two integers $$$ x_2 y_2 $$$ ( $$$ 0 \le x_2 y_2 \le 1000000000 $$$ ) — coordinate destination point guarantee initial coordinate destination point coordinate different third line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length string $$$ s $$$ fourth line contain string $$$ s $$$ consist letter u d l r. line contain minimal number days require ship reach point $$$ ( x_2 y_2 ) $$$ 's impossible print ` ` -1 '' first example ship perform follow sequence move : ` ` <unknown> '' coordinate change accordingly : $$$ ( 0 0 ) $$$ $$$ \rightarrow $$$ $$$ ( 1 1 ) $$$ $$$ \rightarrow $$$ $$$ ( 2 2 ) $$$ $$$ \rightarrow $$$ $$$ ( 3 3 ) $$$ $$$ \rightarrow $$$ $$$ ( 4 4 ) $$$ $$$ \rightarrow $$$ $$$ ( 4 6 ) $$$ second example ship perform follow sequence move : ` ` <unknown> '' ( third day stay place ) coordinate change accordingly : $$$ ( 0 3 ) $$$ $$$ \rightarrow $$$ $$$ ( 0 3 ) $$$ $$$ \rightarrow $$$ $$$ ( 0 1 ) $$$ $$$ \rightarrow $$$ $$$ ( 0 0 ) $$$ third example ship never reach point $$$ ( 0 1 ) $$$,['binary search'],1900.0
925/F,vova recently learn a <unknown> a graph recall definition : let $$$ g = ( v e ) $$$ a direct graph a circulation $$$ f $$$ a collection non - negative real number $$$ f_e $$$ ( $$$ e \in e $$$ ) vertex $$$ v \in v $$$ follow conservation condition hold : $$$ $$$ \sum\limits _ { e \in \delta^ { - } ( v ) } f_e = \sum\limits _ { e \in \delta^ { + } ( v ) } f_e $$$ $$$ $$$ \delta^ { + } ( v ) $$$ set edge end vertex $$$ v $$$ $$$ \delta^ { - } ( v ) $$$ set edge start vertex $$$ v $$$ word vertex total incoming flow equal total <unknown> flow let a $$$ lr $$$ -circulation a circulation $$$ f $$$ edge condition $$$ l_e \leq f_e \leq r_e $$$ hold $$$ l_e $$$ $$$ r_e $$$ edge $$$ e \in e $$$ two non - negative real number denote lower upper bound value circulation edge $$$ e $$$ vova ca n't stop think applications a new topic right think follow natural question : let graph fix value $$$ l_e $$$ $$$ r_e $$$ a linear function a real variable $$$ t $$$ : $$$ $$$ l_e ( t ) = a_e t + b_e $$$ $$$ $$$ $$$ r_e ( t ) = c_e t + d_e $$$ $$$ note $$$ t $$$ edge let $$$ t $$$ choose random uniform distribution a segment $$$ [ 0 1 ] $$$ probability existence $$$ lr $$$ -circulation graph ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 1000 $$$ $$$ 1 \leq m \leq 2000 $$$ ) next $$$ m $$$ line describe edge graph format $$$ u_e $$$ $$$ v_e $$$ $$$ a_e $$$ $$$ b_e $$$ $$$ c_e $$$ $$$ d_e $$$ ( $$$ 1 \leq u_e v_e \leq n $$$ $$$ -10000 \leq a_e c_e \leq 10000 $$$ $$$ 0 \leq b_e d_e \leq 10000 $$$ ) $$$ u_e $$$ $$$ v_e $$$ startpoint endpoint edge $$$ e $$$ remain 4 integers describe linear function upper lower bind circulation guarantee $$$ t \in [ 0 1 ] $$$ edge $$$ e \in e $$$ follow condition hold $$$ 0 \leq l_e ( t ) \leq r_e ( t ) \leq 10000 $$$ print a single real integer — probability existence $$$ lr $$$ -circulation graph give $$$ t $$$ choose uniformly random segment $$$ [ 0 1 ] $$$ answer consider correct absolute difference jury 's answer greater $$$ 10^ { -6 } $$$ first example conservation condition allow <unknown> equal value $$$ f_e $$$ three edge value circulation last edge $$$ 4 $$$ whatever $$$ t $$$ choose probability $$$ $$$ p ( 4 \in [ 3 -4 t + 7 ] <unknown> & <unknown> \in [ -2 t + 5 t + 6 ] ) = 0.25 $$$ $$$,['binary search'],3100.0
925/A,year $$$ <unknown> $$$ participants world program championship live a single large hotel hotel $$$ n $$$ floor floor $$$ m $$$ section a single corridor connect section enumerate $$$ 1 $$$ $$$ m $$$ along corridor section equal number different floor locate exactly one thus hotel represent a rectangle height $$$ n $$$ width $$$ m $$$ denote section pair integers $$$ ( i j ) $$$ $$$ i $$$ floor $$$ j $$$ section number floor guests walk along corridor floor use stairs elevators stairs elevator occupy section $$$ ( 1 x ) $$$ $$$ ( 2 x ) $$$ $$$ \ldots $$$ $$$ ( n x ) $$$ $$$ x $$$ $$$ 1 $$$ $$$ m $$$ section occupy stairs elevators contain guest room take one time unit move neighbor section floor move one floor use stairs take one time unit move $$$ v $$$ floor direction use elevator assume n't wait elevator time need enter exit elevator negligible process $$$ q $$$ query query a question ` ` minimum time need go a room section $$$ ( x_1 y_1 ) $$$ a room section $$$ ( x_2 y_2 ) $$$ ? ` ` first line contain five integers $$$ n m c_l c_e v $$$ ( $$$ 2 \leq n m \leq 100000000 $$$ $$$ 0 \leq c_l c_e \leq 100000 $$$ $$$ 1 \leq c_l + c_e \leq m - 1 $$$ $$$ 1 \leq v \leq n - 1 $$$ ) — number floor section floor number stairs number elevators maximum speed elevator respectively second line contain $$$ c_l $$$ integers $$$ l_1 \ldots l _ { c_l } $$$ increase order ( $$$ 1 \leq l_i \leq m $$$ ) denote position stairs $$$ c_l = 0 $$$ second line empty third line contain $$$ c_e $$$ integers $$$ e_1 \ldots e _ { c_e } $$$ increase order denote elevators position format guarantee integers $$$ l_i $$$ $$$ e_i $$$ distinct fourth line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 100000 $$$ ) — number query next $$$ q $$$ line describe query line contain four integers $$$ x_1 y_1 x_2 y_2 $$$ ( $$$ 1 \leq x_1 x_2 \leq n $$$ $$$ 1 \leq y_1 y_2 \leq m $$$ ) — coordinate start finish section query guarantee start finish section distinct also guarantee section contain guest room i. e. $$$ y_1 $$$ $$$ y_2 $$$ among $$$ l_i $$$ $$$ e_i $$$ print $$$ q $$$ integers one per line — answer query first query optimal way go elevator 5 - th section four time units use go fifth floor two time units go destination one time unit second query still optimal use elevator third query better use stairs section 2,['binary search'],1600.0
774/L,"polycarp 's workday last exactly $$$ n $$$ minutes love chocolate bar eat one bar one minute today polycarp $$$ k $$$ bar begin workday minutes workday polycarp important things minutes able eat a chocolate bar minutes either eat eat one chocolate bar guarantee first last minutes workday polycarp important things always eat bar minutes <unknown> begin end workday also guarantee $$$ k $$$ strictly greater $$$ 1 $$$ task determine order eat chocolate bar maximum break time eat bar minimum possible consider polycarp eat a bar minute $$$ x $$$ next bar minute $$$ y $$$ ( $$$ x < y $$$ ) break time equal $$$ y - x - 1 $$$ minutes necessary polycarp eat bar first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 200\,000 $$$ $$$ 2 \le k \le n $$$ ) — length workday minutes number chocolate bar polycarp begin workday second line contain string length $$$ n $$$ consist zero ones $$$ i $$$ -th symbol string equal zero polycarp important things minute $$$ i $$$ eat a chocolate bar case polycarp busy minute $$$ i $$$ eat a chocolate bar guarantee first last character string equal zero polycarp always eat chocolate bar minutes print minimum possible break minutes eat chocolate bar first example polycarp eat chocolate bar second minute time break equal one minute second example polycarp eat bar minutes $$$ 1 $$$ $$$ 8 $$$ anyway also need eat chocolate bar minute $$$ 5 $$$ time maximum break equal $$$ 3 $$$ minutes",['binary search'],2000.0
587/D,"duff one head mafia country andarz gu andarz gu n cities ( number 1 n ) connect m bidirectional roads ( number 1 m ) road a destruct time a color i - th road connect cities vi ui color ci destruct time ti mafia want destruct a match andarz gu a match a subset roads two roads subset common endpoint destruct roads parallel i. e. total destruction time a maximum destruction time select roads want two condition satisfy : remain roads destruct match form a proper color two roads color endpoint , word edge color form a match programmer mafia 's duff ask help please help determine match destruct order satisfy condition ( state possible ) first line input contain two integers n m ( 2 ≤ n ≤ 5 × 104 1 ≤ m ≤ 5 × 104 ) number cities number roads country next m line contain roads i - th contain four integers vi ui ci ti ( 1 ≤ vi ui ≤ n vi ≠ ui 1 ≤ ci ti ≤ 109 1 ≤ i ≤ m ) first line input print ` ` yes '' ( without quote ) satisfy first condition possible ` ` '' ( without quote ) otherwise possible print two integers t k second line minimum destruct time number roads match ( ) third line print k distinct integers separate space indices roads match order roads number start one order appearance input 's one solution print graph andarz gu first sample case follow : a solution would destruct roads cross graph andarz gu second sample case follow :",['binary search'],3100.0
496/D,petya gena love play table <unknown> a single match play accord follow rule : a match consist multiple set set consist multiple serve serve one players player score one point soon one players score t point win set ; next set start score players set 0 . soon one players win total s set win match match s t positive integer number <unknown> petya gena choose new number s t every match besides sake history keep a record match : serve write winner serve winners record chronological order a record set soon one players score t point match soon one players win s set petya gena find a record old match unfortunately sequence serve record n't divide set number s t give match also lose players wonder value s t might determine possible options ? first line contain a single integer n — length sequence game ( 1 ≤ n ≤ 105 ) second line contain n space - separated integers ai ai = 1 i - th serve petya ai = 2 i - th serve gena guarantee least one option number s t correspond give record first line print a single number k — number options number s t. follow k line print two integers si ti — option number s t. print options order increase si equal si — order increase ti,['binary search'],1900.0
177/E2,smart beaver abbyy plan a space travel <unknown> spaceship voyage plan visit n planets planet i ai maximum number suitcases alien tourist allow bring planet bi number citizens planet smart beaver go bring present abbyy planets visit present pack suitcases x present beaver take ship exactly a1 + ... + suitcases beaver land i - th planet take ai suitcases go first day planet beaver take a walk get know citizens second subsequent days beaver give present citizens — bi citizens get one present per day beaver leave planet even day number present leave strictly less number citizens ( i.e soon wo n't able give away proper number present next day ) leave remain present hotel beaver go spend exactly c days travel time spend flight planets consider zero many ways one choose positive integer x plan voyage take exactly c days ? first input line contain space - separated integers n c — number planets beaver go visit number days go spend travel correspondingly next n line contain pair space - separated integers ai bi ( 1 ≤ i ≤ n ) — number suitcases bring i - th planet number citizens i - th planet correspondingly input limitations get 30 point : input limitations get 100 point : due possible overflow recommend use 64 - bit arithmetic solutions even 64 - bit arithmetic overflow careful calculations ! print a single number k — number ways choose x travel exactly c days infinitely many possible value x print -1 . please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first example one suitable value x = 5 . beaver take 1 <unknown> 5 present first planet spend 2 days : hang around first day give away five present second day take 2 suitcases 10 present second planet spend 3 days — give away 4 present second third days leave remain 2 present hotel total beaver spend 5 days travel x = 4 less beaver wo n't enough present second day first planet voyage end soon x = 6 beaver spend least one day second planet voyage take long,['binary search'],1900.0
163/B,"know lemmings like jump next <unknown> group jump n lemmings gather near a high rock k comfortable ledges first ledge situate height h meter second one height 2h meter ( i - th ledge height <unknown> meter ) lemmings go jump <unknown> 's much time leave lemming characterize climb speed vi meter per minute weight mi mean i - th lemming climb j - th ledge minutes make jump beautiful heavier lemmings jump higher ledges : a lemming weight mi jump ledge i a lemming weight mj jump ledge j ( i < j ) inequation mi ≤ mj fulfil since n lemmings k ledges ( k ≤ n ) k lemmings take part jump need choose choose lemmings distribute ledges 1 k one lemming per ledge lemmings arrange order non - decreasing weight increase height ledge addition lemming enough time get ledge , time climb exceed t minutes lemmings climb ledges time interfere find way arrange lemmings ' jump time t minimize first line contain space - separated integers n k h ( 1 ≤ k ≤ n ≤ 105 1 ≤ h ≤ 104 ) — total number lemmings number ledges distance adjacent ledges second line contain n space - separated integers m1 m2 ... <unknown> ( 1 ≤ mi ≤ 109 ) mi weight i - th lemming third line contain n space - separated integers v1 v2 ... <unknown> ( 1 ≤ vi ≤ 109 ) vi speed i - th lemming print k different number 1 n — number lemmings go ledges heights h 2h ... <unknown> correspondingly jump organize optimal way multiple ways select lemmings pick let 's consider first sample case fifth lemming ( speed 10 ) get ledge height 2 minutes ; second lemming ( speed 2 ) get ledge height 4 2 minutes ; fourth lemming ( speed 2 ) get ledge height 6 3 minutes lemmings manage occupy position 3 minutes",['binary search'],2000.0
975/C,"ivar <unknown> a great leader try capture <unknown> lagertha war begin wave wave ivar 's warriors fall battle ivar $$$ n $$$ warriors place a straight line front main gate a way $$$ i $$$ -th warrior stand right $$$ ( i-1 ) $$$ -th warrior first warrior lead attack <unknown> take $$$ a_i $$$ arrows fall grind $$$ a_i $$$ $$$ i $$$ -th warrior 's strength lagertha order warriors shoot $$$ k_i $$$ arrows $$$ i $$$ -th minute arrows one one hit first still stand warrior ivar 's warriors fall currently fly arrows fly thor <unknown> <unknown> ivar 's warriors get previous strengths back stand fight word warriors die minute $$$ t $$$ stand fight end minute $$$ t $$$ battle last $$$ q $$$ minutes minute tell ivar number stand warriors first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n q \leq 200\,000 $$$ ) — number warriors number minutes battle second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) represent warriors ' strengths third line contain $$$ q $$$ integers $$$ k_1 k_2 \ldots k_q $$$ ( $$$ 1 \leq k_i \leq 10^ { 14 } $$$ ) $$$ i $$$ -th represent lagertha 's order $$$ i $$$ -th minute : $$$ k_i $$$ arrows attack warriors output $$$ q $$$ line $$$ i $$$ -th number stand warriors $$$ i $$$ -th minute first example :",['binary search'],1400.0
24/E,recently construction berland collider complete collider represent a long narrow tunnel contain n particles associate collider 1 - dimensional coordinate system go leave right particle know coordinate velocity moment start collider velocities particles n't change launch collider berland scientists think big bang happen first collision particles whose velocities differ directions help determine much time elapse launch collider big bang happen first line contain single integer n ( 1 ≤ n ≤ 5·105 ) — amount particles collider next n line contain description particles particle describe two integers xi vi ( - 109 ≤ xi vi ≤ 109 vi ≠ 0 ) — coordinate velocity respectively coordinate distinct particles list order increase coordinate coordinate meter velocities — meter per second negative velocity mean start collider particle move leave positive — particle move right big bang output -1 . otherwise output one number — much time second elapse launch collider big bang happen answer must a relative absolute error less 10 - 9,['binary search'],2300.0
68/B,"well know planet suffer energy crisis little petya n't like want save world purpose need every accumulator contain amount energy initially every accumulator amount energy : i - th accumulator ai units energy energy transfer one accumulator every time x units energy transfer ( x necessarily integer ) k percent lose , x units transfer one accumulator amount energy first one decrease x units increase units task help petya find maximum equal amount energy store accumulator transfer first line input contain two integers n k ( 1 ≤ n ≤ 10000 0 ≤ k ≤ 99 ) — number accumulators percent energy lose transfer next line contain n integers a1 a2 ... — amount energy first second .. n - th accumulator respectively ( 0 ≤ ai ≤ 1000 1 ≤ i ≤ n ) output maximum possible amount energy remain accumulators transfer energy absolute relative error answer exceed 10 - 6",['binary search'],1600.0
1066/D,maksim $$$ n $$$ object $$$ m $$$ box box size exactly $$$ k $$$ object number $$$ 1 $$$ $$$ n $$$ order leave right size $$$ i $$$ -th object $$$ a_i $$$ maksim want pack object box pack object follow algorithm : take one empty box go leave right object $$$ i $$$ -th object fit current box ( remain size box greater equal $$$ a_i $$$ ) put box remain size box decrease $$$ a_i $$$ otherwise take new empty box continue process empty box least one object box maksim pack choose set object maksim want know maximum number object pack algorithm reach target throw leftmost object set remain set object pack box task say maximum number object maksim pack box time maksim try pack object box make empty box ( relative order remain set object change ) first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n m \le 200000 $$$ $$$ 1 \le k \le 1000000000 $$$ ) — number object number box size box second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le k $$$ ) $$$ a_i $$$ size $$$ i $$$ -th object print maximum number object maksim pack use algorithm describe problem statement first example maksim pack $$$ 4 $$$ object firstly try pack $$$ 5 $$$ object distribution object $$$ [ 5 ] [ 2 1 ] $$$ maxim pack next object second box empty box next throw first object object distribution $$$ [ 2 1 ] [ 4 2 ] $$$ answer $$$ 4 $$$ second example obvious maksim pack object start first second third fourth ( case distribution object $$$ [ 4 ] $$$ ) pack last object ( $$$ [ 1 ] $$$ ) third example maksim pack object distribution $$$ [ 1 2 ] [ 3 ] [ 1 1 ] $$$,"['binary search', 'implementation']",1800.0
730/C,a new trade empire rise berland bulmart emerge trade giant decide <unknown> market ... shovel ! almost every city berland a bulmart store cities even several ! problem moment <unknown> ... let 's say a little estimate people even say shovel <unknown> market small a big company make a profit company management believe future market seek new ways increase income n cities berland connect m bi - directional roads roads equal lengths happen impossible reach a city another city use roads road connect a city pair cities connect one road w bulmart store berland describe three number : latest idea bulmart management create a program help customers get shovel fast possible <unknown> budget formally program find minimum amount time need deliver rj shovel customer city gj total cost aj burl delivery time two adjacent cities equal 1 . shovel deliver several cities delivery time equal arrival time last <unknown> delivery free <unknown> program need find answer q query query process independently others i.e a query change number shovel store next query first line contain two integers n m ( 1 ≤ n ≤ 5000 0 ≤ m ≤ min ( 5000 n · ( n - 1 ) / 2 ) ) next m line contain two integers xe ye mean e - th road connect cities xe ye ( 1 ≤ xe ye ≤ n ) next line contain a single integer w ( 1 ≤ w ≤ 5000 ) — total number bulmart store berland next w line contain three integers describe i - th store : ci ki pi ( 1 ≤ ci ≤ n 1 ≤ ki pi ≤ 2·105 ) next line contain a single integer q ( 1 ≤ q ≤ 1000 ) — number query next q line contain three integers describe j - th query : gj rj aj ( 1 ≤ gj ≤ n 1 ≤ rj aj ≤ 109 ) output q line j - th line print answer j - th query — minimum amount time need deliver rj shovel customer city gj spend aj burl print -1 solution j - th query,"['binary search', 'dfs and similar']",2100.0
1672/E,"interactive problem $$$ n $$$ word a text editor $$$ i $$$ -th word length $$$ l_i $$$ ( $$$ 1 \leq l_i \leq 2000 $$$ ) array $$$ l $$$ hide know grader text editor display word line split two word a line least one space note a line end a space let height text editor refer number line use give width text editor display word a way height minimize formally suppose text editor width $$$ w $$$ let $$$ a $$$ array length $$$ k+1 $$$ $$$ 1 = a_1 < a_2 < \ldots < a _ { k+1 } = n+1 $$$ $$$ a $$$ a valid array $$$ 1 \leq i \leq k $$$ $$$ l _ { a_i } <unknown> _ { <unknown> } <unknown> _ { a _ { i+1 } -1 } \leq w $$$ height text editor minimum $$$ k $$$ valid array note $$$ w < \max ( l_i ) $$$ text editor display word properly crash height text editor $$$ 0 $$$ instead ask $$$ n+30 $$$ query one query provide a width $$$ w $$$ , grader return height $$$ h_w $$$ text editor width $$$ w $$$ find minimum area text editor minimum value $$$ w \cdot h_w $$$ $$$ w $$$ $$$ h_w \neq 0 $$$ lengths fix advance word interactor adaptive first line input contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 2000 $$$ ) — number word text editor guarantee hide lengths $$$ l_i $$$ satisfy $$$ 1 \leq l_i \leq 2000 $$$ begin interaction read $$$ n $$$ make a query print ` ` ? $$$ w $$$ ` ` ( without quote $$$ 1 \leq w \leq 1000000000 $$$ ) read response standard input , $$$ h_w $$$ program make invalid query run try interactor terminate immediately program get a verdict wrong answer give final answer print ` ` ! $$$ area $$$ ` ` ( without quote ) note give answer count towards limit $$$ n+30 $$$ query print a query forget output end line flush output otherwise get idleness limit exceed , use : <unknown> first line input must contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 2000 $$$ ) — number word text editor second line input must contain exactly $$$ n $$$ space - separated integers $$$ l_1 l_2 \ldots <unknown> $$$ ( $$$ 1 \leq l_i \leq 2000 $$$ ) first test case word $$$ \ { \texttt { glory } \texttt { } \texttt { <unknown> } \texttt { } \texttt { anton } \texttt { trygub } \ } $$$ $$$ <unknown> { <unknown> } $$$ $$$ <unknown> $$$ text editor able display word properly crash height text editor $$$ <unknown> $$$ grader return $$$ 0 $$$ $$$ <unknown> $$$ a possible way word display text editor : height text editor $$$ h _ { 9 } = 4 $$$ grader return $$$ 4 $$$ $$$ <unknown> $$$ a possible way word display text editor : height text editor $$$ h _ { 16 } = 2 $$$ grader return $$$ 2 $$$ somehow figure minimum area text editor $$$ 32 $$$ answer","['binary search', 'greedy']",2200.0
1520/F2,"interactive problem a hard version problem difference easy version hard version $$$ 1 \le t \le \min ( n 10000 ) $$$ total number query limit $$$ 60000 $$$ polycarp play a computer game game array consist zero ones hide polycarp win guess position $$$ k $$$ -th zero leave $$$ t $$$ time polycarp make $$$ 60000 $$$ request <unknown> follow type : make game interest guess zero turn one game continue change array formally position $$$ k $$$ -th zero $$$ x $$$ polycarp guess position $$$ x $$$ -th element array replace $$$ 0 $$$ $$$ 1 $$$ help polycarp win game first program must read two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le t \le \min ( n 10000 ) $$$ ) $$$ t $$$ line follow contain one integer $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) guarantee moment request array contain least $$$ k $$$ zero order get next value $$$ k $$$ must output answer previous value $$$ k $$$ , make $$$ 60000 $$$ request total use follow format output answer ( a request n't count $$$ 60000 $$$ ) : position array number leave right $$$ 1 $$$ $$$ n $$$ inclusive print $$$ t $$$ answer program exit immediately task interactor adaptive mean within test hide array query change case incorrect query -1 display value receive program must immediately exit normally ( example call exit ( 0 ) ) otherwise test system may issue arbitrary verdict number request exceed verdict wrong answer display solution may get verdict idleness limit exceed n't print anything forget flush output buffer flush output buffer need follow immediately query output end - of - line character : hacksuse follow format hack : first line print string $$$ s $$$ ( $$$ 1 \le |s| \le 200000 $$$ ) consist zero ones integer $$$ t $$$ ( $$$ 1 \le t \le \min ( |s| 10000 ) $$$ ) — hide array number request respectively next $$$ t $$$ line output number $$$ k $$$ ( $$$ 1 \le k \le |s| $$$ ) hack solution direct access hide array first test array $$$ [ 1 0 1 1 0 1 ] $$$ hide answer query $$$ k=2 $$$ array change $$$ [ 1 0 1 1 1 1 ] $$$","['binary search', 'data structures']",2200.0
896/B,"interactive problem refer interaction section better understand ithea chtholly want play a game order determine use kitchen tonight initially ithea put n clear sheet paper a line number 1 n leave right game go m round round ithea give chtholly integer 1 c chtholly need choose one sheet write number ( already a number erase original one replace new one ) chtholly win time sheet fill a number n number non - decreasing order look leave right sheet 1 sheet n m round still n't win lose game chtholly really want win game want cook something willem n't know win game chtholly find task write a program receive number ithea give chtholly help make decision sheet paper write number first line contain 3 integers n m c ( mean round ) — number sheet number round largest possible number ithea give chtholly respectively remain part input give throughout interaction process round program need read one line contain a single integer pi ( 1 ≤ pi ≤ c ) indicate number give chtholly program output a line contain integer 1 n indicate number sheet write number output line n't forget flush output example : chtholly win end a round input become available program terminate normally show constraints 's always possible chtholly win game example chtholly initially know 2 sheet 4 round number 1 4 . receive a 2 decide write 1st sheet receive a 1 write 2nd sheet last receive a 3 replace 1 3 2nd sheet time sheet fill a number non - decreasing game note require program terminate immediately chtholly win read number input remain round , <unknown> <unknown> may arise wo n't sure whether program accept reject also please careful hack others ' cod sample chtholly game 3rd round require program n't read number remain 4th round input format hack :","['binary search', 'greedy']",2000.0
1153/E,"interactive problem serval a <unknown> high school student <unknown> middle school however way school must go across a pond a dangerous snake pond represent a $$$ n \times n $$$ grid snake a head a tail different cells body a series adjacent cells connect head tail without self - intersecting serval hit head tail snake bite die luckily a special device answer follow question : pick a rectangle tell number time one need cross border rectangle walk cell cell along snake head tail picture show a possible snake a possible query get answer $$$ 4 $$$ today serval get late time make $$$ <unknown> $$$ query best friend help find position head tail ? note two cells adjacent a common edge grid a snake a body length $$$ 0 $$$ mean adjacent head tail also note snake sleep wo n't move serval use device 's obvious snake position depend query first line contain a single integer $$$ n $$$ ( $$$ 2\leq n \leq 1000 $$$ ) — size grid ready answer print ! x1 y1 x2 y2 $$$ ( x_1 y_1 ) $$$ represent position head $$$ ( x_2 y_2 ) $$$ represent position tail print head tail order make a query print ? x1 y1 x2 y2 ( $$$ 1 \leq x_1 \leq x_2 \leq n $$$ $$$ 1\leq y_1 \leq y_2 \leq n $$$ ) represent a rectangle consist cells $$$ ( x y ) $$$ $$$ x_1 \leq x \leq x_2 $$$ $$$ y_1 \leq y \leq y_2 $$$ get a single integer answer print a query forget output end line flush output otherwise get idleness limit exceed , use : answer $$$ -1 $$$ instead a valid answer mean make invalid query exceed maximum number query exit immediately receive $$$ -1 $$$ see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream program find head tail snake correctly also get a wrong answer verdict hacksto make a hack print a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 1000 $$$ ) first line indicate size grid print integer $$$ k $$$ ( $$$ 2 \leq k \leq n^2 $$$ ) second line indicate length snake next $$$ k $$$ line print $$$ k $$$ pair integers $$$ x_i y_i $$$ ( $$$ 1 \leq x_i y_i \leq n $$$ ) pair a single line indicate $$$ i $$$ -th cell snake adjacent pair adjacent $$$ k $$$ pair distinct picture show query answer first example first make a query $$$ ( 1,1 ) $$$ get answer $$$ 1 $$$ find must connect exactly one cell make a query $$$ ( 1,2 ) $$$ get answer $$$ 0 $$$ know snake never enter cell connect $$$ ( 1,1 ) $$$ must $$$ ( 2,1 ) $$$ make a query $$$ ( 2,2 ) $$$ get answer $$$ 0 $$$ know never enter $$$ ( 2,2 ) $$$ well snake leave $$$ ( 2,1 ) $$$ imply answer $$$ ( 1,1 ) $$$ $$$ ( 2,1 ) $$$ picture show query answer second example make query $$$ ( 2,2 ) $$$ receive $$$ 2 $$$ find snake occupy $$$ ( 2,2 ) $$$ make query rectangle $$$ ( 2,1 ) $$$ $$$ ( 2,3 ) $$$ receive answer $$$ 0 $$$ know never go rectangle $$$ ( 2,1 ) $$$ $$$ ( 2,3 ) $$$ since first answer $$$ 2 $$$ $$$ ( 2,1 ) $$$ $$$ ( 2,3 ) $$$ must occupy none others answer $$$ ( 2,1 ) $$$ $$$ ( 2,3 ) $$$","['binary search', 'brute force']",2200.0
1063/C,interactive problem good old time dwarves try develop <unknown> <unknown> : many <unknown> dwarves finally manage select right place <unknown> without error able repeat success ? ask successively name n different integer point plane name new point give color — black white task ensure name point split a line a way point one color lie side line point different color lie different side moreover point belong line also need report line end process problem interactor adaptive — color point test fix beforehand jury program select arbitrarily particular depend program output first line standard input stream contain integer n ( 1 ≤ n ≤ 30 ) — number point program name n time program must print two integer coordinate x y ( 0 ≤ x ≤ 109 0 ≤ y ≤ 109 ) point print must distinct response coordinate pair program receive string ` ` black '' point black ` ` white '' point white n point process need print four integers x1 y1 x2 y2 ( 0 ≤ x1 y1 ≤ 109 0 ≤ x2 y2 ≤ 109 ) — coordinate point ( x1 y1 ) ( x2 y2 ) form a line separate n point black white point ( x1 y1 ) ( x2 y2 ) coincide hacksto hack solution use follow format first line must contain word ` ` hack '' second line contain number n last line contain sequence 0 1 — color point report solution unlike jury test color point hack always fix advance course hack solution would n't able get information color advance example hack correspond sample test look like : sample input output value align simplicity interpret chronologically real interaction ` ` extra '' line break appear follow picture illustrate first test,"['binary search', 'geometry']",1900.0
1470/C,"interactive problem $$$ n $$$ people sit a circle try shuffle a deck card players number $$$ 1 $$$ $$$ n $$$ players $$$ i $$$ $$$ i+1 $$$ neighbour ( well players $$$ 1 $$$ $$$ n $$$ ) exactly $$$ k $$$ card $$$ k $$$ even leave neighbour a player $$$ i $$$ player $$$ i - 1 $$$ right neighbour player $$$ i + 1 $$$ ( except players $$$ 1 $$$ $$$ n $$$ respective neighbour ) turn follow happen : a player $$$ x $$$ card give $$$ \lfloor x / 2 \rfloor $$$ neighbour leave $$$ \lceil x / 2 \rceil $$$ card neighbour right happen players simultaneously however one player $$$ p $$$ impostor give card neighbour right know number players $$$ n $$$ number card $$$ k $$$ player initially $$$ p $$$ unknown task determine value $$$ p $$$ ask question like ` ` many card player $$$ q $$$ ? '' index $$$ q $$$ choice question players make exactly one move give card neighbour need find impostor ask $$$ 1000 $$$ question first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 4 \le n \le 100000 $$$ $$$ 2 \le k \le 1000000000 $$$ $$$ k $$$ even ) — number players number card ask question print ` ` ? $$$ q $$$ ` ` answer question number card player $$$ q $$$ ( $$$ 1 \le q \le n $$$ ) shuffle process start immediately first question answer first one always equal $$$ k $$$ identify impostor output answer print ` ` ! $$$ p $$$ ` ` $$$ p $$$ player impostor ( $$$ 1 \le p \le n $$$ ) terminate program find impostor ask $$$ 1000 $$$ question print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto make a hack use follow test format line input contain three integers $$$ n $$$ $$$ k $$$ $$$ p $$$ ( $$$ 4 \le n \le 100000 $$$ $$$ 2 \le k \le 1000000000 $$$ $$$ k $$$ even $$$ 1 \le p \le n $$$ ) — number people number card person initially position impostor example card transfer follow way : turn number card remain unchanged player","['binary search', 'brute force']",2500.0
380/A,"sereja love number sequence much 's decide make a new one follow a certain algorithm sereja take a blank piece paper start write sequence m stag time either add a new number end sequence take l first elements current sequence add c time end formally represent current sequence a1 a2 ... , apply describe operation sequence transform a1 a2 ... [ a1 a2 ... al ] ( block square bracket must repeat c time ) a day pass sereja complete sequence wonder value elements help sereja first line contain integer m ( 1 ≤ m ≤ 105 ) — number stag build a sequence next m line contain description stag order follow first number line a type stage ( 1 2 ) type 1 mean add one number end sequence case line contain integer xi ( 1 ≤ xi ≤ 105 ) — number add type 2 mean copy a prefix length li end ci time case line contain two integers li ci ( 1 ≤ li ≤ 105 1 ≤ ci ≤ 104 ) li length prefix ci number copy guarantee length prefix li never larger current length sequence next line contain integer n ( 1 ≤ n ≤ 105 ) — number elements sereja interest next line contain number elements final sequence sereja interest number give strictly increase order guarantee number strictly larger zero exceed length result sequence consider elements final sequence number start 1 begin end sequence please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print elements sereja interest order number occur input","['binary search', 'brute force']",1600.0
371/C,polycarpus love hamburgers much <unknown> adore hamburgers make hand polycarpus think three decent ingredients make hamburgers : a bread sausage cheese write recipe favorite ` ` le hamburger de polycarpus '' a string letter ' b ' ( bread ) 's ' ( sausage ) и ' c ' ( cheese ) ingredients recipe go bottom top example recipe ` ` <unknown> '' represent hamburger ingredients go bottom top bread sausage cheese bread sausage polycarpus nb piece bread ns piece sausage nc piece cheese kitchen besides shop nearby three ingredients price pb rubles a piece bread ps a piece sausage pc a piece cheese polycarpus r rubles ready shop maximum number hamburgers cook ? assume polycarpus break <unknown> piece bread sausage cheese besides shop unlimited number piece ingredient first line input contain a non - empty string describe recipe ` ` le hamburger de polycarpus '' length string n't exceed 100 string contain letter ' b ' ( uppercase english b ) 's ' ( uppercase english s ) ' c ' ( uppercase english c ) second line contain three integers nb ns nc ( 1 ≤ nb ns nc ≤ 100 ) — number piece bread sausage cheese polycarpus ' kitchen third line contain three integers pb ps pc ( 1 ≤ pb ps pc ≤ 100 ) — price one piece bread sausage cheese shop finally fourth line contain integer r ( 1 ≤ r ≤ 1012 ) — number rubles polycarpus please write % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print maximum number hamburgers polycarpus make ca n't make hamburger print 0,"['binary search', 'brute force']",1600.0
109/D,petya love lucky number know lucky number positive integers whose decimal representations contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 petya get array consist n number gift birthday want sort non - decreasing order however a usual sort bore perform 's petya invent follow limitation : one swap two number least one lucky task sort array accord specify limitation find possible sequence swap ( number operations sequence exceed 2n ) first line contain integer n ( 1 ≤ n ≤ 105 ) — number elements array second line contain n positive integers exceed 109 — array need sort non - decreasing order first line print number k ( 0 ≤ k ≤ 2n ) — number swap sort follow k line print one pair distinct number ( a pair per line ) — index elements swap number array number start 1 . impossible sort give sequence print single number -1 . several solutions output note n't minimize k. sort 2n swap accept,['sortings'],2000.0
254/A,petya get 2n card card contain integer number card let 's index card consecutive integers 1 2n 'll denote number write a card number i ai order play one entertain game friends petya need split card pair pair equal number card help petya first line contain integer n ( 1 ≤ n ≤ 3·105 ) second line contain sequence 2n positive integers a1 a2 ... <unknown> ( 1 ≤ ai ≤ 5000 ) — number write card number line separate single space impossible divide card pair card pair number print a single line integer -1 . require partition exist print n pair integers a pair per line — indices card form pair separate number line space print pair number pair order multiple solutions print,['sortings'],1200.0
234/B,vasya go olympics city <unknown> train boy want read <unknown> prepare olympics count need k hours also find light train change every hour light measure a scale 0 100 0 dark 100 light vasya a train light schedule n hours trip — n number 0 100 ( light level first hour second hour ) hours either read whole time read want choose k hours read a book necessarily consecutive minimum level light among select hours maximum vasya <unknown> upcoming contest help choose read hours first input line contain two integers n k ( 1 ≤ n ≤ 1000 1 ≤ k ≤ n ) — number hours train number hours read correspondingly second line contain n space - separated integers ai ( 0 ≤ ai ≤ 100 ) ai light level i - th hour first output line print minimum light level vasya read second line print k distinct space - separated integers b1 b2 ... bk — index hours vasya read ( 1 ≤ bi ≤ n ) hours index start 1 . multiple optimal solutions print print number bi arbitrary order first sample vasya read first hour ( light 20 ) third hour ( light 30 ) fourth hour ( light 40 ) minimum light vasya read 20,['sortings'],1000.0
137/C,"polycarpus like study school a lot always diligent homework polycarpus never problems natural <unknown> great - great - <unknown> great physicist <unknown> hand though polycarpus never easy time history everybody know world history <unknown> exactly n events : i - th event continue year ai year bi inclusive ( ai < bi ) polycarpus easily learn date n events start end ( polycarpus <unknown> <unknown> memory great - great - <unknown> ) teacher give a complicate task : <unknown> know events begin end also find event whether include another event polycarpus ' teacher think event j include event i aj < ai bi < bj task simpler : find number events include event first input line contain integer n ( 1 ≤ n ≤ 105 ) represent number events next n line contain descriptions <unknown> events one event per line i + 1 line contain two integers ai bi ( 1 ≤ ai < bi ≤ 109 ) — begin end i - th event two events start finish year , ai ≠ aj ai ≠ bj bi ≠ aj bi ≠ bj i j ( i ≠ j ) events give arbitrary order print integer — answer problem first example fifth event contain fourth similarly fourth event contain third third — second second — first second example events except first one contain first third example one event answer 0",['sortings'],1500.0
131/E,a queen strongest chess piece modern chess queen move number square horizontal vertical diagonal direction ( consider 're piece way ) queen combine options give rook bishop m queen a square n × n chessboard know queen 's position i - th queen position square ( ri ci ) ri board row number ( number top bottom 1 n ) ci board 's column number ( number leave right 1 n ) two queen share position queen one count w — number queen give queen threaten ( attack ) a fix attack direction first queen direction attack many queen ray attack obviously queen w 0 8 inclusive print sequence t0 t1 ... t8 ti number queen threaten exactly i queen i.e number queen w equal i. first line input contain a pair integers n m ( 1 ≤ n m ≤ 105 ) n size board m number queen board m follow line contain position queen one per line line contain a pair integers ri ci ( 1 ≤ ri ci ≤ n ) — queen 's position two queen stand square print require sequence t0 t1 ... t8 separate number space,['sortings'],1700.0
130/I,sort array traditionally associate high - level languages hard <unknown> ? sort give array non - descending order first line input contain integer n ( 1 ≤ n ≤ 100 ) — size array follow n line contain elements array one per line element array integer 1 60 inclusive array might contain duplicate elements output space - separated elements sort array,['sortings'],2300.0
64/I,"give a rectangular table contain word columns name also give list rule sort form ` ` <unknown> sort_order '' sort_order either <unknown> ( <unknown> order ) desc ( <unknown> order ) rule list separate a single <unknown> a single space sort row table <unknown> first rule , case a tie sort second rule   two row equal term every rule preserve relative order assume element table type ` ` string '' use lexicographic comparison first line contain column name second line contain list rule rest input data contain table word column name separate single space number row columns 1 100 inclusive name columns elements string contain uppercase lowercase latin letter digits length 1 10 inclusive print table sort",['sortings'],2400.0
334/B,gerald particular eight point set think decent eight point set must consist pairwise intersections three distinct integer vertical straight line three distinct integer horizontal straight line except average nine point word must three integers x1 x2 x3 three integers y1 y2 y3 x1 < x2 < x3 y1 < y2 < y3 eight point set consist point ( xi yj ) ( 1 ≤ i j ≤ 3 ) except point ( x2 y2 ) a set eight point find gerald use set ? input consist eight line i - th line contain two space - separated integers xi yi ( 0 ≤ xi yi ≤ 106 ) condition point a single line print word ` ` respectable '' give set point correspond gerald 's <unknown> rule ` ` ugly '' otherwise,['sortings'],1400.0
430/A,iahub n't well prepare geometry problems hear year a lot geometry problems ioi selection camp <unknown> iahub lock <unknown> start think new problems kind one follow iahub want draw n distinct point m segment ox axis draw point either red blue draw good follow requirement meet : segment [ li ri ] consider red point belong ( ri point ) blue point belong ( bi point ) ; segment i satisfy inequality <unknown> - <unknown> ≤ 1 . iahub think point x belong segment [ l r ] inequality l ≤ x ≤ r hold iahub give coordinate point segment please help find good draw first line input contain two integers : n ( 1 ≤ n ≤ 100 ) m ( 1 ≤ m ≤ 100 ) next line contain n space - separated integers x1 x2 ... xn ( 0 ≤ xi ≤ 100 ) — coordinate point follow m line contain descriptions m segment line contain two integers li ri ( 0 ≤ li ≤ ri ≤ 100 ) — border i - th segment 's guarantee point distinct good draw a give test output a single integer -1 . otherwise output n integers integer must 0 1 . i - th number denote color i - th point ( 0 red 1 blue ) multiple good draw output,['sortings'],1600.0
1526/A,give array $$$ a $$$ $$$ 2n $$$ distinct integers want arrange elements array a circle element equal arithmetic mean $$$ 2 $$$ neighbour formally find array $$$ b $$$ : $$$ b $$$ a permutation $$$ a $$$ every $$$ i $$$ $$$ 1 $$$ $$$ 2n $$$ $$$ b_i \neq \frac { b _ { i-1 } + b _ { i+1 } } { 2 } $$$ $$$ b_0 = b _ { 2n } $$$ $$$ b _ { <unknown> } = b_1 $$$ prove constraints problem array $$$ b $$$ always exist first line input contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000 ) $$$ — number testcases description testcases follow first line testcase contain a single integer $$$ n $$$ $$$ ( 1 \leq n \leq 25 ) $$$ second line testcase contain $$$ 2n $$$ integers $$$ a_1 a_2 \ldots a _ { 2n } $$$ $$$ ( 1 \leq a_i \leq 1000000000 ) $$$ — elements array note limit sum $$$ n $$$ testcases testcase output $$$ 2n $$$ integers $$$ b_1 b_2 \ldots b _ { 2n } $$$ condition statement satisfy first testcase array $$$ [ 3 1 4 2 5 6 ] $$$ work 's a permutation $$$ [ 1 2 3 4 5 6 ] $$$ $$$ \frac { 3 + 4 } { 2 } \neq 1 $$$ $$$ \frac { 1 + 2 } { 2 } \neq 4 $$$ $$$ \frac { 4 + 5 } { 2 } \neq 2 $$$ $$$ \frac { 2 + 6 } { 2 } \neq 5 $$$ $$$ \frac { 5 + 3 } { 2 } \neq 6 $$$ $$$ \frac { 6 + 1 } { 2 } \neq 3 $$$,['sortings'],800.0
1339/B,array $$$ n $$$ number $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ rearrange number satisfy $$$ |a _ { 1 } - a _ { 2 } | \le |a _ { 2 } - a _ { 3 } | \le \ldots \le |a _ { n-1 } - a _ { n } | $$$ $$$ |x| $$$ denote absolute value $$$ x $$$ 's always possible find rearrangement note number $$$ a $$$ necessarily different word number $$$ a $$$ may answer independent $$$ t $$$ test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10^ { 4 } $$$ ) — number test case first line test case contain single integer $$$ n $$$ ( $$$ 3 \le n \le 10^ { 5 } $$$ ) — length array $$$ a $$$ guarantee sum value $$$ n $$$ test case input exceed $$$ 10^ { 5 } $$$ second line test case contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ ( $$$ <unknown> { 9 } \le a _ { i } \le 10^ { 9 } $$$ ) test case print rearrange version array $$$ a $$$ satisfy give condition multiple valid <unknown> print first test case give rearrangement $$$ |a _ { 1 } - a _ { 2 } | = 0 \le |a _ { 2 } - a _ { 3 } | = 1 \le |a _ { 3 } - a _ { 4 } | = 2 \le |a _ { 4 } - a _ { 5 } | = 2 \le |a _ { 5 } - a _ { 6 } | = 10 $$$ possible answer like ` ` 5 4 5 6 -2 8 '' second test case give rearrangement $$$ |a _ { 1 } - a _ { 2 } | = 1 \le |a _ { 2 } - a _ { 3 } | = 2 \le |a _ { 3 } - a _ { 4 } | = 4 $$$ possible answer like ` ` 2 4 8 1 '',['sortings'],1200.0
1312/B,give array $$$ a_1 a_2 \dots a_n $$$ array good pair index $$$ i < j $$$ condition $$$ j - a_j \ne i - a_i $$$ hold shuffle array become good ? shuffle array mean reorder elements arbitrarily ( leave initial order also option ) example $$$ a = [ 1 1 3 5 ] $$$ shuffle array $$$ [ 1 3 5 1 ] $$$ $$$ [ 3 5 1 1 ] $$$ $$$ [ 5 3 1 1 ] $$$ good shuffle array $$$ [ 3 1 5 1 ] $$$ $$$ [ 1 1 3 5 ] $$$ $$$ [ 1 1 5 3 ] $$$ n't 's guarantee 's always possible shuffle array meet condition first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — length array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100 $$$ ) test case print shuffle version array $$$ a $$$ good,['sortings'],1000.0
1174/B,'re give array $$$ a $$$ length $$$ n $$$ perform follow operation many time want : lexicographically smallest array obtain ? array $$$ x $$$ lexicographically smaller array $$$ y $$$ exist index $$$ i $$$ $$$ x_i < y_i $$$ $$$ x_j = y_j $$$ $$$ 1 \le j < i $$$ less formally first index $$$ i $$$ differ $$$ x_i < y_i $$$ first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number elements array $$$ a $$$ second line contain $$$ n $$$ space - separated integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a _ { n } $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements array $$$ a $$$ line contain $$$ n $$$ space - separated integers lexicographically smallest array obtain first example swap $$$ 1 $$$ $$$ 4 $$$ since $$$ 1 + <unknown> $$$ odd,['sortings'],1200.0
1148/C,"give a permutation $$$ p $$$ integers $$$ 1 $$$ $$$ n $$$ $$$ n $$$ even number goal sort permutation , perform zero operations follow type : need minimize number operations however use $$$ 5 \cdot n $$$ operations one show always possible first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 300000 $$$ $$$ n $$$ even ) — length permutation second line contain $$$ n $$$ distinct integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) — give permutation first line print $$$ m $$$ ( $$$ 0 \le m \le 5 \cdot n $$$ ) — number swap perform follow $$$ m $$$ line contain integers $$$ a_i b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ $$$ <unknown> - <unknown> \ge \frac { n } { 2 } $$$ ) — indices swap correspond swap note need minimize number operations show answer always exist first example one swap elements position $$$ 1 $$$ $$$ 2 $$$ array become sort second example pay attention need minimize number swap third example swap elements position $$$ 1 $$$ $$$ 5 $$$ array become : $$$ [ 4 5 3 1 2 6 ] $$$ swap elements position $$$ 2 $$$ $$$ 5 $$$ array become $$$ [ 4 2 3 1 5 6 ] $$$ finally swap elements position $$$ 1 $$$ $$$ 4 $$$ array become sort : $$$ [ 1 2 3 4 5 6 ] $$$",['sortings'],1700.0
1144/C,two integer sequence exist initially — one strictly increase one — strictly decrease strictly increase sequence a sequence integers $$$ [ x_1 < x_2 < \dots < x_k ] $$$ strictly decrease sequence a sequence integers $$$ [ y_1 > y_2 > \dots > y_l ] $$$ note empty sequence sequence consist one element consider increase decrease merge one sequence $$$ a $$$ sequence $$$ a $$$ get shuffle example possible result sequence $$$ a $$$ increase sequence $$$ [ 1 3 4 ] $$$ a decrease sequence $$$ [ 10 4 2 ] $$$ sequence $$$ [ 1 2 3 4 4 10 ] $$$ $$$ [ 4 2 1 10 4 3 ] $$$ shuffle sequence $$$ a $$$ give input task find two suitable initial sequence one strictly increase one — strictly decrease note empty sequence sequence consist one element consider increase decrease a contradiction input impossible split give sequence $$$ a $$$ increase decrease sequence print ` ` '' first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements $$$ a $$$ second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 200000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ a contradiction input impossible split give sequence $$$ a $$$ increase decrease sequence print ` ` '' first line otherwise print ` ` yes '' first line two suitable sequence note empty sequence sequence consist one element consider increase decrease second line print $$$ n_i $$$ — number elements strictly increase sequence $$$ n_i $$$ zero case increase sequence empty third line print $$$ n_i $$$ integers $$$ inc_1 inc_2 \dots inc _ { n_i } $$$ increase order value ( $$$ inc_1 < inc_2 < \dots < inc _ { n_i } $$$ ) — strictly increase sequence keep line empty $$$ n_i = 0 $$$ ( print empty line ) fourth line print $$$ n_d $$$ — number elements strictly decrease sequence $$$ n_d $$$ zero case decrease sequence empty fifth line print $$$ n_d $$$ integers $$$ dec_1 dec_2 \dots dec _ { n_d } $$$ decrease order value ( $$$ dec_1 > dec_2 > \dots > dec _ { n_d } $$$ ) — strictly decrease sequence keep line empty $$$ n_d = 0 $$$ ( print empty line ) $$$ n_i + n_d $$$ equal $$$ n $$$ union print sequence a permutation give sequence ( case ` ` yes '' answer ),['sortings'],1000.0
1136/C,nastya come informatics lesson teacher way a little bite famous give follow task two matrices $$$ a $$$ $$$ b $$$ give size $$$ n \times m $$$ nastya perform follow operation matrix $$$ a $$$ unlimited number time : nastya 's task check whether possible transform matrix $$$ a $$$ matrix $$$ b $$$ may require a lot operations ask answer question nastya a square submatrix matrix $$$ m $$$ a matrix consist elements come one row indeces $$$ x x+1 \dots <unknown> $$$ matrix $$$ m $$$ come one columns indeces $$$ y y+1 \dots <unknown> $$$ matrix $$$ m $$$ $$$ k $$$ size square submatrix word square submatrix set elements source matrix form a solid square ( i.e without hole ) first line contain two integers $$$ n $$$ $$$ m $$$ separate space ( $$$ 1 \leq n m \leq 500 $$$ ) — number row columns $$$ a $$$ $$$ b $$$ respectively next $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th number $$$ i $$$ -th line denote $$$ j $$$ -th element $$$ i $$$ -th row matrix $$$ a $$$ ( $$$ 1 \leq a _ { ij } \leq 10^ { 9 } $$$ ) next $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th number $$$ i $$$ -th line denote $$$ j $$$ -th element $$$ i $$$ -th row matrix $$$ b $$$ ( $$$ 1 \leq b _ { ij } \leq 10^ { 9 } $$$ ) print ` ` yes '' ( without quote ) possible transform $$$ a $$$ $$$ b $$$ ` ` '' ( without quote ) otherwise print letter case ( upper lower ) consider third example matrix $$$ a $$$ initially look follow $$$ $$$ \begin { bmatrix } 1 & 2 & <unknown> 4 & 5 & 6\\ 7 & 8 & 9 \end { bmatrix } $$$ $$$ choose whole matrix transpose submatrix become $$$ $$$ \begin { bmatrix } 1 & 4 & 7\\ 2 & 5 & <unknown> 3 & 6 & 9 \end { bmatrix } $$$ $$$ transpose submatrix corner cells $$$ ( 2 2 ) $$$ $$$ ( 3 3 ) $$$ $$$ $$$ \begin { bmatrix } 1 & 4 & 7\\ 2 & \textbf { 5 } & \textbf { 8 } \\ 3 & \textbf { 6 } & \textbf { 9 } \end { bmatrix } $$$ $$$ matrix become $$$ $$$ \begin { bmatrix } 1 & 4 & 7\\ 2 & 5 & 6\\ 3 & 8 & 9 \end { bmatrix } $$$ $$$ $$$ b $$$,['sortings'],1500.0
1101/C,$$$ n $$$ segment $$$ [ l_i r_i ] $$$ $$$ 1 \le i \le n $$$ divide segment two non - empty group way pair segment different group least one common point say 's impossible segment belong exactly one group optimize test process give <unknown> first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 50000 $$$ ) — number query query contain description set segment query independent first line query contain single integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — number segment guarantee $$$ \sum { n } $$$ query exceed $$$ 100000 $$$ next $$$ n $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ per line ( $$$ 1 \le l_i \le r_i \le 200000 $$$ ) — $$$ i $$$ -th segment query print $$$ n $$$ integers $$$ t_1 t_2 \dots t_n $$$ ( $$$ t_i \in \ { 1 2\ } $$$ ) — segment ( order input ) $$$ t_i $$$ equal $$$ 1 $$$ $$$ i $$$ -th segment belong first group $$$ 2 $$$ otherwise multiple answer print answer print $$$ -1 $$$ first query first second segment different group exact number n't matter second query third segment intersect first second segment group group become empty answer $$$ -1 $$$ third query distribute segment way make group non - empty answer $$$ 6 $$$ possible correct,['sortings'],1500.0
1015/C,ivan $$$ n $$$ songs phone size $$$ i $$$ -th song $$$ a_i $$$ bytes ivan also a flash drive hold $$$ m $$$ bytes total initially flash drive empty ivan want copy $$$ n $$$ songs flash drive compress songs compress $$$ i $$$ -th song size $$$ i $$$ -th song reduce $$$ a_i $$$ $$$ b_i $$$ bytes ( $$$ b_i < a_i $$$ ) ivan compress subset songs ( possibly empty ) copy songs flash drive sum size $$$ m $$$ compress subset songs ( necessarily contiguous ) ivan want find minimum number songs need compress a way songs fit drive ( i.e sum size less equal $$$ m $$$ ) impossible copy songs ( even ivan compress songs ) print ` ` -1 '' otherwise print minimum number songs ivan need compress first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100000 1 \le m \le 1000000000 $$$ ) — number songs ivan 's phone capacity ivan 's flash drive next $$$ n $$$ line contain two integers : $$$ i $$$ -th line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le 1000000000 $$$ $$$ a_i > b_i $$$ ) — initial size $$$ i $$$ -th song size $$$ i $$$ -th song compression impossible compress a subset songs a way songs fit flash drive print ` ` -1 '' otherwise print minimum number songs compress first example ivan compress first third songs move sum size equal $$$ 8 + 7 + 1 + 5 = 21 \le 21 $$$ also ivan compress first second songs sum size equal $$$ 8 + 4 + 3 + 5 = 20 \le 21 $$$ note compress single song sufficient copy songs flash drive ( example compress second song sum size equal $$$ 10 + 4 + 3 + 5 = 22 > 21 $$$ ) second example even ivan compress songs sum size equal $$$ 8 + 4 + 1 + 4 = 17 > 16 $$$,['sortings'],1100.0
572/A,give two array a b consist integers sort non - decreasing order check whether possible choose k number array a choose m number array b number choose first array strictly less number choose second array first line contain two integers na nb ( 1 ≤ na nb ≤ 105 ) separate a space — size array a b correspondingly second line contain two integers k m ( 1 ≤ k ≤ na 1 ≤ m ≤ nb ) separate a space third line contain na number a1 a2 ... ana ( - 109 ≤ a1 ≤ a2 ≤ ... ≤ ana ≤ 109 ) separate space — elements array a. fourth line contain nb integers b1 b2 ... bnb ( - 109 ≤ b1 ≤ b2 ≤ ... ≤ bnb ≤ 109 ) separate space — elements array b. print ` ` yes '' ( without quote ) choose k number array a m number array b number choose array a strictly less number choose array b. otherwise print ` ` '' ( without quote ) first sample test example choose number 1 2 array a number 3 array b ( 1 < 3 2 < 3 ) second sample test way choose k elements first array m elements second one choose number array number choose a less number choose b :,['sortings'],900.0
23/C,2n - 1 box apples oranges task choose n box contain less half apples less half oranges first input line contain one number t — amount test description test start a natural number n — amount box follow 2n - 1 line contain number ai oi — amount apples oranges i - th box ( 0 ≤ ai oi ≤ 109 ) sum n test input n't exceed 105 . input number integer test output two line first line output yes 's possible choose n box otherwise answer positive output second line n number — index choose box box number 1 input order otherwise leave second line empty separate number one space,['sortings'],2500.0
798/D,mike always think <unknown> social inequality 's obsess sometimes even affect solve problems moment mike two sequence positive integers a = [ a1 a2 ... ] b = [ b1 b2 ... bn ] length n use ask people quite peculiar question test good spot inequality life want find ` ` unfair '' subset original sequence precise want select k number p = [ p1 p2 ... pk ] 1 ≤ pi ≤ n 1 ≤ i ≤ k elements p distinct sequence p represent indices elements 'll select sequence call a subset p ` ` unfair '' follow condition satisfy : 2 · ( ap1 + ... + <unknown> ) greater sum elements sequence a 2 · ( <unknown> + ... + <unknown> ) greater sum elements sequence b. also k smaller equal easy find sequence p allow select many elements ! mike guarantee a solution always exist give condition describe please help satisfy curiosity ! first line contain integer n ( 1 ≤ n ≤ 105 ) — number elements sequence second line n space - separated integers a1 ... ( 1 ≤ ai ≤ 109 ) — elements sequence a. third line also n space - separated integers b1 ... bn ( 1 ≤ bi ≤ 109 ) — elements sequence b. first line output integer k represent size find subset k less equal next line print k integers p1 p2 ... pk ( 1 ≤ pi ≤ n ) — elements sequence p. print number order want elements sequence p distinct,['sortings'],2400.0
1450/A,a string $$$ b $$$ a subsequence a string $$$ a $$$ $$$ b $$$ obtain $$$ a $$$ deletion several ( possibly zero ) character example ` ` xy '' a subsequence ` ` <unknown> '' ` ` xy '' ` ` <unknown> '' give a string $$$ a $$$ task reorder character $$$ a $$$ ` ` trygub '' a subsequence result string word find a string $$$ b $$$ a permutation symbols string $$$ a $$$ ` ` trygub '' a subsequence $$$ b $$$ a <unknown> <unknown> proof string arrange contain ` ` trygub '' a subsequence problem statement short contain first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 100 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1\le n\le 200 $$$ ) — length $$$ a $$$ next line contain string $$$ a $$$ length $$$ n $$$ consist lowercase english letter test case output a string $$$ b $$$ length $$$ n $$$ a permutation character string $$$ a $$$ ` ` trygub '' a subsequence exist multiple possible string $$$ b $$$ print first test case ` ` <unknown> '' contain ` ` trygub '' a subsequence contain letter ` ` trygub '' correct order a subsequence second test case change order character need third test case ` ` <unknown> '' contain ` ` <unknown> '' a subsequence ` ` trygub '',['sortings'],800.0
1005/E2,give integer sequence $$$ a_1 a_2 \dots a_n $$$ find number pair indices $$$ ( l r ) $$$ ( $$$ 1 \le l \le r \le n $$$ ) value median $$$ a_l a _ { l+1 } \dots a_r $$$ exactly give number $$$ m $$$ median a sequence value element middle sequence sort non - decreasing order length sequence even leave two middle elements use example $$$ a= [ 4 2 7 5 ] $$$ median $$$ 4 $$$ since sort sequence look like $$$ [ 2 4 5 7 ] $$$ leave two middle elements equal $$$ 4 $$$ median $$$ [ 7 1 2 9 6 ] $$$ equal $$$ 6 $$$ since sort value $$$ 6 $$$ middle sequence write a program find number pair indices $$$ ( l r ) $$$ ( $$$ 1 \le l \le r \le n $$$ ) value median $$$ a_l a _ { l+1 } \dots a_r $$$ exactly give number $$$ m $$$ first line contain integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 2\cdot100000 $$$ ) — length give sequence require value median second line contain integer sequence $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 2\cdot100000 $$$ ) print require number first example suitable pair indices : $$$ ( 1 3 ) $$$ $$$ ( 1 4 ) $$$ $$$ ( 1 5 ) $$$ $$$ ( 2 2 ) $$$ $$$ ( 2 3 ) $$$ $$$ ( 2 5 ) $$$ $$$ ( 4 5 ) $$$ $$$ ( 5 5 ) $$$,['sortings'],2400.0
1005/E1,give a permutation $$$ p_1 p_2 \dots p_n $$$ a permutation length $$$ n $$$ a sequence integer $$$ 1 $$$ $$$ n $$$ occur exactly sequence find number pair indices $$$ ( l r ) $$$ ( $$$ 1 \le l \le r \le n $$$ ) value median $$$ p_l p _ { l+1 } \dots p_r $$$ exactly give number $$$ m $$$ median a sequence value element middle sequence sort non - decreasing order length sequence even leave two middle elements use example $$$ a= [ 4 2 7 5 ] $$$ median $$$ 4 $$$ since sort sequence look like $$$ [ 2 4 5 7 ] $$$ leave two middle elements equal $$$ 4 $$$ median $$$ [ 7 1 2 9 6 ] $$$ equal $$$ 6 $$$ since sort value $$$ 6 $$$ middle sequence write a program find number pair indices $$$ ( l r ) $$$ ( $$$ 1 \le l \le r \le n $$$ ) value median $$$ p_l p _ { l+1 } \dots p_r $$$ exactly give number $$$ m $$$ first line contain integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 2\cdot100000 $$$ $$$ 1 \le m \le n $$$ ) — length give sequence require value median second line contain a permutation $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) integer $$$ 1 $$$ $$$ n $$$ occur $$$ p $$$ exactly print require number first example suitable pair indices : $$$ ( 1 3 ) $$$ $$$ ( 2 2 ) $$$ $$$ ( 2 3 ) $$$ $$$ ( 2 4 ) $$$,['sortings'],1800.0
652/B,"a student z - school find a kind sort call z - sort array a n elements z - sorted two condition hold : example array [ 1,2,1,2 ] [ <unknown> ] z - sorted array [ 1,2,3,4 ] ’ t z - sorted make array z - sorted ? first line contain a single integer n ( 1 ≤ n ≤ 1000 ) — number elements array a. second line contain n integers ai ( 1 ≤ ai ≤ 109 ) — elements array a. 's possible make array a z - sorted print n space separate integers ai — elements z - sort otherwise print word ` ` impossible ''",['sortings'],1000.0
599/C,one day squidward spongebob patrick decide go beach unfortunately weather bad friends unable ride wave however decide spend time build sand castle end day n castle build friends castle number 1 n height i - th castle equal hi friends leave squidward notice castle order height look ugly friends go reorder castle a way obtain condition hi ≤ hi + 1 hold i 1 n - 1 . squidward suggest follow process sort castle : even patrick understand increase number block partition <unknown> sort process friends ask count maximum possible number block a partition satisfy requirements first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number castle spongebob patrick squidward make sand day next line contain n integers hi ( 1 ≤ hi ≤ 109 ) i - th integers correspond height i - th castle print maximum possible number block a valid partition first sample partition look like : [ 1 ] [ 2 ] [ 3 ] second sample partition : [ 2 1 ] [ 3 2 ],['sortings'],1600.0
456/A,one day dima alex argument price quality laptops dima think expensive a laptop better alex <unknown> alex think two laptops price first laptop less ( strictly smaller ) price second laptop quality first laptop higher ( strictly greater ) quality second laptop please check guess alex give descriptions n laptops determine whether two describe laptops exist first line contain integer n ( 1 ≤ n ≤ 105 ) — number laptops next n line contain two integers ai bi ( 1 ≤ ai bi ≤ n ) ai price i - th laptop bi number represent quality i - th laptop ( larger number higher quality ) ai distinct bi distinct alex correct print ` ` happy alex '' otherwise print ` ` poor alex '' ( without quote ),['sortings'],1100.0
977/C,give a sequence integers length $$$ n $$$ integer number $$$ k $$$ print integer number $$$ x $$$ range $$$ [ 1 ; 1000000000 ] $$$ ( i.e $$$ 1 \le x \le 1000000000 $$$ ) exactly $$$ k $$$ elements give sequence less equal $$$ x $$$ note sequence contain equal elements $$$ x $$$ print ` ` -1 '' ( without quote ) first line input contain integer number $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 0 \le k \le n $$$ ) second line input contain $$$ n $$$ integer number $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — sequence print integer number $$$ x $$$ range $$$ [ 1 ; 1000000000 ] $$$ exactly $$$ k $$$ elements give sequence less equal $$$ x $$$ $$$ x $$$ print ` ` -1 '' ( without quote ) first example $$$ 5 $$$ also a valid answer elements indices $$$ [ 1 3 4 6 ] $$$ less equal $$$ 5 $$$ obviously less equal $$$ 6 $$$ second example choose number $$$ 2 $$$ elements give sequence less equal number $$$ 3 $$$ elements give sequence also less equal number,['sortings'],1200.0
682/B,"someone give alyona array contain n positive integers a1 a2 ... , one operation alyona choose element array decrease i.e replace positive integer smaller current one alyona repeat operation many time want particular may apply operation array formally apply operations alyona get array n positive integers b1 b2 ... bn 1 ≤ bi ≤ ai every 1 ≤ i ≤ n. task determine maximum possible value mex array mex array problem minimum positive integer n't appear array example mex array contain 1 3 4 equal 2 mex array contain 2 3 2 equal 1 . first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number elements alyona 's array second line input contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — elements array print one positive integer — maximum possible value mex array alyona apply ( possibly none ) operations first sample case one decrease second element value 2 fifth element value 4 mex value result array 1 2 3 3 4 equal 5 . reach answer second sample case one must decrease array elements",['sortings'],1200.0
981/B,two famous compete company chemforces topchemist decide show set recently discover chemical elements exhibition however know element present set company order avoid representatives company decide make agreement set company present set choose way maximize total income company elements enumerate integers chemforces company discover $$$ n $$$ distinct chemical elements indices $$$ a_1 a_2 \ldots a_n $$$ get income $$$ x_i $$$ berland rubles $$$ i $$$ -th element list set company topchemist company discover $$$ m $$$ distinct chemical elements indices $$$ b_1 b_2 \ldots b_m $$$ get income $$$ y_j $$$ berland rubles include $$$ j $$$ -th element list set word first company present subset elements $$$ \ { a_1 a_2 \ldots <unknown> } $$$ ( possibly empty subset ) second company present subset elements $$$ \ { b_1 b_2 \ldots <unknown> } $$$ ( possibly empty subset ) n't equal elements subsets help representatives select set a way element present set total income maximum possible first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — number elements discover chemforces $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ a_i $$$ $$$ x_i $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ $$$ 1 \leq x_i \leq 1000000000 $$$ ) — index $$$ i $$$ -th element income usage exhibition guarantee $$$ a_i $$$ distinct next line contain a single integer $$$ m $$$ ( $$$ 1 \leq m \leq 100000 $$$ ) — number <unknown> invent topchemist $$$ j $$$ -th next $$$ m $$$ line contain two integers $$$ b_j $$$ $$$ y_j $$$ ( $$$ 1 \leq b_j \leq 1000000000 $$$ $$$ 1 \leq y_j \leq 1000000000 $$$ ) — index $$$ j $$$ -th element income usage exhibition guarantee $$$ b_j $$$ distinct print maximum total income obtain choose set company a way element present set first example chemforces choose set ( $$$ 3 7 $$$ ) topchemist choose ( $$$ 1 2 4 $$$ ) way total income $$$ ( 10 + 2 ) + ( 4 + 4 + 4 ) = 24 $$$ second example chemforces choose element $$$ 1000000000 $$$ topchemist choose ( $$$ 14 <unknown> 35 $$$ ) way total income $$$ ( 239 ) + ( 15 + 65 + 89 ) = <unknown> $$$,['sortings'],1000.0
768/A,` ` night gather watch begin shall end death i shall take wife hold land father children i shall wear crown win glory i shall live die post i <unknown> <unknown> i <unknown> wall i shield guard <unknown> <unknown> i <unknown> life <unknown> night 's watch night nights come . '' — night 's watch <unknown> begin watch jon snow assign task support stewards time n stewards provide support steward strength jon snow like support a steward exist least one steward strength strictly less least one steward strength strictly greater find many stewards jon support ? first line consist a single integer n ( 1 ≤ n ≤ 105 ) — number stewards jon snow second line consist n space separate integers a1 a2 ... ( 0 ≤ ai ≤ 109 ) represent value assign stewards output a single integer represent number stewards jon fee first sample jon snow support steward strength 1 steward strength less 1 support steward strength 5 steward strength greater 5 . second sample jon snow support steward strength 2 stewards strength less 2 greater 2,['sortings'],900.0
659/B,"soon berland hold a school team program olympiad m berland regions a team two people invite participate olympiad qualify contest form team hold attend n berland students least two <unknown> participate m regions berland result participants qualify competition integer score 0 800 inclusive team region form two members qualify competition region none replace a schoolboy region include team receive a greater number point may a situation a team region form uniquely , one school team meet properties describe case region need <unknown> additional contest two team region consider different least one schoolboy include one team include team guarantee region least two representatives participate qualify contest task give result qualify competition identify team region announce region <unknown> require additional contest first line input contain two integers n m ( 2 ≤ n ≤ 100 000 1 ≤ m ≤ 10 000 n ≥ 2 m ) — number participants qualify contest number regions berland next n line contain description participants qualify contest follow format : <unknown> ( a string length 1 10 character consist large small english letter ) region number ( integer 1 m ) number point score participant ( integer 0 800 inclusive ) guarantee surnames participants distinct least two people participate m regions surnames differ letter case consider distinct print m line i - th line print team i - th region — surnames two team members arbitrary order a single character ` ` ? '' ( without quote ) need spend qualify contest region first sample region team uniquely determine second sample team region 2 uniquely determine team region 1 three team : ` ` petrov '' - '' sidorov '' ` ` ivanov '' - '' sidorov '' ` ` ivanov '' - '' petrov '' impossible determine a team uniquely",['sortings'],1300.0
1545/A,aquamoon $$$ n $$$ friends stand a row leave right $$$ i $$$ -th friend leave wear a t - shirt a number $$$ a_i $$$ write friend a direction ( leave right ) begin direction friend right aquamoon make operations friends operation aquamoon choose two adjacent friends swap position operation direction choose friends also flip : leave right vice versa aquamoon hop operations number write t - shirt $$$ n $$$ friends row read leave right become non - decreasing also want friends a direction right end please find possible input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 50 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — number aquamoon 's friends second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq 100000 $$$ ) — number write t - <unknown> guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case exist a possible sequence operations print ` ` yes '' ( without quote ) ; otherwise print ` ` '' ( without quote ) print letter case ( upper lower ) possible list operations first test case :,['sortings'],1500.0
1713/B,"consider array $$$ a $$$ $$$ n $$$ positive integers may perform follow operation : let 's call $$$ f ( a ) $$$ minimum number operations need change array $$$ a $$$ array $$$ n $$$ zero determine permutations $$$ ^\dagger $$$ $$$ b $$$ $$$ a $$$ $$$ f ( a ) \leq f ( b ) $$$ true $$$ ^\dagger $$$ array $$$ b $$$ a permutation array $$$ a $$$ $$$ b $$$ consist elements $$$ a $$$ arbitrary order example $$$ [ <unknown> ] $$$ a permutation $$$ [ <unknown> ] $$$ $$$ [ 1,2,2 ] $$$ a permutation $$$ [ 1,2,3 ] $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — description array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print ` ` yes '' ( without quote ) permutations $$$ b $$$ $$$ a $$$ $$$ f ( a ) \leq f ( b ) $$$ true ` ` '' ( without quote ) otherwise output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first test case change elements $$$ 0 $$$ $$$ 5 $$$ operations show permutation $$$ [ 2 3 5 4 ] $$$ require less $$$ 5 $$$ operations change elements $$$ 0 $$$ third test case need $$$ 5 $$$ operations change elements $$$ 0 $$$ $$$ [ 2 3 3 1 ] $$$ need $$$ 3 $$$ operations",['sortings'],1000.0
1614/B,company ` ` divan 's sofas '' plan build $$$ n + 1 $$$ different build a coordinate line : let $$$ x_i $$$ coordinate $$$ i $$$ -th build get build $$$ i $$$ build $$$ j $$$ divan spend $$$ |x_i - <unknown> $$$ minutes $$$ |y| $$$ absolute value $$$ y $$$ build divan go build number $$$ 0 $$$ $$$ n $$$ businessman live build $$$ 0 $$$ new headquarter ` ` divan 's sofas '' first ten years construction divan visit $$$ i $$$ -th build $$$ a_i $$$ time time spend $$$ 2 \cdot <unknown> - x_i| $$$ minutes walk divan ask choose coordinate $$$ n + 1 $$$ build next ten years businessman spend little time walk possible test contain several test case first line contain one integer number $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line case contain integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number build ` ` divan 's sofas '' go build apart headquarter second line contain sequence $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000 $$$ ) $$$ a_i $$$ number visit $$$ i $$$ -th build guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case first line print number $$$ t $$$ — minimum time divan spend walk second line print sequence $$$ x_0 x_1 \ldots x_n $$$ $$$ n + 1 $$$ integers $$$ x_i $$$ ( $$$ -1000000 \le x_i \le 1000000 $$$ ) select coordinate $$$ i $$$ -th build show optimal answer exist coordinate exceed $$$ 1000000 $$$ multiple answer print let 's look first example divan visit first build $$$ a_1 = 1 $$$ time second $$$ a_2 = 2 $$$ time third $$$ a_3 = 3 $$$ time one optimal solution follow : total divan spend $$$ 4 + 4 + 6 = 14 $$$ minutes show impossible arrange build businessman spend less time among others $$$ x = [ 1 3 2 0 ] $$$ $$$ x = [ <unknown> -3 -6 -4 ] $$$ also correct answer first example,['sortings'],1000.0
53/D,"vasya a school pe teacher unlike pe teachers vasya n't like students stand line accord height instead <unknown> children stand follow order : a1 a2 ... , ai height i - th student line n number students line children find hard keep mind strange arrangement today form line follow order : b1 b2 ... bn upset vasya <unknown> vasya want rearrange children result order like : a1 a2 ... , move vasya swap two people stand next line help vasya find sequence swap lead arrangement vasya need require minimize number move first line contain integer n ( 1 ≤ n ≤ 300 ) number students second line contain n space - separated integers ai ( 1 ≤ ai ≤ 109 ) represent height student occupy i - th place must possess third line contain n space - separated integers bi ( 1 ≤ bi ≤ 109 ) represent height student occupy i - th place initial arrangement possible students possess similar heights guarantee possible arrange children require order i.e a b coincide multisets first line print integer k ( 0 ≤ k ≤ 106 ) number move require minimize k must exceed 106 . print k line contain two space - separated integers line pi pi + 1 ( 1 ≤ pi ≤ n - 1 ) mean vasya swap students occupy place pi pi + 1",['sortings'],1500.0
1762/G,"give array $$$ a $$$ consist $$$ n $$$ positive integers find permutation $$$ p $$$ $$$ [ 1,2 \dots n ] $$$ : report permutation exist test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 3 \leq n \leq 300000 $$$ ) — length array $$$ a $$$ second line test case contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — represent array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 300000 $$$ test case output ` ` '' permutation exist otherwise output ` ` yes '' first line print permutation $$$ p $$$ next line case multiple permutations print one output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first test case $$$ p= [ 1,2,3 ] $$$ permutation $$$ [ 1,2,3 ] $$$ satisfy give constraints second test case $$$ [ 1,3,2,4 ] $$$ $$$ [ <unknown> ] $$$ permutations also acceptable third test case prove exist permutation $$$ [ 1,2,3 ] $$$ satisfy give constraints",['sortings'],3100.0
1733/C,give array $$$ a $$$ $$$ n $$$ non - negative integers apply follow operation find sequence $$$ n $$$ operations make $$$ a $$$ non - decreasing prove always possible note minimize number operations array $$$ a_1 a_2 \ldots a_n $$$ non - decreasing $$$ a_1 \le a_2 \le \ldots \le a_n $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case test case consist two line first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — array guarantee sum $$$ n $$$ test case n't exceed $$$ 100000 $$$ test case print one integer $$$ m $$$ ( $$$ 0 \le m \le n $$$ ) number operations first line print $$$ m $$$ line line must contain two integers $$$ l_i r_i $$$ indices choose $$$ i $$$ -th operation ( $$$ 1 \le l_i < r_i \le n $$$ ) multiple solutions print second test case $$$ a $$$ change like : first third test case $$$ a $$$ already non - decreasing,['sortings'],1300.0
1626/A,"give a string $$$ s $$$ consist lowercase latin letter every letter appear twice task rearrange letter string a way pair letter appear exactly twice distance letter pair allow add remove letter show answer always exist multiple answer print first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases testcase consist a non - empty string $$$ s $$$ consist lowercase latin letter every letter appear string twice length string n't exceed $$$ <unknown> $$$ testcase print a single string every letter appear number time appear string $$$ s $$$ pair letter appear exactly twice distance letter pair multiple answer print first testcase example letter appear exactly twice letter ' l ' rearrange letter arbitrarily since distance compare second testcase example letter appear exactly twice ' a ' ' b ' ' c ' initially letter ' a ' distance $$$ 6 $$$ apart letter ' b ' distance $$$ 4 $$$ apart letter ' c ' distance $$$ 2 $$$ apart , rearrange letter rearrangement letter ' a ' distance $$$ 2 $$$ apart letter ' b ' distance $$$ 2 $$$ apart letter ' c ' distance $$$ 2 $$$ apart , answer valid third testcase example letter appear exactly twice thus rearrangement valid include change string",['sortings'],800.0
64/H,table <unknown> tournament participant complete competition accord give final stand table table give a sequence line line a format ` ` name score '' task prepare another table consist line form ` ` place name '' sort participant score ( desc . ) name lexicographically case a tie place numerate 1 . one participant score share place output something like ` ` 12 - 14 john '' please look sample clarification first line contain n ( 1 ≤ n ≤ 100 ) — number row table follow n line contain give table line form ` ` name score '' ` ` name '' a sequence lowercase latin letter ` ` score '' — integer number 0 1000 inclusive name distinct length name 1 10 character inclusive single space name score line print require table look sample output clarifications,['sortings'],2300.0
1088/B,"'re give array $$$ a $$$ repeat follow operation $$$ k $$$ time : find minimum non - zero element array print subtract non - zero elements array elements <unknown> print 0 . first line contain integers $$$ n $$$ $$$ k $$$ $$$ ( 1 \le n k \le 100000 ) $$$ length array number operations perform second line contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 1 \le a_i \le 1000000000 ) $$$ elements array print minimum non - zero element operation a new line first sample : first step : array $$$ [ 1,2,3 ] $$$ minimum non - zero element 1 . second step : array $$$ [ 0,1,2 ] $$$ minimum non - zero element 1 . third step : array $$$ [ <unknown> ] $$$ minimum non - zero element 1 . fourth fifth step : array $$$ [ <unknown> ] $$$ print 0 . second sample : first step : array $$$ [ <unknown> ] $$$ minimum non - zero element 3 . second step : array $$$ [ <unknown> ] $$$ minimum non - zero element 2","['implementation', 'sortings']",1000.0
1776/C,"alessia bernardo discover world competitive program book university library library consist $$$ m $$$ section number $$$ 1 $$$ $$$ m $$$ section contain book dedicate a particular subject different section correspond different subject order prevent students <unknown> library university establish a system pass pass a length $$$ y $$$ associate allow access interval $$$ y $$$ consecutive section library a visit student must choose exactly one book one section leave library pass use moment alessia bernardo $$$ n $$$ pass lengths $$$ x_1 \ x_2 \ \dots \ x_n $$$ different <unknown> best way improve : alessia think important study many different topics bernardo believe important study <unknown> least one topic , alessia want use $$$ n $$$ pass get $$$ n $$$ book distinct topics bernardo would like get least two book topic reach follow agreement : follow $$$ n $$$ days alessia choose a pass length $$$ y $$$ among still available interval $$$ y $$$ section library bernardo go library take exactly one book one section bernardo manage get least two book subject alessia able avoid ? decide whether want alessia bernardo fulfill goal choose character judge impersonate character note even moment bernardo already take two book subject interaction go end $$$ n $$$ days first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100 $$$ $$$ n \le m \le 5000 $$$ ) — number pass number section second line contain $$$ n $$$ integers $$$ x_1 \ x_2 \ \dots \ x_n $$$ ( $$$ 1 \le x_i \le m $$$ ) — lengths pass available first print a line contain either string $$$ \texttt { alessia } $$$ string $$$ \texttt { bernardo } $$$ — character want impersonate , $$$ n $$$ turn : one <unknown> malformed interactor terminate immediately program receive verdict $$$ \texttt { wrong - answer } $$$ otherwise receive verdict accord game 's criteria describe print a line forget end line flush output otherwise get verdict $$$ \texttt { <unknown> } $$$ flush output use : first sample show alessia <unknown> goal example interaction ( read input ) follow : $$$ $$$ \begin { array } { |c|c|c| } \hline \textbf { contestant } & \textbf { judge } & \textbf { explanation } \\ \hline \texttt { alessia } & & \text { program act alessia } \\ \hline 3 \quad 11 & & \text { choose $ y = 3 $ $ a = 11 $ } \\ \hline & 13 & \text { judge select $ b = 13 $ } \\ \hline 10 \quad 2 & & \text { choose $ y = 10 $ $ a = 2 $ } \\ \hline & 9 & \text { judge select $ b = 9 $ } \\ \hline 7 \quad 1 & & \text { choose $ y = 7 $ $ a = 1 $ } \\ \hline & 4 & \text { judge select $ b = 4 $ } \\ \hline 2 \quad 10 & & \text { choose $ y = 2 $ $ a = 10 $ } \\ \hline & 10 & \text { judge select $ b = 10 $ } \\ \hline 3 \quad 6 & & \text { choose $ y = 3 $ $ a = 6 $ } \\ \hline & 7 & \text { judge select $ b = 7 $ } \\ \hline \end { array } $$$ $$$ program contestant win book choose bernardo <unknown> different topics action perform contestant judge example interaction may non - optimal second sample show bernardo manage fulfil goal example interaction ( read input ) follow : $$$ $$$ \begin { array } { |c|c|c| } \hline \textbf { contestant } & \textbf { judge } & \textbf { explanation } \\ \hline \texttt { bernardo } & & \text { program act bernardo } \\ \hline & 4 \quad 1 & \text { judge choose $ y = 4 $ $ a = 1 $ } \\ \hline 4 & & \text { select $ b = 4 $ } \\ \hline & 1 \quad 10 & \text { judge choose $ y = 1 $ $ a = 10 $ } \\ \hline 10 & & \text { select $ b = 10 $ } \\ \hline & 6 \quad 3 & \text { judge choose $ y = 6 $ $ a = 3 $ } \\ \hline 4 & & \text { select $ b = 4 $ } \\ \hline & 4 \quad 5 & \text { judge choose $ y = 4 $ $ a = 5 $ } \\ \hline 8 & & \text { select $ b = 8 $ } \\ \hline \end { array } $$$ $$$ program contestant win bernardo select two book topic number $$$ 4 $$$ action perform contestant judge example interaction may non - optimal","['greedy', 'sortings']",2500.0
1075/B,palo alto unusual city endless coordinate line also know office lyft level 5 . lyft become popular use $$$ m $$$ taxi drivers city every day transport rest city residents — $$$ n $$$ riders resident ( include taxi drivers ) palo - alto live unique location ( pair residents coordinate ) lyft system clever : a rider call a taxi call go taxi drivers one closest person multiple ones distance taxi driver a smaller coordinate select one morning taxi drivers wonder : many riders would call give taxi driver first order a taxi day ? word need find taxi driver $$$ i $$$ number $$$ a _ { i } $$$ — number riders would call $$$ i $$$ -th taxi driver drivers riders home ? taxi driver neither transport taxi drivers first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100000 $$$ ) — number riders taxi drivers second line contain $$$ n + m $$$ integers $$$ x_1 x_2 \ldots x _ { n+m } $$$ ( $$$ 1 \le x_1 < x_2 < \ldots < x _ { n+m } \le 1000000000 $$$ ) $$$ x_i $$$ coordinate $$$ i $$$ -th resident live third line contain $$$ n + m $$$ integers $$$ t_1 t_2 \ldots t _ { n+m } $$$ ( $$$ 0 \le t_i \le 1 $$$ ) $$$ t_i = 1 $$$ $$$ i $$$ -th resident a taxi driver otherwise $$$ t_i = 0 $$$ guarantee number $$$ i $$$ $$$ t_i = 1 $$$ equal $$$ m $$$ print $$$ m $$$ integers $$$ a_1 a_2 \ldots a _ { m } $$$ $$$ a_i $$$ answer $$$ i $$$ -th taxi driver taxi driver number $$$ i $$$ among taxi drivers live $$$ i $$$ -th smallest coordinate ( see examples better understand ) first example one taxi driver mean order $$$ n $$$ riders go second example first taxi driver live point coordinate $$$ 2 $$$ second one live point coordinate $$$ 6 $$$ obviously nearest taxi driver rider live $$$ 3 $$$ coordinate first one rider live coordinate $$$ 5 $$$ second one rider live $$$ 4 $$$ coordinate distance first second taxi drivers since first taxi driver a smaller coordinate call rider go first taxi driver third example one rider taxi driver nearest fourth one,"['implementation', 'sortings']",1200.0
1080/F,"a important day <unknown> a test a program class always give interest problem solve fast solve problem ? give $$$ n $$$ order segment set segment represent a pair two integers $$$ [ l r ] $$$ $$$ l\leq r $$$ set contain arbitrary number segment ( even $$$ 0 $$$ ) possible segment equal also give $$$ m $$$ query represent four number : $$$ a b x y $$$ segment find whether true set $$$ p $$$ ( $$$ a\leq p\leq b $$$ ) contain least one segment $$$ [ l r ] $$$ lie entirely segment $$$ [ x y ] $$$ $$$ x\leq l\leq r\leq y $$$ find answer query note need solve problem online , get a new query print answer previous query first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ $$$ ( 1\leq n m\leq 100000 1\leq k\leq <unknown> ) $$$ — number set query segment respectively next $$$ k $$$ line contain three integers $$$ l $$$ $$$ r $$$ $$$ p $$$ $$$ ( 1\leq l\leq r\leq 1000000000 1\leq p\leq n ) $$$ — limit segment index a set segment belong next $$$ m $$$ line contain four integers $$$ a b x y $$$ $$$ ( 1\leq a\leq b\leq n 1\leq x\leq <unknown> 1000000000 ) $$$ — description query query print ` ` yes '' ` ` '' a new line print a query forget output end line flush output otherwise get idleness limit exceed , use : first query answer negative since second set contain a segment lie segment $$$ [ 2 3 ] $$$ second query first set contain $$$ [ 2 3 ] $$$ second set contain $$$ [ 2 4 ] $$$ third query first set contain $$$ [ 2 3 ] $$$ second set contain $$$ [ 2 4 ] $$$ third set contain $$$ [ 2 5 ] $$$ fourth query second set contain a segment lie segment $$$ [ 3 6 ] $$$ fifth query second set contain $$$ [ 2 4 ] $$$ third set contain $$$ [ 2 5 ] $$$ fourth contain $$$ [ 7 9 ] $$$","['data structures', 'sortings']",2400.0
1269/B,"give a positive integer $$$ m $$$ two integer sequence : $$$ a= [ a_1 a_2 \ldots a_n ] $$$ $$$ b= [ b_1 b_2 \ldots b_n ] $$$ sequence a length $$$ n $$$ permutation a sequence $$$ n $$$ different positive integers $$$ 1 $$$ $$$ n $$$ example sequence permutations : $$$ [ 1 ] $$$ $$$ [ 1,2 ] $$$ $$$ [ 2,1 ] $$$ $$$ [ <unknown> ] $$$ : $$$ [ 0 ] $$$ $$$ [ 1,1 ] $$$ $$$ [ 2,3 ] $$$ need find non - negative integer $$$ x $$$ increase elements $$$ a_i $$$ $$$ x $$$ modulo $$$ m $$$ ( i.e want change $$$ a_i $$$ $$$ ( a_i + x ) \bmod m $$$ ) would possible rearrange elements $$$ a $$$ make equal $$$ b $$$ among need find smallest possible $$$ x $$$ word need find smallest non - negative integer $$$ x $$$ possible find permutation $$$ p= [ p_1 p_2 \ldots p_n ] $$$ $$$ 1 \leq i \leq n $$$ $$$ ( a_i + x ) \bmod m = b _ { p_i } $$$ $$$ y \bmod m $$$ — remainder division $$$ y $$$ $$$ m $$$ example $$$ <unknown> $$$ $$$ a = [ 0 0 2 1 ] b = [ 2 0 1 1 ] $$$ choose $$$ <unknown> $$$ $$$ a $$$ equal $$$ [ 1 1 0 2 ] $$$ rearrange make equal $$$ [ 2 0 1 1 ] $$$ equal $$$ b $$$ first line contain two integers $$$ n m $$$ ( $$$ 1 \leq n \leq 2000 1 \leq m \leq 1000000000 $$$ ) : number <unknown> array $$$ m $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i < m $$$ ) third line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 0 \leq b_i < m $$$ ) guarantee exist non - negative integer $$$ x $$$ would possible find permutation $$$ p_1 p_2 \ldots p_n $$$ $$$ ( a_i + x ) \bmod m = b _ { p_i } $$$ print one integer smallest non - negative integer $$$ x $$$ would possible find permutation $$$ p_1 p_2 \ldots p_n $$$ $$$ ( a_i + x ) \bmod m = b _ { p_i } $$$ $$$ 1 \leq i \leq n $$$","['brute force', 'sortings']",1500.0
1375/D,'re give array $$$ n $$$ integers $$$ 0 $$$ $$$ n $$$ inclusive one operation choose element array replace mex elements array ( may change operation ) example current array $$$ [ 0 2 2 1 4 ] $$$ choose second element replace mex present elements — $$$ 3 $$$ array become $$$ [ 0 3 2 1 4 ] $$$ must make array non - decreasing use $$$ 2n $$$ operations prove always possible please note minimize number operations many solutions print – <unknown> array $$$ b [ 1 \ldots n ] $$$ non - decreasing $$$ b_1 \le b_2 \le \ldots \le b_n $$$ mex ( minimum exclude ) array smallest non - negative integer belong array instance : 's worth mention mex array length $$$ n $$$ always $$$ 0 $$$ $$$ n $$$ inclusive first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 1000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 \ldots a_n $$$ ( $$$ 0 \le a_i \le n $$$ ) — elements array note n't distinct guarantee sum $$$ n $$$ test case n't exceed $$$ 1000 $$$ test case must output two line : first line must contain a single integer $$$ k $$$ ( $$$ 0 \le k \le 2n $$$ ) — number operations perform second line must contain $$$ k $$$ integers $$$ x_1 \ldots x_k $$$ ( $$$ 1 \le x_i \le n $$$ ) $$$ x_i $$$ index choose $$$ i $$$ -th operation many solutions find please remember require minimize $$$ k $$$ first test case array already non - decreasing ( $$$ 2 \le 2 \le 3 $$$ ) explanation second test case ( element modify operation color red ) : explanation third test case :,"['brute force', 'sortings']",1900.0
1637/A,array $$$ a $$$ length $$$ n $$$ exactly select integer $$$ len $$$ $$$ 1 $$$ $$$ n - 1 $$$ inclusively sort non - decreasing order prefix array length $$$ len $$$ suffix array length $$$ n - len $$$ independently example array $$$ a = [ 3 1 4 5 2 ] $$$ choose $$$ len = 2 $$$ array equal $$$ [ 1 3 2 4 5 ] $$$ could perform operation array sort non - decreasing order ? several test case input data first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case follow test case description first line test case contain one integer $$$ n $$$ ( $$$ 2 \leq n \leq 10000 $$$ ) — length array second line test case contain a sequence integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — array elements guarantee sum $$$ n $$$ test case exceed $$$ 10000 $$$ test case input data output ` ` yes '' ( without quote ) array may sort non - decreasing order output ` ` '' ( without quote ) otherwise output letter case ( uppercase lowercase ) first test case 's possible select $$$ len = 1 $$$ operation array sort non - decreasing order equal $$$ [ 2 1 2 ] $$$ second test case 's possible select $$$ len = 3 $$$ operation array sort non - decreasing order equal $$$ [ 1 2 3 1 ] $$$ third test case array sort non - decreasing order every possible $$$ len $$$,"['brute force', 'sortings']",800.0
1607/C,"yelisey array $$$ a $$$ $$$ n $$$ integers $$$ a $$$ length strictly greater $$$ 1 $$$ <unknown> apply operation call minimum extraction : thus operation length array reduce $$$ 1 $$$ example $$$ a = [ 1 6 -4 -2 -4 ] $$$ minimum element $$$ a_3 = -4 $$$ mean operation array equal $$$ a= [ 1 { - ( -4 ) } 6 { - ( -4 ) } -2 { - ( -4 ) } -4 { - ( -4 ) } ] = [ 5 10 2 0 ] $$$ since yelisey like big number want number array $$$ a $$$ big possible formally <unknown> want make minimum number array $$$ a $$$ maximal possible ( i.e want maximize a minimum ) , yelisey apply minimum extraction operation array many time want ( possibly zero ) note operation apply array length $$$ 1 $$$ help find maximal value minimal element array apply several ( possibly zero ) minimum extraction operations array first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case next $$$ 2 t $$$ line contain descriptions test case description test case first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — original length array $$$ a $$$ second line description list $$$ n $$$ space - separated integers $$$ a_i $$$ ( $$$ -1000000000 \leq a_i \leq 1000000000 $$$ ) — elements array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ print $$$ t $$$ line contain answer correspond test case answer test case a single integer — maximal possible minimum $$$ a $$$ obtain several applications describe operation first example test case original length array $$$ n = 1 $$$ therefore minimum extraction apply thus array remain unchanged answer $$$ a_1 = 10 $$$ second set input data array always consist zero third set array change follow : $$$ [ \color { blue } { -1 } 2 0 ] \to [ 3 \color { blue } { 1 } ] \to [ \color { blue } { 2 } ] $$$ minimum elements highlight $$$ \color { blue } { \text { blue } } $$$ maximal one $$$ 2 $$$ fourth set array modify $$$ [ 2 10 \color { blue } { 1 } 7 ] \to [ \color { blue } { 1 } 9 6 ] \to [ 8 \color { blue } { 5 } ] \to [ \color { blue } { 3 } ] $$$ similarly maximum minimum elements $$$ 5 $$$","['brute force', 'sortings']",1000.0
1786/B,a cake <unknown> line a bakery optimize $$$ n $$$ cake make a time ! last step $$$ n $$$ cake cover chocolate consider a side view conveyor belt let a number line $$$ i $$$ -th cake occupy segment $$$ [ a_i - w a_i + w ] $$$ line pair segment common point conveyor $$$ n $$$ dispensers a common button press chocolate $$$ i $$$ -th <unknown> cover conveyor segment $$$ [ b_i - h b_i + h ] $$$ pair segment also common point <unknown> conveyor belt part yet perform make determine 's possible shift conveyor cake chocolate chocolate outside cake assume <unknown> long enough cake never fall also note button press test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow first line test case contain three integers $$$ n $$$ $$$ w $$$ $$$ h $$$ ( $$$ 1 \le n \le 100000 $$$ ; $$$ 1 \le w h \le 100000 $$$ ; $$$ h \le w $$$ ) — number cake dispensers well <unknown> cake segment chocolate <unknown> second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — position cake center guarantee $$$ a_i + w < a _ { i + 1 } - w $$$ $$$ i $$$ third line contain $$$ n $$$ integers $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_n $$$ ( $$$ 1 \le b_i \le 1000000000 $$$ ) — position dispensers guarantee $$$ b_i + h < b _ { i + 1 } - h $$$ $$$ i $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output ` ` yes '' 's possible shift conveyor a way cake end chocolate chocolate outside cake ` ` '' otherwise output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses first example show figure statement second example move conveyor example center cake $$$ 4 9 14 19 24 $$$ third example ca n't move conveyor accordingly,"['brute force', 'sortings']",1300.0
1121/A,"everybody know $$$ m $$$ <unknown> tournament happen soon $$$ m $$$ school participate tournament one student school participate a total $$$ n $$$ students school tournament students put name name school technogoblet fire , technogoblet select strongest student school participate arkady a hacker want $$$ k $$$ choose ones select technogoblet unfortunately strongest school arkady make new school name replace name technogoblet ca n't use made - up name case technogoblet would select strongest student made - up school know power student school study calculate minimal number school arkady make $$$ k $$$ choose ones would select technogoblet first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n \le 100 $$$ $$$ 1 \le m k \le n $$$ ) — total number students number school number choose ones second line contain $$$ n $$$ different integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) $$$ p_i $$$ denote power $$$ i $$$ -th student bigger power stronger student third line contain $$$ n $$$ integers $$$ s_1 s_2 \ldots s_n $$$ ( $$$ 1 \le s_i \le m $$$ ) $$$ s_i $$$ denote school $$$ i $$$ -th student go least one student study school fourth line contain $$$ k $$$ different integers $$$ c_1 c_2 \ldots c_k $$$ ( $$$ 1 \le c_i \le n $$$ ) — i d 's choose ones output a single integer — minimal number school make arkady $$$ k $$$ choose ones would select technogoblet first example 's a single choose one i d $$$ 3 $$$ power equal $$$ 3 $$$ school $$$ 1 $$$ 's a student i d $$$ 5 $$$ power $$$ 6 $$$ mean <unknown> would lead latter choose , however make a new school ( let i d $$$ 4 $$$ ) choose one technogoblet would select students ids $$$ 2 $$$ ( strongest $$$ 3 $$$ ) $$$ 5 $$$ ( strongest $$$ 1 $$$ ) $$$ 6 $$$ ( strongest $$$ 2 $$$ ) $$$ 3 $$$ ( strongest $$$ 4 $$$ ) second example change school student $$$ 3 $$$ made - up $$$ 5 $$$ school student $$$ 4 $$$ made - up $$$ 6 $$$ cause technogoblet choose students $$$ 8 $$$ $$$ 7 $$$ $$$ 6 $$$ $$$ 5 $$$ $$$ 3 $$$ $$$ 4 $$$","['implementation', 'sortings']",1100.0
1740/C,"$$$ n $$$ bricks number $$$ 1 $$$ $$$ n $$$ brick $$$ i $$$ a weight $$$ a_i $$$ pak chanek $$$ 3 $$$ bag number $$$ 1 $$$ $$$ 3 $$$ initially empty brick pak chanek must put one bag , bag must contain least one brick pak chanek distribute bricks bu dengklek take exactly one brick bag let $$$ <unknown> $$$ weight brick bu dengklek take bag $$$ j $$$ score calculate $$$ <unknown> - <unknown> + <unknown> - <unknown> $$$ $$$ |x| $$$ denote absolute value $$$ x $$$ know bu dengklek take bricks a way <unknown> score maximum possible final score pak chanek distribute bricks optimally ? test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 20000 $$$ ) — number test case follow line contain description test case first line test case contain integer $$$ n $$$ ( $$$ 3 \leq n \leq 200000 $$$ ) — number bricks second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — weight bricks guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a line contain integer represent maximum possible final score pak chanek distribute bricks optimally first test case one way achieve a final score $$$ 6 $$$ follow : pak chanek distribute bricks way a way bu dengklek take bricks : score $$$ <unknown> - <unknown> + <unknown> - <unknown> = |3 - 5| + |5 - 1| = 6 $$$ show bu dengklek get a smaller score distribution show distribution result a final score bigger $$$ 6 $$$","['greedy', 'sortings']",1400.0
710/B,give n point a line coordinate xi find point x sum distance give point minimal first line contain integer n ( 1 ≤ n ≤ 3·105 ) — number point line second line contain n integers xi ( - 109 ≤ xi ≤ 109 ) — coordinate give n point print integer x — position optimal point line several optimal point print position leftmost one guarantee answer always integer,"['brute force', 'sortings']",1400.0
1137/A,"dora love adventure quite a lot journey encounter <unknown> city form $$$ n $$$ streets along eastern direction $$$ m $$$ streets across southern direction naturally city $$$ nm $$$ intersections intersection $$$ i $$$ -th eastern street $$$ j $$$ -th southern street a <unknown> skyscraper dora instantly become curious decide explore heights city build dora pass intersection $$$ i $$$ -th eastern $$$ j $$$ -th southern street examine two streets dora learn heights skyscrapers two streets wonder : one <unknown> heights skyscrapers two streets maximum height would small possible result compare heights two skyscrapers one street would n't change formally every $$$ nm $$$ intersections dora solve independent problem see $$$ n + m - 1 $$$ skyscrapers know real height moreover two heights compare get a result ` ` greater '' ` ` smaller '' ` ` equal '' dora want select integer $$$ x $$$ assign every skyscraper a height $$$ 1 $$$ $$$ x $$$ assign heights dora want preserve relative order skyscrapers streets , result comparison heights two skyscrapers current eastern street n't change result comparison heights two skyscrapers current southern street n't change well note skyscrapers locate southern street compare skyscrapers locate eastern street however skyscraper locate streets intersection compare southern eastern skyscrapers every intersection dora want independently calculate minimum possible $$$ x $$$ example intersection two streets correspond look follow : optimal replace heights skyscrapers follow ( note <unknown> ` ` less '' ` ` equal '' ` ` greater '' inside eastern street inside southern street preserve ) largest use number $$$ 5 $$$ hence answer intersection would $$$ 5 $$$ help dora compute answer intersection first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 1000 $$$ ) — number streets go eastern direction number streets go southern direction follow $$$ n $$$ line contain $$$ m $$$ integers $$$ a _ { <unknown> } $$$ $$$ a _ { <unknown> } $$$ ... $$$ a _ { i m } $$$ ( $$$ 1 \le a _ { i j } \le 1000000000 $$$ ) integer $$$ a _ { i j } $$$ locate $$$ j $$$ -th position $$$ i $$$ -th line denote height skyscraper intersection $$$ i $$$ -th eastern street $$$ j $$$ -th southern direction print $$$ n $$$ line contain $$$ m $$$ integers integer $$$ x _ { i j } $$$ locate $$$ j $$$ -th position inside $$$ i $$$ -th line answer problem intersection $$$ i $$$ -th eastern street $$$ j $$$ -th southern street first example 's possible decrease maximum use height problem intersection hence n't change heights second example answer follow :","['implementation', 'sortings']",1600.0
794/C,oleg client igor <unknown> good friends however sometimes argue little things recently start a new company trouble find a name company settle problem ' ve decide play a game company name consist n letter oleg igor a set n letter ( might contain multiple copy letter set different ) initially company name denote n question mark oleg igor take turn play game oleg move first turn a player choose one letter c set replace question mark c. a copy letter c remove set game end question mark replace letter example suppose oleg set letter { i o i } igor set letter { i m o } one possible game follow : initially company name ? ? ? oleg replace second question mark ' i ' company name become ? i ? set letter oleg { i o } igor replace third question mark ' o ' company name become ? io set letter igor { i m } finally oleg replace first question mark ' o ' company name become oio set letter oleg { i } end company name oio oleg want company name lexicographically small possible igor want company name lexicographically large possible company name oleg igor always play optimally ? a string s = s1s2 ... sm call lexicographically smaller a string t = t1t2 ... tm ( s ≠ t ) si < ti i smallest index si ≠ ti ( sj = <unknown> j < i ) first line input contain a string s length n ( 1 ≤ n ≤ 3·105 ) character string lowercase english letter string denote set letter oleg initially second line input contain a string t length n. character string lowercase english letter string denote set letter igor initially output contain a string n lowercase english letter denote company name oleg igor play optimally one way play optimally first sample follow : second sample matter play company name always <unknown>,"['greedy', 'sortings']",1800.0
1627/B,rahul tina look forward start new year college enter new classroom observe seat students arrange a $$$ n \times m $$$ grid seat row $$$ r $$$ column $$$ c $$$ denote $$$ ( r c ) $$$ distance two seat $$$ ( a b ) $$$ $$$ ( c d ) $$$ $$$ |a - <unknown> + <unknown> - <unknown> $$$ class president tina access exactly $$$ k $$$ bucket pink paint follow process occur rahul want choose a seat sit close tina possible however tina want sit far away rahul possible due complicate <unknown> history could n't fit statement ! rahul wonder $$$ k = 0 1 \dots n \cdot m - 1 $$$ tina $$$ k $$$ bucket paint close rahul sit tina rahul tina aware 's intentions act <unknown> possible ? please help satisfy rahul 's curiosity ! input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 50000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \cdot m \leq 100000 $$$ ) — number row columns seat classroom sum $$$ n \cdot m $$$ across test case exceed $$$ 100000 $$$ test case output $$$ n \cdot m $$$ order integers — distance rahul tina act optimally every $$$ k \in [ 0 n \cdot m - 1 ] $$$ one possible sequence choices first testcase tina $$$ k=3 $$$ bucket paint follow tina paint seat position $$$ ( 1 2 ) $$$ $$$ ( 2 2 ) $$$ $$$ ( 3 2 ) $$$ pink paint rahul choose seat $$$ ( 3 1 ) $$$ tina choose sit $$$ ( 1 3 ) $$$ therefore distance tina rahul $$$ |3 - 1| + |1 - 3| = 4 $$$ prove indeed minimum possible distance give constraints may choices seat lead answer well $$$ k=0 $$$ first test case rahul decide sit $$$ ( 2 2 ) $$$ tina decide sit $$$ ( 4 3 ) $$$ distance would $$$ |2 - 4| + |2 - 3| = 3 $$$ <unknown> representations $$$ k=3 $$$ $$$ k=0 $$$ case first test case,"['greedy', 'sortings']",1300.0
1398/B,"alice bob play a game a binary string $$$ s $$$ ( a string character either $$$ 0 $$$ $$$ 1 $$$ ) alice move first bob alice , move player choose number ( less one ) consecutive equal character $$$ s $$$ delete example string $$$ <unknown> $$$ $$$ 6 $$$ possible move ( delete character bold ) : character remove character leave right remove block become adjacent i. e. follow sequence move valid : $$$ <unknown> { 11 } 0 \to <unknown> { 00 } \to 1 $$$ game end string become empty score player number $$$ 1 $$$ -characters delete player want maximize score calculate result score alice first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case test case contain exactly one line contain a binary string $$$ s $$$ ( $$$ 1 \le |s| \le 100 $$$ ) test case print one integer — result score alice ( number $$$ 1 $$$ -characters delete ) question optimal strategy ignore","['greedy', 'sortings']",800.0
388/C,fox ciel play a card game friend fox jiro n pile card table a positive integer card players take turn ciel take first turn ciel 's turn take a card top non - empty pile jiro 's turn take a card bottom non - empty pile player want maximize total sum card take game end pile become empty suppose ciel jiro play optimally score game ? first line contain integer n ( 1 ≤ n ≤ 100 ) next n line contain a description pile : first integer line si ( 1 ≤ si ≤ 100 ) — number card i - th pile ; follow si positive integers c1 c2 ... ck ... <unknown> ( 1 ≤ ck ≤ 1000 ) — sequence number card list top current pile bottom pile print two integers : sum ciel 's card sum jiro 's card play optimally first example ciel take card number 100 1 jiro take card number 10 . second example ciel take card number 2 8 6 5 9 jiro take card number 4 7 1 3,"['greedy', 'sortings']",2000.0
538/G,help ! a robot escape lab need help find lab point ( 0 0 ) coordinate plane time 0 robot robot 's movements define a program — a string length l consist character u l d r. second robot execute next command program : current coordinate robot ( x y ) command u l d r move cells ( x y + 1 ) ( x - 1 y ) ( x y - 1 ) ( x + 1 y ) respectively execution program start time 0 . program loop i.e l second execute program start first character unfortunately n't know program load robot leave lab <unknown> manage find position robot n moments time : know moment time ti robot point ( xi yi ) give data either help determine program could load robot determine possible program meet data robot must break first line input contain two space - separated integers n l ( 1 ≤ n ≤ 2·105 1 ≤ l ≤ 2·106 ) next n line contain three space - separated integers — ti xi yi ( 1 ≤ ti ≤ 1018 - 1018 ≤ xi yi ≤ 1018 ) radar data give chronologically i.e ti < ti + 1 i 1 n - 1 . print possible program meet data program meet data print a single word ' no ' ( without quote ),"['math', 'sortings']",3100.0
1360/C,"call two number $$$ x $$$ $$$ y $$$ similar parity ( remainder divide $$$ 2 $$$ ) $$$ |x - <unknown> $$$ example pair $$$ ( 2 6 ) $$$ $$$ ( 4 3 ) $$$ $$$ ( 11 7 ) $$$ number similar pair $$$ ( 1 4 ) $$$ $$$ ( 3 12 ) $$$ , give array $$$ a $$$ $$$ n $$$ ( $$$ n $$$ even ) positive integers check a partition array pair element array belong exactly one pair number pair similar example array $$$ a = [ 11 14 16 12 ] $$$ a partition pair $$$ ( 11 12 ) $$$ $$$ ( 14 16 ) $$$ number first pair similar differ one second pair even first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case $$$ t $$$ test case follow test case consist two line first line contain even positive integer $$$ n $$$ ( $$$ 2 \le n \le 50 $$$ ) — length array $$$ a $$$ second line contain $$$ n $$$ positive integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100 $$$ ) test case print : letter word yes display case first test case explain statement second test case two give number similar third test case partition suitable","['greedy', 'sortings']",1100.0
934/A,"<unknown> a monster live deep <unknown> a year show land <unknown> <unknown> even people order keep monster away people fill villages red colour light crack <unknown> <unknown> monster come little tommy n lanterns big banban m lanterns tommy 's lanterns brightness a1 a2 ... , banban 's brightness b1 b2 ... bm respectively tommy intend hide one lanterns banban pick one tommy 's non - <unknown> lanterns one lanterns form a pair pair 's brightness product brightness two lanterns tommy want make product small possible banban try make large possible ask find brightness choose pair choose optimally first line contain two space - separated integers n m ( 2 ≤ n m ≤ 50 ) second line contain n space - separated integers a1 a2 ... , third line contain m space - separated integers b1 b2 ... bm integers range - 109 109 . print a single integer — brightness choose pair first example tommy hide 20 banban choose 18 tommy 14 second example tommy hide 3 banban choose 2 tommy 1",['brute force'],1400.0
1034/B,"little c love number « 3 » much love things play a game a chessboard size $$$ n \times m $$$ cell $$$ x $$$ -th row $$$ y $$$ -th column call $$$ ( x y ) $$$ initially chessboard empty time place two chessmen two different empty cells manhattan distance exactly $$$ 3 $$$ manhattan distance two cells $$$ ( x_i y_i ) $$$ $$$ ( x_j y_j ) $$$ define $$$ |x_i - <unknown> - <unknown> $$$ want place many chessmen possible chessboard please help find maximum number chessmen place a single line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 1000000000 $$$ ) — number row number columns chessboard print one integer — maximum number chessmen little c place first example manhattan distance two cells smaller $$$ 3 $$$ answer $$$ 0 $$$ second example a possible solution $$$ ( 1,1 ) ( 3,2 ) $$$ $$$ ( 1,2 ) ( 3,3 ) $$$ $$$ ( 2,1 ) ( 1,3 ) $$$ $$$ ( 3,1 ) ( 2,3 ) $$$",['brute force'],2200.0
1057/B,get news ddos - <unknown> popular <unknown> arseny admin think a website a ddos - attack total number request a period time exceed $$$ 100 \cdot t $$$ $$$ t $$$ — number second time segment arseny know statistics number request per second since server boot know sequence $$$ r_1 r_2 \dots r_n $$$ $$$ r_i $$$ — number request $$$ i $$$ -th second boot determine length longest continuous period time arseny consider a ddos - attack a seek time period go beyond boundaries segment $$$ [ 1 n ] $$$ first line contain $$$ n $$$ ( $$$ 1 \le n \le 5000 $$$ ) — number second since server boot second line contain sequence integers $$$ r_1 r_2 \dots r_n $$$ ( $$$ 0 \le r_i \le 5000 $$$ ) $$$ r_i $$$ — number request $$$ i $$$ -th second print integer number — length longest time period consider a ddos - attack arseny n't exist print 0,['brute force'],1400.0
1028/F,consider a set point $$$ a $$$ initially empty three type query : first line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query follow $$$ q $$$ line describe a query contain three integers $$$ t_i $$$ $$$ x_i $$$ $$$ y_i $$$ ( $$$ t_i \in \ { 1 2 3\ } $$$ $$$ 1 \le x_i y_i \le <unknown> $$$ ) — type query coordinate point type $$$ 1 $$$ addition point type $$$ 2 $$$ removal point type $$$ 3 $$$ query compute minimum number point require make $$$ a $$$ symmetrical guarantee $$$ 100000 $$$ query type $$$ 3 $$$ $$$ 100000 $$$ query type $$$ 1 $$$ $$$ 2 $$$ query third type output a line a single integer — answer query first example show picture,['brute force'],2900.0
1017/H,` ` man high castle '' world $$$ m $$$ different film end abendsen own a storage a shelf first $$$ n $$$ order film shelf $$$ i $$$ -th month : answer abendsen 's question let probability fraction $$$ p_i $$$ let 's say total number ways take $$$ n $$$ film storage $$$ i $$$ -th month $$$ a_i $$$ $$$ p_i \cdot a_i $$$ always integer print month $$$ p_i \cdot a_i \pmod { 998244353 } $$$ $$$ 998244353 $$$ a prime number equal $$$ <unknown> \cdot 2^ { 23 } + 1 $$$ guarantee $$$ 100 $$$ different $$$ k $$$ value first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \le n m q \le 100000 $$$ $$$ <unknown> 100000 $$$ ) — number film shelf initially number end number months second line contain $$$ n $$$ integers $$$ e_1 e_2 \ldots <unknown> $$$ ( $$$ 1\leq <unknown> m $$$ ) — end $$$ i $$$ -th film shelf next $$$ q $$$ line contain three integers $$$ l_i $$$ $$$ r_i $$$ $$$ k_i $$$ ( $$$ 1 \le l_i \le r_i \le n 0 \le k_i \le 100000 $$$ ) — $$$ i $$$ -th query guarantee $$$ 100 $$$ different $$$ k $$$ value print answer question a separate line first sample second query add $$$ 2 \cdot m $$$ film storage storage look like : $$$ \ { 1 1 1 2 2 2 3 3 3 4 4 4 4 4\ } $$$ $$$ 26730 $$$ total ways choose film $$$ <unknown> e _ { l+1 } \ldots <unknown> $$$ change example $$$ [ 1 2 3 2 2 ] $$$ $$$ [ 1 2 3 4 3 ] $$$ ways $$$ 2162160 $$$ total ways choose film 're ask print $$$ ( \frac { 26730 } { 2162160 } \cdot 2162160 ) \mod 998244353 = 26730 $$$,['brute force'],3300.0
982/A,'re give a row $$$ n $$$ chair call a seat people ` ` maximal '' two follow condition hold : seat give a string consist zero ones ( $$$ 0 $$$ mean correspond seat empty $$$ 1 $$$ — occupy ) goal determine whether seat ` ` maximal '' note first last seat adjacent ( $$$ n \ne 2 $$$ ) first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000 $$$ ) — number chair next line contain a string $$$ n $$$ character either zero one describe seat output ` ` yes '' ( without <unknown> mark ) seat ` ` maximal '' otherwise print ` ` '' allow print letter whatever case 'd like ( uppercase lowercase ) sample case one give seat maximal sample case two person chair three a neighbour right sample case three possible seat yet another person chair three,['brute force'],1200.0
958/C1,"rebel spy heidi obtain plan death star empire way safety try break encryption plan ( course encrypt – empire may evil stupid ! ) encryption several level security first one look heidi present a screen show a sequence integers a a positive integer p. know encryption code a single number s define follow : define score x sum elements x modulo p. heidi give a sequence a consist n integers also give integer p. need split a 2 part : output sum s encryption code first line input contain two space - separated integer n p ( 2 ≤ n ≤ 100 000 2 ≤ p ≤ 10 000 ) – number elements a modulo compute score respectively second line contain n space - separated integers elements a. integer interval [ 1 1 000 000 ] output number s describe problem statement first example score maximize input sequence split two part ( 3 4 ) ( 7 2 ) give total score second example score maximize first part consist first three elements second part consist rest , score",['brute force'],1200.0
949/E,never late play fancy ` ` binary card '' game ! infinite amount card positive negative rank use game absolute value card rank a power two i.e card a rank either 2k - 2k integer k ≥ 0 . infinite amount card valid rank begin game player form deck multiset ( possibly empty ) card allow pick number card rank small deck consider a skill <unknown> game consist n round i - th round jury tell player integer ai player <unknown> draw a subset deck sum rank choose card equal ai ( allow draw card case sum consider equal zero ) player fail lose game otherwise player take back card deck game proceed next round player consider a winner able draw suitable set card round somebody tell number ai jury go tell round want pick a deck consist minimum number card allow win ` ` binary card '' game first line input contain integer n ( 1 ≤ n ≤ 100 000 ) number round game second line input contain n integers a1 a2 ... ( - 100 000 ≤ ai ≤ 100 000 ) number jury go tell round first line print integer k ( 0 ≤ k ≤ 100 000 ) minimum number card pick deck order win ` ` binary card '' second line print k integers b1 b2 ... bk ( - 220 ≤ bi ≤ 220 |bi| a power two ) rank card deck may output rank order several <unknown> deck allow print guarantee exist a deck minimum size satisfy requirements first sample round game may simply draw card note sample test one satisfy first test group constraints second sample may draw card - 1 first round card 4 - 1 second round nothing third round card 4 fourth round whole deck fifth round,['brute force'],2700.0
932/C,a permutation p [ 1 ... n ] integers 1 n function f define follow : let g ( i ) minimum positive integer j f ( i j ) = i. show j always exist give n a b find a permutation p integers 1 n 1 ≤ i ≤ n g ( i ) equal either a b. line contain three integers n a b ( 1 ≤ n ≤ 106 1 ≤ a b ≤ n ) permutation exist output -1 . otherwise output a permutation integers 1 n. first example g ( 1 ) = g ( 6 ) = g ( 7 ) = g ( 9 ) = 2 g ( 2 ) = g ( 3 ) = g ( 4 ) = g ( 5 ) = g ( 8 ) = 5 second example g ( 1 ) = g ( 2 ) = g ( 3 ) = 1,['brute force'],1600.0
922/B,imp a magic forest xorangles grow ( <unknown> ? ) a xorangle order n a non - degenerate triangle lengths side integers exceed n xor - sum lengths equal zero imp count number distinct xorangles order n get forest formally a give integer n find number triple ( a b c ) : line contain a single integer n ( 1 ≤ n ≤ 2500 ) print number xorangles order n. xorangle first sample ( 3 5 6 ),['brute force'],1300.0
911/C,mishka decorate <unknown> tree get three garland put tree mishka switch garland a garland switch <unknown> change state — sometimes light sometimes formally i - th garland switch x - th second light second x x + ki x + <unknown> x + <unknown> mishka want switch garland a way second switch garland would least one light garland formally mishka want choose three integers x1 x2 x3 ( necessarily distinct ) switch first garland x1 - th second second one — x2 - th second third one — x3 - th second respectively second start max ( x1 x2 x3 ) least one garland light help mishka tell possible ! first line contain three integers k1 k2 k3 ( 1 ≤ ki ≤ <unknown> ) — time intervals garland mishka choose moments time switch garland a way second switch garland least one garland light print yes otherwise print first example mishka choose x1 = 1 x2 = 2 x3 = 1 . first garland light second 1 3 5 7 ... second — 2 4 6 8 ... already cover second 2 - nd one n't even matter x3 choose choice lead third light second 1 4 7 10 ... though second example way choose moments time always second garland light,['brute force'],1400.0
886/A,a small proud high school decide win acm icpc goal require compose many team three possible since 6 students wish participate decision build exactly two team practice competition participant number i get a score ai team score define sum score participants high school management interest 's possible build two team equal score task answer question single line contain six integers a1 ... <unknown> ( 0 ≤ ai ≤ 1000 ) — score <unknown> ` ` yes '' ( quote clarity ) possible build team equal score ` ` '' otherwise print character either <unknown> lowercase ( ` ` yes '' ` ` yes '' valid answer ` ` yes '' ) first sample first team compose 1st 2nd 6th participant second — 3rd 4th 5th : team score 1 + 3 + 1 = 2 + 1 + 2 = 5 . second sample score participant number 6 high : team score definitely greater,['brute force'],1000.0
856/A,masha grisha like study set positive integers one day grisha write a set a contain n different integers ai a blackboard ask masha create a set b contain n different integers bj n2 integers obtain sum ai bj possible pair i j different masha grisha n't like big number number a 1 106 number b must also range help masha create set b satisfy grisha 's requirement input data contain multiple test case first line contain integer t — number test case ( 1 ≤ t ≤ 100 ) test case describe follow way : first line description contain one integer n — number elements a ( 1 ≤ n ≤ 100 ) second line contain n integers ai — elements a ( 1 ≤ ai ≤ 106 ) test first print answer :,['brute force'],1600.0
838/A,"give image represent a 2 - d n m grid pixels pixel image either denote character ` ` 0 '' ` ` 1 '' respectively would like compress image want choose integer k > 1 split image k k block n m divisible k image pad zero right bottom divisible k. pixel individual block must value give image may compressible current state find minimum number pixels need toggle ( pad ) order image compressible k. specifically step first choose k image pad zero , toggle pixels compressible k. image must compressible state first line input contain two integers n m ( 2 ≤ n m ≤ 2 500 ) dimension image next n line input contain a binary string exactly m character represent image print a single integer minimum number pixels need toggle make image compressible first choose k = 2 . image pad follow : toggle image look follow : see image compressible k = 2",['brute force'],1400.0
801/A,<unknown> a keyboard two letter ` ` v '' ` ` k '' one day type a string s two letter really like string ` ` vk '' appear wish change one letter string ( change ) maximize number occurrences string compute maximum number time ` ` vk '' appear a substring ( i. e. a letter ` ` k '' right a letter ` ` v '' ) result string first line contain a string s consist uppercase english letter ` ` v '' ` ` k '' length less 1 greater 100 . output a single integer maximum number time ` ` vk '' appear a substring give string change one character first case change letter ` ` vk '' appear maximum number time could appear second case change second character a ` ` v '' a ` ` k '' give us string ` ` vk '' one occurrence string ` ` vk '' a substring fourth case change fourth character a ` ` k '' a ` ` v '' give us string ` ` <unknown> '' three occurrences string ` ` vk '' a substring check move give us strictly occurrences,['brute force'],1100.0
681/B,kolya develop economy <unknown> game <unknown> part development process in - game test entertain test much find game - coin score become equal 0 . kolya remember begin game game - coin score equal n buy house ( 1 234 567 game - coins ) cars ( 123 456 game - coins ) computers ( 1 234 game - coins ) kolya interest whether could spend initial n game - coins buy house cars computers a bug game formally a triple non - negative integers a b c a × 1 234 567 + b × 123 456 + c × 1 234 = n ? please help kolya answer question first line input contain a single integer n ( 1 ≤ n ≤ 109 ) — kolya 's initial game - coin score print ` ` yes '' ( without quote ) 's possible kolya spend initial n coin buy house cars computers otherwise print ` ` '' ( without quote ) first sample one possible solutions buy one house one car one computer spend 1 234 567 + 123 456 + <unknown> = 1 <unknown> <unknown> game - coins total,['brute force'],1300.0
665/B,ayush a <unknown> shop center recently department start a ` ` click collect '' service allow users shop online store contain k items n customers already use service user pay m items let aij denote j - th item i - th person 's order due space limitations items arrange one single row ayush receive i - th order find one one items aij ( 1 ≤ j ≤ m ) row let pos ( x ) denote position item x row moment collection ayush take time equal pos ( ai1 ) + pos ( ai2 ) + ... + pos ( aim ) i - th customer ayush access x - th element keep a new stock front row take away x - th element thus value update task calculate total time take ayush process order assume market endless stock first line contain three integers n m k ( 1 ≤ n k ≤ 100 1 ≤ m ≤ k ) — number users number items user want buy total number items market next line contain k distinct integers pl ( 1 ≤ pl ≤ k ) denote initial position items store items number integers 1 k. next n line contain m distinct integers aij ( 1 ≤ aij ≤ k ) — order i - th person print integer t — total time need ayush process order customer 1 want items 1 <unknown> ( 1 ) = 3 new position : [ 1 3 4 2 5 ] .pos ( 5 ) = 5 new position : [ 5 1 3 4 2 ] time take first customer 3 + 5 = 8 . customer 2 want items 3 <unknown> ( 3 ) = 3 new position : [ 3 5 1 4 2 ] .pos ( 1 ) = 3 new position : [ 1 3 5 4 2 ] time take second customer 3 + 3 = 6 . total time 8 + 6 = 14 . formally pos ( x ) index x current row,['brute force'],1400.0
632/B,alice bob play a game game involve split game piece two team n piece i - th piece a strength pi way split game piece split several step : strength a player sum strengths piece group give alice 's initial split two team help bob determine optimal strategy return maximum strength achieve first line contain integer n ( 1 ≤ n ≤ 5·105 ) — number game piece second line contain n integers pi ( 1 ≤ pi ≤ 109 ) — strength i - th piece third line contain n character a b — assignment team first step ( alice 's step ) print integer a — maximum strength bob achieve first sample bob flip suffix length one second sample bob flip prefix suffix ( ) length 5 . third sample bob nothing,['brute force'],1400.0
629/B,famil door want celebrate birthday friends far far away n friends come party a specific range days year ai bi course famil door want many friends celebrate together possible far cars weird far far away citizens carry two people opposite <unknown> exactly one male one female however far far transportation may use get party famil door select day year invite friends available moment number male friends invite equal number female friends invite find maximum number friends may present party first line input contain a single integer n ( 1 ≤ n ≤ 5000 ) — number famil door 's friends follow n line describe friends line start a capital letter ' f ' female friends a capital letter ' m ' male friends follow two integers ai bi ( 1 ≤ ai ≤ bi ≤ <unknown> ) provide i - th friend come party day ai day bi inclusive print maximum number people may come famil door 's party first sample friends 3 4 come day range [ <unknown> <unknown> ] second sample friends indices 3 4 5 6 come day <unknown>,['brute force'],1100.0
508/A,"pasha love phone also put hair ... hair <unknown> pasha instal a new game phone goal game follow a rectangular field consist n row m pixels row initially pixels color white one move pasha choose pixel color black particular choose pixel already black boy 's move pixel change , remain black pasha lose game a 2 × 2 square consist black pixels form pasha make a plan k move accord paint pixels turn plan represent a pair number i j denote respectively row column pixel color current move determine whether pasha lose act <unknown> plan , move 2 × 2 square consist black pixels form first line input contain three integers n m k ( 1 ≤ n m ≤ 1000 1 ≤ k ≤ 105 ) — number row number columns number move pasha go perform next k line contain pasha 's move order make line contain two integers i j ( 1 ≤ i ≤ n 1 ≤ j ≤ m ) represent row number column number pixel paint a move pasha lose print number move 2 × 2 square consist black pixels form pasha n't lose , 2 × 2 square consist black pixels form give k move print 0",['brute force'],1100.0
488/A,"giga tower <unknown> deepest build cyberland 17 777 777 777 floor number - 8 888 888 888 8 888 888 888 . particular floor 0 floor - 1 floor 1 . every day <unknown> tourists come place enjoy wonderful view cyberland believe number ` ` 8 '' a lucky number ( 's giga tower 8 888 888 888 floor grind ) , integer lucky decimal notation contain least one digit ` ` 8 '' example 8 - 180 <unknown> lucky 42 - 10 giga tower write code a floor lucky floor number good luck always ( well round # <unknown> also lucky <unknown> ? ) tourist <unknown> go tower seek good luck floor number a. want find minimum positive integer b , walk b floor higher arrive a floor a lucky number line input contain integer a ( - 109 ≤ a ≤ 109 ) print minimum b a line first sample arrive floor number 180 . second sample arrive 8 . note b positive answer third sample 10 0",['brute force'],1100.0
897/B,"— i experience many great things . — give memories like dream ... i leave ... — one last request ... — help solve a codeforces problem ? — <unknown> — ? chtholly think a problem days : a number palindrome length decimal representation without lead zero even call a zcy number a number palindrome mean write decimal representation contain lead zero read forward backwards example 12321 1221 palindromes 123 <unknown> moreover 1221 zcy number 12321 give integers k p calculate sum k smallest zcy number output sum modulo p. unfortunately willem n't good solve kind problems ask help ! first line contain two integers k p ( 1 ≤ k ≤ 105 1 ≤ p ≤ 109 ) output single integer — answer problem first example smallest zcy number 11 second smallest zcy number 22 . second example ,",['brute force'],1300.0
1088/A,give integer $$$ x $$$ find 2 integers $$$ a $$$ $$$ b $$$ : line contain integer $$$ x $$$ $$$ ( 1 \le x \le 100 ) $$$ output two integers $$$ a $$$ $$$ b $$$ satisfy give condition separate a space pair integers satisfy condition print ` ` -1 '' ( without quote ),['brute force'],800.0
831/C,polycarp watch tv - show k jury members one one rat a participant add a certain number point ( may negative i. e. point subtract ) initially participant score mark one one add score know i - th jury member give ai point polycarp remember many point participant k mark give remember among score announce k judge rat participant n ( n ≤ k ) value b1 b2 ... bn ( guarantee value bj distinct ) possible polycarp remember score announce i. e. n < k. note initial score n't announce task determine number options score participant could judge rat participant first line contain two integers k n ( 1 ≤ n ≤ k ≤ 2 000 ) — number jury members number score polycarp remember second line contain k integers a1 a2 ... ak ( - 2 000 ≤ ai ≤ 2 000 ) — jury 's mark chronological order third line contain n distinct integers b1 b2 ... bn ( - 4 000 000 ≤ bj ≤ 4 000 000 ) — value point polycarp remember note value necessarily give chronological order print number options score participant could judge rat participant polycarp mess something options print ` ` 0 '' ( without quote ) answer first example 3 initially participant could - 10 10 15 point second example one correct initial score equal 4 <unknown> 000,['brute force'],1700.0
1120/E,a positive integer $$$ a $$$ give baron <unknown> claim know a positive integer $$$ n $$$ one multiply $$$ n $$$ $$$ a $$$ sum digits decrease $$$ a $$$ time word $$$ s ( ) = s ( n ) /a $$$ $$$ s ( x ) $$$ denote sum digits number $$$ x $$$ find baron tell true line contain a single integer $$$ a $$$ ( $$$ 2 \le a \le 1000 $$$ ) number $$$ n $$$ print $$$ -1 $$$ otherwise print appropriate positive integer $$$ n $$$ number must consist $$$ 5\cdot100000 $$$ digits show give constraints either answer answer longer $$$ 5\cdot100000 $$$ digits,['brute force'],2600.0
1769/D2,в этой <unknown> задачи игроки <unknown> <unknown> не только на <unknown> но и на <unknown> <unknown> игры для них <unknown> <unknown> величины важности первого хода и нужно найти $$$ 13 $$$ раскладов с различными <unknown> этой величины алиса и боб решили <unknown> в <unknown> <unknown> « девятка » <unknown> <unknown> <unknown> условие задачи <unknown> <unknown> <unknown> <unknown> от <unknown> вам для игры <unknown> <unknown> колода из $$$ 36 $$$ карт — по <unknown> карт ( от <unknown> до туза ) каждой из <unknown> <unknown> ( трефы бубны пики и черви ) карты по <unknown> от <unknown> к <unknown> идут <unknown> образом : <unknown> <unknown> <unknown> девятка <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> колода <unknown> и <unknown> <unknown> <unknown> по $$$ 18 $$$ карт карты нужно <unknown> из руки на стол по <unknown> <unknown> <unknown> игрок который первым <unknown> все карты из своей руки игроки <unknown> по <unknown> ход <unknown> имеет один из <unknown> <unknown> : например девятку <unknown> можно выложить на стол в <unknown> <unknown> для выкладывания <unknown> треф необходимо наличие на столе <unknown> треф а для выкладывания туза червей необходимо наличие на столе короля червей если игрок не может выложить на стол <unknown> <unknown> карту из своей руки то ход <unknown> к <unknown> <unknown> <unknown> : <unknown> пропустить ход <unknown> так — <unknown> необходимо выложить карту на стол <unknown> образом если это <unknown> <unknown> того что каждый игрок <unknown> <unknown> от карт в своей руке алиса и боб также хотят чтобы в конце игры в руке у их <unknown> карт <unknown> как можно больше а в их руке — как можно <unknown> <unknown> что <unknown> <unknown> как только один из игроков <unknown> на стол <unknown> карту из своей руки <unknown> игры назовём <unknown> из <unknown> о том кто из двух игроков выиграет при <unknown> <unknown> а также о том <unknown> карт останется в руке у <unknown> <unknown> алиса и боб <unknown> <unknown> в руки <unknown> $$$ 18 $$$ карт каждый но <unknown> не решили кто из них будет ходить первым <unknown> важности первого хода для <unknown> <unknown> назовём <unknown> <unknown> <unknown> <unknown> игры в случае если первой будет ходить алиса и в случае если первым будет ходить боб например если в <unknown> <unknown> выиграет боб но в одном случае у алисы останется $$$ 6 $$$ карт в руке в конце игры а во втором — всего $$$ 2 $$$ то величина важности первого хода равна $$$ 4 $$$ если же в одном случае выиграет алиса и у боба останется $$$ 5 $$$ карт в руке а во втором случае выиграет боб и у алисы останется $$$ 3 $$$ карты в руке то величина важности первого хода равна $$$ 8 $$$ <unknown> хотят <unknown> насколько <unknown> <unknown> величина важности первого хода для <unknown> раскладов по <unknown> <unknown> $$$ k \le 13 $$$ <unknown> <unknown> найти <unknown> $$$ k $$$ раскладов что величины важности первого хода для всех них — <unknown> <unknown> числа в <unknown> строке <unknown> целое число $$$ k $$$ ( $$$ 2 \le k \le 13 $$$ ) — число <unknown> раскладов в <unknown> два <unknown> в первом тесте $$$ k = 2 $$$ во втором тесте $$$ k = 13 $$$ выведите $$$ k $$$ <unknown> строк каждая <unknown> строк должна <unknown> <unknown> <unknown> величины важности первого хода для всех <unknown> раскладов <unknown> <unknown> различными <unknown> <unknown> в первой строке каждой <unknown> выведите $$$ 18 $$$ строк длины $$$ 2 $$$ через пробел описывающих карты алисы в <unknown> порядке первый символ строки должен обозначать <unknown> карты — символ из набора 6 7 8 9 t j q k a обозначающий <unknown> <unknown> <unknown> девятку <unknown> <unknown> <unknown> короля и туза соответственно второй символ строки должен обозначать <unknown> карты — символ из набора c d s h обозначающий трефы бубны пики и черви соответственно во второй строке выведите $$$ 18 $$$ строк длины $$$ 2 $$$ через пробел описывающих карты боба в том же <unknown> каждая из $$$ 36 $$$ возможных карт должна <unknown> в руке одного из двух игроков в <unknown> <unknown> в первом выведенном раскладе все <unknown> <unknown> в руке у алисы <unknown> если боб будет ходить первым <unknown> <unknown> <unknown> <unknown> пропустить первый же <unknown> ход <unknown> первый ход при таком раскладе имеет <unknown> $$$ 0 $$$ во втором выведенном раскладе <unknown> <unknown> от того <unknown> будет первый ход выиграет алиса <unknown> если алиса будет ходить первой то у боба в конце игры в руке останется <unknown> <unknown> а если же <unknown> будет ходить второй то у боба останется <unknown> карт соответственно величина важности первого хода при таком раскладе равна $$$ 4 $$$,['brute force'],2200.0
1761/A,"give three integers $$$ n $$$ $$$ a $$$ $$$ b $$$ determine exist two permutations $$$ p $$$ $$$ q $$$ length $$$ n $$$ follow condition hold : a permutation length $$$ n $$$ array contain integer $$$ 1 $$$ $$$ n $$$ exactly example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\leq <unknown> 10000 $$$ ) — number test case description test case follow line test case contain three integers $$$ n $$$ $$$ a $$$ $$$ b $$$ ( $$$ 1\leq a b\leq n\leq 100 $$$ ) test case a pair permutations exist output ` ` yes '' ; otherwise output ` ` '' output letter case ( upper lower ) first test case $$$ [ 1 ] $$$ $$$ [ 1 ] $$$ form a valid pair second test case third case show a pair permutations n't exist fourth test case $$$ [ 1,2,3,4 ] $$$ $$$ [ 1,3,2,4 ] $$$ form a valid pair",['brute force'],800.0
1700/E,little <unknown> serega <unknown> a ship puzzle different kinds among kinds like one hardest a puzzle a table $$$ n $$$ row $$$ m $$$ columns whose cells contain number $$$ 1 $$$ $$$ n \cdot m $$$ exactly solve a puzzle find a sequence cells table two consecutive cells adjacent side table sequence arbitrary length visit cell one time a cell contain number $$$ i $$$ denote position first occurrence cell sequence $$$ t_i $$$ sequence solve puzzle $$$ t_1 < t_2 < \dots < t _ { nm } $$$ word cell number $$$ x $$$ first visit cell number $$$ x + 1 $$$ $$$ x $$$ let 's call a puzzle solvable exist least one suitable sequence one move serega choose two arbitrary cells table ( necessarily adjacent side ) swap number would like know minimum number move make puzzle solvable impatient thus please tell minimum number move $$$ 0 $$$ $$$ 1 $$$ least $$$ 2 $$$ case $$$ 1 $$$ move require please also find number suitable cell pair swap first line two whole positive number $$$ n m $$$ ( $$$ 1 \leq <unknown> m \leq <unknown> $$$ ) — table dimension next $$$ n $$$ line $$$ m $$$ integer number $$$ a _ { i1 } a _ { i2 } \dots a _ { i m } $$$ ( $$$ 1 \le a _ { ij } \le nm $$$ ) guarantee every number $$$ 1 $$$ $$$ nm $$$ occur exactly table let $$$ a $$$ minimum number move make puzzle solvable $$$ a = 0 $$$ print $$$ 0 $$$ $$$ a = 1 $$$ print $$$ 1 $$$ number valid swap $$$ a \ge 2 $$$ print $$$ 2 $$$ first example sequence $$$ ( 1 2 ) ( 1 1 ) ( 1 2 ) ( 1 3 ) ( 2 3 ) ( 3 3 ) $$$ $$$ ( 2 3 ) ( 1 3 ) ( 1 2 ) ( 1 1 ) ( 2 1 ) ( 2 2 ) ( 3 2 ) ( 3 1 ) $$$ solve puzzle answer $$$ 0 $$$ puzzle second example ca n't solve 's solvable three swap cells value $$$ ( 1 5 ) ( 1 6 ) ( 2 6 ) $$$ puzzle third example require least two swap answer $$$ 2 $$$,['brute force'],2600.0
1676/H1,"difference two versions version $$$ n \leq 1000 $$$ sum $$$ n $$$ test case exceed $$$ 1000 $$$ a terminal a row $$$ n $$$ equal segment number $$$ 1 $$$ $$$ n $$$ order two terminals one give array $$$ a $$$ length $$$ n $$$ $$$ i = 1 2 \dots n $$$ a straight wire point segment $$$ i $$$ top terminal point segment $$$ a_i $$$ bottom terminal ca n't select endpoints a segment example follow picture show two possible wire $$$ n=7 $$$ $$$ a= [ 4,1,4,6,7,7,5 ] $$$ a cross occur two wire share a point common picture cross circle red maximum number cross place wire optimally ? first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — elements array sum $$$ n $$$ across test case exceed $$$ 1000 $$$ test case output a single integer — maximum number cross place wire optimally first test case show second picture statement second test case wire possible two wire cross answer $$$ 1 $$$ third test case wire possible one wire answer $$$ 0 $$$",['brute force'],1400.0
1633/A,give integer $$$ n $$$ change minimum number digits a way result number lead zero divisible $$$ 7 $$$ multiple ways print give number already divisible $$$ 7 $$$ leave unchanged first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le <unknown> $$$ ) — number test case test case follow test case consist one line contain one integer $$$ n $$$ ( $$$ 10 \le n \le 999 $$$ ) test case print one integer without lead zero — result change ( i. e. integer divisible $$$ 7 $$$ obtain change minimum possible number digits $$$ n $$$ ) multiple ways apply change print result number give number already divisible $$$ 7 $$$ print first test case example $$$ 42 $$$ already divisible $$$ 7 $$$ 's need change second test case example multiple answer — $$$ <unknown> $$$ $$$ 21 $$$ $$$ 63 $$$ third test case example possible answer $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ note print $$$ <unknown> $$$ $$$ <unknown> $$$,['brute force'],800.0
1612/A,let 's denote manhattan distance two point $$$ p_1 $$$ ( coordinate $$$ ( x_1 y_1 ) $$$ ) $$$ p_2 $$$ ( coordinate $$$ ( x_2 y_2 ) $$$ ) $$$ d ( p_1 p_2 ) = <unknown> - <unknown> + <unknown> - <unknown> $$$ example distance two point coordinate $$$ ( 1 3 ) $$$ $$$ ( 4 2 ) $$$ $$$ |1 - 4| + |3 - 2| = 4 $$$ give two point $$$ a $$$ $$$ b $$$ point $$$ a $$$ coordinate $$$ ( 0 0 ) $$$ point $$$ b $$$ coordinate $$$ ( x y ) $$$ goal find a point $$$ c $$$ : find point $$$ c $$$ meet constraints report point exist first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 3000 $$$ ) — number test case test case consist one line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 0 \le x y \le 50 $$$ ) — coordinate point $$$ b $$$ test case print answer a separate line follow : explanations test case example :,['brute force'],800.0
1382/A,"give two array integers $$$ a_1 \ldots a_n $$$ $$$ b_1 \ldots b_m $$$ task find a non - empty array $$$ c_1 \ldots c_k $$$ a subsequence $$$ a_1 \ldots a_n $$$ also a subsequence $$$ b_1 \ldots b_m $$$ multiple answer find one smallest possible length still multiple smallest possible length find array report a sequence $$$ a $$$ a subsequence a sequence $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) elements example $$$ [ 3,1 ] $$$ a subsequence $$$ [ 3,2,1 ] $$$ $$$ [ <unknown> ] $$$ a subsequence $$$ [ <unknown> ] $$$ $$$ [ <unknown> ] $$$ first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 1000 $$$ ) — number test case next $$$ 3 t $$$ line contain descriptions test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1\le n m\le 1000 $$$ ) — lengths two array second line test case contain $$$ n $$$ integers $$$ a_1 \ldots a_n $$$ ( $$$ 1\le a_i\le 1000 $$$ ) — elements first array third line test case contain $$$ m $$$ integers $$$ b_1 \ldots b_m $$$ ( $$$ 1\le <unknown> 1000 $$$ ) — elements second array guarantee sum $$$ n $$$ sum $$$ m $$$ across test case exceed $$$ 1000 $$$ ( $$$ \sum\limits _ { i=1 } ^t n_i \sum\limits _ { i=1 } ^t <unknown> 1000 $$$ ) test case output ` ` yes '' a solution exist ` ` '' otherwise answer ` ` yes '' next line output integer $$$ k $$$ ( $$$ 1\le <unknown> 1000 $$$ ) — length array follow $$$ k $$$ integers $$$ c_1 \ldots c_k $$$ ( $$$ 1\le <unknown> 1000 $$$ ) — elements array multiple solutions smallest possible $$$ k $$$ output first test case $$$ [ 4 ] $$$ a subsequence $$$ [ 10 8 6 4 ] $$$ $$$ [ 1 2 3 4 5 ] $$$ array length $$$ 1 $$$ smallest possible length a subsequence $$$ a $$$ $$$ b $$$ third test case non - empty subsequences $$$ [ 3 ] $$$ $$$ [ 2 ] $$$ exist answer ` ` ''",['brute force'],800.0
1365/E,<unknown> challenge ashish find maximum value subsequence array $$$ a $$$ size $$$ n $$$ consist positive integers value a non - empty subsequence $$$ k $$$ elements $$$ a $$$ define $$$ \sum 2^i $$$ integers $$$ i \ge 0 $$$ least $$$ \max ( 1 k - 2 ) $$$ elements subsequence $$$ i $$$ -th bite set binary representation ( value $$$ x $$$ $$$ i $$$ -th bite set binary representation $$$ \lfloor \frac { x } { 2^i } \rfloor \mod 2 $$$ equal $$$ 1 $$$ ) recall $$$ b $$$ a subsequence $$$ a $$$ $$$ b $$$ obtain delete ( possibly zero ) elements $$$ a $$$ help ashish find maximum value get choose subsequence $$$ a $$$ first line input consist a single integer $$$ n $$$ $$$ ( 1 \le n \le 500 ) $$$ — size $$$ a $$$ next line consist $$$ n $$$ space - separated integers — elements array $$$ ( 1 \le a_i \le 10^ { 18 } ) $$$ print a single integer — maximum value ashish get choose subsequence $$$ a $$$ first test case ashish pick subsequence $$$ \ { { 2 3 } \ } $$$ size $$$ 2 $$$ binary representation $$$ 2 $$$ 10 $$$ 3 $$$ 11 . since $$$ \max ( k - 2 1 ) $$$ equal $$$ 1 $$$ value subsequence $$$ 2 ^ 0 + 2 ^ 1 $$$ ( $$$ 2 $$$ $$$ 3 $$$ $$$ 1 $$$ -st bite set binary representation $$$ 3 $$$ $$$ 0 $$$ -th bite set binary representation ) note could also pick subsequence $$$ \ { { 3\ } } $$$ $$$ \ { { 2 1 3\ } } $$$ second test case ashish pick subsequence $$$ \ { { 3 4\ } } $$$ value $$$ 7 $$$ third test case ashish pick subsequence $$$ \ { { 1\ } } $$$ value $$$ 1 $$$ fourth test case ashish pick subsequence $$$ \ { { 7 <unknown> } } $$$ value $$$ 7 $$$,['brute force'],1900.0
1779/H,"iron werewolf participate a chess olympiad want practice team build gather $$$ n $$$ players $$$ n $$$ a power $$$ 2 $$$ play sport iron werewolf among $$$ n $$$ people one sport tug war $$$ 1\leq i \leq n $$$ $$$ i $$$ -th player strength $$$ s_i $$$ elimination round hold one player remain — call player absolute winner round : iron already know player 's strength wonder become absolute winner ca n't may choose team form round well win team case equal strengths first line contain a single integer $$$ n $$$ ( $$$ 4 \leq n \leq 32 $$$ ) — number players participate tug war guarantee $$$ n $$$ a power $$$ 2 $$$ second line consist a sequence $$$ s_1 s_2 \ldots s_n $$$ integers ( $$$ 1 \leq s_i \leq 10^ { 15 } $$$ ) — strengths players a single line output a binary string $$$ s $$$ length $$$ n $$$ — $$$ i $$$ -th character $$$ s $$$ $$$ 1 $$$ $$$ i $$$ -th player become absolute winner $$$ 0 $$$ otherwise first example players $$$ 1 $$$ $$$ 4 $$$ respective strengths $$$ 60 $$$ $$$ 87 $$$ become absolute winners let 's describe process player $$$ 1 $$$ firstly divide players team $$$ [ 1,3 ] $$$ $$$ [ 2,4 ] $$$ strengths two team $$$ 60 + <unknown> $$$ $$$ 32 + <unknown> $$$ equal iron choose <unknown> two team let choice second team leave players $$$ 1 $$$ $$$ 3 $$$ since $$$ 1 $$$ greater strength ( $$$ 60 > 59 $$$ ) win declare absolute winner last remain player third example strengths remain players may look like $$$ [ <unknown> ] \rightarrow [ <unknown> ] \rightarrow [ <unknown> ] \rightarrow [ 8 ] $$$ person strength $$$ 8 $$$ become absolute winner prove others ca n't",['brute force'],3500.0
1333/E,egor want achieve a rat <unknown> point well - known chess portal <unknown> need help ! start solve problem egor want remind chess piece move chess rook move along straight line leave right many square want want stop queen walk directions vertically diagonally distance see examples reach goal egor research next topic : $$$ n \times n $$$ board cell board a number $$$ 1 $$$ $$$ n ^ 2 $$$ number cells distinct begin chess figure stand cell number $$$ 1 $$$ note cell already consider visit every move determine follow rule : egor find $$$ n \times n $$$ board rook pay strictly less vuns queen round number help find $$$ n \times n $$$ number board tell n't exist line contain one integer $$$ n $$$ — size board $$$ 1\le n \le 500 $$$ output contain $$$ n $$$ line $$$ i $$$ -th line output $$$ n $$$ number — number $$$ i $$$ -th row board number $$$ 1 $$$ $$$ n \times n $$$ must use exactly board rook must pay strictly less vuns queen solutions print $$$ -1 $$$ several solutions output case $$$ 1 \times 1 $$$ board rook queen a chance pay fee second sample rook go cells $$$ 1 \to 3 \to 4 \to 6 \to 9 \to 5 \to 7 \to 13 \to 2 \to 8 \to 16 \to 11 \to 10 \to 12 \to 15 \to \textbf { ( 1 vun ) } \to 14 $$$ queen go $$$ 1 \to 3 \to 4 \to 2 \to 5 \to 6 \to 9 \to 7 \to 13 \to 8 \to 11 \to 10 \to 12 \to 15 \to \textbf { ( 1 vun ) } \to 14 \to \textbf { ( 1 vun ) } \to 16 $$$ a result rook pay 1 vun queen pay 2 vuns,['brute force'],2400.0
1311/C,want perform combo opponent one popular fight game combo string $$$ s $$$ consist $$$ n $$$ lowercase latin letter perform combo press button order appear $$$ s $$$ i.e $$$ s= $$$ ` ` abca '' press ' a ' ' b ' ' c ' ' a ' know spend $$$ m $$$ wrong try perform combo $$$ i $$$ -th try make a mistake right $$$ p_i $$$ -th button ( $$$ 1 \le p_i < n $$$ ) ( i.e press first $$$ p_i $$$ button right start perform combo begin ) guarantee $$$ m+1 $$$ -th try press button right finally perform combo i.e $$$ s= $$$ ` ` abca '' $$$ <unknown> $$$ $$$ p = [ 1 3 ] $$$ sequence press button ' a ' ( 're make a mistake start perform combo begin ) ' a ' ' b ' ' c ' ( 're make a mistake start perform combo begin ) ' a ' ( note point perform combo mistake ) ' b ' ' c ' ' a ' task calculate button ( letter ) number time 'll press answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 1 \le m \le 200000 $$$ ) — length $$$ s $$$ number try correspondingly second line test case contain string $$$ s $$$ consist $$$ n $$$ lowercase latin letter third line test case contain $$$ m $$$ integers $$$ p_1 p_2 \dots p_m $$$ ( $$$ 1 \le p_i < n $$$ ) — number character press right $$$ i $$$ -th try guarantee sum $$$ n $$$ sum $$$ m $$$ exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ $$$ \sum m \le 200000 $$$ ) guarantee answer letter exceed $$$ 2000000000 $$$ test case print answer — $$$ 26 $$$ integers : number time press button ' a ' number time press button ' b ' $$$ \dots $$$ number time press button ' z ' first test case describe problem statement wrong try ` ` a '' ` ` abc '' final try ` ` abca '' number time press ' a ' $$$ 4 $$$ ' b ' $$$ 2 $$$ ' c ' $$$ 2 $$$ second test case five wrong try : ` ` co '' ` ` <unknown> '' ` ` cod '' ` ` co '' ` ` <unknown> '' final try ` ` codeforces '' number time press ' c ' $$$ 9 $$$ 'd ' $$$ 4 $$$ ' e ' $$$ 5 $$$ ' f ' $$$ 3 $$$ ' o ' $$$ 9 $$$ ' r ' $$$ 3 $$$ 's ' $$$ 1 $$$,['brute force'],1300.0
666/E,country <unknown> <unknown> berland recently authorities berland <unknown> a <unknown> spy try bring leaflets intend <unknown> <unknown> berland <unknown> leaflets contain substrings absolutely inadmissible swearword maybe even whole word berland <unknown> system use difficult algorithm order determine <unknown> spy main part algorithm follow procedure m leaflets bring spy number 1 m. 's need get answer q query follow kind : ` ` leaflet segment number [ l r ] substring absolutely inadmissible swearword [ pl pr ] occur often ? ` ` expert want <unknown> procedure time texts leaflets long help ! first line contain string s ( 1 ≤ |s| ≤ 5·105 ) — absolutely inadmissible swearword string s consist lowercase english letter second line contain integer m ( 1 ≤ m ≤ 5·104 ) — number texts leaflets expertise next m line contain string ti — text i - th leaflet sum lengths leaflet texts n't exceed 5·104 text leaflets consist lowercase english letter next line contain integer q ( 1 ≤ q ≤ 5·105 ) — number query expertise finally last q line contain four integers l r pl pr ( 1 ≤ l ≤ r ≤ m 1 ≤ pl ≤ pr ≤ |s| ) |s| length absolutely inadmissible swearword print q line i - th contain two integers — number text occurences number occurences substring [ pl pr ] string s. several text number print smallest one,['data structures'],3100.0
741/E,us know girls arpa ’ s land ... ok ’ get idea : <unknown> know arpa n't a normal man ... well <unknown> i ca n't explain mehrdad interest reason ask sipa one best biology scientists arpa 's land help sipa a dna editor sipa put arpa dna editor dna editor show arpa 's dna a string s consist n lowercase english letter also sipa another dna t consist lowercase english letter belong a normal man ( n + 1 ) options change arpa 's dna number 0 n. i - th put t i - th ( i + 1 ) -th character s ( 0 ≤ i ≤ n ) i = 0 t put s i = n put s. mehrdad want choose interest option arpa 's dna among n + 1 options dna a interest b a lexicographically smaller b. mehrdad ask sipa q question : give integers l r k x y interest option consider options i l ≤ i ≤ r ? several interest options mehrdad want know one smallest number i. since sipa a biology scientist a programmer help first line contain string s t integer q ( 1 ≤ |s| |t| q ≤ 105 ) — arpa 's dna dna a normal man number mehrdad 's question string s t consist small english letter next q line describe mehrdad 's question line contain five integers l r k x y ( 0 ≤ l ≤ r ≤ n 1 ≤ k ≤ n 0 ≤ x ≤ y < k ) print q integers j - th number i interest option among satisfy condition j - th question option i satisfy condition question print -1 . explanation first sample case : first question sipa two options : <unknown> ( i = 0 ) abdc ( i = 2 ) latter ( abcd ) better abdc answer 2 . last question i 0 ≤ i ≤ 1,['data structures'],3400.0
1037/H,program website establish a secure communication protocol security reason want choose several less random string initially a string $$$ s $$$ consist lowercase english letter want choose $$$ q $$$ string use follow step help string $$$ a $$$ lexicographically less string $$$ b $$$ either $$$ a $$$ a prefix $$$ b $$$ $$$ a \ne b $$$ exist a position $$$ i $$$ ( $$$ 1 \le i \le min ( |a| |b| ) $$$ ) $$$ a_i < b_i $$$ $$$ j $$$ ( $$$ 1 \le j < i $$$ ) $$$ a_j = b_j $$$ $$$ |a| $$$ denote length string $$$ a $$$ first line input contain a non - empty string $$$ s $$$ ( $$$ 1 \leq |s| \leq 10^ { 5 } $$$ ) consist lowercase english letter second line contain integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number string select next $$$ q $$$ line contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l \leq r \leq |s| $$$ ) a non - empty string $$$ x $$$ consist lowercase english letter total length string $$$ x $$$ query exceed $$$ 2 \cdot 10^ { 5 } $$$ output $$$ q $$$ line contain desire string $$$ -1 $$$ string consider first example string $$$ s $$$ ` ` baa '' query follow,['data structures'],3200.0
1621/I,consider array integers $$$ c = [ c_1 c_2 \ldots c_n ] $$$ length $$$ n $$$ let 's build sequence array $$$ <unknown> d_1 d_2 \ldots d _ { n } $$$ length $$$ n+1 $$$ follow way : array $$$ x $$$ subarray array $$$ y $$$ $$$ x $$$ obtain deletion several ( possibly zero ) elements begin $$$ y $$$ several ( possibly zero ) elements end $$$ y $$$ array $$$ c $$$ let 's denote array $$$ d_n $$$ $$$ op ( c ) $$$ alice array integers $$$ a = [ a_1 a_2 \ldots a_n ] $$$ length $$$ n $$$ build sequence array $$$ b_0 b_1 \ldots b_n $$$ length $$$ n+1 $$$ follow way : ask $$$ q $$$ query elements sequence array $$$ b_0 b_1 \ldots b_n $$$ query consist two integers $$$ i $$$ $$$ j $$$ answer query value $$$ j $$$ -th element array $$$ b_i $$$ first line contain single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — array $$$ a $$$ third line contain single integer $$$ q $$$ ( $$$ 1 \leq q \leq 1000000 $$$ ) — number query next $$$ q $$$ line contain two integers $$$ i $$$ $$$ j $$$ ( $$$ 1 \leq i j \leq n $$$ ) — parameters query output $$$ q $$$ integers : value $$$ b _ { i j } $$$ require $$$ i $$$ $$$ j $$$ first test case $$$ b_0 = a = [ 2 1 3 1 ] $$$ $$$ b_1 $$$ construct follow way :,['data structures'],3500.0
1073/G,let $$$ \text { lcp } ( s t ) $$$ length longest common prefix string $$$ s $$$ $$$ t $$$ also let $$$ s [ x \dots y ] $$$ substring $$$ s $$$ index $$$ x $$$ index $$$ y $$$ ( inclusive ) example $$$ s = $$$ ` ` abcde '' $$$ s [ 1 \dots 3 ] = $$$ ` ` abc '' $$$ s [ 2 \dots 5 ] = $$$ ` ` <unknown> '' give a string $$$ s $$$ length $$$ n $$$ $$$ q $$$ query query a pair integer set $$$ a_1 a_2 \dots a_k $$$ $$$ b_1 b_2 \dots <unknown> $$$ calculate $$$ \sum\limits _ { i = 1 } ^ { i = k } \sum\limits _ { j = 1 } ^ { j = l } { \text { lcp } ( s [ a_i \dots n ] s [ b_j \dots n ] ) } $$$ query first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n q \le 200000 $$$ ) — length string $$$ s $$$ number query respectively second line contain a string $$$ s $$$ consist lowercase latin letter ( $$$ |s| = n $$$ ) next $$$ <unknown> $$$ line contain descriptions query — three line per query first line query contain two integers $$$ k_i $$$ $$$ l_i $$$ ( $$$ 1 \le k_i l_i \le n $$$ ) — size set $$$ a $$$ $$$ b $$$ respectively second line query contain $$$ k_i $$$ integers $$$ a_1 a_2 \dots a _ { k_i } $$$ ( $$$ 1 \le a_1 < a_2 < \dots < a _ { k_i } \le n $$$ ) — set $$$ a $$$ third line query contain $$$ l_i $$$ integers $$$ b_1 b_2 \dots b _ { l_i } $$$ ( $$$ 1 \le b_1 < b_2 < \dots < b _ { l_i } \le n $$$ ) — set $$$ b $$$ guarantee $$$ \sum\limits _ { i = 1 } ^ { i = q } { k_i } \le 200000 $$$ $$$ \sum\limits _ { i = 1 } ^ { i = q } { l_i } \le 200000 $$$ print $$$ q $$$ integers — answer query order query give input description query :,['data structures'],2600.0
19/C,bob saw a string contain many different letter letter mark number time letter could meet string 10 time bob n't like string contain repeat : a repeat length x a substring length <unknown> first half coincide character character second half bob start delete repeat string follow : 's possible bob take shortest repeat unique take leftmost one delete leave half everything leave repeat 're give string see bob find look like bob delete repeat way describe first input line contain integer n ( 1 ≤ n ≤ 105 ) — length string follow line contain n space - separated integer number 0 109 inclusive — number stand letter string 's guarantee letter meet string 10 time first line output length string 's part leave bob 's <unknown> second line output letter ( separate a space ) string leave bob delete repeat describe way,['greedy'],2200.0
39/A,"c * + + language quite similar c++ <unknown> <unknown> fact program write c * + + sometimes behave <unknown> lead absolutely <unknown> effect example let 's imagine arithmetic expression c * + + look like ( expression main term ) : example ` ` 5 * <unknown> * + + <unknown> '' a valid expression c * + + thus a sum consist several summands divide sign ` ` + '' ` ` - '' every summand expression ` ` a++ '' ` ` + + a '' multiply integer coefficient coefficient omit suggest equal 1 . calculation sum c * + + go follow way first summands calculate one another sum usual arithmetic rule summand contain ` ` a++ '' calculation first value ` ` a '' variable multiply coefficient value ` ` a '' increase 1 . summand contain ` ` + + a '' action perform reverse order : first ` ` a '' increase 1 — multiply coefficient summands may calculate order 's sometimes result calculation completely <unknown> ! task find largest possible value first input line contain integer a ( - 1000 ≤ a ≤ 1000 ) — initial value variable ` ` a '' next line contain expression c * + + language describe type number summands expression exceed 1000 . guarantee line describe expression contain space <unknown> output a single number — maximal possible value expression consider second example initially a = 3 . suppose first first summand calculate second one first summand get equal 3 value a increase 1 . calculation second summand a increase ( get equal 5 ) value second summand 5 together give 8 . calculate second summand first first summand later summands equal 4 result 8 ,",['greedy'],2000.0
1728/F,$$$ n $$$ fishermen return a fish trip $$$ i $$$ -th fisherman catch a fish size $$$ a_i $$$ fishermen choose order go tell size fish catch ( order a permutation size $$$ n $$$ ) however entirely <unknown> may ` ` increase '' size fish catch formally suppose choose order fishermen $$$ [ p_1 p_2 p_3 \dots p_n ] $$$ let $$$ b_i $$$ value $$$ i $$$ -th fisherman order tell fishermen value $$$ b_i $$$ choose follow : example let $$$ n = 7 $$$ $$$ a = [ 1 8 2 3 2 2 3 ] $$$ choose order $$$ p = [ 1 6 7 5 3 2 4 ] $$$ : choose order fishermen a way yield minimum possible $$$ \sum\limits _ { i=1 } ^ { n } b_i $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — number fishermen second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) print one integer — minimum possible value $$$ \sum\limits _ { i=1 } ^ { n } b_i $$$ obtain choose order fishermen optimally,['greedy'],3100.0
725/F,"alice bonnie <unknown> n't like much old family photos find <unknown> start argue receive photos end decide would take turn pick photos alice go first n stack photos stack contain exactly two photos turn a player may take a photo top one stack photo describe two non - negative integers a b indicate worth a units happiness alice b units happiness bonnie value a b might differ different photos 's allow pass instead take a photo game end photos take players pass consecutively players n't act maximize happiness instead player act maximize amount happiness exceed <unknown> 's assume players play optimal find difference alice 's bonnie 's happiness , 's a perfectly - <unknown> game alice x happiness bonnie y happiness end print x - y. first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number two - photo stack follow n line describe one stack a stack describe four space - separated non - negative integers a1 b1 a2 b2 exceed 109 . a1 b1 describe top photo stack a2 b2 describe bottom photo stack output a single integer : difference alice 's bonnie 's happiness play optimally",['greedy'],2900.0
616/B,jack decide invite emma a dinner jack a <unknown> student n't want go expensive restaurant emma a girl high taste prefer <unknown> place munhattan consist n streets m avenues exactly one restaurant intersection street avenue streets number integers 1 n avenues number integers 1 m. cost dinner restaurant intersection i - th street j - th avenue cij jack emma decide choose restaurant follow way firstly emma choose street dinner jack choose avenue emma jack make choice optimally : emma want maximize cost dinner jack want minimize emma take account jack want minimize cost dinner find cost dinner couple love first line contain two integers n m ( 1 ≤ n m ≤ 100 ) — number streets avenues munhattan next n line contain m integers cij ( 1 ≤ cij ≤ 109 ) — cost dinner restaurant intersection i - th street j - th avenue print integer a — cost dinner jack emma first example emma choose first third streets jack choose avenue cost dinner 1 . choose second street jack choose avenue cost dinner 2 . second example regardless emma 's choice jack choose a restaurant cost dinner 1,['greedy'],1000.0
293/A,"yaroslav andrey roman play cub hours hours game three roman n't show yaroslav andrey play another game roman leave a word word consist 2·n binary character ` ` 0 '' ` ` 1 '' players start move turn yaroslav move first a move a player must choose integer 1 2·n n't choose anybody moment player take a piece paper write correspond character string let 's represent yaroslav 's word s = s1s2 ... <unknown> similarly let 's represent andrey 's word t = t1t2 ... <unknown> , yaroslav choose number k move go write character sk piece paper similarly andrey choose number r move go write character <unknown> piece paper game finish player make a move game yaroslav make integer character write piece paper ( yaroslav arrange character want ) andrey result number contain lead zero person largest number win number equal game end a draw give two string s t. determine outcome game provide yaroslav andrey play optimally well first line contain integer n ( 1 ≤ n ≤ 106 ) second line contain string s — yaroslav 's word third line contain string t — andrey 's word guarantee word consist 2·n character ` ` 0 '' ` ` 1 '' print ` ` first '' players play optimally well yaroslav win andrey win print ` ` second '' game end a draw print ` ` draw '' print word without quote",['greedy'],1500.0
276/B,little girl love problems game much 's one two players get a string s consist lowercase english letter play a game describe follow rule : determine player win provide side play optimally well — one move first one move second input contain a single line contain string s ( 1 ≤ |s| ≤ 103 ) string s consist lowercase english letter a single line print word ` ` first '' first player win ( provide players play optimally well ) otherwise print word ` ` second '' print word without quote,['greedy'],1300.0
819/A,sometimes mister b free even n't know fortunately mister b find a new game player play alien character game lowercase english letter two players : mister b <unknown> initially players a string s consist first a english letter alphabetical order ( example a = 5 s equal ` ` abcde '' ) players take turn append letter string s. mister b move first mister b must append exactly b letter move arbitrary choose letter opponent add exactly a letter move mister b quickly understand opponent a computer use a simple algorithm computer turn consider suffix string s length a generate a string t length a letter string t distinct n't appear consider suffix multiple variants t lexicographically minimal choose ( a = 4 suffix ` ` <unknown> '' computer choose string t equal ` ` <unknown> '' ) choose string t append end s. mister b soon find game bore come follow question : minimum possible number different letter string s segment position l r inclusive letter string s numerate start 1 . first line contain four space - separated integers : a b l r ( 1 ≤ a b ≤ 12 1 ≤ l ≤ r ≤ 109 ) — number letter player append bound segment print one integer — minimum possible number different letter segment position l position r inclusive string s. first sample test one optimal strategies generate string s = ` ` <unknown> ... '' 's answer 2 . second sample test string s = ` ` <unknown> ... '' obtain choose segment look like ` ` <unknown> '' 's answer 3 . third sample test string s = ` ` <unknown> ... '' obtain choose segment look like ` ` <unknown> '' 's answer 1,['greedy'],2200.0
1495/B,"a weekend qingshan suggest friend daniel go hike unfortunately busy high school students go hike <unknown> paper a permutation $$$ p $$$ write leave right paper first qingshan choose integer index $$$ x $$$ ( $$$ 1\le x\le n $$$ ) tell daniel , daniel choose another integer index $$$ y $$$ ( $$$ 1\le y\le n $$$ $$$ y \ne x $$$ ) game progress turn turn usual qingshan move first rule follow : person ca n't make move lose win , qingshan 's fan ask calculate number possible $$$ x $$$ make qingshan win case players play optimally first line contain a single integer $$$ n $$$ ( $$$ 2\le n\le 100000 $$$ ) — length permutation second line contain $$$ n $$$ distinct integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1\le p_i\le n $$$ ) — permutation print number possible value $$$ x $$$ qingshan choose make win first test case qingshan choose $$$ <unknown> $$$ win answer $$$ 1 $$$ second test case qingshan choose $$$ <unknown> $$$ daniel choose $$$ <unknown> $$$ first turn ( qingshan 's ) qingshan choose $$$ <unknown> $$$ change $$$ x $$$ $$$ 3 $$$ second turn ( daniel 's ) daniel choose $$$ <unknown> $$$ change $$$ y $$$ $$$ 2 $$$ qingshan ca n't choose $$$ <unknown> $$$ $$$ <unknown> $$$ time qingshan lose",['greedy'],1900.0
1425/A,<unknown> mr . chanek frequently play game arena <unknown> name imply game 's goal find <unknown> crown king <unknown> game play two people take turn mr . chanek take first turn initially a treasure chest contain $$$ n $$$ gold coin game end gold coin chest turn players make one follow move : players try maximize number coin mr . chanek ask help find maximum number coin get end game opponent play optimally first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 100000 ) $$$ denote number test case next $$$ t $$$ line contain a single integer $$$ n $$$ $$$ ( 1 \le n \le 10^ { 18 } ) $$$ $$$ t $$$ line line answer request mr . chanek first case game follow : second case game follow :,['greedy'],1400.0
135/C,little petya much like play little masha recently receive a game call ` ` zero - one '' a gift mother petya immediately offer masha play game begin game several card lie a table one line leave right card contain a digit : 0 1 . players move turn masha move first move a player remove a card table shift card close gap leave remove card example somebody 's move card table form a sequence <unknown> fourth card remove ( card number start 1 ) sequence look like : <unknown> . game end exactly two card leave table digits card determine number binary notation : significant bite locate leave masha 's aim minimize number petya 's aim maximize unpleasant <unknown> occur game start kid spill juice card digits card get <unknown> one spoil card could either 0 1 write consider possible variants initial arrangement digits ( juice spill ) variant let 's find two card leave end game assume petya masha play optimally order pair digits write two card call outcome task find set outcomes variants initial digits arrangement first line contain a sequence character either a ` ` 0 '' a ` ` 1 '' a ` ` ? ` ` sequence determine initial arrangement card table leave right character ` ` ? '' mean give card spoil game sequence 's length range 2 105 inclusive print set outcomes possible initial digits arrangements print possible outcome a single line outcome represent two character : digits write card leave end game outcomes sort lexicographically ascend order ( see first sample ) first sample 16 variants number arrangement possible variant 0000 outcome 00 . variant 1111 outcome 11 . variant 0011 outcome 01 . variant 1100 outcome 10 . regardless outcomes variants set look contain 4 possible outcomes third sample 2 variants number arrangement possible : 111 101 . variant 111 outcome 11 . variant 101 outcome 01 first turn masha remove first card leave game end,['greedy'],1900.0
1592/F2,difference versions cost operations solution one version wo n't work another ! alice a grid size $$$ n \times m $$$ initially cells color white cell intersection $$$ i $$$ -th row $$$ j $$$ -th column denote $$$ ( i j ) $$$ alice follow operations grid : choose subrectangle contain cell $$$ ( 1 1 ) $$$ flip color cells ( flip mean change color white black black white ) operation cost $$$ 1 $$$ coin choose subrectangle contain cell $$$ ( n 1 ) $$$ flip color cells operation cost $$$ 3 $$$ coin choose subrectangle contain cell $$$ ( 1 m ) $$$ flip color cells operation cost $$$ 4 $$$ coin choose subrectangle contain cell $$$ ( n m ) $$$ flip color cells operation cost $$$ 2 $$$ coin a reminder subrectangle a set cells $$$ ( x y ) $$$ $$$ x_1 \le x \le x_2 $$$ $$$ y_1 \le y \le y_2 $$$ $$$ 1 \le x_1 \le x_2 \le n $$$ $$$ 1 \le y_1 \le y_2 \le m $$$ alice want obtain favorite color operations 's smallest number coin would spend ? show 's always possible transform initial grid first line input contain $$$ 2 $$$ integers $$$ n m $$$ ( $$$ 1 \le n m \le 500 $$$ ) — dimension grid $$$ i $$$ -th next $$$ n $$$ line contain a string $$$ s_i $$$ length $$$ m $$$ consist letter w b. $$$ j $$$ -th character string $$$ s_i $$$ w cell $$$ ( i j ) $$$ color white favorite color alice b 's color black output smallest number coin alice would spend achieve favorite color first sample 's optimal apply fourth operation rectangle contain cells $$$ ( 2 2 ) ( 2 3 ) ( 3 2 ) ( 3 3 ) $$$ would cost $$$ 2 $$$ coin,['greedy'],2800.0
980/C,professor ibrahim prepare final homework algorithm ’ s class ask students implement posterization image filter algorithm test array integers $$$ i $$$ -th integer represent color $$$ i $$$ -th pixel image image black white therefore color pixel integer 0 255 ( inclusive ) implement filter students require divide black white color range [ 0 255 ] group consecutive color select one color group group ’ s key order preserve image detail size a group must greater $$$ k $$$ color belong exactly one group finally students replace color pixel array color ’ s assign group key better understand effect image a <unknown> turtle posterization filter apply increase $$$ k $$$ right make process check final answer easier professor ibrahim want students divide group assign key a way produce lexicographically smallest possible array first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ 1 \leq k \leq 256 $$$ ) number pixels image maximum size a group respectively second line contain $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 0 \leq p_i \leq 255 $$$ ) $$$ p_i $$$ color $$$ i $$$ -th pixel print $$$ n $$$ space - separated integers ; lexicographically smallest possible array represent image apply posterization filter one possible way group color assign key first sample : color $$$ 2 $$$ belong group $$$ [ <unknown> ] $$$ group key $$$ 0 $$$ color $$$ 14 $$$ belong group $$$ [ <unknown> ] $$$ group key $$$ 12 $$$ color $$$ 3 $$$ $$$ 4 $$$ belong group $$$ [ 3 5 ] $$$ group key $$$ 3 $$$ group wo n't affect result list,['greedy'],1700.0
1583/D,"turn mean life a permutation $$$ p_1 p_2 \ldots p_n $$$ integers $$$ 1 2 \ldots n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) omkar create life know permutation allow figure use query a query consist array $$$ a_1 a_2 \ldots a_n $$$ integers $$$ 1 $$$ $$$ n $$$ $$$ a $$$ require a permutation omkar first compute pairwise sum $$$ a $$$ $$$ p $$$ mean compute array $$$ s $$$ $$$ s_j = p_j + a_j $$$ $$$ j = 1 2 \ldots n $$$ , find smallest index $$$ k $$$ $$$ s_k $$$ occur $$$ s $$$ answer $$$ k $$$ index $$$ k $$$ answer $$$ 0 $$$ perform $$$ 2n $$$ query figure mean life $$$ p $$$ start interaction read single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) — length permutation $$$ p $$$ make query a query consist a single line ` ` $$$ ? \enspace a_1 \enspace a_2 \enspace \ldots \enspace a_n $$$ ` ` ( $$$ 1 \leq a_j \leq n $$$ ) answer query a single integer $$$ k $$$ describe ( $$$ 0 \leq k \leq n $$$ ) make a query forget output end line flush output otherwise get idleness limit exceed , use : output answer print a single line ` ` $$$ ! \enspace p_1 \enspace p_2 \enspace \ldots \enspace p_n $$$ ` ` terminate make $$$ 2n $$$ query output answer count a query hack formatto hack first output a line contain $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) output another line contain hide permutation $$$ p_1 p_2 \ldots p_n $$$ number $$$ 1 $$$ $$$ n $$$ sample hide permutation $$$ p $$$ $$$ [ 3 2 1 5 4 ] $$$ three query make first query $$$ a = [ 4 4 2 3 2 ] $$$ yield $$$ s = [ 3 + 4 2 + 4 1 + 2 5 + 3 4 + 2 ] = [ 7 6 3 8 6 ] $$$ $$$ 6 $$$ number appear appear first index $$$ 2 $$$ make answer query $$$ 2 $$$ second query $$$ a = [ 3 5 1 5 5 ] $$$ yield $$$ s = [ 3 + 3 2 + 5 1 + 1 5 + 5 4 + 5 ] = [ 6 7 2 10 9 ] $$$ number appear answer query $$$ 0 $$$ third query $$$ a = [ 5 2 4 3 1 ] $$$ yield $$$ s = [ 3 + 5 2 + 2 1 + 4 5 + 3 4 + 1 ] = [ 8 4 5 8 5 ] $$$ $$$ 5 $$$ $$$ 8 $$$ occur $$$ 5 $$$ first appear index $$$ 3 $$$ $$$ 8 $$$ first appear index $$$ 1 $$$ $$$ 1 < 3 $$$ make answer query $$$ 1 $$$ note sample mean provide example interaction work ; guarantee query represent a correct strategy determine answer",['greedy'],1800.0
1797/C,"interactive problem li ming li hua play a game li hua a chessboard size $$$ n\times m $$$ denote $$$ ( r c ) $$$ ( $$$ 1\le r\le n 1\le c\le m $$$ ) cell $$$ r $$$ -th row top $$$ c $$$ -th column leave li ming put a king chessboard li hua need guess position li hua ask li ming $$$ 3 $$$ question question choose a cell ask minimum step need move king choose cell question independent mean king n't actually move a king move $$$ ( x y ) $$$ $$$ ( x ' y ' ) $$$ $$$ \max\ { |x - <unknown> |y - <unknown> } = 1 $$$ ( show follow picture ) position king choose interaction suppose li hua please solve problem first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) first line test case contain two integers $$$ n m $$$ ( $$$ 1\le n m\le 1000000000 $$$ ) — size chessboard interaction begin ask a question print ` ` ? $$$ r $$$ $$$ c $$$ ` ` ( without quote $$$ 1 \leq r \leq n 1 \leq c \leq m $$$ ) input response standard input — minimum step king need move choose cell program ask invalid question run question interactor terminate immediately program get a verdict wrong answer give final answer print ` ` ! $$$ r $$$ $$$ c $$$ ` ` ( without quote $$$ ( r c ) $$$ king 's initial coordinate ) note give answer count towards limit $$$ 3 $$$ question ask a question forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack use follow format first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) first line test case contain four integers $$$ n m r c $$$ ( $$$ 1\le r\le n\le <unknown> c\le m\le 1000000000 $$$ ) test case 1 king $$$ ( 2,2 ) $$$ take $$$ 1 $$$ step move $$$ ( 2,3 ) $$$ $$$ 2 $$$ step move $$$ ( 2,4 ) $$$ note question may seem <unknown> a sample question may ask",['greedy'],1600.0
457/B,piegirl ask implement two table join operation distribute database system minimize network traffic suppose want join two table a b. certain number row distribute different number partition table a distribute first cluster consist m partition partition index i ai row a. similarly second cluster contain table b n partition i - th one bi row b. one network operation copy one row partition partition end row a row b a partition row determine minimal number network operations achieve first line contain two integer number m n ( 1 ≤ m n ≤ 105 ) second line contain description first cluster m space separate integers ai ( 1 ≤ ai ≤ 109 ) similarly third line describe second cluster n space separate integers bi ( 1 ≤ bi ≤ 109 ) print one integer — minimal number copy operations first example make sense move row second partition second cluster achieve 2 + 6 + 3 = 11 <unknown> second example piegirl copy row b partition first cluster need <unknown> = 6 copy operations,['greedy'],1900.0
478/C,r red g green b blue balloon decorate a single table <unknown> need exactly three balloon three balloon attach table n't color maximum number t table decorate know number balloon color ? task write a program give value r g b find maximum number t table decorate require manner single line contain three integers r g b ( 0 ≤ r g b ≤ 2·109 ) — number red green blue <unknown> respectively number separate exactly one space print a single integer t — maximum number table decorate require manner first sample decorate table follow balloon set : ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` r '' ` ` g '' ` ` b '' represent red green blue ball respectively,['greedy'],1800.0
472/C,a way make a new task make nondeterministic probabilistic example hard task <unknown> <unknown> <unknown> <unknown> probabilistic version a convex <unknown> let 's try make a new task firstly use follow task n people sort name ordinary sort problem make interest add nondeterministic element n people person use either his / her first name last name a handle lexicographical order handle exactly equal give permutation p ? formally denote handle i - th person hi follow condition must hold : first line contain integer n ( 1 ≤ n ≤ 105 ) — number people next n line contain two string i - th line contain string fi si ( 1 ≤ <unknown> <unknown> ≤ 50 ) — first name last name i - th person string consist lowercase english letter give 2n string distinct next line contain n distinct integers : p1 p2 ... pn ( 1 ≤ pi ≤ n ) possible output ` ` yes '' otherwise output ` ` '' example 1 2 3 people : tourist petr ( <unknown> ) see whatever handle choose i must first tourist petr must last example 3 copernicus use ` ` copernicus '' handle everything <unknown>,['greedy'],1400.0
462/B,appleman n card card uppercase letter write toastman must choose k card appleman 's card appleman give toastman coin depend choose card formally toastman 's card i calculate much toastman 's card letter equal letter ith sum <unknown> a number coin appleman give toastman give description appleman 's card maximum number coin toastman get ? first line contain two integers n k ( 1 ≤ k ≤ n ≤ 105 ) next line contain n uppercase letter without space — i - th letter describe i - th card appleman print a single integer – answer problem first test example toastman choose nine card letter d one additional card letter card d get 9 coin additional card get 1 coin,['greedy'],1300.0
436/A,hero cut <unknown> game a little monster name om nom love candy a coincidence ! also hero today 's problem one day om nom visit friend evan evan n candy two type ( fruit drop caramel drop ) i - th candy hang height hi centimeters floor house mass mi om nom want eat many candy possible begin om nom make x <unknown> high jump om nom eat a candy mass y get stronger height jump increase y centimeters maximum number candy om nom eat never eat two candy type a row ( om nom find bore ) ? first line contain two integers n x ( 1 ≤ n x ≤ 2000 ) — number sweets evan initial height om nom 's jump follow n line contain three integers ti hi mi ( 0 ≤ ti ≤ 1 ; 1 ≤ hi mi ≤ 2000 ) — type height mass i - th candy number ti equal 0 current candy a caramel drop otherwise a fruit drop print a single integer — maximum number candy om nom eat one possible ways eat 4 candy eat order : 1 5 3 2 . let 's assume follow scenario :,['greedy'],1500.0
322/A,fox ciel friends a dance room n boys m girls never dance songs song must exactly one boy one girl dance besides a special rule : help fox ciel make a schedule dance many songs possible first line contain two integers n m ( 1 ≤ n m ≤ 100 ) — number boys girls dance room first line print k — number songs dance follow k line print index boys girls dance songs chronologically assume boys index 1 n girls index 1 m. test case 1 2 boys 1 girl 2 dance : 1st boy 1st girl ( first song ) 2nd boy 1st girl ( second song ) test case 2 2 boys 2 girls answer 3,['greedy'],1000.0
556/A,<unknown> <unknown> a galaxy - famous detective free time like think string contain zero ones think a string length n consist zero ones consider follow operation : choose two adjacent position string one contain 0 contain 1 allow remove two digits string obtain a string length n - 2 a result andreid think minimum length string remain apply describe operation several time ( possibly zero ) ? help calculate number first line input contain a single integer n ( 1 ≤ n ≤ 2·105 ) length string andreid second line contain string length n consist zero ones output minimum length string may remain apply describe operations several time first sample test possible change string like follow : second sample test possible change string like follow : third sample test possible change string like follow :,['greedy'],900.0
201/B,a widely know among people <unknown> sport programmer yura possess lot information cars invite participate a game show call ` ` guess car ! ` ` game show take place a giant park lot 4n meter long north south 4 m meter wide west east lot n + 1 divide line draw west east m + 1 divide line draw north south divide park lot n·m 4 4 meter square a car park strictly inside square divide line number 0 n north south 0 m west east square coordinate ( i j ) square north - west corner coordinate ( 1 1 ) square south - east corner coordinate ( n m ) see picture note clarifications game show organizers offer yura occupy ( n + 1 ) · ( m + 1 ) intersection point divide line start guess cars yura choose a point prohibit move along park lot end game show yura a car expert always guess cars offer 's a matter time yura know guess car need spend time equal square euclidean distance point center square car multiply coefficient characterize machine 's ` ` rarity '' ( <unknown> car harder guess ) formally guess a car ` ` rarity '' c place a square whose center distance d yura take <unknown> second time yura spend turn head <unknown> happen yura know ` ` rarity '' car park lot advance help choose point total time guess cars smallest possible first line contain two integers n m ( 1 ≤ n m ≤ 1000 ) — size park lot next n line contain m integers : j - th number i - th line describe ` ` rarity '' cij ( 0 ≤ cij ≤ 100000 ) car locate square coordinate ( i j ) first line print minimum total time yura need guess offer cars second line print two number li lj ( 0 ≤ li ≤ n 0 ≤ lj ≤ m ) — number divide line form a junction yura choose stand begin game show multiple optimal start point print point smaller li still multiple point print point smaller lj please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first test case total time guess cars equal 3·8 + 3·8 + <unknown> + <unknown> + <unknown> + <unknown> = <unknown> . coordinate system field :,['math'],1800.0
197/B,give two polynomials : calculate limit first line contain two space - separated integers n m ( 0 ≤ n m ≤ 100 ) — degrees polynomials p ( x ) q ( x ) correspondingly second line contain n + 1 space - separated integers — factor polynomial p ( x ) : a0 a1 ... - 1 ( - 100 ≤ ai ≤ 100 a0 ≠ 0 ) third line contain m + 1 space - separated integers — factor polynomial q ( x ) : b0 b1 ... bm - 1 bm ( - 100 ≤ bi ≤ 100 b0 ≠ 0 ) limit equal + ∞ print ` ` infinity '' ( without quote ) limit equal - ∞ print ` ` <unknown> '' ( without quote ) value limit equal zero print ` ` 0/1 '' ( without quote ) otherwise print irreducible fraction — value limit format ` ` p / q '' ( without quote ) p — <unknown> q ( q > 0 ) denominator fraction let 's consider sample : learn definition properties limit follow link : http : //en.wikipedia.org / wiki / <unknown>,['math'],1400.0
197/A,' ve get a rectangular table length a width b infinite number plat radius r. two players play follow game : take turn put plat table plat n't lie ( touch ) point plate locate within table 's border game one move plat already lie table player make another move lose determine player win one move first one move second provide players play optimally well a single line contain three space - separated integers a b r ( 1 ≤ a b r ≤ 100 ) — table side plat ' radius correspondingly win player move first print ` ` first '' ( without quote ) otherwise print ` ` second '' ( without quote ) first sample table place one plate first player put a plate table second player ca n't lose second sample table small n't enough place even one plate first player lose without make a single move,['math'],1600.0
194/B,"a square paint a piece paper square 's side equal n meter john doe draw cross square 's perimeter john paint first cross lower leave corner square john move along square 's perimeter clockwise direction ( first upwards right <unknown> leave ) every time walk ( n + 1 ) meter draw a cross ( see picture clarifications ) john doe stop lower leave corner square two cross many cross john draw ? first line contain integer t ( 1 ≤ t ≤ 104 ) — number test case second line contain t space - separated integers ni ( 1 ≤ ni ≤ 109 ) — side square test sample test sample print a single line answer , number cross john draw move along square correspond size print answer sample order sample give input please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier",['math'],1200.0
185/B,well know whole universe traditionally use three - dimensional cartesian system coordinate system point correspond three real coordinate ( x y z ) coordinate system distance center universe point calculate follow formula : mushroom scientists work great mushroom king think universe n't exactly right distance center universe a point equal <unknown> test metric mushroom scientists usual scientists offer a task : find x y z ( 0 ≤ x y z ; x + y + z ≤ s ) distance center universe point ( x y z ) maximum possible metric mushroom scientists mushroom scientists n't good maths commission task note problem consider 00 = 1 . first line contain a single integer s ( 1 ≤ s ≤ 103 ) — maximum sum coordinate seek point second line contain three space - separated integers a b c ( 0 ≤ a b c ≤ 103 ) — number describe metric mushroom scientists print three real number — coordinate point reach maximum value <unknown> mushroom scientists multiple answer print meet limitations a natural logarithm distance center universe give point metric mushroom scientists n't differ natural logarithm maximum distance 10 - 6 . think <unknown> ( 0 ) = - ∞,['math'],1800.0
188/D,give a number n. print n line i - th line consist i character ` ` * '' line ' indices 1 - based line input contain integer n ( 1 ≤ n ≤ 50 ) output describe pattern,['implementation'],1100.0
132/A,<unknown> <unknown> esoteric program languages one many weird feature method character - based output know <unknown> <unknown> method convert array <unknown> 8 - bit integers a sequence character print use follow method integers array process one one start first process i - th element array do three <unknown> . 8 - bit binary notation ascii - code previous print character reverse first element array process result step consider <unknown> . i - th element array subtract result previous step modulo <unknown> . binary notation result previous step reverse produce ascii - code i - th character print give text print use method restore array use produce text input consist a single line text contain message print use describe method string text contain 1 100 character inclusive ascii - code character text 32 ( space ) 126 ( <unknown> ) inclusive output initial array use produce text one integer per line let 's a closer look begin example first character ` ` h '' ascii - code <unknown> = <unknown> . reverse <unknown> = 18 number become result second step process result first step consider 0 first element array ( 0 - 18 ) mod 256 = <unknown> a mod b remainder division a b,['implementation'],1300.0
188/B,give number a b. calculate sum a reverse b. a reverse a number a number contain digits reverse order example reverse 230 32 reverse 0 0 . input contain two integers a b ( 0 ≤ a b ≤ 109 ) separate a single space number give without lead zero output sum a reverse b,['implementation'],1300.0
182/B,vasya live a strange world year n months i - th month ai days vasya get a new year present — clock show time also date clock 's face display number 1 d. guarantee ai ≤ d i 1 n. clock keep information current month a new day come simply increase current day number one clock display number d + 1 day number d show day 1 ( current day counter reset ) mechanism clock allow increase day number one manually execute operation day d also follow day 1 . vasya begin day check day number clock day number clock match actual day number current month vasya manually increase one vasya <unknown> repeat operation day number clock match actual number current day current month a year pass vasya wonder many time manually increase day number one first day first month last day n - th month inclusive consider first day first month clock display show day 1 . first line contain single number d — maximum number day vasya 's clock show ( 1 ≤ d ≤ 106 ) second line contain a single integer n — number months year ( 1 ≤ n ≤ 2000 ) third line contain n space - separated integers : ai ( 1 ≤ ai ≤ d ) — number days month order follow start first one print a single number — number time vasya manually increase day number one throughout last year first sample situation like :,['implementation'],1000.0
180/A,"problem implement algorithm defragment hard disk hard disk consist a sequence cluster number integers 1 n. disk m record file i - th file occupy cluster number ai 1 ai 2 ... ai ni cluster necessarily locate consecutively disk order give correspond sequence file ( cluster ai 1 contain first fragment i - th file cluster ai 2 second fragment etc . ) also <unknown> must one several cluster free file permit perform operations copy content cluster number i cluster number j ( i j must different ) moreover cluster number j use keep information lose forever cluster clean defragmentation complete simply declare <unknown> ( although may possibly still contain fragment file ) task use a sequence copy operations ensure file occupy a contiguous area memory file occupy a consecutive cluster section file must follow one another begin hard disk defragmentation free ( unused ) cluster end hard disk <unknown> file place arbitrary order cluster file go consecutively first last see <unknown> examples note print sequence operations lead disk defragmentation note minimize number operations exceed 2n first line contain two integers n m ( 1 ≤ n m ≤ 200 ) — number cluster number file correspondingly next m line contain descriptions file first number line ni ( ni ≥ 1 ) number cluster occupy i - th file follow ni number ai 1 ai 2 ... ai ni ( 1 ≤ ai j ≤ n ) guarantee cluster number occur , exist least one unused cluster number line separate space first line print a single integer k ( 0 ≤ k ≤ 2n ) — number operations need defragment disk next k line contain operations ' descriptions ` ` i j '' ( copy content cluster number i cluster number j ) let 's say a disk consist 8 cluster contain two file first file occupy two cluster second file occupy three cluster let 's look examples correct incorrect position file defragmentation example 2 : file must occupy a contiguous area memory example 3 : order file important first second file write — first one example 4 : violate order file fragment allow example 5 : unused cluster locate end example unused cluster 3 7 8",['implementation'],1800.0
177/A2,smart beaver abbyy get <unknown> square matrices busy study n × n size matrix n odd smart beaver consider follow matrix elements good : help smart beaver count sum good elements give matrix first line input data contain a single odd integer n. next n line contain n integers aij ( 0 ≤ aij ≤ 100 ) separate single space — elements give matrix input limitations get 30 point : input limitations get 100 point : print a single integer — sum good matrix elements first sample matrix elements good good elements second sample show figure,['implementation'],800.0
175/B,vasya play plane tank friends whole year time divide participants several categories depend result a player give a non - negative integer number point round plane tank vasya write result round last year n record total order determine a player 's category consider best result obtain player best result players player belong category : percentage calculate player take account mean two players play game first one gain 100 point second one 1000 point first player 's result worse result 50 % players second one worse result 100 % players vasya give last year plane tank result help vasya determine player 's category first line contain integer number n ( 1 ≤ n ≤ 1000 ) — a number record players ' result next n line contain a player 's name amount point obtain player round separate a space name contain less 1 10 character name consist lowercase latin letter guarantee two different players different name amount point obtain player round a non - negative integer number exceed 1000 . print first line number m — number players participate one round least one next m line contain a player name a category belong separate space category one follow : ` ` noob '' ` ` random '' ` ` average '' ` ` <unknown> '' ` ` pro '' ( without quote ) name player print player name respective categories print arbitrary order first example best result obtain artem worse result 25 % players ( result ) belong category ` ` noob '' vasya kolya best result worse result 75 % players ( artem ) belong category ` ` random '' igor best result worse result 100 % players ( players ) belong category ` ` pro '' second example players amount point result worse 100 % players belong category ` ` pro '',['implementation'],1400.0
171/H,input contain two integers a b ( 1 ≤ a ≤ 10 0 ≤ b ≤ <unknown> - 1 ) separate a single space output two integers separate a single space,['implementation'],1700.0
171/C,make a cake 'll never eat ingredients method serve 1 . line input contain a sequence integers a0 a1 ... ( 1 ≤ a0 ≤ 100 0 ≤ ai ≤ 1000 i ≥ 1 ) output a single integer,['implementation'],2000.0
165/A,one day vasya paint a cartesian coordinate system a piece paper mark set point ( x1 y1 ) ( x2 y2 ) ... ( xn <unknown> ) let 's define neighbor fix point give set ( x y ) : 'll consider point ( x y ) give set supercentral least one upper least one lower least one leave least one right neighbor among set 's point vasya mark quite many point paper analyze picture manually rather a challenge vasya ask help task find number supercentral point give set first input line contain integer n ( 1 ≤ n ≤ 200 ) — number point give set next n line contain coordinate point write ` ` x y '' ( without quote ) ( |x| |y| ≤ 1000 ) coordinate integers number line separate exactly one space guarantee point different print number — number supercentral point give set first sample supercentral point point ( 1 1 ) ( 1 2 ) second sample one <unknown> point — point ( 0 0 ),['implementation'],1000.0
158/A,` ` contestant earn a score equal greater k - th place <unknown> 's score advance next round long contestant earn a positive score ... '' — <unknown> contest rule a total n participants take part contest ( n ≥ k ) already know score calculate many participants advance next round first line input contain two integers n k ( 1 ≤ k ≤ n ≤ 50 ) separate a single space second line contain n space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 100 ) ai score earn participant get i - th place give sequence non - increasing ( i 1 n - 1 follow condition fulfil : ai ≥ ai + 1 ) output number participants advance next round first example participant 5th place earn 7 point participant 6th place also earn 7 point 6 <unknown> second example nobody get a positive score,['implementation'],800.0
152/A,vasya mr . <unknown> petrov a <unknown> a department a local university winter exams get hand a group 's gradebook overall group n students receive mark m subject student get a mark 1 9 ( inclusive ) subject let 's consider a student best subject student get a higher mark subject let 's consider a student successful exist a subject best task find number successful students group first input line contain two integers n m ( 1 ≤ n m ≤ 100 ) — number students number subject correspondingly next n line contain m character describe gradebook character gradebook a number 1 9 . note mark a row <unknown> space print single number — number successful students give group first sample test student number 1 best subject 1 3 student 2 best subject 1 2 student 3 n't best subject second sample test student best least one subject,['implementation'],900.0
149/B,stay home alone petya decide watch forbid film net secret ` ` <unknown> behavior ! '' — say course n't harsh kid country film martians <unknown> <unknown> forbid unfair petya adore adventure <unknown> feature lasers robots today petya watch a <unknown> <unknown> martians call ` ` r2 : d2 '' ` ` r2 : d2 '' possibly mean ? might martian time represent martian numeral system petya know time mar count like earth ( 24 hours hour 60 minutes ) time write ` ` a : b '' string a stand number hours ( 0 23 inclusive ) string b stand number minutes ( 0 59 inclusive ) thing petya n't know numeral system martian time write task print radixes numeral system contain time ` ` a : b '' first line contain a single string ` ` a : b '' ( without quote ) a a non - empty string consist number uppercase latin letter string a show number hours string b a non - empty string consist number uppercase latin letter string b show number minutes lengths string a b 1 5 character inclusive please note string a b lead zero influence result way ( example string ` ` <unknown> '' decimal notation denote correctly write time ) consider character 0 1 ... 9 denote correspond digits number 's representation numeral system character a b ... z correspond number 10 11 ... 35 . print radixes numeral systems represent time ` ` a : b '' increase order separate number space line break numeral system represent time ` ` a : b '' print single integer 0 . infinitely many numeral systems represent time ` ` a : b '' print single integer -1 . note mar <unknown> numeral systems positive radix strictly larger one possible let 's consider first sample string ` ` <unknown> '' perceive example time <unknown> represent <unknown> numeral system time <unknown> hexadecimal system let 's consider second sample test string ` ` <unknown> '' ca n't perceive correct time notation example let 's take <unknown> numeral notation give string represent time <unknown> n't a correct time let 's consider third sample string ` ` <unknown> '' perceive a correct time infinite number numeral systems need example take numeral system radix less 12,['implementation'],1600.0
144/B,"super duper secret meet super duper secret military squad take place a super duper secret place place infinite plane introduce cartesian coordinate system meet table represent a rectangle whose side parallel coordinate ax whose vertexes locate integer point plane integer point belong table perimeter a chair a general sit point plane contain radiators general <unknown> winter radiator characterize number ri — radius area radiator heat , distance general give radiator less equal ri general feel comfortable warm distance define euclidean distance distance point ( x1 y1 ) ( x2 y2 ) general locate outside radiators ' heat area get sick thus bring a warm blanket task count number warm blanket bring super duper secret place general already comfortable need a blanket also general never <unknown> ever locate heat area several radiators radiators locate integer point plane even inside rectangle ( table ) perimeter ( directly general ) even case radius change first input line contain coordinate two opposite table corner xa ya xb yb ( xa ≠ xb ya ≠ yb ) second line contain integer n — number radiators ( 1 ≤ n ≤ 103 ) n line contain heaters ' coordinate ` ` xi yi ri '' number separate space input data number integers absolute value coordinate exceed 1000 1 ≤ ri ≤ 1000 . several radiators locate point print number — number blanket bring first sample general sit point : ( 2 2 ) ( 2 3 ) ( 2 4 ) ( 2 5 ) ( 3 2 ) ( 3 5 ) ( 4 2 ) ( 4 3 ) ( 4 4 ) ( 4 5 ) among 4 general locate outside heat range general point : ( 2 5 ) ( 3 5 ) ( 4 4 ) ( 4 5 ) second sample general sit point : ( 5 2 ) ( 5 3 ) ( 6 2 ) ( 6 3 ) locate inside heat range",['implementation'],1300.0
144/A,a ministry defense send a general <unknown> super secret military squad command colonel <unknown> learn news colonel order n squad soldier line <unknown> grind military <unknown> soldier stand order non - increasing height 's <unknown> time soldier line arbitrary order however general rather short - <unknown> think soldier line correctly first soldier line maximum height last soldier minimum height please note way <unknown> position matter include case several soldier whose height maximum minimum heights first last soldier important example general consider sequence heights ( 4 3 4 2 1 1 ) correct sequence ( 4 3 1 2 2 ) wrong within one second colonel swap two neighbor soldier help count minimum time need form a line - up general consider correct first input line contain integer n ( 2 ≤ n ≤ 100 ) represent number soldier line second line contain integers a1 a2 ... ( 1 ≤ ai ≤ 100 ) value soldier ' heights order soldier ' heights ' increase order begin line end number space - separated number a1 a2 ... necessarily different print integer — minimum number second colonel need form a line - up general like first sample colonel need swap first second soldier third fourth soldier take 2 second result position soldier ( 44 <unknown> 22 11 ) second sample colonel may swap soldier follow sequence :,['implementation'],800.0
139/A,"one sunday petr go a <unknown> buy a new book sport program book exactly n page petr decide start read start next day , monday petr 's get a tight schedule day week know many page able read day days busy petr time read whatsoever however know able read least one page a week assume petr skip days read much every day determine day week read last page book first input line contain single integer n ( 1 ≤ n ≤ 1000 ) — number page book second line contain seven non - negative space - separated integers exceed 1000 — integers represent many page petr read monday tuesday wednesday thursday friday saturday sunday correspondingly guarantee least one number larger zero print a single number — number day week petr finish read book days week number start one natural order : monday tuesday wednesday thursday friday saturday sunday note first sample : end monday therefore begin tuesday petr 85 page leave 65 page leave wednesday <unknown> thursday 30 friday 20 saturday saturday petr finish read book ( also time read 10 page something else ) note second sample : monday first week petr read first page monday second week petr read second page finish read book",['implementation'],1000.0
138/A,vera adore poems poems vera know divide quatrains ( group four line ) quatrain line contain rhyme let 's consider line poems consist lowercase latin letter ( without space ) letter ` ` a '' ` ` e '' ` ` i '' ` ` o '' ` ` u '' consider vowels two line rhyme suffix start k - th vowels ( count end ) match a line less k vowels line ca n't rhyme line example k = 1 line commit <unknown> rhyme ( correspond suffix equal ) k = 2 rhyme ( <unknown> ≠ <unknown> ) today a <unknown> lesson vera learn quatrains contain four different scheme rhyme namely follow ones ( letter stand rhyme line ) : line a quatrain pairwise rhyme quatrain belong rhyme scheme ( situation represent aaaa ) quatrains a poem belong rhyme scheme assume whole poem belong rhyme scheme quatrain line pairwise rhyme rhyme scheme poem aaaa let us note n't matter whether line different quatrains rhyme word possible different quatrains n't connect a rhyme vera get a long poem a home task girl analyse find poem rhyme scheme help vera cope task first line contain two integers n k ( 1 ≤ n ≤ 2500 1 ≤ k ≤ 5 ) — number quatrains poem vowel 's number correspondingly next 4n line contain poem line empty consist small latin letter total length line exceed 104 . assume line number start 1 first quatrain contain line number 1 2 3 4 ; second one contain line number 5 6 7 8 ; print rhyme scheme poem ` ` aabb '' ` ` abab '' ` ` abba '' ` ` aaaa '' ; ` ` '' poem belong mention scheme last sample quatrains rhyme find common scheme impossible answer ` ` '',['implementation'],1600.0
137/A,polycarpus postcards photos hang a row wall decide put away closet hang wall a famous <unknown> 's picture polycarpus like : go leave right remove object consecutively polycarpus n't want mix - <unknown> happen carry hand object two different type word polycarpus ca n't carry postcards photos simultaneously sometimes go closet put object thus leave hand free polycarpus must put postcards photos closet skip object minimum number time visit closet carry 5 items ? line input data contain a non - empty string consist letter ` ` с '' ` ` p '' whose length exceed 100 character i - th character string letter ` ` с '' mean i - th object ( number go leave right ) polycarpus ' wall a postcard i - th character letter ` ` p '' i - th object wall a photo print number — minimum number time polycarpus visit closet first sample polycarpus need take one item closet 7 time second sample polycarpus first take 3 postcards closet ; 3 take 6 photos leave similar way go closet twice third sample polycarpus visit closet twice time carry 3 postcards take 2 photos one postcard finally carry last 10 photos visit closet twice fourth sample polycarpus visit closet twice take 10 postcards ( 5 items go ),['implementation'],900.0
136/A,little petya much like gift recently receive a new laptop a new year gift mother immediately decide give somebody else <unknown> give somebody gift <unknown> organize a new year party place invite n friends 's one thing petya like receive gift 's watch others give gift somebody else thus safely hide laptop next new year make mind watch friends exchange gift participate process number friends integers 1 n. petya remember a friend number i give a gift a friend number pi also remember friends receive exactly one gift petya want know friend i number a friend give a gift first line contain one integer n ( 1 ≤ n ≤ 100 ) — quantity friends petya invite party second line contain n space - separated integers : i - th number pi — number a friend give a gift friend number i. guarantee friend receive exactly one gift possible friends share petya 's ideas give gift somebody else friends give gift print n space - separated integers : i - th number equal number friend give a gift friend number i,['implementation'],800.0
133/B,unary a minimalistic brainfuck <unknown> program write use one <unknown> brainfuck program use 8 command : ` ` + '' ` ` - '' ` ` [ ` ` ` ` ] '' ` ` < ` ` ` ` > '' ` ` . '' ` ` '' ( mean important purpose problem ) unary program create brainfuck program use follow algorithm first replace command a correspond binary code use follow <unknown> table : next concatenate result binary cod one binary number order program finally write number use unary numeral system — unary program equivalent original brainfuck one give a brainfuck program task calculate size equivalent unary program print modulo 1000003 ( 106 + 3 ) input consist a single line p give a brainfuck program string p contain 1 100 character inclusive character p ` ` + '' ` ` - '' ` ` [ ` ` ` ` ] '' ` ` < ` ` ` ` > '' ` ` . '' ` ` '' output size equivalent unary program modulo 1000003 ( 106 + 3 ) write a number n unary numeral system one simply write 1 n time example 5 write unary system <unknown> . first example replace brainfuck command binary code give us 1101 1100 . concatenate cod 'll get <unknown> binary system 220 decimal 's exactly number <unknown> equivalent unary program,['implementation'],1200.0
132/B,"piet one know visual esoteric program languages program piet construct colorful block pixels interpret use pretty complicate rule problem use a subset piet language simplify rule program a rectangular image consist color black pixels color pixel give integer number 0 9 inclusive 0 denote black a block pixels define a rectangle pixels color ( black ) guarantee connect group color pixels color form rectangular block group black pixels form arbitrary shape program interpret use movement instruction <unknown> ( ip ) consist three part : initially bp point block contain top - left corner program dp point right cp point leave ( see orange square image ) one step program interpretation change state ip a follow way interpreter find furthest edge current color block direction dp pixels form edge interpreter select furthest one direction cp , bp attempt move pixel next one direction dp next pixel belong a color block block become current one two part ip stay next pixel black outside program bp stay two part ip change cp point leave point right dp stay cp point right point leave dp rotate 90 degrees clockwise way bp never point a black block ( guarantee top - left pixel program black ) give a piet program figure block program current n step first line input contain two integer number m ( 1 ≤ m ≤ 50 ) n ( 1 ≤ n ≤ <unknown> ) next m line contain row program line length 1 50 pixels consist character 0 - 9 . first character first line equal 0 . output color block current n step program interpretation first example ip change follow way step 1 block 2 become current one stay two step step 4 bp move block 3 step 7 — block 4 finally step 10 bp return block 1 . sequence state ip show image : arrows traverse clockwise main arrow show direction dp side one — direction cp",['implementation'],2100.0
162/A,pentagonal number <unknown> number calculate use formula pn = ( <unknown> - n ) / 2 ( always integer ) give n ; calculate n - th pentagonal number line input contain integer n ( 1 ≤ n ≤ 100 ) output n - th pentagonal number,['implementation'],1100.0
146/A,petya love lucky number much everybody know lucky number positive integers whose decimal record contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 petya love ticket much know ticket a number a positive integer length equal n ( n always even ) petya call a ticket lucky ticket 's number a lucky number sum digits first half ( sum first n / 2 digits ) equal sum digits second half ( sum last n / 2 digits ) check give ticket lucky first line contain even integer n ( 2 ≤ n ≤ 50 ) — length ticket number need check second line contain integer whose length equal exactly n — ticket number number may contain lead zero first line print ` ` yes '' give ticket number lucky otherwise print ` ` '' ( without quote ) first sample sum digits first half equal sum digits second half ( 4 ≠ 7 ) second sample ticket number lucky number,['implementation'],800.0
53/A,autocomplete a program function enable <unknown> text ( <unknown> command line <unknown> <unknown> etc . ) complete text inputted part vasya busy work a new browser call ' <unknown> ' happen work autocomplete function address line moment a list consist n last visit user page inputted part s know task complete s make address one page list find lexicographically smallest address a prefix s. first line contain s line inputted part second line contain integer n ( 1 ≤ n ≤ 100 ) number visit page follow n line visit page one line line lengths 1 100 symbols inclusively consist lowercase latin letter s begin n address visit page print s. otherwise print lexicographically minimal address one visit page start s. lexicographical order order word a dictionary lexicographical comparison line realize ' < ' operator modern program languages,['implementation'],1100.0
49/A,vasya play sleuth friends rule game follow : play first time vasya sleuth investigate a ` ` crime '' find happen ask question whatsoever answer ` ` yes '' ` ` '' rest agree beforehand answer question like : question ’ s last letter a vowel answer ` ` yes '' last letter a consonant answer ` ` '' course sleuth know nothing task understand unfortunately vasya smart 5 hours endless stupid question everybody except vasya get bore ’ s vasya ’ s friends ask write a program would give answer instead english alphabet vowels : a e i o u <unknown> english alphabet consonants : b c d f g h j k l m n p q r s t v w x <unknown> single line contain a question represent a non - empty line consist large small latin letter space a question mark line length exceed 100 . guarantee question mark occur exactly line — last symbol line contain least one letter print answer question a single line : yes answer ` ` yes '' answer ` ` '' remember reply question last letter last character count i. e. space question mark count letter,['implementation'],800.0
255/A,"greg a beginner <unknown> today gym coach give train plan n integers a1 a2 ... , number mean greg need exactly n exercise today besides greg repeat i - th order exercise ai time greg three type exercise : ` ` chest '' exercise ` ` biceps '' exercise ` ` back '' exercise besides train cyclic , first exercise a ` ` chest '' one second one ` ` biceps '' third one ` ` back '' fourth one ` ` chest '' fifth one ` ` biceps '' n - th exercise greg wonder muscle get exercise train know exercise greg repeat maximum number time train correspond muscle help greg determine muscle get train first line contain integer n ( 1 ≤ n ≤ 20 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 25 ) — number time greg repeat exercise print word ` ` chest '' ( without quote ) chest get exercise ` ` biceps '' ( without quote ) biceps get exercise print ` ` back '' ( without quote ) back get exercise guarantee input answer problem unambiguous first sample greg 2 chest 8 biceps zero back exercise biceps get exercise second sample greg 5 chest 1 biceps 10 back exercise back get exercise third sample greg 18 chest 12 biceps 8 back exercise chest get exercise",['implementation'],800.0
