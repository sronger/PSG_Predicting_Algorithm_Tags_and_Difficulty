,description,tags,rating
10/A,tom interest power consumption favourite laptop laptop three modes normal mode laptop consume p1 watt per minute t1 minutes tom move mouse touch keyboard last time a screensaver start power consumption change p2 watt per minute finally t2 minutes start screensaver laptop switch ` ` sleep '' mode consume p3 watt per minute tom move mouse touch keyboard laptop second third mode switch first ( normal ) mode tom 's work laptop divide n time periods [ l1 r1 ] [ l2 r2 ] ... [ ln rn ] interval tom continuously move mouse press button keyboard periods tom stay away laptop find total amount power consume laptop period [ l1 rn ] first line contain 6 integer number n p1 p2 p3 t1 t2 ( 1 ≤ n ≤ 100 0 ≤ p1 p2 p3 ≤ 100 1 ≤ t1 t2 ≤ 60 ) follow n line contain description tom 's work i - th line contain two space - separated integers li ri ( 0 ≤ li < ri ≤ 1440 ri < li + 1 i < n ) stand start end i - th period work output answer problem,['implementation'],900.0
10/D,"problem differ one online contest sequence a1 a2 ... call increase ai < ai + 1 i < n. sequence s1 s2 ... sk call subsequence sequence a1 a2 ... , exist a set index 1 ≤ i1 < i2 < ... < ik ≤ n aij = sj word sequence s derive sequence a cross elements give two sequence integer number find longest common increase subsequence i.e increase sequence maximum length subsequence sequence first line contain integer n ( 1 ≤ n ≤ 500 ) — length first sequence second line contain n space - separated integers range [ 0 109 ] — elements first sequence third line contain integer m ( 1 ≤ m ≤ 500 ) — length second sequence fourth line contain m space - separated integers range [ 0 109 ] — elements second sequence first line output k — length longest common increase subsequence second line output subsequence separate elements a space several solutions output",['dp'],2800.0
100/A,soroush 's room a square side length n. contest buy k fine persian carpet carpet room celebrate <unknown> contest favorite site persian carpet a square side length n1 soroush want cover area room carpet put allow rotate carpet soroush carpet room completely ? input consist three integer number n k n1 ( 10 ≤ n ≤ 12 1 ≤ k ≤ 10 ) write a single yes write yes <unknown> carpet room completely,['implementation'],1100.0
1000/A,codehorses host second codehorses cup year previous one organizers give t - shirts winners valid size t - shirts either ` ` m '' $$$ 0 $$$ $$$ 3 $$$ ` ` x '' follow ` ` s '' ` ` l '' example size ` ` m '' ` ` <unknown> '' ` ` l '' ` ` xxxl '' valid ` ` xm '' ` ` z '' ` ` <unknown> '' $$$ n $$$ winners cup previous year current year ksenia a list t - shirt size print last year cup yet send new list print office organizers want distribute prize soon possible ksenia require write whole list scratch make change list previous year one second choose arbitrary position word replace character uppercase latin letter ksenia ca n't remove add letter word minimal number second ksenia require spend change last year list current one ? list unordered mean two list consider equal number occurrences string list first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number t - shirts $$$ i $$$ -th next $$$ n $$$ line contain $$$ a_i $$$ — size $$$ i $$$ -th t - shirt list previous year $$$ i $$$ -th next $$$ n $$$ line contain $$$ b_i $$$ — size $$$ i $$$ -th t - shirt list current year guarantee size input valid also guarantee ksenia produce list $$$ b $$$ list $$$ a $$$ print minimal number second ksenia require spend change last year list current one list already equal print 0 . first example ksenia replace ` ` m '' ` ` s '' ` ` s '' one occurrences ` ` xs '' ` ` l '' second example ksenia replace ` ` l '' ` ` xxxl '' ` ` s '' third example list equal,"['greedy', 'implementation']",1200.0
1003/F,give a text consist $$$ n $$$ space - separated word exactly one space character pair adjacent word space first word space last word length text number letter space $$$ w_i $$$ $$$ i $$$ -th word text word consist lowercase latin letter let 's denote a segment word $$$ w [ i .. j ] $$$ a sequence word $$$ w_i w _ { i + 1 } \dots w_j $$$ two segment word $$$ w [ i_1 .. j_1 ] $$$ $$$ w [ i_2 .. j_2 ] $$$ consider equal $$$ j_1 - i_1 = j_2 - i_2 $$$ $$$ j_1 \ge i_1 $$$ $$$ j_2 \ge i_2 $$$ every $$$ t \in [ 0 j_1 - i_1 ] $$$ $$$ w _ { i_1 + t } = w _ { i_2 + t } $$$ example text ` ` '' segment $$$ w [ 1 .. 2 ] $$$ $$$ w [ 5 .. 6 ] $$$ equal correspond word ` ` '' abbreviation a replacement segment word first uppercase letter order perform abbreviation choose least two non - intersecting equal segment word replace choose segment string consist first letter word segment ( write uppercase ) example text ` ` a ab a a b ab a a b c '' replace segment word $$$ w [ 2 .. 4 ] $$$ $$$ w [ 6 .. 8 ] $$$ abbreviation ` ` aaa '' obtain text ` ` a aaa b aaa b c '' replace segment word $$$ w [ 2 .. 5 ] $$$ $$$ w [ 6 .. 9 ] $$$ abbreviation ` ` aaab '' obtain text ` ` a aaab aaab c '' minimum length text one abbreviation ? first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 300 $$$ ) — number word text next line contain $$$ n $$$ space - separated word text $$$ w_1 w_2 \dots w_n $$$ word consist lowercase latin letter guarantee length text exceed $$$ 100000 $$$ print one integer — minimum length text one abbreviation first example obtain text ` ` tb tb '' second example obtain text ` ` a aaab aaab c '' third example obtain text ` ` ab aa ab bb '',['dp'],2200.0
1005/D,"polycarp like number divisible 3 . a huge number $$$ s $$$ polycarp want cut maximum number number divisible $$$ 3 $$$ , make arbitrary number vertical cut pair adjacent digits a result $$$ m $$$ cut $$$ m+1 $$$ part total polycarp analyze obtain number find number divisible $$$ 3 $$$ example original number $$$ <unknown> $$$ polycarp cut three part two cut : $$$ 3|1|21 $$$ a result get two number divisible $$$ 3 $$$ polycarp make arbitrary number vertical cut cut make a pair adjacent digits result number contain extra lead zero ( number begin 0 number exactly one character ' 0 ' ) example 007 01 <unknown> valid number 90 0 10001 valid maximum number number divisible $$$ 3 $$$ polycarp obtain ? first line input contain a positive integer $$$ s $$$ number digits number $$$ s $$$ $$$ 1 $$$ $$$ 2\cdot100000 $$$ inclusive first ( leftmost ) digit equal 0 . print maximum number number divisible $$$ 3 $$$ polycarp get make vertical cut give number $$$ s $$$ first example example set optimal cut number 3|1|21 second example need make cut specify number 6 form one number divisible $$$ 3 $$$ third example cut must make pair digits a result polycarp get one digit 1 $$$ 33 $$$ digits 0 . $$$ 33 $$$ digits 0 form a number divisible $$$ 3 $$$ fourth example example set optimal cut <unknown> number $$$ 0 $$$ $$$ 9 $$$ $$$ 201 $$$ $$$ 81 $$$ divisible $$$ 3 $$$","['dp', 'greedy']",1500.0
1006/A,mishka get integer array $$$ a $$$ length $$$ n $$$ a birthday present ( a surprise ! ) mishka n't like present want change somehow invent algorithm call ` ` mishka 's adjacent replacements algorithm '' algorithm represent a sequence step : note dot middle algorithm mean mishka apply replacements pair adjacent integers ( $$$ 2i - 1 2i $$$ ) $$$ i \in\ { 1 2 \ldots 5 \cdot <unknown> } $$$ describe example array $$$ a = [ 1 2 4 5 10 ] $$$ follow sequence array represent algorithm : $$$ [ 1 2 4 5 10 ] $$$ $$$ \rightarrow $$$ ( replace occurrences $$$ 1 $$$ $$$ 2 $$$ ) $$$ \rightarrow $$$ $$$ [ 2 2 4 5 10 ] $$$ $$$ \rightarrow $$$ ( replace occurrences $$$ 2 $$$ $$$ 1 $$$ ) $$$ \rightarrow $$$ $$$ [ 1 1 4 5 10 ] $$$ $$$ \rightarrow $$$ ( replace occurrences $$$ 3 $$$ $$$ 4 $$$ ) $$$ \rightarrow $$$ $$$ [ 1 1 4 5 10 ] $$$ $$$ \rightarrow $$$ ( replace occurrences $$$ 4 $$$ $$$ 3 $$$ ) $$$ \rightarrow $$$ $$$ [ 1 1 3 5 10 ] $$$ $$$ \rightarrow $$$ ( replace occurrences $$$ 5 $$$ $$$ 6 $$$ ) $$$ \rightarrow $$$ $$$ [ 1 1 3 6 10 ] $$$ $$$ \rightarrow $$$ ( replace occurrences $$$ 6 $$$ $$$ 5 $$$ ) $$$ \rightarrow $$$ $$$ [ 1 1 3 5 10 ] $$$ $$$ \rightarrow $$$ $$$ \dots $$$ $$$ \rightarrow $$$ $$$ [ 1 1 3 5 10 ] $$$ $$$ \rightarrow $$$ ( replace occurrences $$$ 10 $$$ $$$ 9 $$$ ) $$$ \rightarrow $$$ $$$ [ 1 1 3 5 9 ] $$$ later step algorithm change array mishka lazy n't want apply change interest result help find first line input contain one integer number $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — number elements mishka 's birthday present ( surprisingly array ) second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements array print $$$ n $$$ integers — $$$ b_1 b_2 \dots b_n $$$ $$$ b_i $$$ final value $$$ i $$$ -th element array apply ` ` mishka 's adjacent replacements algorithm '' array $$$ a $$$ note change order elements array first example describe problem statement,['implementation'],800.0
1008/A,vitya start learn berlanese language know berlanese use latin alphabet vowel letter ` ` a '' ` ` o '' ` ` u '' ` ` i '' ` ` e '' letter consonant berlanese a vowel every consonant letter vowel exception a consonant ` ` n '' ; letter letter ( a vowel ) letter example word ` ` <unknown> '' ` ` <unknown> '' ` ` man '' ` ` <unknown> '' berlanese word ` ` horse '' ` ` king '' ` ` '' ` ` <unknown> '' help vitya find a word $$$ s $$$ berlanese first line input contain string $$$ s $$$ consist $$$ |s| $$$ ( $$$ 1\leq |s|\leq 100 $$$ ) lowercase latin letter print ` ` yes '' ( without quote ) a vowel every consonant except ` ` n '' otherwise print ` ` '' print letter case ( upper lower ) first second sample a vowel go consonant except ` ` n '' word berlanese third sample consonant ` ` c '' go consonant ` ` r '' consonant ` ` s '' stand end word berlanese,['implementation'],900.0
1009/A,maxim want buy game local game shop $$$ n $$$ game shop $$$ i $$$ -th game cost $$$ c_i $$$ maxim a wallet represent array integers wallet contain $$$ m $$$ bill $$$ j $$$ -th bill value $$$ a_j $$$ game shop order leave right maxim try buy every game order maxim stand position $$$ i $$$ shop take first bill wallet ( wallet empty proceed next position immediately ) try buy $$$ i $$$ -th game use bill maxim try buy $$$ n $$$ -th game leave shop maxim buy $$$ i $$$ -th game value first bill ( take ) wallet greater equal cost $$$ i $$$ -th game successfully buy $$$ i $$$ -th game first bill wallet disappear next bill become first otherwise maxim leave first bill wallet ( bill still remain first one ) proceed next game example array $$$ c = [ 2 4 5 2 4 ] $$$ array $$$ a = [ 5 3 4 6 ] $$$ follow process take place : maxim buy first game use first bill ( value $$$ 5 $$$ ) bill disappear second bill ( value $$$ 3 $$$ ) become first one maxim 's wallet maxim n't buy second game $$$ c_2 > a_2 $$$ third game buy fourth game use bill value $$$ a_2 $$$ ( third bill become first one maxim 's wallet ) buy fifth game use bill value $$$ a_3 $$$ task get number game maxim buy first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 1000 $$$ ) — number game number bill maxim 's wallet second line input contain $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \le c_i \le 1000 $$$ ) $$$ c_i $$$ cost $$$ i $$$ -th game third line input contain $$$ m $$$ integers $$$ a_1 a_2 \dots a_m $$$ ( $$$ 1 \le a_j \le 1000 $$$ ) $$$ a_j $$$ value $$$ j $$$ -th bill maxim 's wallet print a single integer — number game maxim buy first example describe problem statement second example maxim buy game value first bill wallet smaller cost game shop third example value bill maxim 's wallet large enough buy game encounter run bill wallet,['implementation'],800.0
1009/E,"leha plan journey moscow saratov hat train decide get one city another car path moscow saratov represent a straight line ( well 's straight reality problem consider straight ) distance moscow saratov $$$ n $$$ km let 's say moscow situate point coordinate $$$ 0 $$$ km saratov — coordinate $$$ n $$$ km drive a long time may really difficult formally leha already cover $$$ i $$$ kilometers since stop a rest consider difficulty cover $$$ ( i + 1 ) $$$ -th kilometer $$$ a _ { i + 1 } $$$ guarantee every $$$ i \in [ 1 n - 1 ] $$$ $$$ a_i \le a _ { i + 1 } $$$ difficulty journey denote sum difficulties kilometer journey fortunately may rest sit moscow saratov every integer point $$$ 1 $$$ $$$ n - 1 $$$ may contain a rest site leha enter a rest site may a rest next kilometer difficulty $$$ a_1 $$$ kilometer — difficulty $$$ a_2 $$$ , example $$$ n = 5 $$$ a rest site coordinate $$$ 2 $$$ difficulty journey $$$ <unknown> + 2a_2 + a_3 $$$ : first kilometer difficulty $$$ a_1 $$$ second one — $$$ a_2 $$$ leha a rest third kilometer difficulty $$$ a_1 $$$ fourth — $$$ a_2 $$$ last one — $$$ a_3 $$$ another example : $$$ n = 7 $$$ rest sit coordinate $$$ 1 $$$ $$$ 5 $$$ difficulty leha 's journey $$$ <unknown> + 2a_2 + a_3 + a_4 $$$ leha n't know integer point contain rest sit consider every possible situation obviously $$$ 2^ { n - 1 } $$$ different distributions rest sit ( two distributions different exist point $$$ x $$$ contain a rest site exactly one distributions ) leha consider distributions equiprobable want calculate $$$ p $$$ — expect value difficulty journey obviously $$$ p \cdot 2^ { n - 1 } $$$ integer number calculate modulo $$$ 998244353 $$$ first line contain one number $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — distance moscow saratov second line contain $$$ n $$$ integer number $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_1 \le a_2 \le \dots \le a_n \le 1000000 $$$ ) $$$ a_i $$$ difficulty $$$ i $$$ -th kilometer leha rest print one number — $$$ p \cdot 2^ { n - 1 } $$$ take modulo $$$ 998244353 $$$",['math'],2000.0
1012/C,welcome innopolis city throughout whole year innopolis citizens suffer <unknown> city construction window room see sequence n hill i - th height ai innopolis administration want build house hill however sake city appearance a house build hill strictly higher neighbour hill ( present ) example sequence heights 5 4 6 2 house could build hill heights 5 6 innopolis administration excavator decrease height arbitrary hill one one hour excavator work one hill a time allow decrease hill zero height even negative value increase height hill impossible city administration want build k house must least k hill satisfy condition minimum time require adjust hill achieve administration 's plan ? however exact value k yet determine could please calculate answer k range ? denote n divide two round first line input contain integer n ( 1 ≤ n ≤ 5000 ) — the number hill sequence second line contain n integers ai ( 1 ≤ ai ≤ 100 000 ) — the heights hill sequence print exactly number separate space i - th print number equal minimum number hours require level hill become possible build i house first example get least one hill suitable construction one decrease second hill one one hour sequence heights become 1 0 1 1 1 first hill become suitable construction first example get least two least three suitable hill one decrease second fourth hill sequence heights become 1 0 1 0 1 hill 1 3 5 become suitable construction,['dp'],1900.0
1013/A,a beautiful garden stone innopolis beautiful place $$$ n $$$ pile stone number $$$ 1 $$$ $$$ n $$$ ejoi participants visit place twice first visit number stone pile $$$ x_1 x_2 \ldots x_n $$$ correspondingly one participants write sequence a notebook visit follow day number stone pile equal $$$ y_1 y_2 \ldots y_n $$$ one participants also write a notebook well know every member ejoi jury night either sit room $$$ 108 $$$ come place stone jury member come either take one stone move one stone one pile another assume unlimited number jury members one except jury go place stone night participants want know whether note correct sure make a mistake first line input file contain a single integer $$$ n $$$ number pile stone garden ( $$$ 1 \leq n \leq 50 $$$ ) second line contain $$$ n $$$ integers separate space $$$ x_1 x_2 \ldots x_n $$$ number stone pile record notebook participants come place stone first time ( $$$ 0 \leq x_i \leq 1000 $$$ ) third line contain $$$ n $$$ integers separate space $$$ y_1 y_2 \ldots y_n $$$ number stone pile record notebook participants come place stone second time ( $$$ 0 \leq y_i \leq 1000 $$$ ) record consistent output ` ` yes '' otherwise output ` ` '' ( quote clarity ) first example follow could happen night : one jury members move one stone second pile first pile jury member move one stone fourth pile third pile second example jury take stone second fourth pile prove impossible jury members move take stone convert first array second array,['math'],800.0
1015/A,give a set $$$ n $$$ segment axis $$$ ox $$$ segment integer endpoints $$$ 1 $$$ $$$ m $$$ inclusive segment may intersect overlap even coincide segment characterize two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le m $$$ ) — coordinate leave right endpoints consider integer point $$$ 1 $$$ $$$ m $$$ inclusive task print point n't belong segment point $$$ x $$$ belong segment $$$ [ l ; r ] $$$ $$$ l \le x \le r $$$ first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100 $$$ ) — number segment upper bind coordinate next $$$ n $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le m $$$ ) — endpoints $$$ i $$$ -th segment segment may intersect overlap even coincide note possible $$$ l_i = r_i $$$ i.e a segment degenerate a point first line print one integer $$$ k $$$ — number point n't belong segment second line print exactly $$$ k $$$ integers order — point n't belong segment point print distinct point print a single integer $$$ 0 $$$ first line either leave second line empty print first example point $$$ 1 $$$ belong second segment point $$$ 2 $$$ belong first second segment point $$$ 5 $$$ belong third segment point $$$ 3 $$$ $$$ 4 $$$ belong segment second example point $$$ 1 $$$ $$$ 7 $$$ belong first segment,['implementation'],800.0
1016/D,vasya take exam mathematics order get a good mark vasya need guess matrix teacher construct ! vasya know matrix consist n row m columns row know xor ( bitwise exclude ) elements row sequence a1 a2 ... denote xor elements row indices 1 2 ... n respectively similarly column know xor elements column sequence b1 b2 ... bm denote xor elements columns indices 1 2 ... m respectively help vasya ! find a matrix satisfy give constraints tell suitable matrix first line contain two number n m ( 2 ≤ n m ≤ 100 ) — dimension matrix second line contain n number a1 a2 ... ( 0 ≤ ai ≤ 109 ) ai xor elements row i. third line contain m number b1 b2 ... bm ( 0 ≤ bi ≤ 109 ) bi xor elements column i. matrix satisfy give constraints first line output ` ` '' otherwise first line output ` ` yes '' n row m number <unknown> <unknown> ... <unknown> ( 0 ≤ cij ≤ 2·109 ) — description matrix several suitable matrices allow print,['math'],1800.0
1029/A,give a string $$$ t $$$ consist $$$ n $$$ lowercase latin letter integer number $$$ k $$$ let 's define a substring string $$$ s $$$ indices $$$ l $$$ $$$ r $$$ $$$ s [ l \dots r ] $$$ task construct string $$$ s $$$ minimum possible length exactly $$$ k $$$ position $$$ i $$$ $$$ s [ i \dots i + n - 1 ] = t $$$ word task construct string $$$ s $$$ minimum possible length exactly $$$ k $$$ substrings $$$ s $$$ equal $$$ t $$$ guarantee answer always unique first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 50 $$$ ) — length string $$$ t $$$ number substrings second line input contain string $$$ t $$$ consist exactly $$$ n $$$ lowercase latin letter print string $$$ s $$$ minimum possible length exactly $$$ k $$$ substrings $$$ s $$$ equal $$$ t $$$ guarantee answer always unique,['implementation'],1300.0
1030/C,recently vasya find a golden ticket — a sequence consist $$$ n $$$ digits $$$ a_1a_2\dots a_n $$$ vasya consider a ticket lucky divide two non - intersecting segment equal sum example ticket $$$ <unknown> $$$ lucky since divide three segment $$$ <unknown> $$$ $$$ 17 $$$ $$$ 8 $$$ : $$$ 3 + 5 + 0=1 + <unknown> $$$ note digit sequence belong exactly one segment help vasya ! tell golden ticket find lucky first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — number digits ticket second line contain $$$ n $$$ digits $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 9 $$$ ) — golden ticket digits print without space golden ticket lucky print ` ` yes '' otherwise print ` ` '' ( case insensitive ) first example ticket divide $$$ 7 $$$ $$$ 34 $$$ $$$ 52 $$$ : $$$ <unknown> + 4=5 + 2 $$$ second example impossible divide ticket segment equal sum,['implementation'],1300.0
1037/B,give array $$$ a $$$ $$$ n $$$ integers integer $$$ s $$$ guarantee $$$ n $$$ odd one operation either increase decrease single element one calculate minimum number operations require make median array equal $$$ s $$$ median array odd length value element locate middle position array sort example median array $$$ 6 5 8 $$$ equal $$$ 6 $$$ since sort array get $$$ 5 6 8 $$$ $$$ 6 $$$ locate middle position first line contain two integers $$$ n $$$ $$$ s $$$ ( $$$ 1\le n\le 2\cdot 100000 - 1 $$$ $$$ 1\le s\le 1000000000 $$$ ) — length array require value median second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1\le a_i \le 1000000000 $$$ ) — elements array $$$ a $$$ guarantee $$$ n $$$ odd a single line output minimum number operations make median equal $$$ s $$$ first sample $$$ 6 $$$ increase twice array transform $$$ 8 5 8 $$$ become $$$ 5 8 8 $$$ sort hence median equal $$$ 8 $$$ second sample $$$ 19 $$$ increase $$$ 15 $$$ increase five time array become equal $$$ 21 20 12 11 20 20 12 $$$ sort array get $$$ 11 12 12 20 20 20 21 $$$ way median $$$ 20 $$$,['greedy'],1300.0
1037/C,give two binary string $$$ a $$$ $$$ b $$$ length perform follow two operations string $$$ a $$$ : find minimum cost make string $$$ a $$$ equal $$$ b $$$ allow modify string $$$ b $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — length string $$$ a $$$ $$$ b $$$ second third line contain string $$$ a $$$ $$$ b $$$ respectively string $$$ a $$$ $$$ b $$$ length $$$ n $$$ contain ' 0 ' ' 1 ' output minimum cost make string $$$ a $$$ equal $$$ b $$$ first example one optimal solutions flip index $$$ 1 $$$ index $$$ 3 $$$ string $$$ a $$$ change follow way : ` ` 100 '' $$$ \to $$$ ` ` 000 '' $$$ \to $$$ ` ` 001 '' cost $$$ 1 + 1 = 2 $$$ optimal solution swap bits indices $$$ 1 $$$ $$$ 3 $$$ string $$$ a $$$ change ` ` 100 '' $$$ \to $$$ ` ` 001 '' cost also $$$ |1 - 3| = 2 $$$ second example optimal solution swap bits indices $$$ 2 $$$ $$$ 3 $$$ string $$$ a $$$ change ` ` 0101 '' $$$ \to $$$ ` ` 0011 '' cost $$$ |2 - 3| = 1 $$$,"['dp', 'greedy']",1300.0
1038/B,find possible partition first $$$ n $$$ positive integers two non - empty disjoint set $$$ s_1 $$$ $$$ s_2 $$$ : $$$ \mathrm { sum } ( s ) $$$ denote sum elements present set $$$ s $$$ $$$ \mathrm { gcd } $$$ mean <unknown> common divisor every integer number $$$ 1 $$$ $$$ n $$$ present exactly one $$$ s_1 $$$ $$$ s_2 $$$ line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le <unknown> $$$ ) partition n't exist print ` ` '' ( quote clarity ) otherwise print ` ` yes '' ( quote clarity ) follow two line describe $$$ s_1 $$$ $$$ s_2 $$$ respectively set description start set size follow elements set order set must non - empty multiple possible partition — print first example way partition a single number two non - empty set hence answer ` ` '' second example sum set $$$ 2 $$$ $$$ 4 $$$ respectively $$$ \mathrm { gcd } ( 2 4 ) = 2 > 1 $$$ hence one possible answer,['math'],1100.0
1038/D,"$$$ n $$$ slim a row slime integer value ( possibly negative zero ) associate slime eat adjacent slime ( closest slime leave right assume slime exist ) a slime a value $$$ x $$$ eat a slime a value $$$ y $$$ eat slime disappear value remain slime change $$$ x - y $$$ slim eat one slime leave find maximum possible value last slime first line input contain integer $$$ n $$$ ( $$$ 1 \le n \le 500\,000 $$$ ) denote number slim next line contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ value $$$ i $$$ -th slime print integer — maximum possible value last slime first example a possible way get last slime value $$$ 4 $$$ : second example first slime keep eat slim right end a value $$$ 4 $$$","['dp', 'greedy', 'implementation']",1800.0
1039/C,"metropolis computer network consist $$$ n $$$ servers encryption key range $$$ 0 $$$ $$$ 2^k - 1 $$$ assign let $$$ c_i $$$ encryption key assign $$$ i $$$ -th server additionally $$$ m $$$ pair servers directly connect via a data communication channel encryption algorithms specifics a data communication channel consider safe two servers connect distinct encryption key initial assignment encryption key guarantee keep data communication channel safe inform a new virus actively spread across internet capable change encryption key server infect specifically virus body contain unknown number $$$ x $$$ aforementioned range server $$$ i $$$ infect encryption key change $$$ c_i $$$ $$$ c_i \oplus x $$$ $$$ \oplus $$$ denote bitwise xor operation sadly know neither number $$$ x $$$ servers metropolis go infect dangerous virus decide count number situations data communication channel remain safe formally speak need find number pair $$$ ( a x ) $$$ $$$ a $$$ ( possibly empty ) subset set servers $$$ x $$$ number range $$$ 0 $$$ $$$ 2^k - 1 $$$ servers choose subset $$$ a $$$ none others infect a virus contain number $$$ x $$$ data communication channel remain safe since number quite big ask find remainder modulo $$$ 1000000000 + 7 $$$ first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 500\,000 $$$ $$$ 0 \leq m \leq \min ( \frac { n ( n - 1 ) } { 2 } 500\,000 ) $$$ $$$ 0 \leq k \leq 60 $$$ ) — number servers number pair servers directly connect a data communication channel parameter $$$ k $$$ define range possible value encryption key next line contain $$$ n $$$ integers $$$ c_i $$$ ( $$$ 0 \leq c_i \leq 2^k - 1 $$$ ) $$$ i $$$ -th encryption key use $$$ i $$$ -th server next $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ u_i \ne v_i $$$ ) denote servers connect a data communication channel guarantee pair servers appear list output line contain a single integer — number safe infections subset servers a virus parameter modulo $$$ 1000000000 + 7 $$$ consider first example possible value number $$$ x $$$ contain virus $$$ 0 $$$ $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ value $$$ 0 $$$ $$$ 2 $$$ $$$ 3 $$$ virus infect subset set servers give us $$$ 16 $$$ pair value a virus contain number $$$ 1 $$$ infect either servers none give us $$$ 16 + 2 + 16 + 16 = 50 $$$ pair total",['math'],2200.0
1041/B,monocarp decide buy a new tv set hang wall flat wall enough free space monocarp buy a tv set screen width greater $$$ a $$$ screen height greater $$$ b $$$ monocarp also use tv set a certain aspect ratio : formally width screen $$$ w $$$ height screen $$$ h $$$ follow condition meet : $$$ \frac { w } { h } = \frac { x } { y } $$$ many different tv set shop monocarp sure pair positive integers $$$ w $$$ $$$ h $$$ a tv set screen width $$$ w $$$ height $$$ h $$$ shop monocarp n't ready choose exact tv set go buy firstly want determine optimal screen resolution decide try possible variants screen size must count number pair positive integers $$$ w $$$ $$$ h $$$ beforehand $$$ ( w \le a ) $$$ $$$ ( h \le b ) $$$ $$$ ( \frac { w } { h } = \frac { x } { y } ) $$$ word monocarp want determine number tv set aspect ratio $$$ \frac { x } { y } $$$ screen width exceed $$$ a $$$ screen height exceed $$$ b $$$ two tv set consider different different screen width different screen height first line contain four integers $$$ a $$$ $$$ b $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \le a b x y \le 10^ { 18 } $$$ ) — constraints screen width height aspect ratio print one integer — number different variants choose tv screen width screen height meet aforementioned constraints first example $$$ 3 $$$ possible variants : $$$ ( 5 3 ) $$$ $$$ ( 10 6 ) $$$ $$$ ( 15 9 ) $$$ second example tv set meet constraints third example one variant : $$$ ( 3 2 ) $$$,['math'],1000.0
1041/E,"monocarp draw a tree ( undirected connect acyclic graph ) give vertex index indices distinct number $$$ 1 $$$ $$$ n $$$ every edge $$$ e $$$ tree monocarp write two number : maximum indices vertices two components form edge $$$ e $$$ ( edge ) erase tree monocarp give a list $$$ n - 1 $$$ pair number want provide example a tree produce say list tree exist tree exist say first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 1\,000 $$$ ) — number vertices tree next $$$ n-1 $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i < b_i \le n $$$ ) — maximal indices vertices components form $$$ i $$$ -th edge remove tree produce give list pair print ` ` '' ( without quote ) otherwise print ` ` yes '' ( without quote ) first line edge tree next $$$ n - 1 $$$ line last $$$ n - 1 $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ ) — vertices connect edge note : numeration edge n't matter task solution consider correct tree produce pair give input file ( possibly reorder ) mean print edge tree reconstruct order possible tree first example dot line show edge need remove get appropriate pair","['data structures', 'greedy']",1900.0
1041/F,"give a tube <unknown> inside represent two non - <unknown> parallel $$$ ox $$$ line line special integer point — position sensors side tube go <unknown> a laser ray tube , choose two integer point $$$ a $$$ $$$ b $$$ first second line respectively ( coordinate negative ) : point $$$ a $$$ responsible position laser point $$$ b $$$ — direction laser ray laser ray a ray start $$$ a $$$ direct $$$ b $$$ reflect side tube ( n't matter sensors a reflection point ) a sensor register ray ray hit exactly position sensor calculate maximum number sensors register ray choose point $$$ a $$$ $$$ b $$$ first second line respectively first line contain two integers $$$ n $$$ $$$ y_1 $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 0 \le y_1 \le 1000000000 $$$ ) — number sensors first line $$$ y $$$ coordinate second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — $$$ x $$$ coordinate sensors first line ascend order third line contain two integers $$$ m $$$ $$$ y_2 $$$ ( $$$ 1 \le m \le 100000 $$$ $$$ y_1 < y_2 \le 1000000000 $$$ ) — number sensors second line $$$ y $$$ coordinate fourth line contain $$$ m $$$ integers $$$ b_1 b_2 \ldots b_m $$$ ( $$$ 0 \le b_i \le 1000000000 $$$ ) — $$$ x $$$ coordinate sensors second line ascend order print integer — maximum number sensors register ray one solutions illustrate image pair $$$ a_2 $$$ $$$ b_2 $$$","['data structures', 'dp', 'math']",2500.0
1042/C,give array $$$ a $$$ consist $$$ n $$$ integers perform follow operations : number elements decrease one operation however index position stay delete number ca n't use later operations task perform exactly $$$ n - 1 $$$ operations array a way number remain array maximum possible number rather large instead print need print sequence operations lead maximum number read output format understand exactly need print first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number elements array second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) — elements array print $$$ n - 1 $$$ line $$$ k $$$ -th line contain one two possible operations operation first type look like : $$$ 1~ <unknown> j_k $$$ $$$ 1 $$$ type operation $$$ i_k $$$ $$$ j_k $$$ position choose elements operation second type look like : $$$ 2~ i_k $$$ $$$ 2 $$$ type operation $$$ i_k $$$ position choose element note one operation multiple possible sequence operations lead maximum number — print let x remove number array let 's take a look examples : first example example follow sequence transformations array : $$$ [ 5 -2 0 1 -3 ] \to [ 5 -2 x 1 -3 ] \to [ x -10 x 1 -3 ] \to $$$ $$$ [ x x x -10 -3 ] \to [ x x x x 30 ] $$$ thus maximum answer $$$ 30 $$$ note sequence lead answer $$$ 30 $$$ also correct second example example follow sequence transformations array : $$$ [ 5 2 0 4 0 ] \to [ 5 2 x 4 0 ] \to [ 5 2 x 4 x ] \to [ x 10 x 4 x ] \to $$$ $$$ [ x x x 40 x ] $$$ follow answer also allow : sequence transformations array look like : $$$ [ 5 2 0 4 0 ] \to [ 5 2 0 4 x ] \to [ 5 8 0 x x ] \to [ 40 x 0 x x ] \to $$$ $$$ [ 40 x x x x ] $$$ third example follow sequence transformations array : $$$ [ 2 -1 ] \to [ 2 x ] $$$ fourth example follow sequence transformations array : $$$ [ 0 -10 0 0 ] \to [ x 0 0 0 ] \to [ x x 0 0 ] \to [ x x x 0 ] $$$ fifth example follow sequence transformations array : $$$ [ 0 0 0 0 ] \to [ x 0 0 0 ] \to [ x x 0 0 ] \to [ x x x 0 ] $$$,"['greedy', 'math']",1700.0
1042/F,give undirected tree consist $$$ n $$$ vertices vertex call a leaf exactly one vertex adjacent distance pair vertices number edge shortest path let 's call set leave beautiful maximum distance pair leave less equal $$$ k $$$ want split leave non - intersecting beautiful set minimal number set a split ? first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 3 \le n \le 1000000 $$$ $$$ 1 \le k \le 1000000 $$$ ) — number vertices tree maximum distance pair leave beautiful set next $$$ n - 1 $$$ line contain two integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ ) — description $$$ i $$$ -th edge guarantee give edge form a tree print a single integer — minimal number beautiful set split graph first example :,"['data structures', 'greedy']",2400.0
1043/F,"janusz a businessman own a company ` ` januszex '' produce game <unknown> last hit januszex a cool one - person game ` ` make one '' player give a sequence $$$ n $$$ integers $$$ a_i $$$ allow select subset score equal greatest common divisor select elements goal take little elements possible get score $$$ 1 $$$ janusz wonder give sequence much elements player choose ? first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 300\,000 $$$ ) — number integers sequence second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 300\,000 $$$ ) subset give sequence gcd equal $$$ 1 $$$ output -1 . otherwise output exactly one integer — size smallest subset gcd equal $$$ 1 $$$ first example select a subset number give a gcd $$$ 1 $$$ smaller subsets gcd greater $$$ 1 $$$ second example subsets number gcd least $$$ 2 $$$","['dp', 'math']",2500.0
1045/A,"year <unknown> 1000 years pass moon land meanwhile humanity <unknown> hyperspace ™ live harmony realize alone far away earth massive fleet alien ' spaceships prepare attack earth first time a humanity real danger crisis panic everywhere scientists around solar system meet discuss possible solutions however progress make earth 's last hope ! fortunately earth equip powerful defense systems make mdcs $$$ n $$$ alien ' spaceships form line defense system consist three type weapons : task make a plan attack destroy largest possible number spaceships every destroy spaceship destroy exactly one weapon first line contain two integers : number weapons $$$ n $$$ $$$ ( 1\leq n\leq 5000 ) $$$ number spaceships $$$ m $$$ $$$ ( 1\leq m\leq 5000 ) $$$ next $$$ n $$$ line line start one integer represent type ( either 0 1 2 ) type 0 weapon sql rocket rest line contain strictly positive number $$$ k $$$ $$$ ( \sum { k } \leq 100 000 ) $$$ array $$$ k_i $$$ $$$ ( 1\leq k_i\leq m ) $$$ $$$ k $$$ integers type 1 weapon cognition beam rest line contain integers $$$ l $$$ $$$ r $$$ $$$ ( 1\leq l\leq r\leq m ) $$$ type 2 weapon omg bazooka rest line contain distinct number $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ ( 1 \leq a b c \leq m ) $$$ first line contain maximum number destroy spaceships — $$$ x $$$ next $$$ x $$$ line every line contain two number $$$ a $$$ $$$ b $$$ $$$ a $$$ index weapon $$$ b $$$ index spaceship destroy weapon $$$ a $$$ sql rocket destroy 4th spaceship omg bazooka destroy two 1st 4th 5th spaceship cognition beam destroy spaceship interval $$$ [ 1,4 ] $$$ maximum number destroy spaceship 4 one possible plan sql rocket destroy 4th spaceship omg bazooka destroy 1st 5th spaceship cognition beam destroy 2nd spaceship",['data structures'],2500.0
1045/D,"intergalactic empire bubbledom $$$ n $$$ planets pair directly connect two - way wormholes $$$ n-1 $$$ wormholes wormholes extreme <unknown> importance bubbledom a set planets bubbledom consider one intergalactic kingdom two planets set reach traverse wormholes give bubbledom one kingdom word network planets wormholes a tree however bubbledom face a powerful enemy also possess teleportation technology enemy attack every night government bubbledom <unknown> planets day a single attack enemy attack every planet bubbledom planets <unknown> others planets number $$$ 0,1 … n-1 $$$ planet $$$ i $$$ fall probability $$$ p_i $$$ every night ( include first one ) government reinforce weaken <unknown> a single planet government bubbledom interest follow question : expect number intergalactic kingdoms bubbledom split a single enemy attack ( get a chance rebuild ) ? word need print expect number connect components every attack first line contain one integer number $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) denote number planets bubbledom ( number $$$ 0 $$$ $$$ n-1 $$$ ) next line contain $$$ n $$$ different real number interval $$$ [ 0,1 ] $$$ specify 2 digits decimal point denote probabilities correspond planet fall next $$$ n-1 $$$ line contain wormholes bubbledom a wormhole specify two planets connect next line contain a positive integer $$$ q $$$ ( $$$ 1 \le q \le 100000 $$$ ) denote number enemy attack next $$$ q $$$ line contain a non - negative integer a real number interval $$$ [ 0,1 ] $$$ denote planet government bubbledom decide reinforce weaken along new probability planet fall output contain $$$ q $$$ number represent expect number kingdoms leave enemy attack answer consider correct absolute relative error exceed $$$ 10^ { -4 } $$$",['math'],2200.0
1046/C,formula 1 officials decide introduce new competition cars replace space ship number point award differ per race give current rank competition point distribution next race task calculate best possible rank a give astronaut next race 's guarantee give astronaut unique number point race first line contain two integer number $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) represent number f1 astronauts current position astronaut $$$ d $$$ ( $$$ 1 \leq d \leq n $$$ ) want calculate best rank ( competitor number point race ) second line contain $$$ n $$$ integer number $$$ s_k $$$ ( $$$ 0 \leq s_k \leq 100000000 $$$ $$$ k=1 ... n $$$ ) separate a single space represent current rank astronauts point sort non - increasing order third line contain $$$ n $$$ integer number $$$ p_k $$$ ( $$$ 0 \leq p_k \leq 100000000 $$$ $$$ k=1 ... n $$$ ) separate a single space represent point award next race point sort non - increasing order winner race get maximum number point output contain one integer number — best possible rank astronaut race multiple astronauts score race share best rank third rank astronaut win race 35 point take lead position overtake second position second rank astronaut finish race last position,['greedy'],1400.0
1051/A,vasya come a password register eatforces — a string $$$ s $$$ password eatforces a string consist lowercase uppercase latin letter digits since eatforces take care security users user passwords must contain least one digit least one uppercase latin letter least one lowercase latin letter example passwords ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> m '' valid passwords ` ` qwerty '' ` ` <unknown> '' ` ` password '' a substring string $$$ s $$$ a string $$$ x = s_l s _ { l + 1 } \dots s _ { l + len - 1 } ( 1 \le l \le |s| 0 \le len \le |s| - l + 1 ) $$$ $$$ len $$$ length substring note empty string also consider a substring $$$ s $$$ length $$$ 0 $$$ vasya 's password however may come weak security settings eatforces like password want replace substring another string length order satisfy condition operation perform exactly choose string minimal possible length note length $$$ s $$$ change replacement substring string contain lowercase uppercase latin letter digits first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number testcases next $$$ t $$$ line contain initial password $$$ <unknown> ( 3 \le |s| \le 100 ) $$$ consist lowercase uppercase latin letter digits $$$ t = 1 $$$ allow hack testcase print a <unknown> password correspond give condition length replace substring calculate follow : write change position none length $$$ 0 $$$ otherwise length difference first last change position plus one example length change substring passwords ` ` abcdef '' $$$ \rightarrow $$$ ` ` <unknown> '' $$$ 4 $$$ change position $$$ 2 $$$ $$$ 5 $$$ thus $$$ ( 5 - 2 ) + 1 = 4 $$$ guarantee a password always exist several suitable passwords — output first example vasya 's password lack a digit replace substring ` ` c '' ` ` 4 '' get password ` ` <unknown> '' mean change substring length 1 . second example vasya 's password ok begin nothing change replace empty substring another empty substring ( length 0 ),"['greedy', 'implementation']",1200.0
1055/D,"alice write a program try improve readability one ways improve readability give sensible name variables alice want rename variables program <unknown> a command call ` ` massive refactoring '' replace name many variable one run use alice need select two string $$$ s $$$ $$$ t $$$ variable follow algorithm perform : variable 's name contain $$$ s $$$ a substring first ( first ) occurrence $$$ s $$$ replace $$$ t $$$ name n't contain $$$ s $$$ variable 's name stay list variables know variable initial name name alice want variable change know moreover variable lengths initial name target name equal ( otherwise alignment code could become break ) need perform rename variables exactly one run massive refactoring command determine impossible first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 3000 $$$ ) — number variables alice 's program follow $$$ n $$$ line contain initial name variables $$$ w_1 w_2 \ldots w_n $$$ one per line , $$$ n $$$ line go $$$ i $$$ -th contain target name $$$ <unknown> $$$ $$$ i $$$ -th variable guarantee $$$ 1 \le <unknown> = <unknown> \le 3000 $$$ guarantee least one variable target name different initial name initial target name consist lowercase english letter variable length initial name equal length target name impossible rename variables one call ` ` massive refactoring '' print ` ` '' ( quote clarity ) otherwise first line print ` ` yes '' ( quote clarity ) follow line print $$$ s $$$ $$$ t $$$ ( $$$ 1 \le |s| |t| \le 5000 $$$ ) use replacement string $$$ s $$$ $$$ t $$$ consist lowercase letter english alphabet multiple ways perform a ` ` massive refactoring '' use","['greedy', 'implementation']",2400.0
1055/E,a give a list integers $$$ a_1 a_2 \ldots a_n $$$ $$$ s $$$ segment $$$ [ l_j ; r_j ] $$$ ( $$$ 1 \le l_j \le r_j \le n $$$ ) need select exactly $$$ m $$$ segment a way $$$ k $$$ -th order statistic multiset $$$ a_i $$$ $$$ i $$$ contain least one segment smallest possible 's impossible select a set $$$ m $$$ segment a way multiset contain least $$$ k $$$ elements print -1 . $$$ k $$$ -th order statistic a multiset value $$$ k $$$ -th element sort multiset non - descending order first line contain four integers $$$ n $$$ $$$ s $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le m \le s \le 1500 $$$ $$$ 1 \le k \le n \le 1500 $$$ ) — size list number segment number segment choose statistic number second line contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — value number list next $$$ s $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) — endpoints segment possible segment coincide print exactly one integer — smallest possible $$$ k $$$ -th order statistic -1 's impossible choose segment a way multiset contain least $$$ k $$$ elements first example one possible solution choose first third segment together cover three elements list ( except third one ) way $$$ 2 $$$ -nd order statistic cover elements $$$ 2 $$$,['dp'],2500.0
1056/A,arkady 's morning seem straight nightmare oversleep whole morning still half - asleep get tram arrive first time leave tram realize sure line number tram ride arkady wake several time time saw tram stop stop stop know line tram stop give information help arkady determine possible line tram ? first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — number stop arkady saw next $$$ n $$$ line describe stop start a single integer $$$ r $$$ ( $$$ 1 \le r \le 100 $$$ ) — number tram line stop $$$ r $$$ distinct integers follow one $$$ 1 $$$ $$$ 100 $$$ inclusive — line number arbitrary order guarantee arkady 's information consistent i.e least one tram line arkady could take print tram line arkady could arbitrary order consider first example arkady wake three time first time saw a stop line $$$ 1 $$$ $$$ 4 $$$ $$$ 6 $$$ second time saw a stop line $$$ 1 $$$ $$$ 4 $$$ third time saw a stop line $$$ 10 $$$ $$$ 5 $$$ $$$ 6 $$$ $$$ 4 $$$ $$$ 1 $$$ a tram one two line : $$$ 1 $$$ $$$ 4 $$$,['implementation'],800.0
1056/C,"say arkady a bite old - <unknown> play checker wo n't right also a modern computer game arkady friends keen wo n't discuss rule feature important problem player pick a distinct hero begin game $$$ 2 $$$ team $$$ n $$$ players $$$ 2n $$$ heroes distribute team team take turn pick heroes : first first team choose a hero team second team choose a hero note a hero choose become unavailable team friends estimate power $$$ i $$$ -th heroes $$$ p_i $$$ team want maximize total power heroes however one exception : $$$ m $$$ pair heroes especially strong team choose a hero a pair team must choose one turn hero one pair interactive problem write a program optimally choose heroes one team jury 's program play team note jury 's program may behave <unknown> case take opportunity still maximize total power team formally ever chance reach total power $$$ q $$$ greater regardless jury 's program choices must get $$$ q $$$ greater pass a test first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 1000 $$$ $$$ 0 \le m \le n $$$ ) — number players one team number special pair heroes second line contain $$$ 2n $$$ integers $$$ p_1 p_2 \ldots p _ { 2n } $$$ ( $$$ 1 \le p_i \le 1000 $$$ ) — power heroes next $$$ m $$$ line contain two integer $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le 2n $$$ $$$ a \ne b $$$ ) — a pair heroes especially strong guarantee hero appear list next line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 2 $$$ ) — team play $$$ t = 1 $$$ first turn otherwise second turn <unknown> order hack use format describe one additional line line output $$$ 2n $$$ distinct integers $$$ 1 $$$ $$$ 2n $$$ — priority order jury 's team jury 's team turn select first possible hero list possible mean yet take contradict rule special pair heroes turn print a single integer $$$ x $$$ ( $$$ 1 \le x \le 2n $$$ ) — index hero choose note ca n't choose a hero previously choose either player must follow rule special pair heroes team 's turn read a line contain a single integer $$$ x $$$ ( $$$ 1 \le x \le 2n $$$ ) — index hero choose team guarantee index choose team also follow rule special pair heroes last turn terminate without print anything print choice forget output end line flush output otherwise get idleness limit exceed , use : jury 's answer $$$ -1 $$$ instead a valid choice mean make invalid turn exit immediately receive $$$ -1 $$$ see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream first example first turn example choose $$$ 6 $$$ team force reply $$$ 2 $$$ choose $$$ 5 $$$ team choose $$$ 4 $$$ finally choose $$$ 3 $$$ team choose $$$ 1 $$$ second example second turn team choose $$$ 6 $$$ choose $$$ 5 $$$ force team choose $$$ 1 $$$ choose $$$ 4 $$$ team choose $$$ 3 $$$ choose $$$ 2 $$$","['greedy', 'implementation']",1700.0
1056/D,one apple tree arkady 's garden represent a set junctions connect branch one way reach junctions one use branch junctions enumerate $$$ 1 $$$ $$$ n $$$ junction $$$ 1 $$$ call root a subtree a junction $$$ v $$$ a set junctions $$$ u $$$ path $$$ u $$$ root must pass $$$ v $$$ note $$$ v $$$ include a subtree $$$ v $$$ a leaf a junction subtree contain exactly one junction new year come arkady want decorate tree put a light bulb color leaf junction count number happy junctions a happy junction a junction $$$ t $$$ light bulbs subtree $$$ t $$$ different color arkady interest follow question : $$$ k $$$ $$$ 1 $$$ $$$ n $$$ minimum number different color need make number happy junctions greater equal $$$ k $$$ ? first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number junctions tree second line contain $$$ n - 1 $$$ integers $$$ p_2 $$$ $$$ p_3 $$$ ... $$$ p_n $$$ ( $$$ 1 \le p_i < i $$$ ) $$$ p_i $$$ mean a branch junctions $$$ i $$$ $$$ p_i $$$ guarantee set branch form a tree output $$$ n $$$ integers $$$ i $$$ -th minimum number color need make number happy junctions least $$$ i $$$ first example $$$ k = 1 $$$ $$$ k = 2 $$$ use one color : junctions $$$ 2 $$$ $$$ 3 $$$ happy $$$ k = 3 $$$ put bulbs different color make junctions happy second example $$$ k = 4 $$$ example put bulbs color $$$ 1 $$$ junctions $$$ 2 $$$ $$$ 4 $$$ a bulb color $$$ 2 $$$ junction $$$ 5 $$$ happy junctions ones indices $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$,"['dp', 'greedy']",1600.0
106/B,vasya choose a laptop shop n laptops taste vasya interest follow properties : processor speed ram hdd vasya a programmer a gamer interest properties three properties a laptop strictly less properties laptop first laptop consider outdated vasya among laptops vasya consider outdated choose cheapest one many laptops vasya decide write a program choose suitable laptop however vasya n't laptop yet ask help first line contain number n ( 1 ≤ n ≤ 100 ) follow n line describe a laptop speed ram hdd cost besides laptops different price print a single number — number a laptop vasya choose laptops number positive integers 1 n order give input data third sample vasya consider first fifth laptops outdated properties match third laptop fourth one cheapest among laptops leave thus vasya choose fourth laptop,['implementation'],1000.0
106/C,lavrenty a baker go make several buns stuff sell lavrenty n grams dough well m different stuff type stuff type numerate 1 m. lavrenty know ai grams leave i - th stuff take exactly bi grams stuff i ci grams dough cook a bun i - th stuff bun sell di tugriks also make buns without stuff buns require c0 grams dough sell d0 tugriks lavrenty cook number buns different stuff without unless run dough stuff lavrenty throw away excess material leave bake find maximum number tugriks lavrenty earn first line contain 4 integers n m c0 d0 ( 1 ≤ n ≤ 1000 1 ≤ m ≤ 10 1 ≤ c0 d0 ≤ 100 ) follow m line contain 4 integers i - th line contain number ai bi ci di ( 1 ≤ ai bi ci di ≤ 100 ) print number — maximum number tugriks lavrenty earn get maximum number tugriks first sample need cook 2 buns stuff 1 4 buns stuff 2 a bun without stuff second sample lavrenty cook 4 buns without stuff,['dp'],1700.0
106/D,"brave travelers reach island pirate bury treasure however ship <unknown> captain find rat eat a piece treasure map treasure map represent a rectangle n × m size cell stand islands ' square ( square 's side length equal a mile ) cells stand sea impenetrable cells penetrable ( i.e available ) contain local sight example large tree hill cave rock besides map also a set k instructions instruction follow form : '' walk n miles y direction '' possible directions : north south east west follow instructions carefully ( fulfill one one ) reach exactly place treasure bury unfortunately captain n't know place start fulfil instructions — piece map lose captain well remember place contain local sight besides captain know whole way go island 's penetrable square captain want know sight worth check ask help first line contain two integers n m ( 3 ≤ n m ≤ 1000 ) follow n line contain m integers — island map 's description ` ` # '' stand sea guarantee cells along rectangle 's perimeter sea ` ` . '' stand a penetrable square without sight sight mark uppercase latin letter ` ` a '' ` ` z '' alphabet letter use however guarantee least one present map local sight mark different letter next line contain number k ( 1 ≤ k ≤ 105 ) k line follow line describe instruction instruction possess form ` ` dir len '' dir stand direction len stand length way walk dir take value ` ` n '' ` ` s '' ` ` w '' ` ` e '' north south west east correspondingly , north top south bottom west leave east right len integer 1 1000 . print local sight satisfy instructions a string without separators alphabetical order sight fit print ` ` solution '' without quote",['implementation'],1700.0
1060/E,"sergey semyonovich a mayor a county city n use spend days nights thoughts improvements <unknown> ' live unfortunately anything everything do already possible improvements think day ( prefer sleep night ) however assistants find a solution draw imaginary city a paper sheet suggest mayor propose improvements right a map imaginary city $$$ n $$$ subway station station directly connect tunnel a way whole map a tree ( assistants short time enthusiasm ) mean exist exactly one simple path pair station call a path simple use tunnel one sergey semyonovich 's favorite quality <unknown> sum pairwise distance every pair station distance two station minimum possible number tunnel a path sergey semyonovich decide add new tunnel subway map particular connect two station $$$ u $$$ $$$ v $$$ connect a direct tunnel share a common neighbor i.e exist a station $$$ w $$$ original map a tunnel $$$ u $$$ $$$ w $$$ a tunnel $$$ w $$$ $$$ v $$$ give a task compute sum pairwise distance pair station new map first line input contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 200\,000 $$$ ) — number subway station imaginary city draw mayor 's assistants follow $$$ n - 1 $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ u_i \ne v_i $$$ ) mean station indices connect a direct tunnel guarantee $$$ n $$$ station $$$ n - 1 $$$ tunnel form a tree print one integer equal sum distance pair station sergey semyonovich draw new tunnel pair station share a common neighbor original map first sample new map pair station share a direct connection sum distance $$$ 6 $$$ second sample new map a direct tunnel pair station except pair $$$ ( 1 4 ) $$$ two station distance $$$ 2 $$$",['dp'],2000.0
1060/F,consider a tree $$$ t $$$ ( a connect graph without cycle ) $$$ n $$$ vertices label $$$ 1 $$$ $$$ n $$$ start follow process $$$ t $$$ : $$$ t $$$ one vertex follow : end process $$$ t $$$ consist a single vertex label one number $$$ 1 \ldots n $$$ number probability number become label final vertex ? first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 50 $$$ ) follow $$$ n - 1 $$$ line describe tree edge line contain two integers $$$ u_i v_i $$$ — label vertices connect respective edge ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ u_i \neq v_i $$$ ) guarantee give graph a tree print $$$ n $$$ float number — desire probabilities label $$$ 1 \ldots n $$$ respectively number correct $$$ 10^ { -6 } $$$ relative absolute precision first sample result vertex label 1 three edge label 1 survive hence probability $$$ 1/2 ^ 3 = 1/8 $$$ label equal probability due symmetry hence probability $$$ ( 1 - 1/8 ) / 3 = <unknown> $$$,['dp'],2900.0
1065/D,stumble upon a new kind chess puzzle chessboard give necesserily $$$ 8 \times 8 $$$ still $$$ n \times n $$$ square number write number $$$ 1 $$$ $$$ n^2 $$$ number pairwise distinct $$$ j $$$ -th square $$$ i $$$ -th row a number $$$ a _ { ij } $$$ write chess set three piece : a knight a bishop a rook first put one square number $$$ 1 $$$ ( choose one ) want reach square $$$ 2 $$$ ( possibly pass square process ) square $$$ 3 $$$ reach square $$$ n^2 $$$ one step allow either make a valid move current piece replace piece square visit arbitrary number time a knight move a square two square away horizontally one square vertically two square vertically one square horizontally a bishop move diagonally a rook move horizontally vertically move perform a different square one a piece currently stand want minimize number step whole traversal among paths number step want choose one lowest number piece replacements path take satisfy condition ? first line contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 10 $$$ ) — size chessboard next $$$ n $$$ line contain $$$ n $$$ integers $$$ a _ { i1 } a _ { i2 } \dots a _ { } $$$ ( $$$ 1 \le a _ { ij } \le n^2 $$$ ) — number write square $$$ i $$$ -th row board guarantee $$$ a _ { ij } $$$ pairwise distinct line contain two integers — number step best answer number replacement move step first example ( start piece a knight ) :,['dp'],2200.0
1066/A,vova plan go conference train initially train point $$$ 1 $$$ destination point path point $$$ l $$$ speed train $$$ 1 $$$ length unit per minute ( i.e first minute train point $$$ 1 $$$ second minute — point $$$ 2 $$$ ) lanterns path place point coordinate divisible $$$ v $$$ ( i.e first lantern point $$$ v $$$ second point $$$ 2v $$$ ) also exactly one stand train occupy point $$$ l $$$ $$$ r $$$ inclusive vova see lantern point $$$ p $$$ $$$ p $$$ divisible $$$ v $$$ stand train position ( $$$ p <unknown> [ l ; r ] $$$ ) thus point lantern one point cover stand train vova ca n't see lantern problem say number lanterns vova see path vova plan go $$$ t $$$ different conferences answer $$$ t $$$ independent query first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number query $$$ t $$$ line follow $$$ i $$$ -th line contain four integers $$$ l_i v_i l_i r_i $$$ ( $$$ 1 \le l v \le 1000000000 $$$ $$$ 1 \le l \le r \le l $$$ ) — destination point $$$ i $$$ -th path period lantern appearance segment occupy stand train print $$$ t $$$ line $$$ i $$$ -th line contain one integer — answer $$$ i $$$ -th query first example query answer $$$ 3 $$$ lanterns position $$$ 2 $$$ $$$ 4 $$$ $$$ 6 $$$ $$$ 8 $$$ $$$ 10 $$$ vova n't see lanterns position $$$ 4 $$$ $$$ 6 $$$ stand train second example query answer $$$ 0 $$$ lantern point $$$ 51 $$$ also a stand train point third example query answer $$$ <unknown> $$$ $$$ 1234 $$$ lanterns vova n't see lanterns position $$$ 100 $$$ position $$$ 199 $$$ inclusive fourth example query answer $$$ 0 $$$ stand train cover whole path,['math'],1100.0
1067/E,let 's define rank undirected graph rank adjacency matrix $$$ \mathbb { r } ^ { n \times n } $$$ give a tree edge tree delete probability $$$ 1/2 $$$ deletions independent let $$$ e $$$ expect rank result forest find $$$ e \cdot 2^ { n-1 } $$$ modulo $$$ 998244353 $$$ ( easy show $$$ e \cdot 2^ { n-1 } $$$ integer ) first line input contain $$$ n $$$ ( $$$ 1 \le n \le 5 \cdot 10^ { 5 } $$$ ) — number vertices next $$$ n-1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u \ \ v \le n ; \ \ u \ne v $$$ ) — indices vertices connect edge guarantee give graph a tree print one integer — answer problem,"['dp', 'math']",2800.0
1070/B,berkomnadzor — federal service supervision communications information technology mass media — a berland federal <unknown> body protect ordinary residents berland <unknown> modern internet berkomnadzor maintain a list prohibit ipv4 subnets ( blacklist ) a list allow ipv4 subnets ( whitelist ) internet service <unknown> ( isps ) berland must configure network equipment block access ipv4 address match blacklist also isps must provide access ( block ) ipv4 address match whitelist ipv4 address match either list 's <unknown> decide whether block ipv4 address match blacklist ( whitelist ) match subnet blacklist ( whitelist ) ipv4 address belong a whitelist a blacklist time situation lead a contradiction ( see solution case output description ) ipv4 address a 32 - bit unsigned integer write form $$$ a.b.c.d $$$ value $$$ a b c d $$$ call octet integer $$$ 0 $$$ $$$ 255 $$$ write decimal notation example ipv4 address $$$ <unknown> $$$ convert a 32 - bit number use follow expression $$$ 192 \cdot 2^ { 24 } + <unknown> \cdot 2^ { 16 } + 0 \cdot 2 ^ 8 + 1 \cdot 2 ^ 0 $$$ first octet $$$ a $$$ encode significant ( leftmost ) $$$ 8 $$$ bits <unknown> $$$ b $$$ $$$ c $$$ — follow block $$$ 8 $$$ bits ( order ) octet $$$ d $$$ encode least significant ( rightmost ) $$$ 8 $$$ bits ipv4 network berland slightly different rest world reserve internal address berland use $$$ 2^ { 32 } $$$ possible value ipv4 subnet represent either $$$ a.b.c.d $$$ $$$ a.b.c.d / x $$$ ( $$$ 0 \le x \le 32 $$$ ) a subnet $$$ a.b.c.d $$$ contain a single address $$$ a.b.c.d $$$ a subnet $$$ a.b.c.d / x $$$ contain ipv4 address $$$ x $$$ leftmost ( significant ) bits equal $$$ x $$$ leftmost bits address $$$ a.b.c.d $$$ require $$$ 32 - x $$$ rightmost ( least significant ) bits subnet $$$ a.b.c.d / x $$$ zero naturally happen address match subnet $$$ a.b.c.d / x $$$ form a continuous range range start address $$$ a.b.c.d $$$ ( rightmost $$$ 32 - x $$$ bits zero ) range end address $$$ x $$$ leftmost bits equal $$$ x $$$ leftmost bits address $$$ a.b.c.d $$$ $$$ 32 - x $$$ rightmost bits ones subnet contain exactly $$$ 2^ { 32 - x } $$$ address subnet $$$ a.b.c.d/32 $$$ contain exactly one address also represent $$$ a.b.c.d $$$ example subnet $$$ <unknown> $$$ contain range 256 address $$$ <unknown> $$$ first address range $$$ <unknown> $$$ last one berkomnadzor 's engineer devise a plan improve performance berland 's global network instead maintain whitelist blacklist want build a single optimise blacklist contain minimal number subnets idea block ipv4 address match optimise blacklist allow rest address course ipv4 address old blacklist must remain block ipv4 address old whitelist must still allow ipv4 address match neither old blacklist old whitelist may either block allow regardless accessibility please write a program take blacklist whitelist input produce optimise blacklist optimise blacklist must contain minimal possible number subnets satisfy ipv4 address accessibility requirements mention ipv4 subnets source list may intersect arbitrarily please output a single number -1 ipv4 address match source whitelist blacklist first line input contain single integer $$$ n $$$ ( $$$ 1 \le n \le 2\cdot100000 $$$ ) — total number ipv4 subnets input follow $$$ n $$$ line contain ipv4 subnets line start either ' - ' ' + ' sign indicate subnet belong blacklist whitelist correspondingly follow without space ipv4 subnet $$$ a.b.c.d $$$ $$$ a.b.c.d / x $$$ format ( $$$ 0 \le x \le 32 $$$ ) blacklist always contain least one subnet ipv4 subnets give input valid integer number start extra lead zero provide ipv4 subnets intersect arbitrarily output -1 ipv4 address match whitelist blacklist otherwise output $$$ t $$$ — length optimise blacklist follow $$$ t $$$ subnets subnet a new line subnets may print arbitrary order address match source blacklist must match optimise blacklist address match source whitelist must match optimise blacklist print a subnet $$$ a.b.c.d/32 $$$ two ways : $$$ a.b.c.d/32 $$$ $$$ a.b.c.d $$$ one solution output,"['data structures', 'greedy']",2400.0
1070/H,"polycarp work a new operate system call beros ask help implementation a file suggestion feature $$$ n $$$ file hard drive name $$$ f_1 f_2 \dots f_n $$$ file name contain $$$ 1 $$$ $$$ 8 $$$ character inclusive file name unique file suggestion feature handle query represent a string $$$ s $$$ query $$$ s $$$ count number file contain $$$ s $$$ a substring ( i.e continuous segment character a file name equal $$$ s $$$ ) suggest file name example file name ` ` read.me '' ` ` host '' ` ` <unknown> '' ` ` beros.18 '' query ` ` os '' number match file $$$ 2 $$$ ( two file name contain ` ` os '' a substring ) suggest file name either ` ` host '' ` ` beros.18 '' first line input contain integer $$$ n $$$ ( $$$ 1 \le n \le 10000 $$$ ) — total number file follow $$$ n $$$ line contain file name one per line $$$ i $$$ -th line contain $$$ f_i $$$ — name $$$ i $$$ -th file file name contain $$$ 1 $$$ $$$ 8 $$$ character inclusive file name contain lowercase latin letter digits dot character ( ' . ' ) sequence valid character a file name ( example beros ` ` ` ` ` ` .. '' ` ` ... '' valid file name ) file name unique follow line contain integer $$$ q $$$ ( $$$ 1 \le q \le 50000 $$$ ) — total number query follow $$$ q $$$ line contain query $$$ s_1 s_2 \dots <unknown> $$$ one per line $$$ s_j $$$ length $$$ 1 $$$ $$$ 8 $$$ character inclusive contain lowercase latin letter digits dot character ( ' . ' ) print $$$ q $$$ line one per query $$$ j $$$ -th line contain response $$$ j $$$ -th query — two value $$$ c_j $$$ $$$ t_j $$$ ,",['implementation'],1500.0
1070/K,polycarp take $$$ n $$$ videos duration $$$ i $$$ -th video $$$ a_i $$$ second videos list chronological order i.e $$$ 1 $$$ -st video earliest $$$ 2 $$$ -nd video next ... $$$ n $$$ -th video last polycarp want publish exactly $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) post <unknown> video a part a single post post preserve chronological order mean first post contain one earliest videos second post contain a block ( one videos ) go next word number videos $$$ j $$$ -th post $$$ s_j $$$ : polycarp a perfectionist want total duration videos post help polycarp find positive integer value $$$ s_1 s_2 \dots s_k $$$ satisfy condition first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 100000 $$$ ) next line contain $$$ n $$$ positive integer number $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 10000 $$$ ) $$$ a_i $$$ duration $$$ i $$$ -th video solution exist print ` ` yes '' first line print $$$ k $$$ positive integers $$$ s_1 s_2 \dots s_k $$$ ( $$$ <unknown> = n $$$ ) second line total duration videos post easily prove answer unique ( exist ) solution print a single line ` ` '',['implementation'],1100.0
1073/A,give a string $$$ s $$$ consist $$$ n $$$ lowercase latin letter a substring string $$$ s $$$ a continuous segment letter $$$ s $$$ example ` ` <unknown> '' a substring ` ` codeforces '' ` ` <unknown> '' length substring number letter let 's call string length $$$ n $$$ diverse letter appear strictly $$$ \frac n 2 $$$ time example string ` ` abc '' ` ` <unknown> '' diverse string ` ` aab '' ` ` zz '' task find diverse substring string $$$ s $$$ report none note require maximize minimize length result substring first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — length string $$$ s $$$ second line string $$$ s $$$ consist exactly $$$ n $$$ lowercase latin letter print ` ` '' diverse substring string $$$ s $$$ otherwise first line contain ` ` yes '' second line contain diverse substring string $$$ s $$$ first example lot correct answer please <unknown> ask specific answer correct specific test question always lead ` ` comment '' answer,['implementation'],1000.0
1075/A,"a chessboard a width $$$ n $$$ a height $$$ n $$$ row number bottom top $$$ 1 $$$ $$$ n $$$ columns number leave right $$$ 1 $$$ $$$ n $$$ therefore cell chessboard assign coordinate $$$ ( r c ) $$$ $$$ r $$$ number row $$$ c $$$ number column white king sit a cell $$$ ( 1,1 ) $$$ coordinate a thousand years black king sit a cell $$$ ( n n ) $$$ coordinate would sit like suddenly a beautiful coin fell cell coordinate $$$ ( x y ) $$$ ... <unknown> want get decide arrange a race accord slightly change chess rule : chess white king make first move black king make second one white king make third one , however problem kings stand adjacent cells even cell time player reach coin first win say player reach cell coordinate $$$ ( x y ) $$$ first win let 's recall king a chess piece move one cell directions , king $$$ ( a b ) $$$ cell one move move $$$ ( a b ) $$$ cells $$$ ( a + 1 b ) $$$ $$$ ( a - 1 b ) $$$ $$$ ( a b + 1 ) $$$ $$$ ( a b - 1 ) $$$ $$$ ( a + 1 b - 1 ) $$$ $$$ ( a + 1 b + 1 ) $$$ $$$ ( a - 1 b - 1 ) $$$ $$$ ( a - 1 b + 1 ) $$$ go outside field prohibit determine color king reach cell coordinate $$$ ( x y ) $$$ first white king move first first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 10^ { 18 } $$$ ) — length side chess field second line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ ) — coordinate cell coin fell a single line print answer ` ` white '' ( without quote ) white king win ` ` black '' ( without quote ) black king win print letter case ( upper lower ) example race first sample white king black king move optimally : example race second sample white king black king move optimally : third example coin fell start cell black king black king immediately win","['implementation', 'math']",800.0
1076/C,try guess statement picture : give a non - negative integer $$$ d $$$ find two non - negative real number $$$ a $$$ $$$ b $$$ $$$ a + b = d $$$ $$$ a \cdot b = d $$$ first line contain $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case contain one integer $$$ d $$$ $$$ ( 0 \le d \le 1000 ) $$$ test print one line answer $$$ i $$$ -th test print ` ` y '' number $$$ a $$$ $$$ b $$$ answer $$$ i $$$ -th test print ` ` n '' answer consider correct $$$ | ( a + b ) - a \cdot b| \le 10^ { -6 } $$$ $$$ | ( a + b ) - d| \le 10^ { -6 } $$$,['math'],1300.0
1076/F,vova take summer practice year write a report go vova already draw table write formulas moreover already decide report consist exactly $$$ n $$$ page $$$ i $$$ -th page include $$$ x_i $$$ table $$$ y_i $$$ formulas page number $$$ 1 $$$ $$$ n $$$ vova fill page one another ca n't go fill page $$$ i + 1 $$$ finish page $$$ i $$$ ca n't skip page however draw strictly $$$ k $$$ table a row write strictly $$$ k $$$ formulas a row get bore vova want rearrange table formulas page a way n't get bore process vova ca n't move table formula another page note count n't reset start new page example page end $$$ 3 $$$ table next page start $$$ 5 $$$ table 's count $$$ 8 $$$ table a row help vova determine rearrange table formulas page a way $$$ k $$$ table a row $$$ k $$$ formulas a row first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 300000 $$$ $$$ 1 \le k \le 1000000 $$$ ) second line contain $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ 1 \le x_i \le 1000000 $$$ ) — number table $$$ i $$$ -th page third line contain $$$ n $$$ integers $$$ y_1 y_2 \dots y_n $$$ ( $$$ 1 \le y_i \le 1000000 $$$ ) — number formulas $$$ i $$$ -th page print ` ` yes '' vova rearrange table formulas page a way $$$ k $$$ table a row $$$ k $$$ formulas a row otherwise print ` ` '' first example option rearrange everything follow ( let table ' t ' formula ' f ' ) : way block table length $$$ 2 $$$ second example way fit everything a way $$$ 2 $$$ table a row $$$ 2 $$$ formulas a row,"['dp', 'greedy']",2500.0
1080/B,little girl margarita a big fan competitive program especially love problems array query recently present array $$$ a $$$ size $$$ 1000000000 $$$ elements fill follow : value $$$ i $$$ -th element array $$$ a $$$ calculate use formula $$$ a_i = i \cdot ( -1 ) ^i $$$ immediately come $$$ q $$$ query array query describe two number : $$$ l $$$ $$$ r $$$ answer a query sum elements array position $$$ l $$$ $$$ r $$$ inclusive margarita really want know answer request n't want count manually unfortunately could n't write program solve problem either turn — best programmer help find answer ! first line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 1000 $$$ ) — number query next $$$ q $$$ line contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \le l \le r \le 1000000000 $$$ ) — descriptions query print $$$ q $$$ line contain one number — answer query first query need find sum elements array position $$$ 1 $$$ position $$$ 3 $$$ sum equal $$$ a_1 + a_2 + a_3 = -1 + 2 -3 = -2 $$$ second query need find sum elements array position $$$ 2 $$$ position $$$ 5 $$$ sum equal $$$ a_2 + a_3 + a_4 + a_5 = 2 -3 + 4 - 5 = -2 $$$ third query need find sum elements array position $$$ 5 $$$ position $$$ 5 $$$ sum equal $$$ a_5 = -5 $$$ fourth query need find sum elements array position $$$ 4 $$$ position $$$ 4 $$$ sum equal $$$ a_4 = 4 $$$ fifth query need find sum elements array position $$$ 2 $$$ position $$$ 3 $$$ sum equal $$$ a_2 + a_3 = 2 - 3 = -1 $$$,['math'],900.0
1081/F,"interactive problem chouti tire study open computer start play a puzzle game long long ago boy find a sequence $$$ s_1 s_2 \ldots s_n $$$ length $$$ n $$$ keep a tricky interactor consist $$$ 0 $$$ s $$$ 1 $$$ s number $$$ 1 $$$ s $$$ t $$$ boy know nothing sequence except $$$ n $$$ $$$ t $$$ try find query interactor define operation call flip flip $$$ [ l r ] $$$ ( $$$ 1 \leq l \leq r \leq n $$$ ) mean $$$ x \in [ l r ] $$$ change $$$ s_x $$$ $$$ 1 - s_x $$$ query boy give interactor two integers $$$ l r $$$ satisfy $$$ 1 \leq l \leq r \leq n $$$ interactor either flip $$$ [ 1 r ] $$$ $$$ [ l n ] $$$ ( outcomes probability decisions make interactor independent see note section detail ) interactor tell current number $$$ 1 $$$ s operation note sequence wo n't restore operation help boy find original sequence $$$ 10000 $$$ interactions ` ` weird legend dumb game . '' think however several try still stick help beat game ? interaction start a line contain two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \leq n \leq 300 $$$ $$$ 0 \leq t \leq n $$$ ) — length sequence number $$$ 1 $$$ s , make query make a query print a line ` ` ? l r '' ( $$$ 1 \leq l \leq r \leq n $$$ ) flush output query read a single integer $$$ t $$$ ( $$$ -1 \leq t \leq n $$$ ) find original sequence print a line ` ` ! s '' flush output terminate print $$$ s_1 s_2 \ldots s_n $$$ a binary string print space solution get idleness limit exceed n't print anything forget flush output flush need follow right print a query a line end : hacksfor hack use follow format : first line print a non - empty binary string length $$$ n $$$ treat $$$ s_1 s_2 \ldots s_n $$$ example test correspond example contain a line ` ` 0011 '' first query $$$ 1,1 $$$ interactor flip $$$ [ 1,1 ] $$$ $$$ [ 1,4 ] $$$ choose flip $$$ [ 1,4 ] $$$ sequence become 1100 . second query $$$ 1,1 $$$ interactor flip $$$ [ 1,1 ] $$$ $$$ [ 1,4 ] $$$ choose flip $$$ [ 1,4 ] $$$ sequence become 0011 . third query $$$ 3,4 $$$ interactor flip $$$ [ 1,4 ] $$$ $$$ [ 3,4 ] $$$ choose flip $$$ [ 3,4 ] $$$ sequence become 0000 . q : interactor choose $$$ [ 1 r ] $$$ $$$ [ l n ] $$$ ? really random ? a : interactor use a secret pseudorandom number generator $$$ s $$$ query hash use seed give sequence query twice secret string get result except consider choices fully random like flip a fair coin need n't ( n't ) exploit exact generator pass problem",['implementation'],2600.0
1088/C,'re give array $$$ a $$$ length $$$ n $$$ perform follow operations : make array strictly increase $$$ n+1 $$$ operations ? first line contain integer $$$ n $$$ $$$ ( 1 \le n \le 2000 ) $$$ number elements array $$$ a $$$ second line contain $$$ n $$$ space - separated integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \dots $$$ $$$ a_n $$$ $$$ ( 0 \le a_i \le 100000 ) $$$ elements array $$$ a $$$ first line print number operations wish perform next line print operations print add operation use format ` ` $$$ 1 $$$ $$$ i $$$ $$$ x $$$ ` ` ; print a <unknown> operation use format ` ` $$$ 2 $$$ $$$ i $$$ $$$ x $$$ ` ` $$$ i $$$ $$$ x $$$ n't satisfy limitations use $$$ n+1 $$$ operations 'll get wrong answer verdict first sample array already increase n't need operations second sample : first step : array become $$$ [ <unknown> ] $$$ second step : array become $$$ [ <unknown> ] $$$,"['greedy', 'math']",1400.0
1089/G,"berland state university invite people world guest students come capital berland study best teachers country berland state university work every day week class guest students hold follow schedule know sequence seven integers $$$ a_1 a_2 \dots a_7 $$$ ( $$$ a_i = 0 $$$ $$$ a_i = 1 $$$ ) : class guest students hold least one day a week want visit capital berland spend minimum number days study $$$ k $$$ days a guest student berland state university write a program find length shortest continuous period days stay capital study exactly $$$ k $$$ days a guest student first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10\,000 $$$ ) — number test case process test case independently solve problem print answer test case consist two line first contain integer $$$ k $$$ ( $$$ 1 \le k \le 100000000 $$$ ) — require number days study a guest student second line contain exactly seven integers $$$ a_1 a_2 \dots a_7 $$$ ( $$$ a_i = 0 $$$ $$$ a_i = 1 $$$ ) $$$ a_i=1 $$$ class guest students hold $$$ i $$$ -th day a week print $$$ t $$$ line $$$ i $$$ -th line contain answer $$$ i $$$ -th test case — length shortest continuous period days need stay study exactly $$$ k $$$ days a guest student first test case must arrive capital berland monday class day spend a week next monday class next monday total need spend $$$ 8 $$$ days capital berland",['math'],1500.0
1089/K,king <unknown> get annoy usual <unknown> knight — break hall without prior notice ! thus king decide build a reception a queue knight choose advance time come long visit take knight serve order record time knight wait visit knight finish princess keabeanie want see father however want interrupt knight join queue unfortunately knight change mind often — join queue cancel visit please help princess understand long wait see father enter queue specify moments time give record reception first line input contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 300000 $$$ ) — number events event three type : join cancel query guarantee event two knight entrance time queue cancel events refer previous join cancel yet keabeanie come time knight keabeanie polite wait knight pass query write a separate line amount time keabeanie wait,['data structures'],2400.0
109/A,petya love lucky number know lucky number positive integers whose decimal representations contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 petya wonder eagerly minimum lucky number sum digits equal n. help cope task single line contain integer n ( 1 ≤ n ≤ 106 ) — sum digits require lucky number print single line result — minimum lucky number whose sum digits equal n. number exist print -1,['implementation'],1000.0
109/C,"petya love lucky number know lucky number positive integers whose decimal representations contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 one day petya encounter a tree n vertexes besides tree weight i. e. edge tree weight ( a positive integer ) edge lucky weight a lucky number note a tree n vertexes undirected connect graph exactly n - 1 edge petya wonder many vertex triple ( i j k ) exist way i j well way i k must least one lucky edge ( three vertexes pairwise distinct ) order number triple matter , triple ( 1 2 3 ) equal triple ( 2 1 3 ) equal triple ( 1 3 2 ) find many triple vertexes exist first line contain single integer n ( 1 ≤ n ≤ 105 ) — number tree vertexes next n - 1 line contain three integers : ui vi wi ( 1 ≤ ui vi ≤ n 1 ≤ wi ≤ 109 ) — pair vertexes connect edge edge 's weight single line print single number — answer please use % lld specificator read write 64 - bit number с++ recommend use cin cout stream % i64d specificator 16 triple vertexes first sample : ( 1 2 4 ) ( 1 4 2 ) ( 2 1 3 ) ( 2 1 4 ) ( 2 3 1 ) ( 2 3 4 ) ( 2 4 1 ) ( 2 4 3 ) ( 3 2 4 ) ( 3 4 2 ) ( 4 1 2 ) ( 4 1 3 ) ( 4 2 1 ) ( 4 2 3 ) ( 4 3 1 ) ( 4 3 2 ) second sample triple count : <unknown> = 24",['dp'],1900.0
1090/M,"$$$ n $$$ house along road anya live one paint one $$$ k $$$ possible color anya like walk along road n't like two adjacent house road color want select a long segment road two adjacent house color help anya find longest segment property first line contain two integers $$$ n $$$ $$$ k $$$ — number house number color ( $$$ 1 \le n \le 100\,000 $$$ $$$ 1 \le k \le 100\,000 $$$ ) next line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ — color house along road ( $$$ 1 \le a_i \le k $$$ ) output a single integer — maximum number house road segment two adjacent house color example longest segment without neighbor house color house 4 house 7 . color house $$$ [ 3 2 1 2 ] $$$ length 4 house",['implementation'],1000.0
1091/C,"$$$ n $$$ people sit a circle number $$$ 1 $$$ $$$ n $$$ order seat , $$$ i $$$ $$$ 1 $$$ $$$ n-1 $$$ people i d $$$ i $$$ $$$ i+1 $$$ adjacent people i d $$$ n $$$ $$$ 1 $$$ adjacent well person i d $$$ 1 $$$ initially a ball pick a positive integer $$$ k $$$ $$$ n $$$ pass ball $$$ k $$$ -th neighbour direction increase ids person pass ball $$$ k $$$ -th neighbour direction person i d $$$ 1 $$$ get ball back get back people pass ball instance $$$ n = 6 $$$ $$$ k = 4 $$$ ball pass order $$$ [ 1 5 3 1 ] $$$ consider set people touch ball fun value game sum ids people touch example fun value would $$$ 1 + 5 + 3 = 9 $$$ find report set possible fun value choices positive integer $$$ k $$$ show constraints problem ball always get back $$$ 1 $$$ -st player finitely many step $$$ 100000 $$$ possible fun value give $$$ n $$$ line consist a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 1000000000 $$$ ) — number people play ball suppose set fun value $$$ f_1 f_2 \dots f_m $$$ output a single line contain $$$ m $$$ space separate integers $$$ f_1 $$$ $$$ f_m $$$ increase order first sample ' ve already show pick $$$ k = 4 $$$ yield fun value $$$ 9 $$$ $$$ k = 2 $$$ pick $$$ k = 6 $$$ result fun value $$$ 1 $$$ $$$ k = 3 $$$ get fun value $$$ 5 $$$ $$$ k = 1 $$$ $$$ k = 5 $$$ get $$$ 21 $$$ second sample value $$$ 1 $$$ $$$ 10 $$$ $$$ 28 $$$ $$$ 64 $$$ $$$ <unknown> $$$ achieve instance $$$ k = 16 $$$ $$$ 8 $$$ $$$ 4 $$$ $$$ 10 $$$ $$$ 11 $$$ respectively",['math'],1400.0
1093/C,mishka try really hard avoid kick university particular absolutely nothing whole semester miraculously pass exams one leave $$$ n $$$ class subject semester $$$ i $$$ -th class professor mention non - negative integer $$$ a_i $$$ students turn exam tell whole sequence back professor sound easy enough attend every class n't ? obviously mishka n't attend class however professor leave clue value $$$ a $$$ help students like mishka : professor also mention sequence $$$ a $$$ produce sequence $$$ b $$$ present technique acceptable help mishka pass last exam restore sort sequence $$$ a $$$ non - negative integers produce sequence $$$ b $$$ present technique guarantee exist least one correct sequence $$$ a $$$ produce give sequence $$$ b $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — length sequence $$$ a $$$ $$$ n $$$ always even second line contain $$$ \frac n 2 $$$ integers $$$ b_1 b_2 \dots b _ { \frac n 2 } $$$ ( $$$ 0 \le b_i \le 10^ { 18 } $$$ ) — sequence $$$ b $$$ $$$ b_i = a_i + a _ { n - i + 1 } $$$ guarantee exist least one correct sequence $$$ a $$$ produce give sequence $$$ b $$$ print $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 10^ { 18 } $$$ ) a single line $$$ a_1 \le a_2 \le \dots \le a_n $$$ satisfy $$$ b_i = a_i + a _ { n - i + 1 } $$$ satisfy valid $$$ i $$$,['greedy'],1300.0
1095/A,polycarp love cipher invent cipher call repeat repeat cipher use string encrypt string $$$ s = s _ { 1 } s _ { 2 } \dots s _ { m } $$$ ( $$$ 1 \le m \le 10 $$$ ) polycarp use follow algorithm : example $$$ s $$$ = '' bab '' process : ` ` b '' $$$ \to $$$ ` ` baa '' $$$ \to $$$ ` ` baabbb '' encrypt $$$ s $$$ = '' bab '' ` ` baabbb '' give string $$$ t $$$ — result encryption string $$$ s $$$ task decrypt i. e. find string $$$ s $$$ first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 55 $$$ ) — length encrypt string second line input contain $$$ t $$$ — result encryption string $$$ s $$$ contain lowercase latin letter length $$$ t $$$ exactly $$$ n $$$ guarantee answer test exist print string $$$ s $$$ encryption equal $$$ t $$$,['implementation'],800.0
1096/D,"vasya prepare a contest write a statement easy problem statement a string length $$$ n $$$ consist lowercase latin <unknown> vasya think statement consider hard contain a subsequence hard ; otherwise statement easy example hard <unknown> <unknown> consider hard statements <unknown> <unknown> <unknown> easy statements vasya n't want statement hard may remove character statement order make easy , course part statement crucial understand initially ambiguity statement $$$ 0 $$$ remove $$$ i $$$ -th character increase ambiguity $$$ a_i $$$ ( index character consider original statement , example delete character r hard character d index d still $$$ 4 $$$ even though delete string ) vasya want calculate minimum ambiguity statement remove character ( possibly zero ) statement easy help ! recall subsequence a sequence derive another sequence delete elements without change order remain elements first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length statement second line contain one string $$$ s $$$ length $$$ n $$$ consist lowercase latin letter — statement write vasya third line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 998244353 $$$ ) print minimum possible ambiguity statement vasya delete ( possibly zero ) character result statement easy first example first two character remove result <unknown> second example $$$ 5 $$$ -th character remove result <unknown> third example 's need remove anything",['dp'],1800.0
1098/D,"vasya a big fish lover parent give aquarium new year vasya a degree <unknown> think fill a new aquarium eels a good idea unfortunately eels <unknown> vasya decide find dangerous idea get one aquarium eels fight exactly one fish remain two eels fight big one eat smaller one ( weight equal one still eat ) namely let $$$ n $$$ eels initially aquarium $$$ i $$$ -th a weight $$$ x_i $$$ $$$ n-1 $$$ battle occur a result one eel survive a battle two eels weight $$$ a $$$ $$$ b $$$ $$$ a \le b $$$ eel weight $$$ a $$$ eat disappear aquarium eel weight $$$ b $$$ increase weight $$$ a+b $$$ a battle two eels weight $$$ a $$$ $$$ b $$$ $$$ a \le b $$$ consider dangerous $$$ b \le 2 a $$$ a give set eels danger define maximum number dangerous battle occur among eels place one aquarium vasya plan eels want put aquarium set eels ( initially empty ) make a series operations set operation either add one eel set remove one eel set vasya ask calculate danger current set eels operation first line input contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 500\,000 $$$ ) number operations vasya make next $$$ q $$$ line describe operations operation one two type : operation output single integer danger set eels operation third example perform operations set eels look like $$$ \ { 1 1 4\ } $$$ set eels several possible scenarios place one aquarium : thus danger set eels 2",['data structures'],2800.0
1099/B,little sofia fourth grade today geometry lesson learn segment square way home decide draw $$$ n $$$ square snow a side length $$$ 1 $$$ simplicity assume sofia live a plane draw segment length $$$ 1 $$$ parallel coordinate ax vertices integer point order draw a segment sofia proceed follow want draw a vertical segment coordinate end $$$ ( x y ) $$$ $$$ ( x y+1 ) $$$ sofia look already a draw segment coordinate end $$$ ( x ' y ) $$$ $$$ ( x ' y+1 ) $$$ $$$ x ' $$$ a segment exist sofia quickly draw a new segment use old one a guideline segment sofia take a ruler measure a new segment a long time thing happen sofia want draw a horizontal segment check existence a segment coordinate $$$ x $$$ $$$ x+1 $$$ differ coordinate $$$ y $$$ example sofia need draw one square draw two segment use a ruler : draw remain two segment use first two a guide : sofia need draw two square draw three segment use a ruler : draw remain four segment use first three a guide : sofia a hurry want minimize number segment draw a ruler without a guide help find minimum number line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 10^ { 9 } $$$ ) number square sofia want draw print single integer minimum number segment sofia draw a ruler without a guide order draw $$$ n $$$ square manner describe,['math'],1100.0
11/C,give a 0 - 1 rectangular matrix number square ? a square a solid square frame ( border ) <unknown> equal 1 . a square least 2 × 2 . interest two type square : regardless type a square must contain least one 1 ca n't touch ( side corner ) foreign 1 . course lengths side square equal many square give matrix ? first line contain integer t ( 1 ≤ t ≤ 10000 ) t number test case input test case follow case start a line contain integers n m ( 2 ≤ n m ≤ 250 ) n number row m number columns follow n line contain m character ( 0 1 ) total number character test case n't exceed 106 input file output exactly t line answer i - th test case i - th line,['implementation'],2200.0
1101/B,"accordion a string ( yes real world accordions musical instrument let 's forget a ) represent a concatenation : open bracket ( ascii code $$$ <unknown> $$$ ) a colon ( ascii code $$$ <unknown> $$$ ) ( possibly zero ) vertical line character ( ascii code $$$ 124 $$$ ) another colon a close bracket ( ascii code $$$ <unknown> $$$ ) length accordion number character example [ : : ] [ : || : ] [ : <unknown> : ] accordions length $$$ 4 $$$ $$$ 6 $$$ $$$ 7 $$$ ( : | : ) { : || : } [ : ] ] : || : [ accordions give a string $$$ s $$$ want transform accordion remove ( possibly zero ) character note may insert new character reorder exist ones possible obtain accordion remove character $$$ s $$$ , maximum possible length result ? line contain one string $$$ s $$$ ( $$$ 1 \le |s| \le 500000 $$$ ) consist lowercase latin letter character [ ] : | possible obtain accordion remove character $$$ s $$$ print $$$ -1 $$$ otherwise print maximum possible length result accordion","['greedy', 'implementation']",1300.0
1103/E,"let 's define radix sum number $$$ a $$$ consist digits $$$ a_1 \ldots a_k $$$ number $$$ b $$$ consist digits $$$ b_1 \ldots b_k $$$ ( add lead zero shorter number match longer length ) number $$$ s ( a b ) $$$ consist digits $$$ ( a_1+b_1 ) \mod 10 \ldots ( <unknown> ) \mod 10 $$$ radix sum several integers define follow : $$$ s ( t_1 \ldots t_n ) = s ( t_1 s ( t_2 \ldots t_n ) ) $$$ give array $$$ x_1 \ldots x_n $$$ task compute integer $$$ i ( 0 \le i < n ) $$$ number ways consequently choose one integers array $$$ n $$$ time radix sum integers equal $$$ i $$$ calculate value modulo $$$ 2^ { 58 } $$$ first line contain integer $$$ n $$$ — length array ( $$$ 1 \leq n \leq 100000 $$$ ) second line contain $$$ n $$$ integers $$$ x_1 \ldots x_n $$$ — array elements ( $$$ 0 \leq x_i < 100000 $$$ ) output $$$ n $$$ integers $$$ y_0 \ldots y _ { n-1 } $$$ — $$$ y_i $$$ equal correspond number ways modulo $$$ 2^ { 58 } $$$ first example exist sequence : sequence $$$ ( 5,5 ) $$$ radix sum $$$ 0 $$$ sequence $$$ ( 5,6 ) $$$ radix sum $$$ 1 $$$ sequence $$$ ( 6,5 ) $$$ radix sum $$$ 1 $$$ sequence $$$ ( 6,6 ) $$$ radix sum $$$ 2 $$$",['math'],3400.0
1104/B,"two people play a game a string $$$ s $$$ consist lowercase latin letter a player 's turn choose two consecutive equal letter string delete example string equal ` ` <unknown> '' one possible turn : delete ` ` aa '' string become ` ` xx '' a player able make a turn lose task determine player win play optimally line contain string $$$ s $$$ consist lowercase latin letter ( $$$ 1 \leq |s| \leq 100\,000 $$$ ) $$$ |s| $$$ mean length a string $$$ s $$$ first player win print ` ` yes '' second player win print ` ` '' first example first player unable make a turn lose second example first player turn string ` ` q '' second player unable move lose","['data structures', 'implementation', 'math']",1200.0
1106/A,lunar new year approach buy a matrix lot ` ` cross '' matrix $$$ m $$$ size $$$ n \times n $$$ contain ' x ' ' . ' ( without quote ) element $$$ i $$$ -th row $$$ j $$$ -th column $$$ ( i j ) $$$ define $$$ m ( i j ) $$$ $$$ 1 \leq i j \leq n $$$ define a cross appear $$$ i $$$ -th row $$$ j $$$ -th column ( $$$ 1 < i j < n $$$ ) $$$ m ( i j ) = m ( i - 1 j - 1 ) = m ( i - 1 j + 1 ) = m ( i + 1 j - 1 ) = m ( i + 1 j + 1 ) = $$$ ' x ' follow figure illustrate a cross appear position $$$ ( 2 2 ) $$$ a $$$ 3 \times 3 $$$ matrix task find number cross give matrix $$$ m $$$ two cross different appear different row columns first line contain one positive integer $$$ n $$$ ( $$$ 1 \leq n \leq 500 $$$ ) denote size matrix $$$ m $$$ follow $$$ n $$$ line illustrate matrix $$$ m $$$ line contain exactly $$$ n $$$ character ' x ' ' . ' $$$ j $$$ -th element $$$ i $$$ -th line represent $$$ m ( i j ) $$$ $$$ 1 \leq i j \leq n $$$ output a single line contain one integer number $$$ k $$$ — number cross give matrix $$$ m $$$ first sample a cross appear $$$ ( 3 3 ) $$$ answer $$$ 1 $$$ second sample cross appear since $$$ n < 3 $$$ answer $$$ 0 $$$ third sample cross appear $$$ ( 3 2 ) $$$ $$$ ( 3 4 ) $$$ $$$ ( 4 3 ) $$$ $$$ ( 4 5 ) $$$ answer $$$ 4 $$$,['implementation'],800.0
1108/C,a garland consist $$$ n $$$ lamps lamp color red green blue color $$$ i $$$ -th lamp $$$ s_i $$$ ( ' r ' ' g ' ' b ' — color lamps garland ) recolor lamps garland ( recoloring a lamp mean change initial color another ) a way obtain garland nice a garland call nice two lamps color distance divisible three i.e obtain garland $$$ t $$$ $$$ i j $$$ $$$ t_i = t_j $$$ satisfy $$$ |i - <unknown> mod~ 3 = 0 $$$ value $$$ |x| $$$ mean absolute value $$$ x $$$ operation $$$ <unknown> mod~ y $$$ mean remainder $$$ x $$$ divide $$$ y $$$ example follow garland nice : ` ` <unknown> '' ` ` gb '' ` ` r '' ` ` <unknown> '' ` ` <unknown> '' follow garland nice : ` ` rr '' ` ` <unknown> '' among ways recolor initial garland make nice choose one minimum number recolored lamps multiple optimal solutions print first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number lamps second line input contain string $$$ s $$$ consist $$$ n $$$ character ' r ' ' g ' ' b ' — color lamps garland first line output print one integer $$$ r $$$ — minimum number recolors need obtain a nice garland give one second line output print one string $$$ t $$$ length $$$ n $$$ — a nice garland obtain initial one minimum number recolors multiple optimal solutions print,"['greedy', 'math']",1300.0
1108/D,a garland consist $$$ n $$$ lamps lamp color red green blue color $$$ i $$$ -th lamp $$$ s_i $$$ ( ' r ' ' g ' ' b ' — color lamps garland ) recolor lamps garland ( recoloring a lamp mean change initial color another ) a way obtain garland diverse a garland call diverse two adjacent ( consecutive ) lamps ( i. e. lamps distance position $$$ 1 $$$ ) distinct color word obtain garland $$$ t $$$ $$$ i $$$ $$$ 1 $$$ $$$ n-1 $$$ condition $$$ t_i \ne t _ { i + 1 } $$$ satisfy among ways recolor initial garland make diverse choose one minimum number recolored lamps multiple optimal solutions print first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number lamps second line input contain string $$$ s $$$ consist $$$ n $$$ character ' r ' ' g ' ' b ' — color lamps garland first line output print one integer $$$ r $$$ — minimum number recolors need obtain a diverse garland give one second line output print one string $$$ t $$$ length $$$ n $$$ — a diverse garland obtain initial one minimum number recolors multiple optimal solutions print,"['dp', 'greedy']",1400.0
1108/F,give undirected weight connect graph $$$ n $$$ vertices $$$ m $$$ edge without loop multiple edge $$$ i $$$ -th edge $$$ e_i = ( u_i v_i w_i ) $$$ ; distance vertices $$$ u_i $$$ $$$ v_i $$$ along edge $$$ e_i $$$ $$$ w_i $$$ ( $$$ 1 \le w_i $$$ ) graph connect i. e. pair vertices least one path consist edge give graph a minimum span tree ( mst ) case positive weight a subset edge a connect weight undirected graph connect vertices together minimum total cost among subsets ( total cost sum cost choose edge ) modify give graph operation perform follow : increase weight edge $$$ 1 $$$ increase weight edge multiple ( possibly zero ) time suppose initial mst cost $$$ k $$$ problem increase weight edge minimum possible number operations a way cost mst obtain graph remain $$$ k $$$ mst unique ( mean one way choose mst obtain graph ) problem calculate minimum number operations require first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 2 \cdot 100000 n - 1 \le m \le 200000 $$$ ) — number vertices number edge initial graph next $$$ m $$$ line contain three integers $$$ i $$$ -th line contain description $$$ i $$$ -th edge $$$ e_i $$$ denote three integers $$$ u_i v_i $$$ $$$ w_i $$$ ( $$$ 1 \le u_i v_i \le n u_i \ne v_i 1 \le w \le 1000000000 $$$ ) $$$ u_i $$$ $$$ v_i $$$ vertices connect $$$ i $$$ -th edge $$$ w_i $$$ weight edge guarantee give graph n't contain loop multiple edge ( i.e $$$ i $$$ $$$ 1 $$$ $$$ m $$$ $$$ u_i \ne v_i $$$ unordered pair vertices $$$ ( u v ) $$$ one edge connect pair vertices ) also guarantee give graph connect print one integer — minimum number operations unify mst initial graph without change cost mst picture correspond first example : example increase weight edge $$$ ( 1 6 ) $$$ $$$ ( 6 3 ) $$$ $$$ 1 $$$ unify mst picture correspond last example : example increase weight edge $$$ ( 1 5 ) $$$ $$$ ( 2 4 ) $$$ $$$ 1 $$$ unify mst,['greedy'],2100.0
1109/A,"sasha like program , a long contest sasha decide a bite tire need relax   since sasha n't ordinary guy prefer relax <unknown> <unknown> time sasha like upsolve unsolved problems <unknown> useful therefore sasha decide upsolve follow problem : array $$$ a $$$ $$$ n $$$ integers need count number funny pair $$$ ( l r ) $$$ $$$ ( l \leq r ) $$$ check a pair $$$ ( l r ) $$$ a funny pair take $$$ mid = \frac { l + r - 1 } { 2 } $$$ $$$ r - l + 1 $$$ even number $$$ a_l \oplus a _ { l+1 } \oplus \ldots \oplus a _ { mid } = a _ { mid + 1 } \oplus a _ { mid + 2 } \oplus \ldots \oplus a_r $$$ pair funny word $$$ \oplus $$$ elements leave half subarray $$$ l $$$ $$$ r $$$ equal $$$ \oplus $$$ elements right half note $$$ \oplus $$$ denote bitwise xor operation time continue solve contest sasha ask solve task first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 300000 $$$ ) — size array second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i < 2^ { 20 } $$$ ) — array print one integer — number funny pair consider pair $$$ r - l + 1 $$$ even number cool sasha upsolve problems ! first example funny pair $$$ ( 2 5 ) $$$ $$$ 2 \oplus 3 = 4 \oplus 5 = 1 $$$ second example funny pair $$$ ( 2 3 ) $$$ $$$ ( 1 4 ) $$$ $$$ ( 3 6 ) $$$ third example funny pair","['dp', 'implementation']",1600.0
1109/D,", a lesson sasha get bore decide talk friends suddenly saw kefa since talk endlessly kefa wo n't even start conversation turn graph kefa promise sasha tell one interest fact graph theory sasha help kefa count number beautiful tree task a tree a weight connect graph consist $$$ n $$$ vertices $$$ n-1 $$$ edge weight edge integers $$$ 1 $$$ $$$ m $$$ kefa determine beauty a tree follow : find tree two favorite vertices — vertices number $$$ a $$$ $$$ b $$$ count distance distance two vertices $$$ x $$$ $$$ y $$$ sum weight edge simple path $$$ x $$$ $$$ y $$$ distance two vertices $$$ a $$$ $$$ b $$$ equal $$$ m $$$ tree beautiful sasha like graph theory even sasha like interest facts 's agree help kefa luckily sasha familiar best programmer byteland help sasha count number beautiful tree kefa two tree consider distinct edge occur one n't occur one edge 's weight matter kefa warn sasha many beautiful tree enough count number modulo $$$ 1000000000 + 7 $$$ first line contain four integers $$$ n $$$ $$$ m $$$ $$$ a $$$ $$$ b $$$ ( $$$ 2 \le n \le 1000000 $$$ $$$ 1 \le m \le 1000000 $$$ $$$ 1 \le a b \le n $$$ $$$ a \neq b $$$ ) — number vertices tree maximum weight edge two kefa 's favorite vertices print one integer — number beautiful tree modulo $$$ 1000000000 + 7 $$$ $$$ 5 $$$ beautiful tree first example : second example follow tree beautiful :","['dp', 'math']",2400.0
111/A,"little petya love inequations help find n positive integers a1 a2 ... , follow two condition satisfy : first line contain three space - separated integers n x y ( 1 ≤ n ≤ 105 1 ≤ x ≤ 1012 1 ≤ y ≤ 106 ) please use % lld specificator read write 64 - bit integers с++ recommend use cin cout stream % i64d specificator print n positive integers satisfy condition one integer per line number exist print a single number ` ` -1 '' several solutions print",['greedy'],1400.0
1111/A,know a superhero transform certain superheroes superheroes transform superhero a superhero name $$$ s $$$ transform another superhero name $$$ t $$$ $$$ s $$$ make equal $$$ t $$$ change vowel $$$ s $$$ vowel consonant $$$ s $$$ consonant multiple change make problem consider letter ' a ' ' e ' ' i ' ' o ' ' u ' vowels letter consonants give name two superheroes determine superhero name $$$ s $$$ transform superhero name $$$ t $$$ first line contain string $$$ s $$$ length $$$ 1 $$$ $$$ 1000 $$$ inclusive second line contain string $$$ t $$$ length $$$ 1 $$$ $$$ 1000 $$$ inclusive string $$$ s $$$ $$$ t $$$ guarantee different consist lowercase english letter output ` ` yes '' ( without quote ) superhero name $$$ s $$$ transform superhero name $$$ t $$$ ` ` '' ( without quote ) otherwise print letter case ( upper lower ) first sample since ' a ' ' u ' vowels possible convert string $$$ s $$$ $$$ t $$$ third sample ' k ' a consonant whereas ' a ' a vowel possible convert string $$$ s $$$ $$$ t $$$,['implementation'],1000.0
1111/B,every superhero give a power value felicity committee avengers crew want maximize average power superheroes team perform certain operations initially $$$ n $$$ superheroes avengers team power $$$ a_1 a_2 \ldots a_n $$$ respectively one operation remove one superhero team ( least two ) increase power a superhero $$$ 1 $$$ $$$ m $$$ operations also a particular superhero $$$ k $$$ operations do help avengers team maximize average power crew ? first line contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \le n \le 10^ { 5 } $$$ $$$ 1 \le k \le 10^ { 5 } $$$ $$$ 1 \le m \le 10^ { 7 } $$$ ) — number superheroes maximum number time increase power a particular superhero total maximum number operations second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 10^ { 6 } $$$ ) — initial power superheroes cast avengers output a single number — maximum final average power answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -6 } $$$ first example maximum average obtain delete first element increase second element four time second sample one ways achieve maximum average delete first third element increase second fourth elements $$$ 2 $$$,"['implementation', 'math']",1700.0
1111/D,a colony villains several hole align a row hole contain exactly one villain colony arrangement express a string even length $$$ i $$$ -th character string represent type villain $$$ i $$$ -th hole iron man destroy a colony colony arrangement villains a certain type either live first half colony second half colony assistant jarvis a special power swap villains two hole i.e swap two character string ; operation number time iron man ask jarvis $$$ q $$$ question question give jarvis two number $$$ x $$$ $$$ y $$$ jarvis tell iron man number distinct colony arrangements create original one use power villains type originally live $$$ x $$$ -th hole $$$ y $$$ -th hole live half iron man destroy colony arrangement two colony arrangements consider different exist a hole different type villains present hole arrangements first line contain a string $$$ s $$$ ( $$$ 2 \le |s| \le 10^ { 5 } $$$ ) represent initial colony arrangement string $$$ s $$$ lowercase uppercase english letter length even second line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 10^ { 5 } $$$ ) — number question $$$ i $$$ -th next $$$ q $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le |s| $$$ $$$ x_i \ne y_i $$$ ) — two number give jarvis $$$ i $$$ -th question question output number arrangements possible modulo $$$ 1000000000 + 7 $$$ consider first example first question possible arrangements ` ` aabb '' ` ` bbaa '' second question index $$$ 1 $$$ contain ' a ' index $$$ 2 $$$ contain ' b ' valid arrangement ' a ' ' b ' half,"['dp', 'math']",2600.0
1117/D,reziba many magic gems magic gem split $$$ m $$$ normal gems amount space magic ( normal ) gem take $$$ 1 $$$ unit a normal gem split reziba want choose a set magic gems split total space occupy result set gems $$$ n $$$ units a magic gem choose split take $$$ m $$$ units space ( since split $$$ m $$$ gems ) ; a magic gem split take $$$ 1 $$$ unit many different configurations result set gems reziba total amount space take $$$ n $$$ units ? print answer modulo $$$ 1000000007 $$$ ( $$$ 1000000000 + 7 $$$ ) two configurations consider different number magic gems reziba take form differ indices gems reziba split differ input contain a single line consist $$$ 2 $$$ integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 10^ { 18 } $$$ $$$ 2 \le m \le 100 $$$ ) print one integer total number configurations result set gems give total amount space take $$$ n $$$ units print answer modulo $$$ 1000000007 $$$ ( $$$ 1000000000 + 7 $$$ ) first example magic gem split $$$ 2 $$$ normal gems know total amount gems $$$ 4 $$$ let $$$ 1 $$$ denote a magic gem $$$ 0 $$$ denote a normal gem total configurations : hence answer $$$ 5 $$$,"['dp', 'math']",2100.0
1118/C,let 's call square matrix integer value cells palindromic n't change order row reverse n't change order columns reverse example follow matrices palindromic : follow matrices palindromic change order row reverse : follow matrices palindromic change order columns reverse : give $$$ n^2 $$$ integers put a matrix $$$ n $$$ row $$$ n $$$ columns number use exactly cell contain exactly one number result matrix palindromic multiple answer print solution print ` ` '' first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 20 $$$ ) second line contain $$$ n^2 $$$ integers $$$ a_1 a_2 \dots a _ { n^2 } $$$ ( $$$ 1 \le a_i \le 1000 $$$ ) — number put a matrix $$$ n $$$ row $$$ n $$$ columns possible put $$$ n^2 $$$ number a matrix $$$ n $$$ row $$$ n $$$ columns number use exactly cell contain exactly one number result matrix palindromic print ` ` yes '' print $$$ n $$$ line $$$ n $$$ space - separated number — result matrix 's impossible construct matrix print ` ` '' print letter case ( upper lower ) example ` ` yes '' ` ` '' ` ` yes '' acceptable note exist multiple answer first two examples,['implementation'],1700.0
1118/E,king berland organize a ball ! $$$ n $$$ pair invite ball number $$$ 1 $$$ $$$ n $$$ pair consist one man one woman dancer ( either man woman ) a monochrome costume color costume represent integer $$$ 1 $$$ $$$ k $$$ inclusive let $$$ b_i $$$ color man 's costume $$$ g_i $$$ color woman 's costume $$$ i $$$ -th pair choose a color dancer 's costume ( i.e value $$$ b_1 b_2 \dots b_n $$$ $$$ g_1 g_2 \dots g_n $$$ ) a way : let 's take a look examples bad good color choose ( $$$ n=4 $$$ $$$ k=3 $$$ man first a pair woman second ) : bad color choose : good color choose : find suitable color choose say suitable choose exist line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n k \le 200000 $$$ ) — number pair number color impossible find suitable color choose print ` ` '' otherwise print ` ` yes '' color costume pair next $$$ n $$$ line $$$ i $$$ -th line contain two integers $$$ b_i $$$ $$$ g_i $$$ — color costume man woman $$$ i $$$ -th pair respectively print letter case ( upper lower ) example ` ` yes '' ` ` '' ` ` yes '' acceptable,['implementation'],1700.0
1119/B,alyona recently buy a <unknown> fridge represent a matrix $$$ h $$$ row $$$ 2 $$$ columns initially one shelf bottom fridge alyona install arbitrary number shelve inside fridge two row a shelf two cells wide occupy space separate inside fridge lower upper part alyona $$$ n $$$ bottle milk want put fridge $$$ i $$$ -th bottle $$$ a_i $$$ cells tall $$$ 1 $$$ cell wide put a bottle shelf correspond space shelf least tall bottle put a bottle top another bottle ( shelf ) two bottle share a cell alyona interest largest integer $$$ k $$$ put bottle $$$ 1 $$$ $$$ 2 $$$ ... $$$ k $$$ fridge time find largest $$$ k $$$ first line contain two integers $$$ n $$$ $$$ h $$$ ( $$$ 1 \le n \le 1000 $$$ $$$ 1 \le h \le 1000000000 $$$ ) — number bottle height fridge second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le h $$$ ) — heights bottle print single integer $$$ k $$$ — maximum integer alyona put bottle $$$ 1 $$$ $$$ 2 $$$ ... $$$ k $$$ fridge time alyona put bottle fridge print $$$ n $$$ easy see alyona always put least one bottle fridge one optimal locations first example show picture statement one optimal locations second example show picture one optimal locations third example show picture,['greedy'],1300.0
1119/G,recently evlampy instal one interest computer game one aspects split army several group fight enemy 's group let us consider a simplify version battle nearest battle evlampy fight enemy army consist $$$ m $$$ group $$$ i $$$ -th $$$ hp_i $$$ health point evlampy 's army consist $$$ n $$$ equal soldier battle split army exactly $$$ m $$$ group ( possibly empty ) total size group $$$ n $$$ battle play step - by - step step evlampy 's group attack exactly one enemy group thus step describe array $$$ m $$$ integers $$$ a_1 a_2 \ldots a_m $$$ mean $$$ i $$$ -th evlampy 's group attack $$$ a_i $$$ -th enemy group different group attack group step array $$$ a $$$ choose independently step health point enemy group decrease total number soldier evlampy 's group attack enemy group step enemy group destroy health point zero negative evlampy 's soldier lose health evlampy understand upcoming battle take whole night become sad way wo n't enough time finish homework evlampy want write a program help win smallest possible number step help ? word find smallest number step need destroy enemy group show a possible way find require split army $$$ m $$$ group array $$$ a $$$ step first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq m \leq n \leq 10^ { 6 } $$$ ) — number soldier evlampy 's army number group enemy army $$$ m $$$ also equal maximum possible number group evlampy split army second line contain $$$ m $$$ integers $$$ <unknown> <unknown> \ldots <unknown> $$$ ( $$$ 1 \leq hp_i \leq 10^ { 6 } $$$ ) — health point enemy group guarantee sum $$$ hp_i $$$ exceed $$$ 10^ { 6 } $$$ print a single integer $$$ t $$$ — minimum possible number step need win battle print $$$ m $$$ integers $$$ s_1 s_2 \ldots s_m $$$ ( $$$ s_i \ge 0 $$$ $$$ s_1 + s_2 + \ldots + s_m = n $$$ ) mean $$$ i $$$ -th group evlampy 's army contain $$$ s_i $$$ soldier next $$$ t $$$ line print $$$ m $$$ integers $$$ a_1 a_2 \ldots a_m $$$ ( $$$ 1 \le a_i \le m $$$ ) — description one step integers mean correspond step $$$ i $$$ -th evlampy 's group attack $$$ a_i $$$ -th enemy group allow attack already destroy group first example show,['implementation'],3100.0
1121/C,"vasya like take part codeforces contest a round vasya follow submissions system test tab $$$ n $$$ solutions $$$ i $$$ -th test $$$ a_i $$$ test test one solution one test take $$$ 1 $$$ second solutions judge order $$$ 1 $$$ $$$ n $$$ $$$ k $$$ test process test solutions simultaneously test one solution a time time moment $$$ t $$$ test process judge solution take first solution queue test test increase order test ids let solution i d $$$ i $$$ test first test time moment $$$ t $$$ till time moment $$$ t + 1 $$$ second test till time moment $$$ t + 2 $$$ solution fully test time moment $$$ t + a_i $$$ test process immediately start test another solution consider time moment let exactly $$$ m $$$ fully test solutions moment a caption ` ` system test : $$$ d $$$ % '' page solutions $$$ d $$$ calculate $$$ $$$ d = <unknown> ( <unknown> { m } { n } \right ) $$$ $$$ $$$ round ( x ) = \lfloor { x + 0.5 } \rfloor $$$ a function map every real nearest integer vasya call a submission interest a time moment ( possibly non - integer ) solution test test $$$ q $$$ caption say ` ` system test : $$$ q $$$ % '' find number interest solutions please note case multiple process attempt take first submission queue moment ( instance initial moment ) order take solutions matter first line contain two positive integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 1000 $$$ $$$ 1 \le k \le 100 $$$ ) stand number submissions number test process respectively second line contain $$$ n $$$ positive integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 150 $$$ ) $$$ a_i $$$ equal number test $$$ i $$$ -th submission run output integer — number interest submissions consider first example time moment $$$ 0 $$$ solutions start test time moment $$$ 49 $$$ first solution fully test time moment $$$ <unknown> $$$ second solution test test $$$ 50 $$$ caption say ` ` system test : $$$ 50 $$$ % '' ( one fully test solution two ) , second solution interest consider second example time moment $$$ 0 $$$ first second solutions start test time moment $$$ 32 $$$ first solution fully test third solution start test caption say ` ` system test : $$$ 25 $$$ % '' time moment $$$ 32 + <unknown> = <unknown> $$$ third solutions test test $$$ 25 $$$ caption still thus solution interest third solution fully test time moment $$$ 32 + 33 = 65 $$$ fourth solution fully test time moment $$$ 65 + 1 = 66 $$$ caption become ` ` system test : $$$ 75 $$$ % '' time moment $$$ <unknown> $$$ second solution test test $$$ 75 $$$ , solution also interest overall two interest solutions",['implementation'],1600.0
1129/C,"morse code letter english alphabet represent a string length $$$ 1 $$$ $$$ 4 $$$ moreover morse code representation english letter contain dot dash task represent a dot a ` ` 0 '' a dash a ` ` 1 '' $$$ 2 ^ 1 + 2 ^ 2 + 2 ^ 3 + 2 ^ 4 = 30 $$$ string length $$$ 1 $$$ $$$ 4 $$$ contain ` ` 0 '' and/or ` ` 1 '' correspond one $$$ 26 $$$ english letter particular string ` ` 0 '' and/or ` ` 1 '' length $$$ 4 $$$ translate a distinct english letter except follow four string correspond english alphabet : ` ` 0011 '' ` ` 0101 '' ` ` 1110 '' ` ` 1111 '' work a string $$$ s $$$ initially empty $$$ m $$$ time either a dot a dash append $$$ s $$$ one a time task find report modifications string $$$ s $$$ number non - empty sequence english letter represent substring $$$ s $$$ morse code since answer incredibly <unknown> print modulo $$$ 1000000000 + 7 $$$ first line contain integer $$$ m $$$ ( $$$ 1 \leq m \leq 3\,000 $$$ ) — number modifications $$$ s $$$ next $$$ m $$$ line contain either a ` ` 0 '' ( represent a dot ) a ` ` 1 '' ( represent a dash ) specify character append $$$ s $$$ print $$$ m $$$ line $$$ i $$$ -th answer $$$ i $$$ -th modification $$$ s $$$ let us consider first sample character append $$$ s $$$ s ` ` 111 '' see ` ` 1 '' ` ` 11 '' ` ` 111 '' correspond distinct english letter fact translate a ' t ' ' m ' ' o ' respectively non - empty sequence english letter represent substring $$$ s $$$ morse code therefore follow although unnecessary task a conversion table english alphabets morse code find","['data structures', 'dp']",2400.0
1131/G,"semyon participate prestigious competition world ocean title dangerous shark competition shark compete different subject : speed swim mask map navigation many others semyon take part « destruction » contest , $$$ m $$$ dominoes place front shark dominoes line height dominoes may vary distance adjacent dominoes $$$ 1 $$$ moreover domino cost value express integer goal drop dominoes , shark push domino leave right begin fall direction fall domino touch dominoes also start fall direction original domino fall thus begin a chain reaction a result many dominoes fall a fall domino touch another one distance strictly less height fall domino dominoes necessarily adjacent course shark easily drop dominoes way goal drop dominoes a minimum cost cost destruction sum cost dominoes shark need push make dominoes fall simon already previous subject smart enough win one help semyon determine minimum total cost dominoes push make dominoes fall order reduce input size heights cost dominoes describe block first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 250\,000 1 \leq m \leq 10000000 $$$ ) — number block total number dominoes semyon must drop descriptions $$$ n $$$ block follow description every block consist three line first line block 's description contain a single integer $$$ k_i $$$ ( $$$ 1 \leq k_i \leq 250\,000 \sum _ { i = 1 } ^ { n } { k_i } \leq 250\,000 $$$ ) — number dominoes block second line block 's description contain $$$ k_i $$$ integers $$$ a_j $$$ ( $$$ 1 \leq a_j \leq m $$$ ) — heights dominoes block third line contain $$$ k_i $$$ integers $$$ c_j $$$ ( $$$ 1 \leq c_j \leq 100\,000 $$$ ) — cost dominoes block domino sequence describe ( leave right ) first line description contain a single integer $$$ q $$$ ( $$$ n \leq q \leq 250\,000 $$$ ) — number block sequence domino sequence follow $$$ q $$$ line contain integers $$$ id_i mul_i $$$ ( $$$ 1 \leq id_i \leq n $$$ $$$ 1 \leq mul_i \leq 100\,000 $$$ ) denote next $$$ k _ { id_i } $$$ dominoes dominoes block $$$ id_i $$$ cost multiply $$$ mul_i $$$ 's guarantee $$$ \sum _ { i = 1 } ^ { q } { k _ { id_i } } = m $$$ 's every block use sequence least print exactly one integer — minimum cost make dominoes fall first example $$$ 7 $$$ dominoes front semyon heights equal $$$ [ 3 1 2 2 1 2 2 ] $$$ cost equal $$$ [ 4 3 6 3 1 2 1 ] $$$ semyon drop domino index $$$ 7 $$$ leave fall drop domino $$$ 6 $$$ well domino $$$ 6 $$$ fall drop domino $$$ 5 $$$ however latter drop dominoes semyon drop domino number $$$ 1 $$$ right drop dominoes $$$ 2 $$$ $$$ 3 $$$ fall domino $$$ 3 $$$ drop domino $$$ 4 $$$ fall hence dominoes fall way second example a single domino cost $$$ 10000000000 $$$","['data structures', 'dp']",2700.0
1132/E,a set items integer weight greater $$$ 8 $$$ denote a subset items good total weight items subset exceed $$$ w $$$ want calculate maximum possible weight a good subset items note consider empty set original set calculate answer first line contain one integer $$$ w $$$ ( $$$ 0 \le w \le 10^ { 18 } $$$ ) — maximum total weight a good subset second line denote set items contain $$$ 8 $$$ integers $$$ cnt_1 $$$ $$$ cnt_2 $$$ ... $$$ <unknown> $$$ ( $$$ 0 \le cnt_i \le 10^ { 16 } $$$ ) $$$ cnt_i $$$ number items weight $$$ i $$$ set print one integer — maximum possible weight a good subset items,"['dp', 'greedy']",2300.0
1132/F,give a string $$$ s $$$ length $$$ n $$$ consist lowercase latin letter may apply operations string : one operation delete contiguous substring string letter substring delete equal example delete substring bbbb string <unknown> get string <unknown> calculate minimum number operations delete whole string $$$ s $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500 $$$ ) — length string $$$ s $$$ second line contain string $$$ s $$$ ( $$$ |s| = n $$$ ) consist lowercase latin letter output a single integer — minimal number operation delete string $$$ s $$$,['dp'],2000.0
1137/C,"country $$$ n $$$ $$$ n $$$ cities connect $$$ m $$$ one - way roads although country seem <unknown> two interest facts first a week last $$$ d $$$ days second exactly one museum city country $$$ n $$$ travel agency ` ` open museums '' develop a new program tourists interest museums agency 's employees know days museums open tour start capital — city number $$$ 1 $$$ first day tour must first day a week day a tourist city watch exposition museum ( case museum open today ) end day tour either end tourist go another city connect a road current one road system $$$ n $$$ design a way travel a road always take one night also roads one - way 's allow visit a city multiple time trip develop route trip number distinct museums possible visit maximum first line contain three integers $$$ n $$$ $$$ m $$$ $$$ d $$$ ( $$$ 1 \leq n \leq 100\,000 $$$ $$$ 0 \leq m \leq 100\,000 $$$ $$$ 1 \leq d \leq 50 $$$ ) number cities number roads number days a week next $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) denote a one - way road city $$$ u_i $$$ city $$$ v_i $$$ next $$$ n $$$ line contain museums ' schedule schedule museum locate $$$ i $$$ -th city describe $$$ i $$$ -th line line consist exactly $$$ d $$$ character ` ` 0 '' ` ` 1 '' $$$ j $$$ -th character string equal ` ` 1 '' museum open $$$ j $$$ -th day a week ` ` 0 '' otherwise 's guarantee pair cities $$$ ( u v ) $$$ exist one road lead $$$ u $$$ $$$ v $$$ print a single integer — maximum number distinct museums 's possible visit start a trip first city first day week maximum number distinct museums visit $$$ 3 $$$ 's possible visit $$$ 3 $$$ museums example way describe maximum number distinct museums visit $$$ 2 $$$ 's possible visit $$$ 2 $$$ museums example way describe","['dp', 'implementation']",2500.0
1138/B,"polycarp a head a circus troupe $$$ n $$$ — even number — artists troupe know whether $$$ i $$$ -th artist perform a clown ( yes $$$ c_i = 1 $$$ otherwise $$$ c_i = 0 $$$ ) whether perform acrobat ( yes $$$ a_i = 1 $$$ otherwise $$$ a_i = 0 $$$ ) split artists two performances a way : first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 5\,000 $$$ $$$ n $$$ even ) — number artists troupe second line contain $$$ n $$$ digits $$$ c_1 c_2 \ldots c_n $$$ $$$ i $$$ -th equal $$$ 1 $$$ $$$ i $$$ -th artist perform a clown $$$ 0 $$$ otherwise third line contain $$$ n $$$ digits $$$ a_1 a_2 \ldots a_n $$$ $$$ i $$$ -th equal $$$ 1 $$$ $$$ i $$$ -th artist perform acrobat $$$ 0 $$$ otherwise print $$$ \frac { n } { 2 } $$$ distinct integers — indices artists play first performance multiple answer print solution print a single integer $$$ -1 $$$ first example one possible divisions two performances follow : first performance artists $$$ 1 $$$ $$$ 4 $$$ take part number artists first performance perform clown equal $$$ 1 $$$ number artists second performance perform acrobats $$$ 1 $$$ well second example division possible third example one possible divisions follow : first performance artists $$$ 3 $$$ $$$ 4 $$$ take part first performance $$$ 2 $$$ artists perform clown number artists second performance perform acrobats $$$ 2 $$$ well","['greedy', 'math']",1800.0
1139/C,give a tree ( a connect undirected graph without cycle ) $$$ n $$$ vertices $$$ n - 1 $$$ edge tree color either black red also give integer $$$ k $$$ consider sequence $$$ k $$$ vertices let 's call a sequence $$$ [ a_1 a_2 \ldots a_k ] $$$ good satisfy follow criterion : consider tree picture $$$ k=3 $$$ follow sequence good : $$$ [ 1 4 7 ] $$$ $$$ [ 5 5 3 ] $$$ $$$ [ 2 3 7 ] $$$ follow sequence good : $$$ [ 1 4 6 ] $$$ $$$ [ 5 5 5 ] $$$ $$$ [ 3 7 3 ] $$$ $$$ n^k $$$ sequence vertices count many good since number quite large print modulo $$$ 1000000000 + 7 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 100000 $$$ $$$ 2 \le k \le 100 $$$ ) size tree length vertex sequence next $$$ n - 1 $$$ line contain three integers $$$ u_i $$$ $$$ v_i $$$ $$$ x_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ x_i \in \ { 0 1\ } $$$ ) $$$ u_i $$$ $$$ v_i $$$ denote endpoints correspond edge $$$ x_i $$$ color edge ( $$$ 0 $$$ denote red edge $$$ 1 $$$ denote black edge ) print number good sequence modulo $$$ 1000000000 + 7 $$$ first example sequence ( $$$ 4 ^ 4 $$$ ) length $$$ 4 $$$ except follow good : second example edge red hence n't good sequence,['math'],1500.0
1140/B,a string $$$ s $$$ length $$$ n $$$ consist character > < may operations string operation choose character still remain string choose a character > character come right delete ( character choose last one nothing happen ) choose a character < character come right delete ( character choose first one nothing happen ) example choose character > string > > < > string become > > > choose character < string > < string become < string good a sequence operations perform one character remain string example string > > > good apply operations may remove number character give string ( possibly none possibly $$$ n - 1 $$$ whole string ) need calculate minimum number character delete string $$$ s $$$ become good first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) – number test case test case represent two line first line $$$ i $$$ -th test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) – length string $$$ s $$$ second line $$$ i $$$ -th test case contain string $$$ s $$$ consist character > < test case print one line $$$ i $$$ -th test case print minimum number character delete string $$$ s $$$ become good first test case delete character string < > second test case n't need delete character string > < < good perform follow sequence operations : > < < $$$ \rightarrow $$$ < < $$$ \rightarrow $$$ <,['implementation'],1200.0
1140/D,give a regular polygon $$$ n $$$ vertices label $$$ 1 $$$ $$$ n $$$ counter - clockwise order triangulation a give polygon a set triangles vertex triangle a vertex initial polygon pair triangles intersection non - zero area total area triangles equal area give polygon weight a triangulation sum <unknown> triangles consist weight a <unknown> denote product label vertices calculate minimum weight among triangulations polygon first line contain single integer $$$ n $$$ ( $$$ 3 \le n \le 500 $$$ ) — number vertices regular polygon print one integer — minimum weight among triangulations give polygon accord wiki : polygon triangulation decomposition a polygonal area ( simple polygon ) $$$ p $$$ a set triangles i. e. find a set triangles pairwise non - intersecting <unknown> whose union $$$ p $$$ first example polygon a triangle n't need cut answer $$$ 2 \cdot 3 = 6 $$$ second example polygon a rectangle divide two triangles 's optimal cut use diagonal $$$ 1 - 3 $$$ answer $$$ 2 \cdot 3 + 3 \cdot 4 = 6 + 12 = 18 $$$,"['dp', 'greedy', 'math']",1200.0
1142/A,"recently a golden circle <unknown> find byteland a circle route go $$$ n \cdot k $$$ cities cities numerate $$$ 1 $$$ $$$ n \cdot k $$$ distance neighbor cities exactly $$$ 1 $$$ km sergey like beetle love burgers fortunately $$$ n $$$ fast food restaurants circle locate $$$ 1 $$$ -st $$$ ( k + 1 ) $$$ -st $$$ ( 2k + 1 ) $$$ -st , $$$ ( ( n-1 ) k + 1 ) $$$ -st cities i.e distance neighbor cities fast food restaurants $$$ k $$$ km sergey begin journey city $$$ s $$$ travel along circle make stop cities $$$ l $$$ km ( $$$ l > 0 $$$ ) stop $$$ s $$$ sergey forget number $$$ s $$$ $$$ l $$$ remember distance city $$$ s $$$ nearest fast food restaurant $$$ a $$$ km distance city stop travel first $$$ l $$$ km $$$ s $$$ nearest fast food restaurant $$$ b $$$ km sergey always travel direction along circle calculate distance restaurants consider directions sergey interest two integers first integer $$$ x $$$ minimum number stop ( exclude first ) sergey could do return $$$ s $$$ second integer $$$ y $$$ maximum number stop ( exclude first ) sergey could do return $$$ s $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 100\,000 $$$ ) — number fast food restaurants circle distance neighbor restaurants respectively second line contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 0 \le a b \le \frac { k } { 2 } $$$ ) — distance nearest fast food restaurants initial city city sergey make first stop respectively print two integers $$$ x $$$ $$$ y $$$ first example restaurants locate cities $$$ 1 $$$ $$$ 4 $$$ initial city $$$ s $$$ could $$$ 2 $$$ $$$ 3 $$$ $$$ 5 $$$ $$$ 6 $$$ next city sergey stop could also cities $$$ 2 3 5 6 $$$ let 's loop possible combinations cities $$$ s $$$ city first stop city $$$ 2 $$$ ( example $$$ l = 6 $$$ ) sergey $$$ s $$$ first stop already $$$ x = 1 $$$ pair sergey need $$$ 1 2 3 $$$ $$$ 6 $$$ stop return $$$ s $$$ $$$ y = 6 $$$ second example sergey cities fast food restaurant initially first stop $$$ l $$$ $$$ 2 $$$ $$$ 4 $$$ $$$ 6 $$$ thus $$$ x = 1 $$$ $$$ y = 3 $$$ third example one restaurant possible locations $$$ s $$$ first stop : $$$ ( 6 8 ) $$$ $$$ ( 6 4 ) $$$ first option $$$ l = 2 $$$ second $$$ l = 8 $$$ case sergey need $$$ x = y=5 $$$ stop go $$$ s $$$",['math'],1700.0
1142/B,recently lynyrd skynyrd go a shop lynyrd buy a permutation $$$ p $$$ length $$$ n $$$ skynyrd buy array $$$ a $$$ length $$$ m $$$ consist integers $$$ 1 $$$ $$$ n $$$ lynyrd skynyrd become bore ask $$$ q $$$ query follow form : ` ` subsegment $$$ a $$$ $$$ l $$$ -th $$$ r $$$ -th position inclusive a subsequence a cyclic shift $$$ p $$$ ? '' please answer query a permutation length $$$ n $$$ a sequence $$$ n $$$ integers integer $$$ 1 $$$ $$$ n $$$ appear exactly a cyclic shift a permutation $$$ ( p_1 p_2 \ldots p_n ) $$$ a permutation $$$ ( p_i p _ { i + 1 } \ldots p _ { n } p_1 p_2 \ldots p _ { i - 1 } ) $$$ $$$ i $$$ $$$ 1 $$$ $$$ n $$$ example a permutation $$$ ( 2 1 3 ) $$$ three distinct cyclic shift : $$$ ( 2 1 3 ) $$$ $$$ ( 1 3 2 ) $$$ $$$ ( 3 2 1 ) $$$ a subsequence a subsegment array $$$ a $$$ $$$ l $$$ -th $$$ r $$$ -th position inclusive a sequence $$$ a _ { i_1 } a _ { i_2 } \ldots a _ { i_k } $$$ $$$ i_1 i_2 \ldots i_k $$$ $$$ l \leq i_1 < i_2 < \ldots < i_k \leq r $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \le n m q \le 200000 $$$ ) — length permutation $$$ p $$$ length array $$$ a $$$ number query next line contain $$$ n $$$ integers $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th $$$ i $$$ -th element permutation integer $$$ 1 $$$ $$$ n $$$ appear exactly next line contain $$$ m $$$ integers $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th $$$ i $$$ -th element array $$$ a $$$ next $$$ q $$$ line describe query $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le m $$$ ) mean $$$ i $$$ -th query subsegment array $$$ l_i $$$ -th $$$ r_i $$$ -th position inclusive print a single string length $$$ q $$$ consist $$$ 0 $$$ $$$ 1 $$$ digit $$$ i $$$ -th position $$$ 1 $$$ subsegment array $$$ a $$$ $$$ l_i $$$ -th $$$ r_i $$$ -th position inclusive contain a subsequence a cyclic shift $$$ p $$$ $$$ 0 $$$ otherwise first example segment $$$ 1 $$$ -st $$$ 5 $$$ -th position $$$ 1 2 3 1 2 $$$ a subsequence $$$ 1 3 2 $$$ a cyclic shift permutation subsegment $$$ 2 $$$ -nd $$$ 6 $$$ -th position also contain a subsequence $$$ 2 1 3 $$$ equal permutation subsegment $$$ 3 $$$ -rd $$$ 5 $$$ -th position $$$ 3 1 2 $$$ one subsequence length $$$ 3 $$$ ( $$$ 3 1 2 $$$ ) a cyclic shift permutation second example possible cyclic shift $$$ 1 2 $$$ $$$ 2 1 $$$ subsegment $$$ 1 $$$ -st $$$ 2 $$$ -nd position $$$ 1 1 $$$ subsequences cyclic shift permutation subsegment $$$ 2 $$$ -nd $$$ 3 $$$ -rd position $$$ 1 2 $$$ coincide permutation subsegment $$$ 3 $$$ $$$ 4 $$$ position $$$ 2 2 $$$ subsequences cyclic shift permutation,"['data structures', 'dp', 'math']",2000.0
1144/A,a string call diverse contain consecutive ( adjacent ) letter latin alphabet letter occur exactly example follow string diverse : ` ` <unknown> '' ` ` xyz '' ` ` r '' ` ` <unknown> '' follow string diverse : ` ` az '' ` ` aa '' ` ` bad '' ` ` babc '' note letter ' a ' ' z ' adjacent formally consider position letter string alphabet position form contiguous segment i.e come one one without gap letter string distinct ( duplicate allow ) give a sequence string string diverse print ` ` yes '' otherwise print ` ` '' first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) denote number string process follow $$$ n $$$ line contain string one string per line string contain lowercase latin letter length $$$ 1 $$$ $$$ 100 $$$ inclusive print $$$ n $$$ line one line per a string input line contain ` ` yes '' correspond string diverse ` ` '' correspond string diverse print letter case ( upper lower ) example ` ` yes '' ` ` '' ` ` yes '' acceptable,['implementation'],800.0
1149/B,"<unknown> research middle east find trace three ancient religions : first religion second religion third religion compile information evolution beliefs wonder followers religion could coexist peace word universe a long word contain lowercase english character moment time religion beliefs could describe a word consist lowercase english character three religions coexist peace descriptions form disjoint subsequences word universe formally one paint character word universe three color : $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ character paint one color description $$$ i $$$ -th religion construct word universe remove character n't paint color $$$ i $$$ religions however evolve begin religion description empty every a either a character append end description a single religion last character drop description change determine religions could coexist peace first line input contain two integers $$$ n q $$$ ( $$$ 1 \leq n \leq 100\,000 $$$ $$$ 1 \leq q \leq 1000 $$$ ) — length word universe number religion evolutions respectively follow line contain word universe — a string length $$$ n $$$ consist lowercase english character follow line describe a single evolution one follow format : assume religion description longer $$$ 250 $$$ character write $$$ q $$$ line $$$ i $$$ -th yes religions could coexist peace $$$ i $$$ -th evolution otherwise print character case ( either upper lower ) first example 6th evolution religion descriptions : ad bc ab follow figure show descriptions form three disjoint subsequences word universe :","['dp', 'implementation']",2200.0
1149/D,codefortia a small island country locate somewhere west <unknown> consist $$$ n $$$ settlements connect $$$ m $$$ bidirectional gravel roads <unknown> enough beliefs inhabitants require time need pass road equal either $$$ a $$$ $$$ b $$$ second 's guarantee one go pair settlements follow a sequence roads codefortia recently strike financial crisis therefore king decide abandon roads : king however forget parliament house settlement $$$ p = 1 2 \dots n $$$ tell minimum time require travel king 's residence parliament house ( locate settlement $$$ p $$$ ) roads abandon ? first line input contain four integers $$$ n $$$ $$$ m $$$ $$$ a $$$ $$$ b $$$ ( $$$ 2 \leq n \leq 70 $$$ $$$ n - 1 \leq m \leq 200 $$$ $$$ 1 \leq a < b \leq 10000000 $$$ ) — number settlements gravel roads codefortia two possible travel time follow line contain three integers $$$ u v c $$$ ( $$$ 1 \leq u v \leq n $$$ $$$ u \neq v $$$ $$$ c \in \ { a b\ } $$$ ) denote a single gravel road settlements $$$ u $$$ $$$ v $$$ require $$$ c $$$ minutes travel assume road network connect loop multiedges output a single line contain $$$ n $$$ integers $$$ p $$$ -th denote minimum possible time require travel $$$ 1 $$$ $$$ p $$$ select roads abandon note $$$ p $$$ abandon a different set roads minimum possible sum time require pass road first example $$$ 85 $$$ — exactly one roads pass time $$$ 25 $$$ must abandon note one roads abandon 's impossible travel settlements $$$ 1 $$$ $$$ 3 $$$ time $$$ 50 $$$,"['dp', 'greedy']",3000.0
1152/B,"cat furrier transform a popular algorithm among cat programmers create longcats one greatest cat programmers ever exist neko want utilize algorithm create perfect longcat assume a cat a number $$$ x $$$ a perfect longcat a cat a number equal $$$ <unknown> - 1 $$$ non - negative integer $$$ m $$$ example number $$$ 0 $$$ $$$ 1 $$$ $$$ 3 $$$ $$$ 7 $$$ $$$ 15 $$$ suitable perfect longcats cat furrier transform follow operations perform $$$ x $$$ : first apply operation must type a second type b third type a , formally number operations one order execute odd - numbered operations must type a even - numbered operations must type b. neko want produce perfect longcats industrial scale thus cat neko want perform $$$ 40 $$$ operations help neko write a transformation plan ? note require minimize number operations need use $$$ 40 $$$ operations line contain a single integer $$$ x $$$ ( $$$ 1 \le x \le 1000000 $$$ ) first line contain a single integer $$$ t $$$ ( $$$ 0 \le t \le 40 $$$ ) — number operations apply odd - numbered operation print correspond number $$$ n_i $$$ , print $$$ \lceil \frac { t } { 2 } \rceil $$$ integers $$$ n_i $$$ ( $$$ 0 \le n_i \le 30 $$$ ) denote replacement $$$ x $$$ $$$ x \oplus ( 2^ { n_i } - 1 ) $$$ correspond step multiple possible answer print possible show least one answer constraints problem first test one transform might follow : $$$ 39 \to 56 \to 57 \to 62 \to 63 $$$ precisely : second third test number already satisfy goal requirement",['math'],1300.0
1153/A,"rain heavily first day serval become 3 years old go kindergarten unfortunately live far kindergarten father busy drive choice poor little boy wait a bus rainy day circumstances poor boy use first bus see matter go several bus come time choose one randomly serval go bus station time $$$ t $$$ $$$ n $$$ bus rout stop station $$$ i $$$ -th bus route first bus arrive time $$$ s_i $$$ minutes bus route come $$$ d_i $$$ minutes later previous one serval 's best friend wonder bus route get several bus arrive time print first line contain two space - separated integers $$$ n $$$ $$$ t $$$ ( $$$ 1\leq n\leq 100 $$$ $$$ 1\leq t\leq 100000 $$$ ) — number bus rout time serval go station next $$$ n $$$ line contain two space - separated integers $$$ s_i $$$ $$$ d_i $$$ ( $$$ 1\leq s_i d_i\leq 100000 $$$ ) — time first bus route arrive interval two bus route print one number — bus route serval use several possible answer print first example first bus first route arrive time $$$ 6 $$$ first bus second route arrive time $$$ 9 $$$ first route answer second example a bus third route arrive time $$$ 5 $$$ answer third example bus first route come time $$$ 2 $$$ $$$ 4 $$$ $$$ 6 $$$ $$$ 8 $$$ fourth bus second route come time $$$ 2 $$$ $$$ 5 $$$ $$$ 8 $$$ fourth bus third route come time $$$ 2 $$$ $$$ 6 $$$ $$$ 10 $$$ , $$$ 1 $$$ $$$ 2 $$$ acceptable answer $$$ 3 $$$",['math'],1000.0
1154/E,"$$$ n $$$ students stand a row two coach form two team — first coach choose first team second coach choose second team $$$ i $$$ -th student integer program skill $$$ a_i $$$ program skills distinct $$$ 1 $$$ $$$ n $$$ inclusive firstly first coach choose student maximum program skill among students take team $$$ k $$$ closest students leave $$$ k $$$ closest students right ( less $$$ k $$$ students leave right choose ) students choose leave row join first team secondly second coach make move ( students choose join second team ) first coach make move , repeat row become empty ( i. e. process end student become team ) problem determine students take first team students take second team first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 200000 $$$ ) — number students value determine range choose students move respectively second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) $$$ a_i $$$ program skill $$$ i $$$ -th student guarantee program skills distinct print a string $$$ n $$$ character ; $$$ i $$$ -th character 1 $$$ i $$$ -th student join first team 2 otherwise first example first coach choose student a position $$$ 3 $$$ row become empty ( students join first team ) second example first coach choose student position $$$ 4 $$$ row become $$$ [ 2 1 ] $$$ ( students program skills $$$ [ 3 4 5 ] $$$ join first team ) second coach choose student position $$$ 1 $$$ row become empty ( students program skills $$$ [ 1 2 ] $$$ join second team ) third example first coach choose student position $$$ 1 $$$ row become $$$ [ 1 3 5 4 6 ] $$$ ( students program skills $$$ [ 2 7 ] $$$ join first team ) second coach choose student position $$$ 5 $$$ row become $$$ [ 1 3 5 ] $$$ ( students program skills $$$ [ 4 6 ] $$$ join second team ) first coach choose student position $$$ 3 $$$ row become $$$ [ 1 ] $$$ ( students program skills $$$ [ 3 5 ] $$$ join first team ) second coach choose remain student ( student program skill $$$ 1 $$$ join second team ) fourth example first coach choose student position $$$ 3 $$$ row become $$$ [ 2 1 ] $$$ ( students program skills $$$ [ 3 4 5 ] $$$ join first team ) second coach choose student position $$$ 1 $$$ row become empty ( students program skills $$$ [ 1 2 ] $$$ join second team )","['data structures', 'implementation']",1800.0
1155/F,whole delivery market berland control two rival company : berex berps provide fast reliable delivery service across cities berland map berland represent undirected graph cities vertices roads edge pair cities one road road connect different cities berex berps competitive pair cities $$$ ( v u ) $$$ set paths $$$ v $$$ $$$ u $$$ a way two paths n't share a single road guarantee possible berland government decide cut road maintenance cost abandon roads obviously want maintain little roads possible however n't want break entire delivery system berex berps still able paths every pair cities non - intersecting minimal number roads berland government maintain ? formally give a 2 - edge connect undirected graph minimum number edge leave result graph also 2 - edge connect ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 3 \le n \le 14 $$$ $$$ n \le m \le \frac { n ( n - 1 ) } { 2 } $$$ ) — number cities number roads next $$$ m $$$ line contain two integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le n $$$ $$$ v \ne u $$$ ) — cities connect next road guarantee pair cities one road guarantee pair cities least two paths n't share a single road first line contain a single integer $$$ k $$$ — minimum number roads berland government maintain berex berps still able paths every pair cities non - intersecting next $$$ k $$$ line contain list roads maintain line form ` ` $$$ v ~ u $$$ ` ` $$$ v $$$ $$$ u $$$ cities connect next road multiple list minimum size print order roads list n't matter graph examples red edge maintain ones,['dp'],2800.0
1156/B,give a string consist lowercase latin letter a pair neighbour letter a string consider ugly letter also neighbour a alphabet example string ` ` abaca '' contain ugly pair position $$$ ( 1 2 ) $$$ — ` ` ab '' $$$ ( 2 3 ) $$$ — ` ` ba '' letter ' a ' ' z ' n't consider neighbour a alphabet rearrange letter a give string ugly pair ? choose order letter give string ca n't add new letter remove exist ones also leave order multiple answer print also answer $$$ t $$$ separate query first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number query next $$$ t $$$ line contain string $$$ s $$$ $$$ ( 1 \le |s| \le 100 ) $$$ — string next query guarantee contain lowercase latin letter note hack set $$$ t = 1 $$$ print $$$ t $$$ line $$$ i $$$ -th line contain answer $$$ i $$$ -th query answer $$$ i $$$ -th query exist print a <unknown> letter give string contain ugly pair choose order letter give string ca n't add new letter remove exist ones also leave order multiple answer print otherwise print ` ` answer '' query first example answer ` ` <unknown> '' also correct second example showcases fact neighbour alphabet letter allow letter ok . lot valid answer third example,"['greedy', 'implementation']",1800.0
1156/D,give a tree ( undirected connect acyclic graph ) consist $$$ n $$$ vertices $$$ n - 1 $$$ edge a number write edge number either $$$ 0 $$$ ( let 's call edge $$$ 0 $$$ -edges ) $$$ 1 $$$ ( $$$ 1 $$$ -edges ) let 's call order pair vertices $$$ ( x y ) $$$ ( $$$ x \ne y $$$ ) valid traverse simple path $$$ x $$$ $$$ y $$$ never go a $$$ 0 $$$ -edge go a $$$ 1 $$$ -edge task calculate number valid pair tree first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number vertices tree $$$ n - 1 $$$ line follow denote edge tree edge represent three integers $$$ x_i $$$ $$$ y_i $$$ $$$ c_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ 0 \le c_i \le 1 $$$ $$$ x_i \ne y_i $$$ ) — vertices connect edge number write respectively guarantee give edge form a tree print one integer — number valid pair vertices picture correspond first example :,['dp'],2200.0
1157/A,"let 's denote a function $$$ f ( x ) $$$ a way : add $$$ 1 $$$ $$$ x $$$ , least one trail zero result number remove zero example say number $$$ y $$$ reachable $$$ x $$$ apply function $$$ f $$$ $$$ x $$$ ( possibly zero ) time get $$$ y $$$ a result example $$$ 102 $$$ reachable $$$ 10098 $$$ $$$ f ( f ( f ( 10098 ) ) ) = f ( f ( <unknown> ) ) = f ( 101 ) = 102 $$$ ; number reachable give a number $$$ n $$$ ; task count many different number reachable $$$ n $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) print one integer : number different number reachable $$$ n $$$ number reachable $$$ 1098 $$$ : $$$ 1 2 3 4 5 6 7 8 9 11 12 13 14 15 16 17 18 19 1098 1099 $$$",['implementation'],1100.0
1157/F,$$$ n $$$ people a row height $$$ i $$$ -th person $$$ a_i $$$ choose subset people try arrange a balance circle a balance circle order people difference heights adjacent people $$$ 1 $$$ example let heights choose people $$$ [ a _ { i_1 } a _ { i_2 } \dots a _ { i_k } ] $$$ $$$ k $$$ number people choose condition $$$ |a _ { i_j } - a _ { i _ { j + 1 } } | \le 1 $$$ satisfy $$$ j $$$ $$$ 1 $$$ $$$ k-1 $$$ condition $$$ |a _ { i_1 } - a _ { i_k } | \le 1 $$$ also satisfy $$$ |x| $$$ mean absolute value $$$ x $$$ obvious circle consist one person balance task choose maximum number people construct a balance circle consist choose people obvious circle consist one person balance answer always exist first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number people second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 200000 $$$ ) $$$ a_i $$$ height $$$ i $$$ -th person first line output print $$$ k $$$ — number people maximum balance circle second line print $$$ k $$$ integers $$$ res_1 res_2 \dots <unknown> $$$ $$$ <unknown> $$$ height $$$ j $$$ -th person maximum balance circle condition $$$ |res _ { j } - res _ { j + 1 } | \le 1 $$$ satisfy $$$ j $$$ $$$ 1 $$$ $$$ k-1 $$$ condition $$$ |res _ { 1 } - res _ { k } | \le 1 $$$ also satisfy,"['dp', 'greedy']",2000.0
1159/A,"vasya a pile consist number stone $$$ n $$$ time either take one stone pile add one stone pile pile non - empty operation take one stone pile give $$$ n $$$ operations vasya make find minimal possible number stone pile make operations first line contain one positive integer $$$ n $$$ — number operations make vasya ( $$$ 1 \leq n \leq 100 $$$ ) next line contain string $$$ s $$$ consist $$$ n $$$ symbols equal ` ` - '' ( without quote ) ` ` + '' ( without quote ) vasya take stone $$$ i $$$ -th operation $$$ s_i $$$ equal ` ` - '' ( without quote ) add $$$ s_i $$$ equal ` ` + '' ( without quote ) print one integer — minimal possible number stone pile $$$ n $$$ operations first test vasya $$$ 3 $$$ stone pile begin make operations number stone equal $$$ 0 $$$ impossible less number pile answer $$$ 0 $$$ please notice number stone begin ca n't less $$$ 3 $$$ case vasya wo n't able take a stone operation ( pile empty ) second test vasya $$$ 0 $$$ stone pile begin make operations number stone equal $$$ 4 $$$ impossible less number pile make $$$ 4 $$$ operations number stone pile increase $$$ 4 $$$ stone , answer $$$ 4 $$$ third test vasya $$$ 1 $$$ stone pile begin make operations number stone equal $$$ 1 $$$ prove impossible less number stone make operations fourth test vasya $$$ 0 $$$ stone pile begin make operations number stone equal $$$ 3 $$$","['implementation', 'math']",800.0
1163/B2,problem previous one larger constraints shiro 's move new house want invite friends house play monopoly however house small invite one friend a time $$$ n $$$ days since day shiro move new house exactly one cat come shiro 's house cat come $$$ i $$$ -th day a ribbon color $$$ u_i $$$ shiro want know largest number $$$ x $$$ consider streak first $$$ x $$$ days possible remove exactly one day streak every ribbon color appear among remain $$$ x - 1 $$$ number occurrences example consider follow sequence $$$ u_i $$$ : $$$ [ 2 2 1 1 5 4 4 5 ] $$$ $$$ x = 7 $$$ make a streak since remove leftmost $$$ u_i = 5 $$$ ribbon color appear exactly twice prefix $$$ x - 1 $$$ days note $$$ x = 8 $$$ n't form a streak since must remove exactly one day since shiro a cat good count need help find longest streak first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — total number days second line contain $$$ n $$$ integers $$$ u_1 u_2 \ldots u_n $$$ ( $$$ 1 \leq u_i \leq 100000 $$$ ) — color ribbons cat wear print a single integer $$$ x $$$ — largest possible streak days first example choose longest streak $$$ 13 $$$ days since upon remove last day streak remain color $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ number occurrences $$$ 3 $$$ note streak also $$$ 10 $$$ days ( remove $$$ 10 $$$ -th day streak ) interest longest streak fourth example take streak first $$$ 6 $$$ days remove third day streak remain color $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ occur exactly,"['data structures', 'implementation']",1600.0
1163/E,kuro learn permutations really excite create a new permutation type choose $$$ n $$$ distinct positive integers put a set $$$ s $$$ define a magical permutation : since kuro really excite magical permutations want create longest magical permutation possible word want find largest non - negative integer $$$ x $$$ a magical permutation integers $$$ 0 $$$ $$$ 2^x - 1 $$$ since a newbie subject want help find value $$$ x $$$ also magical permutation $$$ x $$$ first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — number elements set $$$ s $$$ next line contain $$$ n $$$ distinct integers $$$ s_1 s_2 \ldots s_n $$$ ( $$$ 1 \leq s_i \leq 200000 $$$ ) — elements set $$$ s $$$ first line print largest non - negative integer $$$ x $$$ a magical permutation integers $$$ 0 $$$ $$$ 2^x - 1 $$$ print $$$ 2^x $$$ integers describe a magical permutation integers $$$ 0 $$$ $$$ 2^x - 1 $$$ multiple magical permutations print first example $$$ 0 1 3 2 $$$ a magical permutation since : $$$ \oplus $$$ denote bitwise xor operation,"['data structures', 'math']",2400.0
1163/F,"city capypaland kuro shiro reside $$$ n $$$ towns number $$$ 1 $$$ $$$ n $$$ $$$ m $$$ bidirectional roads number $$$ 1 $$$ $$$ m $$$ connect $$$ i $$$ -th road connect towns $$$ u_i $$$ $$$ v_i $$$ since travel towns quite difficult taxi industry really popular survive harsh competition taxi company find a distinctive trait customers kuro owner a taxi company decide introduce a new fee model taxi brand fee ride calculate base trip length sum price roads travel price $$$ m $$$ roads decide kuro , price road $$$ i $$$ $$$ w_i $$$ hence fee a taxi ride travel roads $$$ e_1 e_2 \ldots e_k $$$ $$$ \sum _ { i=1 } ^k w _ { e_i } $$$ however kuro <unknown> person draft $$$ q $$$ plan change road price plan base original price $$$ w_i $$$ except a single road $$$ t_j $$$ price change $$$ x_j $$$ note plan independent shiro a regular customer kuro 's taxi brand since use taxi travel town $$$ 1 $$$ town $$$ n $$$ every day since 's a regular customer kuro decide show $$$ q $$$ plan publish public , shiro want know lowest fee must pay travel town $$$ 1 $$$ town $$$ n $$$ kuro 's plan first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 1 \le m q \le 200000 $$$ ) — number towns number roads number plan kuro draft respectively $$$ i $$$ -th next $$$ m $$$ contain three integers $$$ u_i $$$ $$$ v_i $$$ $$$ w_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ 1 \le w_i \le 1000000000 $$$ $$$ u_i \ne v_i $$$ ) — two endpoints original price $$$ i $$$ -th road guarantee least one way travel town $$$ 1 $$$ town $$$ n $$$ use $$$ m $$$ bidirectional roads next $$$ q $$$ line contain two integers $$$ t_j $$$ $$$ x_j $$$ ( $$$ 1 \leq t_j \leq m 1 \leq x_j \leq 1000000000 $$$ ) — index road kuro plan change new price respectively print $$$ q $$$ integers — lowest fee shiro must pay get town $$$ 1 $$$ town $$$ n $$$ $$$ q $$$ plan first example original overview capypaland look like number next road denote original price roads overview first plan lowest fee shiro must pay plan $$$ 4 $$$ correspond path $$$ 1 \rightarrow 4 $$$ overview second plan lowest fee shiro must pay plan $$$ 2 $$$ correspond path $$$ 1 \rightarrow 3 \rightarrow 4 $$$ overview third plan lowest fee shiro must pay plan $$$ 5 $$$ correspond path $$$ 1 \rightarrow 2 \rightarrow 4 $$$",['data structures'],3000.0
1165/F2,difference easy hard versions constraints ivan play a computer game contain microtransactions make character look cooler since ivan want character really cool want use microtransactions — wo n't start play get day ( morning ) ivan earn exactly one burle $$$ n $$$ type microtransactions game microtransaction cost $$$ 2 $$$ burl usually $$$ 1 $$$ burle sale ivan order exactly $$$ k_i $$$ microtransactions $$$ i $$$ -th type ( order microtransactions even ) ivan order ( possibly zero ) number microtransactions type day ( course enough money ) microtransaction want order sale buy $$$ 1 $$$ burle otherwise buy $$$ 2 $$$ burl also $$$ m $$$ special offer game shop $$$ j $$$ -th offer $$$ ( d_j t_j ) $$$ mean microtransactions $$$ t_j $$$ -th type sale $$$ d_j $$$ -th day ivan want order microtransactions soon possible task calculate minimum day buy microtransactions want actually start play first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200000 $$$ ) — number type microtransactions number special offer game shop second line input contain $$$ n $$$ integers $$$ k_1 k_2 \dots k_n $$$ ( $$$ 0 \le k_i \le 200000 $$$ ) $$$ k_i $$$ number copy microtransaction $$$ i $$$ -th type ivan order guarantee sum $$$ k_i $$$ less $$$ 1 $$$ greater $$$ 200000 $$$ next $$$ m $$$ line contain special offer $$$ j $$$ -th line contain $$$ j $$$ -th special offer give a pair integers $$$ ( d_j t_j ) $$$ ( $$$ 1 \le d_j \le 2 \cdot 100000 1 \le t_j \le n $$$ ) mean microtransactions $$$ t_j $$$ -th type sale $$$ d_j $$$ -th day print one integer — minimum day ivan order microtransactions want actually start play,"['greedy', 'implementation']",2000.0
1166/D,give a positive integer $$$ m $$$ say a sequence $$$ x_1 x_2 \dots x_n $$$ positive integers $$$ m $$$ -cute every index $$$ i $$$ $$$ 2 \le i \le n $$$ hold $$$ x_i = x _ { i - 1 } + x _ { i - 2 } + \dots + x_1 + r_i $$$ positive integer $$$ r_i $$$ satisfy $$$ 1 \le r_i \le m $$$ give $$$ q $$$ query consist three positive integers $$$ a $$$ $$$ b $$$ $$$ m $$$ query must determine whether exist $$$ m $$$ -cute sequence whose first term $$$ a $$$ whose last term $$$ b $$$ a sequence exist must additionally find example first line contain integer number $$$ q $$$ ( $$$ 1 \le q \le 1000 $$$ ) — number query follow $$$ q $$$ line contain three integers $$$ a $$$ $$$ b $$$ $$$ m $$$ ( $$$ 1 \le a b m \le 10^ { 14 } $$$ $$$ a \leq b $$$ ) describe a single query query $$$ m $$$ -cute sequence whose first term $$$ a $$$ whose last term $$$ b $$$ exist print $$$ -1 $$$ otherwise print integer $$$ k $$$ ( $$$ 1 \le k \leq 50 $$$ ) follow $$$ k $$$ integers $$$ x_1 x_2 \dots x_k $$$ ( $$$ 1 \le x_i \le 10^ { 14 } $$$ ) integers must satisfy $$$ x_1 = a $$$ $$$ x_k = b $$$ sequence $$$ x_1 x_2 \dots x_k $$$ $$$ m $$$ -cute show problem constraints query either $$$ m $$$ -cute sequence exist exist one $$$ 50 $$$ term multiple possible sequence may print consider sample first query sequence $$$ 5 6 13 26 $$$ valid since $$$ 6 = 5 + \bf { \color { blue } 1 } $$$ $$$ 13 = 6 + 5 + { \bf\color { blue } 2 } $$$ $$$ 26 = 13 + 6 + 5 + { \bf\color { blue } 2 } $$$ bold value $$$ 1 $$$ $$$ 2 $$$ sequence $$$ 2 $$$ -cute valid sequence $$$ 5 7 13 26 $$$ also accept second query possible $$$ 1 $$$ -cute sequence start $$$ 3 $$$ $$$ 3 4 8 16 \dots $$$ contain $$$ 9 $$$,"['greedy', 'math']",2200.0
1167/A,a telephone number a sequence exactly 11 digits first digit 8 . example sequence <unknown> a telephone number sequence <unknown> <unknown> give a string $$$ s $$$ length $$$ n $$$ consist digits one operation delete character string $$$ s $$$ example possible obtain string 112 111 121 string 1121 . need determine whether a sequence operations ( possibly empty ) string $$$ s $$$ become a telephone number first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — length string $$$ s $$$ second line test case contain string $$$ s $$$ ( $$$ |s| = n $$$ ) consist digits test print one line a sequence operations $$$ s $$$ become a telephone number print yes otherwise print first test case need delete first third digits string <unknown> become <unknown>,['greedy'],800.0
1168/E,toad mikhail array $$$ 2^k $$$ integers $$$ a_1 a_2 \ldots a _ { 2^k } $$$ find two permutations $$$ p $$$ $$$ q $$$ integers $$$ 0 1 \ldots 2^k-1 $$$ $$$ a_i $$$ equal $$$ p_i \oplus q_i $$$ possible $$$ i $$$ determine permutations $$$ \oplus $$$ denote bitwise xor operation first line contain one integer $$$ k $$$ ( $$$ 2 \leq k \leq 12 $$$ ) denote size array $$$ 2^k $$$ next line contain $$$ 2^k $$$ space - separated integers $$$ a_1 a_2 \ldots a _ { 2^k } $$$ ( $$$ 0 \leq a_i < 2^k $$$ ) — elements give array give array ca n't represent element - wise xor two permutations integers $$$ 0 1 \ldots 2^k-1 $$$ print ` ` fou '' otherwise print ` ` shi '' first line next two line contain description two suitable permutations first line contain $$$ 2^k $$$ space - separated distinct integers $$$ p _ { 1 } p _ { 2 } \ldots p _ { 2^k } $$$ second line contain $$$ 2^k $$$ space - separated distinct integers $$$ q _ { 1 } q _ { 2 } \ldots q _ { 2^k } $$$ elements $$$ p $$$ $$$ q $$$ $$$ 0 $$$ $$$ 2^k - 1 $$$ inclusive ; $$$ p_i \oplus q_i $$$ equal $$$ a_i $$$ $$$ i $$$ $$$ 1 \leq i \leq 2^k $$$ several possible solutions print,['math'],3100.0
117/E,give undirected connect graph g consist n vertexes n edge g contain self - loops multiple edge let edge two state : initially edge switch also give m query represent ( v u ) — change state edge shortest path vertex v vertex u graph g. several paths lexicographically minimal one choose formally let us consider shortest paths vertex v vertex u sequence vertexes v v1 v2 ... u. among sequence choose lexicographically minimal one query tell many connect components graph whose vertexes coincide vertexes graph g edge coincide switch edge graph g. first line contain two integers n m ( 3 ≤ n ≤ 105 1 ≤ m ≤ 105 ) n line describe graph edge a b ( 1 ≤ a b ≤ n ) next m line contain query v u ( 1 ≤ v u ≤ n ) guarantee graph connect self - loops multiple edge print m line contain one integer — query result let 's consider first sample 'll highlight switch edge blue image graph apply operations graph edge switch 's initially 5 connect components graph query v = 5 u = 4 . see graph three components consider switch edge graph query v = 1 u = 5 . see graph three components consider switch edge lexicographical comparison two sequence equal length k number do follow sequence x lexicographically less sequence y exist i ( 1 ≤ i ≤ k ) xi < yi j ( 1 ≤ j < i ) xj = yj,"['data structures', 'implementation']",2900.0
1174/E,"let 's define a function $$$ f ( p ) $$$ a permutation $$$ p $$$ follow let $$$ g_i $$$ greatest common divisor ( gcd ) elements $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_i $$$ ( word gcd prefix length $$$ i $$$ ) $$$ f ( p ) $$$ number distinct elements among $$$ g_1 $$$ $$$ g_2 $$$ ... $$$ g_n $$$ let $$$ f _ { max } ( n ) $$$ maximum value $$$ f ( p ) $$$ among permutations $$$ p $$$ integers $$$ 1 $$$ $$$ 2 $$$ ... $$$ n $$$ give integers $$$ n $$$ count number permutations $$$ p $$$ integers $$$ 1 $$$ $$$ 2 $$$ ... $$$ n $$$ $$$ f ( p ) $$$ equal $$$ f _ { max } ( n ) $$$ since answer may large print remainder division $$$ 1000\,000\,007 = 1000000000 + 7 $$$ line contain integer $$$ n $$$ ( $$$ 2 \le n \le 1000000 $$$ ) — length permutations line contain answer modulo $$$ 1000000000 + 7 $$$ consider second example : permutations length $$$ 3 $$$ : maximum value $$$ f _ { max } ( 3 ) = 2 $$$ $$$ 4 $$$ permutations $$$ p $$$ $$$ f ( p ) = 2 $$$","['dp', 'math']",2500.0
1175/E,give $$$ n $$$ intervals form $$$ [ l ; r ] $$$ a number line also give $$$ m $$$ query form $$$ [ x ; y ] $$$ minimal number intervals take every point ( necessarily integer ) $$$ x $$$ $$$ y $$$ cover least one ? ca n't choose intervals every point $$$ x $$$ $$$ y $$$ cover print -1 query first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200000 $$$ ) — number intervals number query respectively next $$$ n $$$ line contain two integer number $$$ l_i $$$ $$$ r_i $$$ ( $$$ 0 \le l_i < r_i \le 500000 $$$ ) — give intervals next $$$ m $$$ line contain two integer number $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \le x_i < y_i \le 500000 $$$ ) — query print $$$ m $$$ integer number $$$ i $$$ -th number answer $$$ i $$$ -th query : either minimal number intervals take every point ( necessarily integer ) $$$ x_i $$$ $$$ y_i $$$ cover least one -1 ca n't choose intervals every point $$$ x_i $$$ $$$ y_i $$$ cover first example three query : second example four query :,"['data structures', 'dp', 'greedy', 'implementation']",2200.0
1178/F2,"second subtask problem f. differences first subtask constraints value $$$ m $$$ time limit sufficient solve subtask order hack need solve subtasks order hack first one $$$ n+1 $$$ distinct colour universe number $$$ 0 $$$ $$$ n $$$ a strip paper $$$ m $$$ centimetres long initially paint colour $$$ 0 $$$ alice take a brush paint strip use follow process $$$ i $$$ $$$ 1 $$$ $$$ n $$$ order pick two integers $$$ 0 \leq a_i < b_i \leq m $$$ segment $$$ [ a_i b_i ] $$$ currently paint a single colour repaint colour $$$ i $$$ alice choose segment a way centimetre paint colour $$$ 0 $$$ formally segment $$$ [ i-1 i ] $$$ paint colour $$$ c_i $$$ ( $$$ c_i \neq 0 $$$ ) every colour $$$ 0 $$$ visible strip count number different pair sequence $$$ \ { a_i\ } _ { i=1 } ^n $$$ $$$ \ { b_i\ } _ { i=1 } ^n $$$ result configuration since number may large output modulo $$$ 998244353 $$$ first line contain a two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 500 $$$ $$$ n \leq m \leq 1000000 $$$ ) — number colour exclude colour $$$ 0 $$$ length paper respectively second line contain $$$ m $$$ space separate integers $$$ c_1 c_2 \ldots c_m $$$ ( $$$ 1 \leq c_i \leq n $$$ ) — colour visible segment $$$ [ i-1 i ] $$$ process end guarantee $$$ j $$$ $$$ 1 $$$ $$$ n $$$ index $$$ k $$$ $$$ c_k = j $$$ output a single integer — number ways alice perform paint modulo $$$ 998244353 $$$ first example $$$ 5 $$$ ways depict figure , $$$ 0 $$$ white $$$ 1 $$$ red $$$ 2 $$$ green $$$ 3 $$$ blue example a paint process valid second step segment 1 3 single colour thus may repaint colour $$$ 2 $$$ second example alice must first paint segment 0 3 colour $$$ 1 $$$ segment 1 2 colour $$$ 2 $$$",['dp'],2600.0
1179/A,"recently course algorithms data structure valeriy learn use a deque build a deque fill $$$ n $$$ elements $$$ i $$$ -th element $$$ a_i $$$ ( $$$ i $$$ = $$$ 1 2 \ldots n $$$ ) gradually take first two leftmost elements deque ( let 's call $$$ a $$$ $$$ b $$$ respectively ) follow : $$$ a > b $$$ write $$$ a $$$ begin write $$$ b $$$ end deque otherwise write begin $$$ b $$$ $$$ a $$$ write end deque call sequence action operation example deque $$$ [ 2 3 4 5 1 ] $$$ operation write $$$ b=3 $$$ begin $$$ a=2 $$$ end get $$$ [ 3 4 5 1 2 ] $$$ teacher course see valeriy passionate work approach give $$$ q $$$ query query consist singular number $$$ m_j $$$ $$$ ( j = 1 2 \ldots q ) $$$ require query answer two elements pull $$$ m_j $$$ -th operation note query independent query number $$$ a $$$ $$$ b $$$ print order pull deque deque a data structure represent a list elements insertion new elements deletion exist elements make side first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \leq n \leq 100000 $$$ $$$ 0 \leq q \leq 300000 $$$ ) — number elements deque number query second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ $$$ a_i $$$ $$$ ( 0 \leq a_i \leq 1000000000 ) $$$ — deque element $$$ i $$$ -th position next $$$ q $$$ line contain one number mean $$$ m_j $$$ ( $$$ 1 \leq m_j \leq 10^ { 18 } $$$ ) teacher 's query output two number $$$ a $$$ $$$ b $$$ — number valeriy pull deque $$$ m_j $$$ -th operation , $$$ 2 $$$ write begin deque $$$ 1 $$$ — end get follow status deque : $$$ [ 2 3 4 5 1 ] $$$","['data structures', 'implementation']",1500.0
1183/A,"polycarp know sum digits a number divisible $$$ 3 $$$ number divisible $$$ 3 $$$ assume number sum digits divisible $$$ 4 $$$ also somewhat interest thus consider a positive integer $$$ n $$$ interest sum digits divisible $$$ 4 $$$ help polycarp find nearest larger equal interest number give number $$$ a $$$ , find interest number $$$ n $$$ $$$ n \ge a $$$ $$$ n $$$ minimal line input contain integer $$$ a $$$ ( $$$ 1 \le a \le 1000 $$$ ) print nearest greater equal interest number give number $$$ a $$$ word print interest number $$$ n $$$ $$$ n \ge a $$$ $$$ n $$$ minimal",['implementation'],800.0
1183/H,difference easy hard versions constraints a subsequence a string derive another string delete symbols without change order remain symbols character delete require go successively gap example string ` ` abaca '' follow string subsequences : ` ` abaca '' ` ` aba '' ` ` aaa '' ` ` a '' ` ` '' ( empty string ) follow string subsequences : ` ` aabaca '' ` ` cb '' ` ` bcaa '' give a string $$$ s $$$ consist $$$ n $$$ lowercase latin letter one move take subsequence $$$ t $$$ give string add set $$$ s $$$ set $$$ s $$$ ca n't contain duplicate move cost $$$ n - |t| $$$ $$$ |t| $$$ length add subsequence ( i.e price equal number delete character ) task find minimum possible total cost obtain a set $$$ s $$$ size $$$ k $$$ report impossible first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100 1 \le k \le 10^ { 12 } $$$ ) — length string size set correspondingly second line input contain a string $$$ s $$$ consist $$$ n $$$ lowercase latin letter print one integer — impossible obtain set $$$ s $$$ size $$$ k $$$ print -1 . otherwise print minimum possible total cost first example generate $$$ s $$$ = { ` ` asdf '' ` ` asd '' ` ` adf '' ` ` asf '' ` ` sdf '' } cost first element $$$ s $$$ $$$ 0 $$$ cost others $$$ 1 $$$ total cost $$$ s $$$ $$$ 4 $$$,['dp'],1900.0
1184/A1,"melody pond steal parent a newborn baby madame kovarian become a weapon silence crusade doctor madame kovarian change melody 's name river song give a new identity allow kill eleventh doctor heidi figure madame kovarian use a complicate hash function order change name baby steal order prevent happen future doctor heidi decide prepare learn basic hash techniques first hash function design follow give two positive integers $$$ ( x y ) $$$ define $$$ h ( x y ) : = x^2 + <unknown> $$$ , heidi wonder function <unknown> , give a positive integer $$$ r $$$ find a pair $$$ ( x y ) $$$ ( positive integers ) $$$ h ( x y ) = r $$$ ? multiple pair exist output one smallest possible $$$ x $$$ pair output ` ` '' first line contain integer $$$ r $$$ ( $$$ 1 \le r \le 10^ { 12 } $$$ ) output integers $$$ x y $$$ $$$ h ( x y ) = r $$$ $$$ x $$$ smallest possible ` ` '' pair exist",['math'],1200.0
1184/A3,heidi ready crack madame kovarian 's hash function madame kovarian a strict set rule name change two name interchange use follow hash function result a collision however hash function parametrized one always find a set parameters cause a collision heidi decide exploit advantage give two string $$$ w_1 $$$ $$$ w_2 $$$ equal length $$$ n $$$ consist lowercase english letter integer $$$ m $$$ consider standard polynomial hash function : $$$ h_p ( w ) : = \left ( \sum _ { i=0 } ^ { <unknown> } w_i <unknown> \right ) \mbox { mod } ( p ) $$$ $$$ p $$$ prime $$$ r $$$ number $$$ 2\leq r \leq p-2 $$$ goal find $$$ r $$$ a prime $$$ p $$$ ( $$$ m \leq p \leq 1000000000 $$$ ) $$$ h_p ( w_1 ) = h_p ( w_2 ) $$$ string $$$ w_1 $$$ $$$ w_2 $$$ sample independently random string length $$$ n $$$ lowercase english letter first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 10 \le n \le 100000 $$$ $$$ 2 \le m \le 100000 $$$ ) second third line respectively contain word $$$ w_1 $$$ $$$ w_2 $$$ sample independently random string length $$$ n $$$ lowercase english letter output integers $$$ p r $$$ $$$ p $$$ a prime range $$$ [ m 1000000000 ] $$$ $$$ r $$$ integer satisfy $$$ <unknown> [ 2 p-2 ] $$$ least one solution guarantee exist case multiple solutions exist print first example note even though $$$ <unknown> $$$ $$$ r=2 $$$ also cause a <unknown> hash a correct solution since $$$ m $$$ $$$ 5 $$$ thus want $$$ <unknown> 5 $$$ second example aware extra ' g ' end n't realize ` ` river song '' ` ` melody pond '' different lengths .,['math'],3100.0
1185/C2,"difference easy hard versions constraints write a solution python prefer send pypy speed execution time a session begin beland state university many students take exams polygraph poligrafovich go examine a group $$$ n $$$ students students take exam one - by - one order $$$ 1 $$$ -th $$$ n $$$ -th rule exam follow : students take exam fix order one - by - one without interruption moment time polygraph poligrafovich take answer one student duration whole exam students $$$ m $$$ minutes ( $$$ \max t_i \le m $$$ ) students end list a greater possibility run time pass exam student $$$ i $$$ count minimum possible number students need fail exam $$$ i $$$ -th student enough time pass exam student $$$ i $$$ find answer independently , find answer student $$$ i_1 $$$ student $$$ j $$$ leave find answer $$$ i_2 $$$ ( $$$ i_2 > i_1 $$$ ) student $$$ j $$$ student go home first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le m \le 20000000 $$$ ) — number students total duration exam minutes respectively second line input contain $$$ n $$$ integers $$$ t_i $$$ ( $$$ 1 \le t_i \le 100 $$$ ) — time minutes $$$ i $$$ -th student spend answer a ticket 's guarantee value $$$ t_i $$$ greater $$$ m $$$ print $$$ n $$$ number : $$$ i $$$ -th number must equal minimum number students leave exam order $$$ i $$$ -th student enough time pass exam explanation example 1 . please note sum first five exam time exceed $$$ m=15 $$$ ( sum $$$ 1 + 2 + 3 + 4 + 5=15 $$$ ) thus first five students pass exam even students also pass exam word first five number answer $$$ 0 $$$ order $$$ 6 $$$ -th student pass exam necessary least $$$ 2 $$$ students must fail ( example $$$ 3 $$$ -rd $$$ 4 $$$ -th $$$ 6 $$$ -th finish exam $$$ 1 + 2 + 5 + 6=14 $$$ minutes exceed $$$ m $$$ ) order $$$ 7 $$$ -th student pass exam necessary least $$$ 3 $$$ students must fail ( example $$$ 2 $$$ -nd $$$ 5 $$$ -th $$$ 6 $$$ -th $$$ 7 $$$ -th finish exam $$$ 1 + 3 + 4 + 7=15 $$$ minutes exceed $$$ m $$$ )","['data structures', 'greedy', 'math']",1700.0
1187/C,vasya array $$$ a_1 a_2 \dots a_n $$$ n't know array tell $$$ m $$$ facts array $$$ i $$$ -th fact a triple number $$$ t_i $$$ $$$ l_i $$$ $$$ r_i $$$ ( $$$ 0 \le t_i \le 1 1 \le l_i < r_i \le n $$$ ) mean : example $$$ a = [ 2 1 1 3 2 ] $$$ could give three facts : $$$ t_1=1 l_1=2 <unknown> $$$ ( subarray $$$ [ a_2 a_3 a_4 ] = [ 1 1 3 ] $$$ sort ) $$$ <unknown> l_2=4 <unknown> $$$ ( subarray $$$ [ a_4 a_5 ] = [ 3 2 ] $$$ sort ) $$$ <unknown> <unknown> <unknown> $$$ ( subarray $$$ [ a_3 a_5 ] = [ 1 3 2 ] $$$ sort ) n't know array $$$ a $$$ find array satisfy give facts first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 1000 1 \le m \le 1000 $$$ ) next $$$ m $$$ line contain three integers $$$ t_i $$$ $$$ l_i $$$ $$$ r_i $$$ ( $$$ 0 \le t_i \le 1 1 \le l_i < r_i \le n $$$ ) $$$ t_i = 1 $$$ subbarray $$$ a _ { l_i } a _ { l_i + 1 } \dots a _ { r_i } $$$ sort otherwise ( $$$ t_i = 0 $$$ ) subbarray $$$ a _ { l_i } a _ { l_i + 1 } \dots a _ { r_i } $$$ sort array satisfy facts line print ( letter case ) a solution print yes ( letter case ) second line print $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — array $$$ a $$$ satisfy give facts multiple satisfy array print,"['greedy', 'implementation']",1800.0
1187/F,let $$$ x $$$ array integers $$$ x = [ x_1 x_2 \dots x_n ] $$$ let 's define $$$ b ( x ) $$$ a minimal size a partition $$$ x $$$ subsegments elements subsegment equal example $$$ b ( [ 3 3 6 1 6 6 6 ] ) = 4 $$$ use next partition : $$$ [ 3 3\ |\ 6\ |\ 1\ |\ 6 6 6 ] $$$ n't exact value $$$ x $$$ know $$$ x_i $$$ integer value $$$ [ l_i r_i ] $$$ ( $$$ l_i \le r_i $$$ ) uniformly random $$$ x_i $$$ independent calculate expect value $$$ ( b ( x ) ) ^2 $$$ $$$ e ( ( b ( x ) ) ^2 ) $$$ 's guarantee expect value represent rational fraction $$$ \frac { p } { q } $$$ $$$ ( p q ) = 1 $$$ print value $$$ p \cdot q^ { -1 } \mod 1000000000 + 7 $$$ first line contain single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — size array $$$ x $$$ second line contain $$$ n $$$ integers $$$ l_1 l_2 \dots l_n $$$ ( $$$ 1 \le l_i \le 1000000000 $$$ ) third line contain $$$ n $$$ integers $$$ r_1 r_2 \dots r_n $$$ ( $$$ l_i \le r_i \le 1000000000 $$$ ) print single integer — $$$ e ( ( b ( x ) ) ^2 ) $$$ $$$ p \cdot q^ { -1 } \mod 1000000000 + 7 $$$ let 's describe possible value $$$ x $$$ first sample : possible value $$$ x $$$ second sample :,"['dp', 'math']",2500.0
1188/B,give a prime number $$$ p $$$ $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ integer $$$ k $$$ find number pair index $$$ ( i j ) $$$ ( $$$ 1 \le i < j \le n $$$ ) $$$ ( a_i + a_j ) ( a_i^2 + <unknown> ) \equiv k \bmod p $$$ first line contain integers $$$ n p k $$$ ( $$$ 2 \le n \le 300000 $$$ $$$ 2 \le p \le 1000000000 $$$ $$$ 0 \le k \le p-1 $$$ ) $$$ p $$$ guarantee prime second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le p-1 $$$ ) guarantee elements different output a single integer — answer problem first example : $$$ ( 0 + 1 ) ( 0 ^ 2 + 1 ^ 2 ) = 1 \equiv 1 \bmod 3 $$$ $$$ ( 0 + 2 ) ( 0 ^ 2 + 2 ^ 2 ) = 8 \equiv 2 \bmod 3 $$$ $$$ ( 1 + 2 ) ( 1 ^ 2 + 2 ^ 2 ) = 15 \equiv 0 \bmod 3 $$$ $$$ 1 $$$ pair satisfy condition second example $$$ 3 $$$ pair : $$$ ( 1 5 ) $$$ $$$ ( 2 3 ) $$$ $$$ ( 4 6 ) $$$,['math'],2300.0
1188/D,give $$$ n $$$ number $$$ a_1 a_2 \dots a_n $$$ one operation add one number a nonnegative integer power $$$ 2 $$$ smallest number operations need perform make $$$ n $$$ number equal ? prove give constraints n't exceed $$$ 10^ { 18 } $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 10^ { 17 } $$$ ) output exactly one integer — smallest number operations need perform make $$$ n $$$ number equal first example number already equal need number operation $$$ 0 $$$ second example apply operation $$$ 3 $$$ time : add $$$ 8 $$$ first $$$ 2 $$$ add $$$ 8 $$$ second $$$ 2 $$$ add $$$ 2 $$$ $$$ 8 $$$ make number equal $$$ 10 $$$ prove ca n't make number equal less $$$ 3 $$$ operations,['dp'],3100.0
1189/B,give $$$ n $$$ number $$$ a_1 a_2 \ldots a_n $$$ possible arrange a circle a way every number strictly less sum neighbor ? example array $$$ [ 1 4 5 6 7 8 ] $$$ arrangement leave valid arrangement right $$$ <unknown> 4 + 1 $$$ $$$ 8 > 1 + 6 $$$ first line contain a single integer $$$ n $$$ ( $$$ 3\le n \le 100000 $$$ ) — number number second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \le 1000000000 $$$ ) — number give number necessarily distinct ( i.e duplicate allow ) solution output ` ` '' first line a solution output ` ` yes '' first line second line output $$$ n $$$ number — elements array order stay circle first last element output consider neighbor circle multiple solutions output print circle start element one possible arrangements show first example : $$$ 4 < 2 + 3 $$$ ; $$$ 2 < 4 + 3 $$$ ; $$$ 3 < 4 + 2 $$$ one possible arrangements show second example matter arrange $$$ 13 8 5 $$$ a circle third example $$$ 13 $$$ $$$ 8 $$$ $$$ 5 $$$ neighbor $$$ <unknown> 8 + 5 $$$ solution fourth example,"['greedy', 'math']",1100.0
1190/E,tokitsukaze friends try <unknown> a secret base build claris however claris aware set a bomb go explode a minute although try escape place go find door lock moment cjb father tokitsukaze come magical power give <unknown> goddess <unknown> cjb able set $$$ m $$$ barriers protect explosion formally let 's build a cartesian coordinate system plane assume bomb $$$ o ( 0 0 ) $$$ $$$ n $$$ persons tokitsukaze 's crew $$$ i $$$ -th one $$$ p_i ( x_i y_i ) $$$ every barrier consider a line infinity length intersect every person tokitsukaze 's crew must least one barrier separate bomb mean line bomb intersect least one barrier definition exist a person stand position bomb line $$$ o ( 0 0 ) $$$ satisfy requirement although cjb powerful still want barriers far bomb possible order conserve energy please help calculate maximum distance bomb closest barrier tokitsukaze 's crew safe first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 100000 $$$ ) indicate number people number barriers respectively $$$ i $$$ -th line next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ -100000 \leq x_i y_i \leq 100000 $$$ ) indicate $$$ i $$$ -th person 's location $$$ p_i ( x_i y_i ) $$$ note $$$ p_i $$$ may coordinate $$$ p_j $$$ ( $$$ j \neq i $$$ ) even $$$ o $$$ print a single real number — maximum distance meet requirement answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \frac { |a - b| } { \max ( 1 |b| ) } \leq 10^ { -6 } $$$ first two examples cjb must set barrier cross $$$ o ( 0 0 ) $$$ last two examples cjb set barrier cross $$$ p_i $$$ barrier perpendicular line $$$ p_i $$$ $$$ o $$$,['greedy'],3100.0
1191/B,tokitsukaze play a game <unknown> japanese <unknown> game three tile hand tile own a suit tile mean a suit ( <unknown> <unknown> <unknown> ) a number ( a digit range $$$ 1 $$$ $$$ 9 $$$ ) problem use one digit one lowercase letter first character suit represent a suit tile possible suit tile represent 1 m 2 m $$$ \ldots $$$ 9 m 1p 2p $$$ \ldots $$$ <unknown> 1s 2s $$$ \ldots $$$ 9s order win game must least one <unknown> ( describe ) hand sometimes draw extra suit tile draw a tile number tile increase one draw tile want include already hand know minimum number extra suit tile need draw win ? useful definitions game : examples : note order tile unnecessary assume number type suit tile draw infinite line contain three string — tile tokitsukaze 's hand string first character a digit range $$$ 1 $$$ $$$ 9 $$$ second character m p s. print a single integer — minimum number extra suit tile need draw first example tokitsukaze already a shuntsu second example tokitsukaze already a <unknown> third example tokitsukaze get a shuntsu draw one suit tile — 1p 4p result tile [ 3p 9 m 2p 1p ] [ 3p 9 m 2p 4p ],['implementation'],1200.0
1194/C,give three string $$$ s $$$ $$$ t $$$ $$$ p $$$ consist lowercase latin letter may perform number ( possibly zero ) operations string operation choose character $$$ p $$$ erase $$$ p $$$ insert string $$$ s $$$ ( may insert character anywhere want : begin $$$ s $$$ end two consecutive character ) example $$$ p $$$ aba $$$ s $$$ de follow outcomes possible ( character erase $$$ p $$$ insert $$$ s $$$ highlight ) : goal perform several ( maybe zero ) operations $$$ s $$$ become equal $$$ t $$$ please determine whether possible note answer $$$ q $$$ independent query first line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100 $$$ ) — number query query represent three consecutive line first line query contain string $$$ s $$$ ( $$$ 1 \le |s| \le 100 $$$ ) consist lowercase latin letter second line query contain string $$$ t $$$ ( $$$ 1 \le |t| \le 100 $$$ ) consist lowercase latin letter third line query contain string $$$ p $$$ ( $$$ 1 \le |p| \le 100 $$$ ) consist lowercase latin letter query print yes possible make $$$ s $$$ equal $$$ t $$$ otherwise may print every letter case want ( example string yes yes yes yes recognize positive answer ) first test case follow sequence operation : second test case follow sequence operation :,['implementation'],1300.0
1196/C,"$$$ n $$$ robots escape laboratory ! find soon possible robots experimental behavior test yet may really dangerous ! fortunately even though robots escape still control first know location robot : world live model infinite coordinate plane $$$ i $$$ -th robot currently locate point coordinate ( $$$ x_i $$$ $$$ y_i $$$ ) furthermore may send exactly one command robots command contain two integer number $$$ x $$$ $$$ y $$$ robot receive command start move towards point coordinate ( $$$ x $$$ $$$ y $$$ ) robot stop movement two case : normally robots able get point coordinate plane point robot usually perform four action move let 's denote current coordinate robot ( $$$ x_c $$$ $$$ y_c $$$ ) movement system allow move four adjacent point : unfortunately seem movement systems robots malfunction robot know action perform perform want send a command robots gather point , choose a pair integer number $$$ x $$$ $$$ y $$$ robot reach point ( $$$ x $$$ $$$ y $$$ ) possible find a point ? first line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100000 $$$ ) — number query $$$ q $$$ query follow query begin one line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number robots query $$$ n $$$ line follow $$$ i $$$ -th line describe $$$ i $$$ -th robot current query : contain six integer number $$$ x_i $$$ $$$ y_i $$$ $$$ f _ { i 1 } $$$ $$$ f _ { i 2 } $$$ $$$ f _ { i 3 } $$$ $$$ f _ { i 4 } $$$ ( $$$ -100000 \le x_i y_i \le 100000 $$$ $$$ 0 \le f _ { i j } \le 1 $$$ ) first two number describe initial location $$$ i $$$ -th robot follow four number describe action $$$ i $$$ -th robot use move ( $$$ f _ { i j } = 1 $$$ $$$ i $$$ -th robot use $$$ j $$$ -th action $$$ f _ { i j } = 0 $$$ use $$$ j $$$ -th action ) guarantee total number robots query exceed $$$ 100000 $$$ answer query independently order query appear input answer a query one follow :",['implementation'],1500.0
1196/D1,difference easy hard versions size input give a string $$$ s $$$ consist $$$ n $$$ character character ' r ' ' g ' ' b ' also give integer $$$ k $$$ task change minimum number character initial string $$$ s $$$ change a string length $$$ k $$$ a substring $$$ s $$$ also a substring infinite string ` ` rgbrgbrgb ... '' a string $$$ a $$$ a substring string $$$ b $$$ exist a positive integer $$$ i $$$ $$$ a_1 = b_i $$$ $$$ a_2 = b _ { i + 1 } $$$ $$$ a_3 = b _ { i + 2 } $$$ ... $$$ a _ { |a| } = b _ { i + |a| - 1 } $$$ example string ` ` gbrg '' ` ` b '' ` ` br '' substrings infinite string ` ` rgbrgbrgb ... '' ` ` gr '' ` ` rgr '' ` ` ggg '' answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 2000 $$$ ) — number query $$$ q $$$ query follow first line query contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 2000 $$$ ) — length string $$$ s $$$ length substring second line query contain a string $$$ s $$$ consist $$$ n $$$ character ' r ' ' g ' ' b ' guarantee sum $$$ n $$$ query exceed $$$ 2000 $$$ ( $$$ \sum n \le 2000 $$$ ) query print one integer — minimum number character need change initial string $$$ s $$$ change a substring length $$$ k $$$ $$$ s $$$ also a substring infinite string ` ` rgbrgbrgb ... '' first example change first character ' r ' obtain substring ` ` rg '' change second character ' r ' obtain ` ` br '' change third fourth fifth character ' b ' obtain ` ` gb '' second example substring ` ` brg '',['implementation'],1500.0
1196/E,give two integers $$$ b $$$ $$$ w $$$ a chessboard size $$$ 1000000000 \times 1000000000 $$$ top leave cell $$$ ( 1 ; 1 ) $$$ cell $$$ ( 1 ; 1 ) $$$ paint white task find a connect component chessboard contain exactly $$$ b $$$ black cells exactly $$$ w $$$ white cells two cells call connect share a side ( i.e cell $$$ ( x y ) $$$ four connect cells : $$$ ( x - 1 y ) ( x + 1 y ) ( x y - 1 ) ( x y + 1 ) $$$ ) a set cells call a connect component every pair cells $$$ c_1 $$$ $$$ c_2 $$$ set exist a sequence cells $$$ c_1 $$$ $$$ c_2 $$$ ... $$$ c_k $$$ $$$ c_1 = c_1 $$$ $$$ c_k = c_2 $$$ $$$ c_i $$$ $$$ 1 $$$ $$$ k $$$ belong set cells every $$$ i \in [ 1 k - 1 ] $$$ cells $$$ c_i $$$ $$$ c _ { i + 1 } $$$ connect obviously impossible find component case print ` ` '' otherwise print ` ` yes '' suitable connect component answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100000 $$$ ) — number query $$$ q $$$ query follow line query contain two integers $$$ b $$$ $$$ w $$$ ( $$$ 1 \le b w \le 100000 $$$ ) — number black cells require number white cells require guarantee sum number cells exceed $$$ 200000 $$$ ( $$$ \sum w + \sum b \le 200000 $$$ ) query print answer impossible find require component print ` ` '' first line otherwise print ` ` yes '' first line next $$$ b + w $$$ line print coordinate cells component order exactly $$$ b $$$ black cells $$$ w $$$ white cells answer print component connect several answer print coordinate answer range $$$ [ 1 ; 1000000000 ] $$$,['implementation'],1800.0
1198/D,a square grid size $$$ n \times n $$$ cells color black others color white one operation select rectangle color cells white cost $$$ \max ( h w ) $$$ color a rectangle size $$$ h \times w $$$ make cells white minimum total cost first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 50 $$$ ) — size square grid next $$$ n $$$ line contain a string length $$$ n $$$ consist character ' . ' ' # ' $$$ j $$$ -th character $$$ i $$$ -th line ' # ' cell coordinate $$$ ( i j ) $$$ black otherwise white print a single integer — minimum total cost paint cells white examples optimal solutions show picture,['dp'],2300.0
12/B,one cold winter even alice older brother bob sit home near <unknown> give interest problems solve alice 's turn tell number n bob say : — shuffle digits number order obtain smallest possible number without lead <unknown> problem ! — say bob immediately give answer alice say a random number n't know whether bob 's answer correct help find impatient brother wait verdict first line contain one integer n ( 0 ≤ n ≤ 109 ) without lead zero second line contain one integer m ( 0 ≤ m ≤ 109 ) — bob 's answer possibly lead zero print ok bob 's answer correct <unknown> otherwise,['implementation'],1100.0
12/C,spring come mean a lot fruit appear counter one sunny day little boy valera decide go shop make a list m fruit want buy valera want buy one fruit kind include list several time come fruit stall ashot saw seller n't distribute price tag goods put price tag counter later ashot attach every price tag kind fruit valera able count total price fruit list valera want know smallest total price ( case « lucky » distribution price tag ) largest total price ( case « unlucky » distribution price tag ) first line input contain two integer number n m ( 1 ≤ n m ≤ 100 ) — number price tag ( equal number different kinds fruit ashot sell ) number items valera 's list second line contain n space - separated positive integer number n't exceed 100 stand price one fruit kind follow m line contain name fruit list name a non - empty string small latin letter length n't exceed 32 . guarantee number distinct fruit list less equal n. also know seller stock fruit valera want buy print two number a b ( a ≤ b ) — minimum maximum possible sum valera may need buy fruit list,"['greedy', 'implementation']",1100.0
12/D,n ladies attend ball king 's palace every lady describe three value : beauty intellect richness king 's master <unknown> know ladies special creatures lady understand lady ball beautiful smarter rich jump window know value ladies want find many probable self - murderers ball let denote beauty i - th lady bi intellect ii richness ri i - th lady a probable self - <unknown> j - th lady bi < bj ii < ij ri < rj find number probable self - murderers first line contain one integer n ( 1 ≤ n ≤ 500000 ) second line contain n integer number bi separate single space third fourth line contain sequence ii ri format guarantee 0 ≤ bi ii ri ≤ 109 . output answer problem,['data structures'],2400.0
120/I,vasya collect transport ticket quite a collection contain several thousands tram trolleybus bus ticket vasya already feed traditional definition a lucky ticket thus 's look new perspectives besides vasya understand ticket divide lucky unlucky ones think ticket lucky different degrees give matter think vasya work definition a ticket 's degree luckiness let a ticket consist 2n digits let 's regard digit write show picture : see digits electronic clock : seven segment use show digits segment either color color segment form a digit vasya regard digits write way take right half ticket put one leave one first digit coincide n + 1 - th one second digit coincide n + 2 - th one ... n - th digit coincide 2n - th one pair digits put one another count number segment color digits summarize result number result value call degree luckiness a ticket example degree luckiness ticket 03 equal four degree luckiness ticket 2345 equal six give number a ticket contain 2n digits task find among ticket whose number exceed number ticket also consist 2n digits ticket whose degree luckiness exceed degrees luckiness give ticket moreover several ticket choose one smallest number first line contain number ticket consist k character ( k = 2n 1 ≤ n ≤ 105 ) print number seek ticket ` ` -1 '' ( without quote ) ticket exist,['greedy'],2200.0
1200/C,"amugae a large round corridor corridor consist two areas inner area equally divide $$$ n $$$ sectors outer area equally divide $$$ m $$$ sectors a wall exist pair sectors area ( inner outer ) wall inner area outer area a wall always exist 12 o'clock position inner area 's sectors denote $$$ ( 1,1 ) ( 1,2 ) \dots ( 1 n ) $$$ clockwise direction outer area 's sectors denote $$$ ( 2,1 ) ( 2,2 ) \dots ( 2 m ) $$$ manner a clear understand see example image amugae want know move one sector another sector $$$ q $$$ question question check move two give sectors first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \le n m \le 10^ { 18 } $$$ $$$ 1 \le q \le 10000 $$$ ) — number sectors inner area number sectors outer area number question next $$$ q $$$ line contain four integers $$$ s_x $$$ $$$ s_y $$$ $$$ e_x $$$ $$$ e_y $$$ ( $$$ 1 \le s_x e_x \le 2 $$$ ; $$$ s_x = 1 $$$ $$$ 1 \le s_y \le n $$$ otherwise $$$ 1 \le s_y \le m $$$ ; constraints $$$ e_y $$$ similar ) <unknown> want know possible move sector $$$ ( s_x s_y ) $$$ sector $$$ ( e_x e_y ) $$$ question print ` ` yes '' amugae move $$$ ( s_x s_y ) $$$ $$$ ( e_x e_y ) $$$ ` ` '' otherwise print letter case ( upper lower ) example show picture statement",['math'],1400.0
1203/B,give $$$ 4n $$$ stick length $$$ i $$$ -th stick $$$ a_i $$$ create $$$ n $$$ rectangles rectangle consist exactly $$$ 4 $$$ stick give set rectangle consist four side opposite side equal length angle right note stick use one rectangle stick use a side break stick use full length want rectangles equal area area rectangle side $$$ a $$$ $$$ b $$$ $$$ a \cdot b $$$ task say possible create exactly $$$ n $$$ rectangles equal area answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 500 $$$ ) — number query $$$ q $$$ query follow first line query contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number rectangles second line query contain $$$ 4n $$$ integers $$$ a_1 a_2 \dots a _ { 4n } $$$ ( $$$ 1 \le a_i \le 10000 $$$ ) $$$ a_i $$$ length $$$ i $$$ -th stick query print answer impossible create exactly $$$ n $$$ rectangles equal area use give stick print ` ` '' otherwise print ` ` yes '',"['greedy', 'math']",1200.0
1204/A,city saint petersburg a day last $$$ 2^ { 100 } $$$ minutes main station saint petersburg a train depart $$$ 1 $$$ minute $$$ 4 $$$ minutes $$$ 16 $$$ minutes ; word train depart time $$$ 4^k $$$ integer $$$ k \geq 0 $$$ team <unknown> arrive station time $$$ s $$$ try count many train miss ; word number train depart strictly time $$$ s $$$ example $$$ s = 20 $$$ miss train depart $$$ 1 $$$ $$$ 4 $$$ $$$ 16 $$$ one know time help ! note number $$$ s $$$ give a binary representation without lead zero first line contain a single binary number $$$ s $$$ ( $$$ 0 \leq s < 2^ { 100 } $$$ ) without lead zero output a single number — number train depart strictly time $$$ s $$$ first example $$$ <unknown> = 256 _ { 10 } $$$ miss train depart $$$ 1 $$$ $$$ 4 $$$ $$$ 16 $$$ $$$ 64 $$$ second example $$$ 101_2 = 5 _ { 10 } $$$ train depart $$$ 1 $$$ $$$ 4 $$$ third example explain statements,['math'],1000.0
1204/D1,difference easy hard versions length string hack problem solve problems kirk a binary string $$$ s $$$ ( a string consist zero ones ) length $$$ n $$$ ask find a binary string $$$ t $$$ length satisfy follow condition : a non - decreasing subsequence a string $$$ p $$$ a sequence indices $$$ i_1 i_2 \ldots i_k $$$ $$$ i_1 < i_2 < \ldots < i_k $$$ $$$ p _ { i_1 } \leq p _ { i_2 } \leq \ldots \leq p _ { i_k } $$$ length subsequence $$$ k $$$ multiple substrings satisfy condition output first line contain a binary string length $$$ 2\ : 000 $$$ output a binary string satisfy condition many string output first example : second example similar first one,['greedy'],2000.0
1205/F,"define beauty a permutation number $$$ 1 $$$ $$$ n $$$ $$$ ( p_1 p_2 \dots p_n ) $$$ number pair $$$ ( l r ) $$$ $$$ 1 \le l \le r \le n $$$ number $$$ p_l p _ { l+1 } \dots p_r $$$ consecutive $$$ r - l+1 $$$ number order example beauty permutation $$$ ( 1 2 5 3 4 ) $$$ equal $$$ 9 $$$ segment correspond pair $$$ [ 1 ] $$$ $$$ [ 2 ] $$$ $$$ [ 5 ] $$$ $$$ [ 4 ] $$$ $$$ [ 3 ] $$$ $$$ [ 1 2 ] $$$ $$$ [ 3 4 ] $$$ $$$ [ 5 3 4 ] $$$ $$$ [ 1 2 5 3 4 ] $$$ answer $$$ q $$$ independent query query give integers $$$ n $$$ $$$ k $$$ determine exist a permutation number $$$ 1 $$$ $$$ n $$$ beauty equal $$$ k $$$ exist output one first line contain a single integer $$$ q $$$ ( $$$ 1\le q \le 10\,000 $$$ ) — number query follow $$$ q $$$ line line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100 $$$ $$$ 1 \le k \le \frac { n ( n+1 ) } { 2 } $$$ ) — length permutation need beauty respectively a query output ` ` '' a permutation n't exist otherwise output ` ` yes '' next line output $$$ n $$$ number — elements permutation right order let 's look first example first query : $$$ ( 1 ) $$$ one segment consist consecutive number — entire permutation second query : $$$ ( 2 4 1 5 3 ) $$$ $$$ 6 $$$ segment : $$$ [ 2 ] $$$ $$$ [ 4 ] $$$ $$$ [ 1 ] $$$ $$$ [ 5 ] $$$ $$$ [ 3 ] $$$ $$$ [ 2 4 1 5 3 ] $$$ permutation second query fourth query : $$$ ( 2 3 1 4 5 ) $$$ $$$ 10 $$$ segment : $$$ [ 2 ] $$$ $$$ [ 3 ] $$$ $$$ [ 1 ] $$$ $$$ [ 4 ] $$$ $$$ [ 5 ] $$$ $$$ [ 2 3 ] $$$ $$$ [ 2 3 1 ] $$$ $$$ [ 2 3 1 4 ] $$$ $$$ [ 4 5 ] $$$ $$$ [ 2 3 1 4 5 ] $$$",['math'],3400.0
1207/A,two type burgers restaurant — hamburgers chicken burgers ! assemble a hamburger need two buns a beef patty assemble a chicken burger need two buns a chicken cutlet $$$ b $$$ buns $$$ p $$$ beef patties $$$ f $$$ chicken cutlets restaurant sell one hamburger $$$ h $$$ dollars one chicken burger $$$ c $$$ dollars calculate maximum profit achieve answer $$$ t $$$ independent query first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) – number query first line query contain three integers $$$ b $$$ $$$ p $$$ $$$ f $$$ ( $$$ 1 \le b <unknown> <unknown> \le 100 $$$ ) — number buns beef patties chicken cutlets restaurant second line query contain two integers $$$ h $$$ $$$ c $$$ ( $$$ 1 \le h <unknown> \le 100 $$$ ) — hamburger chicken burger price restaurant query print one integer — maximum profit achieve first query sell two hamburgers three chicken burgers income $$$ 10 + 30 = 40 $$$ second query <unknown> one hamburgers two chicken burgers income $$$ 10 + 24 = 34 $$$ third query create type burgers one bun income zero,"['greedy', 'implementation', 'math']",800.0
1209/G1,"easier version next problem version $$$ q = 0 $$$ a sequence integers call nice elements arrange block like $$$ [ 3 3 3 4 1 1 ] $$$ formally two elements equal everything must also equal let 's define difficulty a sequence a minimum possible number elements change get a nice sequence however change least one element value $$$ x $$$ value $$$ y $$$ must also change elements value $$$ x $$$ $$$ y $$$ well example $$$ [ 3 3 1 3 2 1 2 ] $$$ n't allow change first $$$ 1 $$$ $$$ 3 $$$ second $$$ 1 $$$ $$$ 2 $$$ need leave $$$ 1 $$$ 's untouched change value give a sequence integers $$$ a_1 a_2 \ldots a_n $$$ $$$ q $$$ update update form ` ` $$$ i $$$ $$$ x $$$ ` ` — change $$$ a_i $$$ $$$ x $$$ update independent ( change stay future ) print difficulty initial sequence sequence every update first line contain integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n \le 200\,000 $$$ $$$ q = 0 $$$ ) length sequence number update second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 200\,000 $$$ ) initial sequence follow $$$ q $$$ line contain integers $$$ i_t $$$ $$$ x_t $$$ ( $$$ 1 \le i_t \le n $$$ $$$ 1 \le x_t \le 200\,000 $$$ ) position new value position print $$$ q+1 $$$ integers answer initial sequence answer every update","['data structures', 'greedy', 'implementation']",2000.0
1209/H,"airports often use move walkways help walk big distance faster walkway speed effectively increase speed stand a walkway let move could also walk effective speed walk speed plus walkway 's speed limak want get point $$$ 0 $$$ point $$$ l $$$ a straight line $$$ n $$$ disjoint walkways $$$ i $$$ -th walkway describe two integers $$$ x_i $$$ $$$ y_i $$$ a real value $$$ s_i $$$ $$$ i $$$ -th walkway start $$$ x_i $$$ end $$$ y_i $$$ speed $$$ s_i $$$ every walkway locate inside segment $$$ [ 0 l ] $$$ two walkways positive intersection however touch endpoints limak need decide distribute energy example might make sense stand somewhere ( walk slowly ) a lot energy walk faster limak 's initial energy $$$ 0 $$$ must never drop value moment walk speed $$$ v $$$ interval $$$ [ 0 2 ] $$$ cost $$$ v $$$ energy per second continuously recover energy speed $$$ 1 $$$ energy per second , walk speed $$$ v $$$ energy increase $$$ ( 1 - v ) $$$ note negative value would mean lose energy particular walk speed $$$ 1 $$$ wo n't change energy walk speed $$$ <unknown> $$$ effectively give $$$ <unknown> $$$ energy per second limak choose speed arbitrarily ( real value interval $$$ [ 0 2 ] $$$ ) every moment time ( include moments locate non - integer position ) everything continuous ( non - discrete ) fastest time limak get $$$ 0 $$$ $$$ l $$$ ? first line contain integers $$$ n $$$ $$$ l $$$ ( $$$ 1 \le n \le 200\,000 $$$ $$$ 1 \le l \le 1000000000 $$$ ) number walkways distance walk next $$$ n $$$ line contain integers $$$ x_i $$$ $$$ y_i $$$ real value $$$ s_i $$$ ( $$$ 0 \le x_i < y_i \le l $$$ $$$ 0.1 \le s_i \le <unknown> $$$ ) value $$$ s_i $$$ give $$$ 9 $$$ digits decimal point 's guarantee two walkways a positive intersection walkways list leave right , $$$ y_i \le x _ { i + 1 } $$$ $$$ 1 \le i \le n - 1 $$$ print one real value fastest possible time reach $$$ l $$$ answer consider correct absolute relative error wo n't exceed $$$ 10^ { -9 } $$$ draw show first two examples first one a walkway $$$ 0 $$$ $$$ 2 $$$ speed $$$ <unknown> $$$ limak want get point $$$ 5 $$$ second example a walkway $$$ 2 $$$ $$$ 4 $$$ speed $$$ <unknown> $$$ first example one optimal strategies follow total time $$$ 1 + 1 + 1 = 3 $$$","['data structures', 'greedy', 'math']",3300.0
1210/B,marcin a coach university $$$ n $$$ students want attend a train camp marcin a smart coach want send students work calmly let 's focus students index integers $$$ 1 $$$ $$$ n $$$ describe two integers $$$ a_i $$$ $$$ b_i $$$ ; $$$ b_i $$$ equal skill level $$$ i $$$ -th student ( higher better ) also $$$ 60 $$$ know algorithms number integers $$$ 0 $$$ $$$ 59 $$$ $$$ i $$$ -th student know $$$ j $$$ -th algorithm $$$ j $$$ -th bite ( $$$ 2^j $$$ ) set binary representation $$$ a_i $$$ otherwise bite set student $$$ x $$$ think better student $$$ y $$$ $$$ x $$$ know algorithm $$$ y $$$ n't know note two students think better a group students work together calmly student group think better everyone else group marcin want send a group least two students work together calmly maximum possible sum skill level sum ? first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 7000 $$$ ) — number students interest camp second line contain $$$ n $$$ integers $$$ i $$$ -th $$$ a_i $$$ ( $$$ 0 \leq a_i < 2^ { 60 } $$$ ) third line contain $$$ n $$$ integers $$$ i $$$ -th $$$ b_i $$$ ( $$$ 1 \leq b_i \leq 1000000000 $$$ ) output one integer denote maximum sum $$$ b_i $$$ students a group students work together calmly group least two students work together calmly print 0 . first sample test 's optimal send first second third student camp 's also possible send first third student 'd a lower sum $$$ b_i $$$ second test group least two students someone always think better everyone else subset,['greedy'],1700.0
1211/A,"polycarp choose three problems create a program test totally $$$ n $$$ problems list complexity $$$ i $$$ -th problem equal $$$ r_i $$$ problems numerate $$$ 1 $$$ $$$ n $$$ help polycarp choose three problems $$$ a $$$ $$$ b $$$ $$$ c $$$ complexity first problem strictly less complexity second problem complexity second problem strictly less complexity third problem , choose problems $$$ a $$$ $$$ b $$$ $$$ c $$$ true $$$ r_a < r_b < r_c $$$ polycarp choose three problems different ways print first line input contain one integer $$$ n $$$ ( $$$ 3 \le n \le 3000 $$$ ) — number problems polycarp 's list second line input contain $$$ n $$$ integers $$$ r_1 r_2 \dots r_n $$$ ( $$$ 1 \le r_i \le 1000000000 $$$ ) $$$ r_i $$$ complexity $$$ i $$$ -th problem polycarp ways choose three problems print three number -1 . ih a way choose print three different integers $$$ a b c $$$ ( $$$ 1 \le a b c \le n $$$ ) $$$ a $$$ number first choose problem $$$ b $$$ number second choose problem $$$ c $$$ number third choose problem",['implementation'],1000.0
1211/F,polycarp really like write word ` ` kotlin '' write word several time a row without space example could write string like ` ` <unknown> '' polycarp slice ( cut ) write string $$$ n $$$ piece mix a result $$$ n $$$ string $$$ s_1 s_2 \dots s_n $$$ arrange right order concatenate ( join ) get a string like ` ` kotlinkotlin ... kotlin '' help polycarp find right order string $$$ s_1 s_2 \dots s_n $$$ write string order get word ` ` kotlin '' sequence word pay attention must use give string must use string first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number polycarp 's string next line input contain $$$ n $$$ polycarp 's string total sum lengths n't exceed $$$ 3\cdot100000 $$$ 's guarantee right order arrangement string concatenate one string get non - empty sequence word ` ` kotlin '' print $$$ n $$$ different integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) $$$ p_i $$$ index string $$$ i $$$ -th a require concatenation word result concatenation $$$ s _ { p_1 } + s _ { p_2 } + <unknown> _ { p_n } $$$ must form ` ` kotlinkotlin ... kotlin '' many solutions print,['implementation'],2300.0
1213/A,give $$$ n $$$ chip a number line $$$ i $$$ -th chip place integer coordinate $$$ x_i $$$ chip equal coordinate perform two follow type move ( possibly zero ) number time chip : note 's allow move chip integer coordinate include negative zero task find minimum total number coin require move $$$ n $$$ chip coordinate ( i.e $$$ x_i $$$ equal sequence move ) first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number chip second line input contain $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ 1 \le x_i \le 1000000000 $$$ ) $$$ x_i $$$ coordinate $$$ i $$$ -th chip print one integer — minimum total number coin require move $$$ n $$$ chip coordinate first example need move first chip $$$ 2 $$$ right second chip $$$ 1 $$$ right move third chip $$$ 2 $$$ leave second chip $$$ 1 $$$ leave answer $$$ 1 $$$ second example need move two chip coordinate $$$ 3 $$$ $$$ 1 $$$ leave answer $$$ 2 $$$,['math'],900.0
1213/D1,difference easy hard versions number elements array give array $$$ a $$$ consist $$$ n $$$ integers one move choose $$$ a_i $$$ divide $$$ 2 $$$ round ( word one move set $$$ a_i : = \lfloor\frac { a_i } { 2 } \rfloor $$$ ) perform operation ( possibly zero ) number time $$$ a_i $$$ task calculate minimum possible number operations require obtain least $$$ k $$$ equal number array n't forget possible $$$ a_i = 0 $$$ operations thus answer always exist first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 50 $$$ ) — number elements array number equal number require second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 200000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ print one integer — minimum possible number operations require obtain least $$$ k $$$ equal number array,['implementation'],1500.0
1215/A,"final match berland football cup hold recently referee show $$$ n $$$ yellow card throughout match begin match $$$ a_1 $$$ players first team $$$ a_2 $$$ players second team rule send players game a bite different berland football a player first team receive $$$ k_1 $$$ yellow card throughout match longer participate match — 's send a player second team receive $$$ k_2 $$$ yellow card 's send a player leave match longer receive yellow card $$$ n $$$ yellow card show exactly one player even players one team ( even team ) leave match game still continue referee lose record receive yellow card help determine minimum maximum number players could throw game first line contain one integer $$$ a_1 $$$ $$$ ( 1 \le a_1 \le 1\,000 ) $$$ — number players first team second line contain one integer $$$ a_2 $$$ $$$ ( 1 \le a_2 \le 1\,000 ) $$$ — number players second team third line contain one integer $$$ k_1 $$$ $$$ ( 1 \le k_1 \le 1\,000 ) $$$ — maximum number yellow card a player first team receive ( receive many yellow card leave game ) fourth line contain one integer $$$ k_2 $$$ $$$ ( 1 \le k_2 \le 1\,000 ) $$$ — maximum number yellow card a player second team receive ( receive many yellow card leave game ) fifth line contain one integer $$$ n $$$ $$$ ( 1 \le n \le a_1 \cdot k_1 + a_2 \cdot k_2 ) $$$ — number yellow card show match print two integers — minimum maximum number players could throw game first example could possible player leave game first number output $$$ 0 $$$ maximum possible number players could force leave game $$$ 4 $$$ — one player first team three players second second example maximum possible number yellow card show $$$ ( 3 \cdot 6 + 7 = 25 ) $$$ case players send","['greedy', 'implementation', 'math']",1000.0
1215/D,monocarp bicarp live berland every bus ticket consist $$$ n $$$ digits ( $$$ n $$$ even number ) even walk monocarp bicarp find a ticket digits erase number digits erase even monocarp bicarp decide play a game ticket monocarp hat happy ticket bicarp collect a ticket consider happy sum first $$$ \frac { n } { 2 } $$$ digits ticket equal sum last $$$ \frac { n } { 2 } $$$ digits monocarp bicarp take turn ( monocarp perform first ) turn current player must replace erase digit digit $$$ 0 $$$ $$$ 9 $$$ game end erase digits ticket ticket happy erase digits replace decimal digits bicarp win otherwise monocarp win determine win players play optimally first line contain one even integer $$$ n $$$ $$$ ( 2 \le n \le 2 \cdot 10^ { 5 } ) $$$ — number digits ticket second line contain a string $$$ n $$$ digits ` ` ? '' character — ticket monocarp bicarp find $$$ i $$$ -th character ` ` ? ` ` $$$ i $$$ -th digit erase note may lead zero number ` ` ? '' character even monocarp win print ` ` monocarp '' ( without quote ) otherwise print ` ` bicarp '' ( without quote ) since question mark ticket first example winner determine game even start bicarp second example bicarp also win monocarp choose erase digit replace a new one <unknown> choose another position erase digit replace digit ticket happy,"['greedy', 'math']",1700.0
1216/F,work a system administrator a dormitory $$$ n $$$ room one another along a straight hallway room number $$$ 1 $$$ $$$ n $$$ connect $$$ n $$$ room internet connect room internet directly cost connection $$$ i $$$ -th room $$$ i $$$ coin room also a spot a router cost place a router $$$ i $$$ -th room also $$$ i $$$ coin place a router a room a spot place a router room $$$ i $$$ connect room number $$$ max ( 1 ~i - k ) $$$ $$$ min ( n ~i + k ) $$$ inclusive internet $$$ k $$$ range router value $$$ k $$$ routers calculate minimum total cost connect $$$ n $$$ room internet assume number room a spot a router greater number routers first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 200000 $$$ ) — number room range router second line input contain one string $$$ s $$$ length $$$ n $$$ consist zero ones $$$ i $$$ -th character string equal ' 1 ' a spot a router $$$ i $$$ -th room $$$ i $$$ -th character string equal ' 0 ' place a router $$$ i $$$ -th room print one integer — minimum total cost connect $$$ n $$$ room internet first example enough place router room $$$ 3 $$$ room connect internet total cost connection $$$ 3 $$$ second example place routers nowhere need connect room directly thus total cost connection room $$$ 1 + 2 + 3 + 4 + 5 + 6 = 21 $$$ third example need connect room $$$ 1 $$$ directly place router room $$$ 3 $$$ thus total cost connection room $$$ 1 + 3 = 4 $$$ fourth example need place routers room $$$ 5 $$$ $$$ 10 $$$ room connect internet total cost connection $$$ 5 + 10 = 15 $$$,"['data structures', 'dp', 'greedy']",2100.0
1219/G,bubble cup finals season farmer johnny bubble must harvest bubble bubble a rectangular bubblefield form $$$ n $$$ x $$$ m $$$ square parcel divide $$$ n $$$ row $$$ m $$$ columns parcel $$$ i^ { th } $$$ row $$$ j^ { th } $$$ column yield $$$ a _ { i j } $$$ bubble johnny bubble available a special self - <unknown> bubble harvester manually position begin a row column automatically harvest bubble row column harvester reach end row column stop must <unknown> harvester pass parcel number time collect bubble parcel johnny busy farmer available manually position harvester four time per day johnny also impatient want harvest many bubble possible first day please help johnny calculate maximum number bubble collect first day first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 $$$ $$$ \leq $$$ $$$ n $$$ $$$ m $$$ $$$ \leq $$$ $$$ n $$$ * $$$ m $$$ $$$ \leq $$$ $$$ 10^ { 5 } $$$ ) - bubblefield size next $$$ n $$$ line contain $$$ m $$$ integers $$$ j^ { th } $$$ element $$$ i^ { th } $$$ line $$$ a _ { i j } $$$ ( $$$ 0 $$$ $$$ \leq $$$ $$$ a _ { i j } $$$ $$$ \leq $$$ $$$ 10^ { 9 } $$$ ) — yield parcel locate $$$ i^ { th } $$$ row $$$ j^ { th } $$$ column output contain one integer number - maximum number bubble johnny harvest first day first example farmer johnny harvest bubble position harvester first second row second example one way johnny harvest maximum number bubble position harvester second row fourth row second column fourth column,['implementation'],2000.0
1220/A,serezha three years old give a set card letter birthday arrange word way form boy 's mother favorite number binary notation serezha start play immediately shuffle n't yet able read father decide rearrange help restore original number condition maximum possible one first line contain a single integer $$$ n $$$ ( $$$ 1 \leqslant n \leqslant 100000 $$$ ) — length string second line contain a string consist english lowercase letter : ' z ' ' e ' ' r ' ' o ' ' n ' guarantee possible rearrange letter a way form a sequence word either ` ` zero '' correspond digit $$$ 0 $$$ ` ` one '' correspond digit $$$ 1 $$$ print maximum possible number binary notation print binary digits separate a space lead zero allow first example correct initial order ` ` zero '' second example correct initial order ` ` <unknown> '',['implementation'],800.0
1221/C,may already know a standard icpc team consist exactly three members perfect team however restrictions a student specialization : coder mathematician she / he specialization ca n't time team consider perfect include least one coder least one mathematician consist exactly three members a coach a large university know $$$ c $$$ students coders $$$ m $$$ mathematicians $$$ x $$$ specialization maximum number full perfect team distribute ? note students leave without a team student a part one team also ask answer $$$ q $$$ independent query first line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 10000 $$$ ) — number query next $$$ q $$$ line contain three integers $$$ c $$$ $$$ m $$$ $$$ x $$$ ( $$$ 0 \le c m x \le 100000000 $$$ ) — number coders mathematicians students without specialization university respectively note student coder mathematician time print $$$ q $$$ integers — $$$ i $$$ -th answer $$$ i $$$ query order give input answer maximum number full perfect team distribute students first example team form :,['math'],1200.0
1221/D,a fence consist $$$ n $$$ vertical board width board $$$ 1 $$$ height $$$ i $$$ -th board $$$ a_i $$$ think fence great pair adjacent board height formally fence great indices $$$ 2 $$$ $$$ n $$$ condition $$$ a _ { i-1 } \neq a_i $$$ hold unfortunately possible fence great change ! increase length $$$ i $$$ -th board $$$ 1 $$$ pay $$$ b_i $$$ rubles length board increase number time ( possibly zero ) calculate minimum number rubles spend make fence great ! answer $$$ q $$$ independent query first line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 300000 $$$ ) — number query first line query contain one integers $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) — number board fence follow $$$ n $$$ line query contain descriptions board $$$ i $$$ -th line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le 1000000000 $$$ ) — length $$$ i $$$ -th board price increase $$$ 1 $$$ respectively guarantee sum $$$ n $$$ query exceed $$$ 300000 $$$ guarantee answer query exceed $$$ 10^ { 18 } $$$ query print one integer — minimum number rubles spend make fence great first query increase length second board $$$ 2 $$$ total cost $$$ 2 \cdot b_2 = 2 $$$ second query increase length first board $$$ 1 $$$ length third board $$$ 1 $$$ total cost $$$ 1 \cdot b_1 + 1 \cdot b_3 = 9 $$$ third query fence great initially n't need spend rubles,['dp'],1800.0
1221/F,petya recently find a game ` ` choose a square '' game $$$ n $$$ point number $$$ 1 $$$ $$$ n $$$ infinite field $$$ i $$$ -th point coordinate $$$ ( x_i y_i ) $$$ cost $$$ c_i $$$ choose a square side parallel coordinate ax lower leave upper right corner belong line $$$ y = x $$$ corner integer coordinate score get sum cost point cover select square minus length side square note length side zero petya ask calculate maximum possible score game achieve place exactly one square first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) — number point field follow $$$ n $$$ line contain three integers $$$ x_i y_i c_i $$$ ( $$$ 0 \le x_i y_i \le 1000000000 -1000000 \le c_i \le 1000000 $$$ ) — coordinate $$$ i $$$ -th point cost respectively first line print maximum score petya achieve second line print four integers $$$ x_1 y_1 x_2 y_2 $$$ ( $$$ 0 \le x_1 y_1 x_2 y_2 \le 2 \cdot 1000000000 x_1 = y_1 x_2 = y_2 x_1 \le x_2 $$$ ) separate space — coordinate lower leave upper right corner square petya select order achieve maximum score field correspond first example :,['data structures'],2400.0
1225/A,"kolya absent - minded today math teacher ask solve a simple problem equation $$$ a + 1 = b $$$ positive integers $$$ a $$$ $$$ b $$$ kolya forget number $$$ a $$$ $$$ b $$$ , however remember first ( leftmost ) digit $$$ a $$$ $$$ d_a $$$ first ( leftmost ) digit $$$ b $$$ $$$ d_b $$$ reconstruct equation $$$ a + 1 = b $$$ satisfy property ? may possible kolya <unknown> digits suitable equation case report line contain two space - separated digits $$$ d_a $$$ $$$ d_b $$$ ( $$$ 1 \leq d_a d_b \leq 9 $$$ ) equation $$$ a + 1 = b $$$ positive integers $$$ a $$$ $$$ b $$$ first digit $$$ a $$$ $$$ d_a $$$ first digit $$$ b $$$ $$$ d_b $$$ print a single number $$$ -1 $$$ otherwise print suitable $$$ a $$$ $$$ b $$$ positive exceed $$$ 1000000000 $$$ guarantee a solution exist also exist a solution number exceed $$$ 1000000000 $$$",['math'],900.0
1225/C,vasya fancy number long integer power two petya hand <unknown> like a single integer $$$ p $$$ ( may positive negative zero ) combine taste invent $$$ p $$$ -binary number form $$$ 2^x + p $$$ $$$ x $$$ a non - negative integer example $$$ -9 $$$ -binary ( ` ` minus nine '' binary ) number : $$$ -8 $$$ ( minus eight ) $$$ 7 $$$ $$$ 1015 $$$ ( $$$ <unknown> ^ 0 - 9 $$$ $$$ <unknown> ^ 4 - 9 $$$ $$$ <unknown> { 10 } -9 $$$ ) boys use $$$ p $$$ -binary number represent everything face a problem : give a positive integer $$$ n $$$ 's smallest number $$$ p $$$ -binary number ( necessarily distinct ) need represent $$$ n $$$ sum ? may possible representation impossible altogether help solve problem example $$$ <unknown> $$$ represent $$$ 7 $$$ $$$ 2 ^ 0 + 2 ^ 1 + 2 ^ 2 $$$ $$$ <unknown> $$$ represent $$$ 7 $$$ one number $$$ ( 2 ^ 4 - 9 ) $$$ note negative $$$ p $$$ -binary number allow sum ( see note section example ) line contain two integers $$$ n $$$ $$$ p $$$ ( $$$ 1 \leq n \leq 1000000000 $$$ $$$ -1000 \leq p \leq 1000 $$$ ) impossible represent $$$ n $$$ sum number $$$ p $$$ -binary number print a single integer $$$ -1 $$$ otherwise print smallest possible number summands $$$ 0 $$$ -binary number regular binary power thus first sample case represent $$$ 24 = ( 2 ^ 4 + 0 ) + ( 2 ^ 3 + 0 ) $$$ second sample case represent $$$ 24 = ( 2 ^ 4 + 1 ) + ( 2 ^ 2 + 1 ) + ( 2 ^ 0 + 1 ) $$$ third sample case represent $$$ 24 = ( 2 ^ 4 - 1 ) + ( 2 ^ 2 - 1 ) + ( 2 ^ 2 - 1 ) + ( 2 ^ 2 - 1 ) $$$ note repeat summands allow fourth sample case represent $$$ 4 = ( 2 ^ 4 - 7 ) + ( 2 ^ 1 - 7 ) $$$ note second summand negative allow fifth sample case representation possible,['math'],1600.0
1225/E,"top leave cell $$$ ( 1 1 ) $$$ $$$ n \times m $$$ labyrinth goal get bottom right cell $$$ ( n m ) $$$ move right one cell per step move right a cell $$$ ( x y ) $$$ take cell $$$ ( x y + 1 ) $$$ move take cell $$$ ( x + 1 y ) $$$ cells labyrinth contain rock move a cell rock rock push next cell direction 're move next cell contain a rock get push , labyrinth surround impenetrable wall thus move would put rock outside labyrinth illegal count number different legal paths take start goal modulo $$$ 1000000000 + 7 $$$ two paths consider different least one cell visit one path visit first line contain two integers $$$ n m $$$ — dimension labyrinth ( $$$ 1 \leq n m \leq 2000 $$$ ) next $$$ n $$$ line describe labyrinth line contain $$$ m $$$ character $$$ j $$$ -th character $$$ i $$$ -th line equal ` ` r '' cell $$$ ( i j ) $$$ contain a rock ` ` . '' cell $$$ ( i j ) $$$ empty guarantee start cell $$$ ( 1 1 ) $$$ empty print a single integer — number different legal paths $$$ ( 1 1 ) $$$ $$$ ( n m ) $$$ modulo $$$ 1000000000 + 7 $$$ first sample case ca n't ( n't ) move hence path consist a single cell $$$ ( 1 1 ) $$$ second sample case goal block unreachable illustrations third sample case find : https : //assets.codeforces.com / <unknown> / <unknown>",['dp'],2200.0
1225/F,"<unknown> tree factory produce tree kinds industrial applications task optimize production a certain type tree especially large important order tree question a root tree $$$ n $$$ vertices label distinct integers $$$ 0 $$$ $$$ n - 1 $$$ vertex label $$$ 0 $$$ root tree non - root vertex $$$ v $$$ label parent $$$ p ( v ) $$$ less label $$$ v $$$ tree factory make bamboo blank a bamboo a root tree vertex exactly one child except a single leaf vertex children vertices a bamboo blank label arbitrarily process start process a bamboo another tree a single type operation make : choose arbitrary non - root vertex $$$ v $$$ parent $$$ p ( v ) $$$ a root either operation consist change parent $$$ v $$$ parent 's parent $$$ p ( p ( v ) ) $$$ note parent vertices remain unchanged particular subtree $$$ v $$$ change efficiency crucial hence minimize number operations make desire tree a bamboo blank construct optimal sequence operations produce desire tree note label result tree coincide label desire tree formally label root equal non - root vertices label label parent guarantee test present problem answer exist , optimal sequence contain $$$ 1000000 $$$ operations note hack meet condition invalid first line contain a single integer $$$ n $$$ — number vertices tree ( $$$ 2 \leq n \leq 100000 $$$ ) second line contain $$$ n - 1 $$$ integers $$$ p ( 1 ) \ldots p ( n - 1 ) $$$ — indices parent vertices $$$ 1 \ldots n - 1 $$$ respectively ( $$$ 0 \leq p ( i ) < i $$$ ) first line print $$$ n $$$ distinct integers $$$ id_1 \ldots id_n $$$ — initial label bamboo blank start root vertex ( $$$ 0 \leq id_i < n $$$ ) second line print a single integer $$$ k $$$ — number operations sequence ( $$$ 0 \leq k \leq 1000000 $$$ ) third line print $$$ k $$$ integers $$$ v_1 \ldots v_k $$$ describe operations order $$$ i $$$ -th operation consist change $$$ p ( v_i ) $$$ $$$ p ( p ( v_i ) ) $$$ operation valid i.e neither $$$ v_i $$$ $$$ p ( v_i ) $$$ root tree moment",['greedy'],2500.0
1227/D1,"easier version problem version $$$ 1 \le n m \le 100 $$$ hack problem solve lock problems give a sequence integers $$$ a= [ a_1 a_2 \dots a_n ] $$$ length $$$ n $$$ subsequence obtain remove zero elements sequence $$$ a $$$ ( necessarily go consecutively ) example sequence $$$ a= [ 11,20,11,33,11,20,11 ] $$$ : suppose additional non - negative integer $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) give subsequence call optimal : recall sequence $$$ b= [ b_1 b_2 \dots b_k ] $$$ lexicographically smaller sequence $$$ c= [ c_1 c_2 \dots c_k ] $$$ first element ( leave ) differ less sequence $$$ b $$$ $$$ c $$$ formally : exist $$$ t $$$ ( $$$ 1 \le t \le k $$$ ) $$$ b_1 = c_1 $$$ $$$ b_2 = c_2 $$$ ... $$$ b _ { t-1 } = c _ { t-1 } $$$ time $$$ b_t < c_t $$$ example : give a sequence $$$ a= [ a_1 a_2 \dots a_n ] $$$ $$$ m $$$ request consist two number $$$ k_j $$$ $$$ pos_j $$$ ( $$$ 1 \le k \le n $$$ $$$ 1 \le pos_j \le k_j $$$ ) query print value index $$$ pos_j $$$ optimal subsequence give sequence $$$ a $$$ $$$ k = k_j $$$ example $$$ n=4 $$$ $$$ a= [ 10,20,30,20 ] $$$ $$$ k_j=2 $$$ optimal subsequence $$$ [ 20,30 ] $$$ — minimum lexicographically among subsequences length $$$ 2 $$$ maximum total sum items thus answer request $$$ k_j=2 $$$ $$$ pos_j=1 $$$ number $$$ 20 $$$ answer request $$$ k_j=2 $$$ $$$ pos_j=2 $$$ number $$$ 30 $$$ first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — length sequence $$$ a $$$ second line contain elements sequence $$$ a $$$ : integer number $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) third line contain integer $$$ m $$$ ( $$$ 1 \le m \le 100 $$$ ) — number request follow $$$ m $$$ line contain pair integers $$$ k_j $$$ $$$ pos_j $$$ ( $$$ 1 \le k \le n $$$ $$$ 1 \le pos_j \le k_j $$$ ) — request print $$$ m $$$ integers $$$ r_1 r_2 \dots r_m $$$ ( $$$ 1 \le r_j \le 1000000000 $$$ ) one per line : answer request order appear input value $$$ r_j $$$ equal value contain position $$$ pos_j $$$ optimal subsequence $$$ k = k_j $$$ first example $$$ a= [ 10,20,10 ] $$$ optimal subsequences :","['data structures', 'greedy']",1600.0
1228/A,two integers $$$ l $$$ $$$ r $$$ find integer $$$ x $$$ satisfy condition : multiple answer print first line contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \le l \le r \le 10^ { 5 } $$$ ) answer exist print otherwise print $$$ -1 $$$ first example $$$ 123 $$$ one possible answer however $$$ 121 $$$ ca n't answer multiple $$$ 1 $$$ s different digits second example valid answer,['implementation'],800.0
1228/D,a simple undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge graph n't contain self - loops one edge a pair vertices give graph disconnect let 's make a definition let $$$ v_1 $$$ $$$ v_2 $$$ two nonempty subsets vertices intersect let $$$ f ( v _ { 1 } v _ { 2 } ) $$$ true condition satisfy : create three vertex set ( $$$ v _ { 1 } $$$ $$$ v _ { 2 } $$$ $$$ v _ { 3 } $$$ ) satisfy condition ; possible create three vertex set ? 's possible print match vertex set vertex first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 3 \le n \le 10^ { 5 } $$$ $$$ 0 \le m \le \text { min } ( 3 \cdot 10^ { 5 } \frac { n ( n-1 ) } { 2 } ) $$$ ) — number vertices edge graph $$$ i $$$ -th next $$$ m $$$ line contain two integers $$$ a _ { i } $$$ $$$ b _ { i } $$$ ( $$$ 1 \le a _ { i } \lt b _ { i } \le n $$$ ) — mean edge $$$ a _ { i } $$$ $$$ b _ { i } $$$ graph n't contain self - loops one edge a pair vertices give graph disconnect answer exist print $$$ n $$$ integers $$$ i $$$ -th integer mean vertex set number ( $$$ 1 $$$ $$$ 3 $$$ ) $$$ i $$$ -th vertex otherwise print $$$ -1 $$$ multiple answer print first example $$$ v _ { 1 } = \ { 1 \ } $$$ $$$ v _ { 2 } = \ { 2 3 \ } $$$ $$$ v _ { 3 } = \ { 4 5 6 \ } $$$ vertex set satisfy condition assign vertices vertex set a different way ; answer like ` ` 2 3 3 1 1 1 '' accept well second example 's impossible make vertex set,['implementation'],1900.0
1234/B1,difference easy hard versions constraints $$$ n $$$ $$$ k $$$ message one popular social network via smartphone smartphone show $$$ k $$$ recent conversations friends initially screen empty ( i.e number display conversations equal $$$ 0 $$$ ) conversation friends one conversation friends conversation uniquely define friend ( suddenly ! ) ability see future know day receive $$$ n $$$ message $$$ i $$$ -th message receive friend i d $$$ id_i $$$ ( $$$ 1 \le id_i \le 1000000000 $$$ ) receive a message $$$ id_i $$$ conversation currently display smartphone nothing happen : conversations screen change change order read message continue wait new message otherwise ( i.e conversation $$$ id_i $$$ screen ) : task find list conversations ( order display screen ) process $$$ n $$$ message first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 200 ) $$$ — number message number conversations smartphone show second line input contain $$$ n $$$ integers $$$ id_1 id_2 \dots id_n $$$ ( $$$ 1 \le id_i \le 1000000000 $$$ ) $$$ id_i $$$ i d friend send $$$ i $$$ -th message first line output print one integer $$$ m $$$ ( $$$ 1 \le m \le min ( n k ) $$$ ) — number conversations show receive $$$ n $$$ message second line print $$$ m $$$ integers $$$ ids_1 ids_2 \dots ids_m $$$ $$$ ids_i $$$ equal i d friend correspond conversation display position $$$ i $$$ receive $$$ n $$$ message first example list conversations change follow way ( order first last message ) : second example list conversations change follow way :,['implementation'],1000.0
1234/D,give a string $$$ s $$$ consist lowercase latin letter $$$ q $$$ query string recall substring $$$ s [ l ; r ] $$$ string $$$ s $$$ string $$$ s_l s _ { l + 1 } \dots s_r $$$ example substrings ` ` codeforces '' ` ` code '' ` ` force '' ` ` f '' ` ` '' ` ` coder '' ` ` top '' two type query : first line input contain one string $$$ s $$$ consist $$$ 100000 $$$ lowercase latin letter second line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100000 $$$ ) — number query next $$$ q $$$ line contain query one per line query give format describe problem statement guarantee least one query second type query second type print answer — number distinct character require substring query,['data structures'],1600.0
1236/C,order research $$$ n^2 $$$ labs build different heights a mountain let 's enumerate integers $$$ 1 $$$ $$$ n^2 $$$ lab number $$$ 1 $$$ lowest place lab number $$$ 2 $$$ second - lowest place $$$ \ldots $$$ lab number $$$ n^2 $$$ highest place transport water labs pip build every pair labs a pipe transport one unit water a time lab number $$$ u $$$ lab number $$$ v $$$ $$$ u > v $$$ labs need divide $$$ n $$$ group group contain exactly $$$ n $$$ labs labs different group transport water sum units water send a group $$$ a $$$ a group $$$ b $$$ equal number pair labs ( $$$ u v $$$ ) lab number $$$ u $$$ group $$$ a $$$ lab number $$$ v $$$ group $$$ b $$$ $$$ u > v $$$ let 's denote value $$$ f ( a b ) $$$ ( i.e $$$ f ( a b ) $$$ sum units water send a group $$$ a $$$ a group $$$ b $$$ ) example $$$ n=3 $$$ $$$ 3 $$$ group $$$ x $$$ $$$ y $$$ $$$ z $$$ : $$$ x = \ { 1 5 6\ } y = \ { 2 4 9\ } $$$ $$$ z = \ { 3 7 8\ } $$$ case value $$$ f $$$ equal : please divide labs $$$ n $$$ group size $$$ n $$$ value $$$ \min f ( a b ) $$$ possible pair group $$$ a $$$ $$$ b $$$ ( $$$ a \neq b $$$ ) maximal word divide labs $$$ n $$$ group size $$$ n $$$ minimum number sum units water transport a group $$$ a $$$ a group $$$ b $$$ every pair different group $$$ a $$$ $$$ b $$$ ( $$$ a \neq b $$$ ) big possible note example n't demonstrate optimal division demonstrate calculate value $$$ f $$$ division many optimal divisions find line contain one number $$$ n $$$ ( $$$ 2 \leq n \leq 300 $$$ ) output $$$ n $$$ line : $$$ i $$$ -th line print $$$ n $$$ number number labs $$$ i $$$ -th group order want multiple answer maximize minimum number sum units water transport one group another print first test divide $$$ 9 $$$ labs group $$$ \ { 2 8 5\ } \ { 9 3 4\ } \ { 7 6 1\ } $$$ first group second group transport $$$ 4 $$$ units water ( $$$ 8 \rightarrow 3 8 \rightarrow 4 5 \rightarrow 3 5 \rightarrow 4 $$$ ) first group third group transport $$$ 5 $$$ units water ( $$$ 2 \rightarrow 1 8 \rightarrow 7 8 \rightarrow 6 8 \rightarrow 1 5 \rightarrow 1 $$$ ) second group first group transport $$$ 5 $$$ units water ( $$$ 9 \rightarrow 2 9 \rightarrow 8 9 \rightarrow 5 3 \rightarrow 2 4 \rightarrow 2 $$$ ) second group third group transport $$$ 5 $$$ units water ( $$$ 9 \rightarrow 7 9 \rightarrow 6 9 \rightarrow 1 3 \rightarrow 1 4 \rightarrow 1 $$$ ) third group first group transport $$$ 4 $$$ units water ( $$$ 7 \rightarrow 2 7 \rightarrow 5 6 \rightarrow 2 6 \rightarrow 5 $$$ ) third group second group transport $$$ 4 $$$ units water ( $$$ 7 \rightarrow 3 7 \rightarrow 4 6 \rightarrow 3 6 \rightarrow 4 $$$ ) minimal number sum units water transport one group another equal $$$ 4 $$$ prove impossible make a better division,"['greedy', 'implementation']",1300.0
1236/D,alice get a new doll days even walk ! alice build a maze doll want test maze a grid $$$ n $$$ row $$$ m $$$ columns $$$ k $$$ obstacles $$$ i $$$ -th cell $$$ ( x_i y_i ) $$$ mean cell intersection $$$ x_i $$$ -th row $$$ y_i $$$ -th column however doll clumsy ways walk straight turn right cell ( include start cell ) get a cell obstacle get maze formally exist $$$ 4 $$$ directions doll look : stand cell doll move cell direction look turn right turn right doll switch 's direction follow rule : $$$ 1 \to 2 $$$ $$$ 2 \to 3 $$$ $$$ 3 \to 4 $$$ $$$ 4 \to 1 $$$ stand one cell doll make one turn right alice control doll 's move put doll cell $$$ ( 1 1 ) $$$ ( upper - left cell maze ) initially doll look direction $$$ 1 $$$ along row first cell last want let doll walk across cells without obstacles exactly end place achieve ? first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ separate space ( $$$ 1 \leq n m \leq 100000 0 \leq k \leq 100000 $$$ ) — size maze number obstacles next $$$ k $$$ line describe obstacles $$$ i $$$ -th line contain two integer number $$$ x_i $$$ $$$ y_i $$$ separate space ( $$$ 1 \leq x_i \leq <unknown> \leq y_i \leq m $$$ ) describe position $$$ i $$$ -th obstacle guarantee two obstacles cell obstacle cell $$$ ( 1 1 ) $$$ print ' yes ' ( without quote ) doll walk across cells without obstacles exactly rule describe statement impossible walk across maze rule print ' no ' ( without quote ) picture maze describe first example : first example doll walk way :,"['data structures', 'greedy', 'implementation']",2300.0
1242/D,ujan need rest clean start play infinite sequence two integers $$$ n $$$ $$$ k $$$ create infinite sequence $$$ s $$$ repeat follow step ujan stop procrastinate write number $$$ n $$$ sequence $$$ s $$$ help find index $$$ n $$$ $$$ s $$$ word find integer $$$ x $$$ $$$ s _ { x } = n $$$ 's possible prove positive integers include $$$ s $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10^ { 5 } $$$ ) number test case follow $$$ t $$$ line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 10^ { 18 } $$$ $$$ 2 \le k \le 10^ { 6 } $$$ ) number find sequence $$$ s $$$ parameter use create sequence $$$ s $$$ $$$ t $$$ line output answer correspond test case first sample $$$ s = ( 1 2 3 4 5 9 6 7 13 8 10 18 \ldots ) $$$ $$$ 10 $$$ $$$ 11 $$$ -th number answer $$$ 11 $$$ second sample $$$ s = ( 1 2 3 4 5 15 6 7 8 9 10 40 \ldots ) $$$,['math'],3400.0
1244/F,"$$$ n $$$ chip arrange a circle number $$$ 1 $$$ $$$ n $$$ initially chip black white color $$$ k $$$ iterations occur iteration chip change color accord follow rule chip $$$ i $$$ three chip consider : chip $$$ i $$$ two neighbour number white chip among three greater number black chip among three chip chip $$$ i $$$ become white otherwise chip $$$ i $$$ become black note $$$ i $$$ $$$ 2 $$$ $$$ ( n - 1 ) $$$ two neighbour chip number $$$ ( i - 1 ) $$$ $$$ ( i + 1 ) $$$ neighbour chip $$$ i = 1 $$$ $$$ n $$$ $$$ 2 $$$ neighbour $$$ i = n $$$ $$$ ( n - 1 ) $$$ $$$ 1 $$$ follow picture describe one iteration $$$ n = 6 $$$ chip $$$ 1 $$$ $$$ 3 $$$ $$$ 4 $$$ initially black chip $$$ 2 $$$ $$$ 5 $$$ $$$ 6 $$$ white iteration $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ become black $$$ 1 $$$ $$$ 5 $$$ $$$ 6 $$$ become white task determine color chip $$$ k $$$ iterations first line contain two integers $$$ n $$$ $$$ k $$$ $$$ ( 3 \le n \le 200\,000 1 \le k \le 10^ { 9 } ) $$$ — number chip number iterations respectively second line contain a string consist $$$ n $$$ character ` ` w '' ` ` b '' $$$ i $$$ -th character ` ` w '' $$$ i $$$ -th chip white initially $$$ i $$$ -th character ` ` b '' $$$ i $$$ -th chip black initially print a string consist $$$ n $$$ character ` ` w '' ` ` b '' $$$ k $$$ iterations $$$ i $$$ -th chip white $$$ i $$$ -th character ` ` w '' otherwise $$$ i $$$ -th character ` ` b '' first example describe statement second example : ` ` <unknown> '' $$$ \rightarrow $$$ ` ` <unknown> '' $$$ \rightarrow $$$ ` ` <unknown> '' $$$ \rightarrow $$$ ` ` <unknown> '' chip become white third example : ` ` bwbwbw '' $$$ \rightarrow $$$ ` ` wbwbwb '' $$$ \rightarrow $$$ ` ` bwbwbw '' $$$ \rightarrow $$$ ` ` wbwbwb '' $$$ \rightarrow $$$ ` ` bwbwbw ''",['implementation'],2300.0
1244/G,"demonstrative competitions hold run - up $$$ <unknown> $$$ berlatov olympic game today day run competition ! berlatov team consist $$$ 2n $$$ runners place two run track ; $$$ n $$$ runners place track runners number $$$ 1 $$$ $$$ n $$$ track runner number $$$ i $$$ run entire track $$$ i $$$ second competition hold follow : first runners track start run time ; slower arrive end track second runners track start run everyone wait slower finish run , $$$ n $$$ pair run track organizers want run long possible last $$$ k $$$ second crowd get bore coach team may choose order runners arrange track ( ca n't change number runners track swap runners different track ) choose order runners track duration competition long possible exceed $$$ k $$$ second formally want find two permutations $$$ p $$$ $$$ q $$$ ( consist $$$ n $$$ elements ) $$$ sum = \sum\limits _ { i=1 } ^ { n } max ( p_i q_i ) $$$ maximum possible exceed $$$ k $$$ pair report first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 1000000 1 \le k \le n^2 $$$ ) — number runners track maximum possible duration competition respectively impossible reorder runners duration competition exceed $$$ k $$$ second print $$$ -1 $$$ otherwise print three line first line contain one integer $$$ sum $$$ — maximum possible duration competition exceed $$$ k $$$ second line contain a permutation $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i $$$ pairwise distinct ) — number runners first track order participate competition third line contain a permutation $$$ n $$$ integers $$$ q_1 q_2 \dots q_n $$$ ( $$$ 1 \le q_i \le n $$$ $$$ q_i $$$ pairwise distinct ) — number runners second track order participate competition value $$$ sum = \sum\limits _ { i=1 } ^ { n } max ( p_i q_i ) $$$ maximum possible exceed $$$ k $$$ multiple answer print first example order runners first track $$$ [ 5 3 2 1 4 ] $$$ order runners second track $$$ [ 1 4 2 5 3 ] $$$ duration competition $$$ max ( 5 1 ) + max ( 3 4 ) + max ( 2 2 ) + max ( 1 5 ) + max ( 4 3 ) = 5 + 4 + 2 + 5 + 4 = 20 $$$ equal maximum allow duration first example order runners first track $$$ [ 2 3 1 ] $$$ order runners second track $$$ [ 2 1 3 ] $$$ duration competition $$$ 8 $$$ maximum possible duration $$$ n = 3 $$$","['greedy', 'math']",2400.0
1245/D,"shichikuji new resident deity south black snail temple first job follow : $$$ n $$$ new cities locate <unknown> x. cities number $$$ 1 $$$ $$$ n $$$ city $$$ i $$$ locate $$$ x_i $$$ km north shrine $$$ y_i $$$ km east shrine possible $$$ ( x_i y_i ) = ( x_j y_j ) $$$ even $$$ i \ne j $$$ shichikuji must provide electricity city either build a power station city make a connection city another one already electricity city electricity a power station connect a city electricity a direct connection via a chain connections shichikuji want job spend little money possible since accord n't really anything else world money however die fifth grade smart enough thus new resident deity ask help , provide shichikuji follow information : minimum amount yen need provide electricity cities cities power station build connections make multiple ways choose cities connections obtain construction minimum price print first line input contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 2000 $$$ ) — number cities , $$$ n $$$ line follow $$$ i $$$ -th line contain two space - separated integers $$$ x_i $$$ ( $$$ 1 \leq x_i \leq 1000000 $$$ ) $$$ y_i $$$ ( $$$ 1 \leq y_i \leq 1000000 $$$ ) — coordinate $$$ i $$$ -th city next line contain $$$ n $$$ space - separated integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \leq c_i \leq 1000000000 $$$ ) — cost build a power station $$$ i $$$ -th city last line contain $$$ n $$$ space - separated integers $$$ k_1 k_2 \dots k_n $$$ ( $$$ 1 \leq k_i \leq 1000000000 $$$ ) first line print a single integer denote minimum amount yen need , print integer $$$ v $$$ — number power station build next print $$$ v $$$ space - separated integers denote indices cities a power station build number $$$ 1 $$$ $$$ n $$$ number pairwise distinct print number arbitrary order , print integer $$$ e $$$ — number connections make finally print $$$ e $$$ pair integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le n $$$ $$$ a \ne b $$$ ) denote a connection city $$$ a $$$ city $$$ b $$$ make unordered pair cities include ( $$$ ( a b ) $$$ $$$ ( a b ) $$$ $$$ ( b a ) $$$ pair ) print pair arbitrary order multiple ways choose cities connections obtain construction minimum price print answer give sample refer follow diagram ( cities power station color green cities color blue wire color red ) : first example cost build power station cities $$$ 3 + 2 + 3 = 8 $$$ show configuration cost less 8 yen second example cost build a power station city 2 2 . cost connect city 1 city 2 $$$ 2 \cdot ( 3 + 2 ) = 10 $$$ cost connect city 2 city 3 $$$ 3 \cdot ( 2 + 3 ) = 15 $$$ thus total cost $$$ 2 + 10 + 15 = 27 $$$ show configuration cost less 27 yen",['greedy'],1900.0
1248/A,dls jls bore a math lesson order entertain dls take a sheet paper draw $$$ n $$$ distinct line give equations $$$ y = x + p_i $$$ distinct $$$ p_1 p_2 \ldots p_n $$$ jls draw paper sheet $$$ m $$$ distinct line give equations $$$ y = -x + q_i $$$ distinct $$$ q_1 q_2 \ldots q_m $$$ dls jls interest count many line pair integer intersection point i.e point coordinate integers unfortunately lesson end soon dls jls ask help first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) number test case input follow test case descriptions first line a test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) number line draw dls second line a test case contain $$$ n $$$ distinct integers $$$ p_i $$$ ( $$$ 0 \le p_i \le 1000000000 $$$ ) describe line draw dls integer $$$ p_i $$$ describe a line give equation $$$ y = x + p_i $$$ third line a test case contain integer $$$ m $$$ ( $$$ 1 \le m \le 100000 $$$ ) number line draw jls fourth line a test case contain $$$ m $$$ distinct integers $$$ q_i $$$ ( $$$ 0 \le q_i \le 1000000000 $$$ ) describe line draw jls integer $$$ q_i $$$ describe a line give equation $$$ y = -x + q_i $$$ sum value $$$ n $$$ test case input exceed $$$ 100000 $$$ similarly sum value $$$ m $$$ test case input exceed $$$ 100000 $$$ hack allow use one test case input $$$ t=1 $$$ satisfy test case input print a single integer — number line pair integer intersection point picture show line first test case example black circle denote intersection point integer coordinate,['math'],1000.0
1248/B,"gardener alexey teach competitive program high school students congratulate alexey teacher 's day students gift a collection wooden stick every stick integer length alexey want grow a tree tree look like a polyline plane consist stick polyline start point $$$ ( 0 0 ) $$$ construct polyline alexey attach stick one one arbitrary order stick must either vertical horizontal ( parallel $$$ ox $$$ $$$ oy $$$ axis ) allow two consecutive stick align simultaneously horizontally simultaneously vertically see image clarification alexey want make a polyline a way end far possible $$$ ( 0 0 ) $$$ please help grow tree way note polyline define form tree may self - intersections self - touches prove optimal answer contain self - intersections self - touches first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 100\,000 $$$ ) — number stick alexey get a present second line contain $$$ n $$$ integers $$$ a_1 \ldots a_n $$$ ( $$$ 1 \le a_i \le 10\,000 $$$ ) — lengths stick print one integer — square largest possible distance $$$ ( 0 0 ) $$$ tree end follow picture show optimal tree example test square distance first example equal $$$ 25 + 1 = 26 $$$ second example $$$ 16 + 4 = 20 $$$","['greedy', 'math']",900.0
1249/B1,difference easy hard versions constraints $$$ n $$$ kid read a unique book end day $$$ i $$$ -th kid give book $$$ p_i $$$ -th kid ( case $$$ i = p_i $$$ kid give book ) guarantee value $$$ p_i $$$ distinct integers $$$ 1 $$$ $$$ n $$$ ( i.e $$$ p $$$ a permutation ) sequence $$$ p $$$ n't change day day fix example $$$ n=6 $$$ $$$ p= [ 4 6 1 3 5 2 ] $$$ end first day book $$$ 1 $$$ -st kid belong $$$ 4 $$$ -th kid $$$ 2 $$$ -nd kid belong $$$ 6 $$$ -th kid end second day book $$$ 1 $$$ -st kid belong $$$ 3 $$$ -th kid $$$ 2 $$$ -nd kid belong $$$ 2 $$$ -th kid task determine number day book $$$ i $$$ -th child return back first time every $$$ i $$$ $$$ 1 $$$ $$$ n $$$ consider follow example : $$$ p = [ 5 1 2 4 3 ] $$$ book $$$ 1 $$$ -st kid pass follow kid : fourth day book first kid return owner book fourth kid return first time exactly one day answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200 $$$ ) — number query $$$ q $$$ query follow first line query contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200 $$$ ) — number kid query second line query contain $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i $$$ distinct i.e $$$ p $$$ a permutation ) $$$ p_i $$$ kid get book $$$ i $$$ -th kid query print answer : $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ $$$ a_i $$$ number day book $$$ i $$$ -th child return back first time query,['math'],1000.0
1249/F,give a tree consist $$$ n $$$ vertices recall a tree a connect undirected graph without cycle vertices number $$$ 1 $$$ $$$ n $$$ vertices weight weight vertex $$$ v $$$ $$$ a_v $$$ recall distance two vertices tree number edge a simple path task find subset vertices maximum total weight ( weight subset sum weight vertices ) pair vertices distance $$$ k $$$ less subset first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 200 $$$ ) — number vertices tree distance restriction respectively second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100000 $$$ ) $$$ a_i $$$ weight vertex $$$ i $$$ next $$$ n - 1 $$$ line contain edge tree edge $$$ i $$$ denote two integers $$$ u_i $$$ $$$ v_i $$$ — label vertices connect ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) guarantee give edge form a tree print one integer — maximum total weight subset pair vertices distance $$$ k $$$,['dp'],2200.0
125/B,let 's define a string < x > open tag x small letter latin alphabet open tag match a close tag type < <unknown> > x letter <unknown> nest : case one open close tag pair locate inside another pair let 's define notion a xml - text : give a xml - text ( guarantee text valid ) task print follow form : input data consist non - empty string — xml - text length exceed 1000 character guarantee text valid text contain space print give xml - text accord above - given rule,['implementation'],1000.0
1251/E1,difference easy hard versions constraints elections hold berland want win precisely want everyone vote $$$ n $$$ voters two ways convince vote first way convince $$$ i $$$ -th voter pay $$$ p_i $$$ coin second way make $$$ m_i $$$ voters vote $$$ i $$$ -th voter vote free moreover process vote take place several step example five voters $$$ m_1 = 1 $$$ $$$ m_2 = 2 $$$ $$$ m_3 = 2 $$$ $$$ m_4 = 4 $$$ $$$ m_5 = 5 $$$ buy vote fifth voter eventually everyone vote set people vote change follow : $$$ { 5 } \rightarrow { 1 5 } \rightarrow { 1 2 3 5 } \rightarrow { 1 2 3 4 5 } $$$ calculate minimum number coin spend everyone vote first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) — number test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 5000 $$$ ) — number voters next $$$ n $$$ line contain description voters $$$ i $$$ -th line contain two integers $$$ m_i $$$ $$$ p_i $$$ ( $$$ 1 \le p_i \le 1000000000 0 \le m_i < n $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ test case print one integer — minimum number coin spend everyone vote first test case buy vote third voter set people vote change follow : $$$ { 3 } \rightarrow { 1 3 } \rightarrow { 1 2 3 } $$$ second example n't need buy vote set people vote change follow : $$$ { 1 } \rightarrow { 1 3 5 } \rightarrow { 1 2 3 5 } \rightarrow { 1 2 3 5 6 7 } \rightarrow { 1 2 3 4 5 6 7 } $$$ third test case buy vote second fifth voters set people vote change follow : $$$ { 2 5 } \rightarrow { 1 2 3 4 5 } \rightarrow { 1 2 3 4 5 6 } $$$,"['data structures', 'dp', 'greedy']",2300.0
1252/E,"andi a mathematician a computer scientist a <unknown> spend much time write songs finally write a catchy melody think best creation however singer sing song / melody a unique vocal range thus <unknown> may need a melody define a sequence $$$ n $$$ note represent integers let $$$ a $$$ original melody write andi andi need adjust $$$ a $$$ a new melody $$$ b $$$ every $$$ i $$$ $$$ 1 \le i < n $$$ : help andi determine whether $$$ b $$$ exist find lexicographically smallest $$$ b $$$ exist a melody $$$ x $$$ lexicographically smaller melody $$$ y $$$ exist $$$ j $$$ ( $$$ 1 \le j \le n $$$ ) $$$ x_i = y_i $$$ $$$ i < j $$$ $$$ x _ { j } < y _ { j } $$$ example consider a melody $$$ a = \ { <unknown> } $$$ show follow figure diagonal arrow figure imply $$$ a_i < a _ { i+1 } $$$ straight right arrow imply $$$ a_i = a _ { i+1 } $$$ diagonal arrow imply $$$ a_i > a _ { i+1 } $$$ suppose want make a new melody $$$ l = 1 $$$ $$$ r = 8 $$$ $$$ k = 6 $$$ new melody $$$ b = \ { <unknown> } $$$ show figure satisfy requirements lexicographically smallest possible input begin a line contain four integers : $$$ n $$$ $$$ l $$$ $$$ r $$$ $$$ k $$$ ( $$$ 1 \le n \le 100\,000 $$$ ; $$$ 1 \le l \le r \le 1000000000 $$$ ; $$$ 1 \le k \le 1000000000 $$$ ) represent number note melody vocal range ( $$$ l $$$ $$$ r $$$ ) maximum difference two successive note new melody respectively next line contain $$$ n $$$ integers : $$$ a_i $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) represent original melody output a line $$$ n $$$ integers ( separate a single space ) represent lexicographically smallest melody satisfy requirements output -1 melody satisfy requirements note might possible lexicographically smallest melody satisfy requirements original melody explanation sample input / output # 1this example problem description",['greedy'],2200.0
1252/H,"might already know space always a problem icpc jakarta cope icpc jakarta plan build two new build build a shape a rectangle size , problem find land build build $$$ n $$$ land available sale $$$ i^ { th } $$$ land a rectangular shape size $$$ l_i \times w_i $$$ a good <unknown> <unknown> build 's side parallel land 's side one way build two build two different land one land ( necessarily orientation ) a build size $$$ a \times b $$$ build $$$ i^ { th } $$$ land least one follow satisfy : task problem help icpc jakarta figure largest possible build build give $$$ n $$$ available land note icpc jakarta build two build $$$ a \times b $$$ ; output largest possible $$$ a \times b $$$ input begin a line contain integer : $$$ n $$$ ( $$$ 1 \le n \le 100\,000 $$$ ) represent number available land next $$$ n $$$ line contain two integers : $$$ l_i $$$ $$$ w_i $$$ ( $$$ 1 \le l_i w_i \le 1000000000 $$$ ) represent size land output a line a number represent largest build icpc jakarta build exactly one decimal point ( see sample input / output clarity ) explanation sample input / output # <unknown> build $$$ 2.5 \times 5 $$$ build first land explanation sample input / output # <unknown> build $$$ 2 \times 4 $$$ build first second land explanation sample input / output # <unknown> build $$$ 7 \times 6 $$$ build second third land","['greedy', 'implementation']",1800.0
1254/B2,harder version problem version $$$ 1 \le n \le 1000000 $$$ $$$ 0 \leq a_i \leq 1000000 $$$ hack problem lock hack previous problem lock <unknown> come protagonist bob prepare a spectacular present long - time best friend alice year decide prepare $$$ n $$$ box chocolate number $$$ 1 $$$ $$$ n $$$ initially $$$ i $$$ -th box contain $$$ a_i $$$ chocolate piece since bob a typical nice guy send alice $$$ n $$$ empty box word least one $$$ a_1 a_2 \ldots a_n $$$ positive since alice dislike coprime set happy exist integer $$$ k > 1 $$$ number piece box divisible $$$ k $$$ note alice wo n't mind exist empty box charlie alice 's boyfriend also bob 's second best friend decide help bob rearrange chocolate piece one second charlie pick a piece box $$$ i $$$ put either box $$$ i-1 $$$ box $$$ i+1 $$$ ( box exist ) course want help friend quickly possible therefore ask calculate minimum number second would need make alice happy first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — number chocolate box second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000 $$$ ) — number chocolate piece $$$ i $$$ -th box guarantee least one $$$ a_1 a_2 \ldots a_n $$$ positive way charlie make alice happy print $$$ -1 $$$ otherwise print a single integer $$$ x $$$ — minimum number second charlie help bob make alice happy first example charlie move chocolate piece second box box divisible $$$ 17 $$$ second example charlie move a piece box $$$ 2 $$$ box $$$ 3 $$$ a piece box $$$ 4 $$$ box $$$ 5 $$$ box divisible $$$ 3 $$$ third example box already divisible $$$ 5 $$$ fourth example since charlie available move help bob make alice happy,"['greedy', 'math']",2100.0
1255/A,"bob watch tv every day always set volume tv $$$ b $$$ however today angry find someone change volume $$$ a $$$ course bob a remote control change volume six button ( $$$ -5 -2 -1 +1 +2 +5 $$$ ) control one press either increase decrease current volume $$$ 1 $$$ $$$ 2 $$$ $$$ 5 $$$ volume arbitrarily large never negative word bob press button cause volume lower $$$ 0 $$$ bob angry want change volume $$$ b $$$ use button press possible however forget simple calculations ask help write a program give $$$ a $$$ $$$ b $$$ find minimum number press change tv volume $$$ a $$$ $$$ b $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1\,000 $$$ ) descriptions test case follow test case consist one line contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 0 \le a b \le 10^ { 9 } $$$ ) — current volume bob 's desire volume respectively test case output a single integer — minimum number press change tv volume $$$ a $$$ $$$ b $$$ bob need change volume ( i.e $$$ a = b $$$ ) print $$$ 0 $$$ first example bob press $$$ -2 $$$ button twice reach $$$ 0 $$$ note bob press $$$ -5 $$$ volume $$$ 4 $$$ since make volume negative second example one optimal ways bob press $$$ +5 $$$ twice press $$$ -1 $$$ last example bob press $$$ +5 $$$ press $$$ +1 $$$",['math'],800.0
1256/A,$$$ a $$$ coin value $$$ n $$$ $$$ b $$$ coin value $$$ 1 $$$ always pay exact change want know exist $$$ x $$$ $$$ y $$$ take $$$ x $$$ ( $$$ 0 \le x \le a $$$ ) coin value $$$ n $$$ $$$ y $$$ ( $$$ 0 \le y \le b $$$ ) coin value $$$ 1 $$$ total value take coin $$$ s $$$ answer $$$ q $$$ independent test case first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 10000 $$$ ) — number test case $$$ q $$$ test case follow line test case contain four integers $$$ a $$$ $$$ b $$$ $$$ n $$$ $$$ s $$$ ( $$$ 1 \le a b n s \le 1000000000 $$$ ) — number coin value $$$ n $$$ number coin value $$$ 1 $$$ value $$$ n $$$ require total value $$$ i $$$ -th test case print answer — yes ( without quote ) exist $$$ x $$$ $$$ y $$$ take $$$ x $$$ coin value $$$ n $$$ $$$ y $$$ coin value $$$ 1 $$$ total value take coin $$$ s $$$ otherwise may print every letter case want ( example string yes yes yes yes recognize positive answer ),['math'],1000.0
1256/E,$$$ n $$$ students university program skill $$$ i $$$ -th student $$$ a_i $$$ a coach want divide team prepare upcoming icpc finals imagine good university $$$ 200000 $$$ students ready finals ! team consist least three students student belong exactly one team diversity a team difference maximum program skill student belong team minimum program skill student belong team ( word team consist $$$ k $$$ students program skills $$$ a [ i_1 ] a [ i_2 ] \dots a [ i_k ] $$$ diversity team $$$ \max\limits _ { j=1 } ^ { k } a [ i_j ] - \min\limits _ { j=1 } ^ { k } a [ i_j ] $$$ ) total diversity sum <unknown> team form task minimize total diversity division students find optimal way divide students first line input contain one integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) — number students second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ program skill $$$ i $$$ -th student first line print two integers $$$ res $$$ $$$ k $$$ — minimum total diversity division students number team division correspondingly second line print $$$ n $$$ integers $$$ t_1 t_2 \dots t_n $$$ ( $$$ 1 \le t_i \le k $$$ ) $$$ t_i $$$ number team $$$ i $$$ -th student belong multiple answer print note n't need minimize number team team consist least three students first example one team skills $$$ [ 1 1 2 3 4 ] $$$ answer $$$ 3 $$$ show achieve a better answer second example two team skills $$$ [ 1 2 5 ] $$$ $$$ [ 12 13 15 ] $$$ answer $$$ 4 + 3 = 7 $$$ third example three team skills $$$ [ 1 2 5 ] $$$ $$$ [ 129 185 <unknown> <unknown> ] $$$ $$$ [ <unknown> 1909 <unknown> ] $$$ answer $$$ 4 + <unknown> + <unknown> = <unknown> $$$,"['dp', 'greedy']",2000.0
1257/D,play a computer game game lead a party $$$ m $$$ heroes clear a dungeon $$$ n $$$ monsters monster characterize power $$$ a_i $$$ hero characterize power $$$ p_i $$$ endurance $$$ s_i $$$ heroes clear dungeon day day begin day choose a hero ( exactly one ) go enter dungeon day hero enter dungeon challenge first monster defeat previous days ( heroes already defeat $$$ k $$$ monsters hero fight monster $$$ k + 1 $$$ ) hero fight monster two possible outcomes : defeat a monster hero either continue fight next monster leave dungeon leave dungeon either already defeat number monsters equal endurance day ( $$$ i $$$ -th hero defeat $$$ s_i $$$ monsters day ) monsters defeat — otherwise fight next monster hero leave dungeon current day end goal defeat last monster minimum number days need achieve goal ? day use exactly one hero ; possible heroes n't fight monsters hero use arbitrary number time first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number monsters dungeon second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ power $$$ i $$$ -th monster third line contain one integer $$$ m $$$ ( $$$ 1 \le m \le 200000 $$$ ) — number heroes party $$$ m $$$ line follow describe a hero line contain two integers $$$ p_i $$$ $$$ s_i $$$ ( $$$ 1 \le p_i \le 1000000000 $$$ $$$ 1 \le s_i \le n $$$ ) — power endurance $$$ i $$$ -th hero guarantee sum $$$ n + m $$$ test case exceed $$$ 200000 $$$ test case print one integer — minimum number days spend defeat monsters ( $$$ -1 $$$ impossible ),"['data structures', 'dp', 'greedy']",1700.0
1260/F,'re give a tree $$$ n $$$ vertices color $$$ i $$$ -th vertex $$$ h _ { i } $$$ value tree define $$$ \sum\limits _ { h _ { i } = h _ { j } 1 \le i < j \le n } { dis ( i j ) } $$$ $$$ dis ( i j ) $$$ number edge shortest path $$$ i $$$ $$$ j $$$ color vertex lose remember $$$ h _ { i } $$$ integer $$$ [ l _ { i } r _ { i } ] $$$ ( inclusive ) want calculate sum value tree meet condition modulo $$$ 1000000000 + 7 $$$ ( set edge fix color unknown $$$ \prod\limits _ { i = 1 } ^ { n } ( r _ { i } - l _ { i } + 1 ) $$$ different tree ) first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — number vertices $$$ n $$$ line follow line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le 100000 $$$ ) denote range possible color vertex $$$ i $$$ $$$ n - 1 $$$ line follow contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) denote edge tree guarantee edge form a tree print one integer — sum value possible tree take modulo $$$ 1000000000 + 7 $$$ first example four different ways color tree ( four different tree ) : overall sum value $$$ 10 + 4 + 4 + <unknown> $$$,['data structures'],2700.0
1263/B,a pin code a string consist exactly $$$ 4 $$$ digits examples possible pin cod : <unknown> 0000 <unknown> . please note pin code begin digit even 0 . polycarp $$$ n $$$ ( $$$ 2 \le n \le 10 $$$ ) bank card pin code $$$ i $$$ -th card $$$ p_i $$$ polycarp recently read a recommendation better set different pin cod different card thus want change minimal number digits pin cod card $$$ n $$$ cod would become different formally one step polycarp pick $$$ i $$$ -th card ( $$$ 1 \le i \le n $$$ ) pin code $$$ p_i $$$ select one position ( $$$ 1 $$$ $$$ 4 $$$ ) change digit position need change minimum number digits pin cod become different polycarp quickly solve problem solve ? first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case input test case follow first line $$$ t $$$ test set contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 10 $$$ ) — number polycarp 's bank card next $$$ n $$$ line contain pin cod $$$ p_1 p_2 \dots p_n $$$ — one per line length $$$ 4 $$$ pin cod consist digits print answer $$$ t $$$ test set answer set consist a $$$ n + 1 $$$ <unknown> first line print $$$ k $$$ — least number change make pin cod different next $$$ n $$$ line output change pin cod order correspond appearance input several optimal answer print,"['greedy', 'implementation']",1400.0
1263/C,well - known test system mathforces a draw $$$ n $$$ rat units arrange rat distribute accord follow algorithm : $$$ k $$$ participants take part event $$$ n $$$ rat evenly distribute round nearest lower integer end draw unused rat may remain — give participants example $$$ n = 5 $$$ $$$ k = 3 $$$ participant recieve $$$ 1 $$$ rat unit also $$$ 2 $$$ rat units remain unused $$$ n = 5 $$$ $$$ k = 6 $$$ none participants increase rat vasya participate rat draw information total number participants event therefore want know different value rat increment possible get a result draw ask help example $$$ n=5 $$$ answer equal sequence $$$ 0 1 2 5 $$$ sequence value ( ) obtain $$$ \lfloor n / k \rfloor $$$ positive integer $$$ k $$$ ( $$$ \lfloor x \rfloor $$$ value $$$ x $$$ round ) : $$$ 0 = \lfloor <unknown> \rfloor $$$ $$$ 1 = \lfloor <unknown> \rfloor $$$ $$$ 2 = \lfloor <unknown> \rfloor $$$ $$$ 5 = \lfloor <unknown> \rfloor $$$ write a program a give $$$ n $$$ find a sequence possible rat increments first line contain integer number $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) — number test case input $$$ t $$$ test case follow line contain integer $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) — total number rat units draw output answer $$$ t $$$ test case answer contain two line first line print a single integer $$$ m $$$ — number different rat increment value vasya get follow line print $$$ m $$$ integers ascend order — value possible rat increments,['math'],1400.0
1263/E,development a text editor a hard problem need implement extra module bracket color text editor consist a line infinite length cursor point current character please note point one character ( a pair character ) thus point index character user move cursor leave right one position cursor already first ( leftmost ) position move leave initially cursor first ( leftmost ) character also user write a letter bracket ( either ( ) ) position cursor currently point a new character always overwrite old value position editor must check whether current line correct text text correct bracket form correct bracket sequence formally correct text ( <unknown> ) must satisfy follow rule : examples correct texts : hello ( codeforces ) round ( ( i ) ( write ) ) <unknown> ( tor ) s ( ) examples incorrect texts : hello ) <unknown> ( round ) ( ( ) user use special command work editor command symbol must write execute command correspondence command character follow : a complete understand take a look first example illustrations note give a string contain character user enter bracket color module 's work command need : two pair bracket nest ( first second vice versa ) pair bracket paint different color two pair bracket nest paint different color example bracket sequence ( ) ( ( ) ) ( ) ( ) least number color $$$ 2 $$$ bracket sequence ( ( ) ( ( ) ( ) ) ( ) ) ( ( ) ) — $$$ 3 $$$ write a program print minimal number color process command first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — number command second line contain $$$ s $$$ — a sequence command string $$$ s $$$ consist $$$ n $$$ character guarantee character a string valid command a single line print $$$ n $$$ integers $$$ i $$$ -th number : first example text editor take follow form :,"['data structures', 'implementation']",2100.0
1265/A,a string call beautiful two consecutive character equal example ` ` ababcb '' ` ` a '' ` ` abab '' beautiful string ` ` aaaaaa '' ` ` abaa '' ` ` bb '' ahcl want construct a beautiful string a string $$$ s $$$ consist character ' a ' ' b ' ' c ' ' ? ' ahcl need replace character ' ? ' one three character ' a ' ' b ' ' c ' result string beautiful please help ! formally replace character ' ? ' condition $$$ s_i \neq s _ { i+1 } $$$ satisfy $$$ 1 \leq i \leq |s| - 1 $$$ $$$ |s| $$$ length string $$$ s $$$ first line contain positive integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case next $$$ t $$$ line contain descriptions test case line contain a non - empty string $$$ s $$$ consist character ' a ' ' b ' ' c ' ' ? ' guarantee test case a string $$$ s $$$ least one character ' ? ' sum lengths string $$$ s $$$ test case exceed $$$ 100000 $$$ test case give input print answer follow format : first test case possible correct answer ` ` ababcb '' ` ` abcacb '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' two answer ` ` <unknown> '' ` ` <unknown> '' incorrect replace ' ? ' character result string must beautiful second test case impossible create a beautiful string $$$ 4 $$$ -th $$$ 5 $$$ -th character always equal third test case answer ` ` acbac '',['greedy'],1000.0
1265/E,"creatnx $$$ n $$$ mirror number $$$ 1 $$$ $$$ n $$$ every day creatnx ask exactly one mirror ` ` i beautiful ? ` ` $$$ i $$$ -th mirror tell creatnx beautiful probability $$$ \frac { p_i } { 100 } $$$ $$$ 1 \le i \le n $$$ creatnx ask mirror one one start $$$ 1 $$$ -st mirror every day ask $$$ i $$$ -th mirror two possibilities : need calculate expect number days creatnx become happy number find modulo $$$ 998244353 $$$ formally let $$$ m = 998244353 $$$ show answer express irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \not \equiv 0 \pmod { m } $$$ output integer equal $$$ p \cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \le x < m $$$ $$$ x \cdot q \equiv p \pmod { m } $$$ first line contain one integer $$$ n $$$ ( $$$ 1\le n\le 2\cdot 100000 $$$ ) — number mirror second line contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \leq p_i \leq 100 $$$ ) print answer modulo $$$ 998244353 $$$ a single line first test one mirror tell creatnx beautiful probability $$$ \frac { 1 } { 2 } $$$ , expect number days creatnx become happy $$$ 2 $$$","['data structures', 'dp', 'math']",2100.0
1266/B,bob play $$$ 6 $$$ -sided dice a net standard cube show unlimited supply dice want build a tower stack multiple dice top choose orientation dice count number visible pip face dice example number visible pip tower $$$ 29 $$$ — number visible top $$$ 1 $$$ south $$$ 5 $$$ $$$ 3 $$$ west $$$ 4 $$$ $$$ 2 $$$ north $$$ 2 $$$ $$$ 4 $$$ east $$$ 3 $$$ $$$ 5 $$$ one bottom two <unknown> dice touch visible count towards total bob also $$$ t $$$ favourite integers $$$ x_i $$$ every integer goal build a tower number visible pip exactly $$$ x_i $$$ bob 's favourite integers determine whether possible build a tower exactly many visible pip first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number favourite integers bob second line contain $$$ t $$$ space - separated integers $$$ x_i $$$ ( $$$ 1 \leq x_i \leq 10^ { 18 } $$$ ) — bob 's favourite integers bob 's favourite integers output ` ` yes '' possible build tower ` ` '' otherwise ( quote clarity ) first example mention problem statement second example one build tower flip top dice previous tower third example one use a single die $$$ 5 $$$ top fourth example impossible,['math'],1000.0
1267/G,"esports a form competitive sport use video game dota 2 one popular competitive video game esports recently a new video game dota 3 release dota 3 a player buy relics hero relics counter track hero 's action statistics a game gloria like play dota 3 want buy $$$ n $$$ available relics favorite hero relics buy use in - game currency call shards relic price — $$$ c_i $$$ shards $$$ i $$$ -th relic a player buy a relic use one follow options : gloria want buy $$$ n $$$ relics help minimize expect number shards spend buy relics first line contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \le n \le 100 $$$ ; $$$ 1 \le x \le 10\,000 $$$ ) — number relics cost receive a random relic second line consist $$$ n $$$ integers $$$ c_1 c_2 \ldots c_n $$$ ( $$$ x \le c_i \le 10\,000 $$$ ; $$$ \sum { c_i } \le 10\,000 $$$ ) — price $$$ n $$$ relics print a single real number — minimum expect number shards gloria must spend buy relics absolute relative error exceed $$$ 10^ { -9 } $$$ first example optimal strategy randomly get one two relics pay $$$ 20 $$$ shards two scenarios first one happen gloria receive first relic keep get random relics obtain second relic expect number shards spend scenario $$$ 20 + 30 = 50 $$$ second scenario gloria initially get second relic better buy first relic $$$ 25 $$$ shards expect number shards spend scenario $$$ 20 + 25 = 45 $$$ thus expect number shards spend $$$ \frac { 50 + 45 } { 2 } = <unknown> $$$",['math'],3000.0
1267/J,"berphone x almost ready release $$$ n $$$ applications preinstalled phone a category application characterize a genre a theme application ( like ` ` game '' ` ` business '' ` ` education '' ) categories give integers $$$ 1 $$$ $$$ n $$$ inclusive ; $$$ i $$$ -th application category $$$ c_i $$$ choose $$$ m $$$ — number screen $$$ s $$$ — size screen need fit $$$ n $$$ icons applications ( one icon represent one application ) meet follow requirements : task find minimal possible number screen $$$ m $$$ first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10\,000 $$$ ) — number test case input $$$ t $$$ test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 2\cdot1000000 $$$ ) — number icons second line contain $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \le c_i \le n $$$ ) $$$ c_i $$$ category $$$ i $$$ -th application guarantee sum value $$$ n $$$ test case input exceed $$$ 2\cdot1000000 $$$ print $$$ t $$$ integers — answer give test case order follow input answer a test case integer $$$ m $$$ — minimum number screen $$$ n $$$ icons place satisfy give requirements first test case example icons place three screen size $$$ 4 $$$ : a screen $$$ 4 $$$ icons category $$$ 1 $$$ a screen $$$ 3 $$$ icons category $$$ 1 $$$ a screen $$$ 4 $$$ icons category $$$ 5 $$$","['greedy', 'implementation', 'math']",1800.0
1268/C,"give a permutation $$$ p_1 p_2 \ldots p_n $$$ one move swap two adjacent value want perform a minimum number move end exist a subsegment $$$ 1,2 \ldots k $$$ word end integer $$$ i $$$ $$$ 1 \leq i \leq n - k+1 $$$ $$$ p_i = 1 p _ { i+1 } = 2 \ldots p _ { i+k-1 } = k $$$ let $$$ f ( k ) $$$ minimum number move need make a subsegment value $$$ 1,2 \ldots k $$$ appear permutation need find $$$ f ( 1 ) f ( 2 ) \ldots f ( n ) $$$ first line input contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 200\,000 $$$ ) : number elements permutation next line input contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ : give permutation ( $$$ 1 \leq p_i \leq n $$$ ) print $$$ n $$$ integers minimum number move need make a subsegment value $$$ 1,2 \ldots k $$$ appear permutation $$$ k=1 2 \ldots n $$$",['data structures'],2300.0
1270/C,"let 's call array $$$ a_1 a_2 \dots a_m $$$ nonnegative integer number good $$$ a_1 + a_2 + \dots + a_m = 2\cdot ( a_1 \oplus a_2 \oplus \dots \oplus a_m ) $$$ $$$ \oplus $$$ denote bitwise xor operation example array $$$ [ 1 2 3 6 ] $$$ good $$$ 1 + 2 + 3 + 6 = 12 = 2\cdot 6 = 2\cdot ( 1\oplus 2 \oplus 3 \oplus 6 ) $$$ time array $$$ [ 1 2 1 3 ] $$$ n't good $$$ 1 + 2 + 1 + 3 = 7 \neq 2\cdot 1 = 2\cdot ( 1\oplus 2 \oplus 1 \oplus 3 ) $$$ give array length $$$ n $$$ : $$$ a_1 a_2 \dots a_n $$$ append $$$ 3 $$$ elements make good append elements n't different show solution always exist give constraints different solutions allow output note n't minimize number add elements ! , array good already allow append elements test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10\,000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 1\le n \le 100000 ) $$$ — size array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0\le a_i \le 1000000000 $$$ ) — elements array guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output two line first line output a single integer $$$ s $$$ ( $$$ 0\le s\le 3 $$$ ) — number elements want append second line output $$$ s $$$ integers $$$ b_1 \dots b_s $$$ ( $$$ 0\le b_i \le 10^ { 18 } $$$ ) — elements want append array different solutions allow output first test case example sum number $$$ 12 $$$ $$$ \oplus $$$ $$$ 6 $$$ condition already satisfy second test case example add $$$ 4 4 $$$ array become $$$ [ 8 4 4 ] $$$ sum number $$$ 16 $$$ $$$ \oplus $$$ number $$$ 8 $$$",['math'],1400.0
1271/A,"a new delivery clothe arrive today clothe store delivery consist $$$ a $$$ tie $$$ b $$$ scarves $$$ c $$$ vest $$$ d $$$ jacket store sell single clothe items — instead sell suit two type : suit first type cost $$$ e $$$ coin suit second type cost $$$ f $$$ coin calculate maximum possible cost a set suit compose deliver clothe items note one item use one suit ( though items may leave unused ) first line contain one integer $$$ a $$$ $$$ ( 1 \le a \le 100\,000 ) $$$ — number tie second line contain one integer $$$ b $$$ $$$ ( 1 \le b \le 100\,000 ) $$$ — number scarves third line contain one integer $$$ c $$$ $$$ ( 1 \le c \le 100\,000 ) $$$ — number vest fourth line contain one integer $$$ d $$$ $$$ ( 1 \le d \le 100\,000 ) $$$ — number jacket fifth line contain one integer $$$ e $$$ $$$ ( 1 \le e \le 1\,000 ) $$$ — cost one suit first type sixth line contain one integer $$$ f $$$ $$$ ( 1 \le f \le 1\,000 ) $$$ — cost one suit second type print one integer — maximum total cost set suit compose deliver items possible compose three suit second type first example total cost $$$ 6 $$$ since jacket use 's impossible add anything set best course action second example compose nine suit first type eleven suit second type total cost $$$ 36 + 66 = 102 $$$","['greedy', 'math']",800.0
1271/B,$$$ n $$$ block arrange a row number leave right start one block either black white may perform follow operation zero time : choose two adjacent block invert color ( white block become black vice versa ) want find a sequence operations make block color n't minimize number operations exceed $$$ 3 \cdot n $$$ impossible find a sequence operations need report first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200 $$$ ) — number block second line contain one string $$$ s $$$ consist $$$ n $$$ character character either ` ` w '' ` ` b '' $$$ i $$$ -th character ` ` w '' $$$ i $$$ -th block white $$$ i $$$ -th character ` ` b '' $$$ i $$$ -th block black impossible make block color print $$$ -1 $$$ otherwise print integer $$$ k $$$ ( $$$ 0 \le k \le 3 \cdot n $$$ ) — number operations print $$$ k $$$ integers $$$ p_1 p_2 \dots p_k $$$ $$$ ( 1 \le p_j \le n - 1 ) $$$ $$$ p_j $$$ position leave block pair block affect $$$ j $$$ -th operation multiple answer print first example possible make block black $$$ 3 $$$ operations start change block $$$ 6 $$$ $$$ 7 $$$ sequence ` ` <unknown> '' change block $$$ 2 $$$ $$$ 3 $$$ sequence ` ` <unknown> '' finally change block $$$ 4 $$$ $$$ 5 $$$ block black impossible make color equal second example block already white third example fourth example possible make block white two operations : first operation change block $$$ 2 $$$ $$$ 3 $$$ ( sequence ` ` <unknown> '' ) change block $$$ 1 $$$ $$$ 2 $$$ ( block white ),"['greedy', 'math']",1300.0
1271/C,"map capital berland view infinite coordinate plane point integer coordinate contain a build streets connect every build four neighbour build streets parallel coordinate ax main school capital locate $$$ ( s_x s_y ) $$$ $$$ n $$$ students attend school $$$ i $$$ -th live house locate $$$ ( x_i y_i ) $$$ possible students live house student live $$$ ( s_x s_y ) $$$ class end student walk school house along one shortest paths distance $$$ i $$$ -th student go school house $$$ |s_x - x_i| + |s_y - y_i| $$$ <unknown> department berland decide open a shawarma tent somewhere capital ( point integer coordinate ) consider $$$ i $$$ -th student buy a shawarma least one shortest paths school $$$ i $$$ -th student 's house go point shawarma tent locate forbid place shawarma tent point school locate coordinate shawarma tent may coincide coordinate house student ( even multiple students ) want find maximum possible number students buy shawarma optimal location tent first line contain three integers $$$ n $$$ $$$ s_x $$$ $$$ s_y $$$ ( $$$ 1 \le n \le 200\,000 $$$ $$$ 0 \le s_x s_y \le 10^ { 9 } $$$ ) — number students coordinate school respectively $$$ n $$$ line follow $$$ i $$$ -th contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \le x_i y_i \le 10^ { 9 } $$$ ) — location house $$$ i $$$ -th student live locations house may coincide student live location school situate output consist two line first contain one integer $$$ c $$$ — maximum number students buy <unknown> tent second line contain two integers $$$ p_x $$$ $$$ p_y $$$ — coordinate tent locate multiple answer print note $$$ p_x $$$ $$$ p_y $$$ less $$$ 0 $$$ greater $$$ 10^ { 9 } $$$ first example build shawarma tent $$$ ( 4 2 ) $$$ students live $$$ ( 4 2 ) $$$ $$$ ( 4 1 ) $$$ $$$ ( 5 1 ) $$$ visit second example possible build shawarma tent $$$ ( 1 1 ) $$$ students live $$$ ( 0 0 ) $$$ visit","['greedy', 'implementation']",1300.0
1271/D,"play a strategic video game ( yeah run good problem legends ) game control a large army goal conquer $$$ n $$$ castle opponent let 's describe game process detail initially control army $$$ k $$$ warriors enemy control $$$ n $$$ castle ; conquer $$$ i $$$ -th castle need least $$$ a_i $$$ warriors ( good game n't lose warriors take a castle army stay fight ) take control a castle recruit new warriors army — formally capture $$$ i $$$ -th castle $$$ b_i $$$ warriors join army furthermore capture a castle ( later ) defend : leave least one warrior a castle castle consider defend castle importance parameter $$$ c_i $$$ total score sum importance value defend castle two ways defend a castle : obviously order warrior defend castle leave army capture castle fix order : capture first one second one , capture castle $$$ i $$$ ( capture castle $$$ i + 1 $$$ ) may recruit new warriors castle $$$ i $$$ leave a warrior defend castle $$$ i $$$ use number portals lead castle $$$ i $$$ castle smaller number soon capture next castle action castle $$$ i $$$ wo n't available , moment game n't enough warriors capture next castle lose goal maximize sum importance value defend castle ( note may hire new warriors last castle defend use portals lead even capture — score calculate afterwards ) determine optimal strategy capture defend castle ? first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n \le 5000 $$$ $$$ 0 \le m \le \min ( \frac { n ( n - 1 ) } { 2 } 3 \cdot 100000 ) $$$ $$$ 0 \le k \le 5000 $$$ ) — number castle number portals initial size army respectively $$$ n $$$ line follow $$$ i $$$ -th line describe $$$ i $$$ -th castle three integers $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ ( $$$ 0 \le a_i b_i c_i \le 5000 $$$ ) — number warriors require capture $$$ i $$$ -th castle number warriors available hire castle importance value $$$ m $$$ line follow $$$ i $$$ -th line describe $$$ i $$$ -th portal two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le v_i < u_i \le n $$$ ) mean portal lead castle $$$ u_i $$$ castle $$$ v_i $$$ two portals list guarantee size army wo n't exceed $$$ 5000 $$$ circumstances ( i. e. $$$ k + \sum\limits _ { i = 1 } ^ { n } b_i \le 5000 $$$ ) 's impossible capture castle print one integer $$$ -1 $$$ otherwise print one integer equal maximum sum importance value defend castle best course action first example follow : course action ( several ones ) give $$$ 5 $$$ total score best course action second example follow : course action ( several ones ) give $$$ 22 $$$ total score third example 's impossible capture last castle : need $$$ 14 $$$ warriors accumulate $$$ 13 $$$ without capture","['data structures', 'dp', 'greedy', 'implementation']",2100.0
1272/B,recently buy a snow walk robot bring home suppose home a cell $$$ ( 0 0 ) $$$ infinite grid also sequence instructions robot write string $$$ s $$$ consist character ' l ' ' r ' ' u ' 'd ' robot cell $$$ ( x y ) $$$ right move one adjacent cells ( depend current instruction ) ' ve notice warn last page manual : robot visit cell ( except $$$ ( 0 0 ) $$$ ) twice break sequence instructions valid robot start cell $$$ ( 0 0 ) $$$ perform give instructions visit cell $$$ ( 0 0 ) $$$ two time end path cell $$$ ( 0 0 ) $$$ also cell $$$ ( 0 0 ) $$$ visit two time : begin end ( path empty visit ) example follow sequence instructions consider valid : ` ` <unknown> '' ` ` rl '' ` ` <unknown> '' follow consider invalid : ` ` u '' ( endpoint $$$ ( 0 0 ) $$$ ) ` ` <unknown> '' ( cell $$$ ( 0 1 ) $$$ visit twice ) initial sequence instructions however might valid n't want robot break decide <unknown> follow way : remove ( possibly none ) instructions initial sequence instructions rearrange remain instructions wish turn robot move task remove instructions initial sequence possible rearrange remain ones sequence valid report valid sequence maximum length obtain note choose order remain instructions ( n't need minimize number swap similar metric ) answer $$$ q $$$ independent test case first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 20000 $$$ ) — number test case next $$$ q $$$ line contain test case $$$ i $$$ -th test case give string $$$ s $$$ consist least $$$ 1 $$$ $$$ 100000 $$$ character ' l ' ' r ' ' u ' 'd ' — initial sequence instructions guarantee sum $$$ |s| $$$ ( $$$ |s| $$$ length $$$ s $$$ ) exceed $$$ 100000 $$$ test case ( $$$ \sum |s| \le 100000 $$$ ) test case print answer first line print maximum number remain instructions second line print valid sequence remain instructions $$$ t $$$ robot perform move perform leave right order print sequence several answer print answer $$$ 0 $$$ allow print empty line ( n't print ) two possible answer first test case : ` ` lr '' ` ` rl '' picture correspond second test case : another correct answer third test case : ` ` <unknown> '',"['greedy', 'implementation']",1200.0
1277/B,$$$ n $$$ positive integers $$$ a_1 a_2 \dots a_n $$$ one move choose even value $$$ c $$$ divide two elements equal $$$ c $$$ example $$$ a= [ <unknown> ] $$$ choose $$$ <unknown> $$$ $$$ a $$$ transform $$$ a= [ <unknown> ] $$$ move need find minimal number move transform $$$ a $$$ array odd integers ( element n't divisible $$$ 2 $$$ ) first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case input $$$ t $$$ test case follow first line a test case contain $$$ n $$$ ( $$$ 1 \le n \le 2\cdot100000 $$$ ) — number integers sequence $$$ a $$$ second line contain positive integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) sum $$$ n $$$ test case input n't exceed $$$ 2\cdot100000 $$$ $$$ t $$$ test case print answer order test case input answer test case minimal number move need make number test case odd ( i.e divisible $$$ 2 $$$ ) first test case example optimal sequence move follow : thus number become odd $$$ 4 $$$ move $$$ 3 $$$ fewer move make odd,['greedy'],1200.0
1278/C,karlsson recently discover a huge stock berry jam jar basement house specifically $$$ 2n $$$ jar strawberry blueberry jam $$$ 2n $$$ jar arrange a row stairs basement exactly middle row karlsson enter basement see exactly $$$ n $$$ jar leave $$$ n $$$ jar right example basement might look like : <unknown> man immediately start eat jam one minute choose empty either first non - empty jar leave first non - empty jar right finally karlsson decide end amount full strawberry blueberry jam jar become example might result : jar number $$$ 1 $$$ $$$ 2n $$$ leave right karlsson initially stand jar $$$ n $$$ $$$ n+1 $$$ minimum number jar karlsson require empty equal number full strawberry blueberry jam jar leave ? program answer $$$ t $$$ independent test case first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) second line test case contain $$$ 2n $$$ integers $$$ a_1 a_2 \dots a _ { 2n } $$$ ( $$$ 1 \le a_i \le 2 $$$ ) — $$$ a_i=1 $$$ mean $$$ i $$$ -th jar leave a strawberry jam jar $$$ <unknown> $$$ mean a blueberry jam jar guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print answer — minimum number jar karlsson require empty equal number full strawberry blueberry jam jar leave picture statement describe first test case second test case number strawberry blueberry jam jar already equal third test case karlsson require eat $$$ 6 $$$ jar remain $$$ 0 $$$ jar jam fourth test case karlsson empty either second third jar third fourth one scenarios leave $$$ 1 $$$ jar jam,"['data structures', 'dp', 'greedy', 'implementation']",1700.0
1279/D,"santa claus receive letter $$$ n $$$ different kid throughout year course kid want get present santa : particular $$$ i $$$ -th kid ask santa give one $$$ k_i $$$ different items a present items could ask multiple kid santa really busy want new year bot choose present children unfortunately bot 's algorithm choose present bug choose a present kid bot follow : kid $$$ z $$$ list item $$$ y $$$ item want receive decision valid otherwise bot 's choice invalid santa aware bug ca n't estimate bug really severe , want know probability one decision generate accord aforementioned algorithm valid help ? first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — number kid write letter santa $$$ n $$$ line follow $$$ i $$$ -th contain a list items want $$$ i $$$ -th kid follow format : $$$ k_i $$$ $$$ a _ { i 1 } $$$ $$$ a _ { i 2 } $$$ ... $$$ a _ { i k_i } $$$ ( $$$ 1 \le k_i a _ { i j } \le 1000000 $$$ ) $$$ k_i $$$ number items want $$$ i $$$ -th kid $$$ a _ { i j } $$$ items item contain list guarantee $$$ \sum \limits _ { i = 1 } ^ { n } k_i \le 1000000 $$$ print <unknown> bot produce a valid decision follow : let probability represent irreducible fraction $$$ \frac { x } { y } $$$ print $$$ x \cdot y^ { -1 } \mod 998244353 $$$ $$$ y^ { -1 } $$$ inverse element $$$ y $$$ modulo $$$ 998244353 $$$ ( integer $$$ y \cdot y^ { -1 } $$$ remainder $$$ 1 $$$ modulo $$$ 998244353 $$$ )",['math'],1700.0
128/D,one day anna get follow task school : arrange several number a circle two neighbor number differ exactly 1 . anna give several number arrange a circle fulfill task want check arrange number correctly point younger sister maria come shuffle number anna get sick anger 's do do result work destroy please tell anna : could <unknown> complete task use give number ? first line contain integer n — many number anna ( 3 ≤ n ≤ 105 ) next line contain number separate a space number integers belong range 1 109 . print single line ` ` yes '' ( without quote ) anna could complete task correctly use number ( use necessary ) anna could n't fulfil task matter hard would try print ` ` '' ( without quote ),['implementation'],2000.0
1280/A,"start a string $$$ s $$$ consist digits $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ length $$$ s $$$ denote $$$ |s| $$$ $$$ i $$$ $$$ 1 $$$ $$$ |s| $$$ $$$ i $$$ -th character $$$ s $$$ denote $$$ s_i $$$ one cursor cursor 's location $$$ \ell $$$ denote integer $$$ \ { 0 \ldots <unknown> } $$$ follow mean : denote $$$ s_\text { leave } $$$ string leave cursor $$$ s_\text { right } $$$ string right cursor also a string $$$ c $$$ call <unknown> start empty three type action : cursor initially start $$$ \ell = 0 $$$ , perform follow procedure : 're give initial string $$$ s $$$ integer $$$ x $$$ length $$$ s $$$ procedure stop ? since value may large find modulo $$$ 1000000000 + 7 $$$ guarantee $$$ \ell \le |s| $$$ time first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) denote number test case next line contain descriptions test case first line test case contain a single integer $$$ x $$$ ( $$$ 1 \le x \le 1000000 $$$ ) second line test case consist initial string $$$ s $$$ ( $$$ 1 \le |s| \le 500 $$$ ) guarantee $$$ s $$$ consist character ` ` 1 '' ` ` 2 '' ` ` 3 '' guarantee sum $$$ x $$$ a single file $$$ 1000000 $$$ guarantee test case procedure stop true $$$ \ell \le |s| $$$ time test case output a single line contain a single integer denote answer test case modulo $$$ 1000000000 + 7 $$$ let 's illustrate happen first test case initially $$$ s = $$$ 231 . initially $$$ \ell = 0 $$$ $$$ c = \varepsilon $$$ ( empty string ) follow things happen follow procedure : end procedure $$$ s $$$ length $$$ 25 $$$","['implementation', 'math']",1700.0
1283/E,oh new year time gather friends reflect <unknown> events past year ... $$$ n $$$ friends live a city represent a number line $$$ i $$$ -th friend live a house integer coordinate $$$ x_i $$$ $$$ i $$$ -th friend come celebrate new year house coordinate $$$ <unknown> $$$ $$$ <unknown> $$$ stay $$$ x_i $$$ friend allow move friends $$$ 1 \le x_i \le n $$$ hold however come house coordinate $$$ 0 $$$ $$$ n+1 $$$ ( house $$$ 1 $$$ $$$ n $$$ respectively ) example let initial position $$$ x = [ 1 2 4 4 ] $$$ final ones $$$ [ 1 3 3 4 ] $$$ $$$ [ 0 2 3 3 ] $$$ $$$ [ 2 2 5 5 ] $$$ $$$ [ 2 1 3 5 ] $$$ number occupy house number distinct position among final ones friends choose move want perform number occupy house calculate minimum maximum number occupy house ? first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number friends second line contain $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ 1 \le x_i \le n $$$ ) — coordinate house friends print two integers — minimum maximum possible number occupy house move perform first example friends go $$$ [ 2 2 3 3 ] $$$ friend $$$ 1 $$$ go $$$ x_1 + 1 $$$ friend $$$ 2 $$$ stay house $$$ x_2 $$$ friend $$$ 3 $$$ go $$$ x_3 - 1 $$$ friend $$$ 4 $$$ go $$$ x_4 - 1 $$$ $$$ [ 1 1 3 3 ] $$$ $$$ [ 2 2 3 3 ] $$$ $$$ [ 2 2 4 4 ] $$$ also valid options obtain $$$ 2 $$$ occupy house maximum number occupy house friends go $$$ [ 1 2 3 4 ] $$$ $$$ [ 0 2 4 5 ] $$$ example,"['dp', 'greedy']",1800.0
1286/D,"infinitely long line chillland collider ( lcc ) build chillland $$$ n $$$ pip coordinate $$$ x_i $$$ connect lcc experiment start time 0 $$$ i $$$ -th proton fly $$$ i $$$ -th pipe speed $$$ v_i $$$ fly right probability $$$ p_i $$$ fly leave probability $$$ ( 1 - p_i ) $$$ duration experiment determine time first collision two protons case collision duration experiment consider zero find expect value duration experiment first line input contain one integer $$$ n $$$ — number pip ( $$$ 1 \le n \le 100000 $$$ ) follow $$$ n $$$ line contain three integers $$$ x_i $$$ $$$ v_i $$$ $$$ p_i $$$ — coordinate $$$ i $$$ -th pipe speed $$$ i $$$ -th proton probability $$$ i $$$ -th proton fly right percentage point ( $$$ -1000000000 \le x_i \le 1000000000 1 \le v \le 1000000 0 \le p_i \le 100 $$$ ) guarantee $$$ x_i $$$ distinct sort increase order 's possible prove answer always represent a fraction $$$ p / q $$$ $$$ p $$$ integer $$$ q $$$ a natural number divisible $$$ 998\,244\,353 $$$ case print $$$ p \cdot q^ { -1 } $$$ modulo $$$ 998\,244\,353 $$$","['data structures', 'math']",3100.0
1291/B,'re give array $$$ a_1 \ldots a_n $$$ $$$ n $$$ non - negative integers let 's call sharpen exist integer $$$ 1 \le k \le n $$$ $$$ a_1 < a_2 < \ldots < a_k $$$ $$$ a_k > a _ { k+1 } > \ldots > a_n $$$ particular strictly increase strictly decrease array sharpen example : follow operation many time want : choose strictly positive element array decrease one formally choose $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) $$$ a_i > 0 $$$ assign $$$ a_i : = a_i - 1 $$$ tell 's possible make give array sharpen use number ( possibly zero ) operations input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 15\ 000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) second line test case contain a sequence $$$ n $$$ non - negative integers $$$ a_1 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 300000 $$$ test case output a single line contain ` ` yes '' ( without quote ) 's possible make give array sharpen use describe operations ` ` '' ( without quote ) otherwise first second test case first test give array already sharpen third test case first test transform array $$$ [ 3 11 15 9 7 4 ] $$$ ( decrease first element $$$ 97 $$$ time decrease last element $$$ 4 $$$ time ) sharpen $$$ 3 < 11 < 15 $$$ $$$ 15 > 9 > 7 > 4 $$$ fourth test case first test 's impossible make give array sharpen,"['greedy', 'implementation']",1300.0
1293/B,dear cafe 's owner joe <unknown> soon take part a new game tv - show ` ` 1 <unknown> $$$ n $$$ ` ` ! game go round round host ask joe opponents a common question participants fail answer eliminate show end joe remain ( assume joe never answer a question wrong ! ) question joe answer $$$ s $$$ ( $$$ s > 0 $$$ ) opponents remain $$$ t $$$ ( $$$ 0 \le t \le s $$$ ) make a mistake joe receive $$$ <unknown> { t } { s } $$$ dollars consequently $$$ s - t $$$ opponents leave next question joe wonder maximum possible reward receive best possible scenario yet little time show start help answer instead ? first single line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) denote number joe 's opponents show print a number denote maximum prize ( dollars ) joe could answer consider correct 's absolute relative error wo n't exceed $$$ 10^ { -4 } $$$ word answer $$$ a $$$ jury answer $$$ b $$$ must hold $$$ \frac { |a - b| } { max ( 1 b ) } \le 10^ { -4 } $$$ second example best scenario would : one contestant fail first question fail next one total reward $$$ \displaystyle \frac { 1 } { 2 } + \frac { 1 } { 1 } = 1.5 $$$ dollars,"['greedy', 'math']",1000.0
1294/A,polycarp three sisters : alice barbara cerene 're collect coin currently alice $$$ a $$$ coin barbara $$$ b $$$ coin cerene $$$ c $$$ coin recently polycarp return trip around world bring $$$ n $$$ coin want distribute $$$ n $$$ coin sisters a way number coin alice equal number coin barbara equal number coin cerene word polycarp give $$$ a $$$ coin alice $$$ b $$$ coin barbara $$$ c $$$ coin cerene ( $$$ a+b+c = n $$$ ) $$$ a + a = b + b = c + c $$$ note a b c ( number coin polycarp give alice barbara cerene correspondingly ) 0 . task find possible distribute $$$ n $$$ coin sisters a way describe answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case next $$$ t $$$ line describe test case test case give a new line consist four space - separated integers $$$ a b c $$$ $$$ n $$$ ( $$$ 1 \le a b c n \le 100000000 $$$ ) — number coin alice number coin barbara number coin cerene number coin polycarp test case print ` ` yes '' polycarp distribute $$$ n $$$ coin sisters ` ` '' otherwise,['math'],800.0
1294/B,"a robot a warehouse $$$ n $$$ package want collect warehouse represent a coordinate grid initially robot stay point $$$ ( 0 0 ) $$$ $$$ i $$$ -th package point $$$ ( x_i y_i ) $$$ guarantee two package point also guarantee point $$$ ( 0 0 ) $$$ n't contain a package robot semi - broken move ( ' u ' ) right ( ' r ' ) word one move robot go point $$$ ( x y ) $$$ point ( $$$ x + 1 y $$$ ) point $$$ ( x y + 1 ) $$$ say robot want collect $$$ n $$$ package ( arbitrary order ) want minimum possible number move several possible traversals robot want choose lexicographically smallest path string $$$ s $$$ length $$$ n $$$ lexicographically less string $$$ t $$$ length $$$ n $$$ index $$$ 1 \le j \le n $$$ $$$ i $$$ $$$ 1 $$$ $$$ j-1 $$$ $$$ s_i = t_i $$$ $$$ s_j < t_j $$$ standard comparison string like a dictionary program languages compare string way first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case test case follow first line a test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — number package next $$$ n $$$ line contain descriptions package $$$ i $$$ -th package give two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \le x_i y_i \le 1000 $$$ ) — $$$ x $$$ -coordinate package $$$ y $$$ -coordinate package guarantee two package point also guarantee point $$$ ( 0 0 ) $$$ n't contain a package sum value $$$ n $$$ test case test n't exceed $$$ 1000 $$$ print answer test case impossible collect $$$ n $$$ package order start ( $$$ 0,0 $$$ ) print ` ` '' first line otherwise print ` ` yes '' first line print shortest path — a string consist character ' r ' ' u ' among paths choose lexicographically smallest path note problem ` ` yes '' ` ` '' uppercase word i.e ` ` yes '' ` ` '' ` ` yes '' acceptable first test case example optimal path <unknown> show :",['implementation'],1200.0
1296/C,"a robot a coordinate plane initially robot locate point $$$ ( 0 0 ) $$$ path describe a string $$$ s $$$ length $$$ n $$$ consist character ' l ' ' r ' ' u ' 'd ' character correspond move : company create robot ask optimize path robot somehow , remove non - empty substring path company n't want customers notice change robot behavior mean optimization robot end path point $$$ ( x_e y_e ) $$$ optimization ( i.e remove single substring $$$ s $$$ ) robot also end path point $$$ ( x_e y_e ) $$$ optimization a low - budget project need remove shortest possible non - empty substring optimize robot 's path endpoint path n't change possible ca n't optimize path also possible optimization target path empty string ( i.e delete substring whole string $$$ s $$$ ) recall substring $$$ s $$$ string obtain $$$ s $$$ remove amount character ( possibly zero ) prefix amount character ( possibly zero ) suffix example substrings ` ` lurllr '' ` ` lu '' ` ` lr '' ` ` lurllr '' ` ` <unknown> '' ` ` rr '' ` ` ul '' answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next $$$ 2 t $$$ line describe test case test case give two line first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length robot 's path second line test case contain one string $$$ s $$$ consist $$$ n $$$ character ' l ' ' r ' ' u ' 'd ' — robot 's path guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print answer remove non - empty substring endpoint robot 's path n't change print -1 . otherwise print two integers $$$ l $$$ $$$ r $$$ $$$ 1 \le l \le r \le n $$$ — endpoints substring remove value $$$ r - l+1 $$$ minimum possible several answer print","['data structures', 'implementation']",1500.0
1299/A,<unknown> create function $$$ f $$$ : $$$ f ( x y ) = ( x | y ) - y $$$ $$$ | $$$ denote bitwise operation example $$$ f ( 11 6 ) = ( <unknown> ) - 6 = 15 - 6 = 9 $$$ prove nonnegative number $$$ x $$$ $$$ y $$$ value $$$ f ( x y ) $$$ also nonnegative would like research function create multiple problems n't able solve need help one problems a value array $$$ [ a_1 a_2 \dots a_n ] $$$ define $$$ f ( f ( \dots f ( f ( a_1 a_2 ) a_3 ) \dots a _ { n-1 } ) a_n ) $$$ ( see note ) give array necessarily distinct elements reorder elements value array maximal possible ? first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) elements array guarantee different output $$$ n $$$ integers reorder array maximum value multiple answer print first testcase value array $$$ [ 11 6 4 0 ] $$$ $$$ f ( f ( f ( 11 6 ) 4 ) 0 ) = f ( f ( 9 4 ) 0 ) = f ( 9 0 ) = 9 $$$ $$$ [ 11 4 0 6 ] $$$ also a valid answer,"['greedy', 'math']",1500.0
1299/C,$$$ n $$$ water tank a row $$$ i $$$ -th contain $$$ a_i $$$ liters water tank number $$$ 1 $$$ $$$ n $$$ leave right perform follow operation : choose subsegment $$$ [ l r ] $$$ ( $$$ 1\le l \le r \le n $$$ ) redistribute water tank $$$ l l+1 \dots r $$$ evenly word replace $$$ a_l a _ { l+1 } \dots a_r $$$ $$$ \frac { a_l + a _ { l+1 } + \dots + a_r } { r - l+1 } $$$ example volumes $$$ [ 1 3 6 7 ] $$$ choose $$$ l = 2 r = 3 $$$ new volumes water $$$ [ 1 4.5 4.5 7 ] $$$ perform operation number time lexicographically smallest sequence volumes water achieve ? a reminder : a sequence $$$ a $$$ lexicographically smaller a sequence $$$ b $$$ length follow hold : first ( leftmost ) position $$$ a $$$ $$$ b $$$ differ sequence $$$ a $$$ a smaller element correspond element $$$ b $$$ first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — number water tank second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) — initial volumes water water tank liters large input read input double recommend print lexicographically smallest sequence get $$$ i $$$ -th line print final volume water $$$ i $$$ -th tank answer consider correct absolute relative error $$$ a_i $$$ exceed $$$ 10^ { -9 } $$$ formally let answer $$$ a_1 a_2 \dots a_n $$$ jury 's answer $$$ b_1 b_2 \dots b_n $$$ answer accept $$$ \frac { |a_i - b_i| } { \max { ( 1 |b_i| ) } } \le 10^ { -9 } $$$ $$$ i $$$ first sample get sequence apply operation subsegment $$$ [ 1 3 ] $$$ second sample ca n't get lexicographically smaller sequence,"['data structures', 'greedy']",2100.0
1299/D,"guy - manuel thomas plan $$$ 144 $$$ trip around world give a simple weight undirected connect graph $$$ n $$$ vertexes $$$ m $$$ edge follow restriction : n't simple cycle ( i. e. a cycle n't pass vertex ) length greater $$$ 3 $$$ pass vertex $$$ 1 $$$ cost a path ( necessarily simple ) graph define xor weight edge path edge count many time path pass trip cost $$$ 0 $$$ n't excite may choose subset edge incident vertex $$$ 1 $$$ remove many subsets , remove nontrivial cycle cost equal $$$ 0 $$$ pass vertex $$$ 1 $$$ result graph ? a cycle call nontrivial pass edge odd number time answer big output modulo $$$ 1000000000 + 7 $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100000 $$$ ) — number vertexes edge graph $$$ i $$$ -th next $$$ m $$$ line contain three integers $$$ a_i $$$ $$$ b_i $$$ $$$ w_i $$$ ( $$$ 1 \le a_i b_i \le n a_i \neq b_i 0 \le w_i < 32 $$$ ) — endpoints $$$ i $$$ -th edge weight 's guarantee n't multiple edge graph connect n't simple cycle length greater $$$ 3 $$$ pass vertex $$$ 1 $$$ output answer modulo $$$ 1000000000 + 7 $$$ picture represent graph examples first example n't nontrivial cycle cost $$$ 0 $$$ either remove keep edge incident vertex $$$ 1 $$$ second example n't remove edge $$$ 1 - 2 $$$ a cycle $$$ 1 - 2 - 4 - 5 - 2 - 1 $$$ cost $$$ 0 $$$ ; also n't remove edge $$$ 1 - 3 $$$ a cycle $$$ 1 - 3 - 2 - 4 - 5 - 2 - 3 - 1 $$$ cost $$$ 0 $$$ valid subset consist edge third example subsets valid except two edge $$$ 1 - 3 $$$ $$$ 1 - 4 $$$ keep","['dp', 'math']",3000.0
1301/B,"dark go attend motarack 's birthday dark decide gift go give motarack array $$$ a $$$ $$$ n $$$ non - negative integers dark create array $$$ 1000 $$$ years ago elements array disappear dark know motarack hat see array two adjacent elements a high absolute difference n't much time want choose integer $$$ k $$$ ( $$$ 0 \leq k \leq 10^ { 9 } $$$ ) replace miss elements array $$$ a $$$ $$$ k $$$ let $$$ m $$$ maximum absolute difference adjacent elements ( i.e maximum value $$$ |a_i - a _ { i+1 } | $$$ $$$ 1 \leq i \leq n - 1 $$$ ) array $$$ a $$$ dark replace miss elements $$$ k $$$ dark choose integer $$$ k $$$ $$$ m $$$ minimize help ? input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 2 \leq n \leq 10^ { 5 } $$$ ) — size array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1 \leq a_i \leq 10 ^ { 9 } $$$ ) $$$ a_i = -1 $$$ $$$ i $$$ -th integer miss guarantee least one integer miss every test case guarantee sum $$$ n $$$ test case exceed $$$ 40 ^ { 5 } $$$ print answer test case follow format : print two integers minimum possible value $$$ m $$$ integer $$$ k $$$ ( $$$ 0 \leq k \leq 10^ { 9 } $$$ ) make maximum absolute difference adjacent elements array $$$ a $$$ equal $$$ m $$$ make sure replace miss elements $$$ k $$$ maximum absolute difference adjacent elements become $$$ m $$$ one possible $$$ k $$$ print first test case replace miss elements $$$ 11 $$$ array become $$$ [ 11 10 11 12 11 ] $$$ absolute difference adjacent elements $$$ 1 $$$ impossible choose a value $$$ k $$$ absolute difference adjacent element $$$ \leq 0 $$$ , answer $$$ 1 $$$ third test case replace miss elements $$$ 6 $$$ array become $$$ [ 6 6 9 6 3 6 ] $$$ , maximum difference adjacent elements $$$ 3 $$$",['greedy'],1500.0
1303/A,give a string $$$ s $$$ character either 0 1 . want 1 's string form a contiguous subsegment example string 0 1 00111 <unknown> 1 's form a contiguous subsegment string 0101 100001 <unknown> condition meet may erase ( possibly none ) 0 's string minimum number 0 's erase ? first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case $$$ t $$$ line follow represent a test case line contain one string $$$ s $$$ ( $$$ 1 \le |s| \le 100 $$$ ) ; character $$$ s $$$ either 0 1 . print $$$ t $$$ integers $$$ i $$$ -th integer answer $$$ i $$$ -th testcase ( minimum number 0 's erase $$$ s $$$ ) first test case delete third forth symbols string <unknown> ( turn 0111 ),['implementation'],800.0
1305/E,kuroni coordinator next mathforces round write ` ` proof ac '' team preparation do discuss team score distribution round round consist $$$ n $$$ problems number $$$ 1 $$$ $$$ n $$$ problems order increase order difficulty two problems difficulty a score distribution round denote array $$$ a_1 a_2 \dots a_n $$$ $$$ a_i $$$ score $$$ i $$$ -th problem kuroni think score distribution satisfy follow requirements : help team find a score distribution satisfy kuroni 's requirement case a score distribution exist output $$$ -1 $$$ first single line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 5000 $$$ $$$ 0 \leq m \leq 1000000000 $$$ ) — number problems require balance solution print a single integer $$$ -1 $$$ otherwise print a line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ represent a score distribution satisfy requirements multiple answer print first example $$$ 3 $$$ triple $$$ ( i j k ) $$$ contribute balance score distribution,"['greedy', 'implementation', 'math']",2200.0
1307/D,bessie graze farm consist $$$ n $$$ field connect $$$ m $$$ bidirectional roads currently field $$$ 1 $$$ return home field $$$ n $$$ end day <unknown> <unknown> order farmer john install one extra bidirectional road farm $$$ k $$$ special field decide install road two different special field may add road two special field already a road directly connect road add bessie return home shortest path field $$$ 1 $$$ field $$$ n $$$ since bessie need exercise farmer john must maximize length shortest path help ! first line contain integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ n-1 \le m \le 200000 $$$ $$$ 2 \le k \le n $$$ ) — number field farm number roads number special field second line contain $$$ k $$$ integers $$$ a_1 a_2 \ldots a_k $$$ ( $$$ 1 \le a_i \le n $$$ ) — special field $$$ a_i $$$ distinct $$$ i $$$ -th follow $$$ m $$$ line contain integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ ) represent a bidirectional road field $$$ x_i $$$ $$$ y_i $$$ guarantee one reach field every field also guarantee pair field one road connect output one integer maximum possible length shortest path field $$$ 1 $$$ $$$ n $$$ farmer john install one road optimally graph first example show special field denote red optimal farmer john add a road field $$$ 3 $$$ $$$ 5 $$$ result shortest path $$$ 1 $$$ $$$ 5 $$$ length $$$ 3 $$$ graph second example show farmer john must add a road field $$$ 2 $$$ $$$ 4 $$$ result shortest path $$$ 1 $$$ $$$ 5 $$$ length $$$ 3 $$$,"['data structures', 'greedy']",1900.0
1313/E,"vasya three string $$$ a $$$ $$$ b $$$ $$$ s $$$ consist lowercase english letter lengths string $$$ a $$$ $$$ b $$$ equal $$$ n $$$ length string $$$ s $$$ equal $$$ m $$$ vasya decide choose a substring string $$$ a $$$ choose a substring string $$$ b $$$ concatenate formally choose a segment $$$ [ l_1 r_1 ] $$$ ( $$$ 1 \leq l_1 \leq r_1 \leq n $$$ ) a segment $$$ [ l_2 r_2 ] $$$ ( $$$ 1 \leq l_2 \leq r_2 \leq n $$$ ) concatenation obtain a string $$$ a [ l_1 r_1 ] + b [ l_2 r_2 ] = a _ { l_1 } a _ { l_1 + 1 } \ldots a _ { r_1 } b _ { l_2 } b _ { l_2 + 1 } \ldots b _ { r_2 } $$$ , vasya interest count number ways choose segment adhere follow condition : first line contain integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 500\,000 2 \leq m \leq 2 \cdot n $$$ ) — length string $$$ a $$$ $$$ b $$$ length string $$$ s $$$ next three line contain string $$$ a $$$ $$$ b $$$ $$$ s $$$ respectively length string $$$ a $$$ $$$ b $$$ $$$ n $$$ length string $$$ s $$$ $$$ m $$$ string consist lowercase english letter print one integer — number ways choose a pair segment satisfy vasya 's condition let 's list pair segment vasya could choose first example :",['data structures'],2700.0
1315/B,a long party petya decide return home turn opposite end town home $$$ n $$$ crossroads line town either bus tram station crossroad crossroads represent a string $$$ s $$$ length $$$ n $$$ $$$ s_i = \texttt { a } $$$ a bus station $$$ i $$$ -th crossroad $$$ s_i = \texttt { b } $$$ a tram station $$$ i $$$ -th crossroad currently petya first crossroad ( correspond $$$ s_1 $$$ ) goal get last crossroad ( correspond $$$ s_n $$$ ) two crossroads $$$ i $$$ $$$ j $$$ crossroads $$$ i i+1 \ldots j-1 $$$ a bus station one pay $$$ a $$$ roubles bus ticket go $$$ i $$$ -th crossroad $$$ j $$$ -th crossroad bus ( necessary a bus station $$$ j $$$ -th crossroad ) formally pay $$$ a $$$ roubles petya go $$$ i $$$ $$$ j $$$ $$$ s_t = \texttt { a } $$$ $$$ i \le t < j $$$ two crossroads $$$ i $$$ $$$ j $$$ crossroads $$$ i i+1 \ldots j-1 $$$ a tram station one pay $$$ b $$$ roubles tram ticket go $$$ i $$$ -th crossroad $$$ j $$$ -th crossroad tram ( necessary a tram station $$$ j $$$ -th crossroad ) formally pay $$$ b $$$ roubles petya go $$$ i $$$ $$$ j $$$ $$$ s_t = \texttt { b } $$$ $$$ i \le t < j $$$ example $$$ s $$$ = '' <unknown> '' $$$ a=4 $$$ $$$ b=3 $$$ petya need : thus total need spend $$$ 4 + 3 + 4=11 $$$ roubles please note type stop last crossroad ( i.e character $$$ s_n $$$ ) affect final expense petya first crossroad want get $$$ n $$$ -th crossroad party leave $$$ p $$$ roubles 's decide go station foot go home use public transport help choose closest crossroad $$$ i $$$ go foot first enough money get $$$ i $$$ -th crossroad $$$ n $$$ -th use tram bus ticket test contain one test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) first line test case consist three integers $$$ a b p $$$ ( $$$ 1 \le a b p \le 100000 $$$ ) — cost bus ticket cost tram ticket amount money petya second line test case consist one string $$$ s $$$ $$$ s_i = \texttt { a } $$$ a bus station $$$ i $$$ -th crossroad $$$ s_i = \texttt { b } $$$ a tram station $$$ i $$$ -th crossroad ( $$$ 2 \le |s| \le 100000 $$$ ) guarantee sum length string $$$ s $$$ test case one test n't exceed $$$ 100000 $$$ test case print one number — minimal index $$$ i $$$ a crossroad petya go foot rest path ( i.e $$$ i $$$ $$$ n $$$ use public transport ),"['dp', 'greedy']",1300.0
1316/A,"$$$ n $$$ students take exam highest possible score exam $$$ m $$$ let $$$ a _ { i } $$$ score $$$ i $$$ -th student access school database store result students change student 's score long follow condition satisfy : student $$$ 1 $$$ would like maximize score find highest possible score assign condition satisfy test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 200 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 10^ { 3 } $$$ $$$ 1 \leq m \leq 10^ { 5 } $$$ ) — number students highest possible score respectively second line testcase contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \leq a _ { i } \leq m $$$ ) — score students testcase output one integer — highest possible score assign condition <unknown> first case $$$ a = [ 1,2,3,4 ] $$$ average $$$ 2.5 $$$ change array $$$ a $$$ $$$ [ <unknown> ] $$$ average remain $$$ 2.5 $$$ condition satisfy second case $$$ 0 \leq a _ { i } \leq 5 $$$ change $$$ a $$$ $$$ [ <unknown> ] $$$ increase $$$ a _ { 1 } $$$ violate condition $$$ 0\le a_i\le m $$$",['implementation'],800.0
1316/D,"<unknown> design interest yet simple board game a player simply require follow instructions write cell player currently stand board game play $$$ n\times n $$$ board row columns board number $$$ 1 $$$ $$$ n $$$ cell intersection $$$ r $$$ -th row $$$ c $$$ -th column denote $$$ ( r c ) $$$ cells board call block zone cell board write one follow $$$ 5 $$$ character — $$$ u $$$ $$$ d $$$ $$$ l $$$ $$$ r $$$ $$$ x $$$ — instructions player suppose current cell $$$ ( r c ) $$$ character $$$ r $$$ player move right cell $$$ ( r c+1 ) $$$ $$$ l $$$ player move leave cell $$$ ( r c-1 ) $$$ $$$ u $$$ player move top cell $$$ ( r-1 c ) $$$ $$$ d $$$ player move bottom cell $$$ ( r+1 c ) $$$ finally character cell $$$ x $$$ cell block zone player remain cell ( game n't interest ) guarantee character write a way player never step outside board matter cell start a player start a cell move accord character current cell player keep move land a block zone also possible player keep move infinitely long every $$$ n^2 $$$ cells board alice friend want know game go player start cell start cell board write cell player stop player never stop give information write : cell $$$ ( r c ) $$$ write : might possible alice try fool 's possible grid satisfy constraints alice give give information alice provide require decipher a possible board determine a board n't exist exist several different board satisfy provide information find first line input contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 10^ { 3 } $$$ ) — side board $$$ i $$$ -th next $$$ n $$$ line input contain $$$ 2n $$$ integers $$$ x_1 y_1 x_2 y_2 \dots x_n y_n $$$ $$$ ( x_j y_j ) $$$ ( $$$ 1 \leq x_j \leq n 1 \leq y_j \leq n $$$ $$$ ( x_j y_j ) = ( -1 -1 ) $$$ ) pair write alice cell $$$ ( i j ) $$$ n't exist a board satisfy information alice give print a single line contain invalid otherwise first line print valid $$$ i $$$ -th next $$$ n $$$ line print string $$$ n $$$ character correspond character $$$ i $$$ -th row suitable board find character a string either $$$ u $$$ $$$ d $$$ $$$ l $$$ $$$ r $$$ $$$ x $$$ exist several different board satisfy provide information find sample test 1 : give grid output a valid one simulation see : sample test 2 : give grid output a valid one a player start cell one center $$$ ( 2,2 ) $$$ keep move infinitely long cycle never stop start $$$ ( 2,2 ) $$$ would n't move follow instruction $$$ x $$$ simulation see :",['implementation'],2000.0
132/A,<unknown> <unknown> esoteric program languages one many weird feature method character - based output know turing tape method convert array unsigned 8 - bit integers a sequence character print use follow method integers array process one one start first process i - th element array do three <unknown> . 8 - bit binary notation ascii - code previous print character reverse first element array process result step consider 0.2 . i - th element array subtract result previous step modulo <unknown> . binary notation result previous step reverse produce ascii - code i - th character print give text print use method restore array use produce text input consist a single line text contain message print use describe method string text contain 1 100 character inclusive ascii - code character text 32 ( space ) 126 ( tilde ) inclusive output initial array use produce text one integer per line let 's a closer look begin example first character ` ` h '' ascii - code 72 = <unknown> . reverse <unknown> = 18 number become result second step process result first step consider 0 first element array ( 0 - 18 ) mod 256 = <unknown> a mod b remainder division a b,['implementation'],1300.0
132/B,"piet one know visual esoteric program languages program piet construct colorful block pixels interpret use pretty complicate rule problem use a subset piet language simplify rule program a rectangular image consist color black pixels color pixel give integer number 0 9 inclusive 0 denote black a block pixels define a rectangle pixels color ( black ) guarantee connect group color pixels color form rectangular block group black pixels form arbitrary shape program interpret use movement instruction pointer ( ip ) consist three part : initially bp point block contain top - left corner program dp point right cp point leave ( see orange square image ) one step program interpretation change state ip a follow way interpreter find furthest edge current color block direction dp pixels form edge interpreter select furthest one direction cp , bp attempt move pixel next one direction dp next pixel belong a color block block become current one two part ip stay next pixel black outside program bp stay two part ip change cp point leave point right dp stay cp point right point leave dp rotate 90 degrees clockwise way bp never point a black block ( guarantee top - left pixel program black ) give a piet program figure block program current n step first line input contain two integer number m ( 1 ≤ m ≤ 50 ) n ( 1 ≤ n ≤ 5·107 ) next m line contain row program line length 1 50 pixels consist character 0 - 9 . first character first line equal 0 . output color block current n step program interpretation first example ip change follow way step 1 block 2 become current one stay two step step 4 bp move block 3 step 7 — block 4 finally step 10 bp return block 1 . sequence state ip show image : arrows traverse clockwise main arrow show direction dp side one — direction cp",['implementation'],2100.0
132/D,shakespeare a widely know esoteric program language program look like play shakespeare number give combinations <unknown> <unknown> problem a closer look way number describe shakespeare constant shakespeare create non - negative power 2 use arithmetic operations simplicity 'll allow addition subtraction look a representation give number require a minimal number operations give integer n. represent n = a1 + a2 + ... + ai a non - negative power 2 possibly multiply -1 . find a representation minimize value m. line input contain a positive integer n write binary notation length notation 106 . first digit notation guarantee 1 . output require minimal m. output m line line format ` ` <unknown> '' ` ` <unknown> '' x power coefficient correspond term order line n't matter,"['dp', 'greedy']",2100.0
1320/D,problem deal binary string character a binary string either a 0 a 1 . also deal substrings ; recall a substring a contiguous subsequence a string denote substring string $$$ s $$$ start $$$ l $$$ -th character end $$$ r $$$ -th character $$$ s [ l \dots r ] $$$ character string number $$$ 1 $$$ perform several operations string consider operation choose a substring string replace another string two possible type operations : replace 011 110 replace 110 011 . example apply exactly one operation string <unknown> transform <unknown> <unknown> <unknown> . binary string $$$ a $$$ consider reachable binary string $$$ b $$$ exist a sequence $$$ s_1 $$$ $$$ s_2 $$$ ... $$$ s_k $$$ $$$ s_1 = a $$$ $$$ s_k = b $$$ every $$$ i \in [ 1 k - 1 ] $$$ $$$ s_i $$$ transform $$$ s _ { i + 1 } $$$ use exactly one operation note $$$ k $$$ equal $$$ 1 $$$ i. e. every string reachable give a string $$$ t $$$ $$$ q $$$ query query consist three integers $$$ l_1 $$$ $$$ l_2 $$$ $$$ len $$$ answer query determine whether $$$ t [ l_1 \dots l_1 + len - 1 ] $$$ reachable $$$ t [ l_2 \dots l_2 + len - 1 ] $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length string $$$ t $$$ second line contain one string $$$ t $$$ ( $$$ |t| = n $$$ ) character $$$ t $$$ either 0 1 . third line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query $$$ q $$$ line follow line represent a query $$$ i $$$ -th line contain three integers $$$ l_1 $$$ $$$ l_2 $$$ $$$ len $$$ ( $$$ 1 \le l_1 l_2 \le |t| $$$ $$$ 1 \le len \le |t| - \max ( l_1 l_2 ) + 1 $$$ ) $$$ i $$$ -th query query print either yes $$$ t [ l_1 \dots l_1 + len - 1 ] $$$ reachable $$$ t [ l_2 \dots l_2 + len - 1 ] $$$ otherwise may print letter register,['data structures'],2500.0
1320/E,"$$$ n $$$ cities treeland connect $$$ n - 1 $$$ bidirectional roads a way city reachable ; word graph cities roads a tree treeland prepare a seasonal virus epidemic currently try evaluate different infection scenarios scenario several cities initially infect different virus species suppose $$$ k_i $$$ virus species $$$ i $$$ -th scenario let us denote $$$ v_j $$$ initial city virus $$$ j $$$ $$$ s_j $$$ propagation speed virus $$$ j $$$ spread <unknown> happen turn : first virus $$$ 1 $$$ spread follow virus $$$ 2 $$$ , virus $$$ k_i $$$ spread process start virus $$$ 1 $$$ a spread turn virus $$$ j $$$ proceed follow city $$$ x $$$ infect virus start turn end turn become infect virus $$$ j $$$ a city $$$ y $$$ : a city infect a virus stay infect indefinitely infect virus spread stop cities infect need process $$$ q $$$ independent scenarios scenario describe $$$ k_i $$$ virus species $$$ m_i $$$ important cities important city determine virus infect end first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — number cities treeland follow $$$ n - 1 $$$ line describe roads $$$ i $$$ -th line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \leq x_i y_i \leq n $$$ ) — indices cities connect $$$ i $$$ -th road guarantee give graph cities roads a tree next line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 200000 $$$ ) — number infection scenarios $$$ q $$$ scenario descriptions follow description $$$ i $$$ -th scenario start a line contain two integers $$$ k_i $$$ $$$ m_i $$$ ( $$$ 1 \leq k_i m_i \leq n $$$ ) — number virus species number important cities scenario respectively guarantee $$$ \sum _ { i = 1 } ^ q k_i $$$ $$$ \sum _ { i = 1 } ^ q m_i $$$ exceed $$$ 200000 $$$ follow $$$ k_i $$$ line describe virus species $$$ j $$$ -th line contain two integers $$$ v_j $$$ $$$ s_j $$$ ( $$$ 1 \leq v_j \leq n $$$ $$$ 1 \leq s_j \leq 1000000 $$$ ) – initial city propagation speed virus species $$$ j $$$ guarantee initial cities virus species within a scenario distinct follow line contain $$$ m_i $$$ distinct integers $$$ u_1 \ldots u _ { m_i } $$$ ( $$$ 1 \leq u_j \leq n $$$ ) — indices important cities print $$$ q $$$ line $$$ i $$$ -th line contain $$$ m_i $$$ integers — indices virus species cities $$$ u_1 \ldots u _ { m_i } $$$ infect end $$$ i $$$ -th scenario","['data structures', 'dp']",3000.0
1322/B,"<unknown> receive array integers a gift march 8 . eventually grow bore start calculate various useless characteristics succeed one come come another one — xor pairwise sum elements array realize could n't compute a large array thus ask help ? formally need compute $$$ $$$ ( a_1 + a_2 ) \oplus ( a_1 + a_3 ) \oplus \ldots \oplus ( a_1 + a_n ) \\ \oplus ( a_2 + a_3 ) \oplus \ldots \oplus ( a_2 + a_n ) \\ \ldots \\ \oplus ( a _ { n-1 } + a_n ) \\ $$$ $$$ $$$ x \oplus y $$$ a bitwise xor operation ( i.e $$$ x $$$ ^ $$$ y $$$ many modern program languages ) read wikipedia : https : //en.wikipedia.org / wiki / <unknown> # bitwise_operation first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 400\,000 $$$ ) — number integers array second line contain integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 10000000 $$$ ) print a single integer — xor pairwise sum integers give array first sample case one sum $$$ 1 + 2 = 3 $$$ second sample case three sum : $$$ 1 + 2 = 3 $$$ $$$ 1 + 3 = 4 $$$ $$$ 2 + 3 = 5 $$$ binary represent $$$ 011_2 \oplus <unknown> \oplus 101_2 = 010_2 $$$ thus answer 2 $$$ \oplus $$$ bitwise xor operation define $$$ x \oplus y $$$ consider binary representations integers $$$ x $$$ $$$ y $$$ put $$$ i $$$ -th bite result 1 exactly one $$$ i $$$ -th bits $$$ x $$$ $$$ y $$$ 1 . otherwise $$$ i $$$ -th bite result put 0 . example $$$ <unknown> \ \oplus \ <unknown> = <unknown> $$$","['data structures', 'math']",2100.0
1323/A,give array $$$ a $$$ consist $$$ n $$$ positive integers find a non - empty subset elements sum even ( i.e divisible $$$ 2 $$$ ) determine subset give array require subset may contain equal value first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) number test case solve descriptions $$$ t $$$ test case follow a description test case consist two line first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 100 $$$ ) elements $$$ a $$$ give array $$$ a $$$ contain equal value ( duplicate ) test case output $$$ -1 $$$ subset elements otherwise output positive integer $$$ k $$$ number elements require subset output $$$ k $$$ distinct integers ( $$$ 1 \leq p_i \leq n $$$ ) index choose elements multiple solutions output three test case example first test case choose subset consist second element sum $$$ 4 $$$ even second test case one non - empty subset elements consist first element however sum odd solution third test case subset consist array 's elements even sum,"['dp', 'greedy', 'implementation']",800.0
1324/E,vova a pretty weird sleep schedule $$$ h $$$ hours a day vova sleep exactly $$$ n $$$ time $$$ i $$$ -th time sleep exactly $$$ a_i $$$ hours time wake assume vova wake exactly begin story ( initial time $$$ 0 $$$ ) time vova sleep exactly one day ( word $$$ h $$$ hours ) vova think $$$ i $$$ -th sleep time good start sleep hours $$$ l $$$ $$$ r $$$ inclusive vova control $$$ i $$$ -th time choose two options : go sleep $$$ a_i $$$ hours $$$ a_i - 1 $$$ hours task say maximum number good sleep time vova obtain act optimally first line input contain four integers $$$ n h l $$$ $$$ r $$$ ( $$$ 1 \le n \le 2000 3 \le h \le 2000 0 \le l \le r < h $$$ ) — number time vova go sleep number hours a day segment good sleep time second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i < h $$$ ) $$$ a_i $$$ number hours vova go sleep $$$ i $$$ -th time print one integer — maximum number good sleep time vova obtain act optimally maximum number good time example $$$ 3 $$$ story start $$$ t=0 $$$ vova go sleep $$$ a_1 - 1 $$$ hours time $$$ 15 $$$ time good vova go sleep $$$ a_2 - 1 $$$ hours time $$$ 15 + 16 = 7 $$$ time also good vova go sleep $$$ a_3 $$$ hours time $$$ 7 + 14 = 21 $$$ time good vova go sleep $$$ a_4 - 1 $$$ hours time $$$ 21 + 19 = 16 $$$ time good vova go sleep $$$ a_5 $$$ hours time $$$ 16 + 20 = 12 $$$ time good vova go sleep $$$ a_6 $$$ hours time $$$ 12 + 11 = 23 $$$ time good vova go sleep $$$ a_7 $$$ hours time $$$ 23 + 22 = 21 $$$ time also good,"['dp', 'implementation']",1700.0
1325/A,"give a positive integer $$$ x $$$ find $$$ 2 $$$ positive integers $$$ a $$$ $$$ b $$$ $$$ gcd ( a b ) + lcm ( a b ) = x $$$ a reminder $$$ gcd ( a b ) $$$ greatest integer divide $$$ a $$$ $$$ b $$$ similarly $$$ lcm ( a b ) $$$ smallest integer $$$ a $$$ $$$ b $$$ divide 's guarantee solution always exist several pair $$$ ( a b ) $$$ output first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 100 ) $$$ — number testcases testcase consist one line contain a single integer $$$ x $$$ $$$ ( 2 \le x \le 1000000000 ) $$$ testcase output a pair positive integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le 1000000000 ) $$$ $$$ gcd ( a b ) + lcm ( a b ) = x $$$ 's guarantee solution always exist several pair $$$ ( a b ) $$$ output first testcase sample $$$ gcd ( 1,1 ) + lcm ( 1,1 ) = 1 + 1=2 $$$ second testcase sample $$$ gcd ( 6,4 ) + lcm ( 6,4 ) = 2 + <unknown> $$$",['greedy'],800.0
1326/B,"alicia array $$$ a_1 a_2 \ldots a_n $$$ non - negative integers $$$ 1 \leq i \leq n $$$ find a non - negative integer $$$ x_i = max ( 0 a_1 \ldots a _ { i-1 } ) $$$ note $$$ i=1 $$$ $$$ x_i = 0 $$$ example alicia array $$$ a = \ { 0 1 2 0 3\ } $$$ $$$ x = \ { 0 0 1 2 2\ } $$$ , calculate array $$$ b_1 b_2 \ldots b_n $$$ : $$$ b_i = a_i - x_i $$$ example alicia array $$$ a = \ { 0 1 2 0 3\ } $$$ $$$ b = \ { 0 - 0 1 - 0 2 - 1 0 - 2 3 - 2\ } = \ { 0 1 1 -2 1\ } $$$ alicia give value $$$ b_1 b_2 \ldots b_n $$$ ask restore value $$$ a_1 a_2 \ldots a_n $$$ help solve problem ? first line contain one integer $$$ n $$$ ( $$$ 3 \leq n \leq 200\,000 $$$ ) – number elements alicia 's array next line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ -1000000000 \leq b_i \leq 1000000000 $$$ ) guarantee give array $$$ b $$$ a solution $$$ a_1 a_2 \ldots a_n $$$ elements follow true : $$$ 0 \leq a_i \leq 1000000000 $$$ print $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) calculate $$$ x $$$ accord statement $$$ b_1 $$$ equal $$$ a_1 - x_1 $$$ $$$ b_2 $$$ equal $$$ a_2 - x_2 $$$ ... $$$ b_n $$$ equal $$$ a_n - x_n $$$ guarantee exist least one solution give test show solution unique first test describe problem statement second test alicia array $$$ a = \ { 1000 1000000000 0\ } $$$ $$$ x = \ { 0 1000 1000000000\ } $$$ $$$ b = \ { 1000 - 0 1000000000 - 1000 0 - 1000000000\ } = \ { 1000 <unknown> <unknown> } $$$","['implementation', 'math']",900.0
1327/F,give three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ $$$ m $$$ condition $$$ ( l_1 r_1 x_1 ) ( l_2 r_2 x_2 ) \dots ( l_m r_m x_m ) $$$ calculate number distinct array $$$ a $$$ consist $$$ n $$$ integers : two array $$$ a $$$ $$$ b $$$ consider different exist a position $$$ i $$$ $$$ a_i \neq b_i $$$ number pretty large print modulo $$$ 998244353 $$$ first line contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \le n \le 500000 $$$ $$$ 1 \le k \le 30 $$$ $$$ 0 \le m \le 500000 $$$ ) — length array $$$ a $$$ value number $$$ a $$$ smaller $$$ 2^k $$$ number condition respectively next $$$ m $$$ line contain description a condition $$$ l_i $$$ $$$ r_i $$$ $$$ x_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ $$$ 0 \le x_i < 2^k $$$ ) — border condition segment require bitwise value print a single integer — number distinct array $$$ a $$$ satisfy condition modulo $$$ 998244353 $$$ recall a bitwise operation first example answer follow array : $$$ [ 3 3 7 6 ] $$$ $$$ [ 3 7 7 6 ] $$$ $$$ [ 7 3 7 6 ] $$$,"['data structures', 'dp']",2500.0
1329/A,"dreamoon like color cells much a row $$$ n $$$ cells initially cells empty ( n't contain color ) cells number $$$ 1 $$$ $$$ n $$$ give integer $$$ m $$$ $$$ m $$$ integers $$$ l_1 l_2 \ldots l_m $$$ ( $$$ 1 \le l_i \le n $$$ ) dreamoon perform $$$ m $$$ operations $$$ i $$$ -th operation dreamoon choose a number $$$ p_i $$$ range $$$ [ 1 n - l_i+1 ] $$$ ( inclusive ) paint cells $$$ p_i $$$ $$$ <unknown> $$$ ( inclusive ) $$$ i $$$ -th color note cells may color one case cell color latest operation dreamoon hop $$$ m $$$ operations color appear least cells color please help dreamoon choose $$$ p_i $$$ operation satisfy constraints first line contain two integers $$$ n m $$$ ( $$$ 1 \leq m \leq n \leq 100\,000 $$$ ) second line contain $$$ m $$$ integers $$$ l_1 l_2 \ldots l_m $$$ ( $$$ 1 \leq l_i \leq n $$$ ) 's impossible perform $$$ m $$$ operations satisfy constraints print ` ` ' -1 '' ( without quote ) otherwise print $$$ m $$$ integers $$$ p_1 p_2 \ldots p_m $$$ ( $$$ 1 \leq p_i \leq n - l_i + 1 $$$ ) $$$ m $$$ operations color appear least cells color several possible solutions print","['greedy', 'implementation', 'math']",1800.0
1332/A,"alice a cute cat keep cat fit alice want design exercise walk cat ! initially alice 's cat locate a cell $$$ ( x y ) $$$ infinite grid accord alice 's theory cat need move : note move perform arbitrary order example cat move $$$ 1 $$$ step leave $$$ 3 $$$ step right $$$ 2 $$$ step walk right , leave right right valid alice however worry cat might get lose move far away hop cat always area $$$ [ x_1 x_2 ] \times [ y_1 y_2 ] $$$ i.e every cat 's position $$$ ( u v ) $$$ a walk $$$ x_1 \le u \le x_2 $$$ $$$ y_1 \le v \le y_2 $$$ hold also note cat visit cell multiple time help alice find exist a walk satisfy wish ? formally walk contain exactly $$$ a+b+c+d $$$ unit move ( $$$ a $$$ leave $$$ b $$$ right $$$ c $$$ $$$ d $$$ ) alice move order current position $$$ ( u v ) $$$ always satisfy constraints : $$$ x_1 \le u \le x_2 $$$ $$$ y_1 \le v \le y_2 $$$ star point $$$ ( x y ) $$$ require answer $$$ t $$$ test case independently first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases first line test case contain four integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ ( $$$ 0 \le a b c d \le 100000000 $$$ $$$ a+b+c+d \ge 1 $$$ ) second line test case contain six integers $$$ x $$$ $$$ y $$$ $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ -100000000 \le <unknown> x \le x_2 \le 100000000 $$$ $$$ -100000000 \le y_1 \le y \le y_2 \le 100000000 $$$ ) test case output ` ` yes '' a separate line exist a walk satisfy wish otherwise output ` ` '' a separate line print letter case ( upper lower ) first test case one valid exercise walk $$$ $$$ ( 0,0 ) \rightarrow ( -1,0 ) \rightarrow ( -2,0 ) \rightarrow ( -2,1 ) \rightarrow ( <unknown> ) \rightarrow ( -1,2 ) \rightarrow ( 0,2 ) \rightarrow ( 0,1 ) \rightarrow ( 0,0 ) \rightarrow ( -1,0 ) $$$ $$$","['greedy', 'implementation', 'math']",1100.0
1332/B,a positive integer call composite represent a product two positive integers greater $$$ 1 $$$ example follow number composite : $$$ 6 $$$ $$$ 4 $$$ $$$ 120 $$$ $$$ 27 $$$ follow number n't : $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 17 $$$ $$$ 97 $$$ alice give a sequence $$$ n $$$ composite number $$$ a_1 a_2 \ldots a_n $$$ want choose integer $$$ m \le 11 $$$ color element one $$$ m $$$ color $$$ 1 $$$ $$$ m $$$ : note equal elements color different color — choose one $$$ m $$$ color indices $$$ 1 $$$ $$$ n $$$ alice show already $$$ a_i \le 1000 $$$ always solve task choose $$$ m \le 11 $$$ help alice find require color note n't minimize maximize number color find solution $$$ m $$$ $$$ 1 $$$ $$$ 11 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case descriptions test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — amount number a sequence $$$ a $$$ second line test case contain $$$ n $$$ composite integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 4 \le a_i \le 1000 $$$ ) guarantee sum $$$ n $$$ test case n't exceed $$$ 10000 $$$ test case print $$$ 2 $$$ line first line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 11 $$$ ) — number use color consider color number $$$ 1 $$$ $$$ m $$$ second line contain color satisfy condition print $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \le c_i \le m $$$ ) $$$ c_i $$$ color $$$ i $$$ -th element multiple solutions print note n't minimize maximize number color find solution $$$ m $$$ $$$ 1 $$$ $$$ 11 $$$ remember color $$$ 1 $$$ $$$ m $$$ use least two elements color coprime ( i.e gcd greater $$$ 1 $$$ ) first test case $$$ \gcd ( <unknown> ) = 2 $$$ $$$ \gcd ( <unknown> ) =3 $$$ $$$ \gcd ( <unknown> ) = 5 $$$ therefore 's valid color elements color note color satisfy alice 's requirement test case second test case one element color color definitely satisfy alice 's requirement,"['greedy', 'math']",1400.0
1333/C,eugene like work array today need help solve one challenge task array $$$ c $$$ a subarray array $$$ b $$$ $$$ c $$$ obtain $$$ b $$$ deletion several ( possibly zero ) elements begin several ( possibly zero ) elements end let 's call a nonempty array good every nonempty subarray array sum elements subarray nonzero example array $$$ [ -1 2 -3 ] $$$ good array $$$ [ -1 ] $$$ $$$ [ -1 2 ] $$$ $$$ [ -1 2 -3 ] $$$ $$$ [ 2 ] $$$ $$$ [ 2 -3 ] $$$ $$$ [ -3 ] $$$ nonzero sum elements however array $$$ [ -1 2 -1 -3 ] $$$ n't good subarray $$$ [ -1 2 -1 ] $$$ sum elements equal $$$ 0 $$$ help eugene calculate number nonempty good subarrays a give array $$$ a $$$ first line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 2 \times 100000 $$$ ) — length array $$$ a $$$ second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) — elements $$$ a $$$ output a single integer — number good subarrays $$$ a $$$ first sample follow subarrays good : $$$ [ 1 ] $$$ $$$ [ 1 2 ] $$$ $$$ [ 2 ] $$$ $$$ [ 2 -3 ] $$$ $$$ [ -3 ] $$$ however subarray $$$ [ 1 2 -3 ] $$$ n't good subarray $$$ [ 1 2 -3 ] $$$ sum elements equal $$$ 0 $$$ second sample three subarrays size 1 good subarrays time subarray $$$ [ 41 -41 41 ] $$$ n't good subarray $$$ [ 41 -41 ] $$$ sum elements equal $$$ 0 $$$,"['data structures', 'implementation']",1700.0
1335/E1,difference easy hard versions constraints give a sequence $$$ a $$$ consist $$$ n $$$ positive integers let 's define a three block palindrome sequence consist two distinct elements ( let elements $$$ a $$$ $$$ b $$$ $$$ a $$$ equal $$$ b $$$ ) follow : $$$ [ \underbrace { a a \dots a } _ { x } \underbrace { b b \dots b } _ { y } \underbrace { a a \dots a } _ { x } ] $$$ $$$ x y $$$ integers greater equal $$$ 0 $$$ example sequence $$$ [ ] $$$ $$$ [ 2 ] $$$ $$$ [ 1 1 ] $$$ $$$ [ 1 2 1 ] $$$ $$$ [ 1 2 2 1 ] $$$ $$$ [ 1 1 2 1 1 ] $$$ three block palindromes $$$ [ 1 2 3 2 1 ] $$$ $$$ [ 1 2 1 2 1 ] $$$ $$$ [ 1 2 ] $$$ task choose maximum length subsequence $$$ a $$$ a three block palindrome answer $$$ t $$$ independent test case recall sequence $$$ t $$$ a a subsequence sequence $$$ s $$$ $$$ t $$$ derive $$$ s $$$ remove zero elements without change order remain elements example $$$ s= [ 1 2 1 3 1 2 1 ] $$$ possible subsequences : $$$ [ 1 1 1 1 ] $$$ $$$ [ 3 ] $$$ $$$ [ 1 2 1 3 1 2 1 ] $$$ $$$ [ 3 2 3 ] $$$ $$$ [ 1 1 1 1 2 ] $$$ first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 2000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 2000 $$$ ) — length $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 26 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ note maximum value $$$ a_i $$$ $$$ 26 $$$ guarantee sum $$$ n $$$ test case exceed $$$ 2000 $$$ ( $$$ \sum n \le 2000 $$$ ) test case print answer — maximum possible length subsequence $$$ a $$$ a three block palindrome,"['data structures', 'dp']",1700.0
1337/B,"kana ordinary high school girl a talent <unknown> discover , become idol different <unknown> also a <unknown> one day kana get interest a new adventure game call dragon quest game quest beat a dragon dragon a hit point $$$ x $$$ initially hit point go $$$ 0 $$$ $$$ 0 $$$ defeat order defeat dragon kana cast two follow type spell assume dragon 's current hit point $$$ h $$$ cast spell hit point become $$$ \left\lfloor \frac { h } { 2 } \right\rfloor + 10 $$$ $$$ \left\lfloor \frac { h } { 2 } \right\rfloor $$$ denote $$$ h $$$ divide two round spell decrease dragon 's hit point $$$ 10 $$$ assume dragon 's current hit point $$$ h $$$ cast spell hit point lower $$$ <unknown> $$$ due reason kana cast $$$ n $$$ void absorptions $$$ m $$$ lightning strike cast spell order n't cast spell kana n't good math go help find whether possible defeat dragon first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case next $$$ t $$$ line describe test case test case line contain three integers $$$ x $$$ $$$ n $$$ $$$ m $$$ ( $$$ 1\le x \le 100000 $$$ $$$ 0\le n <unknown> $$$ ) — dragon 's <unknown> hit point maximum number void absorptions lightning strike kana cast respectively possible defeat dragon print ` ` yes '' ( without quote ) otherwise print ` ` '' ( without quote ) print letter case ( upper lower ) one possible cast sequence first test case show :","['greedy', 'implementation', 'math']",900.0
1343/F,guess a permutation $$$ p $$$ consist $$$ n $$$ integers permutation length $$$ n $$$ array length $$$ n $$$ element $$$ 1 $$$ $$$ n $$$ appear exactly permutation a secret position $$$ r $$$ $$$ 2 $$$ $$$ n $$$ choose index $$$ l $$$ ( $$$ l < r $$$ ) give segment $$$ p_l p _ { l + 1 } \dots p_r $$$ sort order ( i.e rearrange elements segment a way elements segment sort ) thus give exactly $$$ n-1 $$$ segment initial permutation elements inside segment sort segment give random order example secret permutation $$$ p= [ 3 1 4 6 2 5 ] $$$ possible give set segment : task find suitable permutation ( i.e permutation correspond give input data ) guarantee input data correspond permutation ( i.e permutation exist ) answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200 $$$ ) — length permutation next $$$ n-1 $$$ line describe give segment $$$ i $$$ -th line contain description $$$ i $$$ -th segment line start integer $$$ k_i $$$ ( $$$ 2 \le k_i \le n $$$ ) — length $$$ i $$$ -th segment $$$ k_i $$$ integers follow integers a line distinct sort ascend order $$$ 1 $$$ $$$ n $$$ inclusive guarantee require $$$ p $$$ exist test case also guarantee sum $$$ n $$$ test case exceed $$$ 200 $$$ ( $$$ \sum n \le 200 $$$ ) test case print answer : $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i $$$ distinct ) — suitable permutation ( i.e permutation correspond test case input ),"['data structures', 'greedy', 'implementation']",2400.0
1344/C,"logical quantifiers useful tool express claim a set problem let 's focus set real number specifically set real number include zero negative two kinds quantifiers : universal ( $$$ \forall $$$ ) existential ( $$$ \exists $$$ ) read universal quantifier use make a claim a statement hold real number example : existential quantifier use make a claim exist real number statement hold example : moreover quantifiers nest example : note order variables quantifiers important mean <unknown> a statement $$$ n $$$ variables $$$ x_1 x_2 \ldots x_n $$$ give formula form $$$ $$$ f ( x_1 \dots x_n ) : = ( x _ { j_1 } < x _ { k_1 } ) \land ( x _ { j_2 } < x _ { k_2 } ) \land <unknown> ( x _ { j_m } < x _ { k_m } ) $$$ $$$ $$$ \land $$$ denote logical , $$$ f ( x_1 \ldots x_n ) $$$ true every inequality $$$ x _ { j_i } < x _ { k_i } $$$ hold otherwise least one inequality hold $$$ f ( x_1 \ldots x_n ) $$$ false task assign quantifiers $$$ q_1 \ldots q_n $$$ either universal ( $$$ \forall $$$ ) existential ( $$$ \exists $$$ ) statement $$$ $$$ q_1 x_1 q_2 x_2 \ldots q_n x_n f ( x_1 \ldots x_n ) $$$ $$$ true number universal quantifiers maximize determine statement false every possible assignment quantifiers note order variables appear statement fix example $$$ f ( x_1 x_2 ) : = ( x_1 < x_2 ) $$$ allow make $$$ x_2 $$$ appear first use statement $$$ \forall x_2 \exists x_1 x_1 < x_2 $$$ assign $$$ <unknown> $$$ $$$ <unknown> $$$ interpret $$$ \exists x_1 \forall x_2 x_1 < x_2 $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2\le n\le 2\cdot 100000 $$$ ; $$$ 1\le m\le 2\cdot 100000 $$$ ) — number variables number inequalities formula respectively next $$$ m $$$ line describe formula $$$ i $$$ -th line contain two integers $$$ j_i $$$ $$$ k_i $$$ ( $$$ 1\le j_i <unknown> n $$$ $$$ <unknown> k_i $$$ ) assignment quantifiers statement true output a single integer $$$ -1 $$$ otherwise first line output integer maximum possible number universal quantifiers next line output a string length $$$ n $$$ $$$ i $$$ -th character ` ` a '' $$$ q_i $$$ a universal quantifier ( $$$ \forall $$$ ) ` ` e '' $$$ q_i $$$ existential quantifier ( $$$ \exists $$$ ) letter upper - case multiple solutions number universal quantifiers maximum print first test statement $$$ \forall x_1 \exists x_2 x_1 < x_2 $$$ true answer ` ` <unknown> '' ` ` aa '' give false statements answer ` ` <unknown> '' give a true statement number universal quantifiers string less answer second test show assignment quantifiers statement true exist third test statement $$$ \forall x_1 \forall x_2 \exists x_3 ( x_1 < x_3 ) \land ( x_2 < x_3 ) $$$ true : set $$$ <unknown> { x_1 <unknown> } +1 $$$","['dp', 'math']",2600.0
1348/D,phoenix decide become a scientist ! currently investigate growth bacteria initially day $$$ 1 $$$ one bacterium mass $$$ 1 $$$ every day number bacteria split ( possibly zero ) a bacterium mass $$$ m $$$ split become two bacteria mass $$$ \frac { m } { 2 } $$$ example a bacterium mass $$$ 3 $$$ split two bacteria mass $$$ 1.5 $$$ also every night mass every bacteria increase one phoenix wonder possible total mass bacteria exactly $$$ n $$$ possible interest way obtain mass use minimum possible number nights help become best scientist ! input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 2 \le n \le 1000000000 $$$ ) — sum bacteria mass phoenix interest test case way bacteria exactly achieve total mass $$$ n $$$ print -1 . otherwise print two line first line contain integer $$$ d $$$ — minimum number nights need next line contain $$$ d $$$ integers $$$ i $$$ -th integer represent number bacteria split $$$ i $$$ -th day multiple solutions print first test case follow process result bacteria total mass $$$ 9 $$$ : $$$ $$$ second test case follow process result bacteria total mass $$$ 11 $$$ : $$$ $$$ third test case bacterium split day $$$ 1 $$$ grow mass $$$ 2 $$$ night $$$ 1 $$$,"['greedy', 'implementation', 'math']",1900.0
1349/B,"slime a sequence positive integers $$$ a_1 a_2 \ldots a_n $$$ one operation orac choose arbitrary subsegment $$$ [ l \ldots r ] $$$ sequence replace value $$$ a_l a _ { l + 1 } \ldots a_r $$$ value median $$$ \ { a_l a _ { l + 1 } \ldots a_r\ } $$$ problem integer multiset $$$ s $$$ median $$$ s $$$ equal $$$ \lfloor \frac { <unknown> } { 2 } \rfloor $$$ -th smallest number example median $$$ \ { <unknown> } $$$ $$$ 4 $$$ median $$$ \ { <unknown> } $$$ $$$ 5 $$$ slime want orac make $$$ a_1 = a_2 = \ldots = a_n = k $$$ use operations orac think impossible want waste time decide ask possible satisfy slime 's requirement may ask question several time first line input a single integer $$$ t $$$ : number query first line query contain two integers $$$ n\ ( 1\le n\le 100\,000 ) $$$ $$$ k\ ( 1\le k\le 1000000000 ) $$$ second line contain $$$ n $$$ positive integers $$$ a_1 a_2 \dots a_n\ ( 1\le a_i\le 1000000000 ) $$$ total sum $$$ n $$$ $$$ 100\,000 $$$ output contain $$$ t $$$ line $$$ i $$$ -th line equal ' yes ' possible make integers $$$ k $$$ number operations ' no ' otherwise print letter lowercase uppercase first query orac ca n't turn elements $$$ 3 $$$ second query $$$ <unknown> $$$ already satisfy third query orac select complete array turn elements $$$ 2 $$$ fourth query orac ca n't turn elements $$$ 3 $$$ fifth query orac select $$$ [ 1,6 ] $$$ first select $$$ [ <unknown> ] $$$","['greedy', 'math']",2000.0
1349/D,"slime $$$ n $$$ friends a party slime design a game friends play begin game $$$ i $$$ -th player $$$ a_i $$$ biscuits second slime choose a biscuit randomly uniformly among $$$ a_1 + a_2 + \ldots + a_n $$$ biscuits owner biscuit give a random uniform player among $$$ n-1 $$$ players except game stop one person biscuits host party slime want know expect value time game last hold next activity time convenience answer represent a rational number $$$ \frac { p } { q } $$$ coprime $$$ p $$$ $$$ q $$$ need find value $$$ ( p \cdot q^ { -1 } ) \mod 998\,244\,353 $$$ prove $$$ <unknown> 998\,244\,353 \neq 0 $$$ first line contain one integer $$$ n\ ( 2\le n\le 100\,000 ) $$$ : number people play game second line contain $$$ n $$$ non - negative integers $$$ a_1 a_2 \dots a_n\ ( 1\le <unknown> 300\,000 ) $$$ $$$ a_i $$$ represent number biscuits $$$ i $$$ -th person begin print one integer : expect value time game last modulo $$$ 998\,244\,353 $$$ first example first second probability player $$$ 1 $$$ give player $$$ 2 $$$ a biscuit $$$ \frac { 1 } { 2 } $$$ probability player $$$ 2 $$$ give player $$$ 1 $$$ a biscuit $$$ \frac { 1 } { 2 } $$$ anyway game stop exactly $$$ 1 $$$ second one player occupy biscuits $$$ 1 $$$ second answer $$$ 1 $$$",['math'],3200.0
1349/F1,"note differences easy hard versions constraints $$$ n $$$ time limit make hack versions solve slime interest sequence define good positive integer sequence $$$ p $$$ length $$$ n $$$ follow : give integer $$$ n $$$ set good sequence length $$$ n $$$ $$$ s_n $$$ fix integer $$$ k $$$ sequence $$$ p $$$ let $$$ f_p ( k ) $$$ number time $$$ k $$$ appear $$$ p $$$ $$$ k $$$ $$$ 1 $$$ $$$ n $$$ slime want know follow value : $$$ $$$ \left ( \sum _ { p\in s_n } f_p ( k ) \right ) \ \textrm { mod } \ 998\,244\,353 $$$ $$$ first line contain one integer $$$ n\ ( 1\le n\le 5000 ) $$$ print $$$ n $$$ integers $$$ i $$$ -th equal $$$ \left ( \sum _ { p\in s_n } f_p ( i ) \right ) \ \textrm { mod } \ 998\,244\,353 $$$ first example $$$ s=\ { [ 1,1 ] [ 1,2 ] \ } $$$ second example $$$ s=\ { [ 1,1,1 ] [ 1,1,2 ] [ 1,2,1 ] [ 1,2,2 ] [ 2,1,2 ] [ 1,2,3 ] \ } $$$ third example $$$ s=\ { [ 1 ] \ } $$$","['dp', 'math']",3100.0
1352/E,pay attention non - standard memory limit problem order cut efficient solutions inefficient ones problem time limit rather strict prefer use compile <unknown> type languages ( e.g c++ ) use python submit solutions pypy try write efficient solution array $$$ a= [ a_1 a_2 \ldots a_n ] $$$ ( $$$ 1 \le a_i \le n $$$ ) give element $$$ a_i $$$ call special exist a pair indices $$$ l $$$ $$$ r $$$ ( $$$ 1 \le l < r \le n $$$ ) $$$ a_i = a_l + a _ { l+1 } + \ldots + a_r $$$ word element call special represent sum two consecutive elements array ( matter special ) print number special elements give array $$$ a $$$ example $$$ n=9 $$$ $$$ a= [ <unknown> ] $$$ answer $$$ 5 $$$ : please note elements array $$$ a $$$ may equal — several elements equal special count answer first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case input $$$ t $$$ test case follow test case give two line first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 8000 $$$ ) — length array $$$ a $$$ second line contain integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) guarantee sum value $$$ n $$$ test case input exceed $$$ 8000 $$$ print $$$ t $$$ number — number special elements give array,['implementation'],1500.0
1353/E,give a garland consist $$$ n $$$ lamps state lamps represent string $$$ s $$$ length $$$ n $$$ $$$ i $$$ -th character string $$$ s_i $$$ equal ' 0 ' $$$ i $$$ -th lamp turn ' 1 ' $$$ i $$$ -th lamp turn also give a positive integer $$$ k $$$ one move choose one lamp change state ( i.e turn turn vice versa ) garland call $$$ k $$$ -periodic distance pair adjacent turn lamps exactly $$$ k $$$ consider case $$$ k=3 $$$ garland ` ` <unknown> '' ` ` <unknown> '' ` ` 00010 '' ` ` 0 '' good garland ` ` <unknown> '' ` ` 1000001 '' ` ` <unknown> '' note garland cyclic i.e first turn lamp go last turn lamp vice versa task find minimum number move need make obtain $$$ k $$$ -periodic garland give one answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le <unknown> 000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 1000000 ; 1 \le k \le n $$$ ) — length $$$ s $$$ require period second line test case contain string $$$ s $$$ consist $$$ n $$$ character ' 0 ' ' 1 ' guarantee sum $$$ n $$$ test case exceed $$$ 1000000 $$$ ( $$$ \sum n \le 1000000 $$$ ) test case print answer — minimum number move need make obtain $$$ k $$$ -periodic garland give one,"['dp', 'greedy']",1900.0
1354/F,"polycarp play a computer game game players summon armies magical minions fight polycarp summon $$$ n $$$ different minions initial power level $$$ i $$$ -th minion $$$ a_i $$$ summon previously summon minions ' power level increase $$$ b_i $$$ minions summon order unfortunately polycarp $$$ k $$$ minions control get rid <unknown> minions summon may destroy minion summon ( destroy ) polycarp 's goal summon strongest possible army formally want maximize sum power level minions control ( summon destroy ) help polycarp make a plan action summon strongest possible army ! first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 75 $$$ ) — number test case test case begin a line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 75 $$$ ) — number minions <unknown> summon maximum number minions control polycarp respectively $$$ n $$$ line follow $$$ i $$$ -th line contain $$$ 2 $$$ integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i \le 100000 $$$ $$$ 0 \le b_i \le 100000 $$$ ) — parameters $$$ i $$$ -th minion test case print optimal sequence action follow : firstly print $$$ m $$$ — number action polycarp perform ( $$$ 0 \le m \le 2n $$$ ) print $$$ m $$$ integers $$$ <unknown> $$$ $$$ <unknown> $$$ ... $$$ <unknown> $$$ $$$ o_i $$$ denote $$$ i $$$ -th action follow : $$$ i $$$ -th action summon minion $$$ x $$$ $$$ o_i = x $$$ $$$ i $$$ -th action destroy minion $$$ x $$$ $$$ o_i = -x $$$ minion summon destroy summon ( obviously destroy ) number minions polycarp 's army greater $$$ k $$$ every action multiple optimal sequence print consider example test first test case polycarp summon minion $$$ 2 $$$ power level $$$ 7 $$$ summon minion $$$ 1 $$$ increase power level previous minion $$$ 3 $$$ destroy minion $$$ 1 $$$ finally summon minion $$$ 5 $$$ , polycarp two minions power level $$$ 10 $$$ second test case polycarp control one minion choose strongest summon third test case polycarp able summon control five minions","['dp', 'greedy']",2500.0
1355/E,restore wall wall consist $$$ n $$$ pillars bricks height $$$ i $$$ -th pillar initially equal $$$ h _ { i } $$$ height measure number bricks restoration $$$ n $$$ pillars equal heights allow follow operations : create additional pillars ignore pre - <unknown> pillars even height become $$$ 0 $$$ minimal total cost restoration word minimal total cost make pillars equal height ? first line input contain four integers $$$ n $$$ $$$ a $$$ $$$ r $$$ $$$ m $$$ ( $$$ 1 \le n \le 10^ { 5 } $$$ $$$ 0 \le a r m \le 10^ { 4 } $$$ ) — number pillars cost operations second line contain $$$ n $$$ integers $$$ h _ { i } $$$ ( $$$ 0 \le h _ { i } \le 10^ { 9 } $$$ ) — initial heights pillars print one integer — minimal cost restoration,"['greedy', 'math']",2100.0
1358/A,due coronavirus <unknown> city authorities obligate citizens keep a social distance mayor city semyon want light <unknown> park people could see even night keep social distance park a rectangular table $$$ n $$$ row $$$ m $$$ columns cells table square boundaries cells streets external border also streets every street length $$$ 1 $$$ example park $$$ n = m=2 $$$ $$$ 12 $$$ streets assign develop a plan light park put lanterns middle streets lamp light two square near ( one square stand border park ) semyon want spend least possible amount money light also want people throughout park keep a social distance ask find minimum number lanterns require light square first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case input $$$ t $$$ test case follow test case a line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 10000 $$$ ) — park size print $$$ t $$$ answer test case answer must a single integer — minimum number lanterns require light square possible optimal arrangement lanterns $$$ 2 $$$ -nd test case input data example : possible optimal arrangement lanterns $$$ 3 $$$ -rd test case input data example :,"['greedy', 'math']",800.0
1359/D,alice bob play yet another card game time rule follow $$$ n $$$ card lie a row front $$$ i $$$ -th card value $$$ a_i $$$ first alice choose a non - empty consecutive segment card $$$ [ l ; r ] $$$ ( $$$ l \le r $$$ ) bob remove a single card $$$ j $$$ segment $$$ ( l \le j \le r ) $$$ score game total value remain card segment $$$ ( a_l + a _ { l + 1 } + \dots + a _ { j - 1 } + a _ { j + 1 } + \dots + a _ { r - 1 } + a_r ) $$$ particular alice choose a segment one element score bob remove card $$$ 0 $$$ alice want make score big possible bob take a card score small possible segment alice choose score maximum possible ? output maximum score first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number card second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ <unknown> \le a_i \le 30 $$$ ) — value card print a single integer — final score game first example alice choose a segment $$$ [ 1 ; 5 ] $$$ — entire row card bob remove card $$$ 3 $$$ value $$$ 10 $$$ segment thus final score $$$ 5 + ( -2 ) + ( -1 ) + 4 = 6 $$$ second example alice choose a segment $$$ [ 1 ; 4 ] $$$ bob remove either card $$$ 1 $$$ $$$ 3 $$$ value $$$ 5 $$$ make answer $$$ 5 + 2 + 3 = 10 $$$ third example alice choose segment length $$$ 1 $$$ : $$$ [ 1 ; 1 ] $$$ $$$ [ 2 ; 2 ] $$$ $$$ [ 3 ; 3 ] $$$ bob remove card score $$$ 0 $$$ alice choose segment answer less $$$ 0 $$$,"['data structures', 'dp', 'implementation']",2000.0
1362/A,"johnny recently find ancient break computer machine one register allow one put one variable one operation shift bits leave right three position right shift forbid cut ones , fact one operation multiply divide number $$$ 2 $$$ $$$ 4 $$$ $$$ 8 $$$ division allow number divisible choose divisor formally register contain a positive integer $$$ x $$$ one operation replace one follow : example $$$ x = 6 $$$ one operation replace $$$ 12 $$$ $$$ 24 $$$ $$$ 48 $$$ $$$ 3 $$$ value $$$ 6 $$$ n't divisible $$$ 4 $$$ $$$ 8 $$$ 're four variants replacement johnny wonder many operations need perform put $$$ a $$$ register want get $$$ b $$$ end input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case follow $$$ t $$$ line contain a description test case first line test case contain integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \leq a b \leq 10^ { 18 } $$$ ) — initial target value variable respectively output $$$ t $$$ line line contain one integer denote minimum number operations johnny need perform johnny get $$$ b $$$ end write $$$ -1 $$$ first test case johnny reach $$$ 5 $$$ $$$ 10 $$$ use shift right one ( i.e divide $$$ 2 $$$ ) second test case johnny reach $$$ 44 $$$ $$$ 11 $$$ use shift leave two ( i.e multiply $$$ 4 $$$ ) third test case impossible johnny reach $$$ 21 $$$ $$$ 17 $$$ fourth test case initial target value equal johnny $$$ 0 $$$ operations fifth test case johnny reach $$$ 3 $$$ $$$ 96 $$$ use two shift right : one $$$ 2 $$$ another $$$ 3 $$$ ( i.e divide $$$ 4 $$$ $$$ 8 $$$ )",['implementation'],1000.0
1363/D,"interactive problem ayush devise a new scheme set password lock lock $$$ k $$$ slot slot hold integers $$$ 1 $$$ $$$ n $$$ password $$$ p $$$ a sequence $$$ k $$$ integers range $$$ [ 1 n ] $$$ $$$ i $$$ -th element go $$$ i $$$ -th slot lock set password lock ayush come array $$$ a $$$ $$$ n $$$ integers range $$$ [ 1 n ] $$$ ( necessarily distinct ) pick $$$ k $$$ non - empty mutually disjoint subsets indices $$$ s_1 s_2 ... s_k $$$ $$$ ( s_i \underset { i \neq j } \cap s_j = \emptyset ) $$$ set password $$$ p_i = \max\limits _ { j \notin s_i } a [ j ] $$$ word $$$ i $$$ -th integer password equal maximum elements $$$ a $$$ whose indices belong $$$ s_i $$$ give subsets indices choose ayush need guess password make a query choose a non - empty subset indices array ask maximum elements array index subset ask 12 query first line input contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10 ) $$$ — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ $$$ ( 2 \leq n \leq 1000 1 \leq k \leq n ) $$$ — size array number subsets $$$ k $$$ line follow $$$ i $$$ -th line contain integer $$$ c $$$ $$$ ( 1 \leq c \lt n ) $$$ — size subset $$$ s_i $$$ follow $$$ c $$$ distinct integers range $$$ [ 1 n ] $$$ — indices subset $$$ s_i $$$ guarantee intersection two subsets empty ask a query print a single line : query receive integer $$$ x $$$ — maximum value array among indices query subset indices query invalid exceed number query ( example one indices greater $$$ n $$$ ) get $$$ x = -1 $$$ case terminate program immediately guess password print a single line ` ` ! ` ` ( without quote ) follow $$$ k $$$ space - separated integers — password sequence guess password count towards number query ask , read a string guess password correctly receive string ` ` correct '' case continue solve remain test case guess password incorrect receive string ` ` incorrect '' case terminate program immediately interactor adaptive array $$$ a $$$ change query print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack solution use follow test format : first line input contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10 ) $$$ — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ $$$ ( 2 \leq n \leq 1000 1 \leq k \leq n ) $$$ — size array number subsets next line consist $$$ n $$$ space separate integers range $$$ [ 1 n ] $$$ — array $$$ a $$$ $$$ k $$$ line follow $$$ i $$$ -th line contain integer $$$ c $$$ $$$ ( 1 \leq c \lt n ) $$$ — size subset $$$ s_i $$$ follow $$$ c $$$ distinct integers range $$$ [ 1 n ] $$$ — indices subset $$$ s_i $$$ intersection two subsets empty array $$$ a $$$ example $$$ [ 1 2 3 4 ] $$$ length password $$$ 2 $$$ first element password maximum $$$ a [ 2 ] $$$ $$$ a [ 4 ] $$$ ( since first subset contain indices $$$ 1 $$$ $$$ 3 $$$ take maximum remain indices ) second element password maximum $$$ a [ 1 ] $$$ $$$ a [ 3 ] $$$ ( since second subset contain indices $$$ 2 $$$ $$$ 4 $$$ ) forget read string ` ` correct '' / ` ` incorrect '' guess password","['implementation', 'math']",2100.0
1363/F,"give two string $$$ s $$$ $$$ t $$$ length $$$ n $$$ consist lowercase latin alphabets want make $$$ s $$$ equal $$$ t $$$ perform follow operation $$$ s $$$ number time achieve — example rotate substring $$$ [ 2,4 ] $$$ string ` ` abcde '' become ` ` <unknown> '' a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end find minimum number operations require convert $$$ s $$$ $$$ t $$$ determine 's impossible first line input contain a single integer $$$ t $$$ $$$ ( 1\leq t \leq 2000 ) $$$ — number test case description test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 1\leq n \leq 2000 ) $$$ — length string second third line contain string $$$ s $$$ $$$ t $$$ respectively sum $$$ n $$$ test case exceed $$$ 2000 $$$ test case output minimum number operations convert $$$ s $$$ $$$ t $$$ possible convert $$$ s $$$ $$$ t $$$ output $$$ -1 $$$ instead $$$ 1 $$$ -st test case since $$$ s $$$ $$$ t $$$ equal n't need apply operation $$$ 2 $$$ -nd test case need apply one operation entire string ab convert ba $$$ 3 $$$ -rd test case need apply one operation entire string abc convert cab $$$ 4 $$$ -th test case need apply operation twice : first entire string abc convert cab substring length $$$ 2 $$$ begin second character convert cba $$$ 5 $$$ -th test case need apply one operation entire string abab convert baba $$$ 6 $$$ -th test case possible convert string $$$ s $$$ $$$ t $$$",['dp'],2600.0
1364/B,"give a permutation $$$ p $$$ length $$$ n $$$ find subsequence $$$ s_1 $$$ $$$ s_2 $$$ $$$ \ldots $$$ $$$ s_k $$$ length least $$$ 2 $$$ : multiple subsequences satisfy condition allow find a sequence $$$ a $$$ a subsequence array $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ delete ( possibly zero ) elements a permutation length $$$ n $$$ array length $$$ n $$$ every element $$$ 1 $$$ $$$ n $$$ occur exactly first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — length permutation $$$ p $$$ second line test case contain $$$ n $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ $$$ \ldots $$$ $$$ p _ { n } $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i $$$ distinct ) — elements permutation $$$ p $$$ sum $$$ n $$$ across test case n't exceed $$$ 100000 $$$ test case first line contain length find subsequence $$$ k $$$ second line contain $$$ s_1 $$$ $$$ s_2 $$$ $$$ \ldots $$$ $$$ s_k $$$ — elements multiple subsequences satisfy condition allow find first test case $$$ 4 $$$ subsequences length least $$$ 2 $$$ : answer either $$$ [ 3,1 ] $$$ $$$ [ 3,2,1 ] $$$ since want subsequence short possible answer $$$ [ 3,1 ] $$$",['greedy'],1300.0
1364/D,"give a connect undirected graph $$$ n $$$ vertices integer $$$ k $$$ either : independent set a set vertices two connect edge a simple cycle a cycle n't contain vertex twice i a proof input always solve least one problems 's leave exercise reader first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 3 \le k \le n \le 100000 $$$ $$$ n-1 \le m \le 200000 $$$ ) — number vertices edge graph parameter $$$ k $$$ statement next $$$ m $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) mean 's edge vertices $$$ u $$$ $$$ v $$$ 's guarantee graph connect n't contain self - loops multiple edge choose solve first problem first line print $$$ 1 $$$ follow a line contain $$$ \lceil\frac { k } { 2 } \rceil $$$ distinct integers exceed $$$ n $$$ vertices desire independent set , however choose solve second problem first line print $$$ 2 $$$ follow a line contain one integer $$$ c $$$ represent length find cycle follow a line contain $$$ c $$$ distinct integers exceed $$$ n $$$ vertices desire cycle order appear cycle first sample : notice print independent set $$$ \ { <unknown> } $$$ also ok print cycle $$$ 1 - 2 - 3 - 4 $$$ n't length must $$$ 3 $$$ second sample : notice print independent set $$$ \ { 1,3\ } $$$ print cycle $$$ 2 - 1 - 4 $$$ also ok . third sample : fourth sample :","['greedy', 'implementation']",2100.0
1365/B,ashish $$$ n $$$ elements arrange a line elements represent two integers $$$ a_i $$$ — value element $$$ b_i $$$ — type element ( two possible type : $$$ 0 $$$ $$$ 1 $$$ ) want sort elements non - decreasing value $$$ a_i $$$ perform follow operation number time : tell sort elements non - decreasing value $$$ a_i $$$ perform number operations first line contain one integer $$$ t $$$ $$$ ( 1 \le t \le 100 ) $$$ — number test case description test case follow first line test case contain one integer $$$ n $$$ $$$ ( 1 \le n \le 500 ) $$$ — size array second line contain $$$ n $$$ integers $$$ a_i $$$ $$$ ( 1 \le a_i \le 100000 ) $$$ — value $$$ i $$$ -th element third line containts $$$ n $$$ integers $$$ b_i $$$ $$$ ( b_i \in \ { 0 1\ } ) $$$ — type $$$ i $$$ -th element test case print ` ` yes '' ` ` '' ( without quote ) depend whether possible sort elements non - decreasing order value may print letter case ( upper lower ) first case : elements already sort order second case : ashish may first swap elements position $$$ 1 $$$ $$$ 2 $$$ swap elements position $$$ 2 $$$ $$$ 3 $$$ third case : elements already sort order fourth case : swap operations may perform pair elements $$$ i $$$ $$$ j $$$ $$$ b_i \ne b_j $$$ elements sort fifth case : ashish may swap elements position $$$ 3 $$$ $$$ 4 $$$ elements position $$$ 1 $$$ $$$ 2 $$$,['implementation'],1300.0
1366/A,polycarp play a well - known computer game ( wo n't mention name ) game craft tool two type — shovel swords craft a shovel polycarp spend two stick one diamond ; craft a sword polycarp spend two diamonds one stick tool sell exactly one emerald many emeralds polycarp earn $$$ a $$$ stick $$$ b $$$ diamonds ? first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case line test case contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 0 \le a b \le 1000000000 $$$ ) — number stick number diamonds respectively test case print one integer — maximum number emeralds polycarp earn first test case polycarp earn two emeralds follow : craft one sword one shovel second test case polycarp diamonds craft anything,"['greedy', 'math']",1100.0
1366/F,give a simple weight connect undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge a path graph length $$$ k $$$ a sequence $$$ k+1 $$$ vertices $$$ v_1 v_2 \dots v _ { k+1 } $$$ $$$ i $$$ $$$ ( 1 \le i \le k ) $$$ edge $$$ ( v_i v _ { i+1 } ) $$$ present graph a path vertex $$$ v $$$ also vertex $$$ v_1 = v $$$ note edge vertices allow include path multiple time weight path total weight edge $$$ i $$$ $$$ 1 $$$ $$$ q $$$ consider a path vertex $$$ 1 $$$ length $$$ i $$$ maximum weight sum weight $$$ q $$$ paths ? answer quite large print modulo $$$ 1000000000 + 7 $$$ first line contain a three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 2 \le n \le 2000 $$$ ; $$$ n - 1 \le m \le 2000 $$$ ; $$$ m \le q \le 1000000000 $$$ ) — number vertices graph number edge graph number lengths include answer next $$$ m $$$ line contain a description edge : three integers $$$ v $$$ $$$ u $$$ $$$ w $$$ ( $$$ 1 \le v u \le n $$$ ; $$$ 1 \le w \le 1000000 $$$ ) — two vertices $$$ v $$$ $$$ u $$$ connect undirected edge weight $$$ w $$$ graph contain loop multiple edge guarantee give edge form a connect graph print a single integer — sum weight paths vertex $$$ 1 $$$ maximum weight lengths $$$ 1 2 \dots q $$$ modulo $$$ 1000000000 + 7 $$$ graph first example : maximum weight paths : answer sum $$$ 25 $$$ term : $$$ 3 + 11 + 24 + <unknown> $$$ second example maximum weight paths weight $$$ 4 $$$ $$$ 8 $$$ $$$ 12 $$$ $$$ 16 $$$ $$$ 20 $$$,['dp'],2700.0
1368/D,"<unknown> learn binary number representation come task present give a collection $$$ n $$$ non - negative integers $$$ a_1 \ldots a_n $$$ allow perform follow operation : choose two distinct indices $$$ 1 \leq i j \leq n $$$ operation $$$ a_i = x $$$ $$$ a_j = y $$$ operation $$$ a_i = x~\mathsf { } ~y $$$ $$$ a_j = x~\mathsf { } ~y $$$ $$$ \mathsf { } $$$ $$$ \mathsf { } $$$ bitwise respectively ( refer note section formal description ) operation may perform number time ( possibly zero ) operations do compute $$$ \sum _ { i=1 } ^n a_i^2 $$$ — sum square $$$ a_i $$$ largest sum square achieve ? first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 \ldots a_n $$$ ( $$$ 0 \leq a_i < 2^ { 20 } $$$ ) print a single integer — largest possible sum square achieve several ( possibly zero ) operations first sample operation make thus answer $$$ 123 ^ 2 $$$ second sample obtain collection $$$ 1 1 7 $$$ $$$ 1 ^ 2 + 1 ^ 2 + 7 ^ 2 = 51 $$$ $$$ x $$$ $$$ y $$$ represent binary equal number bits ( possibly lead zero ) bite $$$ x~\mathsf { } ~y $$$ set $$$ 1 $$$ correspond bits $$$ x $$$ $$$ y $$$ set $$$ 1 $$$ similarly bite $$$ x~\mathsf { } ~y $$$ set $$$ 1 $$$ least one correspond bits $$$ x $$$ $$$ y $$$ set $$$ 1 $$$ example $$$ x = 3 $$$ $$$ y = 5 $$$ represent $$$ 011_2 $$$ $$$ 101_2 $$$ ( highest bite first ) , $$$ x~\mathsf { } ~y = 001_2 = 1 $$$ $$$ x~\mathsf { } ~y = <unknown> = 7 $$$","['greedy', 'math']",1700.0
1368/F,"interactive problem john imaginary friend play a game $$$ n $$$ lamps arrange a circle lamps number $$$ 1 $$$ $$$ n $$$ clockwise order , lamps $$$ i $$$ $$$ i + 1 $$$ adjacent $$$ i = 1 \ldots n - 1 $$$ also lamps $$$ n $$$ $$$ 1 $$$ adjacent initially lamps turn john friend take turn john move first turn john choose terminate game make a move make a move john choose positive number $$$ k $$$ turn $$$ k $$$ lamps choose response move john 's friend choose $$$ k $$$ consecutive lamps turn ( lamps range move stay ) note value $$$ k $$$ john 's number last move example $$$ n = 5 $$$ john turn three lamps john 's friend may choose turn lamps $$$ 1 2 3 $$$ $$$ 2 3 4 $$$ $$$ 3 4 5 $$$ $$$ 4 5 1 $$$ $$$ 5 1 2 $$$ , john may choose terminate move , however john make $$$ 10000 $$$ move john want maximize number lamps turn end game friend want minimize number task provide a strategy john achieve optimal result program play interactively john jury 's interactor program play john 's friend suppose $$$ n $$$ lamps game let $$$ r ( n ) $$$ number turn lamps end game players act optimally program terminate game least $$$ r ( n ) $$$ turn lamps within $$$ 10000 $$$ move refer interaction section interaction detail technical reason hack problem disable initially program feed a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000 $$$ ) — number lamps game interactor wait action make a move print a line start integer $$$ k $$$ ( $$$ 1 \leq k \leq n $$$ ) follow $$$ k $$$ distinct integers $$$ l_1 \ldots l_k $$$ ( $$$ 1 \leq l_i \leq n $$$ ) — indices lamps want turn indices may print order allow try turn a lamp already ( although effect ) move invalid reason make $$$ 10000 $$$ move interactor reply a line contain a single integer $$$ -1 $$$ otherwise reply a line contain a single integer $$$ x $$$ ( $$$ 1 \leq x \leq n ) $$$ mean response turn $$$ k $$$ consecutive lamps start $$$ x $$$ clockwise order terminate game instead make a move print a line contain a single integer $$$ 0 $$$ test pass point least $$$ r ( n ) $$$ lamps turn ( note neither $$$ r ( n ) $$$ verdict receive communicate program way ) action count towards number move ( legal terminate game exactly $$$ 10000 $$$ move ) receive correct verdict program terminate immediately print $$$ 0 $$$ receive $$$ -1 $$$ a response n't forget flush output every action $$$ n = 3 $$$ john 's move reverse thus $$$ r ( 3 ) = 0 $$$ terminate game immediately correct $$$ r ( 4 ) = 1 $$$ one strategy achieve result show second sample case blank line sample interactions clarity print","['implementation', 'math']",2600.0
1369/B,lee clean house party find a messy string carpet 'd like make clean accurately a stylish way ... string $$$ s $$$ find a binary string length $$$ n $$$ ( i. e. string consist 0 - s 1 - s ) one move choose two consecutive character $$$ s_i $$$ $$$ s _ { i+1 } $$$ $$$ s_i $$$ 1 $$$ s _ { i + 1 } $$$ 0 erase exactly one ( choose one erase ca n't erase character simultaneously ) string shrink erase lee make arbitrary number move ( possibly zero ) 'd like make string $$$ s $$$ clean possible think two different string $$$ x $$$ $$$ y $$$ shorter string cleaner length lexicographically smaller string cleaner answer $$$ t $$$ test case : $$$ i $$$ -th test case print cleanest possible string lee get number move small reminder : two string $$$ x $$$ $$$ y $$$ length $$$ x $$$ lexicographically smaller $$$ y $$$ a position $$$ i $$$ $$$ x_1 = y_1 $$$ $$$ x_2 = y_2 $$$ ... $$$ x _ { i - 1 } = y _ { i - 1 } $$$ $$$ x_i < y_i $$$ first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case next $$$ 2 t $$$ line contain test case — one per two line first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length string $$$ s $$$ second line contain binary string $$$ s $$$ string $$$ s $$$ a string length $$$ n $$$ consist zero ones 's guarantee sum $$$ n $$$ test case n't exceed $$$ 100000 $$$ print $$$ t $$$ answer — one per test case answer $$$ i $$$ -th test case cleanest string lee get number move ( possibly zero ) first test case lee ca n't perform move second test case lee erase $$$ s_2 $$$ third test case lee make move example follow order : <unknown> $$$ \rightarrow $$$ <unknown> $$$ \rightarrow $$$ <unknown> $$$ \rightarrow $$$ 10101 $$$ \rightarrow $$$ 1101 $$$ \rightarrow $$$ 101 $$$ \rightarrow $$$ 01,"['greedy', 'implementation']",1200.0
1370/A,let 's consider integers range $$$ 1 $$$ $$$ n $$$ ( inclusive ) among pair distinct integers range find maximum possible greatest common divisor integers pair formally find maximum value $$$ \mathrm { gcd } ( a b ) $$$ $$$ 1 \leq a < b \leq n $$$ greatest common divisor $$$ \mathrm { gcd } ( a b ) $$$ two positive integers $$$ a $$$ $$$ b $$$ biggest integer a divisor $$$ a $$$ $$$ b $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case description test case follow line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 1000000 $$$ ) test case output maximum value $$$ \mathrm { gcd } ( a b ) $$$ among $$$ 1 \leq a < b \leq n $$$ first test case $$$ \mathrm { gcd } ( 1 2 ) = \mathrm { gcd } ( 2 3 ) = \mathrm { gcd } ( 1 3 ) = 1 $$$ second test case $$$ 2 $$$ maximum possible value correspond $$$ \mathrm { gcd } ( 2 4 ) $$$,"['greedy', 'implementation', 'math']",800.0
1370/E,naman two binary string $$$ s $$$ $$$ t $$$ length $$$ n $$$ ( a binary string a string consist character ` ` 0 '' ` ` 1 '' ) want convert $$$ s $$$ $$$ t $$$ use follow operation time possible one operation choose subsequence $$$ s $$$ rotate clockwise example $$$ s = 1\textbf { 1 } 101\textbf { 00 } $$$ choose a subsequence correspond indices ( $$$ 1 $$$ -based ) $$$ \ { 2 6 7 \ } $$$ rotate clockwise result string would $$$ s = 1\textbf { 0 } 101\textbf { 10 } $$$ a string $$$ a $$$ say a subsequence string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ delete character without change order remain character perform a clockwise rotation a sequence $$$ c $$$ size $$$ k $$$ perform operation set $$$ c_1 : = c_k c_2 : = c_1 c_3 : = c_2 \ldots c_k : = c _ { k-1 } $$$ simultaneously determine minimum number operations naman perform convert $$$ s $$$ $$$ t $$$ say impossible first line contain a single integer $$$ n $$$ $$$ ( 1 \le n \le 1000000 ) $$$ — length string second line contain binary string $$$ s $$$ length $$$ n $$$ third line contain binary string $$$ t $$$ length $$$ n $$$ impossible convert $$$ s $$$ $$$ t $$$ number operations print $$$ -1 $$$ otherwise print minimum number operations require first test naman choose subsequence correspond indices $$$ \ { 2 6\ } $$$ rotate convert $$$ s $$$ $$$ t $$$ second test rotate subsequence correspond indices $$$ 5 $$$ time prove minimum require number operations last test impossible convert $$$ s $$$ $$$ t $$$,"['data structures', 'greedy']",2100.0
1371/D,"a mad scientist dr . <unknown> make a competitive program task try solve ! give integers $$$ n k $$$ construct a grid $$$ a $$$ size $$$ n \times n $$$ consist integers $$$ 0 $$$ $$$ 1 $$$ important condition satisfy : sum elements grid exactly $$$ k $$$ word number $$$ 1 $$$ grid equal $$$ k $$$ let 's define : find grid $$$ a $$$ satisfy follow condition among grids find value $$$ f ( a ) $$$ minimum possible among table find input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case next $$$ t $$$ line contain descriptions test case test case line contain two integers $$$ n $$$ $$$ k $$$ $$$ ( 1 \le n \le 300 0 \le k \le n^2 ) $$$ guarantee sum $$$ n^2 $$$ test case exceed $$$ 100000 $$$ test case firstly print minimum possible value $$$ f ( a ) $$$ among table condition satisfy , print $$$ n $$$ line contain $$$ n $$$ character $$$ j $$$ -th character $$$ i $$$ -th line equal $$$ a _ { i j } $$$ multiple answer print first test case sum elements grid equal $$$ 2 $$$ condition satisfy $$$ r_1 = 1 r_2 = 1 $$$ $$$ c_1 = 1 c_2 = 1 $$$ , $$$ f ( a ) = ( 1 - 1 ) ^2 + ( 1 - 1 ) ^2 = 0 $$$ minimum possible value $$$ f ( a ) $$$ second test case sum elements grid equal $$$ 8 $$$ condition satisfy $$$ r_1 = 3 r_2 = 3 r_3 = 2 $$$ $$$ c_1 = 3 c_2 = 2 c_3 = 3 $$$ , $$$ f ( a ) = ( 3 - 2 ) ^2 + ( 3 - 2 ) ^2 = 2 $$$ prove minimum possible value $$$ f ( a ) $$$","['greedy', 'implementation']",1600.0
1372/D,danny local math <unknown> fascinate circle omkar 's recent creation help solve circle problem ! give $$$ n $$$ nonnegative integers $$$ a_1 a_2 \dots a_n $$$ arrange a circle $$$ n $$$ must odd ( ie $$$ n-1 $$$ divisible $$$ 2 $$$ ) formally $$$ i $$$ $$$ 2 \leq i \leq n $$$ elements $$$ a _ { i - 1 } $$$ $$$ a_i $$$ consider adjacent $$$ a_n $$$ $$$ a_1 $$$ also consider adjacent one operation pick a number circle replace sum two elements adjacent delete two adjacent elements circle repeat one number remain circle call circular value help danny find maximum possible circular value sequence operations first line contain one odd integer $$$ n $$$ ( $$$ 1 \leq n < 200000 $$$ $$$ n $$$ odd ) — initial size circle second line contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } \dots a _ { n } $$$ ( $$$ 0 \leq a _ { i } \leq 1000000000 $$$ ) — initial number circle output maximum possible circular value apply sequence operations give circle first test case 's a circular value $$$ 17 $$$ obtain : pick number index $$$ 3 $$$ sum adjacent elements equal $$$ 17 $$$ delete $$$ 7 $$$ $$$ 10 $$$ circle replace $$$ 2 $$$ $$$ 17 $$$ note answer may fit a $$$ 32 $$$ -bit integer,"['dp', 'greedy']",2100.0
1375/B,give a grid $$$ n $$$ row $$$ m $$$ columns cell a non - negative integer write say grid good cell follow condition hold : a number $$$ k > 0 $$$ write exactly $$$ k $$$ neighbor cells a number greater $$$ 0 $$$ write note number cell $$$ 0 $$$ restriction neighbor cells allow take number grid increase $$$ 1 $$$ may apply operation many time want number want perform operations ( possibly zero ) make grid good say impossible multiple possible answer may find two cells consider neighbor a common edge input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n m \le 300 $$$ ) — number row columns respectively follow $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th element $$$ i $$$ -th line $$$ a _ { i j } $$$ number write $$$ j $$$ -th cell $$$ i $$$ -th row ( $$$ 0 \le a _ { i j } \le 1000000000 $$$ ) guarantee sum $$$ n \cdot m $$$ test case exceed $$$ 100000 $$$ impossible obtain a good grid print a single line contain ` ` '' otherwise print a single line contain ` ` yes '' follow $$$ n $$$ line contain $$$ m $$$ integers describe final state grid final grid obtainable initial one apply operations ( possibly zero ) multiple possible answer may print first test case obtain result grid increase number row $$$ 2 $$$ column $$$ 3 $$$ cells contain $$$ 1 $$$ exactly one neighbor greater zero grid good many solutions exist <unknown> accept valid answer second test case impossible make grid good third test case notice cell a number greater zero grid automatically good,['greedy'],1200.0
1375/C,give array $$$ a $$$ length $$$ n $$$ initially a permutation number $$$ 1 $$$ $$$ n $$$ one operation choose index $$$ i $$$ ( $$$ 1 \leq i < n $$$ ) $$$ a_i < a _ { i + 1 } $$$ remove either $$$ a_i $$$ $$$ a _ { i + 1 } $$$ array ( removal remain part concatenate ) example array $$$ [ 1 3 2 ] $$$ choose $$$ i = 1 $$$ ( since $$$ a_1 = 1 < a_2 = 3 $$$ ) either remove $$$ a_1 $$$ give new array $$$ [ 3 2 ] $$$ remove $$$ a_2 $$$ give new array $$$ [ 1 2 ] $$$ possible make length array equal $$$ 1 $$$ operations ? first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 20000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 300000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ $$$ a_i $$$ pairwise distinct ) — elements array guarantee sum $$$ n $$$ test case n't exceed $$$ 300000 $$$ test case output a single line word ` ` yes '' possible reduce array a single element use aforementioned operation ` ` '' impossible first two test case fourth test case operate follow ( bolded elements pair choose operation ) : $$$ [ \text { 1 } \textbf { 2 } \textbf { 3 } ] \rightarrow [ \textbf { 1 } \textbf { 2 } ] \rightarrow [ \text { 1 } ] $$$ $$$ [ \text { 3 } \textbf { 1 } \textbf { 2 } \text { 4 } ] \rightarrow [ \text { 3 } \textbf { 1 } \textbf { 4 } ] \rightarrow [ \textbf { 3 } \textbf { 4 } ] \rightarrow [ \text { 4 } ] $$$ $$$ [ \textbf { 2 } \textbf { 4 } \text { 6 } \text { 1 } \text { 3 } \text { 5 } ] \rightarrow [ \textbf { 4 } \textbf { 6 } \text { 1 } \text { 3 } \text { 5 } ] \rightarrow [ \text { 4 } \text { 1 } \textbf { 3 } \textbf { 5 } ] \rightarrow [ \text { 4 } \textbf { 1 } \textbf { 5 } ] \rightarrow [ \textbf { 4 } \textbf { 5 } ] \rightarrow [ \text { 4 } ] $$$,"['data structures', 'greedy']",1400.0
1379/B,"pasha love send strictly positive integers friends pasha care security therefore want send integer $$$ n $$$ encrypt follow way : pick three integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ l \leq a b c \leq r $$$ compute encrypt value $$$ m = n \cdot a + b - c $$$ unfortunately <unknown> intercept value $$$ l $$$ $$$ r $$$ $$$ m $$$ possible recover original value $$$ a $$$ $$$ b $$$ $$$ c $$$ information ? formally ask find value $$$ a $$$ $$$ b $$$ $$$ c $$$ thatthe first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 20 $$$ ) — number test case follow $$$ t $$$ line describe one test case test case consist three integers $$$ l $$$ $$$ r $$$ $$$ m $$$ ( $$$ 1 \leq l \leq r \leq 500\,000 $$$ $$$ 1 \leq m \leq 10^ { 10 } $$$ ) number answer problem exist test case output three integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ l \leq a b c \leq r $$$ exist a strictly positive integer $$$ n $$$ $$$ n \cdot a + b - c = m $$$ guarantee least one possible solution output possible combination multiple solutions first example $$$ n = 3 $$$ possible $$$ n \cdot 4 + 6 - 5 = 13 = m $$$ possible solutions include : $$$ a = 4 $$$ $$$ b = 5 $$$ $$$ c = 4 $$$ ( $$$ n = 3 $$$ ) ; $$$ a = 5 $$$ $$$ b = 4 $$$ $$$ c = 6 $$$ ( $$$ n = 3 $$$ ) ; $$$ a = 6 $$$ $$$ b = 6 $$$ $$$ c = 5 $$$ ( $$$ n = 2 $$$ ) ; $$$ a = 6 $$$ $$$ b = 5 $$$ $$$ c = 4 $$$ ( $$$ n = 2 $$$ ) second example possible case $$$ n = 1 $$$ : case $$$ n \cdot 2 + 2 - 3 = 1 = m $$$ note $$$ n = 0 $$$ possible since case $$$ n $$$ a strictly positive integer",['math'],1500.0
1379/C,"vladimir would like prepare a present wife : anniversary ! decide buy exactly $$$ n $$$ flower vladimir go a flower shop amaze see $$$ m $$$ type flower sell unlimited supply flower type vladimir want choose flower maximize happiness wife know receive first flower $$$ i $$$ -th type happiness wife increase $$$ a_i $$$ receive consecutive flower type happiness increase $$$ b_i $$$ , among choose flower $$$ x_i > 0 $$$ flower type $$$ i $$$ wife get $$$ a_i + ( x_i - 1 ) \cdot b_i $$$ additional happiness ( flower type $$$ i $$$ get nothing particular type ) please help vladimir choose exactly $$$ n $$$ flower maximize total happiness wife first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10\,000 $$$ ) number test case follow $$$ t $$$ descriptions test case test case description start two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 1000000000 $$$ $$$ 1 \le m \le 100\,000 $$$ ) number flower vladimir need choose number type available flower follow $$$ m $$$ line describe type flower : line contain integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 0 \le a_i b_i \le 1000000000 $$$ ) $$$ i $$$ -th available type flower test case separate a blank line guarantee sum value $$$ m $$$ among test case exceed $$$ 100\,000 $$$ test case output a single integer : maximum total happiness vladimir 's wife choose exactly $$$ n $$$ flower optimally first example case vladimir pick 1 flower first type 3 flower second type case total happiness equal $$$ 5 + ( 1 + 2 \cdot 4 ) = 14 $$$ second example vladimir pick 2 flower first type 2 flower second type 1 flower third type case total happiness equal $$$ ( 5 + 1 \cdot 2 ) + ( 4 + 1 \cdot 2 ) + 3 = 16 $$$","['data structures', 'dp', 'greedy']",2000.0
1379/E,"ivan fond <unknown> currently study a particular <unknown> structure consist people structure every person either parent specify none additionally person exactly one child except one special person children people structure conveniently number $$$ 1 $$$ $$$ n $$$ $$$ s_i $$$ denote child person $$$ i $$$ ( $$$ s_i = 0 $$$ exactly one person children ) say $$$ a $$$ ancestor $$$ b $$$ either $$$ a = b $$$ $$$ a $$$ a child ancestor $$$ b $$$ $$$ a $$$ ancestor $$$ a $$$ $$$ s_a $$$ $$$ s _ { s_a } $$$ etc say person $$$ i $$$ imbalanced case person parent specify total number ancestors one parent least double ivan count number imbalanced people structure get $$$ k $$$ people total however sure whether compute correctly would like check least one construction $$$ n $$$ people $$$ k $$$ imbalanced people total please help find one construction determine exist input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 100\,000 $$$ $$$ 0 \leq k \leq n $$$ ) total number people number imbalanced people constructions $$$ n $$$ people $$$ k $$$ imbalanced people output otherwise output yes first line $$$ n $$$ integers $$$ s_1 s_2 \ldots s_n $$$ ( $$$ 0 \leq s_i \leq n $$$ ) describe construction specify child node ( 0 person children ) first example case one a construction 3 people 1 person 2 parent second example case one use follow construction : person 1 imbalanced one parent 1 ancestor total parent 3 ancestors","['dp', 'math']",2800.0
1380/E,"a set $$$ n $$$ discs $$$ i $$$ -th disc radius $$$ i $$$ initially discs split among $$$ m $$$ tower : tower contain least one disc discs tower sort descend order radii bottom top would like assemble one tower contain discs , may choose two different tower $$$ i $$$ $$$ j $$$ ( contain least one disc ) take several ( possibly ) top discs tower $$$ i $$$ put top tower $$$ j $$$ order long top disc tower $$$ j $$$ bigger discs move may perform operation number time example two tower contain discs $$$ [ 6 4 2 1 ] $$$ $$$ [ 8 7 5 3 ] $$$ ( order bottom top ) two possible operations : let difficulty set tower minimum number operations require assemble one tower contain discs example difficulty set tower $$$ [ [ 3 1 ] [ 2 ] ] $$$ $$$ 2 $$$ : may move disc $$$ 1 $$$ second tower move discs second tower first tower give $$$ m - 1 $$$ query query denote two number $$$ a_i $$$ $$$ b_i $$$ mean ` ` merge tower $$$ a_i $$$ $$$ b_i $$$ ` ` ( take discs two tower assemble a new tower contain descend order radii top bottom ) result tower get index $$$ a_i $$$ $$$ k \in [ 0 m - 1 ] $$$ calculate difficulty set tower first $$$ k $$$ query perform first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le m \le n \le 200000 $$$ ) — number discs number tower respectively second line contain $$$ n $$$ integers $$$ t_1 $$$ $$$ t_2 $$$ ... $$$ t_n $$$ ( $$$ 1 \le t_i \le m $$$ ) $$$ t_i $$$ index tower disc $$$ i $$$ belong value $$$ 1 $$$ $$$ m $$$ appear sequence least $$$ m - 1 $$$ line follow denote query query represent two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le m $$$ $$$ a_i \ne b_i $$$ ) mean $$$ i $$$ -th query tower indices $$$ a_i $$$ $$$ b_i $$$ merge ( $$$ a_i $$$ $$$ b_i $$$ choose a way tower exist $$$ i $$$ -th query ) print $$$ m $$$ integers $$$ k $$$ -th integer ( $$$ 0 $$$ -indexed ) equal difficulty set tower first $$$ k $$$ query perform tower example :","['data structures', 'implementation']",2300.0
1381/B,"let $$$ a $$$ $$$ b $$$ two array lengths $$$ n $$$ $$$ m $$$ respectively elements common define a new array $$$ \mathrm { merge } ( a b ) $$$ length $$$ n+m $$$ recursively follow : algorithm nice property $$$ a $$$ $$$ b $$$ sort $$$ \mathrm { merge } ( a b ) $$$ also sort example use a <unknown> merge - sort problem however consider procedure act non - <unknown> array well example $$$ a= [ 3,1 ] $$$ $$$ b= [ 2,4 ] $$$ $$$ \mathrm { merge } ( a b ) = [ 2,3,1,4 ] $$$ a permutation array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) a permutation $$$ p $$$ length $$$ 2n $$$ determine exist two array $$$ a $$$ $$$ b $$$ length $$$ n $$$ elements common $$$ p=\mathrm { merge } ( a b ) $$$ first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 1000 $$$ ) — number test case next $$$ 2 t $$$ line contain descriptions test case first line test case contain a single integer $$$ n $$$ ( $$$ 1\le n\le 2000 $$$ ) second line test case contain $$$ 2n $$$ integers $$$ p_1 \ldots p _ { 2n } $$$ ( $$$ 1\le p_i\le 2n $$$ ) guarantee $$$ p $$$ a permutation guarantee sum $$$ n $$$ across test case exceed $$$ 2000 $$$ test case output ` ` yes '' exist array $$$ a $$$ $$$ b $$$ length $$$ n $$$ common elements $$$ p=\mathrm { merge } ( a b ) $$$ otherwise output ` ` '' first test case $$$ [ 2,3,1,4 ] = \mathrm { merge } ( [ 3,1 ] [ 2,4 ] ) $$$ second test case show $$$ [ 3,1,2,4 ] $$$ merge two array length $$$ 2 $$$ third test case $$$ [ <unknown> ] = \mathrm { merge } ( [ <unknown> ] [ <unknown> ] ) $$$ fourth test case $$$ [ 1,2,3,4,5,6 ] = \mathrm { merge } ( [ <unknown> ] [ 2,4,5 ] ) $$$ example",['dp'],1800.0
1381/C,"game <unknown> two players — alice bob alice a secret code bob try guess , a code define a sequence $$$ n $$$ color exactly $$$ n+1 $$$ color entire universe number $$$ 1 $$$ $$$ n+1 $$$ inclusive bob guess a code alice tell information good a guess form two integers $$$ x $$$ $$$ y $$$ first integer $$$ x $$$ number indices bob 's guess correctly match alice 's code second integer $$$ y $$$ size intersection two cod multisets , bob change order color guess $$$ y $$$ maximum number indices could get correct example suppose $$$ n=5 $$$ alice 's code $$$ [ <unknown> ] $$$ bob 's guess $$$ [ <unknown> ] $$$ indices $$$ 1 $$$ $$$ 2 $$$ color equal indices equal $$$ x=2 $$$ two cod four color $$$ <unknown> $$$ common $$$ y=4 $$$ give bob 's guess two value $$$ x $$$ $$$ y $$$ find one possibility alice 's code value $$$ x $$$ $$$ y $$$ correct ? first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 1000 $$$ ) — number test case next $$$ 2 t $$$ line contain descriptions test case first line test case contain three integers $$$ n x y $$$ ( $$$ 1\le n\le 100000 0\le x\le y\le n $$$ ) — length cod two value alice respond second line test case contain $$$ n $$$ integers $$$ b_1 \ldots b_n $$$ ( $$$ 1\le b_i\le n+1 $$$ ) — bob 's guess $$$ b_i $$$ $$$ i $$$ -th color guess guarantee sum $$$ n $$$ across test case exceed $$$ 100000 $$$ test case first line output ` ` yes '' a solution ` ` '' possible secret code consistent describe situation print character case ( upper lower ) answer ` ` yes '' next line output $$$ n $$$ integers $$$ a_1 \ldots a_n $$$ ( $$$ 1\le a_i\le n+1 $$$ ) — alice 's secret code $$$ a_i $$$ $$$ i $$$ -th color code multiple solutions output first test case describe statement second test case $$$ x=3 $$$ color equal indices $$$ 2,4,5 $$$ $$$ y=4 $$$ share color $$$ 1,1,1,2 $$$ third test case $$$ x=0 $$$ index color $$$ y=4 $$$ share color $$$ <unknown> $$$ fourth test case prove solution exist","['greedy', 'implementation']",2500.0
1381/D,"undirected tree $$$ n $$$ vertices connect $$$ n-1 $$$ bidirectional edge also a snake stick inside tree head vertex $$$ a $$$ tail vertex $$$ b $$$ snake 's body occupy vertices unique simple path $$$ a $$$ $$$ b $$$ snake want know reverse — move head tail start tail head start unfortunately snake 's movements restrict tree 's structure operation snake move head adjacent vertex currently occupy snake , tail move one vertex closer head length snake remain unchanged similarly snake also move tail adjacent vertex currently occupy snake , head move one unit closer tail determine possible reverse snake sequence operations first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 100 $$$ ) — number test case next line contain descriptions test case first line test case contain three integers $$$ n a b $$$ ( $$$ 2\le n\le <unknown> a b\le n a\ne b $$$ ) next $$$ n-1 $$$ line contain two integers $$$ u_i v_i $$$ ( $$$ 1\le u_i v_i\le n u_i\ne v_i $$$ ) indicate edge vertices $$$ u_i $$$ $$$ v_i $$$ guarantee give edge form a tree guarantee sum $$$ n $$$ across test case exceed $$$ 100000 $$$ test case output ` ` yes '' possible snake reverse ` ` '' otherwise first test case picture second test case tree a path show snake reverse third test case show snake reverse fourth test case example solution : $$$ ( <unknown> ) \to ( <unknown> ) \to ( <unknown> ) \to ( <unknown> ) \to ( 8,13 ) \to ( <unknown> ) \to ( <unknown> ) $$$ $$$ \to ( <unknown> ) \to ( 3,4 ) \to ( 2,5 ) \to ( 1,6 ) \to ( 4,7 ) \to ( <unknown> ) \to ( 10,5 ) $$$ $$$ \to ( <unknown> ) \to ( <unknown> ) \to ( <unknown> ) \to ( <unknown> ) \to ( <unknown> ) \to ( <unknown> ) $$$","['dp', 'greedy']",3000.0
1382/B,$$$ n $$$ pile stone $$$ i $$$ -th pile $$$ a_i $$$ stone two people play a game take alternate turn remove stone a move a player may remove a positive number stone first non - empty pile ( pile minimal index least one stone ) first player make a move ( pile empty ) lose game players play optimally determine winner game first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 1000 $$$ ) — number test case next $$$ 2 t $$$ line contain descriptions test case first line test case contain a single integer $$$ n $$$ ( $$$ 1\le n\le 100000 $$$ ) — number pile second line test case contain $$$ n $$$ integers $$$ a_1 \ldots a_n $$$ ( $$$ 1\le a_i\le 1000000000 $$$ ) — $$$ a_i $$$ equal number stone $$$ i $$$ -th pile guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case player make first move win output ` ` first '' otherwise output ` ` second '' first test case first player win game win strategy :,['dp'],1100.0
1383/E,koa koala a binary string $$$ s $$$ length $$$ n $$$ koa perform $$$ n-1 $$$ ( possibly zero ) operations follow form : one operation koa select position $$$ i $$$ $$$ i+1 $$$ $$$ i $$$ $$$ 1 \le i < |s| $$$ set $$$ s_i $$$ $$$ max ( s_i s _ { i+1 } ) $$$ koa delete position $$$ i+1 $$$ $$$ s $$$ ( removal remain part concatenate ) note every operation length $$$ s $$$ decrease $$$ 1 $$$ many different binary string koa obtain $$$ n-1 $$$ ( possibly zero ) operations modulo $$$ 1000000000 + 7 $$$ ( $$$ 1000000007 $$$ ) ? line input contain binary string $$$ s $$$ ( $$$ 1 \le |s| \le 1000000 $$$ ) $$$ i $$$ ( $$$ 1 \le i \le |s| $$$ ) $$$ s_i = 0 $$$ $$$ s_i = 1 $$$ a single line print answer problem modulo $$$ 1000000000 + 7 $$$ ( $$$ 1000000007 $$$ ) first sample koa obtain binary string : $$$ 0 $$$ $$$ 00 $$$ $$$ 000 $$$ second sample koa obtain binary string : $$$ 1 $$$ $$$ 01 $$$ $$$ 11 $$$ $$$ 011 $$$ $$$ 101 $$$ $$$ 0101 $$$ example : parentheses denote two position koa select operation,"['data structures', 'dp']",2800.0
1384/A,length longest common prefix two string $$$ s = s_1 s_2 \ldots s_n $$$ $$$ t = t_1 t_2 \ldots t_m $$$ define maximum integer $$$ k $$$ ( $$$ 0 \le k \le min ( n m ) $$$ ) $$$ s_1 s_2 \ldots s_k $$$ equal $$$ t_1 t_2 \ldots t_k $$$ koa koala initially $$$ n+1 $$$ string $$$ s_1 s_2 \dots s _ { n+1 } $$$ $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) calculate $$$ a_i $$$ — length longest common prefix $$$ s_i $$$ $$$ s _ { i+1 } $$$ several days later koa find number could n't remember string koa would like find string $$$ s_1 s_2 \dots s _ { n+1 } $$$ would generate number $$$ a_1 a_2 \dots a_n $$$ help ? many answer print show answer always exist give constraints test contain multiple test case first line contain $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number elements list $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 50 $$$ ) — elements $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100 $$$ test case : output $$$ n+1 $$$ line $$$ i $$$ -th line print string $$$ s_i $$$ ( $$$ 1 \le |s_i| \le 200 $$$ ) consist lowercase latin letter length longest common prefix string $$$ s_i $$$ $$$ s _ { i+1 } $$$ equal $$$ a_i $$$ many answer print show answer always exist give constraints $$$ 1 $$$ -st test case one possible answer $$$ s = [ <unknown> ari <unknown> around ari ] $$$ lengths longest common prefix :,['greedy'],1200.0
1384/B1,difference easy hard versions constraints version constraints lower make hack versions problem solve koa koala beach ! beach consist ( leave right ) a shore $$$ n+1 $$$ meter sea island $$$ n+1 $$$ meter shore measure depth sea $$$ 1 2 \dots n $$$ meter shore save array $$$ d $$$ $$$ d_i $$$ denote depth sea $$$ i $$$ meter shore $$$ 1 \le i \le n $$$ like beach one tide intensity tide measure parameter $$$ k $$$ affect depths begin time $$$ t=0 $$$ follow way : formally let 's define $$$ 0 $$$ -indexed array $$$ p = [ 0 1 2 \ldots k - 2 k - 1 k k - 1 k - 2 \ldots 2 1 ] $$$ length $$$ 2k $$$ time $$$ t $$$ ( $$$ 0 \le t $$$ ) depth $$$ i $$$ meter shore equal $$$ d_i + p [ t \bmod 2k ] $$$ ( $$$ t \bmod 2k $$$ denote remainder division $$$ t $$$ $$$ 2k $$$ ) note change occur instantaneously second see note better understand time $$$ t=0 $$$ koa stand shore want get island suppose time $$$ t $$$ ( $$$ 0 \le t $$$ ) $$$ x $$$ ( $$$ 0 \le x \le n $$$ ) meter shore : note koa swim tide n't effect ( ie ca n't drown swim ) note koa choose stay shore long need neither shore island affect tide ( solid grind wo n't drown ) koa want know whether go shore island help ! first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain three integers $$$ n $$$ $$$ k $$$ $$$ l $$$ ( $$$ 1 \le n \le 100 ; 1 \le k \le 100 ; 1 \le l \le 100 $$$ ) — number meter sea koa measure parameters $$$ k $$$ $$$ l $$$ second line test case contain $$$ n $$$ integers $$$ d_1 d_2 \ldots d_n $$$ ( $$$ 0 \le d_i \le 100 $$$ ) — depths meter sea koa measure guarantee sum $$$ n $$$ test case exceed $$$ 100 $$$ test case : print yes koa get shore island otherwise may print letter case ( upper lower ) follow $$$ s $$$ denote shore $$$ i $$$ denote island $$$ x $$$ denote distance koa shore underline denote position koa value array denote current depths affect tide $$$ 1 2 \dots n $$$ meter shore test case $$$ 1 $$$ $$$ n = 2 k = 1 l = 1 p = [ 0 1 ] $$$ koa want go shore ( $$$ x = 0 $$$ ) island ( $$$ x = 3 $$$ ) let 's describe a possible solution : show test case $$$ 2 $$$ koa ca n't get island,"['dp', 'greedy']",1900.0
1386/B,"serge chef famous restaurant ` ` salt pepper & garlic '' try obtain first <unknown> star inform a secret expert plan visit restaurant even even though expert 's name n't disclose serge certain know dish menu order well taste preferences expert namely expert require extremely precise proportion salt pepper garlic powder dish serge keep a set bottle mixtures salt pepper garlic powder a special shelf kitchen bottle know exact amount ingredients kilograms serge combine number bottle mixtures ( use one directly ) get a mixture particular proportion need a certain dish luckily absolute amount a mixture need add a dish small assume amount bottle always sufficient however numeric value describe proportion may quite large serge would like know whether possible obtain expert 's favourite mixture available bottle so — what smallest possible number bottle need achieve furthermore set bottle shelf may change time serge receive new ones lend chefs would like answer question change example assume expert 's favorite mixture $$$ <unknown> $$$ three bottle mixtures shelf : obtain desire mixture enough use equivalent amount mixtures bottle 1 2 . bottle 2 remove longer possible obtain write a program help serge solve task ! first row contain three non - negative integers $$$ s_f $$$ $$$ p_f $$$ $$$ g_f $$$ ( $$$ 0 \leq s_f p_f g_f $$$ ; $$$ 0 < <unknown> \leq 1000000 $$$ ) describe amount salt pepper garlic powder expert 's favourite mixture real $$$ \alpha > 0 $$$ $$$ ( \alpha { s_f } \alpha { p_f } \alpha { g_f } ) $$$ also expert 's favourite mixture second row a positive integer $$$ n $$$ ( number change shelf $$$ n \leq 100\,000 $$$ ) assume initially shelf empty next $$$ n $$$ row describe a single change shelf : output $$$ n $$$ row $$$ j $$$ -th row ( $$$ 1 \leq j \leq n $$$ ) contain number $$$ x_j $$$ smallest number bottle need prepare a mixture expert 's favourite proportion salt pepper garlic powder use bottle available first $$$ j $$$ change shelf $$$ 0 $$$ possible subtasks : pay attention example bottle $$$ 1 $$$ $$$ 3 $$$ contain proportion salt pepper garlic powder","['data structures', 'math']",2900.0
1388/A,despite bad reputation captain flint a friendly person ( least friendly animals ) captain flint search worthy sailors join new crew ( solely peaceful purpose ) a sailor consider worthy solve flint 's task recently blue captain flint interest math even define a new class integers let 's define a positive integer $$$ x $$$ nearly prime represent $$$ p \cdot q $$$ $$$ 1 < p < q $$$ $$$ p $$$ $$$ q $$$ prime number example integers $$$ 6 $$$ $$$ 10 $$$ nearly prim ( since $$$ 6 = 6 $$$ $$$ 10 = 10 $$$ ) integers $$$ 1 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 16 $$$ $$$ 17 $$$ $$$ 44 $$$ captain flint guess integer $$$ n $$$ ask : represent sum $$$ 4 $$$ different positive integers least $$$ 3 $$$ nearly prime uncle bogdan easily solve task join crew ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next $$$ t $$$ line contain test case — one per line first line test case contain single integer $$$ n $$$ $$$ ( 1 \le n \le 2 \cdot 100000 ) $$$ — number flint guess test case print : first second test case prove four different positive integers least three nearly prime third test case $$$ <unknown> \cdot 7 + 10 + 6 + 1 $$$ : integers $$$ 14 $$$ $$$ 10 $$$ $$$ 6 $$$ nearly prime fourth test case $$$ <unknown> + 6 + 10 + 15 $$$ : integers $$$ 6 $$$ $$$ 10 $$$ $$$ 15 $$$ nearly prime fifth test case $$$ <unknown> \cdot 3 + 7 + 10 + 21 $$$ : integers $$$ 6 $$$ $$$ 10 $$$ $$$ 21 $$$ nearly prime sixth test case $$$ <unknown> + 10 + 33 + 55 $$$ : integers $$$ 10 $$$ $$$ 33 $$$ $$$ 55 $$$ nearly prime seventh test case $$$ <unknown> \cdot 5 + 21 + 221 + 6 $$$ : integers $$$ 10 $$$ $$$ 21 $$$ $$$ 221 $$$ $$$ 6 $$$ nearly prime,"['greedy', 'math']",800.0
1398/C,give array $$$ a_1 a_2 \dots a_n $$$ consist integers $$$ 0 $$$ $$$ 9 $$$ a subarray $$$ a_l a _ { l+1 } a _ { l+2 } \dots a _ { r-1 } a_r $$$ good sum elements subarray equal length subarray ( $$$ \sum\limits _ { i = l } ^ { r } a_i = r - l + 1 $$$ ) example $$$ a = [ 1 2 0 ] $$$ $$$ 3 $$$ good subarrays : $$$ a _ { 1 \dots 1 } = [ 1 ] a _ { 2 \dots 3 } = [ 2 0 ] $$$ $$$ a _ { 1 \dots 3 } = [ 1 2 0 ] $$$ calculate number good subarrays array $$$ a $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length array $$$ a $$$ second line test case contain a string consist $$$ n $$$ decimal digits $$$ i $$$ -th digit equal value $$$ a_i $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print one integer — number good subarrays array $$$ a $$$ first test case consider statement second test case $$$ 6 $$$ good subarrays : $$$ a _ { 1 \dots 1 } $$$ $$$ a _ { 2 \dots 2 } $$$ $$$ a _ { 1 \dots 2 } $$$ $$$ a _ { 4 \dots 4 } $$$ $$$ a _ { 5 \dots 5 } $$$ $$$ a _ { 4 \dots 5 } $$$ third test case one good subarray : $$$ a _ { 2 \dots 6 } $$$,"['data structures', 'dp', 'math']",1600.0
1398/D,give three multisets pair color stick : construct rectangles pair stick follow process : thus get rectangles opposite side color adjacent side color pair stick use pair leave unused allow split a pair independent stick maximum area achieve ? first line contain three integers $$$ r $$$ $$$ g $$$ $$$ b $$$ ( $$$ 1 \le r g b \le 200 $$$ ) — number pair red stick number pair green stick number pair blue stick second line contain $$$ r $$$ integers $$$ r_1 r_2 \dots <unknown> $$$ ( $$$ 1 \le r_i \le 2000 $$$ ) — lengths stick pair red stick third line contain $$$ g $$$ integers $$$ g_1 g_2 \dots <unknown> $$$ ( $$$ 1 \le g_i \le 2000 $$$ ) — lengths stick pair green stick fourth line contain $$$ b $$$ integers $$$ b_1 b_2 \dots <unknown> $$$ ( $$$ 1 \le b_i \le 2000 $$$ ) — lengths stick pair blue stick print maximum possible total area construct rectangles first example construct one rectangles : red green side $$$ 3 $$$ $$$ 5 $$$ red blue side $$$ 3 $$$ $$$ 4 $$$ green blue side $$$ 5 $$$ $$$ 4 $$$ best area $$$ 4 \times 5 = 20 $$$ second example best rectangles : red / blue $$$ 9 \times 8 $$$ red / blue $$$ 5 \times 5 $$$ green / blue $$$ 2 \times 1 $$$ total area $$$ 72 + 25 + 2 = 99 $$$ third example best rectangles : red / green $$$ 19 \times 8 $$$ red / blue $$$ 20 \times 11 $$$ total area $$$ 152 + 220 = <unknown> $$$ note ca n't construct rectangles allow pair take color,"['dp', 'greedy']",1800.0
1398/E,polycarp play a computer game ( yet ) game fight monsters use magic spell two type spell : fire spell power $$$ x $$$ deal $$$ x $$$ damage monster lightning spell power $$$ y $$$ deal $$$ y $$$ damage monster double damage next spell polycarp cast spell cast per battle polycarp cast order example suppose polycarp know three spell : a fire spell power $$$ 5 $$$ a lightning spell power $$$ 1 $$$ a lightning spell power $$$ 8 $$$ $$$ 6 $$$ ways choose order cast spell : initially polycarp know $$$ 0 $$$ spell spell set change $$$ n $$$ time time either learn a new spell forget already know one change calculate maximum possible damage polycarp may deal use spell know first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number change spell set next $$$ n $$$ line contain two integers $$$ tp $$$ $$$ d $$$ ( $$$ 0 \le tp_i \le 1 $$$ ; $$$ -1000000000 \le d \le 1000000000 $$$ ; $$$ d_i \neq 0 $$$ ) — description change $$$ tp_i $$$ equal $$$ 0 $$$ polycarp learn ( forget ) a fire spell otherwise learn ( forget ) a lightning spell $$$ d_i > 0 $$$ polycarp learn a spell power $$$ d_i $$$ otherwise polycarp forget a spell power $$$ <unknown> $$$ guarantee know spell change guarantee power spell polycarp know change different ( polycarp never know two spell power ) change print maximum damage polycarp deal current set spell,"['data structures', 'greedy', 'implementation', 'math']",2200.0
1398/G,a run competition go hold soon stadium competition hold represent several segment coordinate plane : example a picture stadium $$$ x = 10 $$$ $$$ y = 5 $$$ $$$ n = 3 $$$ $$$ a = [ 0 3 5 10 ] $$$ : a lap a route go along segment start finish point never intersect ( two point a lap coincide start point end point ) length a lap a total distance travel around example red route picture represent stadium a lap length $$$ 24 $$$ competition hold $$$ q $$$ stag $$$ i $$$ -th stage length $$$ l_i $$$ organizers want choose a lap stage length lap a divisor $$$ l_i $$$ organizers n't want choose short lap stag stage want find maximum possible length a suitable lap help organizers calculate maximum possible lengths lap stag ! word every $$$ l_i $$$ find maximum possible integer $$$ l $$$ $$$ l_i \bmod l = 0 $$$ exist a lap length exactly $$$ l $$$ impossible choose a lap print $$$ -1 $$$ first line contain three integers $$$ n $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \le n x y \le 200000 $$$ $$$ n \le x $$$ ) second line contain $$$ n + 1 $$$ integers $$$ a_0 $$$ $$$ a_1 $$$ ... $$$ a_n $$$ ( $$$ 0 = a_0 < a_1 < a_2 < \dots < a _ { n - 1 } < a_n = x $$$ ) third line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number stag fourth line contain $$$ q $$$ even integers $$$ l_1 $$$ $$$ l_2 $$$ ... $$$ <unknown> $$$ ( $$$ 4 \le l_i \le 1000000 $$$ ) — lengths stag print $$$ q $$$ number $$$ i $$$ -th number equal maximum possible length a suitable lap $$$ i $$$ -th stage $$$ -1 $$$ impossible choose a lap stage,['math'],2600.0
14/E,bob like draw camels : a single hump two hump three hump etc draw a <unknown> connect point a coordinate plane 's draw camels t hump represent polylines plane polyline consist n vertices coordinate ( x1 y1 ) ( x2 y2 ) ... ( xn yn ) first vertex a coordinate x1 = 1 second — x2 = 2 etc coordinate yi might satisfy follow condition : a series draw camels t hump bob want buy a notebook n't know many page need output amount different polylines draw represent camels t hump a give number n. first line contain a pair integers n t ( 3 ≤ n ≤ 20 1 ≤ t ≤ 10 ) output require amount camels t hump first sample test sequence y - coordinates six camels : <unknown> <unknown> <unknown> <unknown> <unknown> и <unknown> ( digit correspond one value yi ),['dp'],1900.0
1400/D,give array $$$ a_1 a_2 \dots a_n $$$ calculate number tuples $$$ ( i j k l ) $$$ : first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 4 \le n \le 3000 $$$ ) — size array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — array $$$ a $$$ 's guarantee sum $$$ n $$$ one test n't exceed $$$ 3000 $$$ test case print number describe tuples first test case four indices $$$ i < j < k < l $$$ valid answer number tuples second test case $$$ 2 $$$ valid tuples :,"['data structures', 'math']",1900.0
1406/A,"give a set integers ( contain equal elements ) split two subsets $$$ a $$$ $$$ b $$$ ( contain equal elements empty ) maximize value $$$ mex ( a ) + mex ( b ) $$$ $$$ mex $$$ a set denote smallest non - negative integer n't exist set example : set splitted two subsets $$$ a $$$ $$$ b $$$ integer number $$$ x $$$ number occurrences $$$ x $$$ set equal sum number occurrences $$$ x $$$ $$$ a $$$ number occurrences $$$ x $$$ $$$ b $$$ input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1\leq t\leq 100 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1\leq n\leq 100 $$$ ) — size set second line testcase contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0\leq a_i\leq 100 $$$ ) — number set test case print maximum value $$$ mex ( a ) + mex ( b ) $$$ first test case $$$ a=\left\ { 0,1,2\right\ } b=\left\ { <unknown> } $$$ a possible choice second test case $$$ a=\left\ { 0,1,2\right\ } <unknown> $$$ a possible choice third test case $$$ a=\left\ { 0,1,2\right\ } b=\left\ { <unknown> } $$$ a possible choice fourth test case $$$ a=\left\ { <unknown> } b=\left\ { <unknown> } $$$ a possible choice","['greedy', 'implementation', 'math']",900.0
1408/B,give a non - decreasing array non - negative integers $$$ a_1 a_2 \ldots a_n $$$ also give a positive integer $$$ k $$$ want find $$$ m $$$ non - decreasing array non - negative integers $$$ b_1 b_2 \ldots b_m $$$ : find minimum possible value $$$ m $$$ report possible $$$ m $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) : number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 100 $$$ $$$ 1 \leq k \leq n $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_1 \leq a_2 \leq \ldots \leq a_n \leq 100 $$$ $$$ a_n > 0 $$$ ) test case print a single integer : minimum possible value $$$ m $$$ $$$ m $$$ print $$$ -1 $$$ first test case possible $$$ m $$$ elements array equal $$$ 0 $$$ case impossible get $$$ a_4 = 1 $$$ sum zero second test case take $$$ b_1 = [ 3 3 3 ] $$$ $$$ 1 $$$ smallest possible value $$$ m $$$ third test case take $$$ b_1 = [ 0 1 1 1 2 2 2 2 2 2 2 ] $$$ $$$ b_2 = [ 0 0 1 1 1 1 1 2 2 2 2 ] $$$ 's easy see $$$ a_i = b _ { 1 i } + b _ { 2 i } $$$ $$$ i $$$ number different elements $$$ b_1 $$$ $$$ b_2 $$$ equal $$$ 3 $$$ ( $$$ 3 $$$ ) prove $$$ 2 $$$ smallest possible value $$$ m $$$,"['greedy', 'math']",1400.0
1408/E,"give $$$ m $$$ set integers $$$ a_1 a_2 \ldots a_m $$$ ; elements set integers $$$ 1 $$$ $$$ n $$$ inclusive two array positive integers $$$ a_1 a_2 \ldots a_m $$$ $$$ b_1 b_2 \ldots b_n $$$ one operation delete element $$$ j $$$ set $$$ a_i $$$ pay $$$ a_i + b_j $$$ coin make several ( maybe none ) operations ( set become empty ) , make edge - colored undirected graph consist $$$ n $$$ vertices set $$$ a_i $$$ add edge $$$ ( x y ) $$$ color $$$ i $$$ $$$ x y \in a_i $$$ $$$ x < y $$$ pair vertices connect one edge edge different color call a cycle $$$ i_1 \to e_1 \to i_2 \to e_2 \to \ldots \to i_k \to e_k \to i_1 $$$ ( $$$ <unknown> $$$ edge connect vertices $$$ i_j $$$ $$$ i _ { j+1 } $$$ graph ) rainbow edge different color find minimum number coin pay get a graph without rainbow cycle first line contain two integers $$$ m $$$ $$$ n $$$ ( $$$ 1 \leq m n \leq 100000 $$$ ) number set number vertices graph second line contain $$$ m $$$ integers $$$ a_1 a_2 \ldots a_m $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) third line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1 \leq b_i \leq 1000000000 $$$ ) next $$$ m $$$ line descriptions set $$$ i $$$ -th line first integer $$$ s_i $$$ ( $$$ 1 \leq s_i \leq n $$$ ) equal size $$$ a_i $$$ $$$ s_i $$$ integers follow : elements set $$$ a_i $$$ integers $$$ 1 $$$ $$$ n $$$ distinct guarantee sum $$$ s_i $$$ $$$ 1 \leq i \leq m $$$ exceed $$$ 200000 $$$ print one integer : minimum number coin pay operations avoid rainbow cycle obtain graph first test make operations : pay $$$ 11 $$$ coin total operations first second set equal $$$ \ { 2\ } $$$ third set equal $$$ \ { 1 2\ } $$$ , graph consist one edge $$$ ( 1 2 ) $$$ color $$$ 3 $$$ second test make operations : pay $$$ 66 $$$ coin total operations set : get graph : rainbow cycle","['data structures', 'greedy']",2400.0
1408/I,"give a positive integer $$$ k $$$ array $$$ a_1 a_2 \ldots a_n $$$ non - negative distinct integers smaller $$$ k $$$ greater $$$ 2^c-1 $$$ next $$$ k $$$ second one element choose randomly equiprobably $$$ n $$$ elements decrease $$$ 1 $$$ integer $$$ x $$$ $$$ 0 \leq x \leq 2^c - 1 $$$ need find probability end bitwise xor elements array equal $$$ x $$$ value represent irreducible fraction $$$ \frac { p } { q } $$$ need find value $$$ p \cdot q^ { -1 } $$$ modulo $$$ 998\,244\,353 $$$ first line input contain three integers $$$ n k c $$$ ( $$$ 1 \leq n \leq ( 2^c - k ) $$$ $$$ 1 \leq k \leq 16 $$$ $$$ 1 \leq c \leq 16 $$$ ) second line contain $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ k \leq a_i \leq 2^c-1 $$$ ) print $$$ 2^c $$$ integers : probability bitwise xor equal $$$ x $$$ end $$$ x $$$ $$$ \ { 0 1 \ldots <unknown> } $$$ modulo $$$ 998\,244\,353 $$$","['dp', 'math']",3200.0
141/E,santa claus assistant elf deliver present make wish come true return north pole find cover snow quite tire decide remove snow roads connect huts north pole n huts connect m roads one go along roads directions elf offer split : santa claus clear wide roads elf tread narrow roads road decide clear : santa claus elf minimize efforts decide clear road fulfill condition : point santa claus assistant elf wonder roads clear ? first input line contain two positive integers n m ( 1 ≤ n ≤ 103 1 ≤ m ≤ 105 ) — number huts number roads follow m line contain a road description : number huts connect — x y ( 1 ≤ x y ≤ n ) person responsible clear road ( ` ` s '' — elf ` ` m '' santa claus ) possible go road directions note one road two huts a road begin end <unknown> print ` ` -1 '' without quote impossible choose roads clear give rule otherwise print first line many roads clear second line print number roads ( roads number 1 order occurrence input ) allow print number roads order number print exactly print number separate space a path call simple huts pairwise different,['dp'],2300.0
1411/A,assign develop a filter bad message in - game chat a message a string $$$ s $$$ length $$$ n $$$ consist lowercase english letter character ' ) ' message bad number character ' ) ' end string strictly greater number remain character example string ` ` ) bc ) ) ) '' three parentheses end three remain character consider bad first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) description $$$ t $$$ test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) second line test case contain a string $$$ s $$$ length $$$ n $$$ consist lowercase english letter character ' ) ' $$$ t $$$ test case print ` ` yes '' string bad otherwise print ` ` '' print letter case ( upper lower ),['implementation'],800.0
1411/D,currently xxoc 's rap a string consist zero ones question mark unfortunately haters gon na hate write $$$ x $$$ angry comment every occurrence subsequence 01 $$$ y $$$ angry comment every occurrence subsequence 10 . replace question mark 0 1 a way number angry comment would small possible string $$$ b $$$ a subsequence string $$$ a $$$ obtain remove character $$$ a $$$ two occurrences a subsequence consider distinct set position remain character distinct first line contain string $$$ s $$$ — xxoc 's rap ( $$$ 1 \le |s| \leq 100000 $$$ ) second line contain two integers $$$ x $$$ $$$ y $$$ — number angry comment xxoc recieve every occurrence 01 10 accordingly ( $$$ 0 \leq x y \leq 1000000 $$$ ) output a single integer — minimum number angry comment first example one optimum ways replace 001 . $$$ 2 $$$ subsequences 01 $$$ 0 $$$ subsequences 10 . total number angry comment equal $$$ 4 + 0 = 4 $$$ second example one optimum ways replace 11111 . $$$ 0 $$$ subsequences 01 $$$ 0 $$$ subsequences 10 . total number angry comment equal $$$ 0 + 0 = 0 $$$ third example one optimum ways replace 1100 . $$$ 0 $$$ subsequences 01 $$$ 4 $$$ subsequences 10 . total number angry comment equal $$$ 0 + 28 = 28 $$$ fourth example one optimum ways replace <unknown> . $$$ 8 $$$ subsequences 01 $$$ 8 $$$ subsequences 10 . total number angry comment equal $$$ 40 + 56 = 96 $$$,"['greedy', 'implementation']",2100.0
1413/A,naruto sneak orochimaru 's lair look <unknown> $$$ t $$$ room every room a door door describe number $$$ n $$$ seal integer energies $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ energies $$$ a_i $$$ nonzero exceed $$$ 100 $$$ absolute value also $$$ n $$$ even order open a door naruto must find $$$ n $$$ seal integer energies $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_n $$$ follow equality hold : $$$ a _ { 1 } \cdot b _ { 1 } + a _ { 2 } \cdot b _ { 2 } + ... + a _ { n } \cdot b _ { n } = 0 $$$ $$$ b_i $$$ must nonzero well $$$ a_i $$$ also must exceed $$$ 100 $$$ absolute value please find require seal every room first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) stand number room orochimaru 's lair line contain descriptions doors description start line contain even integer $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) denote number seal follow line contain space separate sequence nonzero integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ |a _ { i } | \leq 100 $$$ $$$ a _ { i } \neq 0 $$$ ) denote energies seal door print a space separate sequence nonzero integers $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_n $$$ ( $$$ |b _ { i } | \leq 100 $$$ $$$ b _ { i } \neq 0 $$$ ) denote seal open door multiple valid answer print prove least one answer always exist first door naruto use energies $$$ [ -100 1 ] $$$ require equality indeed hold : $$$ 1 \cdot ( -100 ) + 100 = 0 $$$ second door naruto use example energies $$$ [ 1 1 1 -1 ] $$$ require equality also hold : $$$ 1 + 2 + 3 + 6 \cdot ( -1 ) = 0 $$$,['math'],800.0
1418/A,play a popular game call <unknown> initially one stick want craft $$$ k $$$ torch one torch craft use one stick one coal hopefully ' ve meet a handsome wander trader two trade offer : one trade use one two trade offer use trade offer number time want order task find minimum number trade need craft least $$$ k $$$ torch answer always exist give constraints answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow line test case contain three integers $$$ x $$$ $$$ y $$$ $$$ k $$$ ( $$$ 2 \le x \le 1000000000 $$$ ; $$$ 1 \le y k \le 1000000000 $$$ ) — number stick buy one stick number stick require buy one coal number torch need respectively test case print answer : minimum number trade need craft least $$$ k $$$ torch answer always exist give constraints,['math'],1000.0
1418/C,"friend play game mortal <unknown> xi try pass a challenge tower $$$ n $$$ boss tower number $$$ 1 $$$ $$$ n $$$ type $$$ i $$$ -th boss $$$ a_i $$$ $$$ i $$$ -th boss easy type $$$ a_i = 0 $$$ otherwise boss hard type $$$ a_i = 1 $$$ one session either friend kill one two boss ( neither friend skip session minimum number boss kill one session least one ) friend session session begin friend session begin session begin , first session friend 's session friend need get good ca n't actually kill hard boss kill use skip point one skip point use kill one hard boss task find minimum number skip point friend need use friend kill $$$ n $$$ boss give order example : suppose $$$ n = 8 $$$ $$$ a = [ 1 0 1 1 0 1 1 1 ] $$$ best course action follow : answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number boss second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 1 $$$ ) $$$ a_i $$$ type $$$ i $$$ -th boss guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print answer : minimum number skip point friend need use friend kill $$$ n $$$ boss give order","['dp', 'greedy']",1500.0
1419/A,everyone know agents valorant decide play attackers play defenders raze breach decide play $$$ t $$$ match a digit game ... $$$ t $$$ match digit game a positive integer generate consist $$$ n $$$ digits digits integer numerate $$$ 1 $$$ $$$ n $$$ highest - order digit lowest - order digit integer announce match start agents play turn raze start one turn agent choose unmarked digit mark raze choose digits odd position choose digits even position breach choose digits even position choose digits odd position match end one unmarked digit leave single last digit odd raze win else breach win prove end match ( every initial integer $$$ n $$$ digits ) agent ability make a turn i.e least one unmarked digit stand a position require parity $$$ t $$$ match find agent win want win play optimally first line input contain integer $$$ t $$$ $$$ ( 1 \le t \le 100 ) $$$ — number match first line match description contain integer $$$ n $$$ $$$ ( 1 \le n \le 1000 ) $$$ — number digits generate number second line match description contain $$$ n $$$ -digit positive integer without lead zero match print $$$ 1 $$$ raze win $$$ 2 $$$ breach win first match one make a turn digit leave $$$ 2 $$$ 's even breach win second match digit leave $$$ 3 $$$ 's odd raze win third match raze mark last digit breach mark $$$ 0 $$$ $$$ 1 $$$ last digit leave 's odd raze win fourth match matter raze play breach mark $$$ 9 $$$ end digit $$$ 0 $$$ 's even breach win,"['greedy', 'implementation']",900.0
1419/C,a new agent call killjoy invent a virus <unknown> infect account codeforces account a rat describe integer ( possibly negative large ) killjoy 's account already infect a rat equal $$$ x $$$ rat constant $$$ n $$$ account except number $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th account 's initial rat $$$ a_i $$$ infect account ( initially infect account killjoy 's ) instantly infect uninfected account rat equal happen begin ( rat change ) contest account infect heal contest regularly hold codeforces contest $$$ n $$$ account ( include infect ones ) participate killjoy ca n't participate contest rat change way : participant 's rat change integer sum change must equal zero new rat integer find minimal number contest need infect account choose account participate contest rat change prove account infect finite number contest first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 100 ) $$$ — number test case next $$$ 2 t $$$ line contain descriptions test case first line test case contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 2 \le n \le 1000 $$$ $$$ -4000 \le x \le 4000 $$$ ) — number account codeforces rat killjoy 's account second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ $$$ ( -4000 \le a_i \le 4000 ) $$$ — rat account test case output minimal number contest need infect account first test case 's possible make rat equal $$$ 69 $$$ first account 's rat increase $$$ 1 $$$ second account 's rat decrease $$$ 1 $$$ sum change equal zero second test case account instantly infect rat ( include killjoy 's account 's rat ) equal $$$ 4 $$$,"['greedy', 'implementation', 'math']",1500.0
1419/D1,easy version problem difference versions easy version price $$$ a_i $$$ different make hack solve versions problem today sage 's birthday go shop buy ice spheres $$$ n $$$ ice spheres place a row number $$$ 1 $$$ $$$ n $$$ leave right ice sphere a positive integer price version price different ice sphere cheap cost strictly less two neighbor ice spheres : nearest leave nearest right leftmost rightmost ice spheres cheap sage choose cheap ice spheres buy visit shop sage reorder ice spheres wish find maximum number ice spheres sage buy show ice spheres reorder first line contain a single integer $$$ n $$$ $$$ ( 1 \le n \le 100000 ) $$$ — number ice spheres shop second line contain $$$ n $$$ different integers $$$ a_1 a_2 \dots a_n $$$ $$$ ( 1 \le a_i \le 1000000000 ) $$$ — price ice spheres first line print maximum number ice spheres sage buy second line print price ice spheres optimal order several correct answer print example 's possible place ice spheres order sage would buy $$$ 3 $$$ ice spheres place like $$$ ( 3 1 4 2 5 ) $$$ sage buy two spheres : one $$$ 1 $$$ one $$$ 2 $$$ cheap,['greedy'],1000.0
1419/F,"$$$ n $$$ detachments surface number $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th detachment place a point coordinate $$$ ( x_i y_i ) $$$ detachments place different point brimstone visit detachment least choose detachment brimstone start move one detachment another first choose one four directions movement ( right leave ) start move constant speed one unit interval a second come a detachment reach arbitrary detachment repeat process $$$ t $$$ second <unknown> strike cover whole surface moment brimstone a point detachment locate stay detachment long need brimstone a good commander 's create one detachment place empty point integer coordinate want trip keep mind brimstone need visit detachment , help brimstone find minimal $$$ t $$$ possible check detachment $$$ t $$$ report first line contain a single integer $$$ n $$$ $$$ ( 2 \le n \le 1000 ) $$$ — number detachments next $$$ n $$$ line a pair integers $$$ x_i $$$ $$$ y_i $$$ $$$ ( |x_i| |y_i| \le 1000000000 ) $$$ — coordinate $$$ i $$$ -th detachment guarantee point different output minimal integer $$$ t $$$ possible check detachments add one new detachment $$$ t $$$ print $$$ -1 $$$ first test possible place a detachment $$$ ( 0 0 ) $$$ possible check detachments $$$ t = 100 $$$ prove impossible check detachments $$$ t < 100 $$$ ; thus answer $$$ 100 $$$ second test $$$ t $$$ possible check detachments even add one new detachment answer $$$ -1 $$$ third test possible place a detachment $$$ ( 1 0 ) $$$ brimstone check detachments $$$ t = 2 $$$ prove minimal $$$ t $$$ fourth test need add detachments answer get better ( $$$ t = 2 $$$ ) prove minimal $$$ t $$$","['data structures', 'implementation']",2800.0
142/B,upon a time kingdom far far away live sir lancelot chief royal general proud men like invite king come watch drill exercise demonstrate fight techniques tactics squad charge time go one day sir lancelot a major argument fairy godmother ( rumor argument occur general speak badly godmother 's fly techniques seem hurt fairy godmother deeply ) result argument godmother put a rather strange curse upon general sound complicate quite harmless : ` ` square distance two soldier equal 5 soldier conflict ! ` ` drill exercise hold a rectangular n × m field split nm square 1 × 1 segment soldier thus square distance soldier stand square ( x1 y1 ) ( x2 y2 ) equal exactly ( x1 - x2 ) 2 + ( y1 - y2 ) 2 . nm squad soldier participate drill exercise fairy godmother 's curse unless course general want soldier fight even worse ... example put a soldier square ( 2 2 ) put soldier square ( 1 4 ) ( 3 4 ) ( 4 1 ) ( 4 3 ) — conflict soldier square ( 2 2 ) task help general give size drill exercise field ask calculate maximum number soldier simultaneously position field two soldier fall fairy godmother 's curse single line contain space - separated integers n m ( 1 ≤ n m ≤ 1000 ) represent size drill exercise field print desire maximum number warriors first sample test sir lancelot place 4 soldier 2 × 4 court follow ( soldier ' locations mark gray circle scheme ) : second sample test place 6 soldier 3 × 4 site follow manner :,"['greedy', 'implementation']",1800.0
1420/E,"a <unknown> keeper peter command army $$$ n $$$ battle lemmings order army stand a line number lemmings $$$ 1 $$$ $$$ n $$$ leave right lemmings hold shield lemming hold one shield protect peter 's army better calculate protection army find number protect pair lemmings pair lemmings pair n't hold a shield a lemming a shield 's time prepare defence increase protection army , peter give order choose a lemming a shield give one two order : one second peter give exactly one order 's clear much time peter defence decide determine maximal value army protection $$$ k $$$ $$$ 0 $$$ $$$ \frac { n ( n-1 ) } 2 $$$ give $$$ k $$$ order help peter calculate ! first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 80 $$$ ) number lemmings peter 's army second line contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 0 \le a_i \le 1 $$$ ) $$$ a_i = 1 $$$ $$$ i $$$ -th lemming a shield otherwise $$$ a_i = 0 $$$ print $$$ \frac { n ( n-1 ) } 2 + 1 $$$ number greatest possible protection $$$ 0 1 \dots \frac { n ( n-1 ) } 2 $$$ order consider first example protection initially equal zero pair lemmings without shield lemmings shield one second peter order first lemming give shield right neighbor case protection two two protect pair lemmings $$$ ( 1 3 ) $$$ $$$ ( 1 4 ) $$$ two second peter act follow way first order fifth lemming give a shield leave neighbor , order first lemming give a shield right neighbor case peter three protect pair lemmings — $$$ ( 1 3 ) $$$ $$$ ( 1 5 ) $$$ $$$ ( 3 5 ) $$$ make sure 's impossible give order a way protection become greater three","['dp', 'greedy']",2500.0
1422/A,yura task build a close fence shape arbitrary non - degenerate simple quadrilateral 's already get three straight fence segment know lengths $$$ a $$$ $$$ b $$$ $$$ c $$$ need find possible integer length $$$ d $$$ fourth straight fence segment build fence use four segment word fence a quadrilateral shape side lengths equal $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ help yura find possible length fourth side a non - degenerate simple quadrilateral a quadrilateral three corner lie line cross first line contain a single integer $$$ t $$$ — number test case ( $$$ 1 \le t \le 1000 $$$ ) next $$$ t $$$ line describe test case line contain three integers $$$ a $$$ $$$ b $$$ $$$ c $$$ — lengths three fence segment ( $$$ 1 \le a b c \le 1000000000 $$$ ) test case print a single integer $$$ d $$$ — length fourth fence segment suitable build fence multiple answer print show answer always exist build a quadrilateral side $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ build a quadrilateral side $$$ 12 $$$ $$$ 34 $$$ $$$ 56 $$$ $$$ 42 $$$,['math'],800.0
1423/J,bubble cup hypothesis stand unsolved $$$ 130 $$$ years ever prove hypothesis regard one greatest mathematicians time ! a famous mathematician jerry mao manage reduce hypothesis problem : give a number $$$ m $$$ many polynomials $$$ p $$$ coefficients set $$$ { \ { <unknown> } } $$$ : $$$ p ( 2 ) = m $$$ ? help jerry mao solve long stand problem ! first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 5\cdot 100000 ) $$$ - number test case next line $$$ t $$$ number $$$ m_i $$$ $$$ ( 1 \leq m_i \leq 10^ { 18 } ) $$$ - mean case $$$ i $$$ solve number $$$ m_i $$$ test case $$$ i $$$ print answer separate line : number polynomials $$$ p $$$ describe statement $$$ p ( 2 ) = m_i $$$ modulo $$$ 1000000000 + 7 $$$ first case $$$ m=2 $$$ polynomials satisfy constraint $$$ x $$$ $$$ 2 $$$ second case $$$ m=4 $$$ polynomials satisfy constraint $$$ x^2 $$$ $$$ x + 2 $$$ $$$ 2x $$$ $$$ 4 $$$,"['dp', 'math']",2400.0
1423/K,number world two different number friends a lot common also one unique perk precisely two different number $$$ a $$$ $$$ b $$$ friends $$$ gcd ( a b ) $$$ $$$ \frac { a } { gcd ( a b ) } $$$ $$$ \frac { b } { gcd ( a b ) } $$$ form side a triangle three number $$$ a $$$ $$$ b $$$ $$$ c $$$ form side a triangle $$$ a + b > c $$$ $$$ b + c > a $$$ $$$ c + a > b $$$ a group number a number lonely n't friends group give a group number contain number $$$ 1 2 3 ... n $$$ many number group lonely ? first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000000 ) $$$ - number test case next line $$$ t $$$ number $$$ n_i $$$ $$$ ( 1 \leq n_i \leq 1000000 ) $$$ - mean case $$$ i $$$ solve number $$$ 1 2 3 ... n_i $$$ test case print answer separate line : number lonely number group $$$ 1 2 3 ... n_i $$$ first test case $$$ 1 $$$ number therefore lonely second test case $$$ n=5 $$$ number $$$ 1 $$$ $$$ 3 $$$ $$$ 5 $$$ lonely third test case $$$ n=10 $$$ number $$$ 1 $$$ $$$ 5 $$$ $$$ 7 $$$ lonely,['math'],1600.0
1426/C,initially array $$$ a $$$ consist one element $$$ 1 $$$ ( $$$ a = [ 1 ] $$$ ) one move one follow things : example consider sequence five move : task find minimum number move require obtain array sum least $$$ n $$$ answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case $$$ t $$$ test case follow line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) — lower bind sum array test case print answer : minimum number move require obtain array sum least $$$ n $$$,['math'],1100.0
1428/C,"zookeeper play a game game zookeeper must use bomb bomb a string consist letter ' a ' ' b ' use bomb bomb a substring either ` ` ab '' ` ` bb '' bomb a substring substring get delete string remain part string get concatenate example zookeeper use two operations : <unknown> $$$ \to $$$ aabba $$$ \to $$$ aaa zookeeper wonder shortest string make help find length shortest string ? test contain multiple test case first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 20000 ) $$$ — number test case description test case follow next $$$ t $$$ line contain a single test case consist a non - empty string $$$ s $$$ : string zookeeper need bomb guarantee symbols $$$ s $$$ either ' a ' ' b ' guarantee sum $$$ |s| $$$ ( length $$$ s $$$ ) among test case exceed $$$ 200000 $$$ test case print a single integer : length shortest string zookeeper make first test case ca n't make move answer $$$ 3 $$$ second test case one optimal sequence move baba $$$ \to $$$ ba , answer $$$ 2 $$$ third test case one optimal sequence move <unknown> $$$ \to $$$ <unknown> $$$ \to $$$ aabbbb $$$ \to $$$ abbb $$$ \to $$$ ab $$$ \to $$$ ( empty string ) , answer $$$ 0 $$$","['data structures', 'greedy']",1100.0
1428/F,"zookeeper buy a carton fruit fee pet wabbit fruit a sequence apples oranges represent a binary string $$$ <unknown> s_n $$$ length $$$ n $$$ $$$ 1 $$$ represent apple $$$ 0 $$$ represent orange since wabbit allergic eat oranges zookeeper would like find longest contiguous sequence apples let $$$ f ( l r ) $$$ longest contiguous sequence apples substring $$$ s _ { l } s _ { l+1 } \ldots s _ { r } $$$ help zookeeper find $$$ \sum _ { l=1 } ^ { n } \sum _ { r = l } ^ { n } f ( l r ) $$$ sum $$$ f $$$ across substrings first line contain a single integer $$$ n $$$ $$$ ( 1 \leq n \leq 5 \cdot 100000 ) $$$ next line contain a binary string $$$ s $$$ length $$$ n $$$ $$$ ( s_i \in \ { 0,1\ } ) $$$ print a single integer : $$$ \sum _ { l=1 } ^ { n } \sum _ { r = l } ^ { n } f ( l r ) $$$ first test ten substrings list ( let $$$ [ l r ] $$$ substring $$$ s_l s _ { l+1 } \ldots s_r $$$ ) : lengths longest contiguous sequence ones ten substrings $$$ <unknown> $$$ respectively hence answer $$$ 0 + 1 + 2 + 2 + 1 + 2 + 2 + 1 + 1 + 0 = 12 $$$","['data structures', 'dp']",2400.0
1428/G1,"easy version problem difference version $$$ q=1 $$$ make hack versions problem solve zookeeper teach $$$ q $$$ sheep write add $$$ i $$$ -th sheep write exactly $$$ k $$$ non - negative integers sum $$$ n_i $$$ strangely sheep superstitions digits believe digits $$$ 3 $$$ $$$ 6 $$$ $$$ 9 $$$ lucky , fortune a number depend decimal representation number ; fortune a number equal sum fortunes digits fortune a digit depend value position describe follow table example number $$$ 319 $$$ fortune $$$ f _ { 2 } + 3f _ { 0 } $$$ sheep want maximize sum fortune among $$$ k $$$ write integers help ? first line contain a single integer $$$ k $$$ ( $$$ 1 \leq k \leq 999999 $$$ ) : number number sheep write next line contain six integers $$$ f_0 $$$ $$$ f_1 $$$ $$$ f_2 $$$ $$$ f_3 $$$ $$$ f_4 $$$ $$$ f_5 $$$ ( $$$ 1 \leq f_i \leq 1000000000 $$$ ) : fortune assign digit next line contain a single integer $$$ q $$$ ( $$$ q = 1 $$$ ) : number sheep next $$$ q $$$ line contain a single integer $$$ n_i $$$ ( $$$ 1 \leq n_i \leq 999999 $$$ ) : sum number $$$ i $$$ -th sheep write version one line print $$$ q $$$ line $$$ i $$$ -th line contain maximum sum fortune number $$$ i $$$ -th sheep version print one line first test case $$$ 57 = 9 + 9 + 39 $$$ three $$$ 9 $$$ 's contribute $$$ 3 $$$ $$$ 3 $$$ tens position contribute $$$ 2 $$$ hence sum fortune $$$ 11 $$$ second test case $$$ 63 = 35 + 19 + 9 $$$ sum fortune $$$ 8 $$$","['dp', 'greedy']",2900.0
1430/C,number $$$ 1 2 3 \dots n $$$ ( integer $$$ 1 $$$ $$$ n $$$ ) write a board one operation erase two number $$$ a $$$ $$$ b $$$ board write one integer $$$ \frac { a + b } { 2 } $$$ round instead perform give operation $$$ n - 1 $$$ time make result number leave board small possible example $$$ n = 4 $$$ follow course action optimal : 's easy see $$$ n - 1 $$$ operations leave one number goal minimize first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case line test case contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number integers write board initially 's guarantee total sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case first line print minimum possible number leave board $$$ n - 1 $$$ operations next $$$ n - 1 $$$ line contain two integers — number $$$ a $$$ $$$ b $$$ choose erase operation,"['data structures', 'greedy', 'implementation', 'math']",1000.0
1431/G,alice bob play a game a set initially consist $$$ n $$$ integers game play $$$ k $$$ turn turn follow events happen : initially score $$$ 0 $$$ alice want maximize result score bob want minimize assume alice bob play optimally calculate result score game first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 400 $$$ $$$ 1 \le k \le \lfloor\frac { n } { 2 } \rfloor $$$ ) — initial size set number turn game second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) — initial content set integers pairwise distinct print one integer — result score game ( assume alice bob play optimally ),"['dp', 'greedy']",2100.0
1431/H,marina play a new <unknown> - like game game $$$ n $$$ different character species $$$ m $$$ different class game play run ; run marina select a species a class character select $$$ i $$$ -th species $$$ j $$$ -th class get $$$ c _ { i j } $$$ point run initially species class unlock others lock unlock $$$ i $$$ -th species marina get least $$$ a_i $$$ point total previous run — soon total score play run least $$$ a_i $$$ species unlock similarly unlock $$$ j $$$ -th class get least $$$ b_j $$$ point total previous run $$$ a_i = 0 $$$ $$$ i $$$ species unlock initially ( apply class $$$ b_j = 0 $$$ ) marina want unlock species class minimum number run play game read exactly one guide combination species class read a guide increase score get run combination $$$ k $$$ ( formally play game increase exactly one value $$$ c _ { i j } $$$ $$$ k $$$ ) minimum number run play unlock species class choose combination read a guide optimally ? first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n m \le 1500 $$$ ; $$$ 0 \le k \le 1000000000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 0 = a_1 \le a_2 \le \dots \le a_n \le 10^ { 12 } $$$ ) $$$ a_i $$$ number point require unlock $$$ i $$$ -th species ( $$$ 0 $$$ unlock initially ) note $$$ a_1 = 0 $$$ value non - descending third line contain $$$ m $$$ integers $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_m $$$ ( $$$ 0 = b_1 \le b_2 \le \dots \le b_m \le 10^ { 12 } $$$ ) $$$ b_i $$$ number point require unlock $$$ i $$$ -th class ( $$$ 0 $$$ unlock initially ) note $$$ b_1 = 0 $$$ value non - descending $$$ n $$$ line follow contain $$$ m $$$ integers $$$ j $$$ -th integer $$$ i $$$ -th line $$$ c _ { i j } $$$ ( $$$ 1 \le c _ { i j } \le 1000000000 $$$ ) — score marina get a run $$$ i $$$ -th species $$$ j $$$ -th class print one integer — minimum number run marina play unlock species class read exactly one guide play game explanation first test : note way unlock everything one explanation second test : $$$ 1 $$$ -st example way unlock everything $$$ 2 $$$ run,['greedy'],2600.0
1437/A,get a job a marketer a pet shop current task boost sales cat food one strategies sell can food pack discount suppose decide sell pack $$$ a $$$ can a pack a discount customer want buy $$$ x $$$ can cat food follow a greedy strategy : $$$ \left\lfloor \frac { x } { a } \right\rfloor $$$ $$$ x $$$ divide $$$ a $$$ round $$$ x \bmod a $$$ <unknown> $$$ x $$$ divide $$$ a $$$ customers greedy general customer want buy $$$ ( x \bmod a ) $$$ can one one happen $$$ ( x \bmod a ) \ge \frac { a } { 2 } $$$ decide buy whole pack $$$ a $$$ can ( instead buy $$$ ( x \bmod a ) $$$ can ) make a marketer happy since customer buy want initially know customers come shop buy number can $$$ l $$$ $$$ r $$$ inclusive choose size pack $$$ a $$$ customer buy can want initially ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \le l \le r \le 1000000000 $$$ ) — range number can customers buy test case print yes choose size pack $$$ a $$$ customer buy can want initially otherwise print print character case first test case take example $$$ a = 5 $$$ size pack a customer want buy $$$ 3 $$$ can 'll buy $$$ 5 $$$ instead ( $$$ 3 \bmod 5 = 3 $$$ $$$ \frac { 5 } { 2 } = 2.5 $$$ ) one want $$$ 4 $$$ can also buy $$$ 5 $$$ can second test case way choose $$$ a $$$ third test case take example $$$ a = 80 $$$,"['greedy', 'math']",800.0
1438/A,andre specific taste recently start fall love array andre call nonempty array $$$ b $$$ good sum elements divisible length array example array $$$ [ 2 3 1 ] $$$ good sum elements — $$$ 6 $$$ — divisible $$$ 3 $$$ array $$$ [ 1 1 2 3 ] $$$ n't good $$$ 7 $$$ n't divisible $$$ 4 $$$ andre call array $$$ a $$$ length $$$ n $$$ perfect follow condition hold : give a positive integer $$$ n $$$ output perfect array length $$$ n $$$ show give constraints array always exist array $$$ c $$$ a subarray array $$$ d $$$ $$$ c $$$ obtain $$$ d $$$ deletion several ( possibly zero ) elements begin several ( possibly zero ) elements end test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line every test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) every test output perfect array length $$$ n $$$ a separate line array $$$ [ 19 33 ] $$$ perfect $$$ 3 $$$ subarrays : $$$ [ 19 ] $$$ $$$ [ 33 ] $$$ $$$ [ 19 33 ] $$$ sum divisible lengths therefore good,['implementation'],800.0
1438/D,ksenia array $$$ a $$$ consist $$$ n $$$ positive integers $$$ a_1 a_2 \ldots a_n $$$ one operation follow : want make $$$ a_i $$$ equal $$$ n $$$ operations determine impossible would n't ask help please help ! first line contain one integer $$$ n $$$ ( $$$ 3 \leq n \leq 100000 $$$ ) — length $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — elements $$$ a $$$ print yes first line depend whether possible make elements equal $$$ n $$$ operations possible print integer $$$ m $$$ ( $$$ 0 \leq m \leq n $$$ ) denote number operations next $$$ m $$$ line print three distinct integers $$$ i j k $$$ represent one operation many operation sequence possible print note minimize number operations first example array become $$$ [ 4 \oplus 1 \oplus 7 2 4 \oplus 1 \oplus 7 4 \oplus 1 \oplus 7 2 ] = [ 2 2 2 2 2 ] $$$,['math'],2200.0
1439/A1,"easy version problem difference versions number possible operations make make hack solve versions problem give a binary table size $$$ n \times m $$$ table consist symbols $$$ 0 $$$ $$$ 1 $$$ make operation : select $$$ 3 $$$ different cells belong one $$$ 2 \times 2 $$$ square change symbols cells ( change $$$ 0 $$$ $$$ 1 $$$ $$$ 1 $$$ $$$ 0 $$$ ) task make symbols table equal $$$ 0 $$$ allow make $$$ 3 nm $$$ operations n't need minimize number operations prove always possible first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 5000 $$$ ) — number test case next line contain descriptions test case first line description test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n m \leq 100 $$$ ) next $$$ n $$$ line contain a binary string length $$$ m $$$ describe symbols next row table guarantee sum $$$ nm $$$ test case exceed $$$ 20000 $$$ test case print integer $$$ k $$$ ( $$$ 0 \leq k \leq 3 nm $$$ ) — number operations next $$$ k $$$ line print $$$ 6 $$$ integers $$$ x_1 y_1 x_2 y_2 x_3 y_3 $$$ ( $$$ 1 \leq x_1 x_2 x_3 \leq n 1 \leq y_1 y_2 y_3 \leq m $$$ ) describe next operation operation make three cells $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ $$$ ( x_3 y_3 ) $$$ three cells different three cells belong $$$ 2 \times 2 $$$ square first test case possible make one operation cells $$$ ( 1 1 ) $$$ $$$ ( 2 1 ) $$$ $$$ ( 2 2 ) $$$ , symbols equal $$$ 0 $$$ second test case : fifth test case :",['implementation'],1500.0
1439/A2,"hard version problem difference versions number possible operations make make hack solve versions problem give a binary table size $$$ n \times m $$$ table consist symbols $$$ 0 $$$ $$$ 1 $$$ make operation : select $$$ 3 $$$ different cells belong one $$$ 2 \times 2 $$$ square change symbols cells ( change $$$ 0 $$$ $$$ 1 $$$ $$$ 1 $$$ $$$ 0 $$$ ) task make symbols table equal $$$ 0 $$$ allow make $$$ nm $$$ operations n't need minimize number operations prove always possible first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 5000 $$$ ) — number test case next line contain descriptions test case first line description test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n m \leq 100 $$$ ) next $$$ n $$$ line contain a binary string length $$$ m $$$ describe symbols next row table guarantee sum $$$ nm $$$ test case exceed $$$ 20000 $$$ test case print integer $$$ k $$$ ( $$$ 0 \leq k \leq nm $$$ ) — number operations next $$$ k $$$ line print $$$ 6 $$$ integers $$$ x_1 y_1 x_2 y_2 x_3 y_3 $$$ ( $$$ 1 \leq x_1 x_2 x_3 \leq n 1 \leq y_1 y_2 y_3 \leq m $$$ ) describe next operation operation make three cells $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ $$$ ( x_3 y_3 ) $$$ three cells different three cells belong $$$ 2 \times 2 $$$ square first test case possible make one operation cells $$$ ( 1 1 ) $$$ $$$ ( 2 1 ) $$$ $$$ ( 2 2 ) $$$ , symbols equal $$$ 0 $$$ second test case : fifth test case :","['greedy', 'implementation']",1900.0
1439/C,give array $$$ a_1 a_2 \ldots a_n $$$ integers array non - increasing let 's consider a line $$$ n $$$ shop shop number integers $$$ 1 $$$ $$$ n $$$ leave right cost a meal $$$ i $$$ -th shop equal $$$ a_i $$$ process $$$ q $$$ query two type : first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \leq n q \leq 200000 $$$ ) second line contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ $$$ ( 1 \leq a _ { i } \leq 1000000000 ) $$$ — cost meals guarantee $$$ a_1 \geq a_2 \geq \ldots \geq a_n $$$ next $$$ q $$$ line contain three integers $$$ t $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq t \leq 2 $$$ $$$ 1\leq x \leq n $$$ $$$ 1 \leq y \leq 1000000000 $$$ ) describe next query guarantee exist least one query type $$$ 2 $$$ query type $$$ 2 $$$ output answer new line first query a hungry man buy meals shop $$$ 3 $$$ $$$ 10 $$$ second query a hungry man buy meals shop $$$ 4 $$$ $$$ 9 $$$ $$$ 10 $$$ third query array $$$ a_1 a_2 \ldots a_n $$$ cost wo n't change $$$ \ { 10 10 10 6 6 5 5 5 3 1\ } $$$ fourth query a hungry man buy meals shop $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ $$$ 9 $$$ $$$ 10 $$$ fifth query array $$$ a $$$ cost $$$ \ { 10 10 10 7 6 5 5 5 3 1\ } $$$ sixth query a hungry man buy meals shop $$$ 2 $$$ $$$ 4 $$$,"['data structures', 'greedy', 'implementation']",2600.0
1445/A,give two array $$$ a $$$ $$$ b $$$ consist $$$ n $$$ positive integers integer $$$ x $$$ please determine one rearrange elements $$$ b $$$ $$$ a_i + b_i \leq x $$$ hold $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) first line input contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case $$$ t $$$ block follow describe individual test case first line test case contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \leq n \leq 50 $$$ ; $$$ 1 \leq x \leq 1000 $$$ ) — length array $$$ a $$$ $$$ b $$$ parameter $$$ x $$$ describe problem statement second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_1 \le a_2 \le \dots \le a_n \leq x $$$ ) — elements array $$$ a $$$ non - descending order third line test case contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1 \leq b_1 \le b_2 \le \dots \le b_n \leq x $$$ ) — elements array $$$ b $$$ non - descending order test case separate a blank line test case print yes one rearrange correspond array $$$ b $$$ $$$ a_i + b_i \leq x $$$ hold $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) otherwise character print case first test case one rearrange $$$ b $$$ 'll look like $$$ [ 1 2 1 ] $$$ case $$$ 1 + 1 \leq 4 $$$ ; $$$ 2 + 2 \leq 4 $$$ ; $$$ 3 + 1 \leq 4 $$$ second test case one set $$$ b $$$ $$$ [ 5 2 ] $$$ $$$ 1 + 5 \leq 6 $$$ ; $$$ 4 + 2 \leq 6 $$$ third test case matter one shuffle array $$$ b $$$ $$$ a_4 + b_4 = 4 + b_4 > 4 $$$ fourth test case one rearrangement array $$$ b $$$ n't satisfy condition since $$$ 5 + 5 > 5 $$$,['greedy'],800.0
1447/A,$$$ n $$$ bag candy initially $$$ i $$$ -th bag contain $$$ i $$$ candy want bag contain equal amount candy end achieve : choose $$$ m $$$ $$$ 1 \le m \le 1000 $$$ perform $$$ m $$$ operations $$$ j $$$ -th operation pick one bag add $$$ j $$$ candy bag apart choose one goal find a valid sequence operations bag contain equal amount candy prove give constraints a sequence always exist n't minimize $$$ m $$$ several valid sequence output test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 2 \le n\le 100 $$$ ) testcase print two line answer first line print $$$ m $$$ ( $$$ 1\le m \le 1000 $$$ ) — number operations want take second line print $$$ m $$$ positive integers $$$ a_1 a_2 \dots a_m $$$ ( $$$ 1 \le a_i \le n $$$ ) $$$ a_j $$$ number bag choose $$$ j $$$ -th operation first case add $$$ 1 $$$ candy bag except second one lead arrangement $$$ [ 2 2 ] $$$ candy second case firstly use first three operations add $$$ 1 + 2 + 3=6 $$$ candy total bag except third one give $$$ [ 7 8 3 ] $$$ later add $$$ 4 $$$ candy second third bag $$$ [ 7 12 7 ] $$$ $$$ 5 $$$ candy first third bag — result $$$ [ 12 12 12 ] $$$,['math'],800.0
145/E,petya love lucky number much everybody know lucky number positive integers whose decimal record contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 petya bring home string s length n. string consist lucky digits digits number leave right start 1 . petya execute m query follow form : subsequence a string s a string obtain s remove zero elements a string call non - decreasing successive digit less previous one help petya process request first line contain two integers n m ( 1 ≤ n ≤ 106 1 ≤ m ≤ 3·105 ) — length string s number query correspondingly second line contain n lucky digits without space — petya 's initial string next m line contain query form describe statement query count print answer a single line first sample chronology string s operations fulfil follow ( seek maximum subsequence mark bold ) :,['data structures'],2400.0
1450/C1,difference easy hard versions tokens type o appear input easy version errichto give monogon follow challenge order intimidate take top contributor spot codeforces a tic - tac - toe grid $$$ n $$$ row $$$ n $$$ columns cell grid either empty contain a token two type tokens : x o. exist three tokens type consecutive a row column a win configuration otherwise a draw configuration operation change x o o x. let $$$ k $$$ denote total number tokens grid task make grid a draw $$$ \lfloor \frac { k } { 3 } \rfloor $$$ ( round ) operations require minimize number operations first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 100 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1\le n\le 300 $$$ ) — size grid follow $$$ n $$$ line contain a string $$$ n $$$ character denote initial grid character $$$ i $$$ -th row $$$ j $$$ -th column ' . ' cell empty type token cell : ' x ' ' o ' guarantee cells empty easy version character ' o ' appear input sum $$$ n $$$ across test case exceed $$$ 300 $$$ test case print state grid apply operations proof a solution always exist multiple solutions print first test case initially three ' x ' consecutive second row second column change middle token ' o ' make grid a draw change $$$ 1\le \lfloor 5/3\rfloor $$$ token second test case change $$$ <unknown> \lfloor 32/3\rfloor $$$ tokens exist three ' x ' ' o ' consecutive a row column a draw third test case change $$$ 3\le \lfloor <unknown> $$$ tokens result grid a draw,['math'],2100.0
1450/H1,difference two versions problem update easy version $$$ n $$$ spool thread place rim a circular table spool come two type thread : first thread black second thread white two spool color attach a thread color a straight line segment define a match a way attach spool together spool attach exactly one spool color assignment color ( white black ) spool a color call valid least one match number black spool number white spool even give a match find number time white thread intersect black thread compute number pair differently color thread intersect instead number intersection point one intersection point may count multiple time different pair thread intersect point $$$ c $$$ a valid color let $$$ f ( c ) $$$ denote minimum number intersections possible match give a string $$$ s $$$ represent unfinished color black white uncolored spool a color $$$ c $$$ call $$$ s $$$ -reachable achieve assign color uncolored spool $$$ s $$$ without change others a color $$$ c $$$ choose uniformly random among valid $$$ s $$$ -reachable color compute expect value $$$ f ( c ) $$$ find modulo $$$ 998244353 $$$ show answer write form $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ relatively prime integers $$$ q\not\equiv 0\pmod { 998244353 } $$$ answer modulo $$$ 998244353 $$$ equal $$$ ( p\cdot q^ { -1 } ) $$$ modulo $$$ 998244353 $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2\le n\le 2\cdot 100000 $$$ $$$ n $$$ even $$$ m=0 $$$ ) — number spool update respectively update easy version always $$$ 0 $$$ second line contain a string $$$ s $$$ length $$$ n $$$ — unfinished color spool $$$ i $$$ -th character ' w ' ' b ' ' ? ' describe $$$ i $$$ -th spool white black uncolored respectively guarantee exist least one uncolored spool print expect value $$$ f ( c ) $$$ modulo $$$ 998244353 $$$ first test correspond closely image color ' ? ' ' w ' create a valid color number black spool odd reachable valid color ' bwbbbwww ' $$$ f ( \text { bwbbbwww } ) = 1 $$$ expect value $$$ 1 $$$ show expect value second test $$$ \frac { 9 } { 16 } $$$,['math'],2900.0
1450/H2,difference two versions problem update easy version $$$ n $$$ spool thread place rim a circular table spool come two type thread : first thread black second thread white two spool color attach a thread color a straight line segment define a match a way attach spool together spool attach exactly one spool color assignment color ( white black ) spool a color call valid least one match number black spool number white spool even give a match find number time white thread intersect black thread compute number pair differently color thread intersect instead number intersection point one intersection point may count multiple time different pair thread intersect point $$$ c $$$ a valid color let $$$ f ( c ) $$$ denote minimum number intersections possible match give a string $$$ s $$$ represent unfinished color black white uncolored spool a color $$$ c $$$ call $$$ s $$$ -reachable achieve assign color uncolored spool $$$ s $$$ without change others a color $$$ c $$$ choose uniformly random among valid $$$ s $$$ -reachable color compute expect value $$$ f ( c ) $$$ find modulo $$$ 998244353 $$$ $$$ m $$$ update change one character $$$ s $$$ update compute expect value $$$ f ( c ) $$$ show answer write form $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ relatively prime integers $$$ q\not\equiv 0\pmod { 998244353 } $$$ answer modulo $$$ 998244353 $$$ equal $$$ ( p\cdot q^ { -1 } ) $$$ modulo $$$ 998244353 $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2\le n\le 2\cdot 100000 $$$ $$$ n $$$ even $$$ 0\le m\le 2\cdot 100000 $$$ ) — number spool number update respectively second line contain a string $$$ s $$$ length $$$ n $$$ — unfinished color spool $$$ i $$$ -th character ' w ' ' b ' ' ? ' describe $$$ i $$$ -th spool white black uncolored respectively next $$$ m $$$ line contain integer $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) — position character $$$ s $$$ update a character $$$ c $$$ ( $$$ c \in \ { \text { w } \text { b } \text { ? } \ } $$$ ) — new color spool $$$ i $$$ update guarantee exist least one uncolored spool initially update print $$$ m+1 $$$ line : expect value $$$ f ( c ) $$$ initially update value find modulo $$$ 998244353 $$$ first test correspond closely image color ' ? ' ' w ' create a valid color number black spool odd reachable valid color ' bwbbbwww ' $$$ f ( \text { bwbbbwww } ) = 1 $$$ expect value $$$ 1 $$$ second test string update : third test string update :,"['implementation', 'math']",3300.0
1453/A,"gildong 's town a train system $$$ 100 $$$ train travel bottom end top end $$$ 100 $$$ train travel leave end right end train start side number $$$ 1 $$$ $$$ 100 $$$ respectively train speed let 's take a look picture train system represent coordinate a 2d plane $$$ i $$$ -th train start bottom end initially $$$ ( i,0 ) $$$ $$$ ( i t ) $$$ $$$ t $$$ minutes $$$ i $$$ -th train start leave end initially $$$ ( 0 i ) $$$ $$$ ( t i ) $$$ $$$ t $$$ minutes train arrive destinations $$$ 101 $$$ minutes however gildong find train schedule depart a specific time simultaneously dangerous time $$$ n $$$ train schedule depart bottom end $$$ m $$$ train schedule depart leave end two train $$$ ( x y ) $$$ time $$$ x $$$ $$$ y $$$ crash therefore ask find minimum number train cancel prevent crash test contain one test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) test case contain three line first line test case consist two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100 $$$ ) — number train schedule depart bottom end number train schedule depart leave end respectively second line test case contain $$$ n $$$ integers integer a train number schedule start bottom end number give strictly increase order $$$ 1 $$$ $$$ 100 $$$ inclusive third line test case contain $$$ m $$$ integers integer a train number schedule start leave end number give strictly increase order $$$ 1 $$$ $$$ 100 $$$ inclusive test case print a single integer : minimum number train cancel order prevent crash first case show crash current schedule follow therefore answer zero second case $$$ <unknown> $$$ a crash see picture prove cancel one train remain train crash therefore answer one",['implementation'],800.0
1455/C,alice bob play ping - <unknown> simplify rule game player serve ball commence a play server strike ball receiver make a return hit ball back thereafter server receiver must alternately make a return one n't make a return one n't make a return lose play winner play commence next play alice start first play alice $$$ x $$$ stamina bob $$$ y $$$ hit ball ( serve return ) player spend $$$ 1 $$$ stamina n't stamina ca n't return ball ( lose play ) ca n't serve ball ( case player serve ball instead ) players run stamina game sometimes 's strategically optimal return ball lose current play save stamina contrary server commence a play hit ball stamina leave alice bob play optimally want firstly maximize number win secondly minimize number win opponent calculate result number alice 's bob 's win first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le 1000000 $$$ ) — alice 's bob 's initial stamina test case print two integers — result number alice 's bob 's win play optimally first test case alice serve ball spend $$$ 1 $$$ stamina bob return ball also spend $$$ 1 $$$ stamina alice ca n't return ball since stamina leave lose play run stamina game $$$ 0 $$$ alice 's win $$$ 1 $$$ bob 's win second test case alice serve ball spend $$$ 1 $$$ stamina bob decide return ball — lose play save stamina alice winner last play serve ball next play spend $$$ 1 $$$ stamina time bob return ball spend $$$ 1 $$$ stamina alice n't stamina leave ca n't return ball lose play run stamina game $$$ 1 $$$ alice 's $$$ 1 $$$ bob 's win third test case alice serve ball spend $$$ 1 $$$ stamina bob return ball spend $$$ 1 $$$ stamina alice run stamina ca n't return ball lose play bob a winner serve ball next $$$ 6 $$$ play time alice ca n't return ball lose play game $$$ 0 $$$ alice 's $$$ 7 $$$ bob 's win,['math'],1100.0
1458/B,"$$$ n $$$ glass table number $$$ 1 \ldots n $$$ glass $$$ i $$$ hold $$$ a_i $$$ units water currently contain $$$ b_i $$$ units water would like choose $$$ k $$$ glass collect much water possible effect pour water one glass another many time like however glass ' awkward shape ( totally <unknown> natural <unknown> ) time try transfer amount water half amount spill floor formally suppose a glass $$$ i $$$ currently contain $$$ c_i $$$ units water a glass $$$ j $$$ contain $$$ c_j $$$ units water suppose try transfer $$$ x $$$ units glass $$$ i $$$ glass $$$ j $$$ ( naturally $$$ x $$$ exceed $$$ c_i $$$ ) , $$$ x / 2 $$$ units spill floor transfer do glass $$$ i $$$ contain $$$ c_i - x $$$ units glass $$$ j $$$ contain $$$ \min ( a_j c_j + x / 2 ) $$$ units ( excess water n't fit glass also spill ) time transfer water <unknown> choose glass $$$ i $$$ glass $$$ j $$$ pour also amount $$$ x $$$ transfer positive real number $$$ k = 1 \ldots n $$$ determine largest possible total amount water collect arbitrarily choose $$$ k $$$ glass transfer water glass zero time first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) — number glass follow $$$ n $$$ line describe glass $$$ i $$$ -th line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 0 \leq b_i \leq a_i \leq 100 $$$ $$$ a_i > 0 $$$ ) — capacity water amount currently contain glass $$$ i $$$ respectively print $$$ n $$$ real number — largest amount water collect $$$ 1 \ldots n $$$ glass respectively answer accept number within $$$ 10^ { -9 } $$$ absolute relative tolerance precise answer sample case act follow :",['dp'],2000.0
146/A,petya love lucky number much everybody know lucky number positive integers whose decimal record contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 petya love ticket much know ticket a number a positive integer length equal n ( n always even ) petya call a ticket lucky ticket 's number a lucky number sum digits first half ( sum first n / 2 digits ) equal sum digits second half ( sum last n / 2 digits ) check give ticket lucky first line contain even integer n ( 2 ≤ n ≤ 50 ) — length ticket number need check second line contain integer whose length equal exactly n — ticket number number may contain lead zero first line print ` ` yes '' give ticket number lucky otherwise print ` ` '' ( without quote ) first sample sum digits first half equal sum digits second half ( 4 ≠ 7 ) second sample ticket number lucky number,['implementation'],800.0
1461/A,"one fall day joe get bore could n't find something interest <unknown> suggest joe generate a string length $$$ n $$$ entertain somehow n't seem particularly difficult joe 's generate string follow rule : a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end example string ` ` a '' ` ` bc '' ` ` abc '' substrings a string ` ` abc '' string ` ` ac '' ` ` ba '' ` ` cba '' a string a palindrome read leave right right leave example string ` ` abccba '' ` ` <unknown> '' ` ` aba '' ` ` abacaba '' ` ` a '' ` ` bacab '' palindromes string ` ` <unknown> '' ` ` abb '' ` ` ab '' joe want find correct string help ! prove answer always exist give constraints test contain one test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 1\,000 $$$ ) — require string length maximum length a palindrome substring respectively test case print string satisfy condition problem statement multiple correct answer print one prove answer always exist give constraints first test case example palindrome substring maximum length ` ` aa '' length exceed $$$ 2 $$$ fit second test case palindrome substrings length one",['greedy'],800.0
1461/C,"ron a happy owner a permutation $$$ a $$$ length $$$ n $$$ a permutation length $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) ron 's permutation subject $$$ m $$$ experiment follow type : ( $$$ r_i $$$ $$$ p_i $$$ ) mean elements range $$$ [ 1 r_i ] $$$ ( word prefix length $$$ r_i $$$ ) sort ascend order probability $$$ p_i $$$ experiment perform order specify input data example let 's take a look a permutation $$$ [ 4 2 1 5 3 ] $$$ experiment ( $$$ 3 0.6 $$$ ) experiment probability $$$ <unknown> % $$$ permutation assume form $$$ [ 1 2 4 5 3 ] $$$ a $$$ <unknown> % $$$ probability remain unchanged determine probability permutation become completely sort ascend order $$$ m $$$ experiment test contain one test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) first line test case contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 1 \le n m \le 100000 ) $$$ — length permutation number experiment respectively second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 1 \le a_i \le n ) $$$ — content permutation follow $$$ m $$$ line test case contain integer $$$ r_i $$$ a real number $$$ p_i $$$ $$$ ( 1 \le r_i \le n 0 \le p_i \le 1 ) $$$ — length prefix probability sort probabilities give $$$ 6 $$$ decimal place guarantee sum $$$ n $$$ sum $$$ m $$$ exceed $$$ 100000 $$$ ( $$$ \sum n \sum m \le 100000 $$$ ) test case print a single number — probability experiment permutation become sort ascend order answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -6 } $$$ explanation first test case : demonstrate whether final permutation sort depend solely sort perform $$$ ( 4 0.6 ) $$$ experiment","['dp', 'math']",1500.0
1461/D,mike receive array $$$ a $$$ length $$$ n $$$ a birthday present decide test pretty array would pass $$$ i $$$ -th prettiness test a way get array a sum elements total $$$ s_i $$$ use number ( possibly zero ) slice operations array slice operation conduct follow way : need help mike find result $$$ q $$$ prettiness test note test prettiness array $$$ a $$$ start prettiness test <unknown> ( initial ) array $$$ a $$$ thus first slice ( require ) always perform array $$$ a $$$ test contain one test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) first line test case contain two integers $$$ n $$$ $$$ q $$$ $$$ ( 1 \le n q \le 100000 ) $$$ — length array $$$ a $$$ total number prettiness test second line test case contain $$$ n $$$ integers $$$ a_1 a_2 ... a_n $$$ $$$ ( 1 \le a_i \le 1000000 ) $$$ — content array $$$ a $$$ next $$$ q $$$ line test case contain a single integer $$$ s_i $$$ $$$ ( 1 \le s_i \le 1000000000 ) $$$ — sum elements mike want get $$$ i $$$ -th test guarantee sum $$$ n $$$ sum $$$ q $$$ exceed $$$ 100000 $$$ ( $$$ \sum n \sum q \le 100000 $$$ ) print $$$ q $$$ line contain either a ` ` yes '' correspond prettiness test pass ` ` '' opposite case explanation first test case : 1.1 $$$ a = [ 1 2 3 4 5 ] $$$ $$$ mid = \frac { 1 + 5 } { 2 } = 3 $$$ $$$ \mathit { leave } = [ 1 2 3 ] $$$ $$$ right = [ 4 5 ] $$$ choose keep $$$ \mathit { leave } $$$ array 1.2 $$$ a = [ 1 2 3 ] $$$ $$$ mid = \frac { 1 + 3 } { 2 } = 2 $$$ $$$ \mathit { leave } = [ 1 2 ] $$$ $$$ right = [ 3 ] $$$ choose keep $$$ \mathit { leave } $$$ array 1.3 $$$ a = [ 1 2 ] $$$ $$$ mid = \frac { 1 + 2 } { 2 } = 1 $$$ $$$ \mathit { leave } = [ 1 ] $$$ $$$ right = [ 2 ] $$$ choose keep $$$ \mathit { leave } $$$ array sum equal $$$ 1 $$$ <unknown> $$$ a = [ 1 2 3 4 5 ] $$$ $$$ mid = \frac { 1 + 5 } { 2 } = 3 $$$ $$$ \mathit { leave } = [ 1 2 3 ] $$$ $$$ right = [ 4 5 ] $$$ choose keep $$$ right $$$ array sum equal $$$ 9 $$$ <unknown> $$$ a = [ 1 2 3 4 5 ] $$$ $$$ mid = \frac { 1 + 5 } { 2 } = 3 $$$ $$$ \mathit { leave } = [ 1 2 3 ] $$$ $$$ right = [ 4 5 ] $$$ choose keep $$$ \mathit { leave } $$$ sum equal $$$ 6 $$$ explanation second test case : <unknown> $$$ a = [ 3 1 3 1 3 ] $$$ $$$ mid = \frac { 1 + 3 } { 2 } = 2 $$$ $$$ \mathit { leave } = [ 1 1 ] $$$ $$$ right = [ 3 3 3 ] $$$ choose keep $$$ \mathit { leave } $$$ array sum equal $$$ 2 $$$ <unknown> $$$ a = [ 3 1 3 1 3 ] $$$ $$$ mid = \frac { 1 + 3 } { 2 } = 2 $$$ $$$ \mathit { leave } = [ 1 1 ] $$$ $$$ right = [ 3 3 3 ] $$$ choose keep $$$ right $$$ array sum equal $$$ 9 $$$,"['data structures', 'implementation']",1600.0
1462/B,polycarp a string $$$ s [ 1 \dots n ] $$$ length $$$ n $$$ consist decimal digits polycarp perform follow operation string $$$ s $$$ ( i.e perform operation $$$ 0 $$$ $$$ 1 $$$ time ) : example string $$$ s = $$$ ` ` <unknown> '' polycarp turn string : polycarp like string ` ` 2020 '' much wonder possible turn string $$$ s $$$ a string ` ` 2020 '' one operation ? note perform zero operations first line contain a positive integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case test $$$ t $$$ test case follow first line test case contain integer $$$ n $$$ ( $$$ 4 \leq n \leq 200 $$$ ) — length string $$$ s $$$ next line contain a string $$$ s $$$ length $$$ n $$$ consist decimal digits allow string $$$ s $$$ start digit 0 . test case output a separate line : may print every letter ` ` yes '' ` ` '' case want ( example string yes yes yes yes recognize positive answer ) first test case polycarp could choose $$$ i=3 $$$ $$$ <unknown> $$$ second test case polycarp could choose $$$ i=2 $$$ $$$ j=5 $$$ third test case polycarp perform operations string,"['dp', 'implementation']",800.0
1462/C,give a positive number $$$ x $$$ find smallest positive integer number sum digits equal $$$ x $$$ digits distinct ( unique ) first line contain a single positive integer $$$ t $$$ ( $$$ 1 \le t \le 50 $$$ ) — number test case test $$$ t $$$ test case follow test case consist a single integer number $$$ x $$$ ( $$$ 1 \le x \le 50 $$$ ) output $$$ t $$$ answer test case :,"['greedy', 'math']",900.0
1463/A,play a new computer game fight monsters a dungeon try clear meet three monsters ; first $$$ a $$$ health point second $$$ b $$$ health point third $$$ c $$$ kill monsters use a cannon fire deal $$$ 1 $$$ damage select monster every $$$ 7 $$$ -th ( i. e. shots number $$$ 7 $$$ $$$ 14 $$$ $$$ 21 $$$ etc . ) cannon shoot enhance deal $$$ 1 $$$ damage monsters one monster 's current amount health point $$$ 0 $$$ ca n't target a regular shoot receive damage enhance shoot want pass dungeon beautifully i. e. kill monsters enhance shoot ( i. e. enhance shoot health point monsters become equal $$$ 0 $$$ first time ) shoot must hit a monster i. e. shoot deal damage least one monster first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist a single line contain three integers $$$ a $$$ $$$ b $$$ $$$ c $$$ ( $$$ 1 \le a b c \le 100000000 $$$ ) — number health point monster test case print yes kill monsters enhance shoot otherwise print may print letter case ( example yes yes yes yes recognize positive answer ) first test case follow : $$$ 1 $$$ -th shoot first monster $$$ 2 $$$ -th shoot second monster $$$ 3 $$$ -th shoot third monster $$$ 4 $$$ -th shoot first monster $$$ 5 $$$ -th shoot third monster $$$ 6 $$$ -th shoot third monster $$$ 7 $$$ -th enhance shoot kill monsters second test case ca n't kill monsters enhance shoot total number health point monsters $$$ 3 $$$ kill first 3 shots,['math'],1100.0
1463/C,"a robot move along a number line time moment $$$ 0 $$$ stand point $$$ 0 $$$ give $$$ n $$$ command robot : time $$$ t_i $$$ second command robot go point $$$ x_i $$$ whenever robot receive a command start move towards point $$$ x_i $$$ speed $$$ 1 $$$ unit per second stop reach point however robot move ignore command give example suppose give three command robot : time $$$ 1 $$$ move point $$$ 5 $$$ time $$$ 3 $$$ move point $$$ 0 $$$ time $$$ 6 $$$ move point $$$ 4 $$$ robot stand $$$ 0 $$$ time $$$ 1 $$$ start move towards $$$ 5 $$$ ignore second command reach $$$ 5 $$$ time $$$ 6 $$$ immediately start move $$$ 4 $$$ execute third command time $$$ 7 $$$ reach $$$ 4 $$$ stop call command $$$ i $$$ successful a time moment range $$$ [ t_i t _ { i + 1 } ] $$$ ( i. e. give command give another one bound inclusive ; consider $$$ t _ { n + 1 } = + \infty $$$ ) robot point $$$ x_i $$$ count number successful command note possible ignore command successful first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next line describe test case first line a test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number command next $$$ n $$$ line describe command $$$ i $$$ -th line contain two integers $$$ t_i $$$ $$$ x_i $$$ ( $$$ 1 \le t_i \le 1000000000 $$$ $$$ -1000000000 \le x_i \le 1000000000 $$$ ) — time point $$$ i $$$ -th command command order time , $$$ t_i < t _ { i + 1 } $$$ possible $$$ i $$$ sum $$$ n $$$ test case exceed $$$ 100000 $$$ testcase output a single integer — number successful command movements robot first test case describe problem statement last command successful second test case second command successful : robot pass target point $$$ 4 $$$ time $$$ 5 $$$ also last command eventually successful third test case command successful robot stop $$$ -5 $$$ time moment $$$ 7 $$$ $$$ 0 $$$ -indexed sequence position robot second testcase example cut position equal last one :",['implementation'],1800.0
1464/F,give a tree consider simple paths let 's denote path vertices $$$ a $$$ $$$ b $$$ $$$ ( a b ) $$$ let $$$ d $$$ -neighborhood a path a set vertices tree locate a distance $$$ \leq d $$$ least one vertex path ( example $$$ 0 $$$ -neighborhood a path a path ) let $$$ p $$$ a multiset tree paths initially empty ask maintain follow query : first line contain two integers $$$ n $$$ $$$ q $$$ — number vertices tree number query accordingly ( $$$ 1 \leq n \leq 200000 $$$ $$$ 2 \leq q \leq 200000 $$$ ) follow $$$ n - 1 $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ — indices vertices connect $$$ i $$$ -th edge ( $$$ 1 \le x_i y_i \le n $$$ ) follow $$$ q $$$ line contain query format describe statement 's guarantee : query third type output answer a new line,['data structures'],3500.0
1467/A,"$$$ n $$$ digital panel place a straight line panel show digit $$$ 0 $$$ $$$ 9 $$$ initially panel show $$$ 0 $$$ every second digit show panel increase $$$ 1 $$$ word end every second a panel show $$$ 9 $$$ would show $$$ 0 $$$ a panel show $$$ 0 $$$ would show $$$ 1 $$$ a panel show $$$ 1 $$$ would show $$$ 2 $$$ , a panel pause digit display panel change subsequent second must pause exactly one panel second wish , panel adjacent get pause one second later panel adjacent get pause $$$ 2 $$$ second later , word pause panel $$$ x $$$ panel $$$ y $$$ ( valid $$$ y $$$ ) would pause exactly $$$ <unknown> $$$ second later example suppose $$$ 4 $$$ panel $$$ 3 $$$ -rd panel pause digit $$$ 9 $$$ result $$$ 4 $$$ -digit number $$$ <unknown> $$$ note example optimal $$$ n = 4 $$$ panel pause write digits display leave right form $$$ n $$$ digit number ( consist lead zero ) largest possible number get ? initially panel show $$$ 0 $$$ first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case test case consist a single line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 2\cdot100000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ test case print largest number achieve pause one panel optimally first test case optimal pause first panel number $$$ 9 $$$ display second test case optimal pause second panel number $$$ 8 $$$ display","['greedy', 'math']",900.0
1467/C,"give three bag bag contain a non - empty multiset number perform a number operations bag one operation choose two non - empty bag choose one number bag let 's say choose number $$$ a $$$ first bag number $$$ b $$$ second bag , remove $$$ b $$$ second bag replace $$$ a $$$ $$$ a - b $$$ first bag note multiple occurrences number shall remove / replace exactly one occurrence perform operations a way exactly one number remain exactly one bag ( two bag empty ) show always apply operations receive a configuration end among configurations find one maximum number leave end first line input contain three space - separated integers $$$ n_1 $$$ $$$ n_2 $$$ $$$ n_3 $$$ ( $$$ 1 \le n_1 n_2 n_3 \le 3\cdot100000 $$$ $$$ 1 \le <unknown> \le 3\cdot100000 $$$ ) — number number three bag $$$ i $$$ -th next three line contain $$$ n_i $$$ space - separated integers $$$ a _ { { i,1 } } $$$ $$$ a _ { { i,2 } } $$$ ... $$$ a _ { { i { { n_i } } } } $$$ ( $$$ 1 \le a _ { { i j } } \le 1000000000 $$$ ) — number $$$ i $$$ -th bag print a single integer — maximum number achieve end first example input let us perform follow operations : $$$ [ 1 2 ] [ 6 3 4 5 ] [ 5 ] $$$ $$$ [ -5 2 ] [ 3 4 5 ] [ 5 ] $$$ ( apply operation $$$ ( 1 6 ) $$$ ) $$$ [ -10 2 ] [ 3 4 ] [ 5 ] $$$ ( apply operation $$$ ( -5 5 ) $$$ ) $$$ [ 2 ] [ 3 4 ] [ 15 ] $$$ ( apply operation $$$ ( 5 -10 ) $$$ ) $$$ [ -1 ] [ 4 ] [ 15 ] $$$ ( apply operation $$$ ( 2 3 ) $$$ ) $$$ [ -5 ] [ ] [ 15 ] $$$ ( apply operation $$$ ( -1 4 ) $$$ ) $$$ [ ] [ ] [ 20 ] $$$ ( apply operation $$$ ( 15 -5 ) $$$ ) verify achieve a bigger number hence answer $$$ 20 $$$",['greedy'],1900.0
1468/A,let 's call a sequence $$$ b_1 b_2 b_3 \dots b _ { k - 1 } b_k $$$ almost increase $$$ $$$ \min ( b_1 b_2 ) \le \min ( b_2 b_3 ) \le \dots \le \min ( b _ { k - 1 } b_k ) $$$ $$$ particular sequence two elements almost increase give a sequence integers $$$ a_1 a_2 \dots a_n $$$ calculate length longest almost increase subsequence 'll give $$$ t $$$ test case solve test case independently reminder : a subsequence a sequence derive another sequence delete elements without change order remain elements first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number independent test case first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 500000 $$$ ) — length sequence $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — sequence 's guarantee total sum $$$ n $$$ test case n't exceed $$$ 500000 $$$ test case print one integer — length longest almost increase subsequence first test case one optimal answer subsequence $$$ 1 2 7 2 2 3 $$$ second third test case whole sequence $$$ a $$$ already almost increase,"['data structures', 'dp', 'greedy']",2200.0
1468/K,"a robot a checker field endless directions initially robot locate cell coordinate $$$ ( 0 0 ) $$$ execute command describe a string capital latin letter ' l ' ' r ' 'd ' ' u ' a command execute robot simply move correspond direction : task put obstacle one cell field execute command robot return original cell path $$$ ( 0 0 ) $$$ course obstacle place start cell $$$ ( 0 0 ) $$$ guarantee obstacle place robot return start cell obstacle affect movement robot follow way : try go a certain direction obstacle simply remain place ( obstacle also remain , disappear ) find cell field ( $$$ ( 0 0 ) $$$ ) put obstacle robot return cell $$$ ( 0 0 ) $$$ execution command solution report first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case test case consist a single line contain $$$ s $$$ — sequence command uppercase latin letter ' l ' ' r ' 'd ' ' u ' length $$$ s $$$ $$$ 1 $$$ $$$ 5000 $$$ inclusive additional constraint $$$ s $$$ : execute sequence command lead robot cell $$$ ( 0 0 ) $$$ obstacles sum lengths $$$ s $$$ a test n't exceed $$$ 5000 $$$ test case print a single line : multiple answer print",['implementation'],1600.0
1468/N,progress stand still berland recently garbage containers bertown capital berland replace differentiate recycle bin accept category waste definitely improve ecological situation citizens 's difficult get use habit sort waste monocarp one citizens try get use waste sort today take trash house three containers near monocarp 's house first one accept paper waste second one accept plastic waste third one — type waste possible fit $$$ c_1 $$$ items first container $$$ c_2 $$$ items second container $$$ c_3 $$$ items third container monocarp a lot items throw containers make paper monocarp put first container ( $$$ a_1 $$$ items ) make plastic put second container ( $$$ a_2 $$$ items ) neither paper plastic — monocarp put third container ( $$$ a_3 $$$ items ) unfortunately also two categories items monocarp unsure : $$$ a_4 $$$ items partially make paper put items either first container third container similarly $$$ a_5 $$$ items partially make plastic put either second container third container obviously choice make separately item — example monocarp throw several partially - plastic items second container partially - plastic items — third one monocarp wonder : possible put item container first container hold $$$ c_1 $$$ items second one — $$$ c_2 $$$ items third one — $$$ c_3 $$$ items ? first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 30000 $$$ ) — number test case test case consist two line first line test case contain three integers $$$ c_1 $$$ $$$ c_2 $$$ $$$ c_3 $$$ ( $$$ 0 \le c_1 c_2 c_3 \le 100000000 $$$ ) — capacities containers second line test case contain five integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ a_3 $$$ $$$ a_4 $$$ $$$ a_5 $$$ ( $$$ 0 \le a_i \le 100000000 $$$ ) $$$ a_i $$$ number items $$$ i $$$ -th category monocarp throw ( $$$ i = 1 $$$ paper waste $$$ i = 2 $$$ plastic waste $$$ i = 3 $$$ general waste $$$ i = 4 $$$ partially - paper waste $$$ i = 5 $$$ partially - plastic waste ) test case print either yes possible fit items containers otherwise may print letter case ( example yes yes yes yes recognize positive answer ) explanations example test case :,"['greedy', 'implementation']",900.0
1469/D,array $$$ a_1 a_2 \dots a_n $$$ $$$ a_i = i $$$ one step choose two indices $$$ x $$$ $$$ y $$$ ( $$$ x \neq y $$$ ) set $$$ a_x = \left\lceil \frac { a_x } { a_y } \right\rceil $$$ ( ceiling function ) goal make array $$$ a $$$ consist $$$ n - 1 $$$ ones $$$ 1 $$$ two $$$ n + 5 $$$ step note n't minimize number step first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain single integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) — length array $$$ a $$$ 's guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print sequence operations make $$$ a $$$ $$$ n - 1 $$$ ones $$$ 1 $$$ two follow format : firstly print one integer $$$ m $$$ ( $$$ m \le n + 5 $$$ ) — number operations ; next print $$$ m $$$ pair integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ ; $$$ x \neq y $$$ ) ( $$$ x $$$ may greater less $$$ y $$$ ) — indices correspond operation prove give constraints 's always possible find a correct sequence operations first test case array $$$ a = [ 1 2 3 ] $$$ example follow : second test case $$$ a = [ 1 2 3 4 ] $$$ example follow :,['math'],1700.0
147/A,give a text consist lowercase latin letter space punctuation mark ( dot comma exclamation mark question mark ) a word define a sequence consecutive latin letter task add space text follow rule : guarantee least one word two punctuation mark text begin end a latin letter input data contain a single non - empty line — text whose length 10000 character print text edit accord rule problem follow output format strictly example extra space end output line consider wrong answer note a newline character end line n't matter,['implementation'],1300.0
1472/E,"polycarp invite $$$ n $$$ friends celebrate new year celebration decide take a group photo friends friend stand lie side friend characterize two value $$$ h_i $$$ ( height ) $$$ w_i $$$ ( width ) photo $$$ i $$$ -th friend occupy a rectangle $$$ h_i \times w_i $$$ ( stand ) $$$ w_i \times h_i $$$ ( lie side ) $$$ j $$$ -th friend place front $$$ i $$$ -th friend photo rectangle lower <unknown> rectangle $$$ i $$$ -th friend formally least one follow condition must fulfil : example $$$ n = 3 $$$ $$$ h= [ 3,5,3 ] $$$ $$$ <unknown> [ <unknown> ] $$$ : case person <unknown> overlap person background help polycarp $$$ i $$$ find $$$ j $$$ $$$ j $$$ -th friend locate front $$$ i $$$ -th friend ( i.e least one condition fulfil ) please note need find arrangement people a group photo need find friend $$$ i $$$ friend $$$ j $$$ locate front think need solve $$$ n $$$ separate independent subproblems first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — number friends follow $$$ n $$$ line contain a description correspond friend friend describe two integers $$$ h_i $$$ $$$ w_i $$$ ( $$$ 1 \leq h_i w_i \leq 1000000000 $$$ ) — height width $$$ i $$$ -th friend respectively guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output $$$ n $$$ integers a separate line $$$ i $$$ -th number index a friend place front $$$ i $$$ -th friend output -1 . several answer output first test case describe statement third test case follow answer also correct :","['data structures', 'dp']",1700.0
1473/C,a sequence $$$ a $$$ $$$ n $$$ elements $$$ 1 2 3 \dots k - 1 k k - 1 k - 2 \dots k - ( n - k ) $$$ ( $$$ k \le n < 2k $$$ ) let 's call inversion $$$ a $$$ a pair indices $$$ i < j $$$ $$$ a [ i ] > a [ j ] $$$ suppose permutation $$$ p $$$ size $$$ k $$$ build a sequence $$$ b $$$ size $$$ n $$$ follow manner : $$$ b [ i ] = p [ a [ i ] ] $$$ goal find permutation $$$ p $$$ total number inversions $$$ b $$$ n't exceed total number inversions $$$ a $$$ $$$ b $$$ lexicographically maximum small reminder : sequence $$$ k $$$ integers call a permutation contain integers $$$ 1 $$$ $$$ k $$$ exactly another small reminder : a sequence $$$ s $$$ lexicographically smaller another sequence $$$ t $$$ either $$$ s $$$ a prefix $$$ t $$$ first $$$ i $$$ $$$ s_i \ne t_i $$$ $$$ s_i < t_i $$$ hold ( first position sequence different $$$ s $$$ smaller number $$$ t $$$ ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ k \le n < 2k $$$ ; $$$ 1 \le k \le 100000 $$$ ) — length sequence $$$ a $$$ maximum 's guarantee total sum $$$ k $$$ test case n't exceed $$$ 100000 $$$ test case print $$$ k $$$ integers — permutation $$$ p $$$ maximize $$$ b $$$ lexicographically without increase total number inversions prove $$$ p $$$ exist unique first test case sequence $$$ a = [ 1 ] $$$ one permutation $$$ p = [ 1 ] $$$ second test case sequence $$$ a = [ 1 2 ] $$$ inversion $$$ a $$$ one permutation $$$ p = [ 1 2 ] $$$ n't increase number inversions third test case $$$ a = [ 1 2 1 ] $$$ $$$ 1 $$$ inversion use $$$ p = [ 2 1 ] $$$ $$$ b = [ p [ a [ 1 ] ] p [ a [ 2 ] ] p [ a [ 3 ] ] ] = [ 2 1 2 ] $$$ also $$$ 1 $$$ inversion fourth test case $$$ a = [ 1 2 3 2 ] $$$ since $$$ p = [ 1 3 2 ] $$$ $$$ b = [ 1 3 2 3 ] $$$ $$$ a $$$ $$$ b $$$ $$$ 1 $$$ inversion $$$ b $$$ lexicographically maximum,['math'],1500.0
1475/C,school vasya study preparations <unknown> graduation ceremony one plan performances a ball attend pair boys girls class must present two couple ball vasya 's class $$$ a $$$ boys $$$ b $$$ girls wish participate boys girls ready dance pair formally know $$$ k $$$ possible one - boy - one - girl pair need choose two pair person one pair example $$$ a=3 $$$ $$$ b=4 $$$ $$$ k=4 $$$ couple $$$ ( 1 2 ) $$$ $$$ ( 1 3 ) $$$ $$$ ( 2 2 ) $$$ $$$ ( 3 4 ) $$$ ready dance together ( pair boy 's number come first girl 's number ) follow combinations two pair possible ( possible options list ) : follow combinations possible : find number ways select two pair match condition two ways consider different consist different pair first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain three integers $$$ a $$$ $$$ b $$$ $$$ k $$$ ( $$$ 1 \le a b k \le 200000 $$$ ) — number boys girls class number couple ready dance together second line test case contain $$$ k $$$ integers $$$ a_1 a_2 \ldots a_k $$$ ( $$$ 1 \le a_i \le a $$$ ) $$$ a_i $$$ number boy pair number $$$ i $$$ third line test case contain $$$ k $$$ integers $$$ b_1 b_2 \ldots b_k $$$ ( $$$ 1 \le b_i \le b $$$ ) $$$ b_i $$$ number girl pair number $$$ i $$$ guarantee sum $$$ a $$$ $$$ b $$$ $$$ k $$$ test case exceed $$$ 200000 $$$ guarantee pair specify one test case test case a separate line print one integer — number ways choose two pair match condition first test case follow combinations pair fit : one pair second test case third test case follow combinations pair fit :,['math'],1400.0
1475/E,masha work advertise agency order promote new brand want conclude contract bloggers total masha connections $$$ n $$$ different bloggers blogger number $$$ i $$$ $$$ a_i $$$ followers since masha a limit budget sign a contract $$$ k $$$ different bloggers course masha want ad see many people possible therefore must hire bloggers maximum total number followers help find number ways select $$$ k $$$ bloggers total number followers maximum possible two ways consider different least one blogger first way second way masha believe bloggers different followers ( follower would follow two different bloggers ) example $$$ n=4 $$$ $$$ k=3 $$$ $$$ a= [ 1 3 1 2 ] $$$ masha two ways select $$$ 3 $$$ bloggers maximum total number followers : since answer quite large output modulo $$$ 1000000000 + 7 $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 1000 $$$ ) — number bloggers many sign a contract second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — number followers blogger guarantee sum $$$ n $$$ test case exceed $$$ 1000 $$$ test case a separate line output one integer — number ways select $$$ k $$$ bloggers total number followers maximum possible test case explain statements second test case follow ways valid : third test case follow ways valid :,['math'],1600.0
1476/B,"a statistic price change one product represent array $$$ n $$$ positive integers $$$ p_0 p_1 \dots p _ { n - 1 } $$$ $$$ p_0 $$$ initial price product $$$ p_i $$$ price increase $$$ i $$$ -th month use price change ask calculate inflation coefficients month ratio current price increase $$$ p_i $$$ price start month $$$ ( p_0 + p_1 + \dots + p _ { i - 1 } ) $$$ boss say clearly inflation coefficients must exceed $$$ k $$$ % decide increase value $$$ p_i $$$ a way $$$ p_i $$$ remain integers inflation coefficients month n't exceed $$$ k $$$ % know bigger change — obvious cheat 's need minimize total sum change 's minimum total sum change need make inflation coefficients $$$ k $$$ % ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 100 $$$ ; $$$ 1 \le k \le 100 $$$ ) — length array $$$ p $$$ coefficient $$$ k $$$ second line test case contain $$$ n $$$ integers $$$ p_0 p_1 \dots p _ { n - 1 } $$$ ( $$$ 1 \le p_i \le 1000000000 $$$ ) — array $$$ p $$$ test case print minimum total sum change need make inflation coefficients $$$ k $$$ % first test case , example increase $$$ p_0 $$$ $$$ 50 $$$ $$$ p_1 $$$ $$$ 49 $$$ get array $$$ [ <unknown> 50 202 202 ] $$$ get next inflation coefficients : second test case n't need modify array $$$ p $$$ since inflation coefficients already good :","['greedy', 'math']",1300.0
1477/E,"famous oh - suit - <unknown> tournament two team play grand prize precious pepper point first team consist $$$ n $$$ players second team consist $$$ m $$$ players player a potential : potential $$$ i $$$ -th player first team $$$ a_i $$$ potential $$$ i $$$ -th player second team $$$ b_i $$$ tournament players stage order a score device initially assign integer $$$ k $$$ use value performance players score players assign order appear stage let potential current player $$$ x $$$ potential previous player $$$ y $$$ ( $$$ y $$$ equal $$$ x $$$ first player ) , $$$ x - y $$$ add value score device afterwards value score device become negative value reset $$$ 0 $$$ lastly player 's score assign current value score device score a team sum score members insane fan first team nezzar desperately want biggest win first team wonder maximum difference score first team second team formally let score first team $$$ score_f $$$ score second team $$$ score_s $$$ nezzar want find maximum value $$$ score_f - score_s $$$ possible order players stage however situation often change $$$ q $$$ events happen three type events : help nezzar answer query third type ? first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \le n m \le 2 \cdot 100000 1 \le q \le 500000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000 $$$ ) third line contain $$$ m $$$ integers $$$ b_1 b_2 \ldots b_m $$$ ( $$$ 0 \le b_i \le 1000000 $$$ ) follow $$$ q $$$ line contain descriptions events describe statement one three possible format : query third type print answer query first query first test tournament hold $$$ k = 5 $$$ would optimal arrange players way ( potentials write ) : $$$ \underline { 7 } $$$ $$$ 3 $$$ $$$ 5 $$$ $$$ 4 $$$ $$$ 6 $$$ $$$ \underline { 1 } $$$ $$$ \underline { 2 } $$$ ( underline number potentials players first team ) individual score players number order appearance : $$$ score_f = 5 + 0 + 1 = 6 $$$ $$$ score_s = 1 + 3 + 2 + 4 = 10 $$$ score difference $$$ 6 - 10 = -4 $$$ prove maximum possible score difference","['data structures', 'greedy']",3300.0
1477/F,"nezzar buy favorite snack — $$$ n $$$ chocolate bar lengths $$$ l_1 l_2 \ldots l_n $$$ however chocolate bar might long store properly ! order solve problem nezzar design interest process divide small piece firstly nezzar put chocolate bar a black box , perform follow operation repeatedly maximum length chocolate bar exceed $$$ k $$$ nezzar wonder expect number operations perform divide chocolate bar small piece show answer represent $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ coprime integers $$$ q \not \equiv 0 $$$ ( $$$ \bmod 998\,244\,353 $$$ ) print value $$$ p\cdot q^ { -1 } \mod 998\,244\,353 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 50 1 \le k \le 2000 $$$ ) second line contain $$$ n $$$ integers $$$ l_1 l_2 \ldots l_n $$$ ( $$$ 1 \le l_i $$$ $$$ \sum _ { i=1 } ^ { n } l_i \le 2000 $$$ ) print a single integer — expect number operations nezzar perform divide chocolate bar small piece modulo $$$ 998\,244\,353 $$$",['math'],3500.0
1478/A,nezzar $$$ n $$$ ball number integers $$$ 1 2 \ldots n $$$ number $$$ a_1 a_2 \ldots a_n $$$ write respectively number ball form a non - decreasing sequence mean $$$ a_i \leq a _ { i+1 } $$$ $$$ 1 \leq i < n $$$ nezzar want color ball use minimum number color follow hold note a sequence length $$$ 1 $$$ consider a strictly increase sequence please help nezzar determine minimum number color first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number testcases first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) guarantee $$$ a_1 \leq a_2 \leq \ldots \leq a_n $$$ test case output minimum number color nezzar use let 's match color number : first test case one optimal color assignment $$$ [ <unknown> ] $$$ second test case one optimal color assignment $$$ [ <unknown> ] $$$,['greedy'],800.0
1478/B,nezzar 's favorite digit among $$$ 1 <unknown> $$$ $$$ d $$$ call a positive integer lucky $$$ d $$$ occur least decimal representation give $$$ q $$$ integers $$$ a_1 a_2 \ldots a_q $$$ $$$ 1 \le i \le q $$$ nezzar would like know $$$ a_i $$$ equal a sum several ( one ) lucky number first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 9 $$$ ) — number test case first line test case contain two integers $$$ q $$$ $$$ d $$$ ( $$$ 1 \le q \le 10000 $$$ $$$ 1 \le d \le 9 $$$ ) second line test case contain $$$ q $$$ integers $$$ a_1 a_2 \ldots a_q $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) integer test case print ` ` yes '' a single line $$$ a_i $$$ equal a sum lucky number otherwise print ` ` '' print letter case ( upper lower ) first test case $$$ 24 = 17 + 7 $$$ $$$ 27 $$$ a lucky number $$$ 25 $$$ equal a sum lucky number,"['dp', 'greedy', 'math']",1100.0
1479/E,"homer 's school $$$ n $$$ students love club initially $$$ m $$$ club $$$ n $$$ students exactly one club word $$$ a_i $$$ students $$$ i $$$ -th club $$$ 1 \leq i \leq m $$$ $$$ a_1+a_2+\dots+a_m = n $$$ $$$ n $$$ students unfriendly every day one ( choose uniformly random $$$ n $$$ students ) get angry student get angry one follow things homer wonder expect number days every student club first time prove answer represent a rational number $$$ \frac p q $$$ $$$ \gcd ( p q ) = 1 $$$ therefore ask find value $$$ <unknown> { -1 } \bmod 998\,244\,353 $$$ show $$$ q \bmod 998\,244\,353 \neq 0 $$$ give constraints problem first line contain integer $$$ m $$$ ( $$$ 1 \leq m \leq 1000 $$$ ) — number club initially second line contain $$$ m $$$ integers $$$ a_1 a_2 \dots a_m $$$ ( $$$ 1 \leq a_i \leq 400000000 $$$ ) $$$ 1 \leq a_1+a_2+\dots+a_m \leq 400000000 $$$ $$$ a_i $$$ denote number students $$$ i $$$ -th club initially print one integer — expect number days every student club first time modulo $$$ 998\,244\,353 $$$ first example matter student get angry two students become club probability $$$ \frac 1 4 $$$ expect number days every student club $$$ 4 $$$ second example note first day : fourth example one club initially , every student already club answer $$$ 0 $$$","['dp', 'math']",3500.0
148/C,"« next please » — princess call cast estimate glance next groom princess intend choose worthy groom , richest one whenever see a groom rich previous ones say a measure « oh ... » whenever groom richer previous ones add together exclaim « wow ! » ( « oh ... » case ) sight first groom princess stay calm say nothing fortune groom describe integer 1 50000 . know day princess saw n groom say « oh ... » exactly a time exclaim « wow ! » exactly b time task output a sequence n integers t1 t2 ... tn ti describe fortune i - th groom several sequence possible output sequence exist would satisfy requirements output a single number -1 . line input data contain three integer number n a b ( 1 ≤ n ≤ 100 0 ≤ a b ≤ 15 n > a + b ) separate single space output sequence integers t1 t2 ... tn ti ( 1 ≤ ti ≤ 50000 ) fortune i - th groom satisfy give constraints sequence exist would satisfy requirements output a single number -1 . let 's a closer look answer first sample test",['greedy'],1700.0
1485/A,two positive integers $$$ a $$$ $$$ b $$$ perform two kinds operations : find minimum number operations require make $$$ a=0 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case line description test case contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le 1000000000 $$$ ) test case print a single integer : minimum number operations require make $$$ a=0 $$$ first test case one optimal solutions :,"['greedy', 'math']",1000.0
1486/D,a give array $$$ a $$$ length $$$ n $$$ find a subarray $$$ a [ l .. r ] $$$ length least $$$ k $$$ largest median a median array length $$$ n $$$ element occupy position number $$$ \lfloor \frac { n + 1 } { 2 } \rfloor $$$ sort elements non - decreasing order example : $$$ median ( [ 1 2 3 4 ] ) = 2 $$$ $$$ median ( [ 3 2 1 ] ) = 2 $$$ $$$ median ( [ 2 1 2 1 ] ) = 1 $$$ subarray $$$ a [ l .. r ] $$$ a contiguous part array $$$ a $$$ i. e. array $$$ a_l a _ { l+1 } \ldots a_r $$$ $$$ 1 \leq l \leq r \leq n $$$ length $$$ r - l + 1 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq k \leq n \leq 200000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) output one integer $$$ m $$$ — maximum median get first example possible subarrays $$$ [ 1 .. 3 ] $$$ $$$ [ 1 .. 4 ] $$$ $$$ [ 1 .. 5 ] $$$ $$$ [ 2 .. 4 ] $$$ $$$ [ 2 .. 5 ] $$$ $$$ [ 3 .. 5 ] $$$ median $$$ 2 $$$ maximum possible median $$$ 2 $$$ second example $$$ median ( [ 3 .. 4 ] ) = 3 $$$,"['data structures', 'dp']",2100.0
1486/F,"give a tree consist $$$ n $$$ vertices $$$ m $$$ simple vertex paths task find many pair paths intersect exactly one vertex formally find number pair $$$ ( i j ) $$$ $$$ ( 1 \leq i < j \leq m ) $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ exactly one vertex common first line contain a single integer $$$ n $$$ $$$ ( 1 \leq n \leq 3 \cdot 100000 ) $$$ next $$$ n - 1 $$$ line describe tree line contain two integers $$$ u $$$ $$$ v $$$ $$$ ( 1 \leq u v \leq n ) $$$ describe edge vertices $$$ u $$$ $$$ v $$$ next line contain a single integer $$$ m $$$ $$$ ( 1 \leq m \leq 3 \cdot 100000 ) $$$ next $$$ m $$$ line describe paths line describe a path 's two endpoints $$$ u $$$ $$$ v $$$ $$$ ( 1 \leq u v \leq n ) $$$ give path vertices shortest path $$$ u $$$ $$$ v $$$ ( include $$$ u $$$ $$$ v $$$ ) output a single integer — number pair paths intersect exactly one vertex tree first example paths look like pair $$$ ( 1,4 ) $$$ $$$ ( 3,4 ) $$$ intersect one vertex second example three paths contain single vertex pair $$$ ( 1 2 ) $$$ $$$ ( 1 3 ) $$$ $$$ ( 2 3 ) $$$ intersect one vertex third example first example two additional paths pair $$$ ( 1,4 ) $$$ $$$ ( 1,5 ) $$$ $$$ ( 2,5 ) $$$ $$$ ( 3,4 ) $$$ $$$ ( 3,5 ) $$$ $$$ ( 3,6 ) $$$ $$$ ( 5,6 ) $$$ intersect one vertex","['data structures', 'dp']",2600.0
1487/C,"a big football championship occur soon ! $$$ n $$$ team compete pair team play exactly one game two possible outcomes a game : score a team number point gain game play interest a hypothetical situation team get score end championship a simple example situation game result tie want minimize number tie well task describe a situation ( choose result game ) team get score number tie minimum possible first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case test case follow test case describe one line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — number team test case print $$$ \frac { n ( n - 1 ) } { 2 } $$$ integers describe result game follow order : first integer correspond match team $$$ 1 $$$ team $$$ 2 $$$ second — team $$$ 1 $$$ team $$$ 3 $$$ $$$ 1 $$$ $$$ 4 $$$ ... $$$ 1 $$$ $$$ n $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 2 $$$ $$$ 4 $$$ ... $$$ 2 $$$ $$$ n $$$ , game team $$$ n - 1 $$$ team $$$ n $$$ integer correspond game team $$$ x $$$ team $$$ y $$$ $$$ 1 $$$ $$$ x $$$ win $$$ -1 $$$ $$$ y $$$ win $$$ 0 $$$ game result a tie team get score number tie minimum possible multiple optimal answer print show always exist a way make team score first test case example team get $$$ 1 $$$ point since game a tie second test case example team $$$ 1 $$$ defeat team $$$ 2 $$$ ( team $$$ 1 $$$ get $$$ 3 $$$ point ) team $$$ 1 $$$ lose team $$$ 3 $$$ ( team $$$ 3 $$$ get $$$ 3 $$$ point ) team $$$ 2 $$$ win team $$$ 3 $$$ ( team $$$ 2 $$$ get $$$ 3 $$$ point )","['greedy', 'implementation', 'math']",1500.0
1487/D,"a pythagorean triple a triple integer number $$$ ( a b c ) $$$ possible form a right triangle lengths first cathetus second cathetus hypotenuse equal $$$ a $$$ $$$ b $$$ $$$ c $$$ respectively example pythagorean triple $$$ ( 3 4 5 ) $$$ vasya study properties right triangles use a formula determine triple integers pythagorean unfortunately forget exact formula ; remember formula equation square , come follow formula : $$$ c = a^2 - b $$$ obviously right formula check a triple number pythagorean , vasya 's surprise actually work triple $$$ ( 3 4 5 ) $$$ : $$$ 5 = 3 ^ 2 - 4 $$$ , accord vasya 's formula a pythagorean triple vasya find right formula ( understand formula wrong ) wonder : many triple integers $$$ ( a b c ) $$$ $$$ 1 \le a \le b \le c \le n $$$ pythagorean accord formula real definition ? ask count triple first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist one line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) test case print one integer — number triple integers $$$ ( a b c ) $$$ $$$ 1 \le a \le b \le c \le n $$$ pythagorean accord real definition formula vasya come pythagorean triple satisfy $$$ c = a^2 - b $$$ $$$ 1 \le a \le b \le c \le 9 $$$ $$$ ( 3 4 5 ) $$$ ; 's answer $$$ n = 3 $$$ $$$ 0 $$$ answer $$$ n = 6 $$$ ( $$$ n = 9 $$$ ) $$$ 1 $$$",['math'],1500.0
1487/E,ivan want a good dinner a good dinner consist a first course a second course a drink a dessert $$$ n_1 $$$ different type first course ivan buy ( $$$ i $$$ -th cost $$$ a_i $$$ coin ) $$$ n_2 $$$ different type second course ( $$$ i $$$ -th cost $$$ b_i $$$ coin ) $$$ n_3 $$$ different type drink ( $$$ i $$$ -th cost $$$ c_i $$$ coin ) $$$ n_4 $$$ different type desserts ( $$$ i $$$ -th cost $$$ d_i $$$ coin ) dish n't go well $$$ m_1 $$$ pair first course second course n't go well $$$ m_2 $$$ pair second course drink $$$ m_3 $$$ pair drink desserts n't go well ivan want buy exactly one first course one second course one drink one dessert go well total cost dinner minimum possible help find cheapest dinner option ! first line contain four integers $$$ n_1 $$$ $$$ n_2 $$$ $$$ n_3 $$$ $$$ n_4 $$$ ( $$$ 1 \le n_i \le 150000 $$$ ) — number type first course second course drink desserts respectively four line follow first line contain $$$ n_1 $$$ integers $$$ a_1 a_2 \dots a _ { n_1 } $$$ ( $$$ 1 \le a_i \le 100000000 $$$ ) $$$ a_i $$$ cost $$$ i $$$ -th type first course three next line denote cost second course drink desserts way ( $$$ 1 \le b_i c_i d_i \le 100000000 $$$ ) next line contain one integer $$$ m_1 $$$ ( $$$ 0 \le m_1 \le 200000 $$$ ) — number pair first second course n't go well next $$$ m_1 $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i \le n_1 $$$ ; $$$ 1 \le y_i \le n_2 $$$ ) denote first course number $$$ x_i $$$ n't go well second course number $$$ y_i $$$ pair different block pair second dish drink n't go well give format pair drink desserts n't go well ( $$$ 0 \le m_2 m_3 \le 200000 $$$ ) 's impossible choose a first course a second course a drink a dessert go well print $$$ -1 $$$ otherwise print one integer — minimum total cost dinner best option first example take first course $$$ 2 $$$ second course $$$ 1 $$$ drink $$$ 2 $$$ dessert $$$ 1 $$$ second example pair first course second course bad 's impossible dinner,"['data structures', 'greedy', 'implementation']",2000.0
1487/G,$$$ c_1 $$$ letter ' a ' $$$ c_2 $$$ letter ' b ' ... $$$ c _ { 26 } $$$ letter ' z ' want build a beautiful string length $$$ n $$$ ( obviously use $$$ i $$$ -th letter $$$ c_i $$$ time ) $$$ c_i $$$ greater $$$ \frac { n } { 3 } $$$ a string call beautiful palindromic contiguous substrings odd length greater $$$ 1 $$$ example string ` ` abacaba '' beautiful several palindromic substrings odd length greater $$$ 1 $$$ ( example ` ` aca '' ) another example : string ` ` abcaa '' beautiful calculate number different string build print answer modulo $$$ 998244353 $$$ first line contain one integer $$$ n $$$ ( $$$ 3 \le n \le 400 $$$ ) second line contain $$$ 26 $$$ integers $$$ c_1 $$$ $$$ c_2 $$$ ... $$$ c _ { 26 } $$$ ( $$$ \frac { n } { 3 } < c_i \le n $$$ ) print one integer — number string build take modulo $$$ 998244353 $$$,"['dp', 'math']",2700.0
1490/C,give a positive integer $$$ x $$$ check whether number $$$ x $$$ representable sum cub two positive integers formally need check two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b $$$ ) $$$ <unknown> = x $$$ example $$$ x = 35 $$$ number $$$ a=2 $$$ $$$ b=3 $$$ suitable ( $$$ 2 ^ 3 + 3 ^ <unknown> + <unknown> $$$ ) $$$ x=4 $$$ pair number $$$ a $$$ $$$ b $$$ suitable first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case $$$ t $$$ test case follow test case contain one integer $$$ x $$$ ( $$$ 1 \le x \le 10^ { 12 } $$$ ) please note input test case wo n't fit $$$ 32 $$$ -bit integer type use least $$$ 64 $$$ -bit integer type program language test case output a separate line : output ` ` yes '' ` ` '' case ( example string yes yes yes yes recognize positive ) number $$$ 1 $$$ representable sum two cub number $$$ 2 $$$ represent $$$ 1 ^ 3 + 1 ^ 3 $$$ number $$$ 4 $$$ representable sum two cub number $$$ 34 $$$ representable sum two cub number $$$ 35 $$$ represent $$$ 2 ^ 3 + 3 ^ 3 $$$ number $$$ 16 $$$ represent $$$ 2 ^ 3 + 2 ^ 3 $$$ number $$$ <unknown> $$$ represent $$$ <unknown> ^ 3 + <unknown> ^ 3 $$$,['math'],1100.0
1491/A,give array $$$ a $$$ consist $$$ n $$$ integers initially elements $$$ a $$$ either $$$ 0 $$$ $$$ 1 $$$ need process $$$ q $$$ query two kinds : a reminder $$$ k $$$ -th largest value array $$$ b $$$ define follow : example second largest element array $$$ [ 0 1 0 1 ] $$$ $$$ 1 $$$ sort non - increasing order become $$$ [ 1 1 0 0 ] $$$ second element array equal $$$ 1 $$$ first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n q \le 100000 $$$ ) — length give array number query second line contain $$$ n $$$ integers $$$ a_1 a_2 a_3 \dots a_n $$$ ( $$$ 0 \le a_i \le 1 $$$ ) — elements initial array follow $$$ q $$$ line contain two integers first integer $$$ t $$$ ( $$$ 1 \le t \le 2 $$$ ) — type query 's guarantee least one query second type ( satisfy $$$ t = 2 $$$ ) query second type print a single integer — answer query initially $$$ a = [ 1 1 0 1 0 ] $$$ first operation print third largest value $$$ 1 $$$ second operation assign $$$ a_2 $$$ value $$$ 0 $$$ $$$ a $$$ become $$$ [ 1 0 0 1 0 ] $$$ third operation print third largest value $$$ 0 $$$ fourth operation print first largest value $$$ 1 $$$ last operation print fifth largest value $$$ 0 $$$,"['greedy', 'implementation']",800.0
1491/C,a trampoline park $$$ n $$$ trampolines a line $$$ i $$$ -th strength $$$ s_i $$$ pekora jump trampolines multiple pass start pass jump trampoline choice moment pekora jump trampoline $$$ i $$$ trampoline launch position $$$ i + s_i $$$ $$$ s_i $$$ become equal $$$ \max ( <unknown> ) $$$ word $$$ s_i $$$ decrease $$$ 1 $$$ except case $$$ s_i=1 $$$ $$$ s_i $$$ remain equal $$$ 1 $$$ trampoline position $$$ i + s_i $$$ pass otherwise pekora continue pass jump trampoline position $$$ i + s_i $$$ rule pekora ca n't stop jump pass land position larger $$$ n $$$ ( trampoline ) poor pekora ! pekora a naughty rabbit want ruin trampoline park reduce $$$ s_i $$$ $$$ 1 $$$ minimum number pass need reduce $$$ s_i $$$ $$$ 1 $$$ ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 5000 $$$ ) — number trampolines second line test case contain $$$ n $$$ integers $$$ s_1 s_2 \dots s_n $$$ ( $$$ 1 \le s_i \le 1000000000 $$$ ) $$$ s_i $$$ strength $$$ i $$$ -th trampoline 's guarantee sum $$$ n $$$ test case n't exceed $$$ 5000 $$$ test case output a single integer — minimum number pass pekora need reduce $$$ s_i $$$ $$$ 1 $$$ first test case optimal series pass pekora take ( bolded number position pekora jump pass ) second test case optimal series pass show third test case $$$ s_i $$$ already equal $$$ 1 $$$,"['data structures', 'dp', 'greedy', 'implementation']",1700.0
1491/D,"a new attraction singapore zoo : infinite zoo infinite zoo represent a graph infinite number vertices label $$$ 1,2,3 \ldots $$$ a direct edge vertex $$$ u $$$ vertex $$$ u+v $$$ $$$ <unknown> & v = v $$$ $$$ \ & $$$ denote bitwise operation edge graph zookeeper $$$ q $$$ query $$$ i $$$ -th query ask travel vertex $$$ u_i $$$ vertex $$$ v_i $$$ go direct edge first line contain integer $$$ q $$$ ( $$$ 1 \leq q \leq 100000 $$$ ) — number query $$$ i $$$ -th next $$$ q $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i < 2^ { 30 } $$$ ) — a query make zookeeper $$$ i $$$ -th $$$ q $$$ query output ` ` yes '' a single line zookeeper travel vertex $$$ u_i $$$ vertex $$$ v_i $$$ otherwise output ` ` '' print answer case example answer ` ` yes '' output ` ` yes '' ` ` yes '' also consider correct answer subgraph vertices $$$ 1,2,3,4,5,6 $$$ show","['dp', 'greedy', 'math']",1800.0
1491/G,"$$$ n $$$ coin label $$$ 1 $$$ $$$ n $$$ initially coin $$$ c_i $$$ position $$$ i $$$ face upwards ( ( $$$ c_1 c_2 \dots c_n ) $$$ a permutation number $$$ 1 $$$ $$$ n $$$ ) operations coin one operation follow : choose $$$ 2 $$$ distinct indices $$$ i $$$ $$$ j $$$ , swap coin position $$$ i $$$ $$$ j $$$ , flip coin position $$$ i $$$ $$$ j $$$ ( initially face face operation vice versa ) construct a sequence $$$ n+1 $$$ operations perform operations coin $$$ i $$$ position $$$ i $$$ end face note need minimize number operations first line contain integer $$$ n $$$ ( $$$ 3 \leq n \leq 200000 $$$ ) — number coin second line contain $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \le c_i \le n $$$ $$$ c_i \neq c_j $$$ $$$ <unknown> j $$$ ) first line output integer $$$ q $$$ $$$ ( 0 \leq q \leq n+1 ) $$$ — number operations use follow $$$ q $$$ line output two integers $$$ i $$$ $$$ j $$$ $$$ ( 1 \leq i j \leq n i \ne j ) $$$ — position choose current operation let coin $$$ i $$$ face upwards denote $$$ i $$$ coin $$$ i $$$ face downwards denote $$$ -i $$$ series move perform first sample change coin : second sample coin already correct position need swap",['math'],2800.0
1491/H,"<unknown> <unknown> give luo tianyi a tree $$$ n $$$ nod root $$$ 1 $$$ luo tianyi tell parent $$$ i $$$ -th node $$$ a_i $$$ ( $$$ 1 \leq a_i < i $$$ $$$ 2 \le i \le n $$$ ) ask perform $$$ q $$$ query $$$ 2 $$$ type : first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2\leq n q \leq 100000 $$$ ) — number nod number query respectively second line contain $$$ n-1 $$$ integers $$$ a_2 a_3 \dots a_n $$$ ( $$$ 1 \le a_i < i $$$ ) $$$ a_i $$$ parent node $$$ i $$$ next $$$ q $$$ line contain query query first integer line $$$ t $$$ ( $$$ t = 1 $$$ $$$ 2 $$$ ) — type query $$$ t = 1 $$$ represent query first type , three integers follow : $$$ l $$$ $$$ r $$$ $$$ x $$$ ( $$$ 2 \le l \le r \le n $$$ $$$ 1 \le x \le 100000 $$$ ) mean replace $$$ a_i $$$ $$$ \max ( a_i - x,1 ) $$$ $$$ i $$$ $$$ l \leq i \leq r $$$ $$$ t = 2 $$$ represent query second type , two integers follow : $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) find lca $$$ u $$$ $$$ v $$$ 's guarantee least one query second type query second type output answer a new line tree example show query first type tree change look show",['data structures'],3400.0
1491/I,realize zookeeper a duck animals <unknown> zookeeper decide a new ruler among a fight tournament follow format : initially animal $$$ 0 $$$ king everyone else queue animal $$$ 1 $$$ front queue animal $$$ n-1 $$$ back animal front queue challenge king a fight animal greater strength win fight winner become king loser join back queue animal win $$$ 3 $$$ time consecutively crown ruler whole zoo strength animal depend many consecutive fight animal $$$ i $$$ strength $$$ a_i $$$ $$$ 0 $$$ consecutive win $$$ b_i $$$ $$$ 1 $$$ consecutive win $$$ c_i $$$ $$$ 2 $$$ consecutive win initially everyone $$$ 0 $$$ consecutive win animals $$$ a_i > b_i $$$ $$$ c_i > b_i $$$ also value $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ distinct ( $$$ 3n $$$ value pairwise different ) word animal a king strength $$$ a_i $$$ a king usually a strength $$$ b_i $$$ $$$ c_i $$$ exception first turn first king ( animal $$$ 0 $$$ ) strength $$$ a_i $$$ new ruler many fight ? end animals fight forever one end ruler ? first line contain one integer $$$ n $$$ ( $$$ 4 \leq n \leq 6000 $$$ ) — number animals $$$ i $$$ -th next $$$ n $$$ line contain $$$ 3 $$$ integers $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ ( $$$ 0 \leq a_i b_i c_i \leq 1000000000 $$$ ) guarantee $$$ a_i > b_i $$$ $$$ c_i > b_i $$$ value $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ distinct output two integers a single line first index animal become ruler second number fight pass animal become ruler animals fight infinitely long output -1 -1 instead follow describe sequence events second sample note fight $$$ 1 $$$ king ( animal $$$ 0 $$$ ) strength $$$ a_0 $$$ tournament end fight $$$ 7 $$$ animal $$$ 1 $$$ win fight $$$ 5 $$$ $$$ 6 $$$ $$$ 7 $$$,['data structures'],3500.0
1494/A,give a string $$$ a $$$ consist $$$ n $$$ character $$$ n $$$ even $$$ i $$$ $$$ 1 $$$ $$$ n $$$ $$$ a_i $$$ one ' a ' ' b ' ' c ' a bracket sequence a string contain character ` ` ( ` ` ` ` ) '' a regular bracket sequence a bracket sequence transform a correct arithmetic expression insert character ` ` 1 '' ` ` + '' original character sequence example bracket sequence ` ` ( ) ( ) '' ` ` ( ( ) ) '' regular ( result expressions : ` ` ( 1 ) + ( 1 ) '' ` ` ( ( 1 + 1 ) +1 ) '' ) ` ` ) ( ` ` ` ` ( ` ` ` ` ) '' want find a string $$$ b $$$ consist $$$ n $$$ character : word want replace occurrences ' a ' type bracket occurrences ' b ' type bracket occurrences ' c ' type bracket task determine a string $$$ b $$$ exist first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases descriptions $$$ t $$$ testcases follow line testcase contain a string $$$ a $$$ $$$ a $$$ consist uppercase letter ' a ' ' b ' ' c ' let $$$ n $$$ length $$$ a $$$ guarantee $$$ n $$$ even $$$ 2 \le n \le 50 $$$ testcase print ` ` yes '' exist a string $$$ b $$$ : otherwise print ` ` '' may print every letter case want ( example string yes yes yes yes recognize positive answer ) first testcase one possible string $$$ b $$$ ` ` ( ( ) ) ( ) '' second testcase one possible string $$$ b $$$ ` ` ( ) ( ) '',['implementation'],900.0
1494/D,"dogeforces company $$$ k $$$ employees employee except lower - level employees least $$$ 2 $$$ subordinate lower - level employees subordinate employee except head company exactly one direct supervisor head company a direct indirect supervisor employees know dogeforces supervisor receive a salary strictly subordinate full structure company a secret know number lower - level employees pair lower - level employees salary common supervisor know ( several <unknown> supervisor minimum salary ) restore structure company first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 500 $$$ ) — number lower - level employees follow $$$ n $$$ line $$$ i $$$ -th line contain $$$ n $$$ integers $$$ a _ { i,1 } a _ { i,2 } \dots a _ { i n } $$$ ( $$$ 1 \le a _ { i j } \le 5000 $$$ ) — salary common supervisor employees number $$$ i $$$ $$$ j $$$ guarantee $$$ a _ { i j } = a _ { j i } $$$ note $$$ a _ { i i } $$$ equal salary $$$ i $$$ -th employee first line print a single integer $$$ k $$$ — number employees company second line print $$$ k $$$ integers $$$ c_1 c_2 \dots c_k $$$ $$$ c_i $$$ salary employee number $$$ i $$$ third line print a single integer $$$ r $$$ — number employee head company follow $$$ k-1 $$$ line print two integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le k $$$ ) — number employee direct supervisor note lower - level employees number $$$ 1 $$$ $$$ n $$$ rest employees assign number $$$ n+1 $$$ $$$ k $$$ several correct company structure print one possible structure first example :","['data structures', 'greedy']",2300.0
1496/A,kawashiro nitori a girl love competitive program one day find a string integer advance problem setter quickly think a problem give a string $$$ s $$$ a parameter $$$ k $$$ need check exist $$$ k+1 $$$ non - empty string $$$ a_1 a_2 ... a _ { k+1 } $$$ $$$ $$$ s = <unknown> + <unknown> _ { k+1 } + r ( a_k ) + r ( a _ { k-1 } ) + <unknown> ( a _ { 1 } ) $$$ $$$ $$$ + $$$ represent concatenation define $$$ r ( x ) $$$ a reverse string $$$ x $$$ example $$$ r ( abcd ) = <unknown> $$$ note formula part $$$ r ( a _ { k+1 } ) $$$ intentionally skip input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 100 $$$ ) — number test case description test case follow first line test case description contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1\le n\le 100 $$$ $$$ 0\le k\le \lfloor \frac { n } { 2 } \rfloor $$$ ) — length string $$$ s $$$ parameter $$$ k $$$ second line test case description contain a single string $$$ s $$$ length $$$ n $$$ consist lowercase english letter test case print ` ` yes '' ( without quote ) possible find $$$ a_1 a_2 \ldots a _ { k+1 } $$$ ` ` '' ( without quote ) otherwise print letter case ( upper lower ) first test case one possible solution $$$ a_1 = <unknown> $$$ $$$ a_2 = q $$$ third test case one possible solution $$$ a_1 = i $$$ $$$ a_2 = o $$$ fifth test case one possible solution $$$ a_1 = <unknown> $$$,['greedy'],900.0
1497/C1,easy version problem difference version $$$ k = 3 $$$ give a positive integer $$$ n $$$ find $$$ k $$$ positive integers $$$ a_1 a_2 \ldots a_k $$$ : $$$ lcm $$$ least common multiple number $$$ a_1 a_2 \ldots a_k $$$ show give constraints answer always exist first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 10000 ) $$$ — number test case line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 3 \le n \le 1000000000 $$$ $$$ k = 3 $$$ ) test case print $$$ k $$$ positive integers $$$ a_1 a_2 \ldots a_k $$$ condition satisfy,['math'],1200.0
1497/E1,easy version problem difference version $$$ k = 0 $$$ array $$$ a_1 a_2 \ldots a_n $$$ $$$ n $$$ positive integers divide a minimal number continuous segment segment two number ( different position ) whose product a perfect square moreover allow $$$ k $$$ operations division : choose a number array change value positive integer version $$$ k = 0 $$$ important minimum number continuous segment use make change optimally ? first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 1000 ) $$$ — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ k = 0 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 10000000 $$$ ) 's guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print a single integer — answer problem first test case division may follow :,"['data structures', 'dp', 'greedy', 'math']",1700.0
1497/E2,hard version problem difference version $$$ 0 \leq k \leq 20 $$$ array $$$ a_1 a_2 \ldots a_n $$$ $$$ n $$$ positive integers divide a minimal number continuous segment segment two number ( different position ) whose product a perfect square moreover allow $$$ k $$$ operations division : choose a number array change value positive integer minimum number continuous segment use make change optimally ? first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 1000 ) $$$ — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 0 \leq k \leq 20 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 10000000 $$$ ) 's guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print a single integer — answer problem first test case possible change array way : $$$ [ \underline { 3 } 6 2 4 \underline { 5 } ] $$$ ( change elements underline ) array need divide answer $$$ 1 $$$ second test case possible change array way : $$$ [ 6 2 \underline { 3 } 8 9 \underline { 5 } 3 6 \underline { 10 } \underline { 11 } 7 ] $$$ division optimal :,"['data structures', 'dp', 'greedy', 'math']",2500.0
1498/A,$$$ \text { $$$ gcdsum $$$ } $$$ a positive integer $$$ gcd $$$ integer sum digits formally $$$ \text { $$$ gcdsum $$$ } ( x ) = gcd ( x \text { sum digits } x ) $$$ a positive integer $$$ x $$$ $$$ gcd ( a b ) $$$ denote greatest common divisor $$$ a $$$ $$$ b $$$ — largest integer $$$ d $$$ integers $$$ a $$$ $$$ b $$$ divisible $$$ d $$$ example : $$$ \text { $$$ gcdsum $$$ } ( 762 ) = gcd ( 762 7 + 6 + 2 ) = gcd ( <unknown> ) = 3 $$$ give integer $$$ n $$$ find smallest integer $$$ x \ge n $$$ $$$ \text { $$$ gcdsum $$$ } ( x ) > 1 $$$ first line input contain one integer $$$ t $$$ $$$ ( 1 \le t \le 10000 ) $$$ — number test case $$$ t $$$ line follow contain a single integer $$$ n $$$ $$$ ( 1 \le n \le 10^ { 18 } ) $$$ test case one test different output $$$ t $$$ line $$$ i $$$ -th line a single integer contain answer $$$ i $$$ -th test case let us explain three test case sample test case 1 : $$$ n = 11 $$$ : $$$ \text { $$$ gcdsum $$$ } ( 11 ) = gcd ( 11 1 + 1 ) = gcd ( 11 \ 2 ) = 1 $$$ $$$ \text { $$$ gcdsum $$$ } ( 12 ) = gcd ( 12 1 + 2 ) = gcd ( 12 \ 3 ) = 3 $$$ smallest number $$$ \ge 11 $$$ whose $$$ gcdsum $$$ $$$ > 1 $$$ $$$ 12 $$$ test case 2 : $$$ n = 31 $$$ : $$$ \text { $$$ gcdsum $$$ } ( 31 ) = gcd ( 31 3 + 1 ) = gcd ( 31 \ 4 ) = 1 $$$ $$$ \text { $$$ gcdsum $$$ } ( 32 ) = gcd ( 32 3 + 2 ) = gcd ( 32 \ 5 ) = 1 $$$ $$$ \text { $$$ gcdsum $$$ } ( 33 ) = gcd ( 33 3 + 3 ) = gcd ( 33 \ 6 ) = 3 $$$ smallest number $$$ \ge 31 $$$ whose $$$ gcdsum $$$ $$$ > 1 $$$ $$$ 33 $$$ test case 3 : $$$ \ n = 75 $$$ : $$$ \text { $$$ gcdsum $$$ } ( 75 ) = gcd ( 75 7 + 5 ) = gcd ( 75 \ 12 ) = 3 $$$ $$$ \text { $$$ gcdsum $$$ } $$$ $$$ 75 $$$ already $$$ > 1 $$$ hence answer,['math'],800.0
15/A,a new cottage village call « flatville » build flatland already build « flatville » n square house centre оx - axis house ' side parallel coordinate ax 's know two house overlap touch architect <unknown> peter work commission build a new house « flatville » customer want future house оx - axis square shape a side t touch least one already build house sure side parallel coordinate ax centre ox - axis n't overlap house village peter give a list house « flatville » would help find amount possible position new house ? first line input data contain number n t ( 1 ≤ n t ≤ 1000 ) follow n line contain two space - separated integer number : xi ai xi — x - coordinate centre i - th house ai — length side ( - 1000 ≤ xi ≤ 1000 1 ≤ ai ≤ 1000 ) output amount possible position new house possible x - coordinate new house non - integer value,['implementation'],1200.0
1501/B,"week arkady want cook pancakes ( follow ancient traditions ) make a problem remember one ca n't make a problem stack pancakes without work a specific company decide bake napoleon cake instead bake a napoleon cake one bake $$$ n $$$ dry layer first put one stack add cream arkady start empty plate perform follow step $$$ n $$$ time : $$$ x $$$ units cream pour top stack top $$$ x $$$ layer cake get drench cream less $$$ x $$$ layer layer get drench rest cream waste $$$ x = 0 $$$ layer get drench help arkady determine layer cake eventually get drench process n't test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 20\,000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number layer cake second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le n $$$ ) — amount cream pour cake add layer guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print a single line $$$ n $$$ integers $$$ i $$$ -th integers equal $$$ 1 $$$ $$$ i $$$ -th layer bottom get drench $$$ 0 $$$ otherwise","['dp', 'implementation']",900.0
1505/A,interactive problem need read participants ' query standard input print responses standard output n't know number query <unknown> 'll need process get ; 'll know 're do reach end file query ask question write one line answer correctly <unknown> without display <unknown> response case - insensitive please make sure use stream flush operation response order leave part output buffer,['implementation'],900.0
1505/B,many people aware dmca – digital millennium <unknown> act another recently propose dmca – digital millennium calculation act – much less know problem need find a root a number accord new dmca law input contain a single integer $$$ a $$$ ( $$$ 1 \le a \le 1000000 $$$ ) output result – integer number,['implementation'],1600.0
1512/C,give a string $$$ s $$$ consist character ' 0 ' ' 1 ' ' ? ' need replace character ' ? ' string $$$ s $$$ ' 0 ' ' 1 ' string become a palindrome exactly $$$ a $$$ character ' 0 ' exactly $$$ b $$$ character ' 1 ' note character ' ? ' replace independently others a string $$$ t $$$ length $$$ n $$$ call a palindrome equality $$$ t [ i ] = t [ n - i+1 ] $$$ true $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) example $$$ s= $$$ ` ` 01 ? ? ? ? ? 0 '' $$$ a=4 $$$ $$$ b=4 $$$ replace character ' ? ' follow ways : give string $$$ s $$$ number $$$ a $$$ $$$ b $$$ replace character ' ? ' string $$$ s $$$ ' 0 ' ' 1 ' string become a palindrome exactly $$$ a $$$ character ' 0 ' exactly $$$ b $$$ character ' 1 ' first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) $$$ t $$$ test case follow first line test case contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 0 \le a b \le 200000 $$$ $$$ a + b \ge 1 $$$ ) second line test case contain string $$$ s $$$ length $$$ a+b $$$ consist character ' 0 ' ' 1 ' ' ? ' guarantee sum string lengths $$$ s $$$ test case exceed $$$ 200000 $$$ test case output : several suitable ways replace character output,['implementation'],1200.0
1512/G,let us denote $$$ d ( n ) $$$ sum divisors number $$$ n $$$ i.e $$$ d ( n ) = \sum\limits _ { k | n } k $$$ example $$$ d ( 1 ) = 1 $$$ $$$ d ( 4 ) = 1 + 2 + <unknown> $$$ $$$ d ( 6 ) = 1 + 2 + 3 + <unknown> $$$ a give number $$$ c $$$ find minimum $$$ n $$$ $$$ d ( n ) = c $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) $$$ t $$$ test case follow test case characterize one integer $$$ c $$$ ( $$$ 1 \le c \le 10000000 $$$ ) test case output :,"['dp', 'math']",1700.0
1513/C,give integer $$$ n $$$ apply $$$ m $$$ operations a single operation must replace every digit $$$ d $$$ number decimal representation integer $$$ d + 1 $$$ example $$$ 1912 $$$ become $$$ 21023 $$$ apply operation find length $$$ n $$$ apply $$$ m $$$ operations since answer large print modulo $$$ 1000000000 + 7 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200000 $$$ ) — number test case line test case contain two integers $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) $$$ m $$$ ( $$$ 1 \le m \le 200000 $$$ ) — initial number number operations test case output length result number modulo $$$ 1000000000 + 7 $$$ first test $$$ 1912 $$$ become $$$ 21023 $$$ $$$ 1 $$$ operation length $$$ 5 $$$ second test $$$ 5 $$$ become $$$ 21 $$$ $$$ 6 $$$ operations length $$$ 2 $$$ third test $$$ 999 $$$ become $$$ 101010 $$$ $$$ 1 $$$ operation length $$$ 6 $$$ fourth test $$$ 88 $$$ become $$$ 1010 $$$ $$$ 2 $$$ operations length $$$ 4 $$$,['dp'],1600.0
1515/G,fire city $$$ n $$$ intersections $$$ m $$$ one - way roads $$$ i $$$ -th road go intersection $$$ a_i $$$ $$$ b_i $$$ length $$$ l_i $$$ miles $$$ q $$$ cars may drive along roads $$$ i $$$ -th car start intersection $$$ v_i $$$ odometer begin $$$ s_i $$$ increments mile drive reset $$$ 0 $$$ whenever reach $$$ t_i $$$ phoenix task drive cars along roads ( possibly none ) return initial intersection odometer show $$$ 0 $$$ car please find possible a car may visit road intersection arbitrary number time odometers n't stop count distance reset odometers may also reset arbitrary number time first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ ; $$$ 1 \le m \le 200000 $$$ ) — number intersections number roads respectively next $$$ m $$$ line contain three integers $$$ a_i $$$ $$$ b_i $$$ $$$ l_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ ; $$$ a_i \neq b_i $$$ ; $$$ 1 \le l_i \le 1000000000 $$$ ) — information $$$ i $$$ -th road graph necessarily connect guarantee two intersections one road direction next line contain integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number cars next $$$ q $$$ line contain three integers $$$ v_i $$$ $$$ s_i $$$ $$$ t_i $$$ ( $$$ 1 \le v_i \le n $$$ ; $$$ 0 \le s_i < t_i \le 1000000000 $$$ ) — initial intersection $$$ i $$$ -th car initial number $$$ i $$$ -th odometer number $$$ i $$$ -th odometer reset respectively print $$$ q $$$ answer $$$ i $$$ -th car 's odometer may reset $$$ 0 $$$ drive roads ( possibly none ) return start intersection $$$ v_i $$$ print yes otherwise print illustration first example : first query phoenix drive follow cities : $$$ 1 $$$ $$$ \rightarrow $$$ $$$ 2 $$$ $$$ \rightarrow $$$ $$$ 3 $$$ $$$ \rightarrow $$$ $$$ 1 $$$ $$$ \rightarrow $$$ $$$ 2 $$$ $$$ \rightarrow $$$ $$$ 3 $$$ $$$ \rightarrow $$$ $$$ 1 $$$ odometer reset $$$ 3 $$$ time display $$$ 0 $$$ end second query show way reset odometer $$$ 0 $$$ return intersection $$$ 1 $$$ third query odometer already display $$$ 0 $$$ need drive roads illustration second example :,['math'],2700.0
1519/B,a $$$ n \times m $$$ grid stand cell $$$ ( 1 1 ) $$$ goal finish cell $$$ ( n m ) $$$ move neighbor cells right word suppose stand cell $$$ ( x y ) $$$ : reach cell $$$ ( n m ) $$$ spend exactly $$$ k $$$ burl ? first line contain single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n m \le 100 $$$ ; $$$ 0 \le k \le 10000 $$$ ) — size grid exact amount money need spend test case reach cell $$$ ( n m ) $$$ spend exactly $$$ k $$$ burl print yes otherwise print may print every letter case want ( example string yes yes yes yes recognize positive answer ) first test case already final cell spend $$$ 0 $$$ burl second third fourth test case two paths $$$ ( 1 1 ) $$$ $$$ ( 2 2 ) $$$ : $$$ ( 1 1 ) $$$ $$$ \rightarrow $$$ $$$ ( 1 2 ) $$$ $$$ \rightarrow $$$ $$$ ( 2 2 ) $$$ $$$ ( 1 1 ) $$$ $$$ \rightarrow $$$ $$$ ( 2 1 ) $$$ $$$ \rightarrow $$$ $$$ ( 2 2 ) $$$ cost $$$ 1 + 2 = 3 $$$ burl 's amount money spend fifth test case way $$$ ( 1 1 ) $$$ $$$ ( 1 4 ) $$$ cost $$$ 1 + 1 + 1 = 3 $$$ burl,"['dp', 'math']",800.0
152/A,vasya mr . vasily petrov a dean a department a local university winter exams get hand a group 's gradebook overall group n students receive mark m subject student get a mark 1 9 ( inclusive ) subject let 's consider a student best subject student get a higher mark subject let 's consider a student successful exist a subject best task find number successful students group first input line contain two integers n m ( 1 ≤ n m ≤ 100 ) — number students number subject correspondingly next n line contain m character describe gradebook character gradebook a number 1 9 . note mark a row sepatated space print single number — number successful students give group first sample test student number 1 best subject 1 3 student 2 best subject 1 2 student 3 n't best subject second sample test student best least one subject,['implementation'],900.0
1521/E,"like number n't ? nastia a lot number want share ! n't amaze ? let $$$ a_i $$$ many number $$$ i $$$ ( $$$ 1 \le i \le k $$$ ) $$$ n \times n $$$ matrix call beautiful contain number $$$ 2 \times 2 $$$ submatrix original matrix satisfy : make a beautiful matrix minimum size first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10\,000 $$$ ) — number test case first line test case contain $$$ 2 $$$ integers $$$ m $$$ $$$ k $$$ ( $$$ 1 \le m k \le 100000 $$$ ) — many number nastia give length array $$$ a $$$ respectively second line test case contain $$$ k $$$ integers $$$ a_1 a_2 \ldots a _ { k } $$$ ( $$$ 0 \le a_i \le m $$$ $$$ a_1 + a_2 + \ldots + a _ { k } = m $$$ ) $$$ a_i $$$ many number $$$ i $$$ 's guarantee sum $$$ m $$$ $$$ k $$$ one test n't exceed $$$ 200000 $$$ $$$ t $$$ test case print a single integer $$$ n $$$ — size beautiful matrix next $$$ n $$$ line print $$$ n $$$ integers $$$ b _ { i j } $$$ ( $$$ 0 \le b _ { i j } \le k $$$ ; position empty print $$$ b _ { i j } = 0 $$$ ) — beautiful matrix $$$ b $$$ make note $$$ 0 $$$ problem represent a blank a number examples possible answer first test case : $$$ \begin { array } { cc } 1 & 1 \\ 4 & 0 \\ \end { array } \hspace { 0,5 cm } \begin { array } { cc } 1 & 4 \\ 1 & 0 \\ \end { array } \hspace { 0,5 cm } \begin { array } { cc } 4 & 0 \\ 1 & 1 \\ \end { array } $$$ examples beautiful matrices first test case : $$$ \begin { array } { cc } 1 & 0 \\ 4 & 1 \\ \end { array } \hspace { 0,5 cm } \begin { array } { cc } 4 & 1 \\ 7 & 1 \\ \end { array } \hspace { 0,5 cm } \begin { array } { cc } 1 & 0 \\ 4 & 0 \\ \end { array } $$$ example beautiful matrix second test case : $$$ \begin { array } { cc } 3 & 4 & 0 & 2 & 2 \\ 3 & 2 & 3 & 3 & 0 \\ 0 & 1 & 0 & 0 & 0 \\ 3 & 0 & 0 & 0 & 0 \\ 2 & 1 & 3 & 3 & 3 \\ \end { array } $$$ everything okay except left - top submatrix contain $$$ 4 $$$ number","['dp', 'greedy']",2700.0
1525/F,"monocarp play a computer game call ` ` goblins gnomes '' game manage a large underground city gnomes defend hordes goblins city consist $$$ n $$$ halls $$$ m $$$ one - directional tunnel connect structure tunnel follow property : a goblin leave hall return hall city attack $$$ k $$$ wave goblins ; $$$ i $$$ -th wave $$$ i $$$ goblins attack city monocarp 's goal pass $$$ k $$$ wave $$$ i $$$ -th wave go follow : firstly $$$ i $$$ goblins appear halls city pillage ; one goblin appear hall , goblins start move along tunnel pillage halls path goblins greedy cunning choose paths two goblins pass hall among possible attack plan choose a plan allow pillage maximum number halls goblins do pillage leave city halls pillage wave — monocarp lose game otherwise city restore hall pillage a wave goblins still interest pillage next wave wave monocarp spend time prepare monocarp n't strict time limit preparations ( decide call wave ) longer prepare a wave fewer point get pass monocarp prepare $$$ i $$$ -th wave $$$ t_i $$$ minutes get $$$ \max ( 0 x_i - t_i \cdot y_i ) $$$ point pass ( obviously n't lose process ) prepare a wave monocarp block tunnel spend one minute either block tunnel lead hall block tunnel lead hall monocarp block a tunnel prepare a wave stay block next wave well help monocarp defend $$$ k $$$ wave goblins get maximum possible amount point ! first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \le n \le 50 $$$ ; $$$ 0 \le m \le \frac { n ( n - 1 ) } { 2 } $$$ ; $$$ 1 \le k \le n - 1 $$$ ) — number halls city number tunnel number goblin wave <unknown> next $$$ m $$$ line describe tunnel $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ; $$$ u_i \ne v_i $$$ ) mean tunnel go hall $$$ u_i $$$ hall $$$ v_i $$$ structure tunnel follow property : a goblin leave hall return hall one tunnel pair halls next $$$ k $$$ line describe score system $$$ i $$$ -th line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i \le 1000000000 $$$ ; $$$ 1 \le y_i \le 1000000000 $$$ ) monocarp prepare $$$ i $$$ -th wave $$$ t_i $$$ minutes get $$$ \max ( 0 x_i - t_i \cdot y_i ) $$$ point pass print optimal monocarp 's strategy follow format : first print one integer $$$ a $$$ ( $$$ k \le a \le 2n + k $$$ ) — number action monocarp perform next print action order monocarp perform $$$ i $$$ -th action describe a single integer $$$ b_i $$$ ( $$$ -n \le b_i \le n $$$ ) use follow format : ca n't repeat block action $$$ b_i $$$ several time monocarp must survive wave call ( goblins n't able pillage halls ) monocarp call exactly $$$ k $$$ wave earn maximum possible number point total several optimal strategies — print first example monocarp firstly block tunnel go hall $$$ 2 $$$ secondly — tunnel go hall $$$ 3 $$$ call wave spend two minutes prepare wave $$$ 1 $$$ get $$$ 98 $$$ point n't prepare 's get maximum score next wave ( $$$ 200 $$$ $$$ 10 $$$ $$$ 100 $$$ ) total monocarp earn $$$ <unknown> $$$ point second example monocarp call first wave immediately get $$$ 100 $$$ point second wave block tunnel go hall $$$ 3 $$$ spend one minute prepare wave get $$$ 195 $$$ point monocarp n't prepare third wave get $$$ 10 $$$ point survive fourth wave block tunnel go hall $$$ 1 $$$ spend one minute get $$$ 99 $$$ point fourth wave total monocarp earn $$$ 404 $$$ point third example n't matter many minutes monocarp spend wave since wo n't get point 's decide block tunnel city spend $$$ 5 $$$ minutes survive wave though without get point",['dp'],2800.0
1528/E,"today mashtali 's birthday ! receive a hagh tree <unknown> <unknown> birthday present ! a direct tree call a hagh tree iff : open gift mashtali find label vertices go immediately ask : many different unlabeled hagh tree ? , many possible tree could receive birthday present ? first glance number tree seem infinite since limit number vertices ; solve problem prove 's a finite number unlabeled hagh tree ! amaze fact share task could enjoy solve well since answer rather large ask find number different unlabeled hagh tree modulo $$$ 998244353 $$$ two tree consider different isomorphic : way map nod one tree second tree edge map edge preserve orientation examples $$$ n = 2 $$$ : direct tree $$$ d $$$ $$$ e $$$ hagh $$$ c $$$ hagh a vertex $$$ 4 $$$ edge attach $$$ a $$$ $$$ b $$$ hagh longest direct paths equal $$$ n $$$ also $$$ b $$$ leftmost rightmost vertices friends neither a mutual friend first line input contain a single integer $$$ n $$$ $$$ ( 1 \le n \le 1000000 ) $$$ print a single integer answer mashtali 's task modulo $$$ 998244353 $$$ five hagh tree $$$ n = 1 $$$ :",['dp'],2900.0
1530/D,every december vk traditionally hold event employees name ` ` secret santa '' 's happen $$$ n $$$ employees number $$$ 1 $$$ $$$ n $$$ take part event employee $$$ i $$$ assign a different employee $$$ b_i $$$ employee $$$ i $$$ make a new year gift employee assign exactly one employee nobody assign ( two employees may assign ) formally $$$ b_i $$$ must distinct integers $$$ 1 $$$ $$$ n $$$ $$$ i $$$ $$$ b_i \ne i $$$ must hold assignment usually generate randomly year experiment event participants ask wish make a gift employee $$$ i $$$ say wish make a gift employee $$$ a_i $$$ find a valid assignment $$$ b $$$ maximize number fulfil wish employees test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow test case consist two line first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number participants event second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ; $$$ a_i \ne i $$$ ) — wish employees order $$$ 1 $$$ $$$ n $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print two line first line print a single integer $$$ k $$$ ( $$$ 0 \le k \le n $$$ ) — number fulfil wish assignment second line print $$$ n $$$ distinct integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1 \le b_i \le n $$$ ; $$$ b_i \ne i $$$ ) — number employees assign employees $$$ 1 2 \ldots n $$$ $$$ k $$$ must equal number value $$$ i $$$ $$$ a_i = b_i $$$ must large possible multiple answer print first test case two valid assignments exist : $$$ [ 3 1 2 ] $$$ $$$ [ 2 3 1 ] $$$ former assignment fulfill two wish latter assignment fulfill one therefore $$$ k = 2 $$$ correct answer $$$ [ 3 1 2 ] $$$,"['greedy', 'math']",1600.0
1530/E,prefix function string $$$ t = t_1 t_2 \ldots t_n $$$ position $$$ i $$$ define length $$$ k $$$ longest proper ( equal whole substring ) prefix substring $$$ t_1 t_2 \ldots t_i $$$ also a suffix substring example string $$$ t = $$$ abacaba value prefix function position $$$ 1 2 \ldots 7 $$$ equal $$$ [ 0 0 1 0 1 2 3 ] $$$ let $$$ f ( t ) $$$ equal maximum value prefix function string $$$ t $$$ position example $$$ f ( $$$ abacaba $$$ ) = 3 $$$ give a string $$$ s $$$ reorder character arbitrarily get a string $$$ t $$$ ( number occurrences character string $$$ s $$$ $$$ t $$$ must equal ) value $$$ f ( t ) $$$ must minimize options minimize $$$ f ( t ) $$$ choose one string $$$ t $$$ lexicographically smallest test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow line test case contain string $$$ s $$$ ( $$$ 1 \le |s| \le 100000 $$$ ) consist lowercase english letter guarantee sum lengths $$$ s $$$ test case exceed $$$ 100000 $$$ test case print a single string $$$ t $$$ multisets letter string $$$ s $$$ $$$ t $$$ must equal value $$$ f ( t ) $$$ maximum prefix function string $$$ t $$$ must small possible string $$$ t $$$ must lexicographically smallest string string satisfy previous condition a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ one follow hold : first test case $$$ f ( t ) = 0 $$$ value prefix function $$$ [ 0 0 0 0 0 ] $$$ permutation letter string <unknown> lexicographically smallest permutation letter string vkcup second test case $$$ f ( t ) = 1 $$$ value prefix function $$$ [ 0 1 0 1 0 1 0 ] $$$ third test case $$$ f ( t ) = 5 $$$ value prefix function $$$ [ 0 1 2 3 4 5 ] $$$,['greedy'],2100.0
1534/B,little dormi receive a histogram $$$ n $$$ bar height $$$ a_1 a_2 \ldots a_n $$$ christmas however play new histogram realize <unknown> today want modify like modify histogram little dormi able perform follow operation arbitrary number time : little dormi define ugliness score histogram ( perform number operations ) sum vertical length outline number operations perform make histogram perfect possible would like minimize ugliness score modify number operations however histogram large little dormi trouble minimize ugliness score little dormi 's older brother help find minimal ugliness consider follow example histogram $$$ 4 $$$ columns heights $$$ <unknown> $$$ : blue region represent histogram red line represent vertical portion outline currently vertical length outline $$$ 4 + 4 + 1 + 3 + 6 = 18 $$$ little dormi modify histogram ugliness would $$$ 18 $$$ however little dormi apply operation column $$$ 2 $$$ twice column $$$ 3 $$$ result a histogram heights $$$ <unknown> $$$ : total vertical length outline ( red line ) $$$ 4 + 3 + 1 + 6=14 $$$ ugliness $$$ 14 + <unknown> $$$ dollars prove optimal test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 400000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 400000 $$$ test case output one integer minimal ugliness little dormi achieve histogram test case example $$$ 1 $$$ example describe statement initial histogram example $$$ 2 $$$ give : ugliness currently $$$ 2 + 1 + 6 + 3 + 4=16 $$$ apply operation column $$$ 1 $$$ six time column $$$ 3 $$$ three time column $$$ 4 $$$ end a histogram heights $$$ <unknown> $$$ : vertical length outline $$$ 1 + 1=2 $$$ little dormi make $$$ 1 + 6 + 3=10 $$$ operations final ugliness $$$ 2 + <unknown> $$$ prove optimal,"['greedy', 'implementation', 'math']",1100.0
1534/G,"annie get bore win every cod contest farm unlimited rat today go farm potatoes instead annie 's garden infinite 2d plane $$$ n $$$ potatoes plant $$$ i $$$ -th potato must plant $$$ ( x_i y_i ) $$$ start point $$$ ( 0 0 ) $$$ annie begin walk one step travel one unit right ( increase $$$ x $$$ $$$ y $$$ coordinate $$$ 1 $$$ respectively ) point $$$ ( x y ) $$$ walk plant potatoes arbitrary point use potato gun consume $$$ \max ( |x - x| |y - y| ) $$$ units energy order plant a potato $$$ ( x y ) $$$ find minimum total energy require plant every potato note annie may plant number potatoes point first line contain integer $$$ n $$$ ( $$$ 1 \le n \le <unknown> $$$ ) next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \le x_i y_i \le 1000000000 $$$ ) represent location $$$ i $$$ -th potato possible potatoes plant location print minimum total energy plant potatoes example $$$ 1 $$$ annie travel spot directly plant a potato energy require example $$$ 2 $$$ move $$$ ( 1,0 ) $$$ annie plant second potato use $$$ 1 $$$ energy next travel $$$ ( 1,1 ) $$$ plant first potato $$$ 0 $$$ energy","['data structures', 'dp']",3300.0
1535/C,give a string $$$ s $$$ consist character 0 1 ? let 's call a string unstable consist character 0 1 two adjacent character different ( i. e. form 010101 ... 101010 ... ) let 's call a string beautiful consist character 0 1 ? replace character ? 0 1 ( character choice independent ) string become unstable example string 0 ? ? 10 0 ? ? ? beautiful string 00 ? 1 ? ? 1 calculate number beautiful contiguous substrings string $$$ s $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain string $$$ s $$$ ( $$$ 1 \le |s| \le 200000 $$$ ) consist character 0 1 ? guarantee sum string lengths test case exceed $$$ 200000 $$$ test case output a single integer — number beautiful substrings string $$$ s $$$,"['dp', 'greedy', 'implementation']",1400.0
1535/F,suppose give two string $$$ a $$$ $$$ b $$$ apply follow operation number time : choose contiguous substring $$$ a $$$ $$$ b $$$ sort character non - descending order let $$$ f ( a b ) $$$ minimum number operations apply order make equal ( $$$ f ( a b ) = 1337 $$$ impossible make $$$ a $$$ $$$ b $$$ equal use operations ) example : give $$$ n $$$ string $$$ s_1 s_2 \dots s_k $$$ equal length calculate $$$ \sum \limits _ { i = 1 } ^ { n } \sum\limits _ { j = i + 1 } ^ { n } f ( s_i s_j ) $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number string $$$ n $$$ line follow line contain one string $$$ s_i $$$ consist lowercase latin letter $$$ |s_1| = |s_2| = \ldots = <unknown> $$$ $$$ n \cdot |s_1| \le 200000 $$$ string pairwise distinct print one integer : $$$ \sum \limits _ { i = 1 } ^ { n } \sum\limits _ { j = i + 1 } ^ { n } f ( s_i s_j ) $$$,"['data structures', 'implementation']",3000.0
1537/B,"riley a bad boy time a yo - yo master , decide use yo - yo skills annoy friend anton anton 's room represent a grid $$$ n $$$ row $$$ m $$$ columns let $$$ ( i j ) $$$ denote cell row $$$ i $$$ column $$$ j $$$ anton currently stand position $$$ ( i j ) $$$ room annoy anton riley decide throw exactly two yo - yos cells room ( cell ) anton n't like yo - yos throw floor pick return back initial position distance travel anton shortest path go position yo - yos return back $$$ ( i j ) $$$ travel adjacent side cells , cell $$$ ( x y ) $$$ travel cells $$$ ( x + 1 y ) $$$ $$$ ( x - 1 y ) $$$ $$$ ( x y + 1 ) $$$ $$$ ( x y - 1 ) $$$ one step ( a cell coordinate exist ) riley wonder throw two yo - yos distance travel anton maximize busy ask tell first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case $$$ t $$$ test case follow line test case contain four integers $$$ n $$$ $$$ m $$$ $$$ i $$$ $$$ j $$$ ( $$$ 1 \leq n m \leq 1000000000 $$$ $$$ 1\le i\le n $$$ $$$ 1\le j\le m $$$ ) — dimension room cell anton currently stand test case print four integers $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \leq x_1 x_2 \leq n $$$ $$$ 1\le y_1 y_2\le m $$$ ) — coordinate two yo - yos throw throw coordinate $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ multiple answer may print a visualization first test case","['greedy', 'math']",900.0
1537/C,a game designer want make obstacle course player walk leave right $$$ n $$$ heights mountains already select want arrange absolute difference heights first last mountains small possible addition want make game difficult since walk uphill flat harder walk downhill difficulty level number mountains $$$ i $$$ ( $$$ 1 \leq i < n $$$ ) $$$ h_i \leq h _ { i+1 } $$$ $$$ h_i $$$ height $$$ i $$$ -th mountain n't want waste mountains model use arrangements minimize $$$ |h_1 - h_n| $$$ find one difficult multiple order satisfy requirements may find first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 200000 $$$ ) — number mountains second line test case contain $$$ n $$$ integers $$$ h_1 \ldots h_n $$$ ( $$$ 1 \leq h_i \leq 1000000000 $$$ ) $$$ h_i $$$ height $$$ i $$$ -th mountain guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output $$$ n $$$ integers — give heights order maximize difficulty score among order minimize $$$ |h_1 - h_n| $$$ multiple order satisfy requirements may output first test case : player begin height $$$ 2 $$$ next go height $$$ 4 $$$ increase difficulty $$$ 1 $$$ go height $$$ 1 $$$ difficulty n't change go downhill finally player go height $$$ 2 $$$ difficulty increase $$$ 1 $$$ absolute difference start height end height equal $$$ 0 $$$ 's minimal difficulty maximal second test case : player begin height $$$ 1 $$$ next go height $$$ 3 $$$ increase difficulty $$$ 1 $$$ absolute difference start height end height equal $$$ 2 $$$ 's minimal heights difficulty maximal,"['greedy', 'implementation', 'math']",1200.0
1538/C,give array $$$ a $$$ $$$ n $$$ integers find number pair $$$ ( i j ) $$$ ( $$$ 1 \le i < j \le n $$$ ) sum $$$ a_i + a_j $$$ greater equal $$$ l $$$ less equal $$$ r $$$ ( $$$ l \le a_i + a_j \le r $$$ ) example $$$ n = 3 $$$ $$$ a = [ 5 1 2 ] $$$ $$$ l = 4 $$$ $$$ r = 7 $$$ two pair suitable : first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) $$$ t $$$ test case follow first line test case contain three integers $$$ n l r $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le l \le r \le 1000000000 $$$ ) — length array limit sum pair second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ overall test case exceed $$$ 200000 $$$ test case output a single integer — number index pair $$$ ( i j ) $$$ ( $$$ i < j $$$ ) $$$ l \le a_i + a_j \le r $$$,"['data structures', 'math']",1300.0
1538/F,give two integers $$$ l $$$ $$$ r $$$ $$$ l < r $$$ add $$$ 1 $$$ $$$ l $$$ result equal $$$ r $$$ thus exactly $$$ r - l $$$ additions perform addition let 's look number digits change example : change digits always form a suffix result write decimal system output total number change digits want get $$$ r $$$ $$$ l $$$ add $$$ 1 $$$ time first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) $$$ t $$$ test case follow test case characterize two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \le l < r \le 1000000000 $$$ ) test case calculate total number change digits want get $$$ r $$$ $$$ l $$$ add one time,"['dp', 'math']",1500.0
1539/F,"vasya array $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ vasya think number array strange reason calculate strange $$$ i $$$ -th number vasya create follow algorithm choose a subsegment $$$ a_l a _ { l+1 } \ldots a_r $$$ $$$ 1 \le l \le i \le r \le n $$$ sort elements increase order head ( arrange equal elements arbitrary ) find center segment center a segment element position $$$ ( l + r ) / 2 $$$ length segment odd position $$$ ( l + r + 1 ) / 2 $$$ otherwise vasya find element position $$$ i $$$ sort calculate distance current position center subsegment ( distance elements indices $$$ j $$$ $$$ k $$$ $$$ |j - k| $$$ ) strangeness number position $$$ i $$$ maximum distance among suitable choices $$$ l $$$ $$$ r $$$ vasya want calculate strangeness number array help first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200\,000 $$$ ) — size array second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — vasya 's array print a single line $$$ n $$$ number $$$ i $$$ -th must equal strangeness $$$ i $$$ -th element array first example :","['data structures', 'greedy']",2600.0
1540/D,play permutation $$$ p $$$ length $$$ n $$$ lose <unknown> <unknown> ! luckily remember information permutation specifically remember array $$$ b $$$ length $$$ n $$$ $$$ b_i $$$ number indices $$$ j $$$ $$$ j < i $$$ $$$ p_j > p_i $$$ array $$$ b $$$ want find permutation $$$ p $$$ however memory n't perfect constantly change value $$$ b $$$ learn next $$$ q $$$ second one follow things happen : answer query remember array ! first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — size permutation second line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 0 \leq b_i < i $$$ ) — initial memory array $$$ b $$$ third line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 100000 $$$ ) — number query next $$$ q $$$ line contain query one follow format : guarantee 's least one query type $$$ 2 $$$ query type $$$ 2 $$$ print one integer — answer query first sample 's initially one possible permutation satisfy constraints : $$$ [ 1 2 3 ] $$$ must $$$ 0 $$$ inversions query type $$$ 1 $$$ array $$$ b $$$ $$$ [ 0 1 0 ] $$$ permutation $$$ p $$$ produce array $$$ [ 2 1 3 ] $$$ permutation $$$ b_2 $$$ equal $$$ 1 $$$ $$$ p_1 > p_2 $$$,['data structures'],3200.0
1540/E,note memory limit unusual $$$ n $$$ chefs number $$$ 1 2 \ldots n $$$ must prepare dish a king chef $$$ i $$$ skill $$$ i $$$ initially a dish tastiness $$$ a_i $$$ $$$ |a_i| \leq i $$$ chef a list chefs allow copy stop chefs learn bad habit king make sure chef $$$ i $$$ copy chefs larger skill a sequence days pass chefs work dish day two stag a chef change tastiness dish chefs work maximize tastiness dish order please king finally give $$$ q $$$ query query one two type note query type $$$ 1 $$$ independent query specifically query type $$$ 1 $$$ a scenario change initial tastiness $$$ a_i $$$ dish future query note query type $$$ 2 $$$ cumulative change initial tastiness $$$ a_i $$$ a dish see note example query first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 300 $$$ ) — number chefs second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -i \le a_i \le i $$$ ) next $$$ n $$$ line begin a integer $$$ c_i $$$ ( $$$ 0 \le c_i < n $$$ ) denote number chefs $$$ i $$$ -th chef copy number follow $$$ c_i $$$ distinct integers $$$ d $$$ ( $$$ i < d \le n $$$ ) <unknown> chef $$$ i $$$ allow copy chef $$$ d $$$ stage $$$ 2 $$$ day next line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query next $$$ q $$$ line contain a query one two type : guarantee least one query first type query first type print a single integer — answer query set chefs chef allow copy : follow a description sample first query type $$$ 1 $$$ initial tastiness value $$$ [ 1 0 -2 -2 4 ] $$$ final result first day show : answer $$$ 1 $$$ -st query $$$ 21 + 0 - 2 + 18 + 20 = 57 $$$ $$$ 5 $$$ -th query ( $$$ 3 $$$ -rd type $$$ 1 $$$ ) initial tastiness value $$$ [ 1 0 0 1 4 ] $$$ day 1 day 2 answer $$$ 5 $$$ -th query $$$ 12 + 108 + <unknown> $$$ show step describe chefs move optimally,['math'],3500.0
1542/C,let $$$ f ( i ) $$$ denote minimum positive integer $$$ x $$$ $$$ x $$$ a divisor $$$ i $$$ compute $$$ \sum _ { i=1 } ^n f ( i ) $$$ modulo $$$ 1000000000 + 7 $$$ word compute $$$ f ( 1 ) + f ( 2 ) + <unknown> ( n ) $$$ modulo $$$ 1000000000 + 7 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 10000 $$$ ) number test case $$$ t $$$ case follow line test case contain a single integer $$$ n $$$ ( $$$ 1\leq n\leq 10^ { 16 } $$$ ) test case output a single integer $$$ ans $$$ $$$ <unknown> _ { i=1 } ^n f ( i ) $$$ modulo $$$ 1000000000 + 7 $$$ fourth test case $$$ n=4 $$$ $$$ ans = f ( 1 ) + f ( 2 ) + f ( 3 ) + f ( 4 ) $$$ therefore $$$ ans = f ( 1 ) + f ( 2 ) + f ( 3 ) + f ( 4 ) = 2 + 3 + 2 + 3=10 $$$,['math'],1600.0
1542/D,"give a sequence $$$ a $$$ elements either form + x - $$$ x $$$ integer a sequence $$$ s $$$ elements either form + x - define $$$ f ( s ) $$$ follow : sequence $$$ b $$$ a subsequence sequence $$$ a $$$ $$$ b $$$ derive $$$ a $$$ remove zero elements without change order remain elements $$$ a $$$ 's subsequences $$$ b $$$ compute sum $$$ f ( b ) $$$ modulo $$$ 998\,244\,353 $$$ first line contain integer $$$ n $$$ ( $$$ 1\leq n\leq 500 $$$ ) — length $$$ a $$$ next $$$ n $$$ line begin operator + - operator + 's follow integer $$$ x $$$ ( $$$ 1\le x < 998\,244\,353 $$$ ) $$$ i $$$ -th line $$$ n $$$ line describe $$$ i $$$ -th element $$$ a $$$ print one integer answer problem modulo $$$ 998\,244\,353 $$$ first example follow possible pair $$$ b $$$ $$$ f ( b ) $$$ : sum value $$$ 16 $$$","['dp', 'implementation', 'math']",2200.0
1543/B,"highway 201 busy street rockport traffic cars cause a lot <unknown> race especially a lot track pass highway divide $$$ n $$$ sub - <unknown> give array $$$ a $$$ $$$ a_i $$$ represent number traffic cars $$$ i $$$ -th sub - track define inconvenience track $$$ \sum\limits _ { i=1 } ^ { n } \sum\limits _ { j = i+1 } ^ { n } \lvert a_i - <unknown> $$$ $$$ |x| $$$ absolute value $$$ x $$$ perform follow operation ( possibly zero ) number time : choose a traffic car move current sub - track sub - track find minimum inconvenience achieve first line input contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 10\,000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1\leq n\leq 2\cdot 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0\leq a_i\leq 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case print a single line contain a single integer : minimum inconvenience achieve apply give operation ( possibly zero ) number time first test case move a car $$$ 3 $$$ -rd sub - track $$$ 1 $$$ -st sub - track obtain $$$ 0 $$$ inconvenience second test case move car wo n't decrease inconvenience track","['greedy', 'math']",900.0
1545/B,"cirno give aquamoon a chessboard size $$$ 1 \times n $$$ cells number integers $$$ 1 $$$ $$$ n $$$ leave right begin cells occupy one pawn cells unoccupied operation aquamoon choose a cell $$$ i $$$ a pawn either follow ( possible ) : give initial state chessboard aquamoon want count number state reachable initial state sequence operations good program help ? answer large find modulo $$$ 998\,244\,353 $$$ input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10\,000 $$$ ) — number test case first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — size chessboard second line contain a string $$$ n $$$ character consist character ` ` 0 '' ` ` 1 '' $$$ i $$$ -th character ` ` 1 '' $$$ i $$$ -th cell initially occupy ; otherwise $$$ i $$$ -th cell initially unoccupied guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print number state reachable initial state sequence operations modulo $$$ 998\,244\,353 $$$ first test case string ` ` 1100 '' ` ` 0110 '' ` ` 0011 '' reachable initial state sequence operations",['math'],1900.0
1545/D,"cirno give aquamoon a problem $$$ m $$$ people number $$$ 0 $$$ $$$ m - 1 $$$ stand a coordinate axis point positive integer coordinate face right ( i.e direction coordinate increase ) moment everyone start run constant speed direction coordinate increase initial coordinate $$$ i $$$ -th person line $$$ x_i $$$ speed $$$ i $$$ -th person $$$ v_i $$$ coordinate $$$ i $$$ -th person moment $$$ t $$$ $$$ x_i + t \cdot v_i $$$ cirno capture coordinate $$$ m $$$ people $$$ k $$$ consecutive integer moments $$$ 0 $$$ $$$ k - 1 $$$ every moment coordinate $$$ m $$$ people record arbitrary order make problem funny cirno modify one coordinate moment $$$ y $$$ ( $$$ 0 < y < k-1 $$$ ) a different integer aquamoon want find moment $$$ y $$$ original coordinate $$$ p $$$ modification actually a programmer n't able solve help ? problem make interactive mean solution read input give interactor interactor give full input begin print answer solve problem like solve usual non - interactive problem wo n't interaction process thing forget flush output buffer print answer otherwise get ` ` idleness limit exceed '' verdict refer interactive problems guide detail information flush output buffer first line contain two integers $$$ m $$$ $$$ k $$$ ( $$$ 5 \leq m \leq 1000 $$$ $$$ 7 \leq k \leq 1000 $$$ ) — number people number record moments next $$$ k $$$ line contain capture position $$$ i $$$ -th line contain $$$ m $$$ integers $$$ 1 $$$ $$$ 1000000 $$$ ( inclusive ) represent position capture cirno moment $$$ i-1 $$$ input guarantee valid ( i.e one integer modify a different value accord problem statement ) also guarantee $$$ 1 \le v_i \le 1000 $$$ $$$ 1 \leq i \leq m $$$ hack format : first line contain two integers $$$ m $$$ $$$ k $$$ ( $$$ 5 \leq m \leq 1000 $$$ $$$ 7 \leq k \leq 1000 $$$ ) — number people number moments second line $$$ m $$$ integers $$$ x_0 x_1 \dots x _ { m - 1 } $$$ ( $$$ 1 \le x_i \le 1000000 $$$ ) $$$ x_i $$$ initial coordinate $$$ i $$$ -th person third line $$$ m $$$ integers $$$ <unknown> v_1 \dots v _ { m - 1 } $$$ ( $$$ 1 \le v_i \le 1000 $$$ ) $$$ v_i $$$ speed $$$ i $$$ -th person true $$$ x_i + ( k-1 ) v_i \leq 1000000 $$$ $$$ 0 \leq i < m $$$ next $$$ k $$$ line line contain $$$ m $$$ integers $$$ i $$$ -th line contain $$$ m $$$ distinct integers $$$ p_0 p_1 \ldots p _ { m-1 } $$$ ( $$$ 0 \leq p_j < m $$$ ) mean number : $$$ j $$$ -th integer input $$$ i $$$ -th moment coordinate $$$ p _ { j } $$$ -th person last line three integers $$$ y $$$ $$$ i $$$ $$$ c $$$ cirno modify coordinate $$$ i $$$ -th person moment $$$ y $$$ $$$ c $$$ ( $$$ 1 \leq y \leq k-2 $$$ $$$ 0 \leq i \leq m - 1 $$$ $$$ 1 \leq c \leq 1000000 $$$ $$$ c \neq x_i + y \cdot v_i $$$ ) print a single line two integers $$$ y $$$ $$$ p $$$ — moment contain modify coordinate original coordinate first test initial coordinate people $$$ 9 $$$ $$$ 6 $$$ $$$ 6 $$$ $$$ 9 $$$ $$$ 9 $$$ speed $$$ 1 $$$ $$$ 2 $$$ $$$ 1 $$$ $$$ 1 $$$ $$$ 1 $$$ , 's easy see moment $$$ 4 $$$ one coordinate modify $$$ 13 $$$ $$$ 12 $$$ first test hack format :",['math'],3000.0
1545/E1,note differences easy hard versions constraints $$$ n $$$ time limit make hack versions solve aquamoon know foresight ghost want curse tourists a pedestrian street unfortunately time ghost hide a barrier could n't enter barrier a short time destroy therefore do save unfortunate person street ghost pedestrian street represent a one - dimensional coordinate system one person hang pedestrian street time $$$ 0 $$$ coordinate $$$ x $$$ move a speed $$$ 1 $$$ unit per second particular time $$$ i $$$ person coordinate $$$ x+i $$$ ghost go cast $$$ n $$$ curse street $$$ i $$$ -th curse last time $$$ tl_i-1 + 10^ { -18 } $$$ time $$$ tr_i+1 - 10^ { -18 } $$$ ( exclusively ) kill people coordinate $$$ l_i-1 + 10^ { -18 } $$$ $$$ r_i+1 - 10^ { -18 } $$$ ( exclusively ) formally mean person whose coordinate $$$ ( l_i-1 + 10^ { -18 } r_i+1 - 10^ { -18 } ) $$$ time range $$$ ( tl_i-1 + 10^ { -18 } tr_i+1 - 10^ { -18 } ) $$$ die save person street aquamoon stop time moment $$$ t $$$ move person current coordinate $$$ x $$$ coordinate $$$ y $$$ ( $$$ t $$$ $$$ x $$$ $$$ y $$$ necessarily integers ) movement cost aquamoon $$$ |x - y| $$$ energy movement continuous exist curse area point $$$ x $$$ $$$ y $$$ time $$$ t $$$ person die aquamoon want know minimum amount energy need spend order save person street $$$ n $$$ curse good program friend help ? first line contain a single integer $$$ n $$$ ( $$$ 1\le n\le 2000 $$$ ) — number curse next line contain a single integer $$$ x $$$ ( $$$ 1\le x\le 1000000 $$$ ) — initial coordinate person follow $$$ n $$$ line contain four integers $$$ tl_i $$$ $$$ tr_i $$$ $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1\le tl_i\le tr_i\le 1000000 $$$ $$$ 1\le l_i\le r_i\le 1000000 $$$ ) print a single integer — minimum energy aquamoon need spend round nearest integer ( case two nearest integers round answer highest ),"['data structures', 'dp']",3500.0
1545/E2,note differences easy hard versions constraints $$$ n $$$ time limit make hack versions solve aquamoon know foresight ghost want curse tourists a pedestrian street unfortunately time ghost hide a barrier could n't enter barrier a short time destroy therefore do save unfortunate person street ghost pedestrian street represent a one - dimensional coordinate system one person hang pedestrian street time $$$ 0 $$$ coordinate $$$ x $$$ move a speed $$$ 1 $$$ unit per second particular time $$$ i $$$ person coordinate $$$ x+i $$$ ghost go cast $$$ n $$$ curse street $$$ i $$$ -th curse last time $$$ tl_i-1 + 10^ { -18 } $$$ time $$$ tr_i+1 - 10^ { -18 } $$$ ( exclusively ) kill people coordinate $$$ l_i-1 + 10^ { -18 } $$$ $$$ r_i+1 - 10^ { -18 } $$$ ( exclusively ) formally mean person whose coordinate $$$ ( l_i-1 + 10^ { -18 } r_i+1 - 10^ { -18 } ) $$$ time range $$$ ( tl_i-1 + 10^ { -18 } tr_i+1 - 10^ { -18 } ) $$$ die save person street aquamoon stop time moment $$$ t $$$ move person current coordinate $$$ x $$$ coordinate $$$ y $$$ ( $$$ t $$$ $$$ x $$$ $$$ y $$$ necessarily integers ) movement cost aquamoon $$$ |x - y| $$$ energy movement continuous exist curse area point $$$ x $$$ $$$ y $$$ time $$$ t $$$ person die aquamoon want know minimum amount energy need spend order save person street $$$ n $$$ curse good program friend help ? first line contain a single integer $$$ n $$$ ( $$$ 1\le n\le 200000 $$$ ) — number curse next line contain a single integer $$$ x $$$ ( $$$ 1\le x\le 1000000 $$$ ) — initial coordinate person follow $$$ n $$$ line contain four integers $$$ tl_i $$$ $$$ tr_i $$$ $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1\le tl_i\le tr_i\le 1000000 $$$ $$$ 1\le l_i\le r_i\le 1000000 $$$ ) print a single integer — minimum energy aquamoon need spend round nearest integer ( case two nearest integers round answer highest ),"['data structures', 'dp']",3500.0
1547/A,three cells infinite 2 - dimensional grid label $$$ a $$$ $$$ b $$$ $$$ f $$$ find length shortest path $$$ a $$$ $$$ b $$$ : first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case input $$$ t $$$ test case follow test case empty line test case contain three line first one contain two integers $$$ x_a y_a $$$ ( $$$ 1 \le x_a y_a \le 1000 $$$ ) — coordinate start cell $$$ a $$$ second one contain two integers $$$ x_b y_b $$$ ( $$$ 1 \le x_b y_b \le 1000 $$$ ) — coordinate finish cell $$$ b $$$ third one contain two integers $$$ x_f y_f $$$ ( $$$ 1 \le x_f y_f \le 1000 $$$ ) — coordinate forbid cell $$$ f $$$ cells distinct coordinate $$$ x $$$ correspond column number coordinate $$$ y $$$ correspond row number ( see picture ) output $$$ t $$$ line $$$ i $$$ -th line contain answer $$$ i $$$ -th test case : length shortest path cell $$$ a $$$ cell $$$ b $$$ cell $$$ f $$$ allow visit,"['implementation', 'math']",800.0
1547/E,a strip land length $$$ n $$$ $$$ k $$$ air conditioners : $$$ i $$$ -th air conditioner place cell $$$ a_i $$$ ( $$$ 1 \le a_i \le n $$$ ) two air conditioners place cell ( i.e $$$ a_i $$$ distinct ) air conditioner characterize one parameter : temperature $$$ i $$$ -th air conditioner set temperature $$$ t_i $$$ cell $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) find 's temperature calculate formula $$$ $$$ \min _ { 1 \le j \le k } ( t_j + |a_j - i| ) $$$ $$$ $$$ |a_j - i| $$$ denote absolute value difference $$$ a_j - i $$$ word temperature cell $$$ i $$$ equal minimum among temperatures air conditioners increase distance cell $$$ i $$$ let 's look example consider $$$ n=6 k=2 $$$ first air conditioner place cell $$$ a_1=2 $$$ set temperature $$$ <unknown> $$$ second air conditioner place cell $$$ a_2=5 $$$ set temperature $$$ <unknown> $$$ case temperatures cells : cell $$$ 1 $$$ $$$ n $$$ find temperature first line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 10000 $$$ ) — number test case input test case follow test case empty line test case contain three line first line contain two integers $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) — length strip land number air conditioners respectively second line contain $$$ k $$$ integers $$$ a_1 a_2 \ldots a_k $$$ ( $$$ 1 \le a_i \le n $$$ ) — position air conditioners strip land third line contain $$$ k $$$ integers $$$ t_1 t_2 \ldots t_k $$$ ( $$$ 1 \le t_i \le 1000000000 $$$ ) — temperatures air conditioners guarantee sum $$$ n $$$ test case exceed $$$ 300000 $$$ test case output $$$ n $$$ integers separate space : temperatures air cells,"['data structures', 'dp', 'implementation']",1500.0
1548/B,"<unknown> mathematician john <unknown> say indian mathematician <unknown> <unknown> ` ` every positive integer one personal friends ` ` turn positive integers also friends ! give array $$$ a $$$ distinct positive integers define a subarray $$$ a_i a _ { i+1 } \ldots a_j $$$ a friend group exist integer $$$ m \ge 2 $$$ $$$ a_i \bmod m = a _ { i+1 } \bmod m = \ldots = a_j \bmod m $$$ $$$ x \bmod y $$$ denote remainder $$$ x $$$ divide $$$ y $$$ friend gregor want know size largest friend group $$$ a $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 2\cdot 10000 $$$ ) test case begin a line contain integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) size array $$$ a $$$ next line contain $$$ n $$$ positive integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le { 10 } ^ { 18 } $$$ ) represent content array $$$ a $$$ guarantee number $$$ a $$$ distinct guarantee sum $$$ n $$$ test case less $$$ 2\cdot 100000 $$$ output consist $$$ t $$$ line line consist a single integer size largest friend group $$$ a $$$ first test case array $$$ [ <unknown> ] $$$ largest friend group $$$ [ 2,4,6 ] $$$ since number congruent $$$ 0 $$$ modulo $$$ 2 $$$ $$$ m=2 $$$ second test case array $$$ [ <unknown> ] $$$ largest friend group $$$ [ <unknown> ] $$$ since number congruent $$$ 2 $$$ modulo $$$ 3 $$$ $$$ m=3 $$$ third case largest friend group $$$ [ <unknown> ] $$$ clearly many possible value $$$ m $$$ work","['data structures', 'math']",1800.0
1548/C,"three little pig world meet a convention ! every minute a triple 3 new pig arrive convention floor $$$ n $$$ -th minute convention end big bad wolf learn convention attack plan minute convention arrive eat exactly $$$ x $$$ pig get away wolf want gregor help figure number possible attack plan involve eat exactly $$$ x $$$ pig various value $$$ x $$$ ( $$$ 1 \le x \le 3n $$$ ) two attack plan consider different occur different time set little pig eat different note query independent , wolf eat little pig make plan ! first line input contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n \le 1000000 $$$ $$$ 1 \le q \le 2\cdot 100000 $$$ ) number minutes convention last number query wolf ask next $$$ q $$$ line contain a single integer $$$ x_i $$$ ( $$$ 1 \le x_i \le 3n $$$ ) number pig wolf eat $$$ i $$$ -th query print $$$ q $$$ line line $$$ i $$$ represent number attack plan wolf want eat $$$ x_i $$$ pig since query answer large output answer modulo $$$ 1000000000 + 7 $$$ example test $$$ n=2 $$$ thus $$$ 3 $$$ pig minute $$$ 1 $$$ $$$ 6 $$$ pig minute $$$ 2 $$$ three query : $$$ x=1 $$$ $$$ x=5 $$$ $$$ <unknown> $$$ wolf want eat $$$ 1 $$$ pig $$$ 3 + <unknown> $$$ possible attack plan depend whether arrive minute $$$ 1 $$$ $$$ 2 $$$ wolf want eat $$$ 5 $$$ pig wolf arrive minute $$$ 1 $$$ since n't enough pig time therefore wolf arrive minute $$$ 2 $$$ $$$ 6 $$$ possible attack plan wolf want eat $$$ 6 $$$ pig plan arrive end convention <unknown> everybody remember output answer modulo $$$ 1000000000 + 7 $$$ !","['dp', 'math']",2500.0
1550/A,let 's call array $$$ a $$$ consist $$$ n $$$ positive ( greater $$$ 0 $$$ ) integers beautiful follow condition hold every $$$ i $$$ $$$ 1 $$$ $$$ n $$$ : either $$$ a_i = 1 $$$ least one number $$$ a_i - 1 $$$ $$$ a_i - 2 $$$ exist array well example : give a positive integer $$$ s $$$ find minimum possible size a beautiful array sum elements equal $$$ s $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) — number test case $$$ t $$$ line follow $$$ i $$$ -th line contain one integer $$$ s $$$ ( $$$ 1 \le s \le 5000 $$$ ) $$$ i $$$ -th test case print $$$ t $$$ integers $$$ i $$$ -th integer answer $$$ i $$$ -th testcase : minimum possible size a beautiful array sum elements equal $$$ s $$$ consider example test :,"['greedy', 'math']",800.0
1550/C,suppose two point $$$ p = ( x_p y_p ) $$$ $$$ q = ( x_q <unknown> ) $$$ let 's denote manhattan distance $$$ d ( p q ) = <unknown> - <unknown> + <unknown> - <unknown> $$$ let 's say three point $$$ p $$$ $$$ q $$$ $$$ r $$$ form a bad triple $$$ d ( p r ) = d ( p q ) + d ( q r ) $$$ let 's say array $$$ b_1 b_2 \dots b_m $$$ good impossible choose three distinct indices $$$ i $$$ $$$ j $$$ $$$ k $$$ point $$$ ( b_i i ) $$$ $$$ ( b_j j ) $$$ $$$ ( b_k k ) $$$ form a bad triple give array $$$ a_1 a_2 \dots a_n $$$ calculate number good subarrays $$$ a $$$ a subarray array $$$ a $$$ array $$$ a_l a _ { l + 1 } \dots a_r $$$ $$$ 1 \le l \le r \le n $$$ note accord definition subarrays length $$$ 1 $$$ $$$ 2 $$$ good first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) — number test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) 's guarantee sum $$$ n $$$ n't exceed $$$ 200000 $$$ test case print number good subarrays array $$$ a $$$ first test case prove subarray $$$ a $$$ good example subarray $$$ [ a_2 a_3 a_4 ] $$$ good since contain three elements : second test case example subarray $$$ [ a_1 a_2 a_3 a_4 ] $$$ good since contain a bad triple $$$ ( a_1 1 ) $$$ $$$ ( a_2 2 ) $$$ $$$ ( a_4 4 ) $$$ : $$$ d ( ( a_1 1 ) ( a_4 4 ) ) = d ( ( a_1 1 ) ( a_2 2 ) ) + d ( ( a_2 2 ) ( a_4 4 ) ) $$$,"['greedy', 'implementation']",1700.0
1551/B2,problem extension problem ` ` wonderful color - 1 '' quite many differences read statement completely recently paul mary find a new favorite sequence integers $$$ a_1 a_2 \dots a_n $$$ want paint use piece <unknown> $$$ k $$$ color color a sequence call wonderful follow condition meet : e. g. consider a sequence $$$ a= [ 3 1 1 1 1 10 3 10 10 2 ] $$$ $$$ k=3 $$$ one wonderful color sequence show figure help paul mary find a wonderful color a give sequence $$$ a $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow test case consist two line first one contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 2\cdot100000 $$$ $$$ 1 \le k \le n $$$ ) — length a give sequence number color respectively second one contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ output $$$ t $$$ line must contain a description a wonderful color correspond test case wonderful color must print a sequence $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 0 \le c_i \le k $$$ ) separate space <unknown> need maximize total count paint elements wonderful color multiple solutions print one first test case answer show figure statement red color number $$$ 1 $$$ blue color — $$$ 2 $$$ green — $$$ 3 $$$,"['data structures', 'greedy']",1400.0
1551/C,stephen queen want write a story a unusual writer use letter ' a ' ' b ' ' c ' 'd ' ' e ' ! compose a story stephen write $$$ n $$$ word consist first $$$ 5 $$$ lowercase letter latin alphabet want select maximum number word make interest story let a story a sequence word necessarily different a story call interest exist a letter occur among word story time letter together example story consist three word ` ` bac '' ` ` aaada '' ` ` e '' interest ( letter ' a ' occur $$$ 5 $$$ time letter occur $$$ 4 $$$ time total ) story consist two word ` ` aba '' ` ` abcde '' ( letter occur letter total ) give a sequence $$$ n $$$ word consist letter ' a ' ' b ' ' c ' 'd ' ' e ' task choose maximum number make interest story 's way make a non - empty story output $$$ 0 $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number word sequence $$$ n $$$ line follow contain a word — a non - empty string consist lowercase letter latin alphabet word sequence may non - distinct ( i. e. duplicate allow ) letter ' a ' ' b ' ' c ' 'd ' ' e ' may occur word guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ ; sum lengths word test case n't exceed $$$ 400000 $$$ test case output maximum number word compose interest story print 0 's way make a non - empty interest story first test case example $$$ 3 $$$ word use make interest story interest story ` ` bac aaada e '' second test case example $$$ 1 $$$ -st $$$ 3 $$$ -rd word use make interest story interest story ` ` aba aba '' stephen ca n't use three word time third test case example stephen ca n't make a non - empty interest story answer $$$ 0 $$$ fourth test case example stephen use $$$ 3 $$$ -rd $$$ 4 $$$ -th word make interest story interest story ` ` c bc '',['greedy'],1500.0
1552/F,"ant move real line constant speed $$$ 1 $$$ unit per second start $$$ 0 $$$ always move right ( position increase $$$ 1 $$$ second ) $$$ n $$$ portals $$$ i $$$ -th locate position $$$ x_i $$$ teleport position $$$ y_i < x_i $$$ portal either active inactive initial state $$$ i $$$ -th portal determine $$$ s_i $$$ : $$$ s_i=0 $$$ $$$ i $$$ -th portal initially inactive $$$ s_i=1 $$$ $$$ i $$$ -th portal initially active ant travel a portal ( i.e. position coincide position a portal ) : long ( instant start move ) take ant reach position $$$ x_n + 1 $$$ ? show happen a finite amount time since answer may large compute modulo $$$ 998\,244\,353 $$$ first line contain integer $$$ n $$$ ( $$$ 1\le n\le 2\cdot 100000 $$$ ) — number portals $$$ i $$$ -th next $$$ n $$$ line contain three integers $$$ x_i $$$ $$$ y_i $$$ $$$ s_i $$$ ( $$$ 1\le y_i < x_i\le 1000000000 $$$ $$$ <unknown> { 0,1\ } $$$ ) — position $$$ i $$$ -th portal position ant teleport travel $$$ i $$$ -th portal ( active ) initial state $$$ i $$$ -th portal position portals strictly increase $$$ x_1 < x_2 < \cdots < x_n $$$ guarantee $$$ 2n $$$ integers $$$ x_1 \ x_2 \ \dots \ x_n \ y_1 \ y_2 \ \dots \ y_n $$$ distinct output amount time elapse second instant ant start move instant reach position $$$ <unknown> $$$ since answer may large output modulo $$$ 998\,244\,353 $$$ explanation first sample : ant move follow ( a curvy arrow denote a teleport a straight arrow denote normal movement speed $$$ 1 $$$ time spend movement write arrow ) $$$ $$$ 0 \stackrel { 6 } { \longrightarrow } 6 \leadsto 5 \stackrel { 3 } { \longrightarrow } 8 \leadsto 1 \stackrel { 2 } { \longrightarrow } 3 \leadsto 2 \stackrel { 4 } { \longrightarrow } 6 \leadsto 5 \stackrel { 2 } { \longrightarrow } 7 \leadsto 4 \stackrel { 2 } { \longrightarrow } 6 \leadsto 5 \stackrel { 4 } { \longrightarrow } 9 $$$ $$$ notice total time $$$ 6 + 3 + 2 + 4 + 2 + 2 + <unknown> $$$ explanation second sample : ant move follow ( a curvy arrow denote a teleport a straight arrow denote normal movement speed $$$ 1 $$$ time spend movement write arrow ) $$$ $$$ 0 \stackrel { 454971987 } { \longrightarrow } 454971987 \leadsto <unknown> \stackrel { <unknown> } { \longrightarrow } <unknown> $$$ $$$ notice total time $$$ 454971987 + <unknown> $$$ explanation third sample : since portals initially ant teleport go straight $$$ 0 $$$ $$$ <unknown> + <unknown> $$$","['data structures', 'dp']",2200.0
1553/A,let 's define $$$ s ( x ) $$$ sum digits number $$$ x $$$ write decimal system example $$$ s ( 5 ) = 5 $$$ $$$ s ( 10 ) = 1 $$$ $$$ s ( <unknown> ) = 7 $$$ call integer $$$ x $$$ interest $$$ s ( x + 1 ) < s ( x ) $$$ test give one integer $$$ n $$$ task calculate number integers $$$ x $$$ $$$ 1 \le x \le n $$$ $$$ x $$$ interest first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case $$$ t $$$ line follow $$$ i $$$ -th line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) $$$ i $$$ -th test case print $$$ t $$$ integers $$$ i $$$ -th answer $$$ i $$$ -th test case first interest number equal $$$ 9 $$$,['math'],800.0
1553/F,array $$$ a $$$ consist $$$ n $$$ distinct positive integers number $$$ 1 $$$ $$$ n $$$ define $$$ p_k $$$ $$$ $$$ p_k = \sum _ { 1 \le i j \le k } a_i \bmod a_j $$$ $$$ $$$ x \bmod y $$$ denote remainder $$$ x $$$ divide $$$ y $$$ find print $$$ p_1 p_2 \ldots p_n $$$ first line contain $$$ n $$$ — length array ( $$$ 2 \le n \le 200000 $$$ ) second line contain $$$ n $$$ space - separated distinct integers $$$ a_1 \ldots a_n $$$ ( $$$ 1 \le a_i \le 300000 $$$ $$$ a_i \neq a_j $$$ $$$ i \neq j $$$ ) print $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$,"['data structures', 'math']",2300.0
1556/H,william really like puzzle kit one birthdays friends gift a complete undirected edge - weighted graph consist $$$ n $$$ vertices want build a span tree graph first $$$ k $$$ vertices follow condition satisfy : degree a vertex index $$$ i $$$ exceed $$$ d_i $$$ vertices $$$ k + 1 $$$ $$$ n $$$ may degree william want find minimum weight a span tree satisfy condition a span tree a subset edge a graph form a tree $$$ n $$$ vertices graph weight a span tree define sum weight edge include a span tree first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \leq n \leq 50 $$$ $$$ 1 \leq k \leq min ( n - 1 5 ) $$$ ) second line contain $$$ k $$$ integers $$$ d_1 d_2 \ldots d_k $$$ ( $$$ 1 \leq d_i \leq n $$$ ) $$$ i $$$ -th next $$$ n - 1 $$$ line contain $$$ n - i $$$ integers $$$ w _ { i i+1 } w _ { i i+2 } \ldots w _ { i n } $$$ ( $$$ 1 \leq w _ { i j } \leq 100 $$$ ) : weight edge $$$ ( i i+1 ) ( i i+2 ) \ldots ( i n ) $$$ print one integer : minimum weight a span tree give degree constraints first $$$ k $$$ vertices,"['greedy', 'math']",3300.0
1557/A,"ezzat array $$$ n $$$ integers ( maybe negative ) want split two non - empty subsequences $$$ a $$$ $$$ b $$$ every element array belong exactly one subsequence value $$$ f ( a ) + f ( b ) $$$ maximum possible value $$$ f ( x ) $$$ average subsequence $$$ x $$$ a sequence $$$ x $$$ a subsequence a sequence $$$ y $$$ $$$ x $$$ obtain $$$ y $$$ deletion several ( possibly zero ) elements average a subsequence sum number subsequence divide size subsequence example average $$$ [ 1,5,6 ] $$$ $$$ ( 1 + 5 + 6 ) <unknown> = <unknown> = 4 $$$ $$$ f ( [ 1,5,6 ] ) = 4 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case consist two line first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 3\cdot100000 $$$ test case print a single value — maximum value ezzat achieve answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -6 } $$$ first test case array $$$ [ 3 1 2 ] $$$ possible ways split array : second test case array $$$ [ -7 -6 -6 ] $$$ possible ways split array :",['math'],800.0
1557/C,"moamen ezzat play a game create array $$$ a $$$ $$$ n $$$ non - negative integers every element less $$$ 2^k $$$ moamen win $$$ a_1 \ \ & \ a_2 \ \ & \ a_3 \ \ & \ \ldots \ \ & \ a_n \ge a_1 \oplus a_2 \oplus a_3 \oplus \ldots \oplus a_n $$$ $$$ \ & $$$ denote bitwise operation $$$ \oplus $$$ denote bitwise xor operation please calculate number win moamen array $$$ a $$$ result may large print value modulo $$$ 1\,000\,000\,007 $$$ ( $$$ 1000000000 + 7 $$$ ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 5 $$$ ) — number test case test case consist one line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n\le 2\cdot 100000 $$$ $$$ 0 \le k \le 2\cdot 100000 $$$ ) test case print a single value — number different array moamen win print result modulo $$$ 1\,000\,000\,007 $$$ ( $$$ 1000000000 + 7 $$$ ) first example $$$ n = 3 $$$ $$$ k = 1 $$$ a result possible array $$$ [ 0,0,0 ] $$$ $$$ [ 0,0,1 ] $$$ $$$ [ 0,1,0 ] $$$ $$$ [ 1,0,0 ] $$$ $$$ [ 1,1,0 ] $$$ $$$ [ 0,1,1 ] $$$ $$$ [ 1,0,1 ] $$$ $$$ [ 1,1,1 ] $$$ moamen win $$$ 5 $$$ : $$$ [ 0,0,0 ] $$$ $$$ [ 1,1,0 ] $$$ $$$ [ 0,1,1 ] $$$ $$$ [ 1,0,1 ] $$$ $$$ [ 1,1,1 ] $$$","['dp', 'math']",1700.0
1558/D,"consider insertion sort algorithm use sort integer sequence $$$ [ a_1 a_2 \ldots a_n ] $$$ length $$$ n $$$ non - decreasing order $$$ i $$$ order $$$ 2 $$$ $$$ n $$$ follow $$$ a_i \ge a _ { i-1 } $$$ nothing move next value $$$ i $$$ otherwise find smallest $$$ j $$$ $$$ a_i < a_j $$$ shift elements position $$$ j $$$ $$$ i-1 $$$ one position right write initial value $$$ a_i $$$ position $$$ j $$$ case 'll say perform insertion element position $$$ i $$$ position $$$ j $$$ notice process $$$ i $$$ prefix sequence $$$ [ a_1 a_2 \ldots a_i ] $$$ sort non - decreasing order therefore algorithm indeed sort sequence example sort $$$ [ 4 5 3 1 3 ] $$$ proceed follow : give integer $$$ n $$$ a list $$$ m $$$ integer pair $$$ ( x_i y_i ) $$$ interest sequence sort use algorithm exactly $$$ m $$$ insertions perform : first position $$$ x_1 $$$ position $$$ y_1 $$$ position $$$ x_2 $$$ position $$$ y_2 $$$ ... finally position $$$ x_m $$$ position $$$ y_m $$$ many sequence length $$$ n $$$ consist ( necessarily distinct ) integers $$$ 1 $$$ $$$ n $$$ inclusive satisfy condition ? print number modulo $$$ 998\,244\,353 $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ ; $$$ 0 \le m < n $$$ ) — length sequence number insertions $$$ i $$$ -th follow $$$ m $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 2 \le x_1 < x_2 < \ldots < x_m \le n $$$ ; $$$ 1 \le y_i < x_i $$$ ) line describe sequence insertions chronological order guarantee sum $$$ m $$$ test case exceed $$$ 200000 $$$ note constraint sum $$$ n $$$ kind test case print number sequence length $$$ n $$$ consist integers $$$ 1 $$$ $$$ n $$$ sort describe algorithm produce give sequence insertions modulo $$$ 998\,244\,353 $$$ first test case algorithm perform insertions — therefore initial sequence already sort non - decreasing order $$$ 10 $$$ sequence : $$$ [ 1 1 1 ] [ 1 1 2 ] [ 1 1 3 ] [ 1 2 2 ] [ 1 2 3 ] [ 1 3 3 ] [ 2 2 2 ] [ 2 2 3 ] [ 2 3 3 ] [ 3 3 3 ] $$$ second test case sequence satisfy condition $$$ [ 3 2 1 ] $$$ third test case $$$ [ 4 5 3 1 3 ] $$$ one seek sequence",['data structures'],2600.0
1561/C,a certain video game player control a hero characterize a single integer value : power hero beat monsters also characterize a single integer value : armor current level hero face $$$ n $$$ cave pass level hero must enter cave order cave exactly exit every cave safe sound hero enter cave $$$ i $$$ fight $$$ k_i $$$ monsters a row : first a monster armor $$$ a _ { i 1 } $$$ a monster armor $$$ a _ { i 2 } $$$ finally a monster armor $$$ a _ { i k_i } $$$ hero beat a monster hero 's power strictly greater monster 's armor hero ca n't beat monster 's fight game end player lose note hero enter a cave ca n't exit fight monsters strictly give order time hero beat a monster hero 's power increase $$$ 1 $$$ find smallest possible power hero must start level able enter cave order beat monsters test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number cave $$$ i $$$ -th next $$$ n $$$ line contain integer $$$ k_i $$$ ( $$$ 1 \le k_i \le 100000 $$$ ) — number monsters $$$ i $$$ -th cave follow $$$ k_i $$$ integers $$$ a _ { i 1 } a _ { i 2 } \ldots a _ { i k_i } $$$ ( $$$ 1 \le a _ { i j } \le 1000000000 $$$ ) — armor level monsters cave $$$ i $$$ order hero fight guarantee sum $$$ k_i $$$ test case exceed $$$ 100000 $$$ test case print a single integer — smallest possible power hero must start level able enter cave order beat monsters first test case hero beat a single monster armor $$$ 42 $$$ 's enough power $$$ 43 $$$ achieve second test case hero pass level initial power $$$ 13 $$$ follow :,['greedy'],1300.0
1561/D1,version problem differ next one constraint $$$ n $$$ note memory limit problem lower others a vertical strip $$$ n $$$ cells number consecutively $$$ 1 $$$ $$$ n $$$ top bottom also a token initially place cell $$$ n $$$ move token arrive cell $$$ 1 $$$ let token cell $$$ x > 1 $$$ moment one shift token either follow kinds : find number ways move token cell $$$ n $$$ cell $$$ 1 $$$ use one shift print modulo $$$ m $$$ note several ways move token one cell another one shift ways consider distinct ( check example explanation a better understand ) line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ ; $$$ 100000000 < m < 1000000000 $$$ ; $$$ m $$$ a prime number ) — length strip modulo print number ways move token cell $$$ n $$$ cell $$$ 1 $$$ modulo $$$ m $$$ first test three ways move token cell $$$ 3 $$$ cell $$$ 1 $$$ one shift : use subtraction $$$ y = 2 $$$ use division $$$ z = 2 $$$ $$$ z = 3 $$$ also two ways move token cell $$$ 3 $$$ cell $$$ 1 $$$ via cell $$$ 2 $$$ : first subtract $$$ y = 1 $$$ either subtract $$$ y = 1 $$$ divide $$$ z = 2 $$$ therefore five ways total,"['data structures', 'dp', 'math']",1700.0
1562/D2,"hard version problem difference versions hard version require output number rods remove make hack versions problem solve stitch like experiment different machine friend sparky today build another machine main element machine $$$ n $$$ rods arrange along one straight line number $$$ 1 $$$ $$$ n $$$ inclusive rods must carry electric charge quantitatively equal either $$$ 1 $$$ $$$ -1 $$$ ( otherwise machine work ) another condition machine work sign - variable sum charge rods must zero formally rods represent array $$$ n $$$ number characterize charge : either $$$ 1 $$$ $$$ -1 $$$ condition must hold : $$$ a_1 - a_2 + a_3 - a_4 + \ldots = 0 $$$ $$$ \sum\limits _ { i=1 } ^n ( -1 ) ^ { i-1 } \cdot a_i = 0 $$$ sparky charge $$$ n $$$ rods electric current unfortunately happen rods charge correctly ( sign - variable sum charge zero ) friends decide leave rods machine sparky $$$ q $$$ question $$$ i $$$ th question sparky ask : machine consist rods number $$$ l_i $$$ $$$ r_i $$$ inclusive minimal number rods could remove machine sign - variable sum charge remain ones would zero ? also sparky want know number rods perhaps friends get something wrong sign - variable sum already zero case n't remove rods number rods zero assume sign - variable sum charge zero , always remove rods help friends answer sparky 's question ! test contain multiple test case first line contain one positive integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) denote number test case description test case follow first line test case contain two positive integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n q \le 300000 $$$ ) — number rods number question second line test case contain a non - empty string $$$ s $$$ length $$$ n $$$ charge $$$ i $$$ -th rod $$$ 1 $$$ $$$ s_i $$$ ` ` + '' symbol $$$ -1 $$$ $$$ s_i $$$ ` ` - '' symbol next line next $$$ q $$$ line contain two positive integers $$$ l_i $$$ ans $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) — number describe sparky 's question guarantee sum $$$ n $$$ test case exceed $$$ 300000 $$$ sum $$$ q $$$ test case exceed $$$ 300000 $$$ guarantee sum answer ( minimal number rods remove ) test case exceed $$$ 1000000 $$$ test case print answer follow format : first line print a single integer $$$ k $$$ — minimal number rods remove second line print $$$ k $$$ number separate a space — number rods remove one correct answer print first test case first query remove rods number $$$ 5 $$$ $$$ 8 $$$ follow set rods remain : + -- + -- + + -++- easy see sign - variable sum zero second test case :","['data structures', 'math']",2200.0
1566/C,a binary string a string consist character $$$ 0 $$$ $$$ 1 $$$ a bi - table a table exactly two row equal length a binary string let $$$ \operatorname { mex } $$$ a bi - table smallest digit among $$$ 0 $$$ $$$ 1 $$$ $$$ 2 $$$ occur bi - table example $$$ \operatorname { mex } $$$ $$$ \begin { bmatrix } <unknown> 1010 \end { bmatrix } $$$ $$$ 2 $$$ $$$ 0 $$$ $$$ 1 $$$ occur bi - table least $$$ \operatorname { mex } $$$ $$$ \begin { bmatrix } <unknown> 111 \end { bmatrix } $$$ $$$ 0 $$$ $$$ 0 $$$ $$$ 2 $$$ occur bi - table $$$ 0 < 2 $$$ give a bi - table $$$ n $$$ columns cut number bi - tables ( consist consecutive columns ) column exactly one bi - table possible cut bi - table a single bi - table — whole bi - table maximal sum $$$ \operatorname { mex } $$$ result bi - tables ? input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line description test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number columns bi - table next two line contain a binary string length $$$ n $$$ — row bi - table 's guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print a single integer — maximal sum $$$ \operatorname { mex } $$$ bi - tables possible get cut give bi - table optimally first test case cut bi - table follow : sum $$$ \operatorname { mex } $$$ $$$ 8 $$$,"['dp', 'greedy']",1000.0
1566/D2,hard version problem difference version $$$ 1 \le n \le 300 $$$ cinema seat represent table $$$ n $$$ row $$$ m $$$ columns row number integers $$$ 1 $$$ $$$ n $$$ seat row number consecutive integers leave right : $$$ k $$$ -th row $$$ m ( k - 1 ) + 1 $$$ $$$ m k $$$ row $$$ 1 \le k \le n $$$ $$$ nm $$$ people want go cinema watch a new film number integers $$$ 1 $$$ $$$ nm $$$ give exactly one seat person know cinema lower seat index better see everything happen screen $$$ i $$$ -th person level sight $$$ a_i $$$ let 's define $$$ s_i $$$ seat index give $$$ i $$$ -th person want give better place people lower sight level two people $$$ i $$$ $$$ j $$$ $$$ a_i < a_j $$$ satisfy $$$ s_i < s_j $$$ give seat people start come seat order $$$ 1 $$$ $$$ nm $$$ person enter hall sit seat get place person go seat 's row start move first seat row leave right move place free occupy people already seat inconvenience person equal number occupy seat go let 's consider example : $$$ m = 5 $$$ person seat $$$ 4 $$$ first row seat $$$ 1 $$$ $$$ 3 $$$ $$$ 5 $$$ first row already occupy seat $$$ 2 $$$ $$$ 4 $$$ free inconvenience person $$$ 2 $$$ go occupy seat $$$ 1 $$$ $$$ 3 $$$ find minimal total inconvenience ( sum inconvenience people ) possible give place people ( condition satisfy ) input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 300 $$$ ) — number row place row respectively second line test case contain $$$ n \cdot m $$$ integers $$$ a_1 a_2 \ldots a _ { n \cdot m } $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ sight level $$$ i $$$ -th person 's guarantee sum $$$ n \cdot m $$$ test case exceed $$$ 100000 $$$ test case print a single integer — minimal total inconvenience achieve first test case a single way give seat : first person sit first place second person — second total inconvenience $$$ 1 $$$ second test case optimal seat look like : third test case optimal seat look like : number a cell person 's index sit place,"['data structures', 'greedy', 'implementation']",1600.0
1566/F,$$$ n $$$ point $$$ m $$$ segment coordinate line initial coordinate $$$ i $$$ -th point $$$ a_i $$$ endpoints $$$ j $$$ -th segment $$$ l_j $$$ $$$ r_j $$$ — leave right endpoints respectively move point one move move point current coordinate $$$ x $$$ coordinate $$$ x - 1 $$$ coordinate $$$ x + 1 $$$ cost move $$$ 1 $$$ move point a way segment visit least one point a point visit segment $$$ [ l r ] $$$ a moment coordinate segment $$$ [ l r ] $$$ ( include endpoints ) find minimal possible total cost move segment visit input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200000 $$$ ) — number point segment respectively next line contain $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) — initial coordinate point next $$$ m $$$ line contain two integers $$$ l_j $$$ $$$ r_j $$$ ( $$$ -1000000000 \le l_j \le r_j \le 1000000000 $$$ ) — leave right endpoints $$$ j $$$ -th segment 's guarantee sum $$$ n $$$ sum $$$ m $$$ test case exceed $$$ 200000 $$$ test case print a single integer — minimal total cost move segment visit first test case point move follow : total cost move $$$ 5 $$$ easy see segment visit movements example tenth segment ( $$$ [ 7 13 ] $$$ ) visit second move third point image describe first test case :,"['data structures', 'dp', 'greedy', 'implementation']",2600.0
1567/F,alice empty grid $$$ n $$$ row $$$ m $$$ columns cells mark mark cells adjacent edge grid ( two square adjacent share a side . ) alice want fill cell a number follow statements true : first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 500 $$$ ) — number row number columns grid respectively $$$ n $$$ line follow contain $$$ m $$$ character character either ' . ' ' x ' — unmarked a mark cell respectively mark cells adjacent edge grid output ` ` ' no '' suitable grid exist otherwise output ` ` ' yes '' ' output $$$ n $$$ line $$$ m $$$ space - separated integers — integers grid show grid exist second test,['implementation'],2700.0
1571/C,let 's say two string $$$ s $$$ $$$ t $$$ rhyme string length least $$$ k $$$ last $$$ k $$$ character equal example $$$ k = 3 $$$ string abcd <unknown> rhyme string ab ab n't rhyme string aaaa aaaaa rhyme string abcd <unknown> n't rhyme $$$ n $$$ pair string $$$ ( s_i t_i ) $$$ pair string know rhyme find possible non - negative integer value $$$ k $$$ pair rhyme rhyme pair must rhyme n't rhyme test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number string pair next $$$ n $$$ line contain descriptions pair — one per line $$$ i $$$ -th line contain space - separated string $$$ s_i $$$ $$$ t_i $$$ marker $$$ r_i $$$ string non - empty consist lowercase latin letter length $$$ 200000 $$$ marker $$$ r_i $$$ equal $$$ 1 $$$ string rhyme $$$ 0 $$$ must rhyme 's guarantee test case least one pair $$$ r_i $$$ equal $$$ 1 $$$ total length string test case n't exceed $$$ 400000 $$$ test case firstly print integer $$$ m $$$ — number possible non - negative integer value $$$ k $$$ pair rhyme rhyme pair must rhyme n't rhyme next print value $$$ k $$$ ( without repetitions ) print order first test case $$$ k $$$ least $$$ 1 $$$ kotlin heroes n't rhyme second test case $$$ k = 2 $$$ join kotlin rhyme episode eight n't rhyme,['implementation'],1800.0
1571/G,"a squad $$$ n $$$ warriors defend a castle a dragon attack $$$ m $$$ barricade castle dragon warriors number $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th warrior know $$$ k_i $$$ attack : $$$ j $$$ -th deal $$$ a _ { i j } $$$ damage dragon apply exactly $$$ b _ { i j } $$$ barricade castle dragon warriors make turn one another start warrior $$$ 1 $$$ warrior $$$ n $$$ make turn total damage dragon calculate $$$ i $$$ -th warrior perform exactly one three possible move turn : total damage sum damage deal warriors choose deploy attack turn maximum total damage warriors deal dragon ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 300000 $$$ ) — number warriors initial number barricade descriptions attack warrior follow $$$ i $$$ -th description consist three line first line contain a single integer $$$ k_i $$$ ( $$$ 1 \le k_i \le m + 1 $$$ ) — number attack $$$ i $$$ -th warrior know second line contain $$$ k_i $$$ integers $$$ a _ { i,1 } a _ { i,2 } \dots a _ { i k_i } $$$ ( $$$ 1 \le a _ { i j } \le 1000000000 $$$ ) — damage attack third line contain $$$ k_i $$$ integers $$$ b _ { i,1 } b _ { i,2 } \dots b _ { i k_i } $$$ ( $$$ 0 \le b _ { i j } \le m $$$ ) — require number barricade attack $$$ b _ { i j } $$$ $$$ i $$$ -th warrior pairwise distinct attack list increase order barricade requirement $$$ b _ { i,1 } < b _ { i,2 } < \dots < b _ { i k_i } $$$ sum $$$ k_i $$$ warriors n't exceed $$$ 300000 $$$ print a single integer — maximum total damage warriors deal dragon first example optimal choice follow : total damage $$$ 10 $$$ first warrior use attack skip turn second warrior would able deploy second attack thus total damage would $$$ 2 + <unknown> $$$ $$$ 5 $$$ second example first warrior skip move second warrior skip move third warrior deploy attack third example two equivalent options : options yield $$$ 30 $$$ total damage","['data structures', 'dp']",2500.0
1572/B,give a sequence $$$ a $$$ length $$$ n $$$ consist $$$ 0 $$$ s $$$ 1 $$$ s. perform follow operation sequence : prove exist a sequence operations length change elements $$$ a $$$ $$$ 0 $$$ s also a sequence length greater $$$ n $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) first line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 2\cdot100000 $$$ ) — length $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ a_i = 0 $$$ $$$ a_i = 1 $$$ ) — elements $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ test case follow : multiple solutions may print first example sequence contain $$$ 0 $$$ s n't need change anything second example transform $$$ [ 1 1 1 1 0 ] $$$ $$$ [ 1 1 0 0 0 ] $$$ $$$ [ 0 0 0 0 0 ] $$$ perform operation third element $$$ a $$$ first element $$$ a $$$ third example matter whether first perform operation first second element $$$ a $$$ get $$$ [ 1 1 1 1 ] $$$ transform $$$ [ 0 0 0 0 ] $$$,['greedy'],2500.0
1579/F,give array $$$ a [ 0 \ldots n - 1 ] = [ a_0 a_1 \ldots a _ { n - 1 } ] $$$ zero ones note problem unlike others array index number zero one one step array $$$ a $$$ replace another array length $$$ n $$$ accord follow rule : mean whole array $$$ a^ { \rightarrow d } $$$ represent a sequence $$$ $$$ a^ { \rightarrow d } = [ a _ { n - d } a _ { n - d + 1 } \ldots a _ { n - 1 } a_0 a_1 \ldots a _ { n - d - 1 } ] $$$ $$$ example $$$ a = [ 0 0 1 1 ] $$$ $$$ d = 1 $$$ $$$ a^ { \rightarrow d } = [ 1 0 0 1 ] $$$ value $$$ a $$$ first step $$$ [ 0 \ \ & \ 1 0 \ \ & \ 0 1 \ \ & \ 0 1 \ \ & \ 1 ] $$$ $$$ [ 0 0 0 1 ] $$$ process end array stop change a give array $$$ a $$$ determine whether consist zero end process yes also find number step process take finish first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case next $$$ 2 t $$$ line contain descriptions test case first line test case description contain two integers : $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — array size $$$ d $$$ ( $$$ 1 \le d \le n $$$ ) — cyclic shift offset second line description contain $$$ n $$$ space - separated integers $$$ a_i $$$ ( $$$ 0 \le a_i \le 1 $$$ ) — elements array guarantee sum $$$ n $$$ test case exceed $$$ 1000000 $$$ print $$$ t $$$ line line contain answer correspond test case answer a test case a single integer — number step array contain zero first time still elements equal $$$ 1 $$$ array end process print -1 . third sample test case array change follow : fourth sample test case array change shift $$$ 2 $$$ right element calculate $$$ 0 \ \ & \ 0 $$$ $$$ 1 \ \ & \ 1 $$$ thus change value answer -1 array never contain zero,['math'],1700.0
1580/B,"let $$$ c_1 c_2 \ldots c_n $$$ a permutation integers $$$ 1 2 \ldots n $$$ consider subsegments permutation contain integer $$$ x $$$ give integer $$$ m $$$ call integer $$$ x $$$ good exactly $$$ m $$$ different value maximum subsegments cirno study mathematics teacher ask count number permutations length $$$ n $$$ exactly $$$ k $$$ good number unfortunately cirno n't good mathematics ca n't answer question therefore ask help since answer may big need tell number permutations modulo $$$ p $$$ a permutation array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) a sequence $$$ a $$$ a subsegment a sequence $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) elements begin several ( possibly zero ) elements end first line contain four integers $$$ n m k p $$$ ( $$$ 1 \le n \le 100 1 \le m \le n 1 \le k \le n 1 \le p \le 1000000000 $$$ ) output number permutations modulo $$$ p $$$ first test case four permutations : $$$ [ 1 3 2 4 ] $$$ $$$ [ 2 3 1 4 ] $$$ $$$ [ 4 1 3 2 ] $$$ $$$ [ 4 2 3 1 ] $$$ take permutation $$$ [ 1 3 2 4 ] $$$ example : number $$$ 1 $$$ subsegments contain : $$$ [ 1 ] $$$ $$$ [ 1 3 ] $$$ $$$ [ 1 3 2 ] $$$ $$$ [ 1 3 2 4 ] $$$ 're three different maxima $$$ 1 $$$ $$$ 3 $$$ $$$ 4 $$$ similarly number $$$ 3 $$$ 're two different maxima $$$ 3 $$$ $$$ 4 $$$ number $$$ 2 $$$ 're three different maxima $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ number $$$ 4 $$$ 're one $$$ 4 $$$",['dp'],2600.0
1581/A,"cqxym count permutations length $$$ 2n $$$ a permutation array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) a permutation $$$ p $$$ ( length $$$ 2n $$$ ) count number $$$ i $$$ satisfy $$$ p_i < p _ { i+1 } $$$ less $$$ n $$$ example : cqxym want help count number permutations modulo $$$ 1000000007 $$$ ( $$$ 1000000000 + 7 $$$ ) addition modulo operation get remainder example : input consist multiple test case first line contain integer $$$ t ( t \geq 1 ) $$$ — number test case description test case follow one line test case contain integer $$$ n ( 1 \leq n \leq 100000 ) $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print answer a single line $$$ n=1 $$$ one permutation satisfy condition : $$$ [ 1,2 ] $$$ permutation $$$ [ 1,2 ] $$$ $$$ p_1 < p_2 $$$ one $$$ i=1 $$$ satisfy condition since $$$ 1 \geq n $$$ permutation count permutation $$$ [ 2,1 ] $$$ $$$ p_1 > p_2 $$$ $$$ 0 < n $$$ permutation count $$$ n=2 $$$ $$$ 12 $$$ permutations : $$$ [ 1,2,3,4 ] [ 1,2,4,3 ] [ <unknown> ] [ 1,3,4,2 ] [ 1,4,2,3 ] [ 2,1,3,4 ] [ 2,3,1,4 ] [ 2,3,4,1 ] [ <unknown> ] [ 3,1,2,4 ] [ <unknown> ] [ 4,1,2,3 ] $$$",['math'],800.0
1581/B,cqxym want create a connect undirected graph $$$ n $$$ nod $$$ m $$$ edge diameter graph must strictly less $$$ k-1 $$$ also cqxym n't want a graph contain self - loops multiple edge ( i.e edge connect two different vertices pair vertices one edge ) diameter a graph maximum distance two nod distance two nod minimum number edge path endpoints two nod cqxym wonder whether possible create a graph input consist multiple test case first line contain integer $$$ t ( 1 \leq t \leq 100000 ) $$$ — number test case description test case follow one line test case contain three integers $$$ n ( 1 \leq n \leq 1000000000 ) $$$ $$$ m $$$ $$$ k $$$ $$$ ( 0 \leq m k \leq 1000000000 ) $$$ test case print yes possible create graph print impossible print letter case ( upper lower ) first test case graph 's diameter equal 0 . second test case graph 's diameter 2 . third test case graph 's diameter 1,"['greedy', 'math']",1200.0
1582/A,luntik decide try sing $$$ a $$$ one - minute songs $$$ b $$$ two - minute songs $$$ c $$$ three - minute songs want distribute songs two concert every song include exactly one concert want make absolute difference durations concert small possible duration concert sum durations songs concert please help luntik find minimal possible difference minutes concert durations first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case consist one line contain three integers $$$ a b c $$$ $$$ ( 1 \le a b c \le 1000000000 ) $$$ — number one - minute two - minute three - minute songs test case print minimal possible difference minutes concert durations first test case luntik include a one - minute song a two - minute song first concert a three - minute song second concert difference equal $$$ 0 $$$ second test case luntik include two one - minute songs a two - minute song a three - minute song first concert two three - minute songs second concert duration first concert $$$ 1 + 1 + 2 + 3 = 7 $$$ duration second concert $$$ 6 $$$ difference $$$ |7 - 6| = 1 $$$,['math'],800.0
1584/D,"interactive problem jury initially a sequence $$$ a $$$ length $$$ n $$$ $$$ a_i = i $$$ jury choose three integers $$$ i $$$ $$$ j $$$ $$$ k $$$ $$$ 1 \leq i < j < k \leq n $$$ $$$ j - i > 1 $$$ , jury reverse subsegments $$$ [ i j - 1 ] $$$ $$$ [ j k ] $$$ sequence $$$ a $$$ reverse a subsegment $$$ [ l r ] $$$ sequence $$$ a $$$ mean reverse order elements $$$ a_l a _ { l+1 } \ldots a_r $$$ sequence i. e. $$$ a_l $$$ swap $$$ a_r $$$ $$$ a _ { l+1 } $$$ swap $$$ a _ { r-1 } $$$ etc give number $$$ n $$$ find $$$ i $$$ $$$ j $$$ $$$ k $$$ ask question one question choose two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l \leq r \leq n $$$ ) ask number inversions subsegment $$$ [ l r ] $$$ sequence $$$ a $$$ give number pair $$$ ( i j ) $$$ $$$ l \leq i < j \leq r $$$ $$$ a_i > a_j $$$ find choose number $$$ i $$$ $$$ j $$$ $$$ k $$$ $$$ 40 $$$ question number $$$ i $$$ $$$ j $$$ $$$ k $$$ fix start program depend query test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case description test case follow single line test case contain a single integer $$$ n $$$ ( $$$ 4 \leq n \leq 1000000000 $$$ ) read start interaction process ask question test case give answer : ask number inversions a subsegment $$$ [ l r ] $$$ print ` ` ? l r '' ( $$$ 1 \leq l \leq r \leq n $$$ ) ask $$$ 40 $$$ question test case a result read a single integer $$$ x $$$ give answer print ` ` ! i j k '' $$$ i $$$ $$$ j $$$ $$$ k $$$ number find continue solve next test case terminate program print a question answer forget print end line flush output otherwise get ` ` idleness limit exceed '' verdict , use : hacksto make a hack use follow format : first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case next $$$ t $$$ line contain four integers $$$ n $$$ $$$ i $$$ $$$ j $$$ $$$ k $$$ ( $$$ 4 \leq n \leq 1000000000 $$$ $$$ 1 \leq i < j < k \leq n $$$ $$$ j - i > 1 $$$ ) first test case $$$ i = 1 $$$ $$$ j = 3 $$$ $$$ k = 5 $$$ sequence $$$ a $$$ $$$ [ 2 1 5 4 3 ] $$$ second test case $$$ i = 2 $$$ $$$ j = 4 $$$ $$$ k = 5 $$$ sequence $$$ a $$$ $$$ [ 1 3 2 5 4 ] $$$",['math'],2000.0
1593/F,give a non - negative integer $$$ x $$$ decimal representation contain $$$ n $$$ digits need color digit red black number form red digits divisible $$$ a $$$ number form black digits divisible $$$ b $$$ least one digit must color two color consider count digits color red $$$ r $$$ count digits color black $$$ b $$$ among possible color give number $$$ x $$$ need output value $$$ |r - b| $$$ minimum possible note number $$$ x $$$ number form digits color may contain lead zero figure show example paint number $$$ x = <unknown> $$$ $$$ n = 5 $$$ digits $$$ a = 3 $$$ $$$ b = 13 $$$ red digits form number $$$ <unknown> $$$ divisible $$$ 3 $$$ black ones — $$$ 26 $$$ divisible $$$ 13 $$$ note absolute value difference count red black digits $$$ 1 $$$ impossible achieve a smaller value first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) — number test case $$$ t $$$ test case follow test case consist two line first line contain three integers $$$ n $$$ $$$ a $$$ $$$ b $$$ ( $$$ 2 \le n \le 40 $$$ $$$ 1 \le a b \le 40 $$$ ) second line contain a non - negative integer $$$ x $$$ contain exactly $$$ n $$$ digits probably contain lead zero test case output a separate line : number form digits color red divisible $$$ a $$$ number form digits color black divisible $$$ b $$$ value $$$ |r - b| $$$ minimal $$$ r $$$ count red digits $$$ b $$$ count black digits many possible answer print first test case consider statement second test case even digits impossible form a number digits divisible $$$ 2 $$$ third test case color contain least one red one black digit possible color $$$ 4 $$$ digits red $$$ 4 $$$ black ( $$$ |4 - 4| = 0 $$$ impossible improve result ) fourth test case a single desire color,"['dp', 'implementation', 'math']",2100.0
1598/C,monocarp get array $$$ a $$$ consist $$$ n $$$ integers let 's denote $$$ k $$$ mathematic mean elements ( note 's possible $$$ k $$$ integer ) mathematic mean array $$$ n $$$ elements sum elements divide number elements ( i. e. sum divide $$$ n $$$ ) monocarp want delete exactly two elements $$$ a $$$ mathematic mean remain $$$ ( n - 2 ) $$$ elements still equal $$$ k $$$ task calculate number pair position $$$ [ i j ] $$$ ( $$$ i < j $$$ ) elements position delete mathematic mean $$$ ( n - 2 ) $$$ remain elements equal $$$ k $$$ ( equal mathematic mean $$$ n $$$ elements original array $$$ a $$$ ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain one integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) — number elements array second line contain a sequence integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 10^ { 9 } $$$ ) $$$ a_i $$$ $$$ i $$$ -th element array sum $$$ n $$$ testcases n't exceed $$$ 200000 $$$ print one integer — number pair position $$$ [ i j ] $$$ ( $$$ i < j $$$ ) elements position delete mathematic mean $$$ ( n - 2 ) $$$ remain elements equal $$$ k $$$ ( equal mathematic mean $$$ n $$$ elements original array $$$ a $$$ ) first example pair elements remove since equal second example way delete two elements mathematic mean n't change third example possible delete elements position $$$ 1 $$$ $$$ 3 $$$ elements position $$$ 4 $$$ $$$ 5 $$$,"['data structures', 'dp', 'implementation', 'math']",1200.0
1599/H,"interactive problem ! part contribution great bubble war task find newly build enemy fortress world live a giant $$$ 1000000000 \times 1000000000 $$$ grid square coordinate $$$ 1 $$$ $$$ 1000000000 $$$ know enemy base shape a rectangle side parallel side grid people world extremely scar edge world know base n't contain square edge grid ( $$$ x $$$ $$$ y $$$ coordinate $$$ 1 $$$ $$$ 1000000000 $$$ ) help locate base give a device place square grid tell manhattan distance closest square base manhattan distance square $$$ ( a b ) $$$ square $$$ ( p q ) $$$ calculate $$$ <unknown> $$$ try place device inside enemy base capture enemy , need make sure never place device inside enemy base unfortunately device power a battery ca n't recharge mean use device $$$ 40 $$$ time input contain answer query code allow place device square grid write ` ` ? $$$ i $$$ $$$ j $$$ ` ` $$$ ( 1 \leq i j \leq 1000000000 ) $$$ return recieve manhattan distance closest square enemy base square $$$ ( i j ) $$$ $$$ -1 $$$ square place device inside enemy base outside grid recieve $$$ -1 $$$ instead a positive number exit <unknown> see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream solution use $$$ 40 $$$ query sure enemy base locate print ` ` ! $$$ x $$$ $$$ y $$$ $$$ p $$$ $$$ q $$$ ` ` $$$ ( 1 \leq x \leq <unknown> 1000000000 1 \leq y \leq q\leq 1000000000 ) $$$ $$$ ( x y ) $$$ square inside enemy base smallest $$$ x $$$ $$$ y $$$ coordinate $$$ ( p q ) $$$ square inside enemy base largest $$$ x $$$ $$$ y $$$ coordinate note answer n't count one 40 query print a query print answer forget output end line flush output otherwise get idleness limit exceed , use :",['math'],2100.0
160/A,"imagine a twin brother sister another person look exactly like seem unusual 's hard say something alter <unknown> good bad a twin well know 's like let 's imagine a typical morning family n't wake yet mom already go work <unknown> nearly forget leave two <unknown> children money buy lunch school <unknown> fish <unknown> find number coin exact n coin arbitrary value a1 a2 ... , mom run time n't split coin two <unknown> a note ask split money equally wake find mom 's coin read note ` ` split money equally ? '' — think , twin sleep wo n't know anything decide act like : pick subset coin sum value coin strictly larger sum value remain coin twin however correctly think take many coin twin suspect deception , ' ve decide stick follow strategy avoid suspicions : take minimum number coin whose sum value strictly sum value remain coin basis determine minimum number coin need take divide describe manner first line contain integer n ( 1 ≤ n ≤ 100 ) — number coin second line contain a sequence n integers a1 a2 ... ( 1 ≤ ai ≤ 100 ) — coin ' value number separate space single line print single number — minimum need number coin first sample take 2 coin ( twin sum equal 6 0 correspondingly ) take 1 coin get sum 3 3 . take 0 coin get sum 0 6 . variants satisfy sum strictly twin ' sum second sample one coin n't enough us , pick coin value 1 2 2 2 . case minimum number coin equal 2",['greedy'],900.0
1603/A,"youkn0wwho integer sequence $$$ a_1 a_2 \ldots a_n $$$ perform follow operation sequence become empty : select index $$$ i $$$ $$$ 1 \le i \le |a| $$$ $$$ a_i $$$ divisible $$$ ( i + 1 ) $$$ erase element sequence $$$ |a| $$$ length sequence $$$ a $$$ moment operation note sequence $$$ a $$$ change next operation perform change sequence example $$$ a= [ <unknown> ] $$$ select $$$ i = 2 $$$ $$$ a_2 = 5 $$$ divisible $$$ i+1 = 3 $$$ operation sequence $$$ [ <unknown> ] $$$ help youkn0wwho determine possible erase whole sequence use aforementioned operation first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10\,000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case n't exceed $$$ 300000 $$$ test case print ` ` yes '' ( without quote ) possible erase whole sequence use aforementioned operation print ` ` '' ( without quote ) otherwise print letter register ( upper lower ) first test case youkn0wwho perform follow operations ( erase elements underline ) : $$$ [ 1 \underline { 2 } 3 ] \rightarrow [ \underline { 1 } 3 ] \rightarrow [ \underline { 3 } ] \rightarrow [ \ ] $$$ second test case impossible erase sequence $$$ i $$$ $$$ 1 $$$ $$$ i=1 $$$ $$$ a_1 = 2 $$$ divisible $$$ i + 1 = 2 $$$",['math'],1300.0
1607/D,give array integers $$$ a $$$ length $$$ n $$$ elements array either different element array color either blue red unpainted elements array one two operations describe apply array a single step : situations elements color also possible example whole array color blue red one operations become unavailable determine whether possible make $$$ 0 $$$ step result array a permutation number $$$ 1 $$$ $$$ n $$$ ? word check whether exist a sequence step ( possibly empty ) apply array $$$ a $$$ contain order number $$$ 1 $$$ $$$ n $$$ ( inclusive ) exactly first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number input data set test description set input data consist three line first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — length original array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ -1000000000 \leq a_i \leq 1000000000 $$$ ) — array elements third line length $$$ n $$$ consist exclusively letter ' b ' and/or ' r ' : $$$ i $$$ th character ' b ' $$$ a_i $$$ color blue ' r ' color red guarantee sum $$$ n $$$ input set exceed $$$ 200000 $$$ print $$$ t $$$ line contain answer correspond test case input print yes answer correspond array transform a permutation otherwise print answer case ( example string yes yes yes yes recognize a positive answer ) first test case example follow sequence move perform : get $$$ a $$$ a permutation hence answer yes,"['greedy', 'math']",1300.0
1607/F,"robot locate a checker rectangular board size $$$ n \times m $$$ ( $$$ n $$$ row $$$ m $$$ columns ) row board number $$$ 1 $$$ $$$ n $$$ top bottom columns — $$$ 1 $$$ $$$ m $$$ leave right robot able move current cell one four cells adjacent side cell one symbols ' l ' ' r ' 'd ' ' u ' write indicate direction robot move get cell — leave right , respectively robot start movement cell move adjacent square direction indicate current square one move robot choose cell start cell goal make maximum number step break stop determine square robot start movement order execute many command possible a command consider successfully complete robot move square command write ( matter whether another square beyond edge board ) first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test test case 's description precede a blank line next a line contain integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 2000 $$$ ; $$$ 1 \le m \le 2000 $$$ ) — height width board line follow $$$ n $$$ line $$$ i $$$ -th describe $$$ i $$$ -th line board exactly $$$ m $$$ letter long consist symbols ' l ' ' r ' 'd ' ' u ' guarantee sum size board input exceed $$$ 4\cdot1000000 $$$ test case output three integers $$$ r $$$ $$$ c $$$ $$$ d $$$ ( $$$ 1 \le r \le n $$$ ; $$$ 1 \le c \le m $$$ ; $$$ d \ge 0 $$$ ) denote robot start move cell $$$ ( r c ) $$$ make maximum number move $$$ d $$$ several answer output",['implementation'],2300.0
1611/F,"polycarp start work a bank assign monitor atm atm initially contain $$$ s $$$ rubles a queue $$$ n $$$ students line student want either withdraw a certain amount money deposit account $$$ a_i $$$ positive student credit amount money via atm otherwise student withdraw $$$ |a_i| $$$ rubles begin atm turn arbitrary number students serve point polycarp turn atm initial amount $$$ s $$$ rubles , remain students start queue atm point time less money atm student want withdraw student serve polycarp turn atm turn anymore formally students serve form a contiguous subsequence polycarp want atm serve maximum number students help matter print number first last student determine able serve anyone word find a longest continuous segment students start sum $$$ s $$$ atm students serve atm serve students consistently ( i.e one another order queue ) first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist two line first one contain integers $$$ n $$$ $$$ s $$$ ( $$$ 1 \le n \le 2\cdot100000 $$$ ; $$$ 0 \le s \le 1000000000 $$$ ) — length $$$ a $$$ array initial amount rubles atm second contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) — elements $$$ a $$$ array note $$$ a_i $$$ zero guarantee sum value $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ print $$$ t $$$ line line must contain answer correspond set input data : answer exist print number first last serve student solution print -1 line several possible answer print first test case correct answer 2 4 since serve students number rubles atm become negative maximum number students serve second test case answer -1 enough money student atm third test case answer either 1 2 4 5",['data structures'],1800.0
1612/C,a usual chat user famous stream platform course moments want <unknown> spam something precisely want spam emote triangle size $$$ k $$$ consist $$$ 2k-1 $$$ message first message consist one emote second one — two emote ... $$$ k $$$ -th one — $$$ k $$$ emote $$$ k+1 $$$ -th one — $$$ k-1 $$$ emote ... last one — one emote example emote triangle $$$ k=3 $$$ consist $$$ 5 $$$ message : course channel auto <unknown> auto <unknown> current chat ban right spam least $$$ x $$$ emote succession ( assume user chat ) interest — many message write get ban ? maybe get ban ( i.e write $$$ 2k-1 $$$ message complete emote triangle successfully ) ? note get ban a result write a message message also count answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case next $$$ t $$$ line describe test case line test case contain integers $$$ k $$$ $$$ x $$$ ( $$$ 1 \le k \le 1000000000 ; 1 \le x \le 10^ { 18 } $$$ ) test case print number message write get ban correspond value $$$ k $$$ $$$ x $$$ let 's analyze test case example,['math'],1300.0
1614/D2,hard version problem difference maximum value $$$ a_i $$$ kostomuksha divan find array $$$ a $$$ consist positive integers want reorder elements $$$ a $$$ maximize value follow function : $$$ $$$ \sum _ { i=1 } ^n \operatorname { gcd } ( a_1 \ a_2 \ \dots \ a_i ) $$$ $$$ $$$ \operatorname { gcd } ( x_1 x_2 \ldots x_k ) $$$ denote greatest common divisor integers $$$ x_1 x_2 \ldots x_k $$$ $$$ \operatorname { gcd } ( x ) = x $$$ integer $$$ x $$$ reorder elements array mean change order elements array arbitrary leave initial order course divan solve problem however find interest decide share first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — size array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a _ { 1 } \ a _ { 2 } \ \dots \ a _ { n } $$$ ( $$$ 1 \le a _ { i } \le 20000000 $$$ ) — array $$$ a $$$ output maximum value function get reorder elements array $$$ a $$$ first example 's optimal rearrange elements give array follow order : $$$ [ 6 \ 2 \ 2 \ 2 \ 3 \ 1 ] $$$ : $$$ $$$ \operatorname { gcd } ( a_1 ) + \operatorname { gcd } ( a_1 \ a_2 ) + \operatorname { gcd } ( a_1 \ a_2 \ a_3 ) + \operatorname { gcd } ( a_1 \ a_2 \ a_3 \ a_4 ) + \operatorname { gcd } ( a_1 \ a_2 \ a_3 \ a_4 \ a_5 ) + \operatorname { gcd } ( a_1 \ a_2 \ a_3 \ a_4 \ a_5 \ a_6 ) = 6 + 2 + 2 + 2 + 1 + 1 = 14 $$$ $$$ show impossible get a better answer second example 's optimal rearrange elements a give array follow order : $$$ [ 100 \ 10 \ 10 \ 5 \ 1 \ 3 \ 3 \ 7 \ 42 \ 54 ] $$$,['dp'],2300.0
1614/E,"divan 's new cottage finally complete ! however a thorough inspection turn workers instal insulation incorrectly temperature house directly depend temperature outside precisely temperature house $$$ p $$$ morning street temperature $$$ t $$$ next morning temperature house change accord follow rule : divan a busy businessman sometimes home long periods know temperature hire find work $$$ n $$$ days begin $$$ i $$$ -th day temperature outside $$$ t_i $$$ first give , $$$ i $$$ -th day receive $$$ k_i $$$ query query ask follow : ` ` temperature house $$$ x_i $$$ morning first day would temperature house next morning ( day $$$ i $$$ ) ? ` ` please answer businessman 's query first line input contain number $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — number days follow a description $$$ n $$$ days follow format first line description contain integer $$$ t_i $$$ ( $$$ 0 \leq t_i \leq 1000000000 $$$ ) — temperature day second line contain a non - negative integer $$$ k_i $$$ ( $$$ 0 \le k_i \le 200000 $$$ ) — number query day third line contain $$$ k $$$ integers $$$ x'_i $$$ ( $$$ 0 \leq x ' _ { i } \leq 1000000000 $$$ ) — encrypt version divan 's query let $$$ lastans = 0 $$$ initially divan 's actual query give $$$ x_i = ( x'_i + lastans ) \bmod ( 1000000000 + 1 ) $$$ $$$ a \bmod b $$$ reminder $$$ a $$$ divide $$$ b $$$ answer query set $$$ lastans $$$ answer guarantee total number query ( sum $$$ k_i $$$ ) exceed $$$ 200000 $$$ query output a single integer — temperature house day $$$ i $$$ let 's look first four query example input temperature $$$ 50 $$$ first day $$$ 50 $$$ second day $$$ 0 $$$ third day note $$$ lastans = 0 $$$ initially",['data structures'],2600.0
1615/A,$$$ n $$$ block tower a row tower $$$ i $$$ a height $$$ a_i $$$ 're part a build crew want make build look nice possible a single day perform follow operation : think ugliness build height difference tallest shortest build formally ugliness define $$$ \max ( a ) -\min ( a ) $$$ 's minimum possible ugliness achieve number days ? first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case $$$ t $$$ case follow first line test case contain one integer $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) — number build second line test case contain $$$ n $$$ space separate integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 10000000 $$$ ) — heights build test case output a single integer — minimum possible ugliness build first test case ugliness already $$$ 0 $$$ second test case one operation $$$ i = 1 $$$ $$$ j = 3 $$$ new heights $$$ [ 2 2 2 2 ] $$$ ugliness $$$ 0 $$$ third test case may three operations :,"['greedy', 'math']",800.0
1616/D,"give array integers $$$ a_1 a_2 \ldots a_n $$$ integer $$$ x $$$ need select maximum number elements array every subsegment $$$ a_l a _ { l + 1 } \ldots a_r $$$ contain strictly one element $$$ ( l < r ) $$$ either : first line input contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 10 $$$ ) : number test case descriptions $$$ t $$$ test case follow three line per test case first line give one integer $$$ n $$$ ( $$$ 1 \leq n \leq 50\,000 $$$ ) : number integers array second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -100\,000 \leq a_i \leq 100\,000 $$$ ) third line contain one integer $$$ x $$$ ( $$$ -100\,000 \leq x \leq 100\,000 $$$ ) test case print one integer : maximum number elements select first example one valid way select elements $$$ [ \underline { 1 } 2 \underline { 3 } \underline { 4 } \underline { 5 } ] $$$ subsegments satisfy least one criteria example subsegment $$$ l = 1 $$$ $$$ r = 2 $$$ element $$$ 2 $$$ select satisfy first criterion subsegment $$$ l = 3 $$$ $$$ r = 5 $$$ $$$ 3 + 4 + 5 = 12 \ge 6 $$$ satisfy second criterion ca n't select elements case $$$ l = 1 $$$ $$$ r = 2 $$$ elements select $$$ a_1 + a_2 = 3 < 4 $$$ thus maximum number select elements $$$ 4 $$$ second example one valid solution $$$ [ \underline { 2 } \underline { 4 } 2 \underline { 4 } \underline { 2 } \underline { 4 } 2 \underline { 4 } \underline { 2 } \underline { 4 } ] $$$ third example one valid solution $$$ [ \underline { -10 } -5 \underline { -10 } ] $$$ fourth example one valid solution $$$ [ \underline { 9 } \underline { 9 } -3 ] $$$","['dp', 'greedy', 'math']",2000.0
1617/C,"<unknown> love permutations array $$$ a_1 a_2 \dots a_n $$$ want make array a permutation integers $$$ 1 $$$ $$$ n $$$ order achieve goal perform operations array operation choose two integers $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) $$$ x $$$ ( $$$ x > 0 $$$ ) perform $$$ a_i : = a_i \bmod x $$$ ( replace $$$ a_i $$$ remainder $$$ a_i $$$ divide $$$ x $$$ ) different operations choose $$$ i $$$ $$$ x $$$ different determine minimum number operations need make array a permutation integers $$$ 1 $$$ $$$ n $$$ impossible output $$$ -1 $$$ a permutation array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output minimum number operations need make array a permutation integers $$$ 1 $$$ $$$ n $$$ $$$ -1 $$$ impossible first test possible sequence operations minimize number operations : second test impossible obtain a permutation integers $$$ 1 $$$ $$$ n $$$","['greedy', 'math']",1300.0
1617/E,christmas come icy receive a box chocolates grandparents ! box contain $$$ n $$$ chocolates $$$ i $$$ -th chocolate a non - negative integer type $$$ a_i $$$ icy believe good things come pair unfortunately type chocolates distinct ( $$$ a_i $$$ distinct ) icy want make least one pair chocolates type a result ask grandparents perform chocolate exchange perform chocolate exchange icy choose two chocolates indices $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ $$$ x \ne y $$$ ) a chocolate exchange icy 's grandparents choose a non - negative integer $$$ k $$$ $$$ 2^k \ge a_x $$$ change type chocolate $$$ x $$$ $$$ a_x $$$ $$$ 2^k - a_x $$$ ( perform $$$ a_x : = 2^k - a_x $$$ ) chocolate exchange stop $$$ a_x = a_y $$$ note pair equal chocolate type stop procedure icy 's grandparents smart would choose sequence chocolate exchange minimize number exchange need since icy like cause trouble want maximize minimum number exchange need choose $$$ x $$$ $$$ y $$$ appropriately wonder optimal pair $$$ ( x y ) $$$ minimum number exchange need maximize across possible choices $$$ ( x y ) $$$ since icy good math hop help solve problem first line input contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number chocolates second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) guarantee $$$ a_i $$$ distinct output three integers $$$ x $$$ $$$ y $$$ $$$ m $$$ $$$ x $$$ $$$ y $$$ indices optimal chocolates perform exchange output must satisfy $$$ 1 \le x y \le n $$$ $$$ x \ne y $$$ $$$ m $$$ number exchange need obtain $$$ a_x = a_y $$$ show $$$ m \le 1000000000 $$$ pair chocolates multiple solutions output first test case minimum number exchange need exchange a chocolate type $$$ 6 $$$ a chocolate type $$$ 9 $$$ $$$ 5 $$$ sequence exchange follow : $$$ 6 \rightarrow 2 \rightarrow 0 \rightarrow 1 \rightarrow 7 \rightarrow 9 $$$ second test case minimum number exchange need exchange a chocolate type $$$ 4 $$$ a chocolate type $$$ 8 $$$ $$$ 2 $$$ sequence exchange follow : $$$ 4 \rightarrow 0 \rightarrow 8 $$$,"['dp', 'implementation', 'math']",2700.0
1618/D,give array $$$ a $$$ $$$ n $$$ integers another integer $$$ k $$$ $$$ 2k \le n $$$ perform exactly $$$ k $$$ operations array one operation choose two elements array ( let $$$ a_i $$$ $$$ a_j $$$ ; equal different position array must ) remove array add $$$ \lfloor \frac { a_i } { a_j } \rfloor $$$ score $$$ \lfloor \frac { x } { y } \rfloor $$$ maximum integer exceed $$$ \frac { x } { y } $$$ initially score $$$ 0 $$$ perform exactly $$$ k $$$ operations add remain elements array score calculate minimum possible score get first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case test case consist two line first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100 $$$ ; $$$ 0 \le k \le \lfloor \frac { n } { 2 } \rfloor $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 200000 $$$ ) print one integer — minimum possible score get let 's consider example test first test case one way obtain a score $$$ 2 $$$ follow one : second test case matter operations choose result score $$$ 16 $$$ third test case one way obtain a score $$$ 0 $$$ follow one : fourth test case operations perform score sum elements array : $$$ 4 + 2 = 6 $$$,"['dp', 'greedy', 'math']",1300.0
1618/F,give two positive integers $$$ x $$$ $$$ y $$$ perform follow operation $$$ x $$$ : write binary form without lead zero add $$$ 0 $$$ $$$ 1 $$$ right reverse binary form turn a decimal number assign new value $$$ x $$$ example : task find whether $$$ x $$$ turn $$$ y $$$ a certain number operations ( possibly zero ) line input contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le 10^ { 18 } $$$ ) print yes make $$$ x $$$ equal $$$ y $$$ ca n't first example n't even need anything fourth example describe statement,"['implementation', 'math']",2000.0
1618/G,monocarp play a computer game ( yet ! ) game a unique trade mechanics trade a character monocarp choose one items possess trade item character possess item integer price monocarp 's choose item price $$$ x $$$ trade item ( exactly one item ) price greater $$$ x+k $$$ monocarp initially $$$ n $$$ items price $$$ i $$$ -th item $$$ a_i $$$ character monocarp trade $$$ m $$$ items price $$$ i $$$ -th item $$$ b_i $$$ monocarp trade character many time want ( possibly even zero time ) time exchange one items one character 's items accord aforementioned constraints note monocarp get item exchange trade another item ( since item belong ) vice versa : monocarp trade one items another item get item back trade something answer $$$ q $$$ query query consist one integer value $$$ k $$$ ask calculate maximum possible total cost items monocarp sequence trade assume trade item cost $$$ x $$$ item cost greater $$$ x+k $$$ trade note query independent : trade actually occur monocarp want calculate maximum total cost get first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \le n m q \le 200000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — price items monocarp third line contain $$$ m $$$ integers $$$ b_1 b_2 \dots b_m $$$ ( $$$ 1 \le b_i \le 1000000000 $$$ ) — price items character fourth line contain $$$ q $$$ integers $$$ i $$$ -th integer value $$$ k $$$ $$$ i $$$ -th query ( $$$ 0 \le k \le 1000000000 $$$ ) query print one integer — maximum possible total cost items monocarp sequence trade give value $$$ k $$$ query,"['data structures', 'greedy']",2200.0
1619/A,a string call square string write twice a row example string ` ` aa '' ` ` abcabc '' ` ` abab '' ` ` <unknown> '' square string ` ` aaa '' ` ` <unknown> '' ` ` <unknown> '' square a give string $$$ s $$$ determine square first line input data contain integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — the number test case follow $$$ t $$$ line contain a description one test case give string consist lowercase latin letter lengths $$$ 1 $$$ $$$ 100 $$$ inclusive test case output a separate line : output yes case ( example string yes yes yes yes recognize a positive response ),['implementation'],800.0
1619/C,tanya learn add number far correctly add two number $$$ a $$$ $$$ b $$$ use follow algorithm : example number $$$ a = <unknown> $$$ $$$ b = <unknown> $$$ tanya add follow : $$$ $$$ <unknown> { \begin { array } { r } + \begin { array } { r } <unknown> <unknown> \end { array } \\ \hline \begin { array } { r } 1106911 \end { array } \end { array } } $$$ $$$ a result get $$$ 1106911 $$$ give two positive integers $$$ a $$$ $$$ s $$$ find number $$$ b $$$ add $$$ a $$$ $$$ b $$$ describe tanya get $$$ s $$$ determine suitable $$$ b $$$ exist first line input data contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist a single line contain two positive integers $$$ a $$$ $$$ s $$$ ( $$$ 1 \le a \lt s \le 10^ { 18 } $$$ ) separate a space test case print answer a separate line solution exist print a single positive integer $$$ b $$$ answer must write without lead zero multiple answer exist print suitable number $$$ b $$$ exist output -1 . first test case explain main part statement third test case choose $$$ b $$$ satisfy problem statement,['implementation'],1200.0
1619/F,"hat a game <unknown> explanation / <unknown> word ( similar <unknown> ) 's fun try ! problem talk a variant game players sit table everyone play individually ( i.e team individual gamers play ) $$$ n $$$ people gather a room $$$ m $$$ table ( $$$ n \ge 2 m $$$ ) want play hat $$$ k $$$ time thus $$$ k $$$ game play table player play $$$ k $$$ game , distribute among table game game one player play exactly one table a player play different table players want ` ` fair '' schedule game reason look a schedule ( table distribution game ) : example $$$ n=5 $$$ $$$ m=2 $$$ $$$ k=2 $$$ request first item either two players three players play table consider follow schedule : find ` ` fair '' game schedule $$$ n $$$ people play $$$ m $$$ table $$$ k $$$ game first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test test case consist one line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \le n \le 2\cdot100000 $$$ $$$ 1 \le m \le \lfloor\frac { n } { 2 } \rfloor $$$ $$$ 1 \le k \le 100000 $$$ ) — number people table game respectively guarantee sum $$$ nk $$$ ( $$$ n $$$ multiply $$$ k $$$ ) test case exceed $$$ 2\cdot100000 $$$ test case print a require schedule — a sequence $$$ k $$$ block $$$ m $$$ line block correspond one game a line a block correspond one table line print number players table indices players ( number $$$ 1 $$$ $$$ n $$$ ) play table several require schedule output show a valid solution always exist output additional blank line separate responses different set input","['greedy', 'math']",2000.0
1620/E,array integers ( initially empty ) perform $$$ q $$$ query query one two type : find result array perform query first line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 500000 $$$ ) — number query next $$$ q $$$ line contain query ( one per line ) query one two type : 's guarantee least one query first type a single line print $$$ k $$$ integers — result array perform query $$$ k $$$ number query first type first example array change follow : $$$ [ ] $$$ $$$ \rightarrow $$$ $$$ [ 3 ] $$$ $$$ \rightarrow $$$ $$$ [ 3 1 ] $$$ $$$ \rightarrow $$$ $$$ [ 3 2 ] $$$ $$$ \rightarrow $$$ $$$ [ 3 2 2 ] $$$ $$$ \rightarrow $$$ $$$ [ 3 2 2 1 ] $$$ $$$ \rightarrow $$$ $$$ [ 3 2 2 1 2 ] $$$ $$$ \rightarrow $$$ $$$ [ 3 2 2 3 2 ] $$$ second example array change follow : $$$ [ ] $$$ $$$ \rightarrow $$$ $$$ [ 1 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 2 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 2 1 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 2 1 ] $$$ third example array change follow : $$$ [ ] $$$ $$$ \rightarrow $$$ $$$ [ ] $$$ $$$ \rightarrow $$$ $$$ [ 1 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 4 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 4 2 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 4 4 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 3 3 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 3 3 2 ] $$$ $$$ \rightarrow $$$ $$$ [ 1 3 3 7 ] $$$,"['data structures', 'implementation']",1900.0
1621/D,"circular land $$$ 2n \times 2n $$$ grid row grid number integers $$$ 1 $$$ $$$ 2n $$$ top bottom columns grid number integers $$$ 1 $$$ $$$ 2n $$$ leave right cell $$$ ( x y ) $$$ cell intersection row $$$ x $$$ column $$$ y $$$ $$$ 1 \leq x \leq 2n $$$ $$$ 1 \leq y \leq 2n $$$ $$$ n^2 $$$ friends top leave corner grid , cell $$$ ( x y ) $$$ $$$ 1 \leq x y \leq n $$$ exactly one friend cells cover snow friends want get bottom right corner grid cell $$$ ( x y ) $$$ $$$ n+1 \leq x y \leq 2n $$$ exactly one friend n't matter cell friends decide help friends get bottom right corner grid , give instructions follow type : note friends grid border behave instructions give instructions number time give instructions different type instruction one friends cell cover snow become ill . order save friends remove snow cells give first instruction : operation number time want spend minimal number coin give instructions friends , friends bottom right corner grid none ill . please find many coin spend first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case first line test case contain single integer $$$ n $$$ ( $$$ 1 \leq n \leq 250 $$$ ) next $$$ 2n $$$ line contain $$$ 2n $$$ integers $$$ c _ { i 1 } c _ { i 2 } \ldots c _ { i 2n } $$$ ( $$$ 0 \leq c _ { i j } \leq 1000000000 $$$ ) — cost remove snow cells $$$ c _ { i j } = 0 $$$ $$$ i j $$$ snow cell $$$ ( i j ) $$$ otherwise cell $$$ ( i j ) $$$ cover snow guarantee $$$ c _ { i j } = 0 $$$ $$$ 1 \leq i j \leq n $$$ guarantee sum $$$ n $$$ test case n't exceed $$$ 250 $$$ test case output one integer — minimal number coin spend first test case remove snow cells $$$ ( 2 1 ) $$$ $$$ ( 2 2 ) $$$ $$$ 100 $$$ coin give instructions second test case remove snow columns $$$ 3 $$$ $$$ 4 $$$ $$$ 22 $$$ coin give instructions show none friends become ill impossible spend less coin","['greedy', 'math']",2100.0
1622/C,"give integer array $$$ a_1 a_2 \dots a_n $$$ integer $$$ k $$$ one step minimum number step need make sum array $$$ \sum\limits _ { i=1 } ^ { n } { a_i } \le k $$$ ? ( allow make value array negative ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 1 \le k \le 10^ { 15 } $$$ ) — size array $$$ a $$$ upper bind sum second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — array 's guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print one integer — minimum number step make $$$ \sum\limits _ { i=1 } ^ { n } { a_i } \le k $$$ first test case decrease $$$ a_1 $$$ $$$ 10 $$$ time get sum lower equal $$$ k = 10 $$$ second test case sum array $$$ a $$$ already less equal $$$ 69 $$$ n't need change third test case , example : fourth test case , example :",['greedy'],1600.0
1623/C,$$$ n $$$ heap stone $$$ i $$$ -th heap $$$ h_i $$$ stone want change number stone heap perform follow process : maximum number stone smallest heap process ? test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 2\cdot 100000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) second line test case contain $$$ n $$$ integers $$$ h_1 h_2 h_3 \ldots h_n $$$ ( $$$ 1 \le h_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print maximum number stone smallest heap contain first test case initial heap size $$$ [ 1 2 10 100 ] $$$ move stone follow second test case last heap $$$ 1 $$$ increase size third test case better move stone last test case final achievable configuration heap $$$ [ 3 5 3 4 3 3 ] $$$,['greedy'],1600.0
1624/B,polycarp $$$ 3 $$$ positive integers $$$ a $$$ $$$ b $$$ $$$ c $$$ perform follow operation exactly polycarp make perform operation sequence three number $$$ a $$$ $$$ b $$$ $$$ c $$$ ( order ) form arithmetic progression ? note change order $$$ a $$$ $$$ b $$$ $$$ c $$$ formally a sequence $$$ x_1 x_2 \dots x_n $$$ call arithmetic progression ( ap ) exist a number $$$ d $$$ ( call ` ` common difference '' ) $$$ x _ { i+1 } = <unknown> $$$ $$$ i $$$ $$$ 1 $$$ $$$ n-1 $$$ problem $$$ n=3 $$$ example follow sequence ap : $$$ [ 5 10 15 ] $$$ $$$ [ 3 2 1 ] $$$ $$$ [ 1 1 1 ] $$$ $$$ [ 13 10 7 ] $$$ follow sequence ap : $$$ [ 1 2 4 ] $$$ $$$ [ 0 1 0 ] $$$ $$$ [ 1 3 2 ] $$$ need answer $$$ t $$$ independent test case first line contain number $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow $$$ t $$$ line contain $$$ 3 $$$ integers $$$ a $$$ $$$ b $$$ $$$ c $$$ ( $$$ 1 \le a b c \le 100000000 $$$ ) test case print ` ` yes '' ( without quote ) polycarp choose a positive integer $$$ m $$$ multiply exactly one integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ m $$$ make $$$ [ a b c ] $$$ arithmetic progression print ` ` '' ( without quote ) otherwise print yes ( upper lower ) case ( example string yes yes yes yes recognize a positive answer ) first second test case choose number $$$ m=4 $$$ multiply second number ( $$$ b=5 $$$ ) $$$ 4 $$$ first test case result sequence $$$ [ 10 20 30 ] $$$ ap a difference $$$ <unknown> $$$ second test case result sequence $$$ [ 30 20 10 ] $$$ ap a difference $$$ <unknown> $$$ third test case choose $$$ m=1 $$$ multiply number $$$ 1 $$$ result sequence $$$ [ 1 2 3 ] $$$ ap a difference $$$ d=1 $$$ fourth test case choose $$$ <unknown> $$$ multiply first number ( $$$ a=1 $$$ ) $$$ 9 $$$ result sequence $$$ [ 9 6 3 ] $$$ ap a difference $$$ <unknown> $$$ fifth test case impossible make ap,"['implementation', 'math']",900.0
1624/E,masha meet a new friend learn phone number — $$$ s $$$ want remember soon possible phone number — a string length $$$ m $$$ consist digits $$$ 0 $$$ $$$ 9 $$$ phone number may start 0 . masha already know $$$ n $$$ phone number ( number length $$$ m $$$ ) easier remember a new number $$$ s $$$ represent segment number already know segment must length least $$$ 2 $$$ otherwise many segment masha get confuse example masha need remember number : $$$ s = $$$ ' <unknown> ' already know $$$ n = 4 $$$ number : ' <unknown> ' ' <unknown> ' ' <unknown> ' ' <unknown> ' represent $$$ s $$$ a $$$ 3 $$$ segment : ' 1234 ' number one ' 56 ' number two ' 78 ' number three ways represent $$$ s $$$ masha ask help ask break string $$$ s $$$ segment length $$$ 2 $$$ number already know several possible answer print first line input data contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — the number test case test case a blank line a line contain integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 1000 $$$ ) — the number phone number masha know number digits phone number follow $$$ n $$$ line $$$ i $$$ -th describe $$$ i $$$ -th number masha know next line contain phone number new friend $$$ s $$$ among give $$$ n+1 $$$ phone may duplicate ( identical phone ) guarantee sum $$$ n \cdot m $$$ ( $$$ n $$$ multiply $$$ m $$$ ) value input test case exceed $$$ 1000000 $$$ need print answer $$$ t $$$ test case first line answer contain one number $$$ k $$$ correspond number segment split phone number $$$ s $$$ print -1 get a split answer yes follow $$$ k $$$ line contain triple number $$$ l r i $$$ triplets mean next $$$ r - l+1 $$$ digits number $$$ s $$$ equal a segment ( substring ) boundaries $$$ [ l r ] $$$ phone number $$$ i $$$ phone digits number $$$ 1 $$$ note $$$ r - l+1 \ge 2 $$$ $$$ k $$$ line example statement second case impossible represent segment know number length 2 third case get segment ' 12 ' ' 21 ' first phone number,"['dp', 'implementation']",2000.0
1625/C,"government mar interest optimize space flight also want improve road system planet one important highways mar connect olymp city kstolop capital cydonia problem consider way kstolop olymp city reverse path ( i. e. path olymp city kstolop ) road kstolop olymp city $$$ \ell $$$ kilometers long point road a coordinate $$$ x $$$ ( $$$ 0 \le x \le \ell $$$ ) equal distance kstolop kilometers , kstolop locate point coordinate $$$ 0 $$$ olymp city locate point coordinate $$$ \ell $$$ $$$ n $$$ sign along road $$$ i $$$ -th set a speed limit $$$ a_i $$$ limit mean next kilometer must pass $$$ a_i $$$ minutes active encounter next along road a road sign start road ( i. e. point coordinate $$$ 0 $$$ ) set initial speed limit know location sign 's hard calculate much time take drive kstolop olymp city consider example : need drive first three kilometers five minutes one kilometer eight minutes four kilometers three minutes finally last two kilometers must pass six minutes total time $$$ 3\cdot 5 + 1\cdot 8 + 4\cdot 3 + 2\cdot 6 = 47 $$$ minutes optimize road traffic government mar decide remove $$$ k $$$ road sign remove sign start road otherwise limit start remove sign government also want make time need drive kstolop olymp city small possible largest industrial <unknown> locate cydonia 's priority task optimize road traffic olymp city , government mar want remove sign way describe first line contain three integers $$$ n $$$ $$$ \ell $$$ $$$ k $$$ ( $$$ 1 \le n \le 500 $$$ $$$ 1 \le \ell \le 100000 $$$ $$$ 0 \le k \le n-1 $$$ ) amount sign road distance cities maximal number sign may remove second line contain $$$ n $$$ integers $$$ d_i $$$ ( $$$ d_1 = 0 $$$ $$$ d_i < d _ { i+1 } $$$ $$$ 0 \le d_i \le \ell - 1 $$$ ) — coordinate sign third line contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 1 \le a_i \le 10000 $$$ ) — speed limit print a single integer — minimal possible time drive kstolop olymp city minutes remove $$$ k $$$ road sign first example remove sign answer $$$ 47 $$$ 's say statements second example may remove second fourth sign case need drive four kilometers $$$ 4\cdot5 = 20 $$$ minutes six kilometers $$$ 6\cdot3 = 18 $$$ total time $$$ 4\cdot5 + 6\cdot3 = 38 $$$ minutes",['dp'],1700.0
1625/D,"binary spiders species spiders live mar spiders weave web defend enemies weave a web spiders join pair first spider pair $$$ x $$$ legs second spider $$$ y $$$ legs weave a web durability $$$ x \oplus y $$$ , $$$ \oplus $$$ mean bitwise xor binary spiders live large group observe a group $$$ n $$$ spiders $$$ i $$$ -th spider $$$ a_i $$$ legs group threaten spiders become defenders defenders choose follow way first must least two defenders second pair defenders must able weave a web durability least $$$ k $$$ third must much defenders possible scientists research behaviour binary spiders a long time a hypothesis always choose defenders optimal way satisfy condition need verify hypothesis group spiders , need understand many spiders must become defenders a binary spider decide use a computer solve problem first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 3\cdot100000 $$$ $$$ 0 \le k \le 2^ { 30 } - 1 $$$ ) amount spiders group minimal allow durability a web second line contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 0 \le a_i \le 2^ { 30 } -1 $$$ ) — number legs $$$ i $$$ -th spider first line print a single integer $$$ \ell $$$ ( $$$ 2 \le \ell \le n $$$ ) maximum possible amount defenders second line print $$$ \ell $$$ integers $$$ b_i $$$ separate a single space ( $$$ 1 \le b_i \le n $$$ ) — indices spiders become defenders exist one way choose defenders print unfortunately may appear 's impossible choose defenders case print a single integer $$$ -1 $$$ consider examples first example group spiders illustrate picture : choose two - legged ten - legged $$$ 16 $$$ <unknown> spiders 's hard see pair may weave a web enough durability $$$ 2 \oplus 10 = 8 \ge 8 $$$ $$$ 2 \oplus 16 = 18 \ge 8 $$$ $$$ 10 \oplus 16 = 26 \ge 8 $$$ way also choose example spiders indices $$$ 3 $$$ $$$ 4 $$$ $$$ 6 $$$ second example pair spiders weave web durability $$$ 1024 $$$ answer $$$ -1 $$$","['data structures', 'implementation', 'math']",2300.0
1627/D,array $$$ a_1 a_2 \dots a_n $$$ consist $$$ n $$$ distinct integers allow perform follow operation : note array change operation subsequent operations perform new array maximum number time perform operation array ? first line consist a single integer $$$ n $$$ ( $$$ 2 \le n \le 1000000 $$$ ) second line consist $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000 $$$ ) $$$ a_i $$$ distinct output a single line contain one integer — maximum number time operation perform give array first example one ways perform maximum number operations array : prove way perform $$$ 3 $$$ operations original array second example one add $$$ 3 $$$ $$$ 1 $$$ $$$ 5 $$$ $$$ 2 $$$,"['dp', 'math']",1900.0
1628/D1,easy version problem difference constraints $$$ n $$$ $$$ m $$$ $$$ t $$$ make hack versions problem solve alice bob give number $$$ n $$$ $$$ m $$$ $$$ k $$$ play a game follow : game a score alice try maximize bob try minimize score initially $$$ 0 $$$ game consist $$$ n $$$ turn turn alice pick a real number $$$ 0 $$$ $$$ k $$$ ( inclusive ) bob either add subtract score game throughout game bob choose add least $$$ m $$$ $$$ n $$$ turn bob get know number alice pick decide whether add subtract number score alice get know whether bob add subtract number previous turn pick number current turn ( except first turn since previous turn ) alice bob play optimally final score game ? first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case description test case follow test case consist a single line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le m \le n \le 2000 0 \le k < 1000000000 + 7 $$$ ) — number turn many turn bob add biggest number alice choose respectively guarantee sum $$$ n $$$ test case exceed $$$ 2000 $$$ test case output a single integer number — score optimal game modulo $$$ 1000000000 + 7 $$$ formally let $$$ m = 1000000000 + 7 $$$ show answer express irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \not \equiv 0 \pmod { m } $$$ output integer equal $$$ p \cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \le x < m $$$ $$$ x \cdot q \equiv p \pmod { m } $$$ first test case entire game $$$ 3 $$$ turn since $$$ m = 3 $$$ bob add therefore alice pick biggest number $$$ k = 2 $$$ every turn third test case alice a strategy guarantee a score $$$ \frac { 75 } { 8 } \equiv 375000012 \pmod { 1000000000 + 7 } $$$ fourth test case alice a strategy guarantee a score $$$ \frac { 45 } { 2 } \equiv 500000026 \pmod { 1000000000 + 7 } $$$,"['dp', 'math']",2100.0
1630/E,"give a cyclic array $$$ a $$$ size $$$ n $$$ $$$ a_i $$$ value $$$ a $$$ $$$ i $$$ -th position may repeat value let us define a permutation $$$ a $$$ equal another permutation $$$ a $$$ value position $$$ i $$$ transform perform cyclic rotation let us define a cyclic array $$$ b $$$ number components number connect components a graph vertices position $$$ b $$$ add edge pair adjacent position $$$ b $$$ equal value ( note a cyclic array first last position also <unknown> ) find expect value components a permutation $$$ a $$$ select equiprobably set different permutations $$$ a $$$ input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — size cyclic array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ i $$$ -th value $$$ a_i $$$ ( $$$ 1 \le a_i \le n $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 1000000 $$$ guarantee total number different permutations $$$ a $$$ divisible $$$ m $$$ test case print a single integer — expect value components a permutation $$$ a $$$ select equiprobably set different permutations $$$ a $$$ modulo $$$ 998\,244\,353 $$$ formally let $$$ m = 998\,244\,353 $$$ show answer express irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \not \equiv 0 \pmod { m } $$$ output integer equal $$$ p \cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \le x < m $$$ $$$ x \cdot q \equiv p \pmod { m } $$$ first test case $$$ 1 $$$ different permutation $$$ a $$$ : second test case $$$ 4 $$$ ways permute cyclic array $$$ a $$$ $$$ 1 $$$ different permutation $$$ a $$$ : third test case $$$ 6 $$$ ways permute cyclic array $$$ a $$$ $$$ 2 $$$ different permutations $$$ a $$$ : fourth test case $$$ 120 $$$ ways permute cyclic array $$$ a $$$ $$$ 24 $$$ different permutations $$$ a $$$ :",['math'],2900.0
1632/A,recently students school 179 develop a unique algorithm take a binary string $$$ s $$$ input however soon find substring $$$ t $$$ $$$ s $$$ a palindrome length greater 1 algorithm work incorrectly students somehow reorder character $$$ s $$$ algorithm work correctly string ? a binary string a string character either 0 1 . a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end a palindrome a string read backwards forward test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — length string $$$ s $$$ second line test case contain string $$$ s $$$ length $$$ n $$$ consist character 0 1 . test case print yes ( case - insensitive ) possible reorder character $$$ s $$$ substrings a palindrome length greater 1 ( case - insensitive ) otherwise first three test case give string contain palindromes length greater 1 answer yes last test case impossible reorder character string contain palindromes length greater 1 answer,['implementation'],800.0
1633/C,monocarp play a computer game game character fight different monsters a fight a character a monster go follow suppose character initially health $$$ h_c $$$ attack $$$ d_c $$$ ; monster initially health $$$ h_m $$$ attack $$$ d_m $$$ fight consist several step : fight end someone 's health become non - positive ( i. e. $$$ 0 $$$ less ) monster 's health become non - positive character win otherwise monster win monocarp 's character currently health equal $$$ h_c $$$ attack equal $$$ d_c $$$ want slay a monster health equal $$$ h_m $$$ attack equal $$$ d_m $$$ fight monocarp spend $$$ k $$$ coin upgrade character 's weapon and/or armor ; upgrade cost exactly one coin weapon upgrade increase character 's attack $$$ w $$$ armor upgrade increase character 's health $$$ a $$$ monocarp 's character slay monster monocarp spend coin upgrade optimally ? first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 50000 $$$ ) — number test case test case consist three line : first line contain two integers $$$ h_c $$$ $$$ d_c $$$ ( $$$ 1 \le h_c \le 10^ { 15 } $$$ ; $$$ 1 \le d_c \le 1000000000 $$$ ) — character 's health attack ; second line contain two integers $$$ h_m $$$ $$$ d_m $$$ ( $$$ 1 \le h_m \le 10^ { 15 } $$$ ; $$$ 1 \le d_m \le 1000000000 $$$ ) — monster 's health attack ; third line contain three integers $$$ k $$$ $$$ w $$$ $$$ a $$$ ( $$$ 0 \le k \le 200000 $$$ ; $$$ 0 \le w \le 10000 $$$ ; $$$ 0 \le a \le 10^ { 10 } $$$ ) — maximum number coin monocarp spend amount add character 's attack weapon upgrade amount add character 's health armor upgrade respectively sum $$$ k $$$ test case exceed $$$ 200000 $$$ test case print yes possible slay monster optimally choose upgrade otherwise print first example monocarp spend one coin upgrade weapon ( damage equal $$$ 5 $$$ ) health battle change follow : $$$ ( h_c h_m ) = ( 25 9 ) \rightarrow ( 25 4 ) \rightarrow ( 5 4 ) \rightarrow ( 5 -1 ) $$$ battle end monocarp 's victory second example monocarp way defeat monster third example monocarp coin ca n't buy upgrade however initial characteristics enough monocarp win fourth example monocarp $$$ 4 $$$ coin defeat monster spend $$$ 2 $$$ coin upgrade weapon $$$ 2 $$$ coin upgrade armor,['math'],1100.0
1633/E,give a connect weight undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge ask $$$ k $$$ query query consist a single integer $$$ x $$$ query select a span tree graph let weight edge $$$ w_1 w_2 \dots w _ { n-1 } $$$ cost a span tree $$$ \sum \limits _ { i=1 } ^ { n-1 } <unknown> - x| $$$ ( sum absolute differences weight $$$ x $$$ ) answer a query lowest cost a span tree query give a compress format first $$$ p $$$ $$$ ( 1 \le p \le k ) $$$ query $$$ q_1 q_2 \dots q_p $$$ provide explicitly query $$$ p+1 $$$ $$$ k $$$ $$$ q_j = ( q _ { j-1 } \cdot a + b ) \mod c $$$ print xor answer query first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 50 $$$ ; $$$ n - 1 \le m \le 300 $$$ ) — number vertices number edge graph next $$$ m $$$ line contain a description undirected edge : three integers $$$ v $$$ $$$ u $$$ $$$ w $$$ ( $$$ 1 \le v u \le n $$$ ; $$$ v \neq u $$$ ; $$$ 0 \le w \le 100000000 $$$ ) — vertices edge connect weight note might multiple edge a pair vertices edge form a connect graph next line contain five integers $$$ p k a b $$$ $$$ c $$$ ( $$$ 1 \le p \le 100000 $$$ ; $$$ p \le k \le 10000000 $$$ ; $$$ 0 \le a b \le 100000000 $$$ ; $$$ 1 \le c \le 100000000 $$$ ) — number query provide explicitly total number query parameters generate query next line contain $$$ p $$$ integers $$$ q_1 q_2 \dots q_p $$$ ( $$$ 0 \le q_j < c $$$ ) — first $$$ p $$$ query print a single integer — xor answer query query first example $$$ 0 1 2 3 4 5 6 7 8 9 0 $$$ answer $$$ 11 9 7 3 1 5 8 7 5 7 11 $$$ query second example $$$ 3 0 2 1 6 0 3 5 4 1 $$$ answer $$$ 14 19 15 16 11 19 14 12 13 16 $$$ query third example $$$ 75 0 0 \dots $$$ answer $$$ 50 150 150 \dots $$$,"['data structures', 'greedy', 'math']",2400.0
1635/C,"give array $$$ a $$$ $$$ n $$$ elements perform follow operation $$$ n $$$ time : select three indices $$$ x y z $$$ $$$ ( 1 \leq x < y < z \leq n ) $$$ replace $$$ a_x $$$ $$$ a_y - a_z $$$ operation $$$ <unknown> $$$ need less $$$ 10^ { 18 } $$$ goal make result array non - decreasing multiple solutions output impossible achieve report well test contain multiple test case first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10000 ) $$$ — number test case $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 3 \leq n \leq 2 \cdot 100000 ) $$$ — size array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( -1000000000 \leq a_i \leq 1000000000 ) $$$ elements $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print $$$ -1 $$$ a single line solution otherwise first line print a single integer $$$ m $$$ $$$ ( 0 \leq m \leq n ) $$$ — number operations perform $$$ i $$$ -th follow $$$ m $$$ line contain three integers $$$ x y z $$$ $$$ ( 1 \leq x < y < z \leq n ) $$$ — description $$$ i $$$ -th operation multiple solutions output note n't minimize number operations task first example array become $$$ [ -6 <unknown> -1,2 ] $$$ first operation $$$ [ -6 -4 -3 -1,2 ] $$$ second operation second example impossible make array sort sequence operations third example array already sort n't need perform operations",['greedy'],1200.0
1635/D,"give array $$$ a $$$ consist $$$ n $$$ distinct positive integers let 's consider infinite integer set $$$ s $$$ contain integers $$$ x $$$ satisfy least one follow condition : example $$$ a = [ 1,2 ] $$$ $$$ 10 $$$ smallest elements $$$ s $$$ $$$ \ { <unknown> } $$$ find number elements $$$ s $$$ strictly smaller $$$ 2^p $$$ since number may large print modulo $$$ 1000000000 + 7 $$$ first line contain two integers $$$ n $$$ $$$ p $$$ $$$ ( 1 \leq n p \leq 2 \cdot 100000 ) $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 1 \leq a_i \leq 1000000000 ) $$$ guarantee number $$$ a $$$ distinct print a single integer number elements $$$ s $$$ strictly smaller $$$ 2^p $$$ remember print modulo $$$ 1000000000 + 7 $$$ first example elements smaller $$$ 2 ^ 4 $$$ $$$ \ { 1 3 4 6 7 9 12 13 15\ } $$$ second example elements smaller $$$ 2 ^ 7 $$$ $$$ \ { <unknown> } $$$","['dp', 'math']",1800.0
1637/B,let array $$$ b_1 b_2 \ldots b_k $$$ let a partition array segment $$$ [ l_1 ; r_1 ] [ l_2 ; r_2 ] \ldots [ <unknown> ; r_c ] $$$ $$$ l_1 = 1 $$$ $$$ r_c = k $$$ $$$ 2 \leq i \leq c $$$ hold $$$ r _ { i-1 } + 1 = l_i $$$ word element array belong exactly one segment let 's define cost a partition $$$ $$$ c + \sum _ { i = 1 } ^ { c } \operatorname { mex } ( \ { b _ { l_i } b _ { l_i + 1 } \ldots b _ { r_i } \ } ) $$$ $$$ $$$ \operatorname { mex } $$$ a set number $$$ s $$$ smallest non - negative integer occur set $$$ s $$$ word cost a partition number segment plus sum mex segment let 's define value array $$$ b_1 b_2 \ldots b_k $$$ maximum possible cost partition array give array $$$ a $$$ size $$$ n $$$ find sum value subsegments array $$$ x $$$ a subsegment array $$$ y $$$ $$$ x $$$ obtain $$$ y $$$ deletion several ( possibly zero ) elements begin several ( possibly zero ) elements end input contain several test case first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 30 $$$ ) — number test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) — length array second line contain a sequence integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) — array elements guarantee sum value $$$ n $$$ test case exceed $$$ 100 $$$ test case print a single integer — answer problem second test case : sum value subsegments equal $$$ 4 + 3 + 1 + 3 + 2 + 1 = 14 $$$,"['dp', 'greedy', 'math']",1100.0
1637/D,give two array $$$ a $$$ $$$ b $$$ length $$$ n $$$ perform follow operation number time ( possibly zero ) : select index $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) swap $$$ a_i $$$ $$$ b_i $$$ let 's define cost array $$$ a $$$ $$$ \sum _ { i=1 } ^ { n } \sum _ { j = i + 1 } ^ { n } ( a_i + a_j ) ^2 $$$ similarly cost array $$$ b $$$ $$$ \sum _ { i=1 } ^ { n } \sum _ { j = i + 1 } ^ { n } ( b_i + b_j ) ^2 $$$ task minimize total cost two array test case consist several test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 40 $$$ ) — number test case follow a description input data set first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 100 $$$ ) — elements first array third line test case contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1 \leq b_i \leq 100 $$$ ) — elements second array guarantee sum $$$ n $$$ test case exceed $$$ 100 $$$ test case print minimum possible total cost second test case one optimal answer operations $$$ a = [ 2 6 4 6 ] $$$ $$$ b = [ 3 7 6 1 ] $$$ cost array $$$ a $$$ equal $$$ ( 2 + 6 ) ^2 + ( 2 + 4 ) ^2 + ( 2 + 6 ) ^2 + ( 6 + 4 ) ^2 + ( 6 + 6 ) ^2 + ( 4 + 6 ) ^2 = 508 $$$ cost array $$$ b $$$ equal $$$ ( 3 + 7 ) ^2 + ( 3 + 6 ) ^2 + ( 3 + 1 ) ^2 + ( 7 + 6 ) ^2 + ( 7 + 1 ) ^2 + ( 6 + 1 ) ^2 = 479 $$$ total cost two array equal $$$ 508 + 479 = 987 $$$,"['dp', 'greedy', 'math']",1800.0
1637/G,"vitaly give maxim $$$ n $$$ number $$$ 1 2 \ldots n $$$ $$$ 16 $$$ -th birthday maxim tire play board game celebration decide play number one step maxim choose two number $$$ x $$$ $$$ y $$$ number throw away add two number $$$ x + y $$$ $$$ |x - y| $$$ instead want number equal several step sum number minimal help maxim find a solution maxim 's friends n't want wait long number step solution exceed $$$ 20n $$$ guarantee give constraints a solution exist exist a solution make number equal minimize sum spend $$$ 20n $$$ move first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 25\,000 $$$ ) — number test case test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 50000 $$$ ) — number integers give maxim guarantee total sum $$$ n $$$ n't exceed $$$ 50000 $$$ test case print $$$ -1 $$$ 's impossible make number equal otherwise print a single integer $$$ s $$$ ( $$$ 0 \le s \le 20n $$$ ) — number step print $$$ s $$$ line $$$ i $$$ -th line must contain two integers $$$ x_i $$$ $$$ y_i $$$ — number maxim choose $$$ i $$$ -th step number must become equal operations n't forget need make number equal also minimize sum guarantee give constraints a solution exist exist a solution make number equal minimize sum spend $$$ 20n $$$ move","['greedy', 'math']",3000.0
1641/B,"olya array integers $$$ a_1 a_2 \ldots a_n $$$ want split tandem repeat since 's rarely possible want perform follow operation several ( possibly zero ) number time : insert a pair equal number arbitrary position help ! formally : test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 30\,000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 500 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — initial array guarantee sum $$$ n^2 $$$ test case exceed $$$ 250\,000 $$$ test case print answer follow format turn array a concatenation tandem repeat print a single integer $$$ -1 $$$ otherwise print number operations $$$ q $$$ ( $$$ 0 \le q \le 2 \cdot n^2 $$$ ) want print descriptions operations follow $$$ q $$$ line print two integers $$$ p $$$ $$$ c $$$ ( $$$ 1 \le c \le 1000000000 $$$ ) mean insert integer $$$ c $$$ twice $$$ p $$$ elements array length array $$$ m $$$ operation condition $$$ 0 \le p \le m $$$ satisfy print way split result array tandem repeat first print a single integer $$$ d $$$ print a sequence $$$ t_1 t_2 \ldots <unknown> $$$ even integers size $$$ d $$$ ( $$$ d t_i \ge 1 $$$ ) number lengths subsegments leave right note size result array $$$ a $$$ $$$ m = n + 2 \cdot q $$$ follow statements must hold : show array turn a concatenation tandem repeat exist a solution satisfy constraints multiple answer print first test case apply operations array make possible split tandem repeat second test case array already a tandem repeat $$$ [ 5 5 ] = \underbrace { ( [ 5 ] + [ 5 ] ) } _ { t_1 = 2 } $$$ thus operations third test case initially follow array : $$$ $$$ [ 1 3 1 2 2 3 ] $$$ $$$ first insertion $$$ p = 1 c = 3 $$$ : $$$ $$$ [ 1 \textbf { 3 3 } 3 1 2 2 3 ] $$$ $$$ second insertion $$$ p = 5 c = 3 $$$ : $$$ $$$ [ 1 3 3 3 1 \textbf { 3 3 } 2 2 3 ] $$$ $$$ third insertion $$$ p = 5 c = 3 $$$ : $$$ $$$ [ 1 3 3 3 1 \textbf { 3 3 } 3 3 2 2 3 ] $$$ $$$ fourth insertion $$$ p = 10 c = 3 $$$ : $$$ $$$ [ 1 3 3 3 1 3 3 3 3 2 \textbf { 3 3 } 2 3 ] $$$ $$$ result array represent a concatenation tandem repeat : $$$ $$$ \underbrace { ( [ 1 3 3 3 ] + [ 1 3 3 3 ] ) } _ { t_1 = 8 } + \underbrace { ( [ 3 2 3 ] + [ 3 2 3 ] ) } _ { t_2 = 6 } $$$ $$$ fourth test case initially follow array : $$$ $$$ [ 3 2 1 1 2 3 ] $$$ $$$ first insertion $$$ p = 0 c = 3 $$$ : $$$ $$$ [ \textbf { 3 3 } 3 2 1 1 2 3 ] $$$ $$$ second insertion $$$ p = 8 c = 3 $$$ : $$$ $$$ [ 3 3 3 2 1 1 2 3 \textbf { 3 3 } ] $$$ $$$ third insertion $$$ p = 5 c = 3 $$$ $$$ $$$ [ 3 3 3 2 1 \textbf { 3 3 } 1 2 3 3 3 ] $$$ $$$ fourth insertion $$$ p = 6 c = 2 $$$ : $$$ $$$ [ 3 3 3 2 1 3 \textbf { 2 2 } 3 1 2 3 3 3 ] $$$ $$$ fifth insertion $$$ p = 7 c = 1 $$$ : $$$ $$$ [ 3 3 3 2 1 3 2 \textbf { 1 1 } 2 3 1 2 3 3 3 ] $$$ $$$ result array represent a concatenation tandem repeat : $$$ $$$ \underbrace { ( [ 3 ] + [ 3 ] ) } _ { t_1 = 2 } + \underbrace { ( [ 3 2 1 ] + [ 3 2 1 ] ) } _ { t_2 = 6 } + \underbrace { ( [ 1 2 3 ] + [ 1 2 3 ] ) } _ { t_3 = 6 } + \underbrace { ( [ 3 ] + [ 3 ] ) } _ { t_4 = 2 } $$$ $$$",['implementation'],2000.0
1644/B,let 's call a permutation $$$ p $$$ length $$$ n $$$ anti - fibonacci condition $$$ p _ { i-2 } + p _ { i-1 } \ne p_i $$$ hold $$$ i $$$ ( $$$ 3 \le i \le n $$$ ) recall permutation array length $$$ n $$$ contain integer $$$ 1 $$$ $$$ n $$$ exactly task a give number $$$ n $$$ print $$$ n $$$ distinct anti - fibonacci permutations length $$$ n $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 48 $$$ ) — number test case single line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 50 $$$ ) test case print $$$ n $$$ line line contain anti - fibonacci permutation length $$$ n $$$ test case print permutation multiple answer print show always possible find $$$ n $$$ different anti - fibonacci permutations size $$$ n $$$ constraints problem,['implementation'],800.0
1646/C,a number call powerful a power two a factorial word number $$$ m $$$ powerful exist a non - negative integer $$$ d $$$ $$$ <unknown> $$$ $$$ m = d ! $$$ $$$ d ! = 1\cdot 2\cdot \ldots \cdot d $$$ ( particular $$$ 0 ! = 1 $$$ ) example $$$ 1 $$$ $$$ 4 $$$ $$$ 6 $$$ powerful number $$$ 1=1 ! $$$ $$$ 4=2 ^ 2 $$$ $$$ <unknown> ! $$$ $$$ 7 $$$ $$$ 10 $$$ $$$ 18 $$$ give a positive integer $$$ n $$$ find minimum number $$$ k $$$ $$$ n $$$ represent sum $$$ k $$$ distinct powerful number say $$$ k $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow a test case consist one line contain one integer $$$ n $$$ ( $$$ 1\le n\le 10^ { 12 } $$$ ) test case print answer a separate line $$$ n $$$ represent sum distinct powerful number print $$$ -1 $$$ otherwise print a single positive integer — minimum possible value $$$ k $$$ first test case $$$ 7 $$$ represent $$$ 7=1 + 6 $$$ $$$ 1 $$$ $$$ 6 $$$ powerful number $$$ 7 $$$ a powerful number know minimum possible value $$$ k $$$ case $$$ k=2 $$$ second test case a possible way represent $$$ 11 $$$ sum three powerful number $$$ <unknown> + 4 + 6 $$$ show way represent $$$ 11 $$$ sum two less powerful number third test case $$$ 240 $$$ represent $$$ <unknown> + 32 + 64 + 120 $$$ observe $$$ <unknown> + 120 $$$ a valid representation powerful number distinct fourth test case $$$ <unknown> { 34 } $$$ $$$ <unknown> $$$ a powerful number minimum $$$ k $$$ case $$$ k=1 $$$,"['dp', 'math']",1500.0
1647/B,madoka 's father reach $$$ 1 $$$ million subscribers <unknown> ! website decide send a personalize award — <unknown> 's bite button ! bite button a rectangular table $$$ n $$$ row $$$ m $$$ columns $$$ 0 $$$ $$$ 1 $$$ cell explore table madoka find : example first illustration red subrectangle nice second one 's 's contain purple subrectangle help madoka determine whether table elegant test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200 $$$ ) — number test case description test case follow first line test case contain two positive integers $$$ n m $$$ ( $$$ 1 \le n m \le 100 $$$ ) next $$$ n $$$ line contain string length $$$ m $$$ consist zero ones — description table guarantee sum value $$$ n $$$ sum value $$$ m $$$ test case exceed $$$ 777 $$$ test case print ` ` yes '' table elegant print ` ` '' otherwise may print letter case ( example ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive answer ) second test case table elegant red purple subrectangles nice intersect fourth test case table elegant red purple subrectangles nice intersect,['implementation'],1200.0
1647/C,madoka a child extremely capricious girl one favorite prank draw wall accord madoka 's memories wall a table $$$ n $$$ row $$$ m $$$ columns consist zero ones coordinate cell $$$ i $$$ -th row $$$ j $$$ -th column ( $$$ 1 \le i \le n $$$ $$$ 1 \le j \le m $$$ ) $$$ ( i j ) $$$ one day saw a picture ` ` <unknown> <unknown> madoka <unknown> '' decide draw wall initially madoka 's table a table size $$$ n \times m $$$ fill zero apply follow operation number time : madoka select rectangular subtable table paint a chess color ( upper leave corner subtable always color $$$ 0 $$$ ) note cells may color several time case final color cell equal color obtain last repaint better understand statement recommend read explanation first test help madoka find sequence $$$ n \cdot m $$$ operations allow obtain picture want determine impossible test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 100 $$$ ) — size table follow $$$ n $$$ line contain a string length $$$ m $$$ consist $$$ 1 $$$ $$$ 0 $$$ — description picture madoka want obtain impossible obtain give picture print $$$ -1 $$$ otherwise print first line a single integer $$$ q $$$ ( $$$ 0 \leq q \leq n \cdot m $$$ ) — number operations need obtain picture note need minimize number operations operation ( order execution ) print a single line contain four number — coordinate upper - left corner lower - right corner rectangle description first test case third test case impossible paint desire picture fourth test case initial table already desire picture,['greedy'],1300.0
1648/B,give array $$$ a $$$ $$$ n $$$ positive integers number $$$ 1 $$$ $$$ n $$$ let 's call array integral two necessarily different number $$$ x $$$ $$$ y $$$ array $$$ x \ge y $$$ number $$$ \left \lfloor \frac { x } { y } \right \rfloor $$$ ( $$$ x $$$ divide $$$ y $$$ round ) also array guarantee number $$$ a $$$ exceed $$$ c $$$ task check whether array integral input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ c $$$ ( $$$ 1 \le n \le 1000000 $$$ $$$ 1 \le c \le 1000000 $$$ ) — size $$$ a $$$ limit number array second line test case contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le c $$$ ) — array $$$ a $$$ let $$$ n $$$ sum $$$ n $$$ test case $$$ c $$$ sum $$$ c $$$ test case guarantee $$$ n \le 1000000 $$$ $$$ c \le 1000000 $$$ test case print yes array integral otherwise first test case easy see array integral : thus condition meet array integral second test case enough see $$$ \left \lfloor \frac { 7 } { 3 } \right \rfloor = \left \lfloor <unknown> { 1 } { 3 } \right \rfloor = 2 $$$ number $$$ a $$$ 's integral third test case $$$ \left \lfloor \frac { 2 } { 2 } \right \rfloor = 1 $$$ $$$ 2 $$$ array 's integral,"['data structures', 'math']",1800.0
1648/E,"berland a large country develop airlines total $$$ n $$$ cities country historically serve berlaflot airline airline operate bi - directional flight $$$ m $$$ pair cities $$$ i $$$ -th connect cities number $$$ a_i $$$ $$$ b_i $$$ a price $$$ c_i $$$ a flight directions know berlaflot flight use get city ( possibly transfer ) cost route consist several consequent flight equal cost expensive formally cost route a city $$$ t_1 $$$ a city $$$ t_k $$$ $$$ ( k-2 ) $$$ transfer use cities $$$ t_2 \ t_3 \ t_4 \ \ldots \ t _ { k - 1 } $$$ equal maximum cost flight $$$ t_1 $$$ $$$ t_2 $$$ $$$ t_2 $$$ $$$ t_3 $$$ $$$ t_3 $$$ $$$ t_4 $$$ flight $$$ t _ { k - 1 } $$$ $$$ t_k $$$ course flight must operate berlaflot a new airline s8 airlines recently start operate berland airline provide bi - directional flight pair cities connect berlaflot direct flight thus pair cities a flight either berlaflot s8 airlines cost s8 airlines flight calculate follow : pair cities $$$ x $$$ $$$ y $$$ connect a s8 airlines flight cost flight equal minimum cost route cities $$$ x $$$ $$$ y $$$ berlaflot accord price describe earlier know help s8 airlines flight get city possible transfer , similarly berlaflot cost a route two cities consist several s8 airlines flight equal cost expensive flight due increase competition s8 airlines berlaflot decide introduce air reform change cost flight namely $$$ i $$$ -th flight cities $$$ a_i $$$ $$$ b_i $$$ berlaflot want make cost flight equal minimum cost route cities $$$ a_i $$$ $$$ b_i $$$ s8 airlines help berlaflot managers calculate new flight cost test consist multiple test case first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10\,000 $$$ ) — amount test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 4 \le n \le 200\,000 $$$ $$$ n - 1 \le m \le 200\,000 $$$ $$$ m \le \frac { ( n - 1 ) ( n - 2 ) } { 2 } $$$ ) — amount cities berland amount berlaflot flight next $$$ m $$$ line contain description berlaflot flight $$$ i $$$ -th line contain three integers $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ $$$ 1 \le c_i \le 1000000000 $$$ ) — number cities connect $$$ i $$$ -th berlaflot flight price $$$ i $$$ -th berlaflot flight guarantee flight connect a city two flight connect pair cities guarantee use berlaflot flight possible get city use s8 airlines flight possible get city let $$$ n $$$ sum $$$ n $$$ test case $$$ m $$$ sum $$$ m $$$ test case guarantee $$$ n m \le 200\,000 $$$ test case print $$$ m $$$ integers a single line $$$ i $$$ -th price $$$ i $$$ -th berlaflot flight air reform first test case s8 airlines provide flight pair cities : $$$ ( 1 3 ) $$$ $$$ ( 1 4 ) $$$ $$$ ( 2 4 ) $$$ cost a flight cities $$$ 1 $$$ $$$ 3 $$$ equal $$$ 2 $$$ since minimum cost berlaflot route $$$ 2 $$$ — route consist a flight cities $$$ 1 $$$ $$$ 2 $$$ cost $$$ 1 $$$ a flight cities $$$ 2 $$$ $$$ 3 $$$ cost $$$ 2 $$$ maximum cost $$$ 2 $$$ cost a flight cities $$$ 1 $$$ $$$ 4 $$$ $$$ 3 $$$ since minimum cost berlaflot route $$$ 3 $$$ — route consist a flight cities $$$ 1 $$$ $$$ 2 $$$ cost $$$ 1 $$$ a flight cities $$$ 2 $$$ $$$ 3 $$$ cost $$$ 2 $$$ a flight cities $$$ 3 $$$ $$$ 4 $$$ cost $$$ 3 $$$ maximum cost $$$ 3 $$$ cost a flight cities $$$ 2 $$$ $$$ 4 $$$ $$$ 3 $$$ since minimum cost berlaflot route $$$ 3 $$$ — route consist a flight cities $$$ 2 $$$ $$$ 3 $$$ cost $$$ 2 $$$ a flight cities $$$ 3 $$$ $$$ 4 $$$ cost $$$ 3 $$$ maximum cost $$$ 3 $$$ air reform cost berlaflot flight cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ since minimum cost s8 airlines route cities $$$ 3 $$$ — route consist a flight cities $$$ 1 $$$ $$$ 4 $$$ cost $$$ 3 $$$ a flight cities $$$ 2 $$$ $$$ 4 $$$ cost $$$ 3 $$$ maximum cost $$$ 3 $$$ cost berlaflot flight cities $$$ 2 $$$ $$$ 3 $$$ $$$ 3 $$$ since minimum cost s8 airlines route cities $$$ 3 $$$ — route consist a flight cities $$$ 2 $$$ $$$ 4 $$$ cost $$$ 3 $$$ a flight cities $$$ 1 $$$ $$$ 4 $$$ cost $$$ 3 $$$ a flight $$$ 1 $$$ $$$ 3 $$$ cost $$$ 2 $$$ maximum cost $$$ 3 $$$ cost berlaflot flight cities $$$ 3 $$$ $$$ 4 $$$ $$$ 3 $$$ since minimum cost s8 airlines route cities $$$ 3 $$$ — route consist a flight cities $$$ 1 $$$ $$$ 3 $$$ cost $$$ 2 $$$ a flight cities $$$ 1 $$$ $$$ 4 $$$ cost $$$ 3 $$$ maximum cost $$$ 3 $$$ second test case s8 airlines follow flight : cities $$$ 1 $$$ $$$ 4 $$$ cost $$$ 1 $$$ cities $$$ 2 $$$ $$$ 3 $$$ cost $$$ 1 $$$ cities $$$ 2 $$$ $$$ 5 $$$ cost $$$ 2 $$$ cities $$$ 3 $$$ $$$ 4 $$$ cost $$$ 1 $$$ cities $$$ 3 $$$ $$$ 5 $$$ cost $$$ 2 $$$","['data structures', 'implementation']",3200.0
1651/A,"consider a playoff tournament $$$ 2^n $$$ athletes compete athletes number $$$ 1 $$$ $$$ 2^n $$$ tournament hold $$$ n $$$ stag stage athletes split pair a way athlete belong exactly one pair pair athletes compete exactly one win winner pair advance next stage athlete defeat get eliminate tournament pair form follow : athletes $$$ x $$$ $$$ y $$$ compete winner decide follow : follow picture describe way tournament $$$ n = 3 $$$ go task follow one : give integer $$$ n $$$ determine index athlete win tournament first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 30 $$$ ) — number test case test case consist one line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 30 $$$ ) test case print one integer — index winner tournament case $$$ n = 3 $$$ show picture statement $$$ n = 1 $$$ 's one match athletes $$$ 1 $$$ $$$ 2 $$$ since $$$ 1 + 2 = 3 $$$ odd number athlete lower index win , athlete $$$ 1 $$$ winner",['implementation'],800.0
1654/D,"alice 's potion make professor give follow assignment students : brew a potion use $$$ n $$$ ingredients proportion ingredient $$$ i $$$ final potion $$$ r_i > 0 $$$ ( $$$ r_1 + r_2 + \cdots + r_n = 1 $$$ ) forget recipe remember a set $$$ n-1 $$$ facts form ` ` ingredients $$$ i $$$ $$$ j $$$ a ratio $$$ x $$$ $$$ y $$$ ` ` ( i.e. $$$ a_i $$$ $$$ a_j $$$ amount ingredient $$$ i $$$ $$$ j $$$ potion respectively must hold $$$ a_i / a_j = x / y $$$ ) $$$ x $$$ $$$ y $$$ positive integers however guarantee set facts remember sufficient uniquely determine original value $$$ r_i $$$ decide allow students pass class long submit a potion satisfy $$$ n-1 $$$ requirements ( may many satisfactory potions ) contain a positive integer amount ingredient find minimum total amount ingredients need make a potion pass class result large print answer modulo $$$ 998\,244\,353 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) next $$$ n-1 $$$ line contain four integers $$$ i j x y $$$ ( $$$ 1 \le i j \le n $$$ $$$ <unknown> = j $$$ $$$ 1\le x y \le n $$$ ) — ingredients $$$ i $$$ $$$ j $$$ a ratio $$$ x $$$ $$$ y $$$ guarantee set facts sufficient uniquely determine original value $$$ r_i $$$ also guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print minimum total amount ingredients need make a potion pass class modulo $$$ 998\,244\,353 $$$ first test case minimum total amount ingredients $$$ 69 $$$ fact amount ingredients $$$ 1 2 3 4 $$$ a valid potion $$$ 16 12 9 32 $$$ respectively potion valid second test case amount ingredients $$$ 1 2 3 4 5 6 7 8 $$$ potion minimize total amount ingredients $$$ 60 60 24 48 32 60 45 30 $$$",['math'],2100.0
1656/H,give two set positive integers $$$ a $$$ $$$ b $$$ find two non - empty subsets $$$ s_a \subseteq a $$$ $$$ s_b \subseteq b $$$ least common multiple ( lcm ) elements $$$ s_a $$$ equal least common multiple ( lcm ) elements $$$ s_b $$$ input consist multiple test case first line input contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 200 $$$ ) number test case test case one line contain two integers $$$ n m $$$ ( $$$ 1 \leq n m \leq 1000 $$$ ) size set $$$ a $$$ $$$ b $$$ respectively next line contain $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 4 \cdot 10^ { 36 } $$$ ) elements $$$ a $$$ next line contain $$$ m $$$ distinct integers $$$ b_1 b_2 \ldots b_m $$$ ( $$$ 1 \leq b_i \leq 4 \cdot 10^ { 36 } $$$ ) elements $$$ b $$$ sum $$$ n $$$ test case sum $$$ m $$$ test case $$$ 1000 $$$ test case exist two subsets equal least common multiple output one line otherwise output one line yes follow a line two integers $$$ |s_a| |s_b| $$$ ( $$$ 1 \leq |s_a| \leq n $$$ $$$ 1 \leq |s_b| \leq m $$$ ) size subsets $$$ s_a $$$ $$$ s_b $$$ next line contain $$$ |s_a| $$$ integers $$$ x_1 x_2 \ldots x _ { |s_a| } $$$ elements $$$ s_a $$$ follow a line $$$ |s_b| $$$ integers $$$ y_1 y_2 \ldots y _ { |s_b| } $$$ elements $$$ s_b $$$ multiple possible pair subsets print,"['data structures', 'math']",3200.0
1658/B,"marin want count number permutations beautiful a beautiful permutation length $$$ n $$$ a permutation follow property : $$$ $$$ \gcd ( 1 \cdot p_1 \ 2 \cdot p_2 \ \dots \ n \cdot p_n ) > 1 $$$ $$$ $$$ \gcd $$$ greatest common divisor a permutation array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3 4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case consist one line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) test case print one integer — number beautiful permutations answer big please print answer modulo $$$ 998\,244\,353 $$$ first test case one permutation $$$ [ 1 ] $$$ beautiful $$$ \gcd ( 1 \cdot 1 ) = 1 $$$ second test case one beautiful permutation $$$ [ 2 1 ] $$$ $$$ \gcd ( 1 \cdot 2 2 \cdot 1 ) = 2 $$$",['math'],800.0
1659/C,"<unknown> king want emperor <unknown> , must first become emperor integers consider a number axis capital empire initially $$$ 0 $$$ $$$ n $$$ <unknown> kingdoms position $$$ 0 < x_1 < x_2 < \ldots < x_n $$$ want conquer kingdoms two action available : note place capital a point without a kingdom word point capital $$$ 0 $$$ one $$$ x_1 x_2 \ldots x_n $$$ also note conquer a kingdom change position capital find minimum total cost conquer kingdoms capital anywhere end first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case description test case follow first line test case contain $$$ 3 $$$ integers $$$ n $$$ $$$ a $$$ $$$ b $$$ ( $$$ 1 \leq n \leq 200000 $$$ ; $$$ 1 \leq a b \leq 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ x_1 x_2 \ldots x_n $$$ ( $$$ 1 \leq x_1 < x_2 < \ldots < x_n \leq 100000000 $$$ ) sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a single integer — minimum cost conquer kingdoms optimal sequence move second test case : total cost $$$ 3 + 6 + 12 + 24 + 3 + 48 + <unknown> $$$ get a lower cost","['dp', 'greedy', 'implementation', 'math']",1500.0
1666/F,"little fiona a collection $$$ n $$$ block various size $$$ a_1 a_2 \ldots a_n $$$ $$$ n $$$ even block equal size would like put block one onto another form a fancy stack let $$$ b_1 b_2 \ldots b_n $$$ size block stack top bottom since fiona use block $$$ b_1 b_2 \ldots b_n $$$ must a permutation $$$ a_1 a_2 \ldots a_n $$$ fiona think stack fancy follow condition satisfy : two stack consider different correspond sequence $$$ b_1 b_2 \ldots b_n $$$ differ least one position fiona want know many different fancy stack build block since large number scare fiona find number modulo $$$ 998\,244\,353 $$$ input contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 2500 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ — number block fiona 's disposal ( $$$ 2 \le n \le 5000 $$$ ; $$$ n $$$ even ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ — size block non - decreasing order ( $$$ 1 \le a_1 \le a_2 \le <unknown> \le a_n \le n $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ test case print number ways build a fancy stack modulo $$$ 998\,244\,353 $$$","['dp', 'implementation']",2200.0
1666/J,"julia 's $$$ n $$$ friends want organize a startup a new country move assign number 1 $$$ n $$$ accord job front - end task back - end ones also estimate a matrix $$$ c $$$ $$$ c _ { ij } = c _ { ji } $$$ average number message per month people job $$$ i $$$ $$$ j $$$ want make a hierarchy tree a binary tree node contain one member team member select a leader team contain root node order leader able easily reach subordinate node $$$ v $$$ tree follow apply : members leave subtree must smaller number $$$ v $$$ members right subtree must larger number $$$ v $$$ hierarchy tree settle people job $$$ i $$$ $$$ j $$$ communicate via shortest path tree nod let 's denote length path $$$ d _ { ij } $$$ thus cost communication $$$ c _ { ij } \cdot d _ { ij } $$$ task find a hierarchy tree minimize total cost communication pair : $$$ \sum _ { 1 \le i < j \le n } c _ { ij } \cdot d _ { ij } $$$ first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 200 $$$ ) – number team members organize a startup next $$$ n $$$ line contain $$$ n $$$ integers $$$ j $$$ -th number $$$ i $$$ -th line $$$ c _ { ij } $$$ — estimate number message per month team members $$$ i $$$ $$$ j $$$ ( $$$ 0 \le c _ { ij } \le 1000000000 ; c _ { ij } = c _ { ji } ; c _ { ii } = 0 $$$ ) output a description a hierarchy tree minimize total cost communication , team member 1 $$$ n $$$ output number member parent node 0 leader many optimal tree output a description one minimal possible total cost $$$ <unknown> \cdot 1 + 239 \cdot 1 + 30 \cdot 1 + 1 \cdot 2 + 1 \cdot <unknown> $$$ :",['dp'],2100.0
1667/E,"consider every tree ( connect undirected acyclic graph ) $$$ n $$$ vertices ( $$$ n $$$ odd vertices number $$$ 1 $$$ $$$ n $$$ ) $$$ 2 \le i \le n $$$ $$$ i $$$ -th vertex adjacent exactly one vertex a smaller index $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) calculate number tree $$$ i $$$ -th vertex centroid answer huge output modulo $$$ 998\,244\,353 $$$ a vertex call a centroid removal split tree subtrees $$$ ( n-1 ) /2 $$$ vertices first line contain odd integer $$$ n $$$ ( $$$ 3 \le n < 200000 $$$ $$$ n $$$ odd ) — number vertices tree print $$$ n $$$ integers a single line $$$ i $$$ -th integer answer $$$ i $$$ -th vertex ( modulo $$$ 998\,244\,353 $$$ ) example $$$ 1 $$$ : two possible tree : edge $$$ ( 1 - 2 ) $$$ $$$ ( 1 - 3 ) $$$ — centroid $$$ 1 $$$ ; edge $$$ ( 1 - 2 ) $$$ $$$ ( 2 - 3 ) $$$ — centroid $$$ 2 $$$ answer $$$ 1 1 0 $$$ example $$$ 2 $$$ : $$$ 24 $$$ possible tree example edge $$$ ( 1 - 2 ) $$$ $$$ ( 2 - 3 ) $$$ $$$ ( 3 - 4 ) $$$ $$$ ( 4 - 5 ) $$$ centroid $$$ 3 $$$","['dp', 'math']",3000.0
1667/F,"give a rectangular grid $$$ n $$$ row $$$ m $$$ columns $$$ n $$$ $$$ m $$$ divisible $$$ 4 $$$ cells already color black white guarantee two color cells share a corner edge color remain cells a way black white cells become orthogonally connect determine impossible consider a graph black cells nod two nod adjacent correspond cells share edge describe graph connect black cells orthogonally connect white cells input consist multiple test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 4000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 8 \le n m \le 500 $$$ $$$ n $$$ $$$ m $$$ divisible $$$ 4 $$$ ) — number row columns next $$$ n $$$ line contain $$$ m $$$ character character either ' b ' ' w ' ' ' represent black white empty cell respectively two color ( black white ) cell share a corner edge guarantee sum $$$ n \cdot m $$$ test case exceed $$$ 250\,000 $$$ testcase print ` ` '' solution otherwise print ` ` yes '' a grid format multiple solutions print solution test case 1 : test case 2 : one see black white part ca n't connect time answer ` ` ''",['implementation'],3500.0
1669/C,give array $$$ a= [ a_1 a_2 \dots a_n ] $$$ $$$ n $$$ positive integers operations two type : determine number operations possible make final array contain even number odd number word determine make elements array parity number operations note operations type number time ( even none ) operations different type perform a different number time first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 50 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq 1000 $$$ ) — elements array note perform operations elements array become greater $$$ 1000 $$$ output $$$ t $$$ line contain answer correspond test case answer output ` ` yes '' number operations possible make final array contain even number odd number ` ` '' otherwise output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ) first test case increment elements even index obtain array $$$ [ 1 3 1 ] $$$ contain odd number answer ` ` yes '' second test case show perform number operations wo n't able make elements parity answer ` ` '' third test case elements already parity answer ` ` yes '' fourth test case perform one operation increase elements odd position $$$ 1 $$$ thus obtain array $$$ [ 1001 1 1001 1 1001 ] $$$ elements become odd answer ` ` yes '',"['greedy', 'greedy', 'implementation', 'math']",800.0
1669/E,give $$$ n $$$ string length $$$ 2 $$$ consist lowercase latin alphabet letter ' a ' ' k ' output number pair indices $$$ ( i j ) $$$ $$$ i < j $$$ $$$ i $$$ -th string $$$ j $$$ -th string differ exactly one position word count number pair $$$ ( i j ) $$$ ( $$$ i < j $$$ ) $$$ i $$$ -th string $$$ j $$$ -th string exactly one position $$$ p $$$ ( $$$ 1 \leq p \leq 2 $$$ ) $$$ { s _ { i } } _ { p } \neq { s _ { j } } _ { p } $$$ answer may fit 32 - bit integer type use 64 - bit integers like long long c++ avoid integer overflow first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number string follow $$$ n $$$ line $$$ i $$$ -th contain a single string $$$ s_i $$$ length $$$ 2 $$$ consist lowercase latin letter ' a ' ' k ' guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print a single integer — number pair $$$ ( i j ) $$$ ( $$$ i < j $$$ ) $$$ i $$$ -th string $$$ j $$$ -th string exactly one position $$$ p $$$ ( $$$ 1 \leq p \leq 2 $$$ ) $$$ { s _ { i } } _ { p } \neq { s _ { j } } _ { p } $$$ please note answer test case wo n't fit 32 - bit integer type use least 64 - bit integer type program language ( like long long c++ ) first test case pair differ exactly one position : ( ` ` ab '' ` ` cb '' ) ( ` ` ab '' ` ` db '' ) ( ` ` ab '' ` ` aa '' ) ( ` ` cb '' ` ` db '' ) ( ` ` cb '' ` ` cc '' ) second test case pair differ exactly one position : ( ` ` aa '' ` ` ac '' ) ( ` ` aa '' ` ` ca '' ) ( ` ` cc '' ` ` ac '' ) ( ` ` cc '' ` ` ca '' ) ( ` ` ac '' ` ` aa '' ) ( ` ` ca '' ` ` aa '' ) third test case pair satisfy condition,"['data structures', 'math']",1200.0
1669/H,let $$$ \mathsf { } $$$ denote bitwise operation $$$ \mathsf { } $$$ denote bitwise operation give array $$$ a $$$ length $$$ n $$$ a non - negative integer $$$ k $$$ perform $$$ k $$$ operations array follow type : output maximum possible value $$$ a_1 $$$ $$$ \mathsf { } $$$ $$$ a_2 $$$ $$$ \mathsf { } $$$ $$$ \dots $$$ $$$ \mathsf { } $$$ $$$ a_n $$$ perform $$$ k $$$ operations first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 0 \le k \le 1000000000 $$$ ) a single line follow contain $$$ n $$$ integers describe array $$$ a $$$ ( $$$ 0 \leq a_i < 2^ { 31 } $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a single line contain maximum possible $$$ \mathsf { } $$$ value $$$ a_1 $$$ $$$ \mathsf { } $$$ $$$ a_2 $$$ $$$ \mathsf { } $$$ $$$ \dots $$$ $$$ \mathsf { } $$$ $$$ a_n $$$ perform $$$ k $$$ operations first test case set bite $$$ 1 $$$ ( $$$ 2 ^ 1 $$$ ) last $$$ 2 $$$ elements use $$$ 2 $$$ operations thus obtain array [ $$$ 2 $$$ $$$ 3 $$$ $$$ 3 $$$ ] $$$ \mathsf { } $$$ value equal $$$ 2 $$$ second test case ca n't perform operations answer $$$ \mathsf { } $$$ whole array $$$ 4 $$$,"['greedy', 'math']",1300.0
1671/A,"give a string $$$ s $$$ determine whether possible build string $$$ s $$$ string aa aaa bb and/or bbb concatenate use string aa aaa bb and/or bbb number time order example : first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case consist one line contain string $$$ s $$$ ( $$$ 1 \le |s| \le 50 $$$ ) consist character a and/or b. test case print yes possible build string $$$ s $$$ otherwise print may print letter case ( example yes yes yes recognize positive answer , recognize negative answer ) first four test case example describe statement",['implementation'],800.0
1671/B,give $$$ n $$$ point integer coordinate a coordinate axis $$$ ox $$$ coordinate $$$ i $$$ -th point $$$ x_i $$$ point ' coordinate distinct give strictly increase order point $$$ i $$$ follow operation : take point move $$$ 1 $$$ leave right ( i .. e. change coordinate $$$ x_i $$$ $$$ x_i - 1 $$$ $$$ x_i + 1 $$$ ) word point choose ( separately ) new coordinate $$$ i $$$ -th point either $$$ x_i - 1 $$$ $$$ x_i $$$ $$$ x_i + 1 $$$ task determine move point describe a way new set point form a consecutive segment integers i. e. integer $$$ l $$$ coordinate point equal $$$ l l + 1 \ldots l + n - 1 $$$ note result point distinct coordinate answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number point set $$$ x $$$ second line test case contain $$$ n $$$ integers $$$ x_1 < x_2 < \ldots < x_n $$$ ( $$$ 1 \le x_i \le 1000000 $$$ ) $$$ x_i $$$ coordinate $$$ i $$$ -th point guarantee point give strictly increase order ( also mean coordinate distinct ) also guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print answer — set point test case move form a consecutive segment integers print yes otherwise print,['math'],1000.0
1672/F1,"oolimry array $$$ a $$$ length $$$ n $$$ really like today change array $$$ b $$$ a permutation $$$ a $$$ make sad oolimry a duck perform follow operation restore array : sadness array $$$ b $$$ minimum number operations need transform $$$ b $$$ $$$ a $$$ give array $$$ a $$$ find array $$$ b $$$ a permutation $$$ a $$$ maximum sadness permutations array $$$ a $$$ test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — elements array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ — describe array $$$ b $$$ multiple answer may print first test case array $$$ [ 1,2 ] $$$ sadness $$$ 1 $$$ transform $$$ [ 1,2 ] $$$ $$$ [ 2,1 ] $$$ use one operation $$$ ( i j ) = ( 1,2 ) $$$ second test case array $$$ [ 3,3,2,1 ] $$$ sadness $$$ 2 $$$ transform $$$ [ 3,3,2,1 ] $$$ $$$ [ 1,2,3,3 ] $$$ two operations $$$ ( i j ) = ( 1,4 ) $$$ $$$ ( i j ) = ( 2,3 ) $$$ respectively",['greedy'],2000.0
1673/C,"give a positive integer $$$ n $$$ let 's call positive integer $$$ a $$$ without lead zero palindromic remain reverse order digits find number distinct ways express $$$ n $$$ a sum positive palindromic integers two ways consider different frequency least one palindromic integer different example $$$ 5=4 + 1 $$$ $$$ 5=3 + 1 + 1 $$$ consider different $$$ 5=3 + 1 + 1 $$$ $$$ <unknown> + 3 + 1 $$$ consider formally need find number distinct multisets positive palindromic integers sum equal $$$ n $$$ since answer quite large print modulo $$$ 1000000000 + 7 $$$ first line input contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 10000 $$$ ) denote number testcases testcase contain a single line input contain a single integer $$$ n $$$ ( $$$ 1\leq n\leq 4\cdot 10000 $$$ ) — require sum palindromic integers testcase print a single integer denote require answer modulo $$$ 1000000000 + 7 $$$ first testcase $$$ 7 $$$ ways partition $$$ 5 $$$ a sum positive palindromic integers : second testcase total $$$ 77 $$$ ways partition $$$ 12 $$$ a sum positive integers among partition $$$ <unknown> + 10 $$$ $$$ <unknown> + 1 + 10 $$$ $$$ <unknown> $$$ valid partition $$$ 12 $$$ a sum positive palindromic integers $$$ 10 $$$ $$$ 12 $$$ palindromic , $$$ 74 $$$ ways partition $$$ 12 $$$ a sum positive palindromic integers","['dp', 'math']",1500.0
1675/C,"polycarp buy a new expensive paint decide show $$$ n $$$ friends hang room $$$ n $$$ friends enter exit one one one moment one person room word first friend enter leave first second , know begin ( visit friends ) a picture hang room end ( $$$ n $$$ -th friend ) turn disappear exact moment disappear — information polycarp ask friends one one ask one a picture enter room friend answer one three : everyone except thief either n't remember tell truth thief say anything ( three options ) polycarp understand thief ask find number consider a thief accord answer first number $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test follow a description test case first line test case contain one string $$$ s $$$ ( length exceed $$$ 200000 $$$ ) — a description friends ' answer $$$ s_i $$$ indicate answer $$$ i $$$ -th friend character string either 0 1 ? give <unknown> describe actual situation particular basis answer least one friend suspect steal a paint guarantee sum string lengths entire input data set exceed $$$ 200000 $$$ output one positive ( strictly zero ) number – number people could steal picture base data show first case answer $$$ 1 $$$ since exactly $$$ 1 $$$ friend second case similar first third case suspect third fourth friends ( count one ) show one else could thief fourth case know absolutely nothing suspect everyone",['implementation'],1100.0
1675/G,"nastya bake $$$ m $$$ pancakes spread $$$ n $$$ dish dish a row number leave right put $$$ a_i $$$ pancakes dish index $$$ i $$$ see dish vlad decide bring order stack move pancakes one move shift one pancake dish closest one , select dish $$$ i $$$ ( $$$ a_i > 0 $$$ ) one follow : vlad want make array $$$ a $$$ non - increasing move pancakes possible help find minimum number move need array $$$ a= [ a_1 a_2 \dots a_n ] $$$ call non - increasing $$$ a_i \ge a _ { i+1 } $$$ $$$ i $$$ $$$ 1 $$$ $$$ n-1 $$$ first line input contain two number $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 250 $$$ ) — number dish number pancakes respectively second line contain $$$ n $$$ number $$$ a_i $$$ ( $$$ 0 \le a_i \le m $$$ ) sum $$$ a_i $$$ equal $$$ m $$$ print a single number : minimum number move require make array $$$ a $$$ non - increasing first example first need move pancake dish $$$ 1 $$$ $$$ a = [ 4 4 2 3 3 3 ] $$$ , need move pancake dish $$$ 2 $$$ dish $$$ 3 $$$ array become non - growing $$$ a = [ 4 3 3 3 3 3 ] $$$",['dp'],2300.0
1676/B,"$$$ n $$$ box different quantities candy $$$ i $$$ -th box $$$ a_i $$$ candy inside also $$$ n $$$ friends want give candy decide give friend a box candy , n't want friends get upset decide eat ( possibly none ) candy box box quantity candy note may eat a different number candy different box add candy box 's minimum total number candy eat satisfy requirements ? first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 50 $$$ ) — number box second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq 10000000 $$$ ) — quantity candy box test case print a single integer denote minimum number candy eat satisfy requirements first test case eat $$$ 1 $$$ candy second box $$$ 2 $$$ candy third box $$$ 3 $$$ candy fourth box $$$ 4 $$$ candy fifth box box $$$ [ 1 1 1 1 1 ] $$$ candy eat $$$ 0 + 1 + 2 + 3 + 4 = 10 $$$ candy total answer $$$ 10 $$$ second test case best answer obtain make box contain $$$ 5 $$$ candy thus eat $$$ 995 + 995 + 0 + 995 + 995 + 995 = <unknown> $$$ candy total","['greedy', 'math']",800.0
1677/B,"tokitsukaze arrange a meet $$$ n $$$ row $$$ m $$$ columns seat meet hall exactly $$$ n \cdot m $$$ students attend meet include several naughty students several serious students students numerate $$$ 1 $$$ $$$ n\cdot m $$$ students enter meet hall order $$$ i $$$ -th student enter meet hall sit $$$ 1 $$$ -st column $$$ 1 $$$ -st row students already seat move back one seat specifically student sit $$$ j $$$ -th ( $$$ 1\leq j \leq m-1 $$$ ) column $$$ i $$$ -th row move $$$ ( j+1 ) $$$ -th column $$$ i $$$ -th row student sit $$$ m $$$ -th column $$$ i $$$ -th row move $$$ 1 $$$ -st column $$$ ( i+1 ) $$$ -th row example a meet hall $$$ 2 $$$ row $$$ 2 $$$ columns seat show : $$$ 4 $$$ students enter meet hall order represent a binary string ` ` 1100 '' ' 0 ' represent naughty students ' 1 ' represent serious students change seat meet hall follow : denote a row a column good least one serious student row column please predict number good row columns $$$ i $$$ -th student enter meet hall $$$ i $$$ first contain a single positive integer $$$ t $$$ ( $$$ 1 \leq t \leq 10\,000 $$$ ) — number test case test case first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 1000000 $$$ ; $$$ 1 \leq n \cdot m \leq 1000000 $$$ ) denote $$$ n $$$ row $$$ m $$$ columns seat meet hall second line contain a binary string $$$ s $$$ length $$$ n \cdot m $$$ consist zero ones $$$ s_i $$$ equal ' 0 ' represent $$$ i $$$ -th student a naughty student $$$ s_i $$$ equal ' 1 ' represent $$$ i $$$ -th student a serious student guarantee sum $$$ n \cdot m $$$ test case exceed $$$ 1000000 $$$ test case print a single line $$$ n \cdot m $$$ integers — number good row columns $$$ i $$$ -th student enter meet hall first test case show statement $$$ 1 $$$ -st student enter meet hall $$$ 2 $$$ good row columns : $$$ 1 $$$ -st row $$$ 1 $$$ -st column $$$ 2 $$$ -nd student enter meet hall $$$ 3 $$$ good row columns : $$$ 1 $$$ -st row $$$ 1 $$$ -st column $$$ 2 $$$ -nd column $$$ 3 $$$ -rd student enter meet hall $$$ 4 $$$ row columns good $$$ 4 $$$ -th student enter meet hall $$$ 3 $$$ good row columns : $$$ 2 $$$ -nd row $$$ 1 $$$ -st column $$$ 2 $$$ -nd column","['data structures', 'implementation', 'math']",1700.0
1677/F,"tokitsukaze a sequence length $$$ n $$$ like gems much $$$ n $$$ kinds gems gems $$$ i $$$ -th kind $$$ i $$$ -th position $$$ a_i $$$ gems kind position define $$$ g ( l r ) $$$ multiset contain gems segment $$$ [ l r ] $$$ ( inclusive ) a multiset gems represent $$$ s= [ s_1 s_2 \ldots s_n ] $$$ a non - negative integer sequence length $$$ n $$$ mean $$$ s $$$ contain $$$ s_i $$$ gems $$$ i $$$ -th kind multiset a multiset $$$ t= [ t_1 t_2 \ldots t_n ] $$$ a <unknown> $$$ s= [ s_1 s_2 \ldots s_n ] $$$ $$$ t_i\le s_i $$$ $$$ i $$$ satisfy $$$ 1\le i\le n $$$ , give two positive integers $$$ k $$$ $$$ p $$$ need calculate result $$$ $$$ \sum _ { l=1 } ^n \sum _ { r = l } <unknown> _ { [ t_1 t_2 \cdots t_n ] \subseteq g ( l r ) } \left ( \left ( \sum _ { i=1 } ^n p^ { t_i } <unknown> ) \left ( \sum _ { i=1 } ^n [ t_i > 0 ] \right ) \right ) $$$ $$$ $$$ [ t_i > 0 ] = 1 $$$ $$$ t_i > 0 $$$ $$$ [ t_i > 0 ] = 0 $$$ $$$ t_i=0 $$$ since answer quite large print modulo $$$ 998\,244\,353 $$$ first line contain three integers $$$ n $$$ $$$ k $$$ $$$ p $$$ ( $$$ 1\le n \le 100000 $$$ ; $$$ 1\le k\le 100000 $$$ ; $$$ 2\le p\le 998\,244\,351 $$$ ) — length sequence number $$$ k $$$ $$$ p $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1\le a_i\le 998\,244\,351 $$$ ) — number gems $$$ i $$$ -th position print a single integers — result modulo $$$ 998\,244\,353 $$$","['dp', 'math']",3500.0
1678/B1,"easy version problem difference two versions harder version ask additionally a minimum number subsegments tokitsukaze a binary string $$$ s $$$ length $$$ n $$$ consist zero ones $$$ n $$$ even tokitsukaze divide $$$ s $$$ minimum number contiguous subsegments subsegment bits subsegment , $$$ s $$$ consider good lengths subsegments even example $$$ s $$$ ` ` 11001111 '' divide ` ` 11 '' ` ` 00 '' ` ` 1111 '' lengths $$$ 2 $$$ $$$ 2 $$$ $$$ 4 $$$ respectively even number ` ` 11001111 '' good another example $$$ s $$$ ` ` 1110011000 '' divide ` ` 111 '' ` ` 00 '' ` ` 11 '' ` ` 000 '' lengths $$$ 3 $$$ $$$ 2 $$$ $$$ 2 $$$ $$$ 3 $$$ obviously ` ` 1110011000 '' good tokitsukaze want make $$$ s $$$ good change value position $$$ s $$$ specifically perform operation number time : change value $$$ s_i $$$ ' 0 ' ' 1 ' ( $$$ 1 \leq i \leq n $$$ ) tell minimum number operations make $$$ s $$$ good ? first contain a single positive integer $$$ t $$$ ( $$$ 1 \leq t \leq 10\,000 $$$ ) — number test case test case first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 200000 $$$ ) — length $$$ s $$$ guarantee $$$ n $$$ even second line contain a binary string $$$ s $$$ length $$$ n $$$ consist zero ones guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print a single line one integer — minimum number operations make $$$ s $$$ good first test case one ways make $$$ s $$$ good follow change $$$ s_3 $$$ $$$ s_6 $$$ $$$ s_7 $$$ ' 0 ' $$$ s $$$ become ` ` 1100000000 '' divide ` ` 11 '' ` ` 00000000 '' lengths $$$ 2 $$$ $$$ 8 $$$ respectively ways operate $$$ 3 $$$ time make $$$ s $$$ good ` ` 1111110000 '' ` ` 1100001100 '' ` ` 1111001100 '' second third fourth test case $$$ s $$$ good initially operation require",['implementation'],800.0
1679/A,"spring come management avtobus bus fleet give order replace winter tire summer tire bus a small bus service business receive order replace $$$ n $$$ tire know bus fleet own two type bus : two axles ( bus $$$ 4 $$$ wheel ) three axles ( bus $$$ 6 $$$ wheel ) n't know many bus type avtobus bus fleet own wonder many bus fleet might determine minimum maximum number bus fleet know total number wheel bus $$$ n $$$ first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1\,000 $$$ ) — number test case follow line contain description test case line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 10^ { 18 } $$$ ) — total number wheel bus test case print answer a single line use follow format print two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x \le y $$$ ) — minimum maximum possible number bus bus fleet suitable number bus give $$$ n $$$ print number $$$ -1 $$$ answer first test case total number wheel $$$ 4 $$$ mean one bus two axles bus fleet second test case 's easy show suitable number bus $$$ 7 $$$ wheel total third test case total number wheel $$$ 24 $$$ follow options possible : minimum number bus $$$ 4 $$$ maximum number bus $$$ 6 $$$","['greedy', 'math']",900.0
168/A,"country <unknown> wizards want organize a demonstration n people live city x wizards surely go demonstration city people ( n - x people ) support wizards n't go go demonstration know city administration react demonstration involve least y percent city people consider matter wizards decide create clone puppets substitute city people demonstration , demonstration involve wizards puppets city administration tell difference a <unknown> a person , calculate percentage administration consider city consist n people contain clone puppets help wizards find minimum number clone create demonstration less y percent city people first line contain three space - separated integers n x y ( 1 ≤ n x y ≤ 104 x ≤ n ) — number citizens city number wizards percentage administration need correspondingly please note y exceed 100 percent , administration want see a demonstration people actually live city ( > n ) print a single integer — answer problem minimum number clone create demonstration involve less y percent n ( real total city population ) first sample necessary least 14 % 10 people come demonstration number people integer least two people come one wizard live city go come n't enough need create one clone second sample 10 people come demonstration city 10 wizards come demonstration nobody create clone","['implementation', 'math']",900.0
168/B,"let 's dive one interest areas magic — write spell learn excite challenge science troublesome learn magic word get know basic rule write spell spell consist several line line whose first non - space character character ` ` # '' amplify line responsible spell power remain line common determine effect spell come across text spell spell long understand mean want make short possible without change mean way shorten a spell know removal space line break know come texts spell space carry mean amplify line remove space line newlines also matter unless two separate line amplify thus two consecutive line amplify need join one ( i.e concatenate second line first one ) remove space amplify line concatenate amplify line anything forbid note empty line must process like others : must join adjacent non - <unknown> line preserve output surround amplify line side ( i.e line one amplify line one amplify ) instructions remove unnecessary character follow ( oh yes a newline a character ) input contain text spell reduce remove extra character print result output input contain multiple line character line cod 32 127 ( inclusive ) please note line may begin end one space size input exceed <unknown> ( = 220 ) bytes newlines include size windows operate system use test computer a newline a sequence character cod # 13 # 10 guarantee line input a newline particular input end a newline note newline end line begin next one guarantee input contain least one character a newline recommend organize input - output line line case newlines process correctly language mean print text spell extra character delete please note output line follow a newline please careful : answer validate compare jury 's answer byte - by - byte , space newlines matter first sample amplify line line 1 7 . line 2 6 concatenate space delete second sample amplify line line 1 3 . line concatenate",['implementation'],1700.0
1681/E,find a map a <unknown> shape labyrinth map a grid consist $$$ n $$$ row $$$ n $$$ columns row grid number $$$ 1 $$$ $$$ n $$$ bottom top columns grid number $$$ 1 $$$ $$$ n $$$ leave right labyrinth $$$ n $$$ layer first layer bottom leave corner ( cell $$$ ( 1 1 ) $$$ ) second layer consist cells grid adjacent first layer a side a corner third layer consist cells grid adjacent second layer a side a corner   labyrinth $$$ 5 $$$ layer example shape follow : layer separate one another wall however doors wall layer ( except layer $$$ n $$$ ) exactly two doors next layer one door place top wall layer another door place right wall layer layer $$$ 1 $$$ $$$ n-1 $$$ give position two doors doors pass directions : either layer $$$ i $$$ layer $$$ i+1 $$$ layer $$$ i+1 $$$ layer $$$ i $$$ stand cell move adjacent a side cell a wall n't block move ( e.g ca n't move a cell another layer door cells ) $$$ m $$$ query sort : 's minimum number move one make go cell $$$ ( x_1 y_1 ) $$$ cell $$$ ( x_2 y_2 ) $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — number layer labyrinth $$$ i $$$ -th next $$$ n-1 $$$ line contain four integers $$$ d _ { 1 x } d _ { 1 y } d _ { 2 x } $$$ $$$ d _ { 2 y } $$$ ( $$$ 1 \le d _ { 1 x } d _ { 1 y } d _ { 2 x } d _ { 2 y } \le n $$$ ) — coordinate doors cells $$$ i $$$ -th layer first cell adjacent top wall $$$ i $$$ -th layer a side — side door second cell adjacent right wall $$$ i $$$ -th layer a side — side door next line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 200000 $$$ ) — number query $$$ j $$$ -th next $$$ m $$$ line contain four integers $$$ x_1 y_1 x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \le x_1 y_1 x_2 y_2 \le n $$$ ) — coordinate cells $$$ j $$$ -th query query print a single integer — minimum number move one make go cell $$$ ( x_1 y_1 ) $$$ cell $$$ ( x_2 y_2 ) $$$ map labyrinth second example doors mark red,"['data structures', 'dp']",2600.0
1682/F,give two integer array $$$ a $$$ $$$ b $$$ ( $$$ b_i \neq 0 $$$ $$$ |b_i| \leq 1000000000 $$$ ) array $$$ a $$$ sort non - decreasing order cost a subarray $$$ a [ l : r ] $$$ define follow : $$$ \sum\limits _ { j = l } ^ { r } b_j \neq 0 $$$ cost define otherwise : give $$$ q $$$ query form two integers $$$ l $$$ $$$ r $$$ compute cost subarray $$$ a [ l : r ] $$$ query modulo $$$ 1000000000 + 7 $$$ n't know minimum cost maximum flow mean read first line input contain two integers $$$ n $$$ $$$ q $$$ $$$ ( 2 \leq n \leq 2\cdot 100000 1 \leq q \leq 2\cdot100000 ) $$$ — length array $$$ a $$$ $$$ b $$$ number query next line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_1 \le a_2 \ldots \le a_n \leq 1000000000 ) $$$ — array $$$ a $$$ guarantee $$$ a $$$ sort non - decreasing order next line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ $$$ ( -1000000000\leq b_i \leq 1000000000 b_i \neq 0 ) $$$ — array $$$ b $$$ $$$ i $$$ -th next $$$ q $$$ line contain two integers $$$ l_i r_i $$$ $$$ ( 1\leq l_i \leq r_i \leq n ) $$$ guarantee $$$ \sum\limits _ { j = l_i } ^ { r_i } b_j = 0 $$$ query $$$ l_i $$$ $$$ r_i $$$ — print cost subarray $$$ a [ l_i : r_i ] $$$ modulo $$$ 1000000000 + 7 $$$ first query maximum possible flow $$$ 1 $$$ i.e one unit source $$$ 2 $$$ one unit $$$ 2 $$$ $$$ 3 $$$ one unit $$$ 3 $$$ sink cost flow $$$ 0 + |2 - 4| \cdot 1 + 0 = 2 $$$ second query maximum possible flow $$$ 1 $$$ i.e source $$$ 7 $$$ $$$ 7 $$$ $$$ 6 $$$ $$$ 6 $$$ sink a cost $$$ 0 \cdot |10 - 10| \cdot 1 + 0 = 0 $$$ third query flow network show leave capacity write edge cost write bracket image right show flow edge optimal configuration fourth query flow network look – minimum cost maximum flow achieve configuration – maximum flow network 4 minimum cost flow 15,"['data structures', 'greedy']",2700.0
1685/B,alina discover a weird language contain $$$ 4 $$$ word : $$$ \texttt { a } $$$ $$$ \texttt { b } $$$ $$$ \texttt { ab } $$$ $$$ \texttt { ba } $$$ also turn space language : a sentence write concatenate word a single string alina find one sentence $$$ s $$$ curious : possible consist precisely $$$ a $$$ word $$$ \texttt { a } $$$ $$$ b $$$ word $$$ \texttt { b } $$$ $$$ c $$$ word $$$ \texttt { ab } $$$ $$$ d $$$ word $$$ \texttt { ba } $$$ ? word determine 's possible concatenate $$$ a+b+c+d $$$ word order result string $$$ s $$$ $$$ a+b+c+d $$$ word must use exactly concatenation choose order concatenate first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case description test case follow first line test case contain four integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ ( $$$ 0\le a b c d\le 2\cdot 100000 $$$ ) — number time word $$$ \texttt { a } $$$ $$$ \texttt { b } $$$ $$$ \texttt { ab } $$$ $$$ \texttt { ba } $$$ respectively must use sentence second line contain string $$$ s $$$ ( $$$ s $$$ consist character $$$ \texttt { a } $$$ $$$ \texttt { b } $$$ $$$ 1\le |s| \le 2\cdot 100000 $$$ $$$ |s|=a+b+2c+2d $$$ ) — sentence notice condition $$$ |s|=a+b+2c+2d $$$ ( $$$ |s| $$$ denote length string $$$ s $$$ ) equivalent fact $$$ s $$$ long concatenation $$$ a+b+c+d $$$ word sum lengths $$$ s $$$ test case n't exceed $$$ 2\cdot 100000 $$$ test case output $$$ \texttt { yes } $$$ possible sentence $$$ s $$$ consist precisely $$$ a $$$ word $$$ \texttt { a } $$$ $$$ b $$$ word $$$ \texttt { b } $$$ $$$ c $$$ word $$$ \texttt { ab } $$$ $$$ d $$$ word $$$ \texttt { ba } $$$ $$$ \texttt { } $$$ otherwise output letter case first test case sentence $$$ s $$$ $$$ \texttt { b } $$$ clearly ca n't consist a single word $$$ \texttt { a } $$$ answer $$$ \texttt { } $$$ second test case sentence $$$ s $$$ $$$ \texttt { ab } $$$ 's possible consist a single word $$$ \texttt { ab } $$$ answer $$$ \texttt { yes } $$$ third test case sentence $$$ s $$$ $$$ \texttt { abab } $$$ 's possible consist one word $$$ \texttt { a } $$$ one word $$$ \texttt { b } $$$ one word $$$ \texttt { ba } $$$ $$$ \texttt { a } + \texttt { ba } + \texttt { b } = \texttt { abab } $$$ fourth test case sentence $$$ s $$$ $$$ \texttt { abaab } $$$ 's possible consist one word $$$ \texttt { a } $$$ one word $$$ \texttt { ab } $$$ one word $$$ \texttt { ba } $$$ $$$ \texttt { a } + \texttt { ba } + \texttt { ab } = \texttt { abaab } $$$ fifth test case sentence $$$ s $$$ $$$ \texttt { baabbabbaa } $$$ 's possible consist one word $$$ \texttt { a } $$$ one word $$$ \texttt { b } $$$ two word $$$ \texttt { ab } $$$ two word $$$ \texttt { ba } $$$ $$$ \texttt { ba } + \texttt { ab } + \texttt { b } + \texttt { ab } + \texttt { ba } + \texttt { a } = \texttt { baabbabbaa } $$$,"['greedy', 'implementation']",2000.0
1685/D2,a hard version problem difference easy hard versions version output lexicographically smallest permutation smallest weight give a permutation $$$ p_1 p_2 \ldots p_n $$$ integers $$$ 1 $$$ $$$ n $$$ let 's define weight permutation $$$ q_1 q_2 \ldots q_n $$$ integers $$$ 1 $$$ $$$ n $$$ $$$ $$$ <unknown> - p _ { q _ { 2 } } | + <unknown> - p _ { q _ { 3 } } | + \ldots + <unknown> _ { n-1 } - p _ { q _ { n } } | + <unknown> - p _ { q _ { 1 } } | $$$ $$$ want permutation lightweight possible among permutations $$$ q $$$ smallest possible weight find lexicographically smallest permutation $$$ a_1 a_2 \ldots a_n $$$ lexicographically smaller permutation $$$ b_1 b_2 \ldots b_n $$$ exist $$$ 1 \le i \le n $$$ $$$ a_j = b_j $$$ $$$ 1 \le j < i $$$ $$$ a_i < b_i $$$ first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200 $$$ ) — size permutation second line test case contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i $$$ distinct ) — elements permutation sum $$$ n $$$ test case n't exceed $$$ 400 $$$ test case output $$$ n $$$ integers $$$ q_1 q_2 \ldots q_n $$$ ( $$$ 1 \le q_i \le n $$$ $$$ q_i $$$ distinct ) — lexicographically smallest permutation smallest weight first test case two permutations length $$$ 2 $$$ : $$$ ( 1 2 ) $$$ $$$ ( 2 1 ) $$$ permutation $$$ ( 1 2 ) $$$ weight $$$ |1 - p_2| + |2 - p_1| = 0 $$$ permutation $$$ ( 2 1 ) $$$ weight : $$$ |2 - p_1| + |1 - p_2| = 0 $$$ version output lexicographically smaller — $$$ ( 1 2 ) $$$ second test case weight permutation $$$ ( 1 3 4 2 ) $$$ $$$ |1 - p_3| + |3 - p_4| + |4 - p_2| + |2 - p_1| = |1 - 1| + |3 - 4| + |4 - 3| + |2 - 2| = 2 $$$ permutations smaller weight third test case weight permutation $$$ ( 1 3 4 2 5 ) $$$ $$$ |1 - p_3| + |3 - p_4| + |4 - p_2| + |2 - <unknown> + |5 - p_1| = |1 - 3| + |3 - 2| + |4 - 4| + |2 - 1| + |5 - 5| = 4 $$$ permutations smaller weight,['greedy'],3500.0
1691/A,give a sequence $$$ a_1 a_2 \ldots a_n $$$ find minimum number elements remove sequence removal sum every $$$ 2 $$$ consecutive elements even test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1\leq <unknown> $$$ ) — elements sequence guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print a single integer — minimum number elements remove sequence sum every $$$ 2 $$$ consecutive elements even first test case remove $$$ 3 $$$ sequence become $$$ [ <unknown> ] $$$ pair consecutive elements $$$ \ { [ 2 4 ] [ 4 6 ] [ 6 8 ] \ } $$$ consecutive pair even sum hence need remove $$$ 1 $$$ element satisfy condition ask second test case consecutive pair already even sum need remove element,"['greedy', 'math']",800.0
1691/D,give array $$$ a $$$ $$$ n $$$ integers ask find inequality $$$ $$$ \max ( a_i a _ { i + 1 } \ldots a _ { j - 1 } a _ { j } ) \geq a_i + a _ { i + 1 } + \dots + a _ { j - 1 } + a _ { j } $$$ $$$ hold pair indices $$$ ( i j ) $$$ $$$ 1 \leq i \leq j \leq n $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — size array next line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case a new line output ` ` yes '' condition satisfy give array ` ` '' otherwise print letter case ( upper lower ) test case $$$ 1 $$$ $$$ 2 $$$ give condition satisfy $$$ ( i j ) $$$ pair test case $$$ 3 $$$ condition n't satisfy pair $$$ ( 1 2 ) $$$ $$$ \max ( 2 3 ) < 2 + 3 $$$,"['data structures', 'implementation']",1800.0
1691/E,give $$$ n $$$ color segment number line segment either color red blue $$$ i $$$ -th segment represent a tuple $$$ ( c_i l_i r_i ) $$$ segment contain point range $$$ [ l_i r_i ] $$$ inclusive color denote $$$ c_i $$$ : say two segment different color connect share least one common point two segment belong group either connect directly a sequence directly connect segment find number group segment test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — number segment next $$$ n $$$ line contain three integers $$$ c_i l_i r_i $$$ ( $$$ 0 \leq c_i \leq 1 0 \leq l_i \leq r_i \leq 1000000000 $$$ ) describe $$$ i $$$ -th segment guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print a single integer $$$ k $$$ number group segment first example $$$ 5 $$$ segment segment $$$ 1 $$$ $$$ 2 $$$ connect different color share a point also segment $$$ 2 $$$ $$$ 3 $$$ connect segment $$$ 4 $$$ $$$ 5 $$$ thus two group : one contain segment $$$ \ { 1 2 3\ } $$$ one contain segment $$$ \ { 4 5\ } $$$,"['data structures', 'greedy']",2300.0
1692/C,mihai $$$ 8 \times 8 $$$ chessboard whose row number $$$ 1 $$$ $$$ 8 $$$ top bottom whose columns number $$$ 1 $$$ $$$ 8 $$$ leave right mihai place exactly one bishop chessboard bishop place edge board ( word row column bishop $$$ 2 $$$ $$$ 7 $$$ inclusive ) bishop attack directions diagonally limit distance bishop attack note cell bishop place also consider attack mihai mark square bishop attack forget bishop ! help mihai find position bishop first line input contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 36 $$$ ) — number test case description test case follow empty line test case test case consist $$$ 8 $$$ line contain $$$ 8 $$$ character character either ' # ' ' ' denote a square attack a square attack respectively test case output two integers $$$ r $$$ $$$ c $$$ ( $$$ 2 \leq r c \leq 7 $$$ ) — row column bishop input generate a way always exactly one possible location bishop edge board first test case picture statement since bishop lie intersection row $$$ 4 $$$ column $$$ 3 $$$ correct output 4 3,['implementation'],800.0
1693/E,<unknown> array $$$ n + 2 $$$ non - negative integers : $$$ a_0 a_1 ... a_n a _ { n + 1 } $$$ know $$$ a_0 = a _ { n + 1 } = 0 $$$ want make elements $$$ a $$$ equal zero minimum number operations one operation one follow : help find minimum number operations need make elements $$$ a $$$ equal zero first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le n $$$ ) print a single integer — minimum number operations need make elements $$$ a $$$ equal zero first sample get $$$ \langle 1 \underline { 1 } 2 4 0 2 \rangle $$$ perform first operation $$$ \langle 1 4 2 \underline { 2 } 0 2 \rangle $$$ perform second operation one way achieve goal show ( underline show last change . ) $$$ \langle 1 4 2 4 0 2 \rangle \to \langle 1 4 2 \underline { 2 } 0 2 \rangle \to \langle 1 \underline { 1 } 2 2 0 2 \rangle \to \langle 1 1 2 2 0 \underline { 0 } \rangle \to \langle 1 1 2 \underline { 0 } 0 0 \rangle \to \langle 1 1 \underline { 0 } 0 0 0 \rangle \to \langle \underline { 0 } 1 0 0 0 0 \rangle \to \langle 0 \underline { 0 } 0 0 0 0 \rangle $$$ third sample element already equal zero operations need,"['data structures', 'greedy']",3400.0
1693/F,give a binary string $$$ s $$$ length $$$ n $$$ index $$$ 1 $$$ $$$ n $$$ perform follow operation number time ( possibly zero ) : choose two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \le l \le r \le n $$$ ) let $$$ cnt_0 $$$ number time 0 occur $$$ s [ l \ldots r ] $$$ $$$ cnt_1 $$$ number time 1 occur $$$ s [ l \ldots r ] $$$ pay $$$ <unknown> - <unknown> + 1 $$$ coin sort $$$ s [ l \ldots r ] $$$ ( $$$ s [ l \ldots r ] $$$ mean substring $$$ s $$$ start position $$$ l $$$ end position $$$ r $$$ ) example $$$ s = $$$ 11001 perform operation $$$ s [ 2 \ldots 4 ] $$$ pay $$$ |2 - 1| + 1 = 2 $$$ coin obtain $$$ s = $$$ 10011 a new string find minimum total number coin require sort $$$ s $$$ increase order first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — size $$$ s $$$ second line test case contain a binary string $$$ s $$$ $$$ n $$$ character $$$ s_1s_2 \ldots s_n $$$ ( $$$ s_i = $$$ 0 $$$ s_i = $$$ 1 $$$ 1 \le i \le n $$$ ) guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case output minimum total number coin require sort $$$ s $$$ increase order first test case $$$ s $$$ already sort second test case 's enough apply operation $$$ l = 1 r = 2 $$$ third test case 's enough apply operation $$$ l = 1 r = 2 $$$,['greedy'],3400.0
1696/D,"a permutation array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) give a permutation $$$ 1,2 \dots n $$$ $$$ [ a_1 a_2 \dots a_n ] $$$ integers $$$ i $$$ $$$ j $$$ $$$ 1\le i < j\le n $$$ define $$$ \operatorname { mn } ( i j ) $$$ $$$ \min\limits _ { k = i } ^j a_k $$$ define $$$ \operatorname { mx } ( i j ) $$$ $$$ \max\limits _ { k = i } ^j a_k $$$ let us build undirected graph $$$ n $$$ vertices number $$$ 1 $$$ $$$ n $$$ every pair integers $$$ 1\le i < j\le n $$$ $$$ \operatorname { mn } ( i j ) = a_i $$$ $$$ \operatorname { mx } ( i j ) = a_j $$$ hold $$$ \operatorname { mn } ( i j ) = a_j $$$ $$$ \operatorname { mx } ( i j ) = a_i $$$ hold add undirected edge length $$$ 1 $$$ vertices $$$ i $$$ $$$ j $$$ graph find length shortest path vertex $$$ 1 $$$ vertex $$$ n $$$ prove $$$ 1 $$$ $$$ n $$$ always connect via path a shortest path always exist test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 5\cdot 10000 $$$ ) description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1\le n\le 2.5\cdot 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a_n $$$ ( $$$ 1\le a_i\le n $$$ ) 's guarantee $$$ a $$$ a permutation $$$ 1 $$$ $$$ 2 $$$ $$$ \dots $$$ $$$ n $$$ guarantee sum $$$ n $$$ test case exceed $$$ 5\cdot 100000 $$$ test case print a single line contain one integer — length shortest path $$$ 1 $$$ $$$ n $$$ follow illustrations construct graph example test case","['data structures', 'greedy']",1900.0
1696/G,"suppose give a 1 - indexed sequence $$$ a $$$ non - negative integers whose length $$$ n $$$ two integers $$$ x $$$ $$$ y $$$ consecutive $$$ t $$$ second ( $$$ t $$$ positive real number ) one follow operations : define minimum amount time ( might a real number ) require make elements sequence less equal $$$ 0 $$$ $$$ f ( a ) $$$ example $$$ x=1 $$$ $$$ y=2 $$$ take $$$ 3 $$$ second deal array $$$ [ 3,1,1,3 ] $$$ : prove 's possible make elements less equal $$$ 0 $$$ less $$$ 3 $$$ second $$$ f ( [ 3,1,1,3 ] ) =3 $$$ give a 1 - indexed sequence $$$ b $$$ positive integers whose length $$$ n $$$ also give positive integers $$$ x $$$ $$$ y $$$ process $$$ q $$$ query follow two type : first line input contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2\le n\le 2\cdot 100000 $$$ $$$ 1\le q\le 2\cdot 100000 $$$ ) second line input contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1\le x y\le 1000000 $$$ ) third line input contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1\le b_i\le 1000000 $$$ ) follow $$$ q $$$ line $$$ q $$$ line contain three integers first integer $$$ op $$$ either $$$ 1 $$$ $$$ 2 $$$ query type $$$ 2 $$$ print one real number — answer query answer consider correct absolute error relative error exceed $$$ 10^ { -9 } $$$ let 's analyse sample first query ask compute $$$ f ( [ <unknown> ] ) $$$ answer $$$ 3.5 $$$ one optimal sequence operations : third query ask compute $$$ f ( [ 1,1,1 ] ) $$$ answer $$$ 1 $$$ one optimal sequence operations :","['data structures', 'math']",3300.0
1698/B,"$$$ n $$$ pile sand $$$ i $$$ -th pile $$$ a_i $$$ block sand $$$ i $$$ -th pile call tall $$$ 1 < i < n $$$ $$$ a_i > a _ { i-1 } + a _ { i+1 } $$$ , a pile tall sand two neighbour combine ( note pile end array tall ) give integer $$$ k $$$ operation consist pick $$$ k $$$ consecutive pile sand add one unit sand formally pick $$$ 1 \leq l r \leq n $$$ $$$ r - l+1 = k $$$ $$$ l \leq i \leq r $$$ update $$$ a_i <unknown> a_i+1 $$$ maximum number pile simultaneously tall ( possibly zero ) operations ? input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 3 \leq n \leq 200000 $$$ ; $$$ 1 \leq k \leq n $$$ ) — number pile sand size operation respectively second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — size pile guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a single integer — maximum number pile simultaneously tall ( possibly zero ) operations first test case perform follow three operations : second test case operation increase pile $$$ 1 $$$ unit number tall pile always $$$ 0 $$$ third test case increase pile $$$ 1 $$$ unit sand show maximum number tall pile $$$ 1 $$$","['greedy', 'implementation']",800.0
1698/E,"give a permutation $$$ a $$$ length $$$ n $$$ recall permutation array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order a strength $$$ s $$$ perform $$$ n $$$ move permutation $$$ a $$$ $$$ i $$$ -th move consist follow : want turn $$$ a $$$ another permutation $$$ b $$$ $$$ n $$$ move however elements $$$ b $$$ miss replace $$$ -1 $$$ instead count number ways replace $$$ -1 $$$ $$$ b $$$ integer $$$ 1 $$$ $$$ n $$$ $$$ b $$$ a permutation possible turn $$$ a $$$ $$$ b $$$ a strength $$$ s $$$ since answer large output modulo $$$ 998\,244\,353 $$$ input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ s $$$ ( $$$ 1 \leq n \leq 200000 $$$ ; $$$ 1 \leq s \leq n $$$ ) — size permutation strength respectively second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — elements $$$ a $$$ elements $$$ a $$$ distinct third line test case contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1 \le b_i \le n $$$ $$$ b_i = -1 $$$ ) — elements $$$ b $$$ elements $$$ b $$$ equal $$$ -1 $$$ distinct guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a single integer — number ways fill permutation $$$ b $$$ possible turn $$$ a $$$ $$$ b $$$ use a strength $$$ s $$$ modulo $$$ 998\,244\,353 $$$ first test case $$$ a= [ 2,1,3 ] $$$ two possible ways fill $$$ -1 $$$ s $$$ b $$$ make a permutation : $$$ [ 3,1,2 ] $$$ $$$ [ 3,2,1 ] $$$ make $$$ a $$$ $$$ [ 3,1,2 ] $$$ a strength $$$ 1 $$$ follow : $$$ $$$ [ 2,1,3 ] \xrightarrow [ x=1 \ <unknown> ] { } [ 2,1,3 ] \xrightarrow [ x=2 \ y=3 ] { } [ 3,1,2 ] \xrightarrow [ x=3 \ y=3 ] { } [ 3,1,2 ] $$$ $$$ prove impossible make $$$ [ 2,1,3 ] $$$ $$$ [ 3,2,1 ] $$$ a strength $$$ 1 $$$ thus one permutation $$$ b $$$ satisfy constraints answer $$$ 1 $$$ second test case $$$ a $$$ $$$ b $$$ previous test case a strength $$$ 2 $$$ make $$$ a $$$ $$$ [ 3,2,1 ] $$$ a strength $$$ 2 $$$ follow : $$$ $$$ [ 2,1,3 ] \xrightarrow [ x=1 \ y=3 ] { } [ 2,3,1 ] \xrightarrow [ x=2 \ y=3 ] { } [ 3,2,1 ] \xrightarrow [ x=3 \ y=3 ] { } [ 3,2,1 ] $$$ $$$ still make $$$ a $$$ $$$ [ 3,1,2 ] $$$ use a strength $$$ 1 $$$ show previous test case answer $$$ 2 $$$ third test case one permutation $$$ b $$$ show impossible turn $$$ a $$$ $$$ b $$$ answer $$$ 0 $$$",['greedy'],2300.0
1700/B,"a daily walk alina notice a long number write grind alina want find positive number length without lead zero sum two number a palindrome recall a number call a palindrome read right leave leave right example number $$$ 121 66 <unknown> $$$ palindromes $$$ 103 239 <unknown> $$$ palindromes alina understand a valid number always exist help find one ! first line input data contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case next descriptions $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100\,000 $$$ ) — length number write grind second line contain positive $$$ n $$$ -digit integer without lead zero — number guarantee sum value $$$ n $$$ test case exceed $$$ 100\,000 $$$ $$$ t $$$ test case print answer — a positive $$$ n $$$ -digit integer without lead zero sum input integer number a palindrome show least one number satisfy constraints exist multiple solutions output first test case $$$ 99 + 32 = 131 $$$ a palindrome note another answer $$$ 12 $$$ $$$ 99 + 12 = 111 $$$ also a palindrome second test case $$$ <unknown> + <unknown> = <unknown> $$$ third test case $$$ <unknown> + <unknown> = <unknown> $$$","['implementation', 'math']",1100.0
1701/F,a triple point $$$ i $$$ $$$ j $$$ $$$ k $$$ a coordinate line call beautiful $$$ i < j < k $$$ $$$ k - i \le d $$$ give a set point a coordinate line initially empty process query three type : first line contain two integers $$$ q $$$ $$$ d $$$ ( $$$ 1 \le q d \le 200000 $$$ ) — number query parameter define a triple beautiful respectively second line contain $$$ q $$$ integers $$$ a_1 a_2 \dots a_q $$$ ( $$$ 1 \le a_i \le 200000 $$$ ) denote query integer $$$ a_i $$$ denote $$$ i $$$ -th query follow way : query print one integer — number beautiful triple process respective query,"['data structures', 'implementation', 'math']",2500.0
1703/A,a string $$$ s $$$ length $$$ 3 $$$ consist uppercase lowercase english letter check equal ` ` yes '' ( without quote ) letter case example ` ` yes '' ` ` yes '' ` ` yes '' allowable first line input contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number testcases description test consist one line contain one string $$$ s $$$ consist three character character $$$ s $$$ either uppercase lowercase english letter test case output ` ` yes '' ( without quote ) $$$ s $$$ satisfy condition ` ` '' ( without quote ) otherwise output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first five test case contain string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' equal ` ` yes '' character either uppercase lowercase,['implementation'],800.0
1703/B,icpc contest balloon distribute follow : determine total number balloon team receive note problems may solve none team first line input contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number testcases first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 50 $$$ ) — length string second line test case contain a string $$$ s $$$ length $$$ n $$$ consist uppercase english letter denote order solve problems test case output a single integer — total number balloon team receive first test case $$$ 5 $$$ balloon give : second test case one problem solve team solve receive $$$ 2 $$$ balloon : one solve problem additional one first team solve problem $$$ <unknown> { a } $$$,"['data structures', 'implementation']",800.0
1703/C,"luca a cypher make a sequence $$$ n $$$ wheel a digit $$$ a_i $$$ write $$$ i $$$ -th wheel make $$$ b_i $$$ move move one two type : luca know final sequence wheel move wheel help find original sequence crack cypher first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) — number wheel second line contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 0 \leq a_i \leq 9 $$$ ) — digit show $$$ i $$$ -th wheel move perform $$$ n $$$ line follow $$$ i $$$ -th contain integer $$$ b_i $$$ ( $$$ 1 \leq b_i \leq 10 $$$ ) $$$ b_i $$$ character either $$$ \texttt { u } $$$ $$$ \texttt { d } $$$ — number move perform $$$ i $$$ -th wheel move perform $$$ \texttt { u } $$$ $$$ \texttt { d } $$$ represent move a move respectively test case output $$$ n $$$ space - separated digits — initial sequence cypher first test case prove initial sequence $$$ [ 2,1,1 ] $$$ case follow move perform :",['implementation'],800.0
1703/G,$$$ n $$$ chests $$$ i $$$ -th chest contain $$$ a_i $$$ coin need open $$$ n $$$ chests order chest $$$ 1 $$$ chest $$$ n $$$ two type key use open a chest : need use total $$$ n $$$ key one chest initially coin key want use a good key need buy process allow go debt ; example $$$ 1 $$$ coin allow buy a good key worth $$$ k=3 $$$ coin balance become $$$ -2 $$$ coin find maximum number coin open $$$ n $$$ chests order chest $$$ 1 $$$ chest $$$ n $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 100000 $$$ ; $$$ 0 \leq k \leq 1000000000 $$$ ) — number chests cost a good key respectively second line test case contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) — amount coin chest sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output a single integer — maximum number coin obtain open chests order chest $$$ 1 $$$ chest $$$ n $$$ please note answer test case wo n't fit 32 - bit integer type use least 64 - bit integer type program language ( like long long c++ ) first test case one possible strategy follow :,"['dp', 'greedy', 'math']",1600.0
1704/C,$$$ n $$$ house number $$$ 1 $$$ $$$ n $$$ a circle $$$ 1 \leq i \leq n - 1 $$$ house $$$ i $$$ house $$$ i + 1 $$$ neighbour ; additionally house $$$ n $$$ house $$$ 1 $$$ also neighbour initially $$$ m $$$ $$$ n $$$ house infect a deadly virus morning cirno choose a house uninfected protect house infect permanently every day follow things happen order : cirno want stop virus spread find minimum number house infect end optimally choose house protect note every day cirno always choose a house protect virus spread also a protect house infect forever input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case consist two positive integers $$$ n m $$$ ( $$$ 5 \leq n \leq 1000000000 $$$ $$$ 1 \leq m \leq \min ( n 100000 ) $$$ ) — number house circle number house initially infect second line test case consist $$$ m $$$ distinct positive integers $$$ a_1 a_2 \cdots a_m $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — indices house infect initially guarantee sum $$$ m $$$ test case exceed $$$ 100000 $$$ test case output integer a separate line minimum number infect house end first test case : start first day house $$$ 3 $$$ $$$ 6 $$$ $$$ 8 $$$ infect choose house $$$ 2 $$$ protect start second day house $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ $$$ 6 $$$ $$$ 7 $$$ $$$ 8 $$$ $$$ 9 $$$ infect choose house $$$ 10 $$$ protect start third day house infect second test case : start first day house $$$ 2 $$$ $$$ 5 $$$ infect choose house $$$ 1 $$$ protect start second day house $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ $$$ 6 $$$ infect available house protect,"['greedy', 'implementation']",1200.0
1704/H1,"easy version problem difference easy hard versions constraint $$$ k $$$ time limit also version problem need calculate answer $$$ n = k $$$ make hack versions problem solve cirno play a war simulator game $$$ n $$$ tower ( number $$$ 1 $$$ $$$ n $$$ ) $$$ n $$$ bots ( number $$$ 1 $$$ $$$ n $$$ ) $$$ i $$$ -th tower initially occupy $$$ i $$$ -th bot $$$ 1 \le i \le n $$$ game cirno first choose a permutation $$$ p = [ p_1 p_2 \ldots p_n ] $$$ length $$$ n $$$ ( a permutation length $$$ n $$$ array length $$$ n $$$ integer $$$ 1 $$$ $$$ n $$$ appear exactly ) , choose a sequence $$$ a = [ a_1 a_2 \ldots a_n ] $$$ ( $$$ 1 \le a_i \le n $$$ $$$ a_i \ne i $$$ $$$ 1 \le i \le n $$$ ) game $$$ n $$$ round attack $$$ i $$$ -th round $$$ p_i $$$ -th bot still game begin attack result $$$ a _ { p_i } $$$ -th tower become occupy $$$ p_i $$$ -th bot ; bot previously occupy $$$ a _ { p_i } $$$ -th tower longer occupy $$$ p_i $$$ -th bot game nothing happen round round a bot n't occupy tower eliminate leave game please note tower occupy one bot one bot occupy one tower game end game cirno record result a sequence $$$ b = [ b_1 b_2 \ldots b_n ] $$$ $$$ b_i $$$ number bot occupy $$$ i $$$ -th tower end game however a mathematics master want solve follow count problem instead play game : count number different pair sequence $$$ a $$$ $$$ b $$$ get possible choices sequence $$$ a $$$ permutation $$$ p $$$ since number may large output modulo $$$ m $$$ line contain two positive integers $$$ k $$$ $$$ m $$$ ( $$$ 1\le k\le 5000 $$$ $$$ 2\le m\le 1000000000 $$$ ) guarantee $$$ 2^ { 18 } $$$ a divisor $$$ m-1 $$$ $$$ m $$$ a prime number need calculate answer $$$ n = k $$$ output a single integer — number different pair sequence $$$ n = k $$$ modulo $$$ m $$$ $$$ n=1 $$$ valid sequence $$$ a $$$ exist regard answer $$$ 0 $$$ $$$ n=2 $$$ one possible array $$$ a $$$ : $$$ [ 2 1 ] $$$ number different pair sequence $$$ ( a b ) $$$ $$$ 2 $$$ ( $$$ [ 2 1 ] $$$ $$$ [ 1 1 ] $$$ $$$ [ 2 1 ] $$$ $$$ [ 2 2 ] $$$ ) $$$ n=2 $$$","['dp', 'math']",3200.0
1705/D,mark purchase a rack $$$ n $$$ lightbulbs state lightbulbs describe binary string $$$ s = s_1s_2\dots s_n $$$ $$$ s_i=\texttt { 1 } $$$ mean $$$ i $$$ -th lightbulb turn $$$ s_i=\texttt { 0 } $$$ mean $$$ i $$$ -th lightbulb turn unfortunately lightbulbs break operation perform change state lightbulbs follow : mark want state lightbulbs another binary string $$$ t $$$ help mark determine minimum number operations first line input contain a single integer $$$ q $$$ ( $$$ 1\leq q\leq 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 3\leq n\leq 2\cdot 100000 $$$ ) — number lightbulbs second line test case contain a binary string $$$ s $$$ length $$$ n $$$ — initial state lightbulbs third line test case contain a binary string $$$ t $$$ length $$$ n $$$ — final state lightbulbs guarantee sum $$$ n $$$ across test case exceed $$$ 2\cdot 100000 $$$ test case print a line contain minimum number operations mark need perform transform $$$ s $$$ $$$ t $$$ sequence operations print $$$ -1 $$$ first test case one sequence operations achieve minimum number operations follow third test case even though first digits $$$ s $$$ $$$ t $$$ last digits $$$ s $$$ $$$ t $$$ show sequence operations satisfy condition fourth test case one sequence achieve minimum number operations follow :,"['greedy', 'math']",1800.0
1705/E,"watch a certain <unknown> go sleep mark dream stand old classroom a blackboard a sequence $$$ n $$$ positive integers $$$ a_1 a_2 \dots a_n $$$ , professor koro come perform follow operation : professor koro ask mark question ` ` maximum possible number could appear board operations ? ` ` mark quickly solve question still slower professor koro thus professor koro decide give mark additional challenge update initial sequence integers $$$ q $$$ time time choose positive integers $$$ k $$$ $$$ l $$$ change $$$ a_k $$$ $$$ l $$$ update ask mark question help mark answer question faster professor koro ! note update persistent change make sequence $$$ a $$$ apply process future update first line input contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2\leq n\leq 2\cdot 100000 $$$ $$$ 1\leq q\leq 2\cdot 100000 $$$ ) — length sequence $$$ a $$$ number update respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1\leq a_i\leq 2\cdot 100000 $$$ ) $$$ q $$$ line follow consist two integers $$$ k $$$ $$$ l $$$ ( $$$ 1\leq k\leq n $$$ $$$ 1\leq l\leq 2\cdot 100000 $$$ ) tell update $$$ a_k $$$ $$$ l $$$ print $$$ q $$$ line $$$ i $$$ -th line consist a single integer — answer $$$ i $$$ -th update first example test program must proceed $$$ 4 $$$ update sequence first update $$$ [ <unknown> ] $$$ one sequence operations achieve number $$$ 6 $$$ follow , second update array change $$$ [ <unknown> ] $$$ time mark achieve $$$ 6 $$$ however one sequence mark use achieve $$$ 5 $$$ show third update array change $$$ [ <unknown> ] $$$ one way achieve $$$ 4 $$$ show","['data structures', 'greedy']",2300.0
1706/B,a sequence $$$ n $$$ color block color $$$ i $$$ -th block $$$ c_i $$$ integer $$$ 1 $$$ $$$ n $$$ place block sequence infinite coordinate grid follow way a tower form $$$ s $$$ block place position $$$ ( x y ) ( x y + 1 ) \ldots ( x y + s - 1 ) $$$ position $$$ ( x y ) $$$ integer $$$ s $$$ size tower $$$ s $$$ number block a tower color $$$ r $$$ a tower block color $$$ r $$$ color $$$ r $$$ $$$ 1 $$$ $$$ n $$$ solve follow problem independently : first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ c_1 c_2 \ldots c_n $$$ ( $$$ 1 \le c_i \le n $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output $$$ n $$$ integers $$$ r $$$ -th maximum size tower color $$$ r $$$ form follow give rule form tower color $$$ r $$$ $$$ r $$$ -th integer $$$ 0 $$$ first test case one possible ways form a tower color $$$ 1 $$$ size $$$ 3 $$$ : block position $$$ ( 0 0 ) $$$ $$$ ( 0 1 ) $$$ $$$ ( 0 2 ) $$$ color $$$ 1 $$$ form tower size $$$ 3 $$$ second test case note follow placement valid since allow place block $$$ 6 $$$ block $$$ 5 $$$ : show impossible form a tower color $$$ 4 $$$ size $$$ 3 $$$,"['dp', 'greedy', 'math']",1100.0
1706/D1,easy version problem difference versions constraints $$$ n $$$ $$$ k $$$ $$$ a_i $$$ sum $$$ n $$$ test case make hack versions problem solve note unusual memory limit give array integers $$$ a_1 a_2 \ldots a_n $$$ length $$$ n $$$ integer $$$ k $$$ cost array integers $$$ p_1 p_2 \ldots p_n $$$ length $$$ n $$$ $$$ $$$ \max\limits _ { 1 \le i \le n } \left ( \left \lfloor \frac { a_i } { p_i } \right \rfloor \right ) - \min\limits _ { 1 \le i \le n } \left ( \left \lfloor \frac { a_i } { p_i } \right \rfloor \right ) $$$ $$$ $$$ \lfloor \frac { x } { y } \rfloor $$$ denote integer part division $$$ x $$$ $$$ y $$$ find minimum cost array $$$ p $$$ $$$ 1 \le p_i \le k $$$ $$$ 1 \le i \le n $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 3000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_1 \le a_2 \le \ldots \le a_n \le 3000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 3000 $$$ test case print a single integer — minimum possible cost array $$$ p $$$ satisfy condition first test case optimal array $$$ p = [ 1 1 1 2 2 ] $$$ result array value $$$ \lfloor \frac { a_i } { p_i } \rfloor $$$ $$$ [ 4 5 6 4 5 ] $$$ cost $$$ p $$$ $$$ \max\limits _ { 1 \le i \le n } ( \lfloor \frac { a_i } { p_i } \rfloor ) - \min\limits _ { 1 \le i \le n } ( \lfloor \frac { a_i } { p_i } \rfloor ) = 6 - 4 = 2 $$$ show array ( satisfy condition statement ) a smaller cost second test case one optimal array $$$ p = [ 12 12 12 12 12 ] $$$ result $$$ \lfloor \frac { a_i } { p_i } \rfloor $$$ $$$ 0 $$$ third test case possible array $$$ p = [ 1 1 1 ] $$$,['greedy'],1700.0
1706/D2,hard version problem difference versions constraints $$$ n $$$ $$$ k $$$ $$$ a_i $$$ sum $$$ n $$$ test case make hack versions problem solve note unusual memory limit give array integers $$$ a_1 a_2 \ldots a_n $$$ length $$$ n $$$ integer $$$ k $$$ cost array integers $$$ p_1 p_2 \ldots p_n $$$ length $$$ n $$$ $$$ $$$ \max\limits _ { 1 \le i \le n } \left ( \left \lfloor \frac { a_i } { p_i } \right \rfloor \right ) - \min\limits _ { 1 \le i \le n } \left ( \left \lfloor \frac { a_i } { p_i } \right \rfloor \right ) $$$ $$$ $$$ \lfloor \frac { x } { y } \rfloor $$$ denote integer part division $$$ x $$$ $$$ y $$$ find minimum cost array $$$ p $$$ $$$ 1 \le p_i \le k $$$ $$$ 1 \le i \le n $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_1 \le a_2 \le \ldots \le a_n \le 100000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print a single integer — minimum possible cost array $$$ p $$$ satisfy condition first test case optimal array $$$ p = [ 1 1 1 2 2 ] $$$ result array value $$$ \lfloor \frac { a_i } { p_i } \rfloor $$$ $$$ [ 4 5 6 4 5 ] $$$ cost $$$ p $$$ $$$ \max\limits _ { 1 \le i \le n } ( \lfloor \frac { a_i } { p_i } \rfloor ) - \min\limits _ { 1 \le i \le n } ( \lfloor \frac { a_i } { p_i } \rfloor ) = 6 - 4 = 2 $$$ show array ( satisfy condition statement ) a smaller cost second test case one optimal array $$$ p = [ 12 12 12 12 12 ] $$$ result $$$ \lfloor \frac { a_i } { p_i } \rfloor $$$ $$$ 0 $$$ third test case possible array $$$ p = [ 1 1 1 ] $$$,"['data structures', 'dp', 'greedy', 'math']",2400.0
1707/D,"kawashiro nitori a girl love competitive program one day find a root tree consist $$$ n $$$ vertices root vertex $$$ 1 $$$ advance problem setter quickly think a problem kawashiro nitori a vertex set $$$ u=\ { 1,2 \ldots n\ } $$$ 's go play a game tree set operation choose a vertex set $$$ t $$$ $$$ t $$$ a partial virtual tree $$$ u $$$ change $$$ u $$$ $$$ t $$$ a vertex set $$$ s_1 $$$ a partial virtual tree a vertex set $$$ s_2 $$$ $$$ s_1 $$$ a subset $$$ s_2 $$$ $$$ s_1 \neq s_2 $$$ pair vertices $$$ i $$$ $$$ j $$$ $$$ s_1 $$$ $$$ \operatorname { lca } ( i j ) $$$ $$$ s_1 $$$ $$$ \operatorname { lca } ( x y ) $$$ denote lowest common ancestor vertices $$$ x $$$ $$$ y $$$ tree note a vertex set many different partial virtual tree kawashiro nitori want know possible $$$ k $$$ perform operation exactly $$$ k $$$ time many ways make $$$ u=\ { 1\ } $$$ end ? two ways consider different exist integer $$$ z $$$ ( $$$ 1 \le z \le k $$$ ) $$$ z $$$ operations set $$$ u $$$ different since answer could large need find modulo $$$ p $$$ 's guarantee $$$ p $$$ a prime number first line contain two integers $$$ n $$$ $$$ p $$$ ( $$$ 2 \le n \le 2000 $$$ $$$ 100000000 + 7 \le p \le 1000000000 + 9 $$$ ) 's guarantee $$$ p $$$ a prime number next $$$ n-1 $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ ) represent edge $$$ u_i $$$ $$$ v_i $$$ guarantee give edge form a tree line contain $$$ n-1 $$$ integers — answer modulo $$$ p $$$ $$$ <unknown> \ldots n-1 $$$ first test case $$$ k=1 $$$ possible way : $$$ k=2 $$$ $$$ 6 $$$ possible ways : $$$ k=3 $$$ $$$ 6 $$$ possible ways :","['dp', 'math']",3000.0
1708/A,"give array $$$ a $$$ consist $$$ n $$$ positive integers allow perform operation number time ( possibly zero ) : possible make $$$ a_i=0 $$$ $$$ 2\le i\le n $$$ ? input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 100 $$$ ) — number test case description test case follow first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) test case print ` ` yes '' ( without quote ) possible change $$$ a_i $$$ $$$ 0 $$$ $$$ 2 \le i \le n $$$ ` ` '' ( without quote ) otherwise print letter case ( upper lower ) first test case initial array $$$ [ 5,10 ] $$$ perform $$$ 2 $$$ operations reach goal : second test case initial array $$$ [ 1,2,3 ] $$$ perform $$$ 4 $$$ operations reach goal : third test case choose indices order $$$ 4 $$$ $$$ 3 $$$ $$$ 2 $$$","['greedy', 'math']",800.0
1709/F,give three integers $$$ n $$$ $$$ k $$$ $$$ f $$$ consider binary string ( i. e. string consist character $$$ 0 $$$ and/or $$$ 1 $$$ ) length $$$ 1 $$$ $$$ n $$$ every string $$$ s $$$ need choose integer $$$ c_s $$$ $$$ 0 $$$ $$$ k $$$ a multiset binary string length exactly $$$ n $$$ consider beautiful every binary string $$$ s $$$ length $$$ 1 $$$ $$$ n $$$ number string multiset $$$ s $$$ prefix exceed $$$ c_s $$$ example let $$$ n = 2 $$$ $$$ c _ { 0 } = 3 $$$ $$$ c _ { 00 } = 1 $$$ $$$ c _ { 01 } = 2 $$$ $$$ c _ { 1 } = 1 $$$ $$$ c _ { 10 } = 2 $$$ $$$ c _ { 11 } = 3 $$$ multiset string $$$ \ { 11 01 00 01\ } $$$ beautiful since : problem calculate number ways choose integer $$$ c_s $$$ every binary string $$$ s $$$ length $$$ 1 $$$ $$$ n $$$ a way maximum possible size a beautiful multiset exactly $$$ f $$$ line input contain three integers $$$ n $$$ $$$ k $$$ $$$ f $$$ ( $$$ 1 \le n \le 15 $$$ ; $$$ 1 \le k f \le 200000 $$$ ) print one integer — number ways choose integer $$$ c_s $$$ every binary string $$$ s $$$ length $$$ 1 $$$ $$$ n $$$ a way maximum possible size a beautiful multiset exactly $$$ f $$$ since huge print modulo $$$ 998244353 $$$ first example three ways choose integers $$$ c_s $$$ :,"['dp', 'math']",2500.0
1712/C,give array $$$ n $$$ positive integers $$$ a_1 a_2 \ldots a_n $$$ one operation follow : find minimum number operations require sort array non - decreasing order test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) second line test case contain $$$ n $$$ positive integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print one integer — minimum number operations require sort array non - decreasing order first test case choose $$$ x = 3 $$$ operation result array $$$ [ 0 0 2 ] $$$ second test case choose $$$ x = 1 $$$ first operation $$$ x = 3 $$$ second operation result array $$$ [ 0 0 0 0 ] $$$,['greedy'],1100.0
1713/C,"a $$$ \mathbf { 0 } $$$ -indexed array $$$ a $$$ size $$$ n $$$ call good valid indices $$$ i $$$ ( $$$ 0 \le i \le n-1 $$$ ) $$$ a_i + i $$$ a perfect square $$$ ^\dagger $$$ give integer $$$ n $$$ find a permutation $$$ ^\ddagger $$$ $$$ p $$$ $$$ [ 0,1,2 \ldots n-1 ] $$$ good determine permutation exist $$$ ^\dagger $$$ integer $$$ x $$$ say a perfect square exist integer $$$ y $$$ $$$ x = y^2 $$$ $$$ ^\ddagger $$$ array $$$ b $$$ a permutation array $$$ a $$$ $$$ b $$$ consist elements $$$ a $$$ arbitrary order example $$$ [ <unknown> ] $$$ a permutation $$$ [ <unknown> ] $$$ $$$ [ 1,2,2 ] $$$ a permutation $$$ [ 1,2,3 ] $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length permutation $$$ p $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output $$$ n $$$ distinct integers $$$ p_0 p_1 \dots p _ { n-1 } $$$ ( $$$ 0 \le p_i \le n-1 $$$ ) — permutation $$$ p $$$ — answer exist $$$ -1 $$$ otherwise first test case $$$ n=3 $$$ array $$$ p = [ 1 0 2 ] $$$ good since $$$ 1 + 0 = 1 ^ 2 $$$ $$$ 0 + 1 = 1 ^ 2 $$$ $$$ 2 + 2 = 2 ^ 2 $$$ second test case $$$ n=4 $$$ array $$$ p = [ 0 3 2 1 ] $$$ good since $$$ 0 + 0 = 0 ^ 2 $$$ $$$ 3 + 1 = 2 ^ 2 $$$ $$$ 2 + 2 = 2 ^ 2 $$$ $$$ 1 + 3 = 2 ^ 2 $$$","['dp', 'math']",1200.0
1713/E,"give a square matrix $$$ a $$$ size $$$ n \times n $$$ whose elements integers denote element intersection $$$ i $$$ -th row $$$ j $$$ -th column $$$ a _ { i j } $$$ perform operations matrix operation choose integer $$$ k $$$ index $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) swap $$$ a _ { i k } $$$ $$$ a _ { k i } $$$ note cell $$$ a _ { k k } $$$ remain unchanged example $$$ n = 4 $$$ $$$ k = 3 $$$ matrix transform like : perform operation number time find lexicographically smallest matrix $$$ ^\dagger $$$ obtain perform arbitrary number operations $$$ { } ^\dagger $$$ two matrices $$$ a $$$ $$$ b $$$ size $$$ n \times n $$$ let $$$ a _ { ( i-1 ) \cdot n + j } = a _ { i j } $$$ $$$ b _ { ( i-1 ) \cdot n + j } = b _ { i j } $$$ , matrix $$$ a $$$ lexicographically smaller matrix $$$ b $$$ exist index $$$ i $$$ ( $$$ 1 \leq i \leq n^2 $$$ ) $$$ a_i < b_i $$$ indices $$$ j $$$ $$$ 1 \leq j < i $$$ $$$ a_j = b_j $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000 $$$ ) — size matrix $$$ i $$$ -th line next $$$ n $$$ line contain $$$ n $$$ integers $$$ a _ { i 1 } a _ { i 2 } \dots a _ { i n } $$$ ( $$$ 1 \le a _ { i j } \le 1000000000 $$$ ) — description matrix $$$ a $$$ guarantee sum $$$ n^2 $$$ test case exceed $$$ 1000000 $$$ test case print $$$ n $$$ line $$$ n $$$ integers — lexicographically smallest matrix note every picture matrix transform a way blue row swap green columns first test case perform $$$ 1 $$$ operation $$$ k = 3 $$$ matrix transform :","['data structures', 'greedy']",2400.0
1714/E,give array $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ apply follow operation arbitrary number time : a single index ( value $$$ i $$$ ) operation apply multiple time operation apply repeatedly index current value $$$ a_i $$$ take account time example $$$ a_i=47 $$$ first operation get $$$ a_i=47 + 7=54 $$$ second operation get $$$ <unknown> + <unknown> $$$ check possible make array elements equal apply multiple ( possibly zero ) operations example array $$$ [ 6 11 ] $$$ thus apply $$$ 2 $$$ operations make elements array equal first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow a description test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — size array second line test case contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — array elements guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print : print yes case ( example string yes yes yes yes recognize a positive answer ) first test case clarify second test case impossible make array elements equal third test case need apply operation elements equal $$$ 5 $$$ fourth test case need apply operation elements become equal $$$ 8 $$$ fifth test case impossible make array elements equal sixth test case need apply operation elements become equal $$$ 102 $$$,['math'],1400.0
1715/A,stanley megan decide shop ` ` <unknown> '' grocery store represent a matrix $$$ n $$$ row $$$ m $$$ columns stanley megan move adjacent cell use $$$ 1 $$$ unit power two cells consider adjacent share edge speed shop process megan bring portals leave one cell visit ( portal yet ) a person ( stanley megan ) a cell a portal person use $$$ 1 $$$ unit power teleport cell a portal include megan 's start cell decide split : stanley go upper - left cell ( cell coordinate $$$ ( 1 1 ) $$$ ) lower - right cell ( cell coordinate $$$ ( n m ) $$$ ) <unknown> megan need get lower - left cell ( cell coordinate $$$ ( n 1 ) $$$ ) upper - right cell ( cell coordinate $$$ ( 1 m ) $$$ ) minimum total energy need ? note choose time move time affect energy test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) description test case follow line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100000 $$$ ) test case print a single integer a new line – answer first test case stick follow plan : total energy spend $$$ ( 2 + 6 ) + ( 2 + 1 + 2 ) + ( 2 ) = 15 $$$ final answer,"['greedy', 'math']",800.0
1716/A,stand point $$$ 0 $$$ a coordinate line goal reach point $$$ n $$$ one minute move $$$ 2 $$$ $$$ 3 $$$ leave right ( i. e. current coordinate $$$ x $$$ become $$$ x-3 $$$ $$$ x-2 $$$ $$$ x+2 $$$ $$$ x+3 $$$ ) note new coordinate become negative task find minimum number minutes require get point $$$ 0 $$$ point $$$ n $$$ answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ line describe test case follow $$$ i $$$ -th line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) — goal $$$ i $$$ -th test case test case print one integer — minimum number minutes require get point $$$ 0 $$$ point $$$ n $$$ correspond test case,"['greedy', 'math']",800.0
1716/B,a permutation length $$$ n $$$ a sequence integers $$$ 1 $$$ $$$ n $$$ integer appear exactly let fixedness a permutation $$$ p $$$ number fix point — number position $$$ j $$$ $$$ p_j = j $$$ $$$ p_j $$$ $$$ j $$$ -th element permutation $$$ p $$$ ask build a sequence permutations $$$ a_1 a_2 \dots $$$ start identity permutation ( permutation $$$ a_1 = [ 1 2 \dots n ] $$$ ) let 's call a permutation chain thus $$$ a_i $$$ $$$ i $$$ -th permutation length $$$ n $$$ every $$$ i $$$ $$$ 2 $$$ onwards permutation $$$ a_i $$$ obtain permutation $$$ a _ { i-1 } $$$ swap two elements ( necessarily neighbor ) fixedness permutation $$$ a_i $$$ strictly lower fixedness permutation $$$ a _ { i-1 } $$$ consider chain $$$ n = 3 $$$ : find longest permutation chain multiple longest answer print first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 99 $$$ ) — number testcases line testcase contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — require length permutations chain testcase first print length a permutation chain $$$ k $$$ print $$$ k $$$ permutations $$$ a_1 a_2 \dots a_k $$$ $$$ a_1 $$$ identity permutation length $$$ n $$$ ( $$$ [ 1 2 \dots n ] $$$ ) $$$ i $$$ $$$ 2 $$$ $$$ k $$$ $$$ a_i $$$ obtain swap two elements $$$ a _ { i-1 } $$$ also a strictly lower fixedness $$$ a _ { i-1 } $$$,['math'],800.0
1717/E,madoka want enter ` ` <unknown> state university '' entrance exam come across a difficult task : give integer $$$ n $$$ require calculate $$$ \sum { \operatorname { lcm } ( c \gcd ( a b ) ) } $$$ triple positive integers $$$ ( a b c ) $$$ $$$ a + b + c = n $$$ problem $$$ \gcd ( x y ) $$$ denote greatest common divisor $$$ x $$$ $$$ y $$$ $$$ \operatorname { lcm } ( x y ) $$$ denote least common multiple $$$ x $$$ $$$ y $$$ solve problem madoka help enter best university ! first line contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 100000 $$$ ) print exactly one interger — $$$ \sum { \operatorname { lcm } ( c \gcd ( a b ) ) } $$$ since answer large output modulo $$$ 1000000000 + 7 $$$ first example one suitable triple $$$ ( 1 1 1 ) $$$ answer $$$ \operatorname { lcm } ( 1 \gcd ( 1 1 ) ) = \operatorname { lcm } ( 1 1 ) = 1 $$$ second example $$$ \operatorname { lcm } ( 1 \gcd ( 3 1 ) ) + \operatorname { lcm } ( 1 \gcd ( 2 2 ) ) + \operatorname { lcm } ( 1 \gcd ( 1 3 ) ) + \operatorname { lcm } ( 2 \gcd ( 2 1 ) ) + \operatorname { lcm } ( 2 \gcd ( 1 2 ) ) + \operatorname { lcm } ( 3 \gcd ( 1 1 ) ) = \operatorname { lcm } ( 1 1 ) + \operatorname { lcm } ( 1 2 ) + \operatorname { lcm } ( 1 1 ) + \operatorname { lcm } ( 2 1 ) + \operatorname { lcm } ( 2 1 ) + \operatorname { lcm } ( 3 1 ) = 1 + 2 + 1 + 2 + 2 + 3 = 11 $$$,['math'],2200.0
1717/F,"oh first exam madoka get hard problem : give integer $$$ n $$$ $$$ m $$$ pair integers ( $$$ v_i u_i $$$ ) also array $$$ b_1 b_2 \ldots b_n $$$ initially fill zero index $$$ i $$$ $$$ 1 \leq i \leq m $$$ perform either $$$ b _ { v_i } : = b _ { v_i } - 1 $$$ $$$ b _ { u_i } : = b _ { u_i } + 1 $$$ $$$ b _ { v_i } : = b _ { v_i } + 1 $$$ $$$ b _ { u_i } : = b _ { u_i } - 1 $$$ note exactly one operations perform every $$$ i $$$ also array $$$ s $$$ length $$$ n $$$ consist $$$ 0 $$$ $$$ 1 $$$ array $$$ a_1 a_2 \ldots a_n $$$ guarantee $$$ s_i = 0 $$$ hold $$$ a_i = 0 $$$ help madoka determine whenever possible perform operations way every $$$ i $$$ $$$ s_i = 1 $$$ hold $$$ a_i = b_i $$$ possible also provide madoka a way perform operations first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 10000 1 \leq m \leq 10000 $$$ ) — length array $$$ a $$$ number pair integers second line contain $$$ n $$$ integers $$$ s_1 s_2 \ldots s_n $$$ ( $$$ 0 \le s_i \le 1 $$$ ) — elements array $$$ s $$$ third line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ |a_i| \leq m $$$ ) — elements array $$$ a $$$ guarantee $$$ s_i = 0 $$$ hold $$$ a_i = 0 $$$ $$$ i $$$ -th follow $$$ m $$$ line contain two integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \leq v_i u_i \leq n v_i \ne u_i $$$ ) — index elements array $$$ b $$$ operation perform also guarantee two indices $$$ i $$$ $$$ j $$$ $$$ 1 \le i < j \le m $$$ $$$ ( v_i u_i ) = ( v_j u_j ) $$$ $$$ ( v_i u_i ) = ( u_j v_j ) $$$ first line print ` ` yes '' possible perform operations require way ` ` '' otherwise may print letter case ( example ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive answer ) case print ` ` yes '' print $$$ m $$$ pair integers pair $$$ ( v_i u_i ) $$$ perform $$$ b _ { v_i } : = b _ { v_i } - 1 $$$ $$$ b _ { u_i } : = b _ { u_i } + 1 $$$ print $$$ ( v_i u_i ) $$$ otherwise print $$$ ( u_i v_i ) $$$ multiple ways get correct answer print print pair order first example array $$$ b $$$ change follow : $$$ [ 0,0,0,0,0 ] \rightarrow [ <unknown> ] \rightarrow [ <unknown> ] \rightarrow [ <unknown> ] \rightarrow [ <unknown> ] \rightarrow [ <unknown> -1 ] $$$ $$$ a_i = b_i $$$ indices $$$ i $$$ $$$ 1 $$$ $$$ 5 $$$ second example enough us $$$ b_2 = 1 $$$ end since $$$ s_2 = 1 $$$ third example operations perform require",['implementation'],2500.0
1718/B,school buryatia $$$ 1 $$$ class everyone tell theory fibonacci string ` ` a block a subsegment a string letter bound leave right end string letter letter block a string call a fibonacci string divide block lengths order appear string form fibonacci sequence ( $$$ f_0 = f_1 = 1 $$$ $$$ f_i = f _ { i-2 } + f _ { i-1 } $$$ ) start <unknown> member sequence a string call semi - fibonacci possible reorder letter get a fibonacci string ` ` burenka decide enter buryat state university entrance exam give a difficult task give a string consist letter buryat alphabet ( contain exactly $$$ k $$$ letter ) ask give string semi - fibonacci string long instead string give number appearances letter ( $$$ c_i $$$ $$$ i $$$ -th letter ) string unfortunately burenka longer remember theory fibonacci string without help pass exam first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case follow a description input data set first line test case contain one integer $$$ k $$$ ( $$$ 1 \leq k \leq 100 $$$ ) — number letter alphabet second line test case contain $$$ k $$$ integers $$$ c_1 c_2 \ldots c_k $$$ ( $$$ 1 \leq c_i \leq 1000000000 $$$ ) — number occurrences letter string test case print string ` ` yes '' correspond string semi - fibonacci ` ` '' print ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ) first test case a one - character string semi - fibonacci a fibonacci string second test case a string two different character fibonacci third test case string ` ` abb '' ( let first alphabet letter a second letter b ) a semi - fibonacci string since permutation letter ( ` ` abb '' ` ` bab '' ` ` bba '' ) a fibonacci string fourth test case two permutations letter string ` ` <unknown> '' ( first letter a second letter b third letter c ) fibonacci string — ` ` <unknown> '' ` ` <unknown> '',"['greedy', 'implementation', 'math']",2000.0
1719/A,burenka tonya play old buryat game a chip a board $$$ n \times m $$$ cells begin game chip locate lower leave corner board one move player move chip right odd number cells ( move chip right one move ) one make a move lose burenka make first move players take turn burenka really want win game lazy come a strategy invite solve difficult task find name winner game ( believe burenka tonya master play chip always move optimal way ) first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case follow a description input data set line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 1000000000 $$$ ) — dimension game board test case print a single line — name winner game ( ` ` burenka '' ` ` tonya '' ) first case burenka move tonya win second case burenka move $$$ 3 $$$ cells right tony able make a move mean burenka win third case burenka move $$$ 5 $$$ square right say a game a board $$$ 1 \times 5 $$$ cells tonya first player game second player win original one burenka win,['math'],800.0
1720/B,give array $$$ a $$$ contain $$$ n $$$ integers choose proper subsegment $$$ a_l a _ { l + 1 } \ldots a_r $$$ array mean choose two integers $$$ 1 \le l \le r \le n $$$ $$$ r - l + 1 < n $$$ define beauty a give subsegment value follow expression : $$$ $$$ \max ( a _ { 1 } a _ { 2 } \ldots a _ { l-1 } a _ { r+1 } a _ { r+2 } \ldots a _ { n } ) - \min ( a _ { 1 } a _ { 2 } \ldots a _ { l-1 } a _ { r+1 } a _ { r+2 } \ldots a _ { n } ) + \max ( a _ { l } \ldots a _ { r } ) - \min ( a _ { l } \ldots a _ { r } ) $$$ $$$ please find maximum beauty among proper subsegments first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case follow descriptions test case first line test case contain a single integer $$$ n $$$ $$$ ( 4 \leq n \leq 100000 ) $$$ — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a _ { i } \leq 1000000000 $$$ ) — elements give array guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ testcase print a single integer — maximum beauty a proper subsegment first test case optimal segment $$$ l = 7 $$$ $$$ r = 8 $$$ beauty segment equal $$$ ( 6 - 1 ) + ( 5 - 1 ) = 9 $$$ second test case optimal segment $$$ l = 2 $$$ $$$ r = 4 $$$ beauty segment equal $$$ ( 100 - 2 ) + ( 200 - 1 ) = <unknown> $$$,"['data structures', 'greedy', 'math']",800.0
1726/B,"mainak two positive integers $$$ n $$$ $$$ m $$$ mainak find a sequence $$$ a_1 a_2 \ldots a_n $$$ $$$ n $$$ positive integers interest integers $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) bitwise xor elements $$$ a $$$ strictly less $$$ a_i $$$ $$$ 0 $$$ formally $$$ p_i $$$ bitwise xor elements $$$ a $$$ strictly less $$$ a_i $$$ $$$ a $$$ interest sequence $$$ p_1 = p_2 = \ldots = p_n = 0 $$$ example sequence $$$ [ 1,3,2,3,1,2,3 ] $$$ $$$ [ 4,4,4,4 ] $$$ $$$ [ 25 ] $$$ interest whereas $$$ [ 1,2,3,4 ] $$$ ( $$$ p_2 = 1 \ne 0 $$$ ) $$$ [ <unknown> ] $$$ ( $$$ p_1 = 1 \oplus 1 \oplus 2 = 2 \ne 0 $$$ ) $$$ [ <unknown> ] $$$ ( $$$ p_2 = 29 \ne 0 $$$ ) n't interest $$$ a \oplus b $$$ denote bitwise xor integers $$$ a $$$ $$$ b $$$ find interest sequence $$$ a_1 a_2 \ldots a_n $$$ ( report exist sequence ) sum elements sequence $$$ a $$$ equal $$$ m $$$ i.e $$$ a_1 + a_2 \ldots + a_n = m $$$ a reminder bitwise xor empty sequence consider $$$ 0 $$$ test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case description test case follow first line line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 1 \le m \le 1000000000 $$$ ) — length sequence sum elements guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case exist interest sequence output ` ` yes '' first line otherwise output ` ` '' may print letter case ( example ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive answer ) answer ` ` yes '' output $$$ n $$$ positive integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ a_i \ge 1 $$$ ) form interest sequence $$$ a_1 + a_2 \ldots + a_n = m $$$ multiple solutions output",['math'],1100.0
1728/E,monocarp go host a party friends prepare $$$ n $$$ dish serve first add powder pepper — otherwise dish pretty <unknown> $$$ i $$$ -th dish two value $$$ a_i $$$ $$$ b_i $$$ — tastiness red pepper add black pepper add respectively monocarp wo n't add pepper dish wo n't add pepper multiple time wo n't leave dish without pepper add add pepper monocarp first purchase say pepper shop $$$ m $$$ shop local area $$$ j $$$ -th package red pepper sufficient $$$ x_j $$$ serve package black pepper sufficient $$$ y_j $$$ serve monocarp go exactly one shop purchase multiple ( possibly zero ) package pepper a way dish get pepper add pepper leave formally purchase $$$ x $$$ red pepper package $$$ y $$$ black pepper package $$$ x $$$ $$$ y $$$ non - negative $$$ x \cdot x_j + y \cdot y_j $$$ equal $$$ n $$$ shop determine maximum total tastiness dish monocarp buy pepper package shop add pepper dish 's impossible purchase package say way print -1 . first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) — number dish $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le 1000000000 $$$ ) — tastiness $$$ i $$$ -th dish red pepper add black pepper add respectively next line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 300000 $$$ ) — number shop $$$ j $$$ -th next $$$ m $$$ line contain two integers $$$ x_j $$$ $$$ y_j $$$ ( $$$ 1 \le x_j y_j \le n $$$ ) — number serve red black pepper package sufficient $$$ j $$$ -th shop respectively print $$$ m $$$ integers shop print maximum total tastiness dish monocarp buy pepper package shop add pepper dish 's impossible purchase package dish get pepper add pepper leave print -1 . consider first example first shop monocarp buy $$$ 0 $$$ red pepper package $$$ 1 $$$ black pepper package black pepper add dish sum $$$ 10 + 50 + 2 = 62 $$$ second shop monocarp buy number red black pepper package : $$$ 0 $$$ $$$ 3 $$$ $$$ 1 $$$ $$$ 2 $$$ $$$ 2 $$$ $$$ 1 $$$ $$$ 3 $$$ $$$ 0 $$$ optimal choice turn either $$$ 1 $$$ $$$ 2 $$$ $$$ 2 $$$ $$$ 1 $$$ monocarp add black pepper first dish red pepper second dish pepper third dish total $$$ 10 + 100 + 2 = 112 $$$ third shop monocarp buy $$$ 1 $$$ red pepper package $$$ 0 $$$ black pepper package red pepper add dish sum $$$ 5 + 100 + 2 = 107 $$$ fourth shop monocarp buy even total number package since $$$ n $$$ odd 's impossible get exactly $$$ n $$$ package thus answer $$$ -1 $$$,"['data structures', 'greedy', 'math']",2300.0
1728/G,consider a segment $$$ [ 0 d ] $$$ coordinate line $$$ n $$$ lanterns $$$ m $$$ point interest segment lantern choose power — integer $$$ 0 $$$ $$$ d $$$ ( inclusive ) a lantern coordinate $$$ x $$$ illuminate point interest coordinate $$$ y $$$ $$$ |x - y| $$$ less equal power lantern a way choose power value lanterns consider valid every point interest illuminate least one lantern process $$$ q $$$ query query represent one integer $$$ f_i $$$ answer $$$ i $$$ -th query : first line contain three integers $$$ d $$$ $$$ n $$$ $$$ m $$$ ( $$$ 4 \le d \le 300000 $$$ ; $$$ 1 \le n \le 200000 $$$ ; $$$ 1 \le m \le 16 $$$ ) — size segment number lanterns number point interest respectively second line contain $$$ n $$$ integers $$$ l_1 l_2 \dots l_n $$$ ( $$$ 1 \le l_i \le d - 1 $$$ ) $$$ l_i $$$ coordinate $$$ i $$$ -th lantern third line contain $$$ m $$$ integers $$$ p_1 p_2 \dots p_m $$$ ( $$$ 1 \le p_i \le d - 1 $$$ ) $$$ p_i $$$ coordinate $$$ i $$$ -th point interest fourth line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 500000 $$$ ) — number query fifth line contain $$$ q $$$ integers $$$ f_1 f_2 \dots f_q $$$ ( $$$ 1 \le f_i \le d - 1 $$$ ) $$$ f_i $$$ integer represent $$$ i $$$ -th query additional constraint input : process query coordinate contain one object ( i. e. two lanterns coordinate two point interest coordinate a lantern a point interest coordinate ) query print one integer — answer take modulo $$$ 998244353 $$$,"['dp', 'math']",2700.0
173/D,<unknown> kingdom exactly n = 3k cities locate shore river <unknown> flow whole kingdom cities locate one side river rest side cities connect bridge build bridge connect two cities locate opposite side river two cities exist one bridge recently <unknown> king tristan third busy distribute deputies among cities total k deputies king want commission control exactly three cities however deputy entrust manage cities connect a bridge — deputy set a high fee travel bridge <unknown> pocket bad reputation king help king tristan third distribute deputies cities possible first line contain two integers n m — number cities bridge ( 3 ≤ n < 105 n = 3k 0 ≤ m ≤ 105 ) next m line describe bridge i - th line contain two integers ai bi — number cities connect i - th bridge ( 1 ≤ ai bi ≤ n ai ≠ bi 1 ≤ i ≤ m ) guarantee bridge connect a city two cities connect one bridge distribute deputies require manner impossible print a single line ` ` '' ( without quote ) otherwise first line print ` ` yes '' ( without quote ) second line print deputy put charge city i - th number represent number deputy ( 1 k ) charge city number i - th input — overall n number multiple solutions print,"['greedy', 'implementation']",2500.0
173/E,a club want take members camp order organize event better club directors decide partition members several group club member i a responsibility value ri age value ai a group a non - empty subset club members one member know group leader a group leader one responsible members group ( responsibility value less responsibility group member ) age absolute difference group member exceed k. club members friends want group also like group large possible write a program answer a series question like ` ` 's largest size a group contain club member x club member y ? ` ` 's possible x y group leader first line contain two integers n k ( 2 ≤ n ≤ 105 0 ≤ k ≤ 109 ) — number club members age restriction one group next line contain integer number r1 r2 ... rn ( 1 ≤ ri ≤ 109 ) separate space : ri denote i - th club member 's responsibility way integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) third line : ai denote i - th club member 's age next line contain integer q denote number question answer ( 1 ≤ q ≤ 105 ) next q line describe question line contain two space - separated integers xi yi ( 1 ≤ xi yi ≤ n xi ≠ yi ) — indices club members end group question print maximum size group a line make a group impossible print -1 instead first query largest group members 3 5 { 1 3 4 5 } member 3 leader second query member 2 leader group { 1 2 3 } third query leader group age 3 leader member 3 less responsible member 2 . make a group impossible group fourth query first query,['data structures'],2600.0
1732/D1,easy version problem difference version ` ` remove '' query initially a set contain one element — $$$ 0 $$$ need handle $$$ q $$$ query follow type : problem define $$$ k\text { -mex } $$$ a set integers smallest non - negative integer $$$ x $$$ divisible $$$ k $$$ contain set first line contain integer $$$ q $$$ ( $$$ 1 \leq q \leq 200000 $$$ ) — number query follow $$$ q $$$ line describe query addition query integer $$$ x $$$ give format + $$$ x $$$ ( $$$ 1 \leq x \leq 10^ { 18 } $$$ ) guarantee $$$ x $$$ contain set a search query $$$ k\text { -mex } $$$ give format ? $$$ k $$$ ( $$$ 1 \leq k \leq 10^ { 18 } $$$ ) guarantee least one query type ? query type ? output a single integer — $$$ k\text { -mex } $$$ set first example : first second query set contain elements $$$ \ { 0 1 2\ } $$$ smallest non - negative number divisible $$$ 1 $$$ contain set $$$ 3 $$$ fourth query set contain elements $$$ \ { 0 1 2 4\ } $$$ smallest non - negative number divisible $$$ 2 $$$ contain set $$$ 6 $$$ second example :,"['data structures', 'implementation']",1500.0
1732/D2,hard version problem difference version remove query initially a set contain one element — $$$ 0 $$$ need handle $$$ q $$$ query follow type : problem define $$$ k\text { -mex } $$$ a set integers smallest non - negative integer $$$ x $$$ divisible $$$ k $$$ contain set first line contain integer $$$ q $$$ ( $$$ 1 \leq q \leq 200000 $$$ ) — number query follow $$$ q $$$ line describe query addition query integer $$$ x $$$ give format + $$$ x $$$ ( $$$ 1 \leq x \leq 10^ { 18 } $$$ ) guarantee $$$ x $$$ contain set a remove query integer $$$ x $$$ give format - $$$ x $$$ ( $$$ 1 \leq x \leq 10^ { 18 } $$$ ) guarantee $$$ x $$$ contain set a search query $$$ k\text { -mex } $$$ give format ? $$$ k $$$ ( $$$ 1 \leq k \leq 10^ { 18 } $$$ ) guarantee least one query type ? query type ? output a single integer — $$$ k\text { -mex } $$$ set first example : first second query set contain elements $$$ \ { 0 1 2\ } $$$ smallest non - negative number divisible $$$ 1 $$$ set $$$ 3 $$$ fourth query set contain elements $$$ \ { 0 1 2 4\ } $$$ smallest non - negative number divisible $$$ 2 $$$ set $$$ 6 $$$ second example :,['data structures'],2400.0
1732/E,give two array integers $$$ a_1 a_2 \ldots a_n $$$ $$$ b_1 b_2 \ldots b_n $$$ need handle $$$ q $$$ query follow two type : problem $$$ \gcd ( x y ) $$$ denote greatest common divisor $$$ x $$$ $$$ y $$$ $$$ \operatorname { lcm } ( x y ) $$$ denote least common multiple $$$ x $$$ $$$ y $$$ first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \leq n q \leq 50000 $$$ ) — number number array $$$ a $$$ $$$ b $$$ number query second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 50000 $$$ ) — elements array $$$ a $$$ third line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1 \leq b_i \leq 50000 $$$ ) — elements array $$$ b $$$ $$$ q $$$ line follow $$$ j $$$ -th start integer $$$ t_j $$$ ( $$$ 1 \leq t_j \leq 2 $$$ ) mean $$$ j $$$ -th query type $$$ t_j $$$ $$$ t_j = 1 $$$ follow three integers $$$ l_j $$$ $$$ r_j $$$ $$$ x_j $$$ ( $$$ 1 \leq l_j \leq r_j \leq n $$$ $$$ 1 \leq x_j \leq 50000 $$$ ) $$$ t_j = 2 $$$ follow two integers $$$ l_j $$$ $$$ r_j $$$ ( $$$ 1 \leq l_j \leq r_j \leq n $$$ ) guarantee least one query type $$$ 2 $$$ query second type output minimum value expression first example : second :,"['data structures', 'dp', 'math']",2800.0
1734/C,"give a set $$$ s $$$ contain first $$$ n $$$ positive integers : $$$ 1 2 \ldots n $$$ perform follow operation $$$ s $$$ number time ( possibly zero ) : give a set $$$ t $$$ a subset $$$ s $$$ find minimum possible total cost operations $$$ s $$$ would transform $$$ t $$$ show a transformation always possible first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10\,000 $$$ ) — number test case description test case follow first line contain a single positive integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) second line test case contain a binary string length $$$ n $$$ describe set $$$ t $$$ $$$ i $$$ -th character string ' 1 ' $$$ i $$$ element $$$ t $$$ ' 0 ' otherwise guarantee sum $$$ n $$$ test case exceed $$$ 1000000 $$$ test case output one non - negative integer — minimum possible total cost operations $$$ s $$$ would transform $$$ t $$$ first test case shall perform operations $$$ s $$$ already equal $$$ t $$$ set $$$ \ { 1 2 3 4 5 6\ } $$$ second test case initially $$$ s = \ { 1 2 3 4 5 6 7\ } $$$ $$$ t = \ { 1 2 4 7\ } $$$ shall perform follow operations : total cost $$$ 3 + 3 + 5 = 11 $$$ show smallest cost possible third test case initially $$$ s = \ { 1 2 3 4\ } $$$ $$$ t = \ { \ } $$$ ( empty set ) shall perform $$$ 4 $$$ operations $$$ k=1 $$$ delete $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ fourth test case initially $$$ s = \ { 1 2 3 4\ } $$$ $$$ t = \ { 3\ } $$$ shall perform two operations $$$ k=1 $$$ delete $$$ 1 $$$ $$$ 2 $$$ perform one operation $$$ k=2 $$$ delete $$$ 4 $$$","['greedy', 'math']",1200.0
1734/F,let $$$ s $$$ <unknown> - morse sequence word $$$ s $$$ $$$ 0 $$$ -indexed binary string infinite length construct follow : example first four iterations : give two positive integers $$$ n $$$ $$$ m $$$ find number position string $$$ s_0 s_1 \ldots s _ { m-1 } $$$ $$$ s_n s _ { n + 1 } \ldots s _ { n + m - 1 } $$$ different test contain multiple test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain two positive integers $$$ n $$$ $$$ m $$$ respectively ( $$$ 1 \leq n m \leq 10^ { 18 } $$$ ) testcase output a non - negative integer — ham distance two require string string $$$ s $$$ equal <unknown> .... first test case $$$ s_0 $$$ ` ` 0 '' $$$ s_1 $$$ ` ` 1 '' ham distance two string $$$ 1 $$$ second test case $$$ s_0 s_1 \ldots <unknown> $$$ ` ` <unknown> '' $$$ s_5 s_6 \ldots s _ { 14 } $$$ ` ` <unknown> '' ham distance two string $$$ 6 $$$,"['dp', 'math']",2500.0
1735/C,a string $$$ s $$$ suppose encrypt reason $$$ 26 $$$ lowercase english letter arrange a circle order afterwards letter $$$ s $$$ replace one follow clockwise order way string $$$ t $$$ obtain give a string $$$ t $$$ determine lexicographically smallest string $$$ s $$$ could a prototype give string $$$ t $$$ a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ length : first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 30000 $$$ ) — number test case description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length string $$$ t $$$ next line contain string $$$ t $$$ length $$$ n $$$ contain lowercase english letter guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case output a single line contain lexicographically smallest string $$$ s $$$ could a prototype $$$ t $$$ first test case could n't string ` ` a '' since letter a would transit lexicographically second string ` ` b '' suitable answer second test case string ` ` aa '' suitable since a would transit ` ` ab '' suitable since circle would close $$$ 2 $$$ letter must contain $$$ 26 $$$ next string ` ` ac '' suitable see scheme first three test case non - <unknown> letter skip arbitrary place gap,"['greedy', 'implementation']",1400.0
1736/A,give two array $$$ a $$$ $$$ b $$$ $$$ n $$$ elements element either $$$ 0 $$$ $$$ 1 $$$ make operations $$$ 2 $$$ kinds find minimum number operations require make $$$ a $$$ equal $$$ b $$$ test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 400 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) — length array $$$ a $$$ $$$ b $$$ second line test case contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ a_i $$$ $$$ 0 $$$ $$$ 1 $$$ ) represent array $$$ a $$$ third line test case contain $$$ n $$$ space - separated integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ b_i $$$ $$$ 0 $$$ $$$ 1 $$$ ) represent array $$$ b $$$ test case print minimum number operations require make $$$ a $$$ equal $$$ b $$$ first case need one operation : change $$$ a_1 $$$ $$$ 1 - a_i $$$ $$$ a = [ 0 0 ] $$$ equal $$$ b $$$ second case optimal way rearrange $$$ a $$$ get array $$$ [ 0 1 11 $$$ $$$ a = [ 0 0 1 ] $$$ equal $$$ b $$$ second case one optimal ways would first change $$$ a_3 $$$ $$$ 1 - a_3 $$$ rearrange $$$ a $$$ third case operation need fourth case optimal way rearrange $$$ a $$$ get array $$$ [ 0 1 1 0 ] $$$,['greedy'],800.0
1736/B,give integer array $$$ a $$$ length $$$ n $$$ exist array $$$ b $$$ consist $$$ n+1 $$$ positive integers $$$ <unknown> ( b_i b _ { i+1 } ) $$$ $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) ? note $$$ \gcd ( x y ) $$$ denote greatest common divisor ( gcd ) integers $$$ x $$$ $$$ y $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — length array $$$ a $$$ second line test case contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \ldots a_n $$$ represent array $$$ a $$$ ( $$$ 1 \leq a_i \leq 10000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output ` ` yes '' $$$ b $$$ exist otherwise output ` ` '' print letter case ( upper lower ) first test case take $$$ b= [ <unknown> ] $$$ second test case one possibility $$$ b $$$ $$$ b= [ <unknown> ] $$$ third test case prove exist array $$$ b $$$ fulfill condition,['math'],1200.0
1738/B,suppose $$$ a_1 a_2 \dots a_n $$$ a sort integer sequence length $$$ n $$$ $$$ a_1 \leq a_2 \leq \dots \leq a_n $$$ every $$$ 1 \leq i \leq n $$$ prefix sum $$$ s_i $$$ first $$$ i $$$ term $$$ a_1 a_2 \dots a_i $$$ define $$$ $$$ s_i = \sum _ { k=1 } ^i a_k = a_1 + a_2 + \dots + a_i $$$ $$$ give last $$$ k $$$ term prefix sum $$$ s _ { n - k+1 } \dots s _ { n-1 } s _ { n } $$$ task determine whether possible formally give $$$ k $$$ integers $$$ s _ { n - k+1 } \dots s _ { n-1 } s _ { n } $$$ task check whether a sequence $$$ a_1 a_2 \dots a_n $$$ test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case follow line contain description test case first line test case contain two integers $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) $$$ k $$$ ( $$$ 1 \leq k \leq n $$$ ) indicate length sequence $$$ a $$$ number term prefix sum respectively second line test case contain $$$ k $$$ integers $$$ s _ { n - k+1 } \dots s _ { n-1 } s _ { n } $$$ ( $$$ -1000000000 \leq s_i \leq 1000000000 $$$ every $$$ n - k+1 \leq i \leq n $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output ` ` yes '' ( without quote ) possible ` ` '' ( without quote ) otherwise output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first test case sequence $$$ a = [ 1 1 1 1 1 ] $$$ second test case choose example $$$ a = [ -3 -2 -1 0 1 2 3 ] $$$ third test case prefix sum define sequence $$$ a = [ 2 1 1 ] $$$ sort fourth test case show sequence give prefix sum,"['greedy', 'math']",1200.0
1738/H,task maintain a queue consist lowercase english letter follow : initially queue empty operation ask count number distinct palindromic substrings string obtain concatenate letter front back queue especially number distinct palindromic substrings empty string $$$ 0 $$$ a string $$$ s [ 1 .. n ] $$$ length $$$ n $$$ palindromic $$$ s [ i ] = s [ n - i+1 ] $$$ every $$$ 1 \leq i \leq n $$$ string $$$ s [ l .. r ] $$$ a substring string $$$ s [ 1 .. n ] $$$ every $$$ 1 \leq l \leq r \leq n $$$ two string $$$ s [ 1 .. n ] $$$ $$$ t [ 1 .. m ] $$$ distinct least one follow hold first line integer $$$ q $$$ ( $$$ 1 \leq q \leq 1000000 $$$ ) indicate number operations $$$ q $$$ line follow follow line contain one operations follow guarantee ` ` pop '' operation perform queue empty operation print number distinct palindromic substrings string present queue let $$$ s_k $$$ string present queue $$$ k $$$ -th operation let $$$ c_k $$$ number distinct palindromic substrings $$$ s_k $$$ follow table show detail example worth point,['data structures'],3300.0
1740/F,"pak chanek give array $$$ a $$$ $$$ n $$$ integers $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) pak chanek write one - element set $$$ \ { a_i\ } $$$ a whiteboard , one operation pak chanek may follow : perform zero operations pak chanek construct a multiset $$$ m $$$ contain size set write whiteboard word element $$$ m $$$ correspond size a set operations many distinct $$$ ^\dagger $$$ multisets $$$ m $$$ create process ? since answer may large output modulo $$$ 998\,244\,353 $$$ $$$ ^\dagger $$$ multisets $$$ b $$$ $$$ c $$$ different exist a value $$$ k $$$ number elements value $$$ k $$$ $$$ b $$$ different number elements value $$$ k $$$ $$$ c $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 2000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) output number distinct multisets $$$ m $$$ modulo $$$ 998\,244\,353 $$$ first example possible multisets $$$ m $$$ $$$ \ { <unknown> } $$$ $$$ \ { <unknown> } $$$ $$$ \ { <unknown> } $$$ $$$ \ { <unknown> } $$$ $$$ \ { <unknown> } $$$ $$$ \ { 1,2,3\ } $$$ $$$ \ { <unknown> } $$$ example let 's consider a possible sequence operations","['dp', 'math']",2600.0
1741/B,"a sequence $$$ n $$$ number call permutation contain number $$$ 1 $$$ $$$ n $$$ exactly example sequence $$$ [ 3 1 4 2 ] $$$ [ $$$ 1 $$$ ] $$$ [ 2,1 ] $$$ permutations $$$ [ 1,2,1 ] $$$ $$$ [ 0,1 ] $$$ $$$ [ 1,3,4 ] $$$ a give number $$$ n $$$ need make a permutation $$$ p $$$ two requirements satisfy time : let 's call permutation satisfy requirements funny example let $$$ n = 4 $$$ [ $$$ 4 3 1 2 $$$ ] a funny permutation since : a give positive integer $$$ n $$$ output funny permutation length $$$ n $$$ output -1 funny permutation length $$$ n $$$ exist first line input data contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow test case consist f single line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print a separate line : first test case explain problem statement second test case possible make require permutation : permutations $$$ [ 1 2 3 ] $$$ $$$ [ 1 3 2 ] $$$ $$$ [ 2 1 3 ] $$$ $$$ [ 3 2 1 ] $$$ fix point $$$ [ 2 3 1 ] $$$ $$$ [ 3 1 2 ] $$$ first condition meet position",['math'],800.0
1742/C,$$$ 8 \times 8 $$$ grid horizontal row paint red vertical columns paint blue order strip draw sequentially one stripe draw repaint cells pass determine color use last first line input contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 4000 $$$ ) — number test case description test case follow empty line test case test case consist $$$ 8 $$$ line contain $$$ 8 $$$ character character either ' r ' ' b ' ' ' denote a red square a blue square unpainted square respectively guarantee give field obtain a colorless one draw horizontal red row vertical blue columns least one stripe paint test case output ' r ' a red stripe paint last ' b ' a blue stripe paint last ( without quote ) first test case picture statement second test case first blue column paint first first last red row finally last blue column since a blue stripe paint last answer b,['implementation'],900.0
1743/A,monocarp forget password mobile phone password consist $$$ 4 $$$ digits $$$ 0 $$$ $$$ 9 $$$ ( note start digit $$$ 0 $$$ ) monocarp remember password exactly two different digits digits appear exactly two time password monocarp also remember digits definitely use password calculate number different sequence $$$ 4 $$$ digits could password monocarp 's mobile phone ( i. e. sequence meet constraints monocarp 's password ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200 $$$ ) — number testcases first line testcase contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 8 $$$ ) — number digits monocarp remember use password second line contain $$$ n $$$ different integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 9 $$$ ) represent digits use password note digits $$$ a_1 a_2 \dots a_n $$$ give ascend order testcase print one integer — number different $$$ 4 $$$ -digit sequence meet constraints first example possible passwords : ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '',"['implementation', 'math']",800.0
1743/B,"give integer $$$ n $$$ construct a permutation size $$$ n $$$ a permutation array integer $$$ 1 $$$ $$$ s $$$ ( $$$ s $$$ size permutation ) occur exactly example $$$ [ 2 1 4 3 ] $$$ a permutation size $$$ 4 $$$ ; $$$ [ 1 2 4 5 3 ] $$$ a permutation size $$$ 5 $$$ ; $$$ [ 1 4 3 ] $$$ a permutation ( integer $$$ 2 $$$ absent ) $$$ [ 2 1 3 1 ] $$$ a permutation ( integer $$$ 1 $$$ appear twice ) a subsegment a permutation a contiguous subsequence permutation example permutation $$$ [ 2 1 4 3 ] $$$ $$$ 10 $$$ subsegments : $$$ [ 2 ] $$$ $$$ [ 2 1 ] $$$ $$$ [ 2 1 4 ] $$$ $$$ [ 2 1 4 3 ] $$$ $$$ [ 1 ] $$$ $$$ [ 1 4 ] $$$ $$$ [ 1 4 3 ] $$$ $$$ [ 4 ] $$$ $$$ [ 4 3 ] $$$ $$$ [ 3 ] $$$ value permutation number subsegments also permutations example value $$$ [ 2 1 4 3 ] $$$ $$$ 3 $$$ since subsegments $$$ [ 2 1 ] $$$ $$$ [ 1 ] $$$ $$$ [ 2 1 4 3 ] $$$ permutations construct a permutation size $$$ n $$$ minimum possible value among permutations size $$$ n $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 48 $$$ ) — number test case , $$$ t $$$ line follow $$$ i $$$ -th contain one integer $$$ n $$$ ( $$$ 3 \le n \le 50 $$$ ) represent $$$ i $$$ -th test case test case print $$$ n $$$ integers — permutation size $$$ n $$$ minimum possible value multiple permutations print first example permutation $$$ [ 1 4 3 5 2 ] $$$ one possible answer ; value $$$ 2 $$$ second example permutation $$$ [ 4 1 6 2 5 3 ] $$$ one possible answer ; value $$$ 2 $$$",['greedy'],800.0
1743/C,"monocarp collect rare magazines quite a decide sell distribute magazines $$$ n $$$ box arrange a row $$$ i $$$ -th box contain $$$ a_i $$$ magazines box cover lids others suddenly start rain monocarp save many magazines rain possible , move lids box follow : $$$ i $$$ -th box cover a lid initially either move lid $$$ i $$$ -th box box $$$ ( i-1 ) $$$ ( exist ) keep lid $$$ i $$$ -th box may assume monocarp move lids instantly moment lid move a box cover a lid monocarp move lids magazines safe rain ; otherwise <unknown> calculate maximum number magazines monocarp save rain first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number box second line contain a string $$$ n $$$ character 0 and/or 1 . $$$ i $$$ -th character 1 $$$ i $$$ -th box initially cover a lid $$$ i $$$ -th character 0 $$$ i $$$ -th box initially cover third line contain a sequence integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 10000 $$$ ) $$$ a_i $$$ number magazines $$$ i $$$ -th box sum $$$ n $$$ testcases n't exceed $$$ 200000 $$$ testcase print one integer — maximum number magazines monocarp save rain first testcase example monocarp move lid second box first box box $$$ 1 $$$ $$$ 3 $$$ $$$ 4 $$$ cover $$$ 10 + 8 + 9 = 27 $$$ magazines save second testcase monocarp move lid second box first box third box second box fifth box fourth box sixth box fifth box box $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$ $$$ 5 $$$ cover $$$ 20 + 10 + 30 + 20 = 80 $$$ magazines save lids third testcase 's impossible save even a single magazine","['dp', 'greedy']",1100.0
1744/A,integer array $$$ a_1 a_2 \ldots a_n $$$ transform array lowercase english letter use follow <unknown> : least one number array : example initially array $$$ a = [ 2 3 2 4 1 ] $$$ could transform follow way : transformation letter unite a string example get string ` ` <unknown> '' array $$$ a $$$ string $$$ s $$$ determine string $$$ s $$$ could get array $$$ a $$$ describe transformation ? first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 50 $$$ ) — length array $$$ a $$$ string $$$ s $$$ second line test case contain exactly $$$ n $$$ integers : $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 50 $$$ ) — elements array $$$ a $$$ third line test case contain a string $$$ s $$$ length $$$ n $$$ consist lowercase english letter test case output ` ` yes '' get string $$$ s $$$ array $$$ a $$$ ` ` '' otherwise output letter case first test case correspond sample describe statement second test case choose number $$$ 50 $$$ letter a. third test case choose number $$$ 11 $$$ letter a $$$ a = [ a 22 ] $$$ choose number $$$ 22 $$$ letter b get $$$ a = [ a b ] $$$ fifth test case change number one one letter a,"['greedy', 'implementation']",800.0
1744/E1,easy version problem difference easy a hard version constraints $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ give $$$ 4 $$$ positive integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ $$$ a < c $$$ $$$ b < d $$$ find pair number $$$ x $$$ $$$ y $$$ satisfy follow condition : note require $$$ x $$$ $$$ y $$$ may exist first line input contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10 $$$ ) number test case descriptions test case follow line test case contain four integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ ( $$$ 1 \leq a < c \leq 100000 $$$ $$$ 1 \leq b < d \leq 100000 $$$ ) test case print a pair number $$$ a < x \leq c $$$ $$$ b < y \leq d $$$ $$$ x \cdot y $$$ divisible $$$ a \cdot b $$$ multiple answer print pair number print -1 -1,['math'],1500.0
1746/G,"anton decide get ready olympiad informatics ilya prepare $$$ n $$$ task solve possible submit solution $$$ i $$$ -th task first $$$ d _ { i } $$$ days anton solve one task a day ilya estimate usefulness $$$ i $$$ -th task $$$ r _ { i } $$$ divide task three topics topic $$$ i $$$ -th task $$$ type _ { i } $$$ anton want solve exactly $$$ a $$$ task first topic $$$ b $$$ task second topic $$$ c $$$ task third topic tell anton possible , calculate maximum total usefulness task may solve first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain four integers $$$ n a b c $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 0 \le a b c \le n $$$ ) follow $$$ n $$$ line contain three integers — $$$ r_i type_i d_i $$$ ( $$$ 0 \le r_i \le 10^ { 9 } $$$ $$$ 1 \le type_i \le 3 $$$ $$$ 1 \le d_i \le n $$$ ) sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print $$$ -1 $$$ anton reach goal ; otherwise print maximum usefulness task solve first test case sample test anton solve task $$$ 2 $$$ $$$ 4 $$$ second test case sample test impossible fulfill anton 's wish third test case sample test optimal solve task $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ last test case sample test optimal solve task $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$","['data structures', 'dp', 'implementation']",3500.0
1747/A,give array $$$ a $$$ consist $$$ n $$$ integers want distribute $$$ n $$$ integers two group $$$ s_1 $$$ $$$ s_2 $$$ ( group empty ) follow condition satisfy : $$$ sum ( s_1 ) $$$ denote sum number group $$$ s_1 $$$ $$$ sum ( s_2 ) $$$ denote sum number group $$$ s_2 $$$ determine maximum possible value $$$ |sum ( s_1 ) | - |sum ( s_2 ) | $$$ input consist multiple test case first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 2 \cdot 10000 ) $$$ — number test case description test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 1 \leq n \leq 100000 ) $$$ — length array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( -1000000000 \leq a_i \leq 1000000000 ) $$$ — elements array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case output a single integer — maximum possible value $$$ |sum ( s_1 ) | - |sum ( s_2 ) | $$$ first testcase distribute $$$ s_1 = \ { 10\ } $$$ $$$ s_2 = \ { <unknown> } $$$ value $$$ <unknown> - <unknown> = 0 $$$ second testcase distribute $$$ s_1 = \ { 0 11 <unknown> } $$$ $$$ s_2 = \ { <unknown> } $$$ value $$$ |0 + 11 - 1| - <unknown> = 10 - 2 = 8 $$$ third testcase distribute $$$ s_1 = \ { 2 3 2\ } $$$ $$$ s_2 = \ { \ } $$$ value $$$ |2 + 3 + 2| - |0| = 7 $$$ fourth testcase distribute $$$ s_1 = \ { -9 -4 0\ } $$$ $$$ s_2 = \ { 2 0\ } $$$ value $$$ <unknown> - 4 + 0| - |2 + 0| = 13 - 2 = 11 $$$,['greedy'],800.0
1748/B,a non - empty digit string diverse number occurrences character n't exceed number distinct character example : give a string $$$ s $$$ length $$$ n $$$ consist digits $$$ 0 $$$ $$$ 9 $$$ find many $$$ \frac { n ( n+1 ) } { 2 } $$$ substrings diverse a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end note diverse string appear $$$ s $$$ multiple time occurrence count independently example two diverse substrings ` ` 77 '' equal ` ` 7 '' answer string ` ` 77 '' $$$ 2 $$$ test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length string $$$ s $$$ second line test case contain a string $$$ s $$$ length $$$ n $$$ guarantee character $$$ s $$$ digits $$$ 0 $$$ $$$ 9 $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print one integer — number diverse substrings give string $$$ s $$$ first test case diverse substring ` ` 7 '' second test case diverse substring ` ` 7 '' appear twice answer $$$ 2 $$$ third test case diverse substrings ` ` 0 '' ( $$$ 2 $$$ time ) ` ` 01 '' ` ` 010 '' ` ` 1 '' ( $$$ 2 $$$ time ) ` ` 10 '' ( $$$ 2 $$$ time ) ` ` 101 '' ` ` 1010 '' fourth test case diverse substrings ` ` 0 '' ( $$$ 3 $$$ time ) ` ` 01 '' ` ` 011 '' ` ` 0110 '' ` ` 1 '' ( $$$ 2 $$$ time ) ` ` 10 '' ` ` 100 '' ` ` 110 '' ` ` 1100 '' fifth test case diverse substrings ` ` 3 '' ` ` 39 '' ` ` <unknown> '' ` ` 6 '' ` ` 9 '' ( $$$ 4 $$$ time ) ` ` 96 '' ` ` <unknown> '' sixth test case $$$ 15 $$$ non - empty substrings ` ` <unknown> '' diverse,['implementation'],1400.0
1748/D,give three integers $$$ a $$$ $$$ b $$$ $$$ d $$$ task find integer $$$ x $$$ satisfy follow condition determine integers exist : $$$ | $$$ denote bitwise operation test contain multiple test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist one line contain three integers $$$ a $$$ $$$ b $$$ $$$ d $$$ ( $$$ 1 \le a b d \lt 2^ { 30 } $$$ ) test case print one integer exist integer $$$ x $$$ satisfy condition statement print $$$ x $$$ otherwise print $$$ -1 $$$ multiple solutions may print first test case $$$ <unknown> $$$ one possible solutions since $$$ <unknown> $$$ $$$ <unknown> $$$ multiples $$$ <unknown> $$$ second test case $$$ <unknown> $$$ one possible solutions since $$$ <unknown> $$$ a multiple $$$ <unknown> $$$ third fourth test case show solutions,['math'],2100.0
175/F,"vasya play a popular game gnomes might magic game vasya manage kingdom gnomes consist several castle connect bidirectional roads kingdom road network a special form kingdom m main castle a1 a2 ... , form good path path consist roads castle ai ai + 1 ( 1 ≤ i < m ) well road a1 roads castle good path addition pair neighbor good path castle u v exactly one evil shortcut — a path go along roads lead first castle ( u ) second one ( v ) common vertexes good path except vertexes u v. know roads castle kingdom , every road every castle lie either good path evil shortcut ( castle lie ) addition two evil shortcuts common castle different castle good path begin week kingdom appear one bad gnome stand one roads kingdom begin rob corovans go road one road may accumulate multiple bad gnomes vasya care corovans sometimes send mission death one castle another let 's suggest mission death get castle s castle t. move castle s castle t destroy bad gnomes roads mission 's path vasya tough mission death destroy number gnomes way however vasya kind always choose path castle s t follow destroy smallest number gnomes multiple paths vasya choose path contain smallest number roads among multiple paths still vasya choose lexicographically minimal one among help vasya simulate life kingdom gnomes might magic game a path a sequence castle pair neighbor castle path connect a road also path x1 x2 ... xp lexicographically less path y1 y2 ... yq either p < q x1 = y1 x2 = y2 ... xp = yp exist number r ( r < p r < q ) x1 = y1 x2 = y2 ... xr = yr xr + 1 < yr + 1 . first line contain two integers n m ( 3 ≤ m ≤ n ≤ 100000 ) — number castle kingdom number castle good path respectively second line contain m integers number good path castle ( castle number 1 n ) order occurrence path start castle good path castle different follow m line describe evil shortcut first a line contain integer ki ( 3 ≤ ki ≤ 100000 ) — number castle correspond evil shortcut ( two castle good path ) follow a ki integers — number castle order occurrence give shortcut castle one evil shortcut different guarantee first last castle shortcut good path first castle evil shortcuts form good path present order path represent second line next line contain integer q ( 1 ≤ q ≤ 100000 ) — number events life kingdom follow q line describe a single event event describe symbol cj two number castle sj tj ( character number castle separate a single space ) character cj equal ` ` + '' ( a plus ) mean a bad gnome ( probably first one ) appear road castle sj tj cj equal ` ` ? '' ( a question ) vasya send a mission death castle sj castle tj guarantee request ` ` + '' road castle sj tj exist events give chronological order start earliest one initially bad gnomes roads number line separate single space guarantee give evil shortcuts good path fit limitations give problem statement query ` ` ? '' print a single number a single line — number bad gnomes destroy correspond mission death print answer query chronological order example first four request one path castle 1 castle 2 contain roads bad gnomes : 1 6 3 5 2 . a gnome stand road ( 2 5 ) next mission death move along path 1 2 destroy gnome road ( 1 2 ) next mission death follow path already free gnomes yet another gnome stand road ( 1 2 ) next mission death go path 1 2 kill gnome","['data structures', 'implementation']",3000.0
1750/A,"give a permutation $$$ a_1 a_2 \ldots a_n $$$ size $$$ n $$$ integer $$$ 1 $$$ $$$ n $$$ appear exactly follow operation number time ( possibly zero ) : determine whether make array $$$ a $$$ sort non - descending order test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 10 $$$ ) — length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ $$$ a_i \neq a_j $$$ $$$ i \neq j $$$ ) — elements array $$$ a $$$ test case output ` ` yes '' ( without quote ) array sort non - descending order ` ` '' ( without quote ) otherwise output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first test case $$$ [ 1,2,3 ] $$$ already sort non - descending order second test case choose $$$ i = 1 j = 2 k = 3 $$$ since $$$ a_1 \le a_3 $$$ swap $$$ a_2 $$$ $$$ a_3 $$$ array become $$$ [ 1,2,3 ] $$$ sort non - descending order seventh test case follow operations successively : third fourth fifth sixth test case show array sort non - descending order","['implementation', 'math']",800.0
1750/D,"give two integers $$$ n $$$ $$$ m $$$ array $$$ a $$$ $$$ n $$$ integers $$$ 1 \le i \le n $$$ hold $$$ 1 \le a_i \le m $$$ task count number different array $$$ b $$$ length $$$ n $$$ : $$$ \gcd ( a_1 a_2 \dots a_i ) $$$ denote greatest common divisor ( gcd ) integers $$$ a_1 a_2 \ldots a_i $$$ since number large print modulo $$$ 998\,244\,353 $$$ test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le m \le 1000000000 $$$ ) — length array $$$ a $$$ maximum possible value element second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le m $$$ ) — elements array $$$ a $$$ guarantee sum $$$ n $$$ across test case n't exceed $$$ 200000 $$$ test case print a single integer — number different array satisfy condition since number large print modulo $$$ 998\,244\,353 $$$ first test case possible array $$$ b $$$ : second test case array satisfy demand $$$ [ 1,1 ] $$$ third test case prove array exist",['math'],1800.0
1759/C,vlad come home find someone <unknown> old thermostat temperature $$$ a $$$ thermostat set a temperature $$$ l $$$ $$$ r $$$ inclusive temperature change less $$$ x $$$ formally one operation <unknown> thermostat temperature $$$ a $$$ temperature $$$ b $$$ $$$ |a - b| \ge x $$$ $$$ l \le b \le r $$$ give $$$ l $$$ $$$ r $$$ $$$ x $$$ $$$ a $$$ $$$ b $$$ find minimum number operations require get temperature $$$ b $$$ temperature $$$ a $$$ say impossible first line input data contain single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test descriptions test case follow first line case contain three integers $$$ l $$$ $$$ r $$$ $$$ x $$$ ( $$$ -1000000000 \le l \le r \le 1000000000 $$$ $$$ 1 \le x \le 1000000000 $$$ ) — range temperature minimum temperature change second line case contain two integers $$$ a $$$ $$$ b $$$ ( $$$ l \le a b \le r $$$ ) — initial final temperatures output $$$ t $$$ number answer correspond test case impossible achieve temperature $$$ b $$$ output -1 otherwise output minimum number operations first example thermostat already set correctly second example achieve desire temperature follow : $$$ 4 \rightarrow 10 \rightarrow 5 $$$ third example achieve desire temperature follow : $$$ 3 \rightarrow 8 \rightarrow 2 \rightarrow 7 $$$ fourth test impossible make operation,"['greedy', 'math']",1100.0
1760/C,"$$$ n $$$ participants a competition participant $$$ i $$$ a strength $$$ s_i $$$ every participant wonder much advantage best participant word participant $$$ i $$$ want know difference $$$ s_i $$$ $$$ s_j $$$ $$$ j $$$ strongest participant competition count $$$ i $$$ ( a difference negative ) , ask help ! $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) output difference $$$ s_i $$$ maximum strength participant participant $$$ i $$$ input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case descriptions test case follow first line test case contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 2\cdot100000 $$$ ) — length array follow line contain $$$ n $$$ space - separated positive integers $$$ s_1 $$$ $$$ s_2 $$$ ... $$$ s_n $$$ ( $$$ 1 \leq s_i \leq 1000000000 $$$ ) — strengths participants guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ test case output $$$ n $$$ space - separated integers $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) output difference $$$ s_i $$$ maximum strength participant first test case :","['data structures', 'implementation']",800.0
1760/D,give array $$$ a [ 0 \dots n-1 ] $$$ $$$ n $$$ integers array call a ` ` valley '' exist exactly one subarray $$$ a [ l \dots r ] $$$ : three examples : first image show array [ $$$ 3 2 2 1 2 2 3 $$$ ] a valley subarray indices $$$ l = r=3 $$$ satisfy condition second image show array [ $$$ 1 1 1 2 3 3 4 5 6 6 6 $$$ ] a valley subarray indices $$$ <unknown> r=2 $$$ satisfy <unknown> third image show array [ $$$ 1 2 3 4 3 2 1 $$$ ] a valley two subarrays $$$ l = r=0 $$$ $$$ l = r=6 $$$ satisfy condition ask whether give array a valley note consider array index $$$ 0 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 2\cdot100000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — elements array guarantee sum $$$ n $$$ test case smaller $$$ 2\cdot100000 $$$ test case output ` ` yes '' ( without quote ) array a valley ` ` '' ( without quote ) otherwise output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ) first three test case explain statement,['implementation'],1000.0
1761/F1,easy version problem difference two versions constraint $$$ n $$$ make hack versions problem solve let 's call array $$$ a $$$ odd length $$$ 2m+1 $$$ ( $$$ m \ge 1 $$$ ) bad element $$$ a _ { m+1 } $$$ equal median array word array bad sort element $$$ m+1 $$$ -st position remain let 's call a permutation $$$ p $$$ integers $$$ 1 $$$ $$$ n $$$ anti - median every subarray odd length $$$ \ge 3 $$$ bad already give value elements permutation find number ways set unknown value obtain anti - median permutation number large find modulo $$$ 1000000000 + 7 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 2 \le n \le 1000 ) $$$ — length permutation second line test case contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i = -1 $$$ ) — elements permutation $$$ p_i \neq -1 $$$ 's give else 's unknown 's guarantee $$$ i \neq j $$$ hold $$$ p_i \neq -1 p_j \neq -1 $$$ $$$ p_i \neq p_j $$$ guarantee sum $$$ n^2 $$$ test case exceed $$$ 1000000 $$$ test case output a single integer — number ways set unknown value obtain anti - median permutation modulo $$$ 1000000000 + 7 $$$ first test case $$$ [ 1 2 ] $$$ $$$ [ 2 1 ] $$$ anti - median second test case permutations $$$ [ 1 3 2 ] [ 2 1 3 ] [ 2 3 1 ] [ 3 1 2 ] $$$ anti - median remain two permutations $$$ [ 1 2 3 ] $$$ $$$ [ 3 2 1 ] $$$ bad array median $$$ 2 $$$ middle third test case $$$ [ 1 2 3 4 ] $$$ n't anti - median contain bad subarray $$$ [ 1 2 3 ] $$$ fourth test case anti - median array get $$$ [ 5 6 3 4 1 2 ] $$$,"['dp', 'math']",3100.0
1761/F2,hard version problem difference two versions constraint $$$ n $$$ make hack versions problem solve let 's call array $$$ a $$$ odd length $$$ 2m+1 $$$ ( $$$ m \ge 1 $$$ ) bad element $$$ a _ { m+1 } $$$ equal median array word array bad sort element $$$ m+1 $$$ -st position remain let 's call a permutation $$$ p $$$ integers $$$ 1 $$$ $$$ n $$$ anti - median every subarray odd length $$$ \ge 3 $$$ bad already give value elements permutation find number ways set unknown value obtain anti - median permutation number large find modulo $$$ 1000000000 + 7 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 2 \le n \le 1000000 ) $$$ — length permutation second line test case contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ $$$ p_i = -1 $$$ ) — elements permutation $$$ p_i \neq -1 $$$ 's give else 's unknown 's guarantee $$$ i \neq j $$$ hold $$$ p_i \neq -1 p_j \neq -1 $$$ $$$ p_i \neq p_j $$$ guarantee sum $$$ n $$$ test case exceed $$$ 1000000 $$$ test case output a single integer — number ways set unknown value obtain anti - median permutation modulo $$$ 1000000000 + 7 $$$ first test case $$$ [ 1 2 ] $$$ $$$ [ 2 1 ] $$$ anti - median second test case permutations $$$ [ 1 3 2 ] [ 2 1 3 ] [ 2 3 1 ] [ 3 1 2 ] $$$ anti - median remain two permutations $$$ [ 1 2 3 ] $$$ $$$ [ 3 2 1 ] $$$ bad array median $$$ 2 $$$ middle third test case $$$ [ 1 2 3 4 ] $$$ n't anti - median contain bad subarray $$$ [ 1 2 3 ] $$$ fourth test case anti - median array get $$$ [ 5 6 3 4 1 2 ] $$$,"['dp', 'math']",3500.0
1763/E,let 's call order pair nod $$$ ( u v ) $$$ a direct graph unidirectional $$$ u \neq v $$$ exist a path $$$ u $$$ $$$ v $$$ paths $$$ v $$$ $$$ u $$$ a direct graph call $$$ p $$$ -reachable contain exactly $$$ p $$$ order pair nod $$$ ( u v ) $$$ $$$ u < v $$$ $$$ u $$$ $$$ v $$$ reachable find minimum number nod require create a $$$ p $$$ -reachable direct graph also among $$$ p $$$ -reachable direct graph minimum number nod let $$$ g $$$ denote a graph maximize number unidirectional pair nod find number first line contain a single integer $$$ p $$$ ( $$$ 0 \le p \le 200000 $$$ ) — number order pair nod print a single line contain two integers — minimum number nod require create a $$$ p $$$ -reachable direct graph maximum number unidirectional pair nod among $$$ p $$$ -reachable direct graph minimum number nod first test case minimum number nod require create a $$$ 3 $$$ -reachable direct graph $$$ 3 $$$ among $$$ 3 $$$ -reachable direct graph $$$ 3 $$$ nod follow graph $$$ g $$$ one graph maximum number unidirectional pair nod $$$ 0 $$$,"['dp', 'math']",2200.0
1764/H,doremy $$$ n $$$ bucket paint represent array $$$ a $$$ length $$$ n $$$ bucket $$$ i $$$ contain paint color $$$ a_i $$$ initially $$$ a_i = i $$$ doremy $$$ m $$$ segment $$$ [ l_i r_i ] $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) segment describe operation operation $$$ i $$$ perform follow : doremy also select integer $$$ k $$$ want know integer $$$ x $$$ $$$ 0 $$$ $$$ m-1 $$$ number distinct color array perform operations $$$ x \bmod m +1 ( x+1 ) \bmod m + 1 \ldots ( x+k-1 ) \bmod m +1 $$$ help calculate value ? note $$$ x $$$ individually start initial array perform give $$$ k $$$ operations give order first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1\le n m\le 2\cdot 100000 $$$ $$$ 1 \le k \le m $$$ ) — length array $$$ a $$$ total number operations integer doremy select $$$ i $$$ -th line follow $$$ m $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1\le l_i\le r_i\le n $$$ ) — bound $$$ i $$$ -th segment output $$$ m $$$ integers $$$ ( x+1 ) $$$ -th integer number distinct color array start initial array perform operations $$$ x \bmod m +1 ( x+1 ) \bmod m + 1 \ldots ( x+k-1 ) \bmod m +1 $$$ first test case picture show result array value $$$ <unknown> $$$ respectively,['data structures'],3400.0
1768/A,give integer $$$ k $$$ find largest integer $$$ x $$$ $$$ 1 \le x < k $$$ $$$ x ! + ( x - 1 ) ! ^\dagger $$$ a multiple $$$ ^\ddagger $$$ $$$ k $$$ determine $$$ x $$$ exist $$$ ^\dagger $$$ $$$ y ! $$$ denote factorial $$$ y $$$ define recursively $$$ y ! = y \cdot ( y-1 ) ! $$$ $$$ y \geq 1 $$$ base case $$$ 0 ! = 1 $$$ example $$$ 5 ! = 20 \cdot 6 \cdot 1 \cdot 0 ! = 120 $$$ $$$ ^\ddagger $$$ $$$ a $$$ $$$ b $$$ integers $$$ a $$$ a multiple $$$ b $$$ exist integer $$$ c $$$ $$$ a = b \cdot c $$$ example $$$ 10 $$$ a multiple $$$ 5 $$$ $$$ 9 $$$ a multiple $$$ 6 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow line test case contain a single integer $$$ k $$$ ( $$$ 2 \le k \le 1000000000 $$$ ) test case output a single integer — largest possible integer $$$ x $$$ satisfy condition $$$ x $$$ exist output $$$ -1 $$$ first test case $$$ 2 ! + 1 ! = 2 + 1 = 3 $$$ a multiple $$$ 3 $$$ third test case $$$ 7 ! + 6 ! = 5040 + 720 = <unknown> $$$ a multiple $$$ 8 $$$,"['greedy', 'math']",800.0
1768/B,"give a permutation $$$ ^\dagger $$$ $$$ p $$$ length $$$ n $$$ a positive integer $$$ k \le n $$$ one operation : example $$$ p = [ <unknown> ] $$$ $$$ k = 2 $$$ choose $$$ 5 $$$ $$$ 3 $$$ elements operation $$$ [ 2 \color { red } { 5 } 1 \color { red } { 3 } 4 ] \rightarrow [ 2 1 4 \color { red } { 3 } \color { red } { 5 } ] $$$ find minimum number operations need sort permutation increase order prove always possible $$$ ^\dagger $$$ a permutation length $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 100000 $$$ $$$ 1 \le k \le n $$$ ) second line test case contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) guarantee $$$ p $$$ a permutation guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output a single integer — minimum number operations need sort permutation prove always possible first test case permutation already sort second test case choose element $$$ 3 $$$ permutation become sort follow : $$$ [ \color { red } { 3 } 1 2 ] \rightarrow [ 1 2 \color { red } { 3 } ] $$$ third test case choose elements $$$ 3 $$$ $$$ 4 $$$ permutation become sort follow : $$$ [ 1 \color { red } { 3 } 2 \color { red } { 4 } ] \rightarrow [ 1 2 \color { red } { 3 } \color { red } { 4 } ] $$$ fourth test case show impossible sort permutation $$$ 1 $$$ operation however choose elements $$$ 2 $$$ $$$ 1 $$$ first operation choose elements $$$ 3 $$$ $$$ 4 $$$ second operation permutation become sort follow : $$$ [ \color { red } { 2 } 3 \color { red } { 1 } 4 ] \rightarrow [ \color { blue } { 3 } \color { blue } { 4 } \color { red } { 1 } \color { red } { 2 } ] \rightarrow [ 1,2 \color { blue } { 3 } \color { blue } { 4 } ] $$$","['greedy', 'math']",900.0
1768/E,"consider a permutation $$$ ^\dagger $$$ $$$ p $$$ length $$$ 3n $$$ time one follow operations : show every permutation make sort increase order use operations let 's call $$$ f ( p ) $$$ minimum number operations need make permutation $$$ p $$$ sort increase order give $$$ n $$$ find sum $$$ f ( p ) $$$ $$$ ( 3n ) ! $$$ permutations $$$ p $$$ size $$$ 3n $$$ since answer could large output modulo a prime $$$ m $$$ $$$ ^\dagger $$$ a permutation length $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) line input contain two number $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 1000000 $$$ $$$ 100000000 \leq m \leq 1000000000 $$$ ) guarantee $$$ m $$$ a prime number output answer modulo $$$ m $$$ first test case permutations : therefore answer $$$ 0 + 1 + 1 + 2 + 2 + 3=9 $$$",['math'],2300.0
1769/A,<unknown> из $$$ n $$$ самокатов едет по <unknown> <unknown> <unknown> в <unknown> б . самокаты <unknown> от $$$ 1 $$$ до $$$ n $$$ для каждого самоката $$$ i $$$ известно что текущее расстояние от него до пункта б равно $$$ a_i $$$ метров при этом $$$ a_1 < a_2 < \ldots < a_n $$$ в частности самокат $$$ 1 $$$ находится ближе всего к пункту б а самокат $$$ n $$$ — дальше всего самокат с номером $$$ i $$$ <unknown> в сторону пункта б со скоростью $$$ i $$$ метров в секунду ( то есть чем ближе самокат в колонне к пункту б тем <unknown> он едет ) так как <unknown> <unknown> самокаты не могут <unknown> друг друга более того <unknown> самокаты в колонне <unknown> <unknown> <unknown> хотя бы в $$$ 1 $$$ метр поэтому <unknown> более <unknown> самокат <unknown> более <unknown> более <unknown> <unknown> дальше ехать со скоростью более медленного <unknown> на расстоянии в $$$ 1 $$$ метр от него определите на <unknown> расстоянии до пункта б будет каждый самокат ровно через одну секунду в первой строке задано одно целое число $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — число самокатов в колонне в $$$ i $$$ -й из следующих $$$ n $$$ строк задано одно целое число $$$ a_i $$$ ( $$$ 1 \le a_i \le 1000 $$$ ; $$$ a_1 < a_2 < \ldots < a_n $$$ ) — текущее расстояние от самоката $$$ i $$$ до пункта б в метрах выведите $$$ n $$$ целых чисел — <unknown> от самокатов $$$ 1 2 \ldots n $$$ до пункта б в метрах через одну секунду в первом тесте самокаты <unknown> не <unknown> друг <unknown> ехать поэтому каждый самокат $$$ i $$$ <unknown> на $$$ i $$$ метров в сторону пункта б . во втором тесте самокаты уже <unknown> в колонне на расстоянии $$$ 1 $$$ метр друг от друга и <unknown> ехать со скоростью самого медленного самоката с номером $$$ 1 $$$,['math'],800.0
1769/B1,в этой версии задачи размеры копируемых файлов не превышают $$$ 1000 $$$ байт вы копируете с одного сервера на другой $$$ n $$$ файлов размером $$$ a_1 a_2 \ldots a_n $$$ байт файлы копируются последовательно в заданном порядке при копировании вы видите два прогресс - бара : первый показывает процент скопированных данных в текущем файле а второй — общий процент скопированных данных по всем $$$ n $$$ файлам оба процента отображаются округлёнными вниз до целого числа значения на прогресс - барах обновляются после копирования каждого байта формально после копирования байта номер $$$ x $$$ из файла номер $$$ i $$$ первый прогресс - бар показывает $$$ \lfloor \frac { 100 \cdot x } { a_i } \rfloor $$$ процентов а второй — $$$ \lfloor \frac { 100 \cdot ( a_1 + a_2 + \ldots + a _ { i - 1 } + x ) } { a_1 + a_2 + \ldots + a_n } \rfloor $$$ процентов в самом начале копирования оба прогресс - бара показывают $$$ 0 $$$ процентов найдите все такие целые числа от $$$ 0 $$$ до $$$ 100 $$$ включительно что существует момент времени в который оба прогресс - бара одновременно показывают это число выведите эти числа в порядке возрастания в первой строке задано одно целое число $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — число копируемых файлов во второй строке заданы $$$ n $$$ целых чисел $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000 $$$ ) — размеры файлов в байтах в том порядке в котором они будут копироваться выведите в возрастающем порядке все числа от $$$ 0 $$$ до $$$ 100 $$$ включительно такие что существует момент времени в который на обоих прогресс - барах одновременно показывается это число в первом тесте копируется всего один файл поэтому оба прогресс - бара всегда показывают одинаковые значения во втором тесте первый прогресс - бар сразу же уйдёт вперёд потом сбросится в ноль и начнёт догонять второй прогресс - бар заново в конце копирования прогресс - бары некоторое время будут показывать одно и то же число,"['implementation', 'math']",1000.0
1769/B2,в этой версии задачи размеры копируемых файлов не превышают $$$ 10^ { 10 } $$$ байт вы копируете с одного сервера на другой $$$ n $$$ файлов размером $$$ a_1 a_2 \ldots a_n $$$ байт файлы копируются последовательно в заданном порядке при копировании вы видите два прогресс - бара : первый показывает процент скопированных данных в текущем файле а второй — общий процент скопированных данных по всем $$$ n $$$ файлам оба процента отображаются округлёнными вниз до целого числа значения на прогресс - барах обновляются после копирования каждого байта формально после копирования байта номер $$$ x $$$ из файла номер $$$ i $$$ первый прогресс - бар показывает $$$ \lfloor \frac { 100 \cdot x } { a_i } \rfloor $$$ процентов а второй — $$$ \lfloor \frac { 100 \cdot ( a_1 + a_2 + \ldots + a _ { i - 1 } + x ) } { a_1 + a_2 + \ldots + a_n } \rfloor $$$ процентов в самом начале копирования оба прогресс - бара показывают $$$ 0 $$$ процентов найдите все такие целые числа от $$$ 0 $$$ до $$$ 100 $$$ включительно что существует момент времени в который оба прогресс - бара одновременно показывают это число выведите эти числа в порядке возрастания в первой строке задано одно целое число $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — число копируемых файлов во второй строке заданы $$$ n $$$ целых чисел $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 10^ { 10 } $$$ ) — размеры файлов в байтах в том порядке в котором они будут копироваться выведите в возрастающем порядке все числа от $$$ 0 $$$ до $$$ 100 $$$ включительно такие что существует момент времени в который на обоих прогресс - барах одновременно показывается это число в первом тесте копируется всего один файл поэтому оба прогресс - бара всегда показывают одинаковые значения во втором тесте первый прогресс - бар сразу же уйдёт вперёд потом сбросится в ноль и начнёт догонять второй прогресс - бар заново в конце копирования прогресс - бары некоторое время будут показывать одно и то же число обратите внимание что <unknown> тест в этой версии задачи <unknown> от <unknown> теста в <unknown> версии задачи,['math'],1400.0
1769/D1,в этой версии задачи нужно определить кто выиграет в <unknown> игре для двух игроков в заданном <unknown> при оптимальной игре обоих <unknown> алиса и <unknown> <unknown> <unknown> в <unknown> <unknown> « девятка » <unknown> <unknown> <unknown> условие задачи <unknown> <unknown> могут <unknown> от <unknown> вам для игры <unknown> <unknown> колода из $$$ 36 $$$ карт — по <unknown> карт ( от <unknown> до туза ) <unknown> из <unknown> <unknown> ( трефы бубны пики и черви ) карты по <unknown> от <unknown> к <unknown> идут следующим образом : <unknown> <unknown> <unknown> девятка <unknown> <unknown> <unknown> <unknown> <unknown> перед <unknown> колода <unknown> и <unknown> <unknown> <unknown> по $$$ 18 $$$ карт карты нужно <unknown> из руки на стол по <unknown> правилам <unknown> игрок который первым <unknown> все карты из своей руки игроки <unknown> по <unknown> ход игрока <unknown> один из следующих <unknown> : например девятку <unknown> можно выложить на стол в <unknown> момент для выкладывания <unknown> треф необходимо наличие на столе <unknown> треф а для выкладывания туза червей необходимо наличие на столе короля червей если игрок не может выложить на стол ни одну карту из своей руки то ход <unknown> к <unknown> обратите внимание : <unknown> <unknown> ход <unknown> так — всегда необходимо выложить карту на стол <unknown> образом если это <unknown> вам <unknown> <unknown> карт в начале игры алиса будет ходить первой определите кто первым <unknown> от всех <unknown> карт и выиграет если оба игрока будут <unknown> <unknown> и <unknown> <unknown> в первой строке задано $$$ 18 $$$ строк длины $$$ 2 $$$ через пробел описывающих карты <unknown> в <unknown> порядке первый символ строки обозначает <unknown> карты — символ из набора 6 7 8 9 t j q k a обозначающий <unknown> <unknown> <unknown> девятку <unknown> <unknown> <unknown> короля и туза соответственно второй символ строки обозначает <unknown> карты — символ из набора c d s h обозначающий трефы бубны пики и черви соответственно во второй строке задано $$$ 18 $$$ строк длины $$$ 2 $$$ через пробел описывающих карты <unknown> в том же формате <unknown> из $$$ 36 $$$ возможных карт находится в <unknown> одного из двух игроков в <unknown> <unknown> в <unknown> $$$ 100 $$$ <unknown> все <unknown> <unknown> <unknown> образом выведите alice если при оптимальной игре выиграет алиса и bob в противном случае,['dp'],1800.0
1771/E,hossam buy a new piece grind length $$$ n $$$ width $$$ m $$$ divide $$$ n \cdot m $$$ grid cell size $$$ 1\times1 $$$ since hossam 's name start letter ' h ' decide draw capital letter ' h ' build wall size $$$ 1\times1 $$$ square grind square $$$ 1\times1 $$$ grind assign a quality degree : perfect medium bad process build wall form letter ' h ' follow constraints : find maximum number wall use draw letter ' h ' check note clarification first line input contain two integer number $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 400 $$$ ) next $$$ n $$$ line input contain $$$ m $$$ character describe grid character ' . ' stand a perfect square character ' m ' stand a medium square character ' # ' stand a bad square print a single integer — maximum number wall form a capital letter ' h ' possible draw letter ' h ' print $$$ 0 $$$ first test case ca n't build letter ' h ' second test case figure represent grid valid letter ' h ' perfect medium bad square represent white yellow black color respectively,"['dp', 'implementation']",2500.0
1772/C,array $$$ a $$$ consist $$$ k $$$ integers strictly increase $$$ a_1 < a_2 < \dots < a_k $$$ example array $$$ [ 1 3 5 ] $$$ $$$ [ 1 2 3 4 ] $$$ $$$ [ 3 5 6 ] $$$ strictly increase ; array $$$ [ 2 2 ] $$$ $$$ [ 3 7 5 ] $$$ $$$ [ 7 4 3 ] $$$ $$$ [ 1 2 2 3 ] $$$ a strictly increase array $$$ a $$$ $$$ k $$$ elements let 's denote characteristic number different elements array $$$ [ a_2 - a_1 a_3 - a_2 \dots a_k - a _ { k-1 } ] $$$ example characteristic array $$$ [ 1 3 4 7 8 ] $$$ $$$ 3 $$$ since array $$$ [ 2 1 3 1 ] $$$ contain $$$ 3 $$$ different elements : $$$ 2 $$$ $$$ 1 $$$ $$$ 3 $$$ give two integers $$$ k $$$ $$$ n $$$ ( $$$ k \le n $$$ ) construct increase array $$$ k $$$ integers $$$ 1 $$$ $$$ n $$$ maximum possible characteristic first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le <unknown> $$$ ) — number test case test case consist one line contain two integers $$$ k $$$ $$$ n $$$ ( $$$ 2 \le k \le n \le 40 $$$ ) test case print $$$ k $$$ integers — elements strictly increase array $$$ a $$$ maximum possible characteristic multiple answer print,"['greedy', 'math']",1000.0
1772/D,give array $$$ a $$$ consist $$$ n $$$ integers array sort $$$ a_1 \le a_2 \le \dots \le a_n $$$ want make array $$$ a $$$ sort apply follow operation exactly : find value $$$ x $$$ make array sort report value first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case test case consist two line first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100000000 $$$ ) additional constraint input : sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print integer $$$ x $$$ ( $$$ 0 \le x \le 1000000000 $$$ ) make array sort show integer $$$ x $$$ exist least one integer $$$ 0 $$$ $$$ 1000000000 $$$ integer print $$$ -1 $$$ multiple suitable value $$$ x $$$ print first test case use $$$ x = 4 $$$ array become $$$ [ 1 1 1 1 1 ] $$$ third test case use $$$ x = 0 $$$ array become $$$ [ 1 2 3 4 5 6 7 8 ] $$$ fourth test case use $$$ x = 42 $$$ array become $$$ [ 32 37 38 39 40 41 ] $$$,['math'],1400.0
1774/A,"aquamoon a string $$$ a $$$ consist $$$ 0 $$$ $$$ 1 $$$ want add $$$ + $$$ $$$ - $$$ pair consecutive position make absolute value result expression small possible help ? first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 2\,000 $$$ ) – number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) — length $$$ a $$$ second line test case contain a string $$$ a $$$ length $$$ n $$$ consist $$$ 0 $$$ $$$ 1 $$$ test case output a string length $$$ n - 1 $$$ consist $$$ - $$$ $$$ + $$$ a separate line one assignment sign produce smallest possible absolute value accept first test case get expression $$$ 1 - 1 = 0 $$$ absolute value $$$ 0 $$$ second test case get expression $$$ 0 + 1 - 1 + 0 + 1 = 1 $$$ absolute value $$$ 1 $$$ third test case get expression $$$ 1 + 0 + 0 + 0 - 1 = 0 $$$ absolute value $$$ 0 $$$",['math'],800.0
1774/C,"little09 friends play a game $$$ n $$$ players temperature value player $$$ i $$$ $$$ i $$$ type environment express $$$ 0 $$$ $$$ 1 $$$ two players fight a specific environment type $$$ 0 $$$ player a lower temperature value environment always win ; $$$ 1 $$$ player a higher temperature value environment always win type $$$ n-1 $$$ environments form a binary string $$$ s $$$ a length $$$ n-1 $$$ $$$ x $$$ players participate game a total $$$ x-1 $$$ battle type $$$ x-1 $$$ environments first $$$ x-1 $$$ character $$$ s $$$ one player leave tournament choose two remain players fight player lose eliminate tournament type environment battle $$$ i $$$ $$$ s_i $$$ $$$ x $$$ $$$ 2 $$$ $$$ n $$$ answer follow question : players whose temperature value exceed $$$ x $$$ participate game many players a chance win ? test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\le t \le 1000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2\leq n\leq 2\cdot 100000 $$$ ) — number players second line test case contain a binary string $$$ s $$$ a length $$$ n-1 $$$ guarantee sum $$$ n $$$ test case exceed $$$ 3\cdot 100000 $$$ test case output $$$ n-1 $$$ integers — $$$ x $$$ $$$ 2 $$$ $$$ n $$$ output number players a chance win first test case $$$ x=2 $$$ $$$ x=3 $$$ player whose temperature value $$$ 1 $$$ winner $$$ x=4 $$$ player whose temperature value $$$ 2,3,4 $$$ winner","['dp', 'greedy']",1300.0
1774/E,"<unknown> a tree $$$ n $$$ nod will share mean operate initially two chess piece node $$$ 1 $$$ tree one step choose piece move neighbor node also give integer $$$ d $$$ need ensure distance two piece n't ever exceed $$$ d $$$ two piece a sequence nod need pass order eventually return root a curious boy want know minimum step need take first line contain two integers $$$ n $$$ $$$ d $$$ ( $$$ 2 \le d \le n \le 2\cdot 100000 $$$ ) $$$ i $$$ -th follow $$$ n - 1 $$$ line contain two integers $$$ u_i v_i $$$ $$$ ( 1 \le u_i v_i \le n ) $$$ denote edge nod $$$ u_i v_i $$$ tree 's guarantee edge form a tree next line contain integer $$$ m_1 $$$ ( $$$ 1 \le m_1 \le n $$$ ) $$$ m_1 $$$ integers $$$ a_1 a_2 \ldots a _ { m_1 } $$$ ( $$$ 1 \le a_i \le n $$$ $$$ a_i $$$ distinct ) — sequence nod first piece need pass second line contain integer $$$ m_2 $$$ ( $$$ 1 \le m_2 \le n $$$ ) $$$ m_2 $$$ integers $$$ b_1 b_2 \ldots b _ { m_2 } $$$ ( $$$ 1 \le b_i \le n $$$ $$$ b_i $$$ distinct ) — sequence nod second piece need pass output a single integer — minimum step need take first sample one possible sequence step length $$$ 6 $$$ second piece move route $$$ 1 \to 2 \to 4 \to 2 \to 1 $$$ , first piece move route $$$ 1 \to 3 \to 1 $$$ second sample one possible sequence step length $$$ 8 $$$ : first piece move route $$$ 1 \to 2 \to 3 $$$ , second piece move route $$$ 1 \to 2 $$$ , first piece move route $$$ 3 \to 4 \to 3 \to 2 \to 1 $$$ , second piece move route $$$ 2 \to 1 $$$","['dp', 'greedy']",1900.0
1774/F1,"easy version problem difference two versions constraint $$$ n $$$ $$$ x $$$ make hack versions problem solve little09 interest magic a long time 's lucky meet a magician ! magician perform $$$ n $$$ operations one follow three : a pig die health point less equal $$$ 0 $$$ little09 want know many live pig operations please print answer modulo $$$ 998\,244\,353 $$$ first line contain a single integer $$$ n $$$ ( $$$ 1\leq n\leq 2\cdot 100000 $$$ ) — number operations follow $$$ n $$$ line contain operation give form describe problem statement 's guarantee $$$ 1\leq x\leq 2\cdot 100000 $$$ operations first two type print a single integer — number live pig operations modulo $$$ 998\,244\,353 $$$ first example operations equivalent repeat four time : create a pig $$$ 8 $$$ health point reduce health point live pig $$$ 3 $$$ easy find two live pig end $$$ 2 $$$ $$$ 5 $$$ health point","['data structures', 'implementation']",2400.0
1774/G,"chthollynotaseniorious give datastructures a number axis $$$ m $$$ distinct segment let $$$ f ( l r ) $$$ number ways choose even number segment union exactly $$$ [ l r ] $$$ $$$ g ( l r ) $$$ number ways choose odd number segment union exactly $$$ [ l r ] $$$ chthollynotaseniorious ask datastructures $$$ q $$$ question query chthollynotaseniorious give datastructures two number $$$ l r $$$ wish help find value $$$ f ( l r ) -g ( l r ) $$$ modulo $$$ 998\,244\,353 $$$ would n't let first line input contain two integers $$$ m $$$ ( $$$ 1 \leq m \leq 200000 $$$ ) $$$ q $$$ ( $$$ 1 \leq q \leq 200000 $$$ ) — number segment query correspondingly $$$ i $$$ -th next $$$ m $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \leq x_i < y_i \leq 1000000000 $$$ ) denote a segment $$$ [ x_i y_i ] $$$ guarantee segment distinct formally exist two number $$$ i j $$$ $$$ 1 \le i < j \le m $$$ $$$ x_i = x_j $$$ $$$ y_i = y_j $$$ $$$ i $$$ -th next $$$ q $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \leq l_i < r_i \leq 1000000000 $$$ ) describe a query query output a single integer — $$$ f ( l_i r_i ) -g ( l_i r_i ) $$$ modulo $$$ 998\,244\,353 $$$ first query find $$$ f ( 1 4 ) - g ( 1 4 ) $$$ subset segment union $$$ [ 1 4 ] $$$ $$$ \ { [ 1 3 ] [ 2 4 ] \ } $$$ $$$ f ( 1 4 ) = 1 g ( 1 4 ) = 0 $$$ second query find $$$ f ( 1 5 ) - g ( 1 5 ) $$$ subsets segment union $$$ [ 1 5 ] $$$ $$$ \ { [ 1 3 ] [ 2 4 ] [ 3 5 ] \ } $$$ $$$ \ { [ 1 3 ] [ 3 5 ] \ } $$$ $$$ f ( 1 5 ) = 1 g ( 1 5 ) = 1 $$$","['data structures', 'dp']",3200.0
1775/A2,hard version problem difference versions string longer easy version hack versions problem pass kazimir kazimirovich a martian gardener a huge orchard binary balance apple tree recently casimir decide get three capybaras gardener even come name write a piece paper name capybara a non - empty line consist letter ` ` a '' ` ` b '' denote name capybaras line $$$ a $$$ $$$ b $$$ $$$ c $$$ casimir write nonempty line $$$ a $$$ $$$ b $$$ $$$ c $$$ a row without space example capybara 's name ` ` aba '' ` ` ab '' ` ` bb '' string gardener write would look like ` ` abaabbb '' gardener remember interest property : either string $$$ b $$$ lexicographically smaller string $$$ a $$$ $$$ c $$$ time string $$$ b $$$ lexicographically greater string $$$ a $$$ $$$ c $$$ time word either $$$ a \le b $$$ $$$ c \le b $$$ satisfy $$$ b \le a $$$ $$$ b \le c $$$ satisfy ( possibly condition simultaneously ) $$$ \le $$$ denote lexicographic ` ` less equal '' string thus $$$ a \le b $$$ mean string must either equal string $$$ a $$$ must stand earlier dictionary string $$$ b $$$ a detail explanation operation see ` ` note '' section today gardener look note realize recover name write without space longer sure recover original string $$$ a $$$ $$$ b $$$ $$$ c $$$ want find triplet name satisfy property test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow line a test case contain string $$$ s $$$ ( $$$ 3 \le |s| \le 200000 $$$ ) — name capybaras write together string consist english letter ' a ' ' b ' guarantee sum string lengths test case exceed $$$ 400000 $$$ test case print three string $$$ a $$$ $$$ b $$$ $$$ c $$$ a single line separate space — name capybaras write without space result a line $$$ s $$$ either $$$ a \le b $$$ $$$ c \le b $$$ $$$ b \le a $$$ $$$ b \le c $$$ must satisfy several ways restore name print name recover print ` ` : ( ` ` ( without quote ) a string $$$ x $$$ lexicographically smaller a string $$$ y $$$ one follow hold : let 's move examples first test case one possible ways split line $$$ s $$$ three line — is ` ` b '' ` ` bb '' ` ` a '' third test case see split satisfy two condition ( i.e. $$$ a \le b $$$ $$$ c \le b $$$ $$$ b \le a $$$ $$$ b \le c $$$ true simultaneously ),['greedy'],900.0
1776/N,"give a string $$$ s $$$ length $$$ n-1 $$$ whose character either $$$ \texttt { < } $$$ $$$ \texttt { > } $$$ count permutations $$$ p_1 \ p_2 \ \dots \ p_n $$$ $$$ 1 \ 2 \ \dots \ n $$$ $$$ i = 1 \ 2 \ \dots \ n - 1 $$$ $$$ s_i $$$ $$$ \texttt { < } $$$ $$$ p_i < p _ { i+1 } $$$ $$$ s_i $$$ $$$ \texttt { > } $$$ $$$ p_i > p _ { i+1 } $$$ since number large compute logarithm base $$$ 2 $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100\,000 $$$ ) second line contain a string $$$ s $$$ length $$$ n-1 $$$ ; character $$$ s $$$ either $$$ \texttt { < } $$$ $$$ \texttt { > } $$$ print logarithm base $$$ 2 $$$ number permutations satisfy constraints describe statement answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ x $$$ let correct answer $$$ y $$$ answer accept $$$ \frac { |x - y| } { \max { ( 1 |y| ) } } \le 10^ { -6 } $$$ first sample one valid permutation $$$ [ 2 1 ] $$$ since $$$ \log_2 ( 1 ) = 0 $$$ correct output $$$ 0 $$$ second sample $$$ 2 $$$ valid permutations $$$ [ 3 1 2 ] $$$ $$$ [ 2 1 3 ] $$$ since $$$ \log_2 ( 2 ) = 1 $$$ correct output $$$ 1 $$$ third sample $$$ 4 $$$ valid permutations $$$ [ 1 5 4 3 2 ] $$$ $$$ [ 2 5 4 3 1 ] $$$ $$$ [ 3 5 4 2 1 ] $$$ $$$ [ 4 5 3 2 1 ] $$$ since $$$ \log_2 ( 4 ) = 2 $$$ correct output $$$ 2 $$$ fourth sample $$$ 909 $$$ valid permutations notice $$$ \log_2 ( 909 ) = <unknown> $$$",['math'],3500.0
1778/D,"give two binary string $$$ a $$$ $$$ b $$$ length $$$ n $$$ move string $$$ a $$$ modify follow way expect number move require make string equal first time ? a binary string a string character either $$$ \tt { 0 } $$$ $$$ \tt { 1 } $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000000 $$$ ) — length string second line test case contain binary string $$$ a $$$ length $$$ n $$$ third line test case contain binary string $$$ b $$$ length $$$ n $$$ guarantee sum $$$ n $$$ test case exceed $$$ 1000000 $$$ test case output a single line contain expect number move modulo $$$ 998\,244\,353 $$$ formally let $$$ m = 998\,244\,353 $$$ show answer express irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \not \equiv 0 \pmod { m } $$$ output integer equal $$$ p \cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \le x < m $$$ $$$ x \cdot q \equiv p \pmod { m } $$$ first test case index $$$ 1 $$$ choose randomly $$$ a_1 $$$ flip move string $$$ a $$$ $$$ b $$$ equal expect number move $$$ 1 $$$ string $$$ a $$$ $$$ b $$$ already equal second test case , expect number move $$$ 0 $$$ expect number move third fourth test case $$$ \frac { 56 } { 3 } $$$ $$$ \frac { 125 } { 3 } $$$ respectively","['dp', 'math']",2100.0
1778/F,"give a root tree consist $$$ n $$$ vertices number $$$ 1 $$$ $$$ n $$$ vertex $$$ 1 $$$ root tree vertex integer value value $$$ i $$$ -th vertex $$$ a_i $$$ follow operation $$$ k $$$ time maximum possible value root node $$$ 1 $$$ $$$ k $$$ operations ? formally maximize value $$$ a_1 $$$ a tree a connect undirected graph without cycle a root tree a tree a select vertex call root subtree a node $$$ u $$$ set nod $$$ y $$$ simple path $$$ y $$$ root pass $$$ u $$$ note $$$ u $$$ subtree $$$ u $$$ first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 50\,000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \leq n \leq 100000 $$$ $$$ 0 \leq k \leq n $$$ ) — number vertices tree number operations second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000 $$$ ) $$$ a_i $$$ denote value vertex $$$ i $$$ next $$$ n - 1 $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ u_i \neq v_i $$$ ) denote edge tree vertices $$$ u_i $$$ $$$ v_i $$$ guarantee give edge form a tree guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output maximum value root perform $$$ k $$$ operations examples tree : first test case two operations follow : second test case three operations follow :","['dp', 'math']",2600.0
1779/B,"mknez want construct array $$$ s_1 s_2 \ldots s_n $$$ satisfy follow condition : formally $$$ s_i \neq 0 $$$ must hold $$$ 1 \leq i \leq n $$$ moreover must hold $$$ s_1 + s_2 + \cdots + s_n = s_i + s _ { i+1 } $$$ $$$ 1 \leq i < n $$$ help mknez construct array properties determine exist test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) description test case follow line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 1000 $$$ ) — length array test case print ` ` yes '' array length $$$ n $$$ satisfy condition exist otherwise print ` ` '' answer ` ` yes '' next line print a sequence $$$ s_1 s_2 \ldots s_n $$$ satisfy condition element a non - zero integer range $$$ [ -5000,5000 ] $$$ i. e. $$$ -5000 \leq s_i \leq 5000 $$$ $$$ s_i \neq 0 $$$ hold $$$ 1 \leq i \leq n $$$ prove a solution exist also exist one satisfy additional constraints range several correct answer print first test case $$$ [ <unknown> ] $$$ a valid answer since $$$ 9 + 5 $$$ ( sum two adjacent elements $$$ <unknown> $$$ ) equal $$$ 9 + 5 $$$ ( sum elements ) solutions include $$$ [ 6 -9 ] [ -1 -2 ] [ -5000,5000 ] \ldots $$$ second test case let us show array satisfy constraints : a proof show answer ` ` ''",['math'],900.0
178/A3,smart beaver abbyy begin develop a new educational game children rule game fairly simple describe play field a sequence n non - negative integers ai number 1 n. goal game make number a1 a2 ... ak ( i.e prefix sequence ) equal zero fix k ( k < n ) do smallest possible number move one move choose integer i ( 1 ≤ i ≤ n ) ai > 0 integer t ( t ≥ 0 ) i + 2 t ≤ n. value i t select value ai decrease 1 value ai + 2 t increase 1 . example let n = 4 a = ( 1 0 1 2 ) possible make move i = 3 t = 0 get a = ( 1 0 0 3 ) make move i = 1 t = 1 get a = ( 0 0 2 2 ) ( possible move i = 1 t = 0 ) give n initial sequence ai task calculate minimum number move need make first k elements original sequence equal zero possible k ( 1 ≤ k < n ) first input line contain a single integer n. second line contain n integers ai ( 0 ≤ ai ≤ 104 ) separate single space input limitations get 20 point : input limitations get 50 point : input limitations get 100 point : print exactly n - 1 line : k - th output line must contain minimum number move need make first k elements original sequence ai equal zero please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier,['greedy'],1100.0
1780/G,today important day chef tonio — <unknown> arrive hometown morioh also arrive tonio 's restaurant order dessert tonio prepare turn events know dessert a string lowercase english letter tonio remember rule desserts — a string $$$ s $$$ length $$$ n $$$ dessert $$$ t $$$ delicious number occurrences $$$ t $$$ $$$ s $$$ a substring divisible length $$$ t $$$ tonio want know number delicious substrings $$$ s $$$ substring occur several time string $$$ s $$$ occurrences must take account first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000000 $$$ ) — length rule $$$ s $$$ second line contain string $$$ s $$$ length $$$ n $$$ — rule rule consist lowercase english letter a single line print number delicious substrings $$$ s $$$ first sample many delicious substrings $$$ 7 $$$ substrings length $$$ 1 $$$ ( number divisible $$$ 1 $$$ ) consider delicious substrings : therefore answer $$$ 7 + 2 + 2 = 11 $$$ note answer include occurrences ` ` ab '' ` ` ba '',['math'],2400.0
1781/E,a rectangular grid height $$$ 2 $$$ width $$$ 1000000000 $$$ consist unit cells $$$ n $$$ rectangles place grid border rectangles pass along cell border $$$ i $$$ -th rectangle cover cells row $$$ u_i $$$ $$$ d_i $$$ inclusive columns $$$ l_i $$$ $$$ r_i $$$ inclusive ( $$$ 1 \le u_i \le d_i \le 2 $$$ ; $$$ 1 \le l_i \le r_i \le 1000000000 $$$ ) initial rectangles intersect nest coincide arbitrarily either remove rectangle replace non - empty subrectangles latter case new subrectangle must lie inside initial rectangle border must still pass along cell border particular allow subrectangle equal initial rectangle replacement two ( non - <unknown> ) rectangles allow common cells total area cover new rectangles must large possible test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number rectangles next $$$ n $$$ line contain four integers $$$ u_i l_i d_i r_i $$$ ( $$$ 1 \le u_i \le d_i \le 2 $$$ ; $$$ 1 \le l_i \le r_i \le 1000000000 $$$ ) — coordinate cells locate top - left bottom - right corner rectangle respectively guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case first print integer $$$ s $$$ — largest possible cover new rectangles area print $$$ n $$$ line solution cover area $$$ i $$$ -th line print four integers $$$ u'_i l'_i d'_i r'_i $$$ remove $$$ i $$$ -th rectangle print $$$ u'_i = l'_i = d'_i = r'_i = 0 $$$ otherwise number denote new coordinate top - left bottom - right corner $$$ i $$$ -th rectangle satisfy $$$ u_i \le u'_i \le d'_i \le d_i $$$ ; $$$ l_i \le l'_i \le r'_i \le r_i $$$ multiple solutions print picture statement illustrate first test case,"['data structures', 'greedy', 'implementation']",2300.0
1783/G,give a tree $$$ n $$$ vertices $$$ n - 1 $$$ edge $$$ i $$$ -th vertex initial weight $$$ a_i $$$ let distance $$$ d_v ( u ) $$$ vertex $$$ v $$$ vertex $$$ u $$$ number edge path $$$ v $$$ $$$ u $$$ note $$$ d_v ( u ) = <unknown> ( v ) $$$ $$$ d_v ( v ) = 0 $$$ let weight distance $$$ w_v ( u ) $$$ $$$ v $$$ $$$ u $$$ $$$ w_v ( u ) = d_v ( u ) + a_u $$$ note $$$ w_v ( v ) = a_v $$$ $$$ w_v ( u ) \neq w_u ( v ) $$$ $$$ a_u \neq a_v $$$ analogically usual distance let 's define eccentricity $$$ e ( v ) $$$ vertex $$$ v $$$ greatest weight distance $$$ v $$$ vertex ( include $$$ v $$$ ) $$$ e ( v ) = \max\limits _ { 1 \le u \le n } { w_v ( u ) } $$$ finally let 's define radius $$$ r $$$ tree minimum eccentricity vertex $$$ r = \min\limits _ { 1 \le v \le n } { e ( v ) } $$$ need perform $$$ m $$$ query follow form : perform query print radius $$$ r $$$ current tree first line contain single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number vertices tree second line contain $$$ n $$$ integers $$$ a_1 \dots a_n $$$ ( $$$ 0 \le a_i \le 1000000 $$$ ) — initial weight vertices next $$$ n - 1 $$$ line contain edge tree $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ; $$$ u_i \neq v_i $$$ ) — correspond edge give edge form a tree next line contain single integer $$$ m $$$ ( $$$ 1 \le m \le 100000 $$$ ) — number query next $$$ m $$$ line contain query — one query per line $$$ j $$$ -th query contain two integers $$$ v_j $$$ $$$ x_j $$$ ( $$$ 1 \le v_j \le n $$$ ; $$$ 0 \le x_j \le 1000000 $$$ ) — a vertex 's new weight print $$$ m $$$ integers — radius $$$ r $$$ tree perform query first query follow tree : tree second query : third query radius $$$ r = e ( 2 ) = 5 $$$ :,"['data structures', 'implementation']",2800.0
1787/A,"give integer $$$ n $$$ find pair integers $$$ ( x y ) $$$ ( $$$ 1\leq x y\leq n $$$ ) $$$ <unknown> <unknown> x = n $$$ first line contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 10000 $$$ ) — number test case test case contain one line a single integer $$$ n $$$ ( $$$ 1\leq n\leq 1000000000 $$$ ) test case possible print two integers $$$ x $$$ $$$ y $$$ ( $$$ 1\leq x y\leq n $$$ ) multiple answer print otherwise print $$$ -1 $$$ third test case $$$ 2 ^ 3 \cdot 3 + 3 ^ 2 \cdot 2 = 42 $$$ $$$ ( 2,3 ) ( 3,2 ) $$$ consider legal solutions fourth test case $$$ 5 ^ 5 \cdot 5 + 5 ^ 5 \cdot 5 = <unknown> $$$ $$$ ( 5,5 ) $$$ a legal solution",['math'],800.0
1787/H,participate a codeforces round $$$ n $$$ problems spend exactly one minute solve problem time take submit a problem ignore solve one problem time contest start time $$$ 0 $$$ make first submission time $$$ t \ge 1 $$$ minutes whenever submit a problem always accept score $$$ i $$$ -th problem represent three integers $$$ k_i $$$ $$$ b_i $$$ $$$ a_i $$$ solve time $$$ t $$$ minutes get $$$ \max ( b_i - k_i \cdot t a_i ) $$$ point task choose order solve $$$ n $$$ problems get maximum possible score assume contest long enough solve problems test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number problems $$$ n $$$ line follow $$$ i $$$ -th contain three integers $$$ k_i $$$ $$$ b_i $$$ $$$ a_i $$$ ( $$$ 1\le k_i b_i a_i\le 1000000000 $$$ ; $$$ a_i < b_i $$$ ) denote get score $$$ \max ( b_i - k_i \cdot t a_i ) $$$ solve $$$ i $$$ -th task time $$$ t $$$ minutes 's guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ test case print a line contain a single integer — maximum score get second test case point problems minute list point display red denote one optimal order score $$$ 53 $$$,"['data structures', 'dp']",3300.0
1788/C,give integer $$$ n $$$ pair integers $$$ 1 $$$ $$$ 2n $$$ ( i.e integer exactly one pair ) sum match pair consecutive distinct formally let $$$ ( a_i b_i ) $$$ pair match $$$ \ { a_1 b_1 a_2 b_2 \ldots a_n b_n\ } $$$ a permutation $$$ \ { 1 2 \ldots <unknown> } $$$ let sort list $$$ \ { a_1+b_1 <unknown> \ldots <unknown> } $$$ $$$ s_1 < s_2 < \ldots < s_n $$$ must $$$ s _ { i+1 } <unknown> = 1 $$$ $$$ 1 \le i \le n - 1 $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) description test case follow test case a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) give guarantee sum $$$ n $$$ test case n't exceed $$$ 100000 $$$ test case impossible make a pair print ` ` '' otherwise print ` ` yes '' follow $$$ n $$$ line line print two integers pair output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses multiple solutions print third test case integer $$$ 1 $$$ $$$ 6 $$$ appear sum match pair $$$ 4 + <unknown> $$$ $$$ 1 + <unknown> $$$ $$$ 3 + <unknown> $$$ consecutive distinct,"['greedy', 'math']",1300.0
1788/E,give array $$$ a_1 a_2 \ldots a_n $$$ $$$ n $$$ integers consider $$$ s $$$ a set segment satisfy follow condition length segment $$$ [ x y ] $$$ define $$$ y - x+1 $$$ $$$ f ( s ) $$$ define sum lengths every element $$$ s $$$ a formal way $$$ f ( s ) = \sum _ { [ x y ] \in s } ( y - x + 1 ) $$$ note $$$ s $$$ empty $$$ f ( s ) $$$ $$$ 0 $$$ maximum $$$ f ( s ) $$$ among possible $$$ s $$$ ? first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) next line follow $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \leq a_i \leq 1000000000 $$$ ) print a single integer maximum $$$ f ( s ) $$$ among every possible $$$ s $$$ first example $$$ s=\ { [ 1 2 ] [ 4 5 ] \ } $$$ a possible $$$ s $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ s=\ { [ 1 4 ] \ } $$$ also a possible solution since exist $$$ s $$$ satisfy $$$ f ( s ) > 4 $$$ answer $$$ 4 $$$ second example $$$ s=\ { [ 1 9 ] \ } $$$ set satisfy $$$ f ( s ) = 9 $$$ since every possible $$$ s $$$ satisfy $$$ f ( s ) \leq 9 $$$ answer $$$ 9 $$$ third example $$$ s $$$ empty set answer $$$ 0 $$$,"['data structures', 'dp']",2200.0
1790/B,taisia $$$ n $$$ six - sided dice face die mark a number $$$ 1 $$$ $$$ 6 $$$ number $$$ 1 $$$ $$$ 6 $$$ use taisia roll $$$ n $$$ dice time get a sequence value $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 6 $$$ ) $$$ a_i $$$ value upper face $$$ i $$$ -th dice sum sequence equal $$$ s $$$ suddenly taisia 's pet cat steal exactly one dice maximum value $$$ a_i $$$ calculate sum value remain $$$ n-1 $$$ dice equal $$$ r $$$ know number dice $$$ n $$$ value $$$ s $$$ $$$ r $$$ restore a possible sequence $$$ a $$$ fulfill constraints first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases testcase give a separate line contain three integers $$$ n $$$ $$$ s $$$ $$$ r $$$ ( $$$ 2 \le n \le 50 $$$ $$$ 1 \le r < s \le 300 $$$ ) guarantee a solution exist testcase print : $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ order guarantee sequence exist multiple solutions print,"['greedy', 'greedy', 'math']",800.0
1791/D,let 's denote $$$ f ( x ) $$$ function a string $$$ x $$$ number distinct character string contain example $$$ f ( \texttt { abc } ) = 3 $$$ $$$ f ( \texttt { bbbbb } ) = 1 $$$ $$$ f ( \texttt { <unknown> } ) = 3 $$$ give a string $$$ s $$$ split two non - empty string $$$ a $$$ $$$ b $$$ $$$ f ( a ) + f ( b ) $$$ maximum possible word find maximum possible value $$$ f ( a ) + f ( b ) $$$ $$$ a + b = s $$$ ( concatenation string $$$ a $$$ string $$$ b $$$ equal string $$$ s $$$ ) input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 2\cdot100000 $$$ ) — length string $$$ s $$$ second line contain string $$$ s $$$ consist lowercase english letter guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ test case output a single integer — maximum possible value $$$ f ( a ) + f ( b ) $$$ $$$ a + b = s $$$ first test case one valid way split $$$ \texttt { aa } $$$ two non - empty string $$$ \texttt { a } $$$ $$$ \texttt { a } $$$ $$$ f ( \texttt { a } ) + f ( \texttt { a } ) = 1 + 1 = 2 $$$ second test case split $$$ \texttt { <unknown> } $$$ $$$ \texttt { abc } $$$ $$$ \texttt { abcd } $$$ get answer $$$ f ( \texttt { abc } ) + f ( \texttt { abcd } ) = 3 + 4 = 7 $$$ maximum possible third test case n't matter split string answer always $$$ 2 $$$,['greedy'],1000.0
1791/G1,difference easy hard versions locations teleport consider point $$$ 0 1 \dots n $$$ number line a teleporter locate point $$$ 1 2 \dots n $$$ point $$$ i $$$ follow : $$$ c $$$ coin start point $$$ 0 $$$ 's number teleporters use ? input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case descriptions test case follow first line test case contain two integers $$$ n $$$ $$$ c $$$ ( $$$ 1 \leq n \leq 2\cdot100000 $$$ ; $$$ 1 \leq c \leq 1000000000 $$$ ) — length array number coin respectively follow line contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — cost use teleporters guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot100000 $$$ test case output maximum number teleporters use first test case move one unit right use teleporter index $$$ 1 $$$ teleport point $$$ 0 $$$ move two units right use teleporter index $$$ 2 $$$ leave $$$ 6 - 1 - 1 - 2 - 1 = 1 $$$ coin n't enough coin use another teleporter use two teleporters answer two second test case go four units right use teleporter go $$$ 0 $$$ go six units right use teleporter index $$$ 6 $$$ go $$$ 0 $$$ total cost $$$ 4 + 6 + 6 + 4 = 20 $$$ leave $$$ 12 $$$ coin enough reach teleporter use answer $$$ 2 $$$ third test case n't enough coin use teleporter answer zero,['greedy'],1100.0
1792/D,give $$$ n $$$ permutations $$$ a_1 a_2 \dots a_n $$$ length $$$ m $$$ recall a permutation length $$$ m $$$ a sequence $$$ m $$$ distinct integers $$$ 1 $$$ $$$ m $$$ let beauty a permutation $$$ p_1 p_2 \dots p_m $$$ largest $$$ k $$$ $$$ p_1 = 1 p_2 = 2 \dots p_k = k $$$ $$$ p_1 \neq 1 $$$ beauty $$$ 0 $$$ product two permutations $$$ p \cdot q $$$ a permutation $$$ r $$$ $$$ r_j = q _ { p_j } $$$ $$$ i $$$ $$$ 1 $$$ $$$ n $$$ print largest beauty a permutation $$$ a_i \cdot a_j $$$ $$$ j $$$ $$$ 1 $$$ $$$ n $$$ ( possibly $$$ i = j $$$ ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 50000 $$$ ; $$$ 1 \le m \le 10 $$$ ) — number permutations length permutation $$$ i $$$ -th next $$$ n $$$ line contain a permutation $$$ a_i $$$ — $$$ m $$$ distinct integers $$$ 1 $$$ $$$ m $$$ sum $$$ n $$$ n't exceed $$$ 50000 $$$ testcases testcase print $$$ n $$$ integers $$$ i $$$ -th value equal largest beauty a permutation $$$ a_i \cdot a_j $$$ $$$ j $$$ ( $$$ 1 \le j \le n $$$ ),"['data structures', 'math']",1700.0
1792/F1,difference easy hard version constraint $$$ n $$$ give undirected complete graph $$$ n $$$ vertices a complete graph a graph pair vertices connect edge paint edge graph two color red blue ( edge one color ) a set vertices $$$ s $$$ red - connected every pair vertices $$$ ( v_1 v_2 ) $$$ $$$ v_1 \in s $$$ $$$ v_2 \in s $$$ exist a path $$$ v_1 $$$ $$$ v_2 $$$ go red edge vertices $$$ s $$$ similarly a set vertices $$$ s $$$ blue - connected every pair vertices $$$ ( v_1 v_2 ) $$$ $$$ v_1 \in s $$$ $$$ v_2 \in s $$$ exist a path $$$ v_1 $$$ $$$ v_2 $$$ go blue edge vertices $$$ s $$$ paint graph a way : calculate number ways paint graph print modulo $$$ 998244353 $$$ first ( ) line contain one integer $$$ n $$$ ( $$$ 3 \le n \le 5000 $$$ ) print one integer — number ways paint graph take modulo $$$ 998244353 $$$,['dp'],2700.0
1793/E,famous writer velepin productive recently sign a contract a well - known publication need write $$$ k_i $$$ book $$$ i $$$ -th year a problem write much want <unknown> space <unknown> insects <unknown> $$$ n $$$ regular readers $$$ i $$$ -th year read one $$$ k_i $$$ book publish velepin readers fond discuss book $$$ j $$$ -th satisfy within a year least $$$ a_j $$$ persons read book ( include ) velepin obvious problems market turn ! a well - known book read service control velepin 's regular readers read want book waste someone read book turn a request tell maximum number regular readers make satisfy years choose person book read first line contain a single integer $$$ n $$$ $$$ ( 2 \le n \le 3 \cdot 100000 ) $$$ — number regular readers velepin second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 1 \le a_i \le n ) $$$ — number necessary readers book happiness $$$ i $$$ -th person third line contain a single integer $$$ q $$$ $$$ ( 1 \le q \le 3 \cdot 100000 ) $$$ — number years analyze follow $$$ q $$$ line contain a single integer $$$ k_j $$$ $$$ ( 2 \le k_j \le n ) $$$ — number book velepin must write $$$ j $$$ -th a year print $$$ q $$$ line exactly one number — maximum number people satisfy $$$ j $$$ -th a year velepin release $$$ k_j $$$ book first example first year optimal division $$$ 1 2 2 2 2 $$$ ( first book read first person everyone else read second ) second year optimal solution $$$ 1 2 2 3 3 $$$ ( first book read first person second book read second third person others read third book ) third year optimal split $$$ 1 2 3 4 2 $$$ accordingly number satisfy people years $$$ 5 5 3 $$$ second example first year optimal division $$$ 1 1 1 1 1 2 $$$ everyone happy except $$$ 6 $$$ -th person second year optimal division $$$ 1 1 1 1 2 3 $$$ everyone happy except $$$ 5 $$$ -th $$$ 6 $$$ -th person,"['data structures', 'dp', 'greedy']",2600.0
1798/B,"lottery ` ` three <unknown> '' hold $$$ m $$$ days day $$$ i $$$ $$$ n_i $$$ people number $$$ a _ { i 1 } \ldots a _ { i n_i } $$$ participate lottery know $$$ m $$$ days one winner select lottery participants lottery winner day $$$ i $$$ allow participate lottery days $$$ i+1 $$$ $$$ m $$$ unfortunately information lottery winners lose need find possible list lottery winners days $$$ 1 $$$ $$$ m $$$ determine solution exist test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 50\,000 $$$ ) description test case follow first line test case contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 50\,000 $$$ ) — number days lottery hold next $$$ i $$$ $$$ 1 $$$ $$$ m $$$ follow a two - line block data first line block contain a single integer $$$ n_i $$$ ( $$$ 1 \le n_i \le 50\,000 $$$ ) — number lottery participants day $$$ i $$$ second line block contain integers $$$ a _ { i 1 } \ldots a _ { i n_i } $$$ ( $$$ 1 \le a _ { i j } \le 50\,000 $$$ ) — lottery participants day $$$ i $$$ guarantee number $$$ a _ { i 1 } \ldots a _ { i n_i } $$$ pairwise distinct guarantee sum $$$ n_i $$$ block test case exceed $$$ 50\,000 $$$ test case solution print a single integer $$$ -1 $$$ otherwise print $$$ m $$$ integers $$$ p_1 p_2 \ldots p_m $$$ ( $$$ 1 \le p_i \le 50\,000 $$$ ) — lottery winners days $$$ 1 $$$ $$$ m $$$ multiple solutions print first test case one answer $$$ [ 8 2 1 ] $$$ since participant number $$$ 8 $$$ participate day $$$ 1 $$$ participate days $$$ 2 $$$ $$$ 3 $$$ ; participant number $$$ 2 $$$ participate day $$$ 2 $$$ participate day $$$ 3 $$$ ; participant number $$$ 1 $$$ participate day $$$ 3 $$$ note possible answer example $$$ [ 8 9 4 ] $$$ also a correct answer second test case lottery participants participate days possible lottery winner day $$$ 1 $$$ must participate day $$$ 2 $$$ allow thus correct answer third test case one participant participate days $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ day $$$ 1 $$$ one participant participate lottery days $$$ 2 3 4 $$$ — participant $$$ 2 $$$ mean $$$ [ 2 1 4 3 ] $$$ correct answer test case","['data structures', 'greedy', 'implementation']",1000.0
1798/C,"store sell $$$ n $$$ type candy number $$$ 1 $$$ $$$ n $$$ one candy type $$$ i $$$ cost $$$ b_i $$$ coin total $$$ a_i $$$ candy type $$$ i $$$ store need pack available candy pack pack contain one type candy formally type candy $$$ i $$$ need choose integer $$$ d_i $$$ denote number type $$$ i $$$ candy one pack $$$ a_i $$$ divide without remainder $$$ d_i $$$ cost one pack candy type $$$ i $$$ equal $$$ b_i \cdot d_i $$$ let 's denote cost $$$ c_i $$$ , $$$ c_i = b_i \cdot d_i $$$ package pack place shelf consider cost pack place shelf order $$$ c_1 c_2 \ldots c_n $$$ price tag use describe cost pack one price tag describe cost pack $$$ l $$$ $$$ r $$$ inclusive $$$ c_l = c _ { l+1 } = \ldots = c_r $$$ pack $$$ 1 $$$ $$$ n $$$ must describe least one price tag example $$$ c_1 \ldots c_n = [ 4 4 2 4 4 ] $$$ describe pack a $$$ 3 $$$ price tag enough first price tag describe pack $$$ 1 2 $$$ second : $$$ 3 $$$ third : $$$ 4 5 $$$ give integers $$$ a_1 b_1 a_2 b_2 \ldots a_n b_n $$$ task choose integers $$$ d_i $$$ $$$ a_i $$$ divisible $$$ d_i $$$ $$$ i $$$ require number price tag describe value $$$ c_1 c_2 \ldots c_n $$$ minimum possible a better understand statement look illustration first test case first test : let 's repeat mean notation use problem : $$$ a_i $$$ — number candy type $$$ i $$$ available store $$$ b_i $$$ — cost one candy type $$$ i $$$ $$$ d_i $$$ — number candy type $$$ i $$$ one pack $$$ c_i $$$ — cost one pack candy type $$$ i $$$ express formula $$$ c_i = b_i \cdot d_i $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100\,000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200\,000 $$$ ) — number type candy next $$$ n $$$ line test case contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ $$$ 1 \le b_i \le 10\,000 $$$ ) — number candy cost one candy type $$$ i $$$ respectively guarantee sum $$$ n $$$ test case exceed $$$ 200\,000 $$$ test case output minimum number price tag require describe cost pack candy store first test case choose $$$ d_1 = 4 $$$ $$$ d_2 = 6 $$$ $$$ d_3 = 7 $$$ $$$ d_4 = 5 $$$ cost pack equal $$$ [ 12 12 35 35 ] $$$ $$$ 2 $$$ price tag enough describe first price tag $$$ c_1 c_2 $$$ second price tag $$$ c_3 c_4 $$$ show correct choice $$$ d_i $$$ least $$$ 2 $$$ price tag need describe pack also note example illustrate a picture statement second test case $$$ d_1 = 4 $$$ $$$ d_2 = 2 $$$ $$$ d_3 = 10 $$$ cost pack equal $$$ 20 $$$ thus $$$ 1 $$$ price tag enough describe pack note $$$ a_i $$$ divisible $$$ d_i $$$ $$$ i $$$ necessary condition third test case difficult understand one price tag use describe $$$ 2 $$$ nd $$$ 3 $$$ rd $$$ 4 $$$ th pack additionally a price tag pack $$$ 1 $$$ pack $$$ 5 $$$ total : $$$ 3 $$$ price tag","['greedy', 'math']",1700.0
1799/B,give array $$$ a_1 a_2 \ldots a_n $$$ positive integers make operation multiple ( possibly zero ) time : possible make array elements equal sequence operations ( possibly empty ) ? yes print way $$$ 30n $$$ operations prove problem constraints way exist make elements equal exist a way $$$ 30n $$$ operations first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case descriptions test case follow first line test case description contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) second line test case description contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 1000 $$$ test case print a single integer $$$ q $$$ ( $$$ -1 \leq q \leq 30n $$$ ) $$$ <unknown> $$$ solution otherwise $$$ q $$$ equal number operations $$$ q \geq 0 $$$ next $$$ q $$$ line print two integers $$$ i $$$ $$$ j $$$ ( $$$ 1 \leq i j \leq n $$$ $$$ i \neq j $$$ ) — descriptions operations multiple solutions print first second fourth test case number equal possible nothing third test case impossible make number equal fifth test case : $$$ [ \color { red } { 4 } 3 \color { blue } { 2 } ] \to [ \color { blue } { 2 } \color { red } { 3 } 2 ] \to [ 2 2 2 ] $$$ sixth test case : $$$ [ \color { blue } { 3 } 3 \color { red } { 4 } 4 ] \to [ 3 \color { blue } { 3 } 2 \color { red } { 4 } ] \to [ \color { red } { 3 } 3 \color { blue } { 2 } 2 ] \to [ 2 \color { red } { 3 } 2 \color { blue } { 2 } ] \to [ 2 2 2 2 ] $$$ red number $$$ i $$$ indices ( assign ) blue number $$$ j $$$ indices,"['greedy', 'math']",1200.0
1799/F,array positive integers $$$ a_1 a_2 \ldots a_n $$$ length $$$ n $$$ also give a positive integer $$$ b $$$ allow perform follow operations ( possibly several ) time order : however must also follow rule : cost array sum elements find minimum cost $$$ a $$$ achieve perform operations input consist multiple test case first line contain a single integer $$$ t $$$ number test case ( $$$ 1 \le t \le 5000 $$$ ) first line test case contain $$$ n $$$ $$$ b $$$ $$$ k_1 $$$ $$$ k_2 $$$ ( $$$ 1 \le n \le 5000 $$$ $$$ 1 \le b \le 1000000000 $$$ $$$ 0 \le k_1 k_2 \le n $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ describe array $$$ a $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ test case print minimum cost $$$ a $$$ achieve perform operations first test case follow : operations array $$$ a = [ 5 3 3 ] $$$ a cost $$$ 5 + 3 + 3 = 11 $$$ show minimum achievable cost second test case note allow perform operation 1 $$$ a_1 $$$ optimal apply operation 1 $$$ a_1 $$$ $$$ a_2 $$$ alternatively could apply operation 1 $$$ a_1 $$$ since effect $$$ a_2 $$$ third test case one way achieve a cost $$$ 23 $$$ : operations $$$ a = [ 2 8 3 7 3 ] $$$ cost $$$ a $$$ $$$ 2 + 8 + 3 + 7 + 3 = 23 $$$ show minimum achievable cost,"['dp', 'greedy']",2700.0
18/D,"last year bob earn sell memory stick n days work one two follow events take place : bob never keep one memory stick fear mix capacities deceive a customer <unknown> also know memory stick capacity one customer want buy memory stick , know customers ' demand prize program competitions last n days bob want know much money could earn act optimally first input line contain number n ( 1 ≤ n ≤ 5000 ) — amount bob 's work days follow n line contain description days line sell x stand a day a customer come bob buy a 2x mb memory stick ( 0 ≤ x ≤ 2000 ) 's guarantee x one line sell x. line win x stand a day bob a 2x mb memory stick ( 0 ≤ x ≤ 2000 ) output maximum possible earn bob <unknown> would know events beforehand n't forget please bob ca n't keep one memory stick a time","['dp', 'greedy']",2000.0
180/D,everything get unclear us a far away constellation <unknown> <unknown> specifically taucetians choose name children a peculiar manner two young parent abac bbad think name give first - <unknown> child decide name permutation letter string s. keep neighbour decide call baby name lexicographically strictly larger neighbour 's son 's name t. hand suspect a name tax introduce shortly accord taucetians lexicographically larger name pay larger tax 's reason abac bbad want call newborn name lexicographically strictly larger name t lexicographically minimum lexicographical order string order use ` ` dictionary '' order comparison use modern program languages compare string formally a string p length n lexicographically less string q length m one two statements correct : write a program give string s <unknown> ' child 's name t determine string result permutation letter s. string lexicographically strictly t also lexicographically minimum first line contain a non - empty string s ( 1 ≤ |s| ≤ 5000 ) |s| length second line contain a non - empty string t ( 1 ≤ |t| ≤ 5000 ) |t| length string consist lowercase latin letter print seek name -1 n't exist first sample give string s seek one consequently need change letter order,['greedy'],1900.0
1800/A,walk street hear a sound sound describe string $$$ s $$$ consist lowercase uppercase latin character want find sound a cat meow sound a meow string contain letter ' m ' ' e ' ' o ' ' w ' either uppercase lowercase also : example string ` ` meow '' ` ` <unknown> '' ` ` <unknown> '' describe a meow string ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' determine whether sound hear a cat meow something else first line input data contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — length string describe sound second line test case contain a string $$$ s $$$ $$$ n $$$ character string describe sound hear consist lowercase uppercase latin letter test case output a separate line : output yes case ( example string yes yes yes yes recognize positive response ) first test case string consist a sequence character ' m ' ' e ' ' o ' ' w ' satisfy definition meow second test case string consist a sequence $$$ 3 $$$ character ' m ' ' m ' one ' e ' a sequence $$$ 3 $$$ character ' o ' ' o ' a sequence $$$ 7 $$$ character ' w ' ' w ' satisfy definition meow third test case string describe a meow lack a sequence ' o ' ' o ' character ' e ' ' w ' fourth test case string contain character ' u ' describe a meow,['implementation'],800.0
1800/C1,easy version problem differ hard one constraints $$$ n $$$ $$$ t $$$ a deck $$$ n $$$ card characterize power two type card : follow deck : task use action gather army maximum possible total power first line input data contain single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 5000 $$$ ) — number card deck second line test case contain $$$ n $$$ integers $$$ s_1 s_2 \dots s_n $$$ ( $$$ 0 \le s_i \le 1000000000 $$$ ) — card power top - down order guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ output $$$ t $$$ number answer correspond test case — maximum possible total power army achieve first sample take bonuses $$$ 1 $$$ $$$ 2 $$$ hero card receive $$$ 3 $$$ power take bonuses one remain unused second sample hero 's card top deck power rest power $$$ 2 $$$ $$$ 3 $$$ bonuses get $$$ 6 $$$ total power fourth sample take bonuses $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 5 $$$ skip bonus $$$ 6 $$$ hero $$$ 4 $$$ enhance a bonus $$$ 3 $$$ $$$ 5 $$$ hero $$$ 7 $$$ a bonus $$$ 5 $$$ $$$ 4 $$$ $$$ 4 + 5=9 $$$,"['data structures', 'greedy']",1000.0
1801/C,"vitya a friend masha really want invite festival favorite band perform however order a friend agree must first evaluate release <unknown> vitya know masha listen a track cooler previous ones get 1 unit impression unfortunately albums listen <unknown> without change songs place help vitya find order albums masha 's impression turn much possible definitely go festival test consist multiple test case first line contain a single integer t ( $$$ 1 \le t \le 200\,000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200\,000 $$$ ) — number albums album descriptions follow album description consist two line : first line contain a single integer $$$ k_i $$$ ( $$$ 1 \le k_i \le 200\,000 $$$ ) — number track $$$ i $$$ th album follow line contain $$$ k_i $$$ integers $$$ a _ { i 1 } \ a _ { i 2 } \ a _ { i 3 } \ \ldots \ a _ { i k_i } $$$ ( $$$ 1 \le a _ { i j } \le 200\,000 $$$ ) — coolness track $$$ i $$$ album denote $$$ \sum k_i $$$ sum $$$ k_i $$$ guarantee $$$ \sum k_i \le 200\,000 $$$ test case print singular number — maximum impression masha get first test example optimal order listen 4th 2nd 3rd 1st albums case masha listen track follow order : 1 ; 7 ; 8 6 ; 4 9 4 6 8 receive 4 units impression second test example must first listen 1st 4th order 2nd 3rd case masha get maximum impression every song 1st 4th albums nothing 2nd 3rd","['data structures', 'dp', 'greedy']",1900.0
1802/A,nikita recently hold a controversial round contribution change quickly announcement hang main page $$$ n $$$ second $$$ i $$$ th second $$$ |a_i| $$$ th person either like remove like ( nikita lucky task dislike ) $$$ a_i > 0 $$$ $$$ a_i $$$ th person put a like $$$ a_i < 0 $$$ person $$$ -a_i $$$ remove like person put remove like a person could remove a like put since nikita 's contribution become bad round want analyze contribution change announcement main page turn creator platform a request give sequence $$$ a_1 a_2 \ldots a_n $$$ due imperfection platform sequence $$$ a $$$ shuffle give a shuffle sequence $$$ a $$$ describe user activity need tell moment $$$ 1 $$$ $$$ n $$$ maximum minimum number like could post moment first line input data contain one number $$$ t $$$ ( $$$ 1 \leqslant t \leqslant 1000 $$$ ) — number test case first line test case one number give $$$ n $$$ ( $$$ 1 \leqslant n \leqslant 100 $$$ ) — number second nikita 's announcement hang main page next line contain $$$ n $$$ number $$$ b_1 b_2 b_3 \ldots b_n $$$ ( $$$ 1 \leqslant |b_i| \leqslant n $$$ ) — mix array $$$ a $$$ guarantee exist a permutation $$$ b $$$ a correct sequence events describe condition guarantee sum $$$ n $$$ input test case exceed $$$ 10000 $$$ test case output two line contain $$$ n $$$ number first line test case output maximum number like nikita could announcement $$$ i $$$ th second second line test case output minimum number like nikita could announcement $$$ i $$$ th second first test case maximum value reach follow permutation : $$$ 1 2 -2 $$$ minimum value : $$$ 2 -2 1 $$$ third test case maximal value reach follow permutation : $$$ 4 2 3 1 -1 -2 $$$ minimum value next permutation : $$$ 2 -2 1 -1 3 4 $$$,"['greedy', 'implementation']",800.0
1805/F2,hard version problem differ easy one constraints $$$ n $$$ make hack lock versions let $$$ a_1 a_2 \ldots a_n $$$ array non - negative integers let $$$ f ( a_1 a_2 \ldots a_n ) $$$ sort non - decreasing order array $$$ n - 1 $$$ smallest number form $$$ a_i + a_j $$$ $$$ 1 \le i < j \le n $$$ word $$$ f ( a_1 a_2 \ldots a_n ) $$$ sort non - decreasing order array $$$ n - 1 $$$ smallest sum possible pair elements array $$$ a_1 a_2 \ldots a_n $$$ example $$$ f ( 1 2 5 7 ) = [ 1 + 2 1 + 5 2 + 5 ] = [ 3 6 7 ] $$$ give array non - negative integers $$$ a_1 a_2 \ldots a_n $$$ determine single element array $$$ \underbrace { f ( f ( f\ldots f } _ { n-1 } ( a_1 a_2 \ldots a_n ) \ldots ) ) $$$ since answer quite large output modulo $$$ 1000000000 + 7 $$$ first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — initial length array second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — array elements output a single number — answer modulo $$$ 1000000000 + 7 $$$ first test array transform follow : $$$ [ 1 2 4 5 6 ] \to [ 3 5 6 6 ] \to [ 8 9 9 ] \to [ 17 17 ] \to [ 34 ] $$$ element final array $$$ 34 $$$ second test $$$ f ( a_1 a_2 \ldots a_n ) $$$ $$$ [ 2 2 2 8 8 8 8 8 ] $$$ array make $$$ 3 $$$ number form $$$ 1 + 1 $$$ $$$ 5 $$$ number form $$$ 1 + 7 $$$ fourth test array transform follow : $$$ [ 1000000000 1000000000 777 ] \to [ 1000000000 + 777 1000000000 + 777 ] \to [ 2 \cdot 1000000000 + 1554 ] $$$ $$$ 2000000000 + 1554 $$$ modulo $$$ 1000000000 + 7 $$$ equal $$$ 1540 $$$,"['greedy', 'math']",3100.0
1806/C,"positive integer $$$ m $$$ yunqian consider array $$$ q $$$ $$$ 2 m $$$ ( possibly negative ) integers good every possible subsequence $$$ q $$$ length $$$ m $$$ product $$$ m $$$ elements subsequence equal sum $$$ m $$$ elements subsequence formally let $$$ u=\ { 1,2 <unknown> } $$$ set $$$ s \subseteq u $$$ $$$ <unknown> $$$ $$$ \prod\limits _ { i \in s } q_i = \sum\limits _ { i \in u \setminus s } q_i $$$ define distance two array $$$ a $$$ $$$ b $$$ length $$$ k $$$ $$$ \sum\limits _ { i=1 } <unknown> - b_i| $$$ give a positive integer $$$ n $$$ array $$$ p $$$ $$$ 2n $$$ integers find minimum distance $$$ p $$$ $$$ q $$$ good array $$$ q $$$ length $$$ 2n $$$ show positive integers $$$ n $$$ least one good array exist note require construct array $$$ q $$$ achieve minimum distance first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1\le n\le 2\cdot100000 $$$ ) second line test case contain $$$ 2n $$$ integers $$$ p_1 p_2 \ldots p _ { 2n } $$$ ( $$$ <unknown> \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case output minimum distance $$$ p $$$ a good $$$ q $$$ first test case optimal let $$$ q= [ 6,6 ] $$$ second test case optimal let $$$ q= [ <unknown> ] $$$",['math'],1600.0
1806/D,"give integer $$$ n $$$ array $$$ a $$$ length $$$ n-1 $$$ whose elements either $$$ 0 $$$ $$$ 1 $$$ let us define value a permutation $$$ ^\dagger $$$ $$$ p $$$ length $$$ m-1 $$$ ( $$$ m \leq n $$$ ) follow process let $$$ g $$$ a graph $$$ m $$$ vertices label $$$ 1 $$$ $$$ m $$$ contain edge $$$ i $$$ $$$ 1 $$$ $$$ m-1 $$$ perform follow operations : value $$$ p $$$ number incoming edge vertex $$$ 1 $$$ $$$ g $$$ $$$ k $$$ $$$ 1 $$$ $$$ n-1 $$$ find sum value $$$ k ! $$$ permutations length $$$ k $$$ since value big require compute value modulo $$$ 998\,244\,353 $$$ $$$ ^\dagger $$$ a permutation length $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2,3,1,5,4 ] $$$ a permutation $$$ [ 1,2,2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1,3,4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) $$$ ^\ddagger $$$ weakly connect components a direct graph components undirected version graph formally direct graph $$$ g $$$ define a graph $$$ h $$$ edge $$$ a \to b $$$ $$$ g $$$ add undirected edge $$$ a \leftrightarrow b $$$ $$$ h $$$ weakly connect components $$$ g $$$ components $$$ h $$$ $$$ ^ { <unknown> } $$$ note a vertex edge consider incoming edge first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2\le n\le 500000 $$$ ) second line test case contain $$$ n-1 $$$ integers $$$ a_1 a_2 \ldots a _ { n-1 } $$$ ( $$$ a_i $$$ $$$ 0 $$$ $$$ 1 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 500000 $$$ test case output $$$ n-1 $$$ integers a line $$$ i $$$ -th integer represent answer $$$ k = i $$$ modulo $$$ 998\,244\,353 $$$ consider first test case $$$ k=1 $$$ $$$ 1 $$$ permutation $$$ p $$$ therefore $$$ k=1 $$$ answer $$$ 1 $$$ $$$ k=2 $$$ $$$ 2 $$$ permutations $$$ p $$$ therefore $$$ k=2 $$$ answer $$$ 2 + 1=3 $$$","['dp', 'math']",2500.0
1806/F2,"hard version problem difference two versions constraint $$$ m $$$ make hack versions problem solve give array $$$ a $$$ length $$$ n $$$ two integers $$$ m $$$ $$$ k $$$ element $$$ a $$$ satisfy $$$ 1\le a_i \le m $$$ one operation choose two indices $$$ i $$$ $$$ j $$$ $$$ 1 \le i < j \le |a| $$$ append $$$ \gcd ( a_i a_j ) $$$ back array delete $$$ a_i $$$ $$$ a_j $$$ array note length array decrease one operation find maximum possible sum array perform exactly $$$ k $$$ operations first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 100000 $$$ ) — number test case description test case follow first line test case contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \le n \le 1000000 $$$ ; $$$ 1\le m \le <unknown> 10^ { 18 } $$$ ; $$$ 1 \le k \le n-1 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le m $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 1000000 $$$ test case output maximum possible sum array perform $$$ k $$$ operations optimally first test case best way choose $$$ i=1 $$$ $$$ j=3 $$$ first operation final sequence $$$ [ 7,4 ] $$$","['greedy', 'math']",2900.0
1807/A,give three integers $$$ a $$$ $$$ b $$$ $$$ c $$$ exactly one two equations true : first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 162 $$$ ) — number test case description test case consist three integers $$$ a $$$ $$$ b $$$ $$$ c $$$ ( $$$ 1 \leq a b \leq 9 $$$ $$$ -8 \leq c \leq 18 $$$ ) additional constraint input : generate exactly one two equations true test case output either + - a new line represent correct equation first test case $$$ 1 + 2=3 $$$ second test case $$$ 3 - 2=1 $$$ third test case $$$ 2 - <unknown> $$$ note $$$ c $$$ negative,['implementation'],800.0
1807/F,"give a room represent a $$$ n \times m $$$ grid a ball position $$$ ( i_1 j_1 ) $$$ ( intersection row $$$ i_1 $$$ column $$$ j_1 $$$ ) start go diagonally one four directions : step ball maintain direction unless hit a wall ( direction take room 's bound next step ) case ball 's direction get flip along axis wall ; ball hit a corner directions get flip instance call a bounce ball never stop move example ball start $$$ ( 1 7 ) $$$ go $$$ \texttt { dl } $$$ reach bottom wall bounce continue direction $$$ \texttt { ul } $$$ reach leave wall ball bounce continue go direction $$$ \texttt { ur } $$$ ball reach upper wall bounce continue direction $$$ \texttt { dr } $$$ reach bottom - right corner bounce continue direction $$$ \texttt { ul } $$$ , task find many bounce ball go reach cell $$$ ( i_2 j_2 ) $$$ room report never reach cell $$$ ( i_2 j_2 ) $$$ print $$$ -1 $$$ note ball first go a cell bounce need first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain six integers a string $$$ n m i_1 j_1 i_2 j_2 d $$$ ( $$$ 2 \leq n m \leq 25000 $$$ ; $$$ 1 \leq i_1 i_2 \leq n $$$ ; $$$ 1 \leq j_1 j_2 \leq m $$$ ; $$$ d \in\ { \texttt { dr } \texttt { dl } \texttt { ur } \texttt { ul } \ } $$$ ) — dimension grid start coordinate ball coordinate final cell start direction ball guarantee sum $$$ n \cdot m $$$ test case exceed $$$ 50000 $$$ test case output a single integer — number bounce ball reach cell $$$ ( i_2 j_2 ) $$$ first time $$$ -1 $$$ ball never reach final cell",['implementation'],1700.0
1807/G2,difference two versions version constraints higher initially array $$$ a $$$ contain number $$$ 1 $$$ perform several operations order change array operation select subsequence $$$ ^ { \dagger } $$$ $$$ a $$$ add $$$ a $$$ element equal sum elements subsequence give a final array $$$ c $$$ check $$$ c $$$ obtain initial array $$$ a $$$ perform number ( possibly 0 ) operations initial array $$$ ^ { \dagger } $$$ a sequence $$$ b $$$ a subsequence a sequence $$$ a $$$ $$$ b $$$ obtain $$$ a $$$ deletion several ( possibly zero ) elements word select $$$ k $$$ ( $$$ 1 \leq k \leq |a| $$$ ) distinct indices $$$ i_1 i_2 \dots i_k $$$ insert anywhere $$$ a $$$ a new element value equal $$$ a _ { i_1 } + a _ { i_2 } + \dots + a _ { i_k } $$$ first line input contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — number elements final array $$$ c $$$ second line test case contain $$$ n $$$ space - separated integers $$$ c_i $$$ ( $$$ 1 \leq c_i \leq 200000 $$$ ) — elements final array $$$ c $$$ obtain initial array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output ` ` yes '' ( without quote ) a sequence operations exist ` ` '' ( without quote ) otherwise output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ) first test case initial array $$$ a $$$ already equal $$$ [ 1 ] $$$ answer ` ` yes '' second test case perform amount operations change $$$ a $$$ array size least two n't element $$$ 2 $$$ thus obtain array $$$ [ 2 ] $$$ impossible answer ` ` '' third test case perform follow operations order obtain final give array $$$ c $$$ :,"['dp', 'greedy', 'implementation']",1100.0
1808/C,problem unlike problem a need look unluckiest number luckiest one note constraints problem differ problem a. olympus city recently launch production personal starships everyone mar buy one fly planets inexpensively starship a number — some positive integer $$$ x $$$ let 's define luckiness a number $$$ x $$$ difference largest smallest digits number example $$$ 142857 $$$ $$$ 8 $$$ largest digit $$$ 1 $$$ smallest digit luckiness $$$ 8 - 1=7 $$$ number $$$ 111 $$$ digits equal $$$ 1 $$$ luckiness zero hateehc a famous martian blogger often fly different corner solar system release interest videos even faster decide buy a starship come store saw starships number $$$ l $$$ $$$ r $$$ inclusively store hateehc want find a starship unluckiest number since a lot starships store hateehc ca n't program help blogger write a program answer question first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 600 $$$ ) — the number test case follow $$$ t $$$ line contain a description test case description consist two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \le l \le r \le 10^ { 18 } $$$ ) — largest smallest number starships store print $$$ t $$$ line one line test case contain unluckiest starship number store several ways choose unluckiest number output let 's look two test examples : fifth test case unluckiest number $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ $$$ 6 $$$ $$$ 7 $$$ $$$ 8 $$$ $$$ 9 $$$ $$$ 11 $$$ $$$ 22 $$$ $$$ 33 $$$ $$$ 44 $$$ $$$ 55 $$$ $$$ 66 $$$ $$$ 77 $$$ $$$ 88 $$$ $$$ 99 $$$ allow choose,"['dp', 'greedy', 'implementation']",1900.0
1809/A,a garland consist $$$ 4 $$$ color light bulbs color $$$ i $$$ -th light bulb $$$ s_i $$$ initially light bulbs turn task turn light bulbs perform follow operation number time : select a light bulb switch state ( turn turn ) restriction operation apply operation a light bulb previous operation apply a light bulb a different color ( first operation apply light bulb ) calculate minimum number operations turn light bulbs report impossible first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case single line test case contain $$$ s $$$ — a sequence $$$ 4 $$$ character character a decimal digit $$$ i $$$ -th character denote color $$$ i $$$ -th light bulb test case print one integer — minimum number operations turn light bulbs impossible turn bulbs print -1 . first example color different turn bulbs $$$ 4 $$$ operations second example impossible turn bulbs switch one light bulb impossible turn others third example proceed follow : turn first light bulb turn third light bulb turn fourth light bulb turn third light bulb turn second light bulb turn third light bulb,['implementation'],800.0
1809/C,array $$$ a = [ a_1 a_2 \dots a_n ] $$$ let 's denote subarray $$$ a [ l r ] $$$ array $$$ [ a_l a _ { l+1 } \dots a_r ] $$$ example array $$$ a = [ 1 -3 1 ] $$$ $$$ 6 $$$ non - empty subarrays : give two integers $$$ n $$$ $$$ k $$$ construct array $$$ a $$$ consist $$$ n $$$ integers : first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) — number test case test case consist one line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 30 $$$ ; $$$ 0 \le k \le \dfrac { ( n+1 ) \cdot n } { 2 } $$$ ) test case print $$$ n $$$ integers — elements array meet constraints show answer always exist multiple answer print,"['greedy', 'math']",1500.0
1809/D,give a binary string $$$ s $$$ consist character 0 and/or 1 . perform several operations string ( possibly zero ) two type operations : task calculate minimum number coin require sort string $$$ s $$$ non - decreasing order ( i. e. transform $$$ s $$$ $$$ s_1 \le s_2 \le \dots \le s_m $$$ $$$ m $$$ length string apply operations ) empty string also consider sort non - decreasing order first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case line test case contain string $$$ s $$$ ( $$$ 1 \le |s| \le 300000 $$$ ) consist character 0 and/or 1 . sum lengths give string n't exceed $$$ 300000 $$$ test case print a single integer — minimum number coin require sort string $$$ s $$$ non - decreasing order first example remove $$$ 1 $$$ -st element string become equal 00 . second example string already sort third example swap $$$ 2 $$$ -nd $$$ 3 $$$ -rd elements string become equal 0011 . fourth example swap $$$ 3 $$$ -rd $$$ 4 $$$ -th elements string become equal <unknown> remove $$$ 7 $$$ -th element string become equal <unknown> . fifth example remove $$$ 1 $$$ -st element string become equal <unknown> remove $$$ 5 $$$ -th element string become equal 00111 . sixth example string already sort,['greedy'],1800.0
1809/G,"consider a tournament $$$ n $$$ participants rat $$$ i $$$ -th participant $$$ a_i $$$ tournament organize follow first organizers assign participant index $$$ 1 $$$ $$$ n $$$ indices unique let $$$ p_i $$$ participant get index $$$ i $$$ , $$$ n-1 $$$ game hold first game participants $$$ p_1 $$$ $$$ p_2 $$$ play second game winner first game play $$$ p_3 $$$ third game winner second game play $$$ p_4 $$$ — last game winner $$$ ( n-2 ) $$$ -th game play $$$ p_n $$$ monocarp want predict result $$$ n-1 $$$ game ( course prediction indices participants assign ) know sure two participants rat $$$ x $$$ $$$ y $$$ play $$$ |x - y| > k $$$ participant higher rat win $$$ |x - y| \le k $$$ two participants may win among $$$ n ! $$$ ways assign indices participants calculate number ways monocarp predict result $$$ n-1 $$$ game since answer large print modulo $$$ 998244353 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 1000000 $$$ ; $$$ 0 \le k \le 1000000000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_1 \le a_2 \le \dots \le a_n \le 1000000000 $$$ ) print one integer — number ways assign indices participants monocarp predict result $$$ n-1 $$$ game first example a match pair players predict monocarp $$$ 24 $$$ ways assign indices count second example suitable ways $$$ [ 1 3 2 ] $$$ $$$ [ 2 3 1 ] $$$ $$$ [ 3 1 2 $$$ ] $$$ [ 3 2 1 ] $$$","['dp', 'math']",2800.0
1810/A,"a sequence $$$ m $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { m } $$$ good exist least one $$$ i $$$ ( $$$ 1 \le i \le m $$$ ) $$$ a _ { i } = i $$$ example $$$ [ 3,2,3 ] $$$ a good sequence since $$$ a _ { 2 } = 2 $$$ $$$ a _ { 3 } = 3 $$$ $$$ [ 3,1,1 ] $$$ a good sequence since $$$ i $$$ $$$ a _ { i } = i $$$ a sequence $$$ a $$$ beautiful exist least one subsequence $$$ a $$$ satisfy subsequence good example $$$ [ <unknown> ] $$$ a beautiful sequence since subsequence $$$ [ 4,2 ] $$$ good $$$ [ <unknown> ] $$$ a beautiful sequence a sequence $$$ b $$$ a subsequence a sequence $$$ a $$$ $$$ b $$$ obtain $$$ a $$$ deletion several ( possibly zero ) elements give a sequence check whether beautiful test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case description follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — length give sequence second line test case contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ ( $$$ 1 \le a _ { i } \le 1000000000 $$$ ) represent sequence test case output ` ` yes '' ` ` '' ( without quote ) one line represent whether give sequence beautiful output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses first test case good subsequence $$$ b= [ 3,2 ] $$$ $$$ b _ { 2 } = 2 $$$ second test case good subsequence $$$ b= [ 2,4,3 ] $$$ $$$ b _ { 3 } = 3 $$$ fourth test case good subsequence $$$ b= [ 1 ] $$$ $$$ b _ { 1 } = 1 $$$ fifth test case good subsequence $$$ b= [ 2,2 ] $$$ $$$ b _ { 2 } = 2 $$$",['greedy'],800.0
1810/E,"undirected graph $$$ n $$$ vertices $$$ m $$$ edge initially vertex $$$ i $$$ a monster danger $$$ a _ { i } $$$ vertex a monster danger $$$ a _ { i } $$$ defeat defeat least $$$ a _ { i } $$$ monsters want defeat monsters first choose vertex $$$ s $$$ defeat monster vertex ( since n't defeat monsters $$$ a _ { s } $$$ $$$ 0 $$$ ) , move edge want move vertex $$$ u $$$ vertex $$$ v $$$ follow must hold : either monster vertex $$$ v $$$ defeat defeat second case defeat monster vertex $$$ v $$$ reach vertex $$$ v $$$ pass vertices edge number time determine whether defeat monsters test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200000 $$$ ) — number vertices edge graph respectively second line test case contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ ( $$$ 0 \le a _ { i } \le n $$$ ) — dangers monsters correspond vertices follow $$$ m $$$ line line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) describe edge connect vertex $$$ u $$$ vertex $$$ v $$$ guarantee multi - edges self - loops graph guarantee sum $$$ n $$$ sum $$$ m $$$ test case exceed $$$ 200000 $$$ test case output ` ` yes '' defeat monsters ` ` '' otherwise output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses first test case start vertex $$$ 3 $$$ defeat monster go vertices $$$ 2 $$$ $$$ 1 $$$ order defeat monsters well return vertex $$$ 3 $$$ go vertex $$$ 4 $$$ defeat monster third test case path vertex $$$ 4 $$$ start vertex $$$ 1 $$$ also path vertices $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ start vertex $$$ 4 $$$","['data structures', 'greedy']",2100.0
1810/G,"'re go generate array $$$ a $$$ a length $$$ n $$$ $$$ a _ { i } $$$ equal either $$$ 1 $$$ $$$ -1 $$$ generate array follow way array generate calculate $$$ s _ { i } = a _ { 1 } + a _ { 2 } + a _ { 3 } + \ldots + a _ { i } $$$ specially $$$ s _ { 0 } = 0 $$$ let $$$ s $$$ equal $$$ \displaystyle \max _ { i=0 } ^ { k } { s _ { i } } $$$ , $$$ s $$$ maximum prefix sum array $$$ a $$$ give $$$ n+1 $$$ integers $$$ h _ { 0 } h _ { 1 } \ldots h _ { n } $$$ score array $$$ a $$$ maximum prefix sum $$$ s $$$ $$$ h _ { s } $$$ , $$$ k $$$ want know expect score array length $$$ k $$$ modulo $$$ 1000000000 + 7 $$$ test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) — number test case description follow first line contain integer $$$ n $$$ ( $$$ 1\le n \le 5000 $$$ ) follow $$$ n $$$ line line contain two integers $$$ x _ { i } $$$ $$$ y _ { i } $$$ ( $$$ 0 \le x _ { i } < 1000000000 + 7 $$$ $$$ 1\le y _ { i } < 1000000000 + 7 $$$ $$$ x _ { i } \le y _ { i } $$$ ) indicate $$$ p _ { i } = \frac { x _ { i } } { y _ { i } } $$$ next line contain $$$ n+1 $$$ integers $$$ h _ { 0 } h _ { 1 } \ldots h _ { n } $$$ ( $$$ 0 \le h _ { i } < 1000000000 + 7 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ test case output $$$ n $$$ integers one single line $$$ i $$$ -th denote expect score array length $$$ i $$$ modulo $$$ 1000000000 + 7 $$$ formally let $$$ m = 1000000000 + 7 $$$ show answer express irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \not \equiv 0 \pmod { m } $$$ output integer equal $$$ p \cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \le x < m $$$ $$$ x \cdot q \equiv p \pmod { m } $$$ first test case choose $$$ k=1 $$$ $$$ 2 $$$ possible array equal probabilities : $$$ [ 1 ] $$$ $$$ [ -1 ] $$$ $$$ s $$$ value $$$ 1 $$$ $$$ 0 $$$ expect score $$$ \frac { 1 } { 2 } h _ { 0 } + \frac { 1 } { 2 } h _ { 1 } = \frac { 3 } { 2 } $$$ choose $$$ k=2 $$$ $$$ 4 $$$ possible array equal probabilities : $$$ [ 1,1 ] $$$ $$$ [ 1 -1 ] $$$ $$$ [ -1,1 ] $$$ $$$ [ -1 -1 ] $$$ $$$ s $$$ value $$$ <unknown> $$$ expect score $$$ \frac { 1 } { 2 } h _ { 0 } + \frac { 1 } { 4 } h _ { 1 } + \frac { 1 } { 4 } h _ { 2 } = \frac { 7 } { 4 } $$$ second test case matter $$$ s $$$ value score always $$$ 1 $$$ expect score always $$$ 1 $$$",['dp'],3200.0
1811/F,vlad find a flowerbed graph yard decide take one later find addition usual graph $$$ k $$$ -flowers also grow flowerbed a graph call a $$$ k $$$ -flower consist a simple cycle length $$$ k $$$ vertex pass simple cycle length $$$ k $$$ cycle intersect vertices example $$$ 3 $$$ -flower look like : note $$$ 1 $$$ -flower $$$ 2 $$$ -flower exist since least $$$ 3 $$$ vertices need form a cycle vlad really like structure $$$ k $$$ -flowers want find lucky take one flowerbed first line input contain single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test descriptions case follow empty string write case first line case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 1 \le m \le \min ( 2 \cdot 100000 \frac { n \cdot ( n-1 ) } { 2 } ) $$$ ) — number vertices edge graph respectively next $$$ m $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) — number vertices connect edge guarantee graph contain multiple edge self - loops guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ also guarantee sum $$$ m $$$ test case output $$$ t $$$ line answer correspond test case answer output ` ` yes '' vlad 's graph a $$$ k $$$ -flower $$$ k $$$ ` ` '' otherwise output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ),['implementation'],2100.0
1816/B,"consider a $$$ 2 \times n $$$ grid $$$ n $$$ even integer may place integers $$$ 1 2 \ldots 2n $$$ grid use integer exactly a path a sequence cells achieve start $$$ ( 1 1 ) $$$ repeatedly walk either downwards right stop $$$ ( 2 n ) $$$ reach path extend beyond grid cost a path alternate sum number write cells a path , let number write cells $$$ a_1 a_2 \ldots a_k $$$ ( order visit ) cost path $$$ a_1 - a_2 + a_3 - a_4 + \ldots = \sum _ { i=1 } ^k a_i \cdot ( -1 ) ^ { i+1 } $$$ construct a way place integers $$$ 1 2 \ldots 2n $$$ grid minimum cost paths $$$ ( 1 1 ) $$$ $$$ ( 2 n ) $$$ maximize multiple grids result maximum value output first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100000 $$$ $$$ n $$$ even ) — number columns grid guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output $$$ 2 $$$ line contain $$$ n $$$ integers — desire grid multiple solutions output first test case two paths cell $$$ ( 1 1 ) $$$ cell $$$ ( 2 2 ) $$$ cost $$$ 3 - 1 + <unknown> $$$ $$$ 3 - 2 + 4=5 $$$ minimum cost $$$ 5 $$$ maximum possible value second test case four paths cell $$$ ( 1 1 ) $$$ cell $$$ ( 2 4 ) $$$ cost $$$ 8 - 1 + 5 - 3 + 7=16 $$$ $$$ 8 - 2 + 5 - 3 + 7=15 $$$ $$$ 8 - 2 + 6 - 3 + 7=16 $$$ $$$ 8 - 2 + 6 - 4 + 7=15 $$$ minimum value $$$ 15 $$$ maximum possible value",['greedy'],1000.0
1817/D,"a toy machine toy arrange two row $$$ n $$$ cells ( $$$ n $$$ odd ) initially $$$ n-2 $$$ toy place non - corner cells top row bottom row initially empty leftmost rightmost central cells block $$$ 4 $$$ button control toy machine : leave right , mark letter l r u d correspondingly press l r u d toy move simultaneously correspond direction stop push another toy wall a block cell goal move $$$ k $$$ -th toy leftmost cell top row toy number $$$ 1 $$$ $$$ n-2 $$$ leave right give $$$ n $$$ $$$ k $$$ find a solution use $$$ 1\,000\,000 $$$ button press test toy machine a web page available let play game real time first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 5 \le n \le 100\,000 $$$ $$$ n $$$ odd $$$ 1 \le k \le n-2 $$$ ) — number cells a row index toy move leftmost cell top row a single line output a description button press a string $$$ 1\,000\,000 $$$ character string contain character l r u d. $$$ i $$$ -th character string $$$ i $$$ -th button press button press perform $$$ k $$$ -th toy leftmost cell top row multiple solutions print number button press minimize first example $$$ 5 - 2 = 3 $$$ toy first toy need end leftmost cell top row move <unknown> achieve see picture a better understand another possible solution would one button press l",['implementation'],2700.0
1821/A,integer template a string consist digits and/or question mark a positive ( strictly greater $$$ 0 $$$ ) integer match integer template possible replace every question mark template a digit a way get decimal representation integer without lead zero example : give integer template consist $$$ 5 $$$ character calculate number positive ( strictly greater $$$ 0 $$$ ) integers match first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case test case consist one line contain string $$$ s $$$ ( $$$ 1 \le |s| \le 5 $$$ ) consist digits and/or question mark — integer template correspond test case test case print one integer — number positive ( strictly greater $$$ 0 $$$ ) integers match template,['math'],800.0
1821/E,a regular bracket sequence a bracket sequence transform a correct arithmetic expression insert character ` ` 1 '' ` ` + '' original character sequence example : give a regular bracket sequence one move remove a pair adjacent bracket leave one open bracket right one a close bracket concatenate result part without change order cost move number bracket right right bracket pair cost regular bracket sequence smallest total cost move require make sequence empty actually remove bracket instead give a regular bracket sequence integer $$$ k $$$ perform follow operation $$$ k $$$ time : operations perform bracket sequence regular smallest possible cost result regular bracket sequence ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain a single integer $$$ k $$$ ( $$$ 0 \le k \le 5 $$$ ) — maximum number operations perform second line contain a non - empty regular bracket sequence consist character ' ( ' ' ) ' total length regular bracket sequence testcases n't exceed $$$ 200000 $$$ testcase print a single integer — smallest possible cost regular bracket sequence perform $$$ k $$$ operations,"['dp', 'greedy']",2100.0
1822/A,mushroom <unknown> cook a meal lunch decide watch a video tubetube spend $$$ t $$$ second lunch ask help selection video tubetube fee a list $$$ n $$$ videos index $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th video last $$$ a_i $$$ second entertainment value $$$ b_i $$$ initially fee open first video mushroom skip next video $$$ 1 $$$ second ( next video exist ) mushroom skip videos number time ( include zero ) help mushroom choose one video open watch $$$ t $$$ second several want choose entertain one print index appropriate video $$$ -1 $$$ first line input data contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 1000 $$$ ) — number test case test description test case follow first line a test case contain two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 50 $$$ $$$ 1 \le t \le 200 $$$ ) — number videos fee second lunch respectively second line a test case contain $$$ n $$$ integers $$$ a_1 a_2 a_3 \dots a_n $$$ ( $$$ 1 \le a_i \le 100 $$$ ) — durations videos third line a test case contain $$$ n $$$ integers $$$ b_1 b_2 b_3 \dots b_n $$$ ( $$$ 1 \le b_i \le 100 $$$ ) — entertainment value videos output $$$ q $$$ integers answer correspond test case answer output index entertain video mushroom time watch several answer allow output output $$$ -1 $$$ video watch lunch break,['implementation'],800.0
1822/G2,hard version problem difference version $$$ a_i \le 1000000000 $$$ a give sequence $$$ n $$$ integers $$$ a $$$ a triple $$$ ( i j k ) $$$ call magic : kolya receive a sequence integers $$$ a $$$ a gift want count number magic triple help task ! note constraints order integers $$$ i $$$ $$$ j $$$ $$$ k $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) — length sequence second line test contain $$$ n $$$ integers $$$ a_1 a_2 a_3 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements sequence $$$ a $$$ sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a single integer — number magic triple sequence $$$ a $$$ first example $$$ 6 $$$ magic triple sequence $$$ a $$$ — $$$ ( 2 3 5 ) $$$ $$$ ( 2 5 3 ) $$$ $$$ ( 3 2 5 ) $$$ $$$ ( 3 5 2 ) $$$ $$$ ( 5 2 3 ) $$$ $$$ ( 5 3 2 ) $$$ second example a single magic triple sequence $$$ a $$$ — $$$ ( 2 1 3 ) $$$,"['data structures', 'math']",2200.0
1824/A,$$$ n $$$ people take part a show <unknown> sit row seat number $$$ 1 $$$ $$$ m $$$ leave right $$$ n $$$ people come sit order person occupy a seat one three ways : want know maximum number people take a seat let people show order ? test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100000 $$$ ) — number people number seat second line test case contain $$$ n $$$ integers $$$ x_1 x_2 \ldots x_n $$$ ( $$$ -2 \le x_i \le m $$$ $$$ x_i \ne 0 $$$ ) $$$ i $$$ -th describe way $$$ i $$$ -th person occupy a seat : guarantee sum $$$ n $$$ sum $$$ m $$$ test case n't exceed $$$ 100000 $$$ test case output a single integer — maximum number people occupy a seat first test case people want occupy $$$ 5 $$$ seat $$$ 1 $$$ people occupy seat second test case let people order $$$ 1 2 3 4 $$$ last person take a seat third test case let people show order : let third person : – – – 3 – – – let fourth person : – – – 34 – – let fifth person : – – – <unknown> – let first person : – – 1345 – let second person : – <unknown> – thus $$$ 5 $$$ people take seat fifth test case let people show order : let fourth person : – – – – 4 – let third person : – – – 34 – let sixth person 'll leave show take third seat third way sit $$$ 4 $$$ seat 's already take : – – – 34 – let fifth person : – – <unknown> – let first person : – <unknown> – let second person <unknown> – thus $$$ 5 $$$ people take seat seventh test case let people show order : let third person <unknown> fourth person <unknown> – – – – – let fifth person <unknown> – – – – let sixth person <unknown> – – – let first person <unknown> second person leave show occupy first way $$$ 1 $$$ seat <unknown> $$$ 5 $$$ people take seat,"['greedy', 'implementation']",1400.0
1826/E,"a fashion tour consist $$$ m $$$ identical runway show different cities $$$ n $$$ model will participate tour number $$$ 1 $$$ $$$ n $$$ people different cities different view fashion industry rate model differently particular people city $$$ i $$$ rate model $$$ j $$$ rat $$$ r _ { i j } $$$ choose number $$$ k $$$ model order let choose model indices $$$ j_1 j_2 \dots j_k $$$ choose order city $$$ k $$$ model walk runway one another order make show excite city rat model strictly increase order performance formally city $$$ i $$$ index $$$ t $$$ ( $$$ 2 \leq t \leq k $$$ ) rat must satisfy $$$ r _ { i j _ { t - 1 } } < r _ { i <unknown> } $$$ , fashion industry money choose model $$$ j $$$ participate tour profit $$$ p_j $$$ money compute maximum total profit make choose model order satisfy requirements first line contain two integers $$$ m $$$ $$$ n $$$ ( $$$ 1 \leq m \leq 500 $$$ $$$ 1 \leq n \leq 5000 $$$ ) — number show number model will participate respectively second line contain $$$ n $$$ integers $$$ p_j $$$ ( $$$ 1 \leq p_j \leq 1000000000 $$$ ) — profit get invite $$$ j $$$ -th model tour next $$$ m $$$ line contain $$$ n $$$ integers line number $$$ i $$$ contain $$$ n $$$ integers $$$ r _ { i j } $$$ ( $$$ 1 \leq r _ { i j } \leq n $$$ ) — rat model city $$$ i $$$ output a single integer — largest total amount money get first example $$$ 3 $$$ invite model show consist model order $$$ [ 1 3 4 ] $$$ , correspond rat cities follow : see rat increase total profit $$$ 10 + 10 + 10 = 30 $$$ prove ca n't achieve a bigger profit second example invite fifth model tour would result a total profit $$$ 50 $$$ prove ca n't achieve a bigger profit third example invite single model tour result a total profit $$$ 1\,000\,000\,000 $$$ fourth test case invite model make show order $$$ [ 5 4 3 2 1 ] $$$ total profit $$$ 5 \cdot 1\,000\,000\,000 = <unknown> $$$","['data structures', 'dp', 'implementation']",2400.0
1827/A,give two array $$$ a $$$ $$$ b $$$ consist $$$ n $$$ integers elements $$$ a $$$ pairwise distinct find number ways reorder $$$ a $$$ $$$ a_i > b_i $$$ $$$ 1 \le i \le n $$$ modulo $$$ 1000000000 + 7 $$$ two ways reorder consider different result array different test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 2 \cdot 10^ { 5 } $$$ ) — length array $$$ a $$$ $$$ b $$$ second line test case contain $$$ n $$$ distinct integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — array $$$ a $$$ guarantee elements $$$ a $$$ pairwise distinct second line test case contain $$$ n $$$ integers $$$ b_1 $$$ $$$ b_2 $$$ $$$ \ldots $$$ $$$ b_n $$$ ( $$$ 1 \le b_i \le 1000000000 $$$ ) — array $$$ b $$$ guarantee sum $$$ n $$$ test case exceed $$$ 2 \cdot 10^ { 5 } $$$ test case output number ways reorder array $$$ a $$$ $$$ a_i > b_i $$$ $$$ 1 \le i \le n $$$ modulo $$$ 1000000000 + 7 $$$,['math'],1100.0
1827/B2,difference problem easy version constraints $$$ t $$$ $$$ n $$$ give array $$$ a $$$ consist $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ define beauty array $$$ p_1 p_2 \ldots p_k $$$ minimum amount time need sort array use arbitrary number range - sort operations range - sort operation follow : please calculate sum beauty subarrays array $$$ a $$$ a subarray array define a sequence consecutive elements array test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) — length array $$$ a $$$ second line test case consist $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1\le a_i\le 1000000000 $$$ ) guarantee elements $$$ a $$$ pairwise distinct guarantee sum $$$ n $$$ test case exceed $$$ 300000 $$$ test case output sum beauty subarrays array $$$ a $$$ first test case : second test case :,"['data structures', 'dp', 'greedy']",2400.0
1829/F,a snowflake graph generate two integers $$$ x $$$ $$$ y $$$ greater $$$ 1 $$$ follow : snowflake graph a central vertex $$$ 15 $$$ $$$ x=5 $$$ vertices attach ( $$$ 3 $$$ $$$ 6 $$$ $$$ 7 $$$ $$$ 8 $$$ $$$ 20 $$$ ) $$$ y=3 $$$ vertices attach first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 200 $$$ ; $$$ 1 \leq m \leq <unknown> ( 1000 \frac { n ( n-1 ) } { 2 } \right ) $$$ ) — number vertices edge graph respectively next $$$ m $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \leq u v \leq n $$$ $$$ u \neq v $$$ ) — number vertices connect edge graph contain multiple edge self - loops guarantee graph a snowflake graph integers $$$ x $$$ $$$ y $$$ greater $$$ 1 $$$ test case a separate line output value $$$ x $$$ $$$ y $$$ order separate a space first test case picture statement note output 3 5 incorrect since $$$ x $$$ output $$$ y $$$,['math'],1300.0
1830/C,"give integer $$$ n $$$ $$$ k $$$ intervals $$$ i $$$ -th interval $$$ [ l_i r_i ] $$$ $$$ 1 \leq l_i \leq r_i \leq n $$$ let us call a regular bracket sequence $$$ ^ { \dagger \ddagger } $$$ length $$$ n $$$ hyperregular $$$ i $$$ $$$ 1 \leq i \leq k $$$ substring $$$ \overline { s _ { l_i } s _ { l _ { i } +1 } \ldots s _ { r_i } } $$$ also a regular bracket sequence task count number hyperregular bracket sequence since number really large require find modulo $$$ 998\,244\,353 $$$ $$$ ^\dagger $$$ a bracket sequence a string contain character ` ` ( ` ` ` ` ) '' $$$ ^\ddagger $$$ a bracket sequence call regular one turn a valid math expression add character + 1 . example sequence ( ( ) ) ( ) ( ) ( ( ) ( ( ) ) ) empty string regular ) ( ( ( ) ( ( ) ) ) ( test contain multiple test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 300000 $$$ $$$ 0 \le k \le 300000 $$$ ) — length hyperregular bracket sequence number intervals respectively follow $$$ k $$$ line test case contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l \le r \le n $$$ ) guarantee sum $$$ n $$$ across test case exceed $$$ 300000 $$$ sum $$$ k $$$ across test case exceed $$$ 300000 $$$ test case output number hyperregular bracket sequence modulo $$$ 998\,244\,353 $$$","['greedy', 'math']",2400.0
1832/E,recall binomial coefficient $$$ \binom { x } { y } $$$ calculate follow ( $$$ x $$$ $$$ y $$$ non - negative integers ) : give array $$$ a_1 a_2 \dots a_n $$$ integer $$$ k $$$ calculate a new array $$$ b_1 b_2 \dots b_n $$$ <unknown> $$$ b_i = ( \sum\limits _ { j=1 } ^ { i } \binom { i - j + 1 } { k } \cdot a_j ) \bmod 998244353 $$$ note array give a modify way output a modify way well line input contain six integers $$$ n $$$ $$$ a_1 $$$ $$$ x $$$ $$$ y $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n \le 10000000 $$$ ; $$$ 0 \le a_1 x y < m $$$ ; $$$ 2 \le m \le 998244353 $$$ ; $$$ 1 \le k \le 5 $$$ ) array $$$ [ a_1 a_2 \dots a_n ] $$$ generate follow : since output $$$ 10000000 $$$ integers might slow follow : let $$$ c_i = b_i \cdot i $$$ ( without take modulo $$$ 998244353 $$$ multiplication ) print integer $$$ c_1 \oplus c_2 \oplus \dots \oplus c_n $$$ $$$ \oplus $$$ denote bitwise xor operator,['dp'],2200.0
1833/A,"vlad decide compose a melody guitar let 's represent melody a sequence note correspond character ' a ' ' b ' ' c ' 'd ' ' e ' ' f ' ' g ' however vlad experience play guitar record exactly two note a time vlad want obtain melody $$$ s $$$ , merge record melodies together case last sound first melody must match first sound second melody example vlad record melodies ` ` ab '' ` ` ba '' merge together obtain melody ` ` aba '' merge result ` ` ab '' get ` ` abab '' help vlad determine minimum number melodies consist two note need record order obtain melody $$$ s $$$ first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow descriptions test case first line test case contain integer $$$ n $$$ ( $$$ 2 \le n \le 50 $$$ ) — length melody $$$ s $$$ second line test case contain a string $$$ s $$$ length $$$ n $$$ consist character ' a ' ' b ' ' c ' 'd ' ' e ' ' f ' ' g ' output $$$ t $$$ integers represent answer correspond test case answer output minimum number melodies consist two note vlad need record first sample need record melodies ` ` ab '' ` ` ba '' describe problem statement second sample need record melodies ` ` ab '' ` ` ba '' ` ` ac '' ` ` ca '' third sample necessary melody ` ` aa ''",['implementation'],800.0
1833/C,"vlad give array $$$ a $$$ $$$ n $$$ positive integers want build a beautiful array $$$ b $$$ length $$$ n $$$ vlad consider array beautiful number positive parity , number beautiful array greater zero either even odd build array $$$ b $$$ vlad assign $$$ b_i $$$ either value $$$ a_i $$$ $$$ a_i - a_j $$$ $$$ j $$$ $$$ 1 $$$ $$$ n $$$ choose avoid try impossible vlad ask determine whether possible build a beautiful array $$$ b $$$ length $$$ n $$$ use array $$$ a $$$ first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow descriptions test case first line case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length array $$$ a $$$ second line case contain $$$ n $$$ positive integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements array $$$ a $$$ guarantee sum $$$ n $$$ case exceed $$$ 200000 $$$ output $$$ t $$$ string answer correspond test case answer output ` ` yes '' vlad build a beautiful array $$$ b $$$ ` ` '' otherwise output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer )","['greedy', 'math']",800.0
1834/C,alice bob play a game two string $$$ s $$$ $$$ t $$$ length $$$ n $$$ consist lowercase latin letter players take turn alternately alice go first turn alice choose integer $$$ i $$$ $$$ 1 $$$ $$$ n $$$ one string $$$ s $$$ $$$ t $$$ lowercase latin letter $$$ c $$$ replace $$$ i $$$ -th symbol choose string character $$$ c $$$ turn bob choose one string $$$ s $$$ $$$ t $$$ reverse formally bob make replacement $$$ s : = \operatorname { rev } ( s ) $$$ $$$ t : = \operatorname { rev } ( t ) $$$ $$$ \operatorname { rev } ( p ) = p_n p _ { n-1 } \ldots p_1 $$$ game last string $$$ s $$$ $$$ t $$$ equal soon string become equal game end instantly define duration game total number move make players game example alice make $$$ 2 $$$ move total bob make $$$ 1 $$$ move duration game $$$ 3 $$$ alice 's goal minimize duration game bob 's goal maximize duration game duration game players play optimally ? show game end a finite number turn test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length string $$$ s $$$ $$$ t $$$ second line test case contain a string $$$ s $$$ length $$$ n $$$ consist lowercase latin letter third line test case contain a string $$$ t $$$ length $$$ n $$$ consist lowercase latin letter guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output a single number a separate line — duration describe game players play optimally first test case turn alice replace third symbol string $$$ s $$$ x. string become equal ` ` <unknown> '' game end one move since alice 's goal finish game move possible move one optimal first move final answer $$$ 1 $$$ second test case turn alice replace fifth symbol string $$$ t $$$ h. move $$$ s = $$$ ` ` hello '' $$$ t = $$$ ` ` olleh '' bob make turn turn must reverse one string bob choose string $$$ s $$$ turn string equal ` ` olleh '' choose string $$$ t $$$ turn string equal ` ` hello '' thus present first move alice game definitely end $$$ 2 $$$ move show strategy alice finish game less $$$ 2 $$$ move players play optimally final answer $$$ 2 $$$ third test case first move alice replace second symbol string $$$ s $$$ c. move $$$ s = $$$ ` ` ac '' $$$ t = $$$ ` ` cd '' bob make turn bob reverse string $$$ s $$$ turn $$$ s = $$$ ` ` ca '' $$$ t = $$$ ` ` cd '' easy see case alice definitely finish game $$$ 3 $$$ -rd move replace second symbol string $$$ t $$$ a string become equal ` ` ca '' bob reverse string $$$ t $$$ turn $$$ s = $$$ ` ` ac '' $$$ t = $$$ ` ` dc '' case alice also definitely finish game $$$ 3 $$$ rd move replace first symbol string $$$ s $$$ d string become equal ` ` dc '' thus alice definitely finish game $$$ 3 $$$ move regardless bob 's move show game end less $$$ 3 $$$ move players play optimally fifth test case string $$$ s $$$ $$$ t $$$ equal game end without start $$$ 0 $$$ move,"['greedy', 'math']",1200.0
1834/E,"give array $$$ a $$$ length $$$ n $$$ a positive integer $$$ x $$$ call good impossible find a subsegment $$$ ^ { \dagger } $$$ array least common multiple elements equal $$$ x $$$ need find smallest good integer a subsegment $$$ ^ { \dagger } $$$ array $$$ a $$$ a set elements $$$ a_l a _ { l + 1 } \ldots a_r $$$ $$$ 1 \le l \le r \le n $$$ denote subsegment $$$ [ l r ] $$$ test consist multiple test case first line test case contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 50000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 300000 $$$ ) — length array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — elements array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 300000 $$$ test case output a single integer — smallest good integer first test case $$$ 4 $$$ a good integer smallest one since integers $$$ 1,2,3 $$$ appear array mean subsegments array length $$$ 1 $$$ least common multiples $$$ 1,2,3 $$$ however impossible find a subsegment array a least common multiple equal $$$ 4 $$$ second test case $$$ 7 $$$ a good integer integers $$$ 1,2,3,4,5 $$$ appear explicitly array integer $$$ 6 $$$ least common multiple subsegments $$$ [ 2 3 ] $$$ $$$ [ 1 3 ] $$$ third test case $$$ 1 $$$ a good integer since least common multiples integer subsegments $$$ [ 1 1 ] [ 1 2 ] [ 2 2 ] $$$ $$$ <unknown> $$$ respectively","['data structures', 'implementation', 'math']",2300.0
1839/A,give two integers $$$ n $$$ $$$ k $$$ array $$$ a_1 a_2 \ldots a_n $$$ length $$$ n $$$ consist zero ones good integers $$$ i $$$ $$$ 1 $$$ $$$ n $$$ follow condition satisfy : $$$ \lceil \frac { i } { k } \rceil $$$ denote result division $$$ i $$$ $$$ k $$$ round example $$$ \lceil \frac { 6 } { 3 } \rceil = 2 $$$ $$$ \lceil \frac { 11 } { 5 } \rceil = \lceil <unknown> \rceil = 3 $$$ $$$ \lceil \frac { 7 } { 4 } \rceil = \lceil <unknown> \rceil = 2 $$$ find minimum possible number ones a good array test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 100 $$$ $$$ 1 \le k \le n $$$ ) — length array parameter $$$ k $$$ statement test case output one integer — minimum possible number ones a good array show give constraints least one good array always exist first test case $$$ n = 3 $$$ $$$ k = 2 $$$ : thus answer $$$ 2 $$$ second test case $$$ n = 5 $$$ $$$ k = 2 $$$ : third test case $$$ n = 9 $$$ $$$ k = 3 $$$ : fourth test case $$$ n = 7 $$$ $$$ k = 1 $$$ good array $$$ [ \ 1 1 1 1 1 1 1\ ] $$$ answer $$$ 7 $$$,"['greedy', 'implementation', 'math']",800.0
1839/B,$$$ n $$$ lamps number integers $$$ 1 $$$ $$$ n $$$ lamp $$$ i $$$ two integer parameters $$$ a_i $$$ $$$ b_i $$$ moment lamp one three state : may turn turn break initially lamps turn one operation select one lamp turn turn ( ca n't turn break lamps ) receive $$$ b_i $$$ point turn lamp $$$ i $$$ follow happen perform operation : please note break lamps never count turn a turn lamp break still keep point receive turn perform arbitrary number operations find maximum number point get first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number lamps next $$$ n $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i \le n 1 \le b_i \le 1000000000 $$$ ) — parameters $$$ i $$$ -th lamp guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case output one integer — maximum number point get first test case $$$ n = 4 $$$ one ways get maximum number point follow : receive $$$ 13 + 2 = 15 $$$ point total show maximum number point get answer first test case $$$ 15 $$$ second test case one ways get maximum number point follow : receive $$$ 2 + 5 + 4 + 3 = 14 $$$ point total show maximum number point get third test case one ways get maximum number point follow : receive $$$ 4 + 4 + 3 + 4 + 5 = 20 $$$ point total show maximum number point get,['greedy'],1100.0
1840/B,upon a time toma find a binary cafe a popular unusual place cafe offer visitors $$$ k $$$ different delicious desserts desserts number $$$ 0 $$$ $$$ k-1 $$$ cost $$$ i $$$ -th dessert $$$ 2^i $$$ coin a binary cafe ! toma will spend $$$ n $$$ coin taste desserts time interest buy dessert one enough evaluate taste many different ways buy several desserts ( possibly zero ) taste ? first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case follow $$$ t $$$ line describe one test case test case give a single line consist two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 1000000000 $$$ ) — number coin toma will spend number desserts binary cafe output $$$ t $$$ integers $$$ i $$$ -th equal answer $$$ i $$$ -th test case — number ways buy desserts taste variants 1st sample : { } { 1 } variants 2nd sample : { } { 1 } variants 3rd sample : { } { 1 } { 2 } variants 4th sample : { } { 1 } { 2 } { 1 2 },['math'],1100.0
1840/G1,"difference easy hard versions maximum number query version allow ask $$$ 2023 $$$ query interactive problem play a game circle divide $$$ n $$$ sectors sectors number $$$ 1 $$$ $$$ n $$$ order adjacent room know either number sectors number also arrow initially point sector initially host tell number sector arrow point , ask host move arrow $$$ k $$$ sectors counterclockwise clockwise $$$ 2023 $$$ time time tell number sector arrow point task determine integer $$$ n $$$ — number sectors $$$ 2023 $$$ query guarantee $$$ 1 \le n \le 1000000 $$$ input consist a single integer $$$ x $$$ ( $$$ 1 \le x \le n $$$ ) — number initial sector determine integer $$$ n $$$ — number sectors output ` ` ! n '' ( $$$ 1 \le n \le 1000000 $$$ ) program immediately terminate note print answer count a query guarantee integer $$$ n $$$ number sectors fix initially change jury program depend query read description input may ask query query two type : query read integer $$$ x $$$ ( $$$ 1 \le x \le n $$$ ) — number current sector arrow point allow make $$$ 2023 $$$ query total make many query get wrong answer print a query answer forget output a end line flush output otherwise get idleness limit exceed , use : hacksto hack use follow test format first line output a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — number sectors second line output $$$ n $$$ different integers $$$ 1 \le a_1 a_2 \dots a_n \le n $$$ — number sectors clockwise order arrow initially point sector number $$$ a_1 $$$",['math'],2200.0
1842/C,tenzing $$$ n $$$ ball arrange a line color $$$ i $$$ -th ball leave $$$ a_i $$$ tenzing follow operation number time : tenzing want know maximum number ball remove test contain multiple test case first line input contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 1000 $$$ ) — number test case description test case follow first line contain a single integer $$$ n $$$ ( $$$ 1\leq n\leq 2\cdot 100000 $$$ ) — number ball second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1\leq a_i \leq n $$$ ) — color ball guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case output maximum number ball tenzing remove first example tenzing choose $$$ i=2 $$$ $$$ j=3 $$$ first operation $$$ a= [ <unknown> ] $$$ tenzing choose $$$ i=2 $$$ $$$ j=3 $$$ second operation $$$ a= [ 1 ] $$$ tenzing remove $$$ 4 $$$ ball total second example tenzing choose $$$ i=1 $$$ $$$ j=3 $$$ first operation $$$ a= [ 2 ] $$$ tenzing remove $$$ 3 $$$ ball total,['dp'],1500.0
1843/A,sasha find array $$$ a $$$ consist $$$ n $$$ integers ask paint elements paint element array use many color want element paint exactly one color color least one element color cost one color value $$$ \max ( s ) - \min ( s ) $$$ $$$ s $$$ sequence elements color cost whole color sum cost color example suppose array $$$ a = [ \color { red } { 1 } \color { red } { 5 } \color { blue } { 6 } \color { blue } { 3 } \color { red } { 4 } ] $$$ paint elements two color follow : elements position $$$ 1 $$$ $$$ 2 $$$ $$$ 5 $$$ color $$$ 1 $$$ ; elements position $$$ 3 $$$ $$$ 4 $$$ color $$$ 2 $$$ : give array $$$ a $$$ calculate maximum possible cost color first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — length $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq 50 $$$ ) — array $$$ a $$$ test case output maximum possible cost color first example one optimal color $$$ [ \color { red } { 1 } \color { red } { 5 } \color { blue } { 6 } \color { blue } { 3 } \color { red } { 4 } ] $$$ answer $$$ ( 5 - 1 ) + ( 6 - 3 ) = 7 $$$ second example possible color $$$ [ \color { blue } { 5 } ] $$$ answer $$$ 5 - 5 = 0 $$$ third example optimal color $$$ [ \color { blue } { 1 } \color { red } { 6 } \color { red } { 3 } \color { blue } { 9 } ] $$$ answer $$$ ( 9 - 1 ) + ( 6 - 3 ) = 11 $$$,['greedy'],800.0
1843/D,timofey apple tree grow garden ; a root tree $$$ n $$$ vertices root vertex $$$ 1 $$$ ( vertices number $$$ 1 $$$ $$$ n $$$ ) a tree a connect graph without loop multiple edge tree unusual — grow root upwards however 's quite normal programmer 's tree apple tree quite young two apples grow apples grow certain vertices ( vertices may ) apples grow timofey start shake apple tree apples fall time timofey shake apple tree follow happen apples : let apple vertex $$$ u $$$ show a finite time apples fall tree timofey $$$ q $$$ assumptions vertices apples grow assume apples grow vertices $$$ x $$$ $$$ y $$$ want know number pair vertices ( $$$ a $$$ $$$ b $$$ ) apples fall tree $$$ a $$$ — vertex apple vertex $$$ x $$$ fall $$$ b $$$ — vertex apple vertex $$$ y $$$ fall help first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 200000 $$$ ) — number vertices tree $$$ n - 1 $$$ line describe tree line $$$ i $$$ two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ u_i \ne v_i $$$ ) — edge tree next line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 200000 $$$ ) — number timofey 's assumptions next $$$ q $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \leq x_i y_i \leq n $$$ ) — suppose vertices apples grow assumption $$$ i $$$ guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ similarly guarantee sum $$$ q $$$ exceed $$$ 200000 $$$ timofey 's assumption output number order pair vertices apples fall tree assumption true a separate line first example : second example $$$ 4 $$$ possible pair vertices apples fall : $$$ ( 2 3 ) ( 2 2 ) ( 3 2 ) ( 3 3 ) $$$ second assumption one possible pair : $$$ ( 2 3 ) $$$ third assumption two pair : $$$ ( 3 2 ) ( 3 3 ) $$$,"['dp', 'math']",1200.0
1843/F2,hard version problem difference simple hard versions version $$$ u $$$ take possible value know omsk capital berland like capital omsk a well - developed metro system omsk metro consist a certain number station connect tunnel two station exactly one path pass tunnel word metro a tree develop metro attract residents follow system use omsk station weight $$$ x \in \ { -1 1\ } $$$ station a weight $$$ -1 $$$ station visit omsk resident a fee $$$ 1 $$$ burle charge weight station $$$ 1 $$$ omsk resident reward $$$ 1 $$$ burle omsk metro currently one station number $$$ 1 $$$ weight $$$ x = 1 $$$ every day one follow events occur : a friend alex task answer alex 's question $$$ \dagger $$$ subsegment — continuous sequence elements first line contain a single number $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case first line test case contain number $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — number events $$$ n $$$ line describe events $$$ i $$$ -th line one follow options possible : guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ alex 's question output ` ` yes '' ( without quote ) subsegment describe condition exist otherwise output ` ` '' ( without quote ) output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ) explanation first sample answer second question ` ` yes '' a path $$$ 1 $$$ fourth question choose $$$ 1 $$$ path fifth query answer ` ` yes '' since a path $$$ 1 - 3 $$$ sixth query choose empty path sum weight $$$ 0 $$$ difficult show paths satisfy first third query,"['data structures', 'dp', 'math']",2300.0
188/H,problem 'll use a stack support two type operations : give a string describe sequence operations perform stack i - th character correspond i - th operation : initially stack empty output topmost number stack execute give operations line input contain a string operations consist character « + » « * » digits ( 0 .. 9 ) length string 1 20 character inclusive give sequence operations guarantee correct i.e stack least two elements every math operation number stack never exceed 106 . output a single number — topmost element stack perform give operations first case stack end contain a single number — result calculate ( 1 + 2 ) * 3 + 6 * 6 . second case math operations answer last number push stack,['implementation'],1800.0
189/A,polycarpus a ribbon length n. want cut ribbon a way fulfil follow two condition : help polycarpus find number ribbon piece require cut first line contain four space - separated integers n a b c ( 1 ≤ n a b c ≤ 4000 ) — length original ribbon acceptable lengths ribbon piece cut correspondingly number a b c coincide print a single number — maximum possible number ribbon piece guarantee least one correct ribbon cut exist first example polycarpus cut ribbon way : first piece length 2 second piece length 3 . second example polycarpus cut ribbon way : first piece length 5 second piece length 2,['dp'],1300.0
19/A,everyone know 2010 fifa world cup hold south <unknown> decision bfa ( berland 's football association ) next world cup hold berland bfa take decision change world cup regulations : ask write a program give list compete team result match find list team manage get knockout stage first input line contain integer n ( 1 ≤ n ≤ 50 ) — amount team take part final tournament world cup follow n line contain name team a name a string lower - case upper - case latin letter length n't exceed 30 character follow n · ( n - 1 ) / 2 line describe hold match format name1 - name2 num1 : num2 name1 name2 — name team ; num1 num2 ( 0 ≤ num1 num2 ≤ 100 ) — amount goals score correspond team accuracy descriptions guarantee : two team name coincide accurate letter ' case ; match a team play ; match meet descriptions output n / 2 line — name team manage get knockout stage lexicographical order output name a separate line odd character ( include space ) allow 's guarantee describe regulations help order team without ambiguity,['implementation'],1400.0
190/A,one day vasya hear a story : ` ` city high bertown a bus number 62 leave bus station n grown - ups m kid ... '' latter events happen importance us vasya accountant love count money wonder maximum minimum sum money passengers could pay ride bus fare equal one berland ruble high bertown however everything easy — one child ride free grown - up passenger mean a grown - up passenger rid k ( k > 0 ) children pay overall k rubles : a ticket ( k - 1 ) ticket children also a grown - up ride without children case pay one ruble know high bertown children ca n't ride a bus <unknown> grown - ups help vasya count minimum maximum sum berland rubles passengers bus could pay total input file consist a single line contain two space - separated number n m ( 0 ≤ n m ≤ 105 ) — number grown - ups number children bus correspondingly n grown - ups m children could ride bus print a single line two space - separated integers — minimum maximum possible total bus fare correspondingly otherwise print ` ` impossible '' ( without quote ) first sample a grown - up rid two children pay two rubles second sample children bus situation impossible,"['greedy', 'math']",1100.0
191/A,"ancient berlanders believe longer name important <unknown> thus berland kings famous long name long name somewhat inconvenient berlanders start abbreviate name kings call every king first letter name thus king whose name victorious vasily <unknown> always call berlanders <unknown> berland long history many dynasties kings replace unite common traditions thus accord one berland traditions maintain stability country first name heir last name predecessor ( hence first letter abbreviate name heir coincide last letter abbreviate name predecessor ) berlanders appreciate stability tradition never break also berlanders like <unknown> another tradition require first name first king dynasty coincide last name last king dynasty ( hence first letter abbreviate name first king coincide last letter abbreviate name last king ) tradition course also always observe name a dynasty form simple rule : take short name kings order rule write one line thus a dynasty kings ` ` ab '' ` ` ba '' call ` ` abba '' dynasty king ` ` abca '' call ` ` abca '' vasya a <unknown> recently find a list abbreviate name berland kings relatives help vasya find maximally long name dynasty could exist berland note list name order time , name a earlier list b a b kings king a rule king b. first line contain integer n ( 1 ≤ n ≤ 5·105 ) — number name vasya 's list next n line contain n abbreviate name one per line abbreviate name a non - empty sequence lowercase latin letter length exceed 10 character print a single number — length seek dynasty 's name letter vasya 's list wrong dynasty find print a single number 0 . first sample two dynasties exist : one call ` ` <unknown> '' ( first second kings ) one call ` ` abccba '' ( first third kings ) second sample n't acceptable dynasties dynasty third sample consist one king name ` ` c ''",['dp'],1500.0
195/E,orient weight forest acyclic weight <unknown> vertex one edge go root vertex v orient weight forest a vertex edge go reach vertex v move along edge weight orient forest denote root vertex v root ( v ) depth vertex v sum weight paths pass vertex v root let 's denote depth vertex v depth ( v ) let 's consider process construct a weight direct forest initially forest contain vertices vertices add sequentially one one overall n perform operations add i - th ( i > 0 ) add operation describe a set number ( k v1 x1 v2 x2 ... vk xk ) mean add vertex number i k edge graph : edge vertex root ( v1 ) vertex i weight depth ( v1 ) + x1 edge vertex root ( v2 ) vertex i weight depth ( v2 ) + x2 k = 0 vertex i add graph add edge task like : give operations add vertices calculate sum weight edge forest result application define operations modulo 1000000007 ( 109 + 7 ) first line contain a single integer n ( 1 ≤ n ≤ 105 ) — number operations add a vertex next n line contain descriptions operations i - th line contain description operation add i - th vertex follow format : first number a line integer k ( 0 ≤ k ≤ i - 1 ) follow 2k space - separated integers : v1 x1 v2 x2 ... vk xk ( 1 ≤ vj ≤ i - 1 <unknown> ≤ 109 ) operations give order apply graph guarantee sum k operations exceed 105 also apply operations add vertexes result loop multiple edge print a single number — sum weight edge result graph modulo 1000000007 ( 109 + 7 ) <unknown> first sample : result graph show <unknown> :,['data structures'],2000.0
200/E,students still sit exams tractor college complete summer exam session fact students study one subject college — art operate a tractor therefore end a term a student get one mark a three ( satisfactory ) a four ( good ) a five ( excellent ) score lower mark unfortunately expel college n students <unknown> enough scholarship size scholarships vary term since end - of - the - term exam end 's time determine size scholarship end next term <unknown> budget scholarships tractor college s rubles distribute budget optimally must follow rule : give result exam budget size s find optimal distribution scholarship first line two integers n s ( 3 ≤ n ≤ 300 1 ≤ s ≤ 3·105 ) — number students budget size scholarship respectively second line contain n integers i - th number represent mark i - th student get exam guarantee mark give least one student a single line print three integers k3 <unknown> k5 — seek value represent optimal distribution scholarships multiple optimal answer print answer print -1,"['implementation', 'math']",2400.0
201/C,play a video game reach bonus level possible goal score many point possible a perfectionist ' ve decide wo n't leave level ' ve gain maximum possible number point bonus level consist n small platforms place a line number 1 n leave right ( n - 1 ) bridge connect adjacent platforms bridge platforms fragile bridge number time one pass bridge one end collapse forever know advance player 's action follow first select one platforms start position hero player freely move hero across platforms move undestroyed bridge soon hero find a platform undestroyed bridge attach level automatically end number point score player end level calculate number transition make hero platforms note hero start move a certain bridge continue move direction a platform find many point need score sure nobody beat record move next level a quiet heart first line contain a single integer n ( 2 ≤ n ≤ 105 ) — number platforms bonus level second line contain ( n - 1 ) integers ai ( 1 ≤ ai ≤ 109 1 ≤ i < n ) — number transition one end bridge platforms i i + 1 bear print a single integer — maximum number point a player get bonus level please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier one possibility get 5 point sample start platform 3 consequently move platforms 4 3 2 1 2 . undestroyed bridge bridge platforms 4 5 bridge far platform 2 hero locate,['dp'],2000.0
203/B,"one particularly beautiful even valera get bore amuse a little bite find follow game take a checker white square piece paper consist n × n cells , start paint white cells black one total paint m different cells piece paper since valera keen everything square wonder many move ( i.e time boy paint a square black ) make till a black square side 3 find piece paper valera know answer question ask help task find minimum number move till checker piece paper least one black square side 3 . otherwise determine move exist first line contain two integers n m ( 1 ≤ n ≤ 1000 1 ≤ m ≤ min ( <unknown> 105 ) ) — size square piece paper number move correspondingly , m line contain description move i - th line contain two integers xi yi ( 1 ≤ xi yi ≤ n ) — number row column square get paint i - th move number line separate single space guarantee move different move number start 1 order give input columns square piece paper number start 1 leave right row square piece paper number start 1 top bottom a single line print answer problem — minimum number move piece paper a black square side 3 . move exist print -1",['implementation'],1300.0
203/D,valera play football a stadium suddenly begin rain valera hide corridor <unknown> get wet however desire play great decide train hit ball right corridor valera go back far enough put ball hit ball bounce wall ceiling floor corridor finally hit exit door ball wet leave a spot door valera want know coordinate spot let 's describe event formally ball consider a point space door corridor consider a rectangle locate plane <unknown> lower leave corner door locate point ( 0 0 0 ) upper right corner locate point ( a 0 b ) corridor consider a rectangular parallelepiped infinite direction increase coordinate y. corridor floor consider plane xoy ceiling plane parallel xoy pass point ( a 0 b ) also assume one wall plane yoz wall plane parallel yoz pass point ( a 0 b ) 'll say ball hit door coordinate y equal 0 . thus coordinate spot point ( x0 0 z0 ) 0 ≤ x0 ≤ a 0 ≤ z0 ≤ b. hit ball valera step away door distance m put ball center corridor point hit ball fly speed ( vx vy vz ) mean ball coordinate ( x y z ) one second coordinate ( x + vx y + vy z + vz ) see image note clarification ball collide ceiling floor a wall corridor bounce accordance laws reflection ( angle incidence equal angle reflection ) problem consider ideal physical model assume air resistance <unknown> force loss energy first line contain three space - separated integers a b m ( 1 ≤ a b m ≤ 100 ) first two integers specify point ( a 0 b ) ceiling one corridor wall pass third integer distance valera go away door second line three space - separated integers vx vy vz ( <unknown> <unknown> <unknown> ≤ 100 vy < 0 vz ≥ 0 ) — speed ball hit guarantee ball hit door print two real number x0 z0 — x z coordinate point ( x0 0 z0 ) ball hit exit door answer consider correct absolute relative error exceed 10 - 6,"['implementation', 'math']",1700.0
203/E,valera come japan buy many robots research 's already airport plane fly soon valera urgently need bring robots luggage compartment robots self - <unknown> ( <unknown> move ) even compartments carry robots precisely i - th robot know value ci — number robots carry case ci transport robots additionally carry robots however robots need fill fuel go valera spend last money buy s liters fuel learn robot a restriction travel distance thus addition feature ci i - th robot two feature fi li — amount fuel ( liters ) need move i - th robot maximum distance robot go due limit amount time fuel valera want move maximum number robots luggage compartment operate follow d meter luggage compartment therefore robots carry rest must feature li less d. move valera stop change location robots way help valera calculate maximum number robots able take home minimum amount fuel spend remain fuel come <unknown> valera 's research first line contain three space - separated integers n d s ( 1 ≤ n ≤ 105 1 ≤ d s ≤ 109 ) first number represent number robots second one — distance luggage compartment third one — amount available fuel next n line specify robots i - th line contain three space - separated integers ci fi li ( 0 ≤ ci fi li ≤ 109 ) — i - th robot 's feature first number number robots i - th robot carry second number amount fuel need i - th robot move third one show maximum distance i - th robot go print two space - separated integers — maximum number robots valera transport luggage compartment minimum amount fuel need valera wo n't manage get robots luggage compartment print two zero,['greedy'],2300.0
204/A,little elephant much love sum intervals time a pair integers l r ( l ≤ r ) little elephant find number integers x ( l ≤ x ≤ r ) first digit integer x equal last one ( decimal notation ) example number 101 <unknown> 9 include answer 47 <unknown> <unknown> help count number describe number x a give pair l r. single line contain a pair integers l r ( 1 ≤ l ≤ r ≤ 1018 ) — boundaries interval please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier a single line print a single integer — answer problem first sample answer include integers 2 3 4 5 6 7 8 9 11 22 33 44,['dp'],1500.0
205/B,little elephant love sort array a consist n integers let 's number array elements 1 n i - th element denote ai little elephant make one move choose arbitrary pair integers l r ( 1 ≤ l ≤ r ≤ n ) increase ai 1 i l ≤ i ≤ r. help little elephant find minimum number move need convert array a arbitrary array sort non - decreasing order array a consist n elements sort non - decreasing order i ( 1 ≤ i < n ) ai ≤ ai + 1 hold first line contain a single integer n ( 1 ≤ n ≤ 105 ) — size array a. next line contain n integers separate single space — array a ( 1 ≤ ai ≤ 109 ) array elements list line order index 's increase a single line print a single integer — answer problem please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first sample array already sort non - decreasing order answer 0 . second sample need perform two operations : first increase number second third ( array : [ 3 3 2 ] ) second increase last element ( array : [ 3 3 3 ] ) third sample make least 6 step possible sequence operations : ( 2 ; 3 ) ( 2 ; 3 ) ( 2 ; 3 ) ( 3 ; 3 ) ( 3 ; 3 ) ( 3 ; 3 ) array convert [ 7 7 7 47 ],['greedy'],1400.0
21/B,give two set point first set determine equation <unknown> + <unknown> + c1 = 0 second one determine equation <unknown> + <unknown> + c2 = 0 . write program find number point intersection two give set first line input contain three integer number a1 b1 c1 separate space second line contain three integer number a2 b2 c2 separate space number -100 100 inclusive print number point intersection -1 infinite number point,"['implementation', 'math']",2000.0
215/B,"world program olympics medal a metal disk consist two part : first part a ring outer radius r1 cm inner radius r2 cm ( 0 < r2 < r1 ) make metal density p1 g / cm3 second part inner disk radius r2 cm make metal density p2 g / cm3 disk nest inside ring olympic jury decide r1 take one possible value x1 x2 ... xn jury decide particular value r1 take similarly olympic jury decide p1 take one possible value y1 y2 ... ym p2 take a value list z1 z2 ... zk accord ancient traditions ratio outer ring mass mout inner disk mass min must equal a b constants take ancient book , start make medals jury need take value r1 p1 p2 calculate suitable value r2 jury want choose value would maximize radius r2 help jury find seek value r2 value r2 n't integer medal a uniform thickness throughout area thickness inner disk thickness outer ring first input line contain integer n a sequence integers x1 x2 ... xn second input line contain integer m a sequence integers y1 y2 ... ym third input line contain integer k a sequence integers z1 z2 ... zk last line contain two integers a b. number give input positive exceed 5000 . three sequence contain distinct number number line separate space print a single real number — seek value r2 absolute relative error 10 - 6 . guarantee solution meet problem requirements exist first sample jury choose follow value : r1 = 3 p1 = 2 p2 = 1","['greedy', 'math']",1300.0
215/C,a board a grid consist n row m columns row number 1 top bottom columns number 1 leave right grid denote cell lie row number i column number j ( i j ) a group six number ( a b c d x0 y0 ) 0 ≤ a b c d a cross a set cells assign cell ( x y ) belong set least one two condition fulfil : task find number different group six number ( a b c d x0 y0 ) determine cross area equal s place entirely grid cross place entirely grid cells range grid ( cell ( x y ) cross 1 ≤ x ≤ n ; 1 ≤ y ≤ m hold ) area cross number cells note two cross consider distinct order group six number denote distinct even cross coincide set point input consist a single line contain three integers n m s ( 1 ≤ n m ≤ 500 1 ≤ s ≤ n·m ) integers separate a space print a single integer — number distinct group six integers denote cross area s fully place n × m grid please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first sample seek group six number : ( 0 0 0 0 1 1 ) ( 0 0 0 0 1 2 ) ( 0 0 0 0 2 1 ) ( 0 0 0 0 2 2 ) second sample seek group six number : ( 0 1 1 0 2 2 ) ( 0 1 1 0 2 3 ) ( 1 0 0 1 2 2 ) ( 1 0 0 1 2 3 ),['implementation'],2100.0
216/A,several age ago berland a kingdom king berland adore math 's first visit one many palaces first pay attention floor one hall floor tile hexagonal tile hall also turn hexagonal shape king walk along perimeter hall conclude six side a b c a b c adjacent tile correspondingly better <unknown> situation look picture show a similar hexagon a = 2 b = 3 c = 4 . accord legend king berland obtain value a b c almost immediately calculate total number tile hall floor ? first line contain three integers : a b c ( 2 ≤ a b c ≤ 1000 ) print a single number — total number tile hall floor,"['implementation', 'math']",1200.0
221/B,little elephant love number a positive integer x. little elephant want find number positive integers d d divisor x x d least one common ( ) digit decimal representations help little elephant find describe number a single line contain a single integer x ( 1 ≤ x ≤ 109 ) a single line print integer — answer problem,['implementation'],1300.0
225/D,"let us remind rule a popular game call ` ` snake '' ( sometimes ` ` <unknown> '' ` ` python '' ` ` worm '' ) game field represent n × m rectangular table square field consider impassable ( wall ) square field passable control a snake snake consist segment segment take exactly one passable square field passable square contain one segment segment index integers 1 k k snake 's length 1 - th segment head k - th segment tail i ( 1 ≤ i < k ) segment index i i + 1 locate adjacent square field , square share a common side one passable field square contain apple snake 's aim reach apple eat ( position head square apple ) snake move throughout game one move snake move head adjacent field square segment follow head , segment number i ( 1 < i ≤ k ) move square segment number i - 1 . consider segment include head move simultaneously ( see second test sample ) snake 's head move <unknown> square square occupy segment snake die 's consider move <unknown> task determine minimum number valid move snake need reach apple first line contain two space - separated integers n m ( 1 ≤ n m ≤ 15 ) — number row columns game field next n line describe game field line contain m character character ` ` # '' represent a wall ` ` . '' a passable square ` ` @ '' apple snake 's first segment represent character ` ` 1 '' second one segment — character ` ` 2 '' game field description n't contain character besides ` ` # ' ` ` ` ` ` ` @ '' digits ( except 0 ) guarantee describe field correct guarantee describe field contain exactly one apple exactly one snake snake 's length least 3 9 . print a single integer output — minimum number move need reach apple snake ca n't reach apple print -1",['implementation'],2200.0
230/B,know prime number positive integers exactly two distinct positive divisors similarly 'll call a positive integer t т - prime t exactly three distinct positive divisors give array n positive integers determine whether т - prime first line contain a single positive integer n ( 1 ≤ n ≤ 105 ) show many number array next line contain n space - separated integers xi ( 1 ≤ xi ≤ 1012 ) please use % lld specifier read write 64 - bit integers с++ advise use cin cout stream % i64d specifier print n line : i - th line contain ` ` yes '' ( without quote ) number xi т - prime ` ` '' ( without quote ) n't give test three number first number 4 exactly three divisors — 1 2 4 thus answer number ` ` yes '' second number 5 two divisors ( 1 5 ) third number 6 four divisors ( 1 2 3 6 ) hence answer ` ` '',"['implementation', 'math']",1300.0
234/H,"two deck card lie table front card deck lay face lay face want merge one deck card face 're go two stag first stage merge two deck a way relative order card deck n't change , two different card i j one deck card i lie card j merge card i must also card j. second stage perform deck result first stage stage execute operation turn operation one turn take a top card turn put back thus take card get turn order card reverse , card bottom turn top task make sure card lie face find order merge card first stage sequence turn operations second stage make card lie face number turn minimum first input line contain a single integer n — number card first deck ( 1 ≤ n ≤ 105 ) second input line contain n integers separate single space a1 a2 ... ( 0 ≤ ai ≤ 1 ) value ai equal 0 i - th card lie face 1 card lie face card give order topmost one bottommost one third input line contain integer m — number card second deck ( 1 ≤ m ≤ 105 ) fourth input line contain m integers separate single space b1 b2 ... bm ( 0 ≤ bi ≤ 1 ) value bi equal 0 i - th card lie face 1 card lie face card give order topmost bottommost first line print n + m space - separated integers — number card order lie first stage list card top bottom card first deck match index 1 n order top bottom card second deck match index increase n , number n + 1 n + m order top bottom second line print a single integer x — minimum number turn operations need make card deck lie face third line print x integers : c1 c2 ... cx ( 1 ≤ ci ≤ n + m ) represent number card take top deck perform a turn operation print operations order perform multiple optimal solutions print guarantee minimum number operations n't exceed <unknown>",['greedy'],2000.0
236/A,days many boys use beautiful girls ' photos <unknown> forums pretty hard tell gender a user first glance last year hero go a forum a nice chat a beauty ( think ) talk often eventually become a couple network yesterday come see ` ` '' real world find ` ` '' actually a strong man ! hero sad tire love come a way recognize users ' genders user name method : number distinct character one 's user name odd a male otherwise a female give string denote user name please help hero determine gender user method first line contain a non - empty string contain lowercase english letter — user name string contain 100 letter a female hero 's method print ` ` chat ! '' ( without quote ) otherwise print ` ` ignore ! '' ( without quote ) first example 6 distinct character ` ` wjmzbmr '' character : ` ` w '' ` ` j '' ` ` m '' ` ` z '' ` ` b '' ` ` r '' wjmzbmr a female print ` ` chat ! ` `,['implementation'],800.0
237/A,valera run a <unknown> fast food cafe magically learn next day n people visit cafe person know arrival time : i - th person come exactly hi hours mi minutes cafe spend less a minute serve client a client come see free cash n't want wait leave cafe immediately valera greedy want serve n customers next day ( get profit ) however need ensure moment time number work cash less number clients cafe help valera count minimum number cash work cafe next day serve visitors first line contain a single integer n ( 1 ≤ n ≤ 105 ) number cafe visitors follow n line two space - separated integers hi mi ( 0 ≤ hi ≤ 23 ; 0 ≤ mi ≤ 59 ) represent time i - th person come cafe note time give chronological order time give within one 24 - hour period print a single integer — minimum number cash need serve clients next day first sample enough one cash serve clients two visitors come cafe <unknown> . therefore one cash cafe one customer serve another one wait go away second sample visitors come different time enough one cash,['implementation'],1000.0
237/B,"' ve get table a consist n row number 1 n. i - th line table a contain ci cells i ( 1 < i ≤ n ) hold ci ≤ ci - 1 . let 's denote s total number cells table a , know cell table contain a single integer 1 s write integers distinct let 's assume cells i - th row table a number 1 ci let 's denote number write j - th cell i - th row ai j. task perform several swap operations rearrange number table fulfill follow condition : one swap operation allow choose two different cells table swap record number number record first select cells swap write second cell similarly number record second select cells write first cell swap rearrange number require manner note allow perform number operations s. minimize number operations first line contain a single integer n ( 1 ≤ n ≤ 50 ) show number row table second line contain n space - separated integers ci ( 1 ≤ ci ≤ 50 ; ci ≤ ci - 1 ) — number cells correspond row next n line contain table а . i - th contain ci space - separated integers : j - th integer line represent ai j. guarantee give number ai j positive exceed s. guarantee ai j distinct first line print a single integer m ( 0 ≤ m ≤ s ) represent number perform swap next m line print description swap operations i - th line print four space - separated integers xi yi pi qi ( 1 ≤ xi pi ≤ n ; 1 ≤ yi ≤ <unknown> ; 1 ≤ qi ≤ <unknown> ) print number denote swap content cells axi yi api qi note a swap operation change content distinct table cells print swap order execute",['implementation'],1500.0
238/E,urpal live a big city plan meet lover tonight city n junctions number 1 n. junctions connect m direct streets roads equal length urpal live junction a date plan a restaurant junction b. want use public transportation get junction b. k bus transportation company begin every second a bus i - th company choose a random shortest path junction si junction ti pass might path si ti case bus leave si ti a bus pass a junction urpal stand get bus also get <unknown> bus junction along path urpal want know 's possible go date use public transportation a finite amount time ( time travel sum length travel roads ) minimum number bus take worst case moment urpal know position place date get bus know index company bus course urpal know city map pair ( si ti ) company note urpal n't know bus velocity first line input contain four integers n m a b ( 2 ≤ n ≤ 100 ; 0 ≤ m ≤ n · ( n - 1 ) ; 1 ≤ a b ≤ n ; a ≠ b ) next m line contain two integers ui vi ( 1 ≤ ui vi ≤ n ; ui ≠ vi ) describe a direct road junction ui junction vi roads input distinct next line contain integer k ( 0 ≤ k ≤ 100 ) k line contain two integers si ti ( 1 ≤ si ti ≤ n ; si ≠ ti ) say a bus route start si end ti please note might path si ti case describe problem statement line output print minimum number bus urpal get way worst case 's possible reach destination worst case print -1,['dp'],2600.0
241/C,mirror box a name a popular game <unknown> national amusement park ( <unknown> ) a wooden box 105 cm long 100 cm high game part box 's ceiling floor cover mirror two negligibly small hole opposite side box heights hl hr centimeters floor picture show box look like game give a laser gun shoot laser beam must enter one hole exit one mirror a preset number vi show number point players gain laser beam hit mirror also — make things even funnier — beam must hit mirror give information box task find maximum score a player may gain please note reflection obey law ` ` angle incidence equal angle reflection '' first line input contain three space - separated integers hl hr n ( 0 < hl hr < 100 0 ≤ n ≤ 100 ) — heights hole number mirror next n line contain descriptions mirror i - th line contain space - separated vi ci ai bi ; integer vi ( 1 ≤ vi ≤ 1000 ) score i - th mirror ; character ci denote i - th mirror 's position — mirror ceiling ci equal ` ` t '' floor ci equal ` ` f '' ; integers ai bi ( 0 ≤ ai < bi ≤ 105 ) represent x - coordinates begin end mirror two mirror share a common point consider x coordinate increase direction leave right border hole height hl x coordinate equal 0 border hole height hr x coordinate equal 105 . line output contain a single integer — maximum possible score a player could gain second sample depict red beam get 10 + 50 + 5 + 35 + 8 + 2 = 110 point blue one get 120 . red beam picture give statement show laser beam go approximately illustration laser beam gain score second sample beam gain score 110,['implementation'],2000.0
241/F,old city a rectangular city represent m × n grid block city contain many build straight two - way streets junctions junction build exactly one block streets width one block either vertical horizontal a junction side street call two block adjacent share a common side two block different streets adjacent two junctions adjacent annual festival a part old peykan follow a special path city path start a block a street continue many junctions end a block street street block know much time take old peykan go block adjacent block also old peykan go junction adjacent street block one minute course old peykan ca n't go build block know initial position old peykan sequence junctions pass reach destination pass junctions reach destination stay forever task find old peykan k minutes start move consider old peykan always follow shortest path pass give sequence junctions reach destination note old peykan may visit block first line input contain three integers m n k ( 3 ≤ m n ≤ 100 1 ≤ k ≤ 100000 ) next m line represent city 's map containts n character character a block : consider block coordinate : j - th i - th line coordinate ( i j ) ( 1 ≤ i ≤ m 1 ≤ j ≤ n ) ( m + 2 ) th line contain two integers rs cs ( 1 ≤ rs ≤ m 1 ≤ cs ≤ n ) string s another two integers ce ( 1 ≤ ≤ m 1 ≤ ce ≤ n ) path start block ( rs cs ) continue junctions order specify s end block ( ce ) length s 1 1000 . 's guarantee string s denote a correct path start position end position string s n't contain two consecutive equal letter also start position ( rs cs ) end position ( ce ) street block a single line print two integers rf cf — ( rf cf ) position old peykan exactly k minutes,['implementation'],2300.0
242/B,a coordinate line n segment i - th segment start position li end position ri denote a segment [ li ri ] suggest one define segment cover others word segment give set contain ones want test assumption find give set segment cover segment print number a segment n't exist print -1 . formally assume segment [ a b ] cover segment [ c d ] meet condition a ≤ c ≤ d ≤ b. first line contain integer n ( 1 ≤ n ≤ 105 ) — number segment next n line contain descriptions segment i - th line contain two space - separated integers li ri ( 1 ≤ li ≤ ri ≤ 109 ) — border i - th segment guarantee two segment coincide print a single integer — number segment cover segment set 's solution print -1 . segment number start 1 order appear input,['implementation'],1100.0
245/C,two pirate polycarpus vasily play a interest game n chests coin chests number integers 1 n. chest number i ai coin polycarpus vasily move turn polycarpus move first a move a player allow choose a positive integer x ( 2·x + 1 ≤ n ) take a coin chest number x 2·x 2·x + 1 . may turn chest coin case player n't take a coin chest game finish chests get empty polycarpus n't a greedy <unknown> <unknown> a lazy <unknown> wonder minimum number move game finish help polycarpus determine minimum number move game finish note polycarpus count move also count vasily 's move first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number chests coin second line contain a sequence space - separated integers : a1 a2 ... ( 1 ≤ ai ≤ 1000 ) ai number coin chest number i begin game print a single integer — minimum number move need finish game sequence turn lead finish game print -1 . first test case n't a single move make 's players wo n't able empty chests second sample one possible move x = 1 . move repeat least 3 time empty third chest,['greedy'],1700.0
246/C,"general payne a battalion n soldier soldier ' beauty contest come last k days payne decide battalion participate pageant choose participants soldier battalion different beauty represent a positive integer value ai represent beauty i - th soldier k days general send a detachment soldier pageant beauty detachment sum beauties soldier part detachment payne want surprise jury beauty pageant k days beauty send detachment unique word k beauties send detachments must distinct number help payne choose k detachments different beauties pageant please note payne forget send soldier one day , detachment soldier send pageant never empty first line contain two integers n k ( 1 ≤ n ≤ 50 ; 1 ≤ k ≤ ) — number soldier number days pageant correspondingly second line contain space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 107 ) — beauties battalion soldier guarantee payne 's battalion n't two soldier beauty print k line : i - th line print description detachment participate pageant i - th day description consist integer ci ( 1 ≤ ci ≤ n ) — number soldier detachment i - th day pageant ci distinct integers p1 i p2 i ... <unknown> i — beauties soldier detachment i - th day pageant beauties soldier allow print order separate number line space guarantee solution meet problem condition multiple solutions print",['greedy'],1600.0
248/D,christmas celebrations come whoville cindy lou parent lou lou <unknown> lou decide give sweets people street decide give residents house street one kilogram sweets need many kilos sweets home street street lou family live represent n consecutive section equal length go section a neighbour one one unit time section one three type : empty piece land a house a shop cindy lou family buy sweets a shop one kilogram sweets one shop ( <unknown> care residents whoville overeat sweets ) lou family leave home first section road get section road also require one unit time assume cindy mom dad carry unlimited number kilograms sweets every time a house section give a kilogram sweets inhabitants house simply move another section family already give sweets residents a house ca n't similarly shop section either buy a kilo sweets skip shop ' ve buy a kilo sweets a shop seller shop remember wo n't sell a single candy come time buy give sweets neglect lou who s want people house remain without food lou who s want spend t time units time give sweets really want enough time prepare christmas celebration order time give sweets may initially bring additional k kilos sweets cindy lou want know minimum number k kilos sweets need take time give sweets residents house street task write a program determine minimum possible value k. first line input contain two space - separated integers n t ( 2 ≤ n ≤ 5·105 1 ≤ t ≤ 109 ) second line input contain n character i - th equal ` ` h '' ( i - th segment contain a house ) ` ` s '' ( i - th segment contain a shop ) ` ` . '' ( i - th segment n't contain a house a shop ) guarantee least one segment a house n't a single value k make possible give sweets everybody t units time print a single line ` ` -1 '' ( without quote ) otherwise print a single line minimum possible value k. first example many store house family take a single kilo sweets home order treat inhabitants first house need make least one step back absolutely time take one kilogram sweets wo n't need go back second example number shop equal number house plenty time available store pass candy one direction give pass opposite direction third example shop street fewer house lou who s take miss number kilograms sweets home,"['greedy', 'implementation']",2300.0
252/A,little petya like array consist non - negative integers a lot recently mom present one array consist n elements petya immediately decide find a segment consecutive elements xor number segment maximal possible help xor operation bitwise exclusive ` ` '' denote ` ` xor '' pascal ` ` ^ '' c / c++/java first line contain integer n ( 1 ≤ n ≤ 100 ) — number elements array second line contain space - separated integers array number non - negative integers strictly less 230 . print a single integer — require maximal xor a segment consecutive elements first sample one optimal segment segment consist first second array elements consider array elements index start one second sample contain one optimal segment contain exactly one array element ( element index three ),['implementation'],1100.0
254/B,"2013 writers berland state university prepare problems n olympiads assume olympiads number consecutive integers 1 n. olympiad know many members jury must involve preparation well time require prepare problems namely olympiad number i prepare pi people ti days preparation olympiad a continuous period time end exactly one day olympiad day olympiad juries prepare already work example olympiad hold december 9th preparation take 7 people 6 days seven members jury work problems olympiad december 3rd december <unknown> ( jury members wo n't work problems olympiad december 9th , start prepare problems olympiad ) olympiad hold november 3rd require 5 days train members jury work october <unknown> november 2nd order overload jury follow rule introduce : one member jury work day task different olympiads write a program determine minimum number people must part jury olympiads could prepare time first line contain integer n — number olympiads 2013 ( 1 ≤ n ≤ 100 ) follow n line contain four integers mi di pi ti — month day olympiad ( give without lead zero ) need number jury members time need prepare i - th olympiad ( 1 ≤ mi ≤ 12 di ≥ 1 1 ≤ pi ti ≤ 100 ) di n't exceed number days month mi olympiads give arbitrary order several olympiads take place one day use modern ( gregorian ) calendar solution note date give year 2013 . a leap year february 28 days please note preparation olympiad start 2012 year print a single number — minimum jury size",['implementation'],1500.0
254/C,string x anagram string y rearrange letter string x get exact string y. example string ` ` dog '' ` ` god '' anagram string ` ` baba '' ` ` aabb '' string ` ` <unknown> '' ` ` <unknown> '' give two string s t length consist uppercase english letter need get anagram string t string s. permit perform replace operation : every operation replace character string s character get anagram string t least number replace operations get multiple anagram string t least number operations get lexicographically minimal one lexicographic order string familiar us ` ` dictionary '' order formally string p length n lexicographically smaller string q length p1 = q1 p2 = q2 ... pk - 1 = qk - 1 pk < qk k ( 1 ≤ k ≤ n ) character string number 1 . character string compare alphabetic order input consist two line first line contain string s second line contain string t. string length ( 1 105 character ) consist uppercase english letter first line print z — minimum number replacement operations need get anagram string t string s. second line print lexicographically minimum anagram could obtain z operations second sample eight anagram string t obtain string s replace exactly two letter : ` ` adbadc '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' anagram list lexicographical order lexicographically minimum anagram ` ` adbadc '',['greedy'],1800.0
255/A,"greg a beginner <unknown> today gym coach give train plan n integers a1 a2 ... , number mean greg need exactly n exercise today besides greg repeat i - th order exercise ai time greg three type exercise : ` ` chest '' exercise ` ` biceps '' exercise ` ` back '' exercise besides train cyclic , first exercise a ` ` chest '' one second one ` ` biceps '' third one ` ` back '' fourth one ` ` chest '' fifth one ` ` biceps '' n - th exercise greg wonder muscle get exercise train know exercise greg repeat maximum number time train correspond muscle help greg determine muscle get train first line contain integer n ( 1 ≤ n ≤ 20 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 25 ) — number time greg repeat exercise print word ` ` chest '' ( without quote ) chest get exercise ` ` biceps '' ( without quote ) biceps get exercise print ` ` back '' ( without quote ) back get exercise guarantee input answer problem unambiguous first sample greg 2 chest 8 biceps zero back exercise biceps get exercise second sample greg 5 chest 1 biceps 10 back exercise back get exercise third sample greg 18 chest 12 biceps 8 back exercise chest get exercise",['implementation'],800.0
255/B,little vitaly love different algorithms today invent a new algorithm vitaly 's algorithm work string s consist character ` ` x '' ` ` y '' use two follow operations runtime : input new algorithm string s algorithm work follow : vitaly wonder go print result algorithm 's work input receive string s. first line contain a non - empty string s. guarantee string consist character ` ` x '' ` ` y '' guarantee string consist 106 character guarantee result algorithm 's execution wo n't empty string line print string print result algorithm 's work input algorithm input receive string s. first test algorithm end first step algorithm impossible apply operation thus string wo n't change second test transformation like : a result ' ve get string ` ` y '' third test case one transformation take place : string ` ` <unknown> '' transform string ` ` xxxx '' thus answer string ` ` xxxx '',['implementation'],1200.0
256/D,"n people sit a line table person know always tell either truth lie little serge ask : many always tell truth ? people table know everything ( honest person a liar ) people table honest people go say correct answer liars go say integer 1 n correct answer every liar choose answer regardless liars two distinct liars may give distinct answer serge know information people besides answer question take a piece paper write n integers a1 a2 ... , ai answer i - th person row give sequence serge determine exactly k people sit table apparently lie serge wonder many variants people 's answer ( sequence answer a length n ) one say exactly k people sit table apparently lie rather many describe variants answer count remainder divide number variants 777777777 . first line contain two integers n k ( 1 ≤ k ≤ n ≤ 28 ) guarantee n — power number 2 . print a single integer — answer problem modulo 777777777",['dp'],2700.0
256/E,"little maxim love interest problems decide share one problem initially array a consist n zero elements array index start 1 . follow query change array a. query characterize two integers vi ti answer query make vi - th array element equal ti ( avi = ti ; 1 ≤ vi ≤ n ) maxim think pair integers ( x y ) good maxim think array a consist n integers lucky integer i ( 1 ≤ i ≤ n - 1 ) pair integers ( ai ai + 1 ) — good note order number pair important , specifically ( 1 2 ) ≠ ( 2 1 ) query change array a maxim want know many ways replace zero array a integers one three make result array ( without zero ) lucky course distinct zero replace distinct integers maxim tell sequence query pair integers consider lucky help maxim solve problem first line contain integers n m ( 1 ≤ n m ≤ 77777 ) — number elements array number command next three line contain matrix w consist zero ones ; j - th number i - th line — wi j. wi j = 1 ( 1 ≤ i j ≤ 3 ) pair ( i j ) good otherwise good matrix symmetric relative main diagonal next m line contain pair integers vi ti ( 1 ≤ vi ≤ n 0 ≤ ti ≤ 3 ) — query change array print m integers — i - th number equal number ways replace zero array a ( change i - th query ) integers one three make result array ( without zero ) lucky separate number whitespaces answer rather large print remainder divide 777777777",['data structures'],2400.0
258/C,"little elephant love lcm ( least common multiple ) operation a non - empty set positive integers result lcm operation k positive integers x1 x2 ... xk minimum positive integer divisible number xi let 's assume a sequence integers b1 b2 ... bn let 's denote lcms lcm ( b1 b2 ... bn ) maximum max ( b1 b2 ... bn ) little elephant consider a sequence b good lcm ( b1 b2 ... bn ) = max ( b1 b2 ... bn ) little elephant a sequence integers a1 a2 ... , help find number good sequence integers b1 b2 ... bn i ( 1 ≤ i ≤ n ) follow condition fulfill : 1 ≤ bi ≤ ai answer rather large print remainder divide 1000000007 ( 109 + 7 ) first line contain a single positive integer n ( 1 ≤ n ≤ 105 ) — number integers sequence a. second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 105 ) — sequence a. single line print a single integer — answer problem modulo 1000000007 ( 109 + 7 )","['dp', 'math']",2000.0
26/C,bob decide lay a parquet floor live room live room size n × m metres bob plank three type : a plank 1 × 2 meter b plank 2 × 1 meter c plank 2 × 2 meter help bob find possible parquet live room a set plank possible find one possible ways bob n't use plank first input line contain 5 space - separated integer number n m a b c ( 1 ≤ n m ≤ 100 0 ≤ a b c ≤ 104 ) n m — live room dimension a b c — amount plank 1 × 2 2 × 1 и 2 × 2 respectively 's allow turn plank possible parquet room a set plank output impossible otherwise output one possible ways parquet room — output n line m lower - case latin letter two square common side contain letter belong one plank different letter otherwise different plank mark one letter ( see examples ) answer unique output,"['greedy', 'implementation']",2000.0
260/E,"a country call flatland infinite two - dimensional plane flatland n cities a point plane flatland rule king circle iv circle iv 9 sons want give sons part flatland rule , want draw four distinct straight line two parallel ox axis two others parallel oy axis , straight line go city thus flatland divide 9 part son give exactly one part circle iv think a little evaluate sons ' <unknown> decide i - th son get part flatland exactly ai cities help circle find four straight line divide flatland 9 part line result part give sons son number i get part flatland contain ai cities first line contain integer n ( 9 ≤ n ≤ 105 ) — number cities flatland next n line contain two space - separated integers : xi yi ( - 109 ≤ xi yi ≤ 109 ) — coordinate i - th city two cities locate point last line contain nine space - separated integers : solution print a single integer -1 . otherwise print first line two distinct real space - separated number : x1 x2 — <unknown> straight line parallel oy axis second line print two distinct real space - separated number : y1 y2 — <unknown> straight line parallel ox multiple solutions print answer check a city consider lie a straight line distance city line n't exceed 10 - 6 . two straight line consider distance n't exceed 10 - 6 . solution first sample test show : solution second sample test show : solution third sample test",['data structures'],2500.0
262/A,roma ( a popular russian name mean ' roman ' ) love little <unknown> elephant 's lucky number let us remind lucky number positive integers whose decimal representation contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 roma 's get n positive integers wonder many integers k lucky digits ? help write program solve problem first line contain two integers n k ( 1 ≤ n k ≤ 100 ) second line contain n integers ai ( 1 ≤ ai ≤ 109 ) — number roma number line separate single space a single line print a single integer — answer problem first sample number contain four lucky digits answer 3 . second sample number <unknown> n't fit contain two lucky digits number fine answer 2,['implementation'],800.0
264/D,two sequence colorful stone color stone one red green blue give two string s t. i - th ( 1 - based ) character s represent color i - th stone first sequence similarly i - th ( 1 - based ) character t represent color i - th stone second sequence character ` ` r '' ` ` g '' ` ` b '' color correspond stone red green blue respectively initially squirrel liss stand first stone first sequence cat vasya stand first stone second sequence perform follow instructions zero time instruction one three type : ` ` red '' ` ` green '' ` ` blue '' instruction c animals stand stone whose color c move one stone forward example perform instruction « red » animals stand red stone move one stone forward allow perform instructions lead animals sequence word animals stand last stone ca n't perform instructions color stone a pair position ( position liss position vasya ) call a state a state call reachable state reachable perform instructions zero time initial state ( 1 1 ) calculate number distinct reachable state input contain two line first line contain string s ( 1 ≤ |s| ≤ 106 ) second line contain string t ( 1 ≤ |t| ≤ 106 ) character string one ` ` r '' ` ` g '' ` ` b '' print number distinct reachable state a single line please write % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first example five reachable state : ( 1 1 ) ( 2 2 ) ( 2 3 ) ( 3 2 ) ( 3 3 ) example state ( 3 3 ) reachable perform instructions ` ` red '' ` ` green '' ` ` blue '' order initial state state ( 3 3 ) follow picture show instructions work case,['dp'],2500.0
266/A,n stone table a row red green blue count minimum number stone take table two neighbor stone different color stone a row consider neighbor stone first line contain integer n ( 1 ≤ n ≤ 50 ) — number stone table next line contain string s represent color stone 'll consider stone row number 1 n leave right i - th character s equal ` ` r '' i - th stone red ` ` g '' 's green ` ` b '' 's blue print a single integer — answer problem,['implementation'],800.0
266/B,"break schoolchildren boys girls form a queue n people canteen initially children stand order enter canteen however a boys start feel awkward stand front girls queue start let girls move forward second let 's describe process precisely let 's say position queue sequentially number integers 1 n person position number 1 serve first , time x a boy stand i - th position a girl stand ( i + 1 ) -th position time x + 1 i - th position a girl ( i + 1 ) -th position a boy time give second ' ve get initial position children initial moment time determine way queue go look t second first line contain two integers n t ( 1 ≤ n t ≤ 50 ) represent number children queue time queue transform arrangement need find next line contain string s represent schoolchildren 's initial arrangement i - th position queue contain a boy i - th character string s equal ` ` b '' otherwise i - th character equal ` ` g '' print string a describe arrangement t second i - th position a boy need time i - th character a must equal ` ` b '' otherwise must equal ` ` g ''",['implementation'],800.0
27/C,sequence call order non - decreasing non - increasing example <unknown> [ 3 1 1 0 ] [ 1 2 3 100 ] order sequence [ 1 3 3 1 ] give a sequence number find 's shortest subsequence order a subsequence a sequence derive give sequence delete zero elements without change order remain elements first line input contain one integer n ( 1 ≤ n ≤ 105 ) second line contain n space - separated integers — give sequence number sequence exceed 106 absolute value give sequence contain unordered subsequences output 0 . otherwise output length k shortest subsequence output k integers range [ 1 .. n ] — index elements subsequence several solutions output,['greedy'],1900.0
273/D,dima love make picture a piece square paper yet dima love picture depict one favorite figure a piece square paper size n × m represent a table consist n row m columns square white blank square paper dima define a picture image a blank piece paper obtain paint square black picture <unknown> one dima 's favorite figure follow condition hold : dima wonder : many paint n × m piece paper depict one favorite figure ? count number modulo 1000000007 ( 109 + 7 ) first line contain two integers n m — size piece paper ( 1 ≤ n m ≤ 150 ) a single line print remainder divide answer problem number 1000000007 ( 109 + 7 ),['dp'],2400.0
274/E,imagine n × m grid block cells top leave cell grid coordinate ( 1 1 ) bottom right cell coordinate ( n m ) k block cells grid others empty flash a laser beam center empty cell ( xs ys ) one diagonal directions ( i.e north - east north - west south - east south - west ) beam hit a block cell border grid reflect behavior beam reflection different situations depict figure a beam enter infinite cycle count number empty cells beam go least consider beam go cell go center first line input contain three integers n m k ( 1 ≤ n m ≤ 105 0 ≤ k ≤ 105 ) next k line contain two integers xi yi ( 1 ≤ xi ≤ n 1 ≤ yi ≤ m ) indicate position i - th block cell last line contain xs ys ( 1 ≤ xs ≤ n 1 ≤ ys ≤ m ) flash direction equal ` ` ne '' ` ` nw '' ` ` se '' ` ` <unknown> '' string denote directions ( - 1 1 ) ( - 1 - 1 ) ( 1 1 ) ( 1 - 1 ) 's guarantee two block cells coordinate line output print number empty cells beam go least please write % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier,"['data structures', 'implementation']",3000.0
276/A,write another program contest three rabbit decide grab lunch coach give team exactly k time units lunch break rabbit a list n restaurants lunch : i - th restaurant characterize two integers fi ti value ti show time rabbit need lunch i - th restaurant time ti exceed time k coach give lunch break rabbit ' joy lunch restaurant equal fi - ( ti - k ) otherwise rabbit get exactly fi units joy task find value maximum joy rabbit get lunch depend restaurant rabbit must choose exactly one restaurant lunch note joy value n't necessarily a positive value first line contain two space - separated integers — n ( 1 ≤ n ≤ 104 ) k ( 1 ≤ k ≤ 109 ) — number restaurants rabbit ' list time coach give lunch correspondingly next n line contain two space - separated integers — fi ( 1 ≤ fi ≤ 109 ) ti ( 1 ≤ ti ≤ 109 ) — characteristics i - th restaurant a single line print a single integer — maximum joy value rabbit get lunch,['implementation'],900.0
276/C,little girl love problems array query much one day come across a rather well - known problem : ' ve get array $$$ n $$$ elements ( elements array index start 1 ) ; also $$$ q $$$ query one define a pair integers $$$ l_i $$$ $$$ r_i $$$ $$$ ( 1 \le l_i \le r_i \le n ) $$$ need find query sum elements array index $$$ l_i $$$ $$$ r_i $$$ inclusive little girl find problem rather bore decide reorder array elements reply query a way make sum query reply maximum possible task find value maximum sum first line contain two space - separated integers $$$ n $$$ ( $$$ 1 \le n \le 2\cdot100000 $$$ ) $$$ q $$$ ( $$$ 1 \le q \le 2\cdot100000 $$$ ) — number elements array number query correspondingly next line contain $$$ n $$$ space - separated integers $$$ a_i $$$ ( $$$ 1 \le a_i \le 2\cdot100000 $$$ ) — array elements follow $$$ q $$$ line contain two space - separated integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) — $$$ i $$$ -th query a single line print a single integer — maximum sum query reply array elements reorder please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier,"['data structures', 'greedy', 'implementation']",1500.0
276/D,a little girl love problems bitwise operations much 's one give two integers l r. let 's consider value pair integers a b ( l ≤ a ≤ b ≤ r ) task find maximum value among consider ones expression mean apply bitwise exclude operation integers x y. give operation exist modern program languages example languages c++ java represent ` ` ^ '' pascal — ` ` xor '' single line contain space - separated integers l r ( 1 ≤ l ≤ r ≤ 1018 ) please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier a single line print a single integer — maximum value pair integers a b ( l ≤ a ≤ b ≤ r ),"['dp', 'greedy', 'implementation', 'math']",1700.0
276/E,a little girl love problems tree much 's one a tree undirected connect graph contain cycle degree node x tree number nod y tree connect node x edge tree let 's consider a tree consist n nod 'll consider tree 's nod index 1 n. <unknown> tree follow property : node except node number 1 degree 2 . initially node tree contain number 0 . task quickly process request two type : first line contain integers n ( 2 ≤ n ≤ 105 ) q ( 1 ≤ q ≤ 105 ) — number tree nod number request correspondingly next n - 1 line contain two integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) show edge nod ui vi edge 's description occur input exactly guarantee give graph a tree property describe statement next q line describe request number line separate single space request print node value print integer — reply request,['data structures'],2100.0
279/B,"valera get free time go library read book today 's get t free minutes read 's valera take n book library book estimate time go need read let 's number book integers 1 n. valera need ai minutes read i - th book valera decide choose arbitrary book number i read book one one start book word first read book number i book number i + 1 book number i + 2 continue process either run free time finish read n - th book valera read book end , n't start read book n't enough free time finish read print maximum number book valera read first line contain two integers n t ( 1 ≤ n ≤ 105 ; 1 ≤ t ≤ 109 ) — number book number free minutes valera 's get second line contain a sequence n integers a1 a2 ... ( 1 ≤ ai ≤ 104 ) number ai show number minutes boy need read i - th book print a single integer — maximum number book valera read",['implementation'],1400.0
284/B,n cow play poker a table current bet phase player 's status either ` ` allin '' ` ` '' ` ` fold '' change throughout phase increase <unknown> a player whose current status ` ` fold '' may show his / her hand table however affect bet decisions he / she may players a status either ` ` allin '' ` ` fold '' player 's status may either ` ` allin '' ` ` '' find number cow currently show hand without affect bet decisions first line contain a single integer n ( 2 ≤ n ≤ 2·105 ) second line contain n character either ` ` a '' ` ` i '' ` ` f '' i - th character ` ` a '' i - th player 's status ` ` allin '' ` ` i '' i - th player 's status ` ` '' ` ` f '' i - th player 's status ` ` fold '' first line contain a single integer denote number players currently show hand first sample cow 1 4 5 6 show hand second sample cow 3 show hand,['implementation'],1000.0
285/A,permutation p order set integers p1 p2 ... pn consist n distinct positive integers n't exceed n. 'll denote i - th element permutation p pi 'll call number n size length permutation p1 p2 ... pn decrease coefficient permutation p1 p2 ... pn number i ( 1 ≤ i < n ) pi > pi + 1 . number n k. task print permutation length n decrease coefficient k. single line contain two space - separated integers : n k ( 1 ≤ n ≤ 105 0 ≤ k < n ) — permutation length decrease coefficient a single line print n space - separated integers : p1 p2 ... pn — permutation length n decrease coefficient k. several permutations meet condition print guarantee permutation seek parameters exist,"['greedy', 'implementation']",1100.0
289/A,"little penguin polo adore integer segment , pair integers [ l ; r ] ( l ≤ r ) a set consist n integer segment : [ l1 ; r1 ] [ l2 ; r2 ] ... [ ln ; rn ] know two segment set intersect one move polo either widen segment set 1 unit leave 1 unit right transform [ l ; r ] either segment [ l - 1 ; r ] segment [ l ; r + 1 ] value a set segment consist n segment [ l1 ; r1 ] [ l2 ; r2 ] ... [ ln ; rn ] number integers x integer j follow inequality hold lj ≤ x ≤ rj find minimum number move need make value set polo 's segment divisible k. first line contain two integers n k ( 1 ≤ n k ≤ 105 ) follow n line contain a segment a pair integers li ri ( - 105 ≤ li ≤ ri ≤ 105 ) separate a space guarantee two segment intersect word two integers i j ( 1 ≤ i < j ≤ n ) follow inequality hold min ( ri rj ) < max ( li lj ) a single line print a single integer — answer problem",['implementation'],1100.0
29/C,one day bob get a letter envelope bob know berland 's post officer send a letter directly city « a » city « b » stamp « a b » « b a » unfortunately often impossible send a letter directly city sender city receiver 's letter send via intermediate cities post officer never send a letter a way route letter contain city bob sure post officer stamp letter accurately n stamp envelope bob 's letter understand possible rout letter two stamp numerous bob ca n't determine none rout 's ask help find one possible rout letter first line contain integer n ( 1 ≤ n ≤ 105 ) — amount mail stamp envelope follow n line two integers — description stamp stamp describe index cities a letter send index cities integers 1 109 . index cities different every time letter send one city another exactly one stamp put envelope guarantee give stamp correspond valid route city city output n + 1 number — index cities one two possible rout letter,"['data structures', 'implementation']",1700.0
292/E,"often copy large volumes information operation take many computer resources therefore problem advise come a way copy part a number array another one quickly formally ' ve get two array integers a1 a2 ... b1 b2 ... bn length n. also ' ve get m query two type : query second type print result — value correspond element array b. first line contain two space - separated integers n m ( 1 ≤ n m ≤ 105 ) — number elements array number query correspondingly second line contain array integers a1 a2 ... ( |ai| ≤ 109 ) third line contain array integers b1 b2 ... bn ( |bi| ≤ 109 ) next m line contain descriptions query i - th line first contain integer ti — type i - th query ( 1 ≤ ti ≤ 2 ) ti = 1 i - th query mean copy operation ti = 2 i - th query mean take value array b. ti = 1 query type follow three integers xi yi ki ( 1 ≤ xi yi ki ≤ n ) — parameters copy query ti = 2 query type follow integer xi ( 1 ≤ xi ≤ n ) — position array b. number line separate single space guarantee query correct , copy border fit border array a b. second type query print result a single line",['data structures'],1900.0
297/B,know k fish species polar ocean number 1 k. sort non - decreasing order weight a positive number let weight i - th type fish wi 0 < w1 ≤ w2 ≤ ... ≤ wk hold polar bear alice bob catch fish guess larger sum weight fish he / she 's catch give type fish ' ve catch determine whether possible fish catch alice a strictly larger total weight bob 's word exist a sequence weight wi ( necessary integers ) fish catch alice a strictly larger total weight ? first line contain three integers n m k ( 1 ≤ n m ≤ 105 1 ≤ k ≤ 109 ) — number fish catch alice bob respectively number fish species second line contain n integers 1 k list fish type catch alice third line contain m integers 1 k list fish type catch bob note one may catch one fish a species output ` ` yes '' ( without quote ) possible ` ` '' ( without quote ) otherwise first sample w1 = 1 w2 = 2 w3 = 2.5 alice a total 2 + 2 + 2 = 6 weight units bob 1 + 1 + 2.5 = 4.5 . second sample fish alice catch a subset bob 's therefore total weight bob ’ s fish always less total weight alice ’ s fish,['greedy'],1600.0
297/E,polar bear discover a gigantic circular piece float ice mystic carve n line carve ice line connect two point boundary ice ( call point endpoints ) endpoints number 1 2 ... 2n counter - clockwise along circumference two line share endpoint a group 6 polar bear ( alice bob carol dave eve frank ) go build cave endpoints polar bear would build a cave live two polar bear build a cave endpoints alice bob a pair superstitious lovers believe line carve alien ( humans pretty much thing polar bear ) certain <unknown> power therefore want build cave two endpoints connect a line carol dave eve frank distance two cave x y define one plus minimum number cave one need pass order travel x y along boundary ice ( endpoints without cave count ) ensure fairness distance three pair lovers ( distance alice bob distance carol dave distance eve frank ) figure show two different configurations dot circle endpoints configuration leave valid although pair lovers ( a b c d e f ) connect a line distance requirement satisfy distance a b 2 ( one go a b clockwise direction pass f ) distance e f also 2 . however distance c d 1 ( one go c d counter - clockwise direction without pass cave ) configuration right valid three pair distance 1 . count number ways build cave requirements two configurations consider set 6 endpoints use first line contain integer n ( 3 ≤ n ≤ 105 ) — number line follow n line contain two integers ai bi ( 1 ≤ ai bi ≤ 2n ) mean a line carve ice connect ai – th bi – th endpoint 's guarantee endpoints touch exactly one line print number ways build cave please write % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier second sample correspond figure problem statement,['data structures'],3000.0
299/B,"ksusha squirrel stand begin a straight road divide n sectors sectors number 1 n leave right initially ksusha stand sector 1 . ksusha want walk end road , get sector n. unfortunately rock road know ksusha hat rock n't want stand sectors rock ksusha squirrel keep fit jump sector i sectors i + 1 i + 2 ... i + k. help ksusha ! give road description say reach end road ( note stand a rock ) ? first line contain two integers n k ( 2 ≤ n ≤ 3·105 1 ≤ k ≤ 3·105 ) next line contain n character — description road : i - th character equal ` ` ` ` i - th sector contain rock otherwise equal ` ` # '' guarantee first last character equal ` ` . ` ` print ` ` yes '' ( without quote ) ksusha reach end road otherwise print ` ` '' ( without quote )",['implementation'],900.0
3/C,certainly everyone familiar tic - tac - toe game rule simple indeed two players take turn mark cells a 3 × 3 grid ( one player always draw cross — noughts ) player succeed first place three mark a horizontal vertical diagonal line win game finish player draw cross go first grid fill neither xs 0s form require line a draw announce give a 3 × 3 grid grid cell empty occupy a cross a <unknown> find player ( first second ) whose turn next print one verdicts : input consist three line line contain character ` ` ` ` ` ` x '' ` ` 0 '' ( a period a capital letter x a digit zero ) print one six verdicts : first second illegal first player second player draw,['implementation'],1800.0
30/E,young years hero story king copa decide private data hide enough <unknown> unacceptable king 's invent tricky clever password ( later learn password a palindrome odd length ) cod data use copa afraid forget password decide write a piece paper aware insecure keep password way decide cipher follow way : cut x character start password end ( x 0 2x strictly less password length ) obtain 3 part password let 's call prefix middle suffix correspondingly prefix suffix equal length middle always odd length part make a string a + prefix + b + middle + c + suffix a b c ( possibly empty ) string invent copa « + » mean concatenation many years pass yesterday king copa find piece paper cipher password write password well string a b c completely forget copa ask find a password maximum possible length could invent cipher write copa input contain single string small latin letter length 1 105 character first line contain integer k — amount nonempty part password answer ( ) follow k line output two integers xi li — start length correspond part password output pair order increase xi separate number pair a single space start position xi integer 1 length input string li must positive output non - empty part middle part must odd length several solutions output note goal maximize sum li maximize k,"['data structures', 'greedy']",2800.0
300/A,vitaly array n distinct integers vitaly want divide array three non - empty set follow condition hold : help vitaly divide give array first line input contain integer n ( 3 ≤ n ≤ 100 ) second line contain n space - separated distinct integers a1 a2 ... ( |ai| ≤ 103 ) — array elements first line print integer n1 ( n1 > 0 ) — number elements first set print n1 number — elements get first set next line print integer n2 ( n2 > 0 ) — number elements second set print n2 number — elements get second set next line print integer n3 ( n3 > 0 ) — number elements third set print n3 number — elements get third set print set must meet describe condition guarantee solution exist several solutions allow print,['implementation'],1100.0
301/D,yaroslav array p = p1 p2 ... pn ( 1 ≤ pi ≤ n ) consist n distinct integers also m query : help yaroslav answer query first line contain integers n m ( 1 ≤ n m ≤ 2·105 ) second line contain n distinct integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) follow m line contain yaroslav 's query i - th line contain integers li ri ( 1 ≤ li ≤ ri ≤ n ) print m integers — answer yaroslav 's query order appear input please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier,['data structures'],2200.0
313/A,ilya a clever lion live unusual city zooville city animals right <unknown> moreover even bank account state a bank account integer state a bank account a negative number mean owner account owe bank money ilya lion recently a birthday get a lot gift one ( gift main zooville bank ) opportunity delete last digit digit last state bank account example state ilya 's bank account <unknown> ilya delete last digit get account balance equal <unknown> also remove digit last get account balance equal -13 . course ilya permit use opportunity delete a digit balance ilya good math 's ask help maximize bank account find maximum state bank account obtain use bank 's gift single line contain integer n ( 10 ≤ <unknown> ≤ 109 ) — state ilya 's bank account a single line print integer — maximum state bank account ilya get first test sample ilya n't profit use present second test sample delete digit 1 get state account equal 0,['implementation'],900.0
313/E,ilya recently take <unknown> 's recently find two number write m - based notation find number consist exactly n digits ilya immediately start look information number learn number part a cypher code one decypher get greatest treasure considerable research ilya understand decypher code follow : help ilya find key code first line contain two integers n m ( 1 ≤ n m ≤ 105 m > 1 ) second line contain first find number third line contain second find number number record a sequence digits m - based notation digit integer 0 m - 1 . digits line write order significant digits least significant ones give number contain lead zero print n m - base digits result third number write m - based notation print digits order significant digits least significant ones,"['data structures', 'greedy']",2300.0
314/C,"sereja a sequence consist n positive integers a1 a2 ... , first sereja take a piece square paper write distinct non - empty non - decreasing subsequences sequence a. sequence write square paper sereja write a piece line paper sequence exceed a sequence positive integers x = x1 x2 ... xr n't exceed a sequence positive integers y = y1 y2 ... yr follow inequation hold : x1 ≤ y1 x2 ≤ y2 ... xr ≤ yr . sereja wonder many sequence write line piece paper help sereja find require quantity modulo 1000000007 ( 109 + 7 ) first line contain integer n ( 1 ≤ n ≤ 105 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 106 ) single line print answer problem modulo 1000000007 ( 109 + 7 )","['data structures', 'dp']",2000.0
314/D,sereja place n point a plane sereja want place plane two straight line intersect a right angle one straight line intersect ox axis angle 45 degrees maximum distance point straight line minimum problem consider distance point ( x1 y1 ) ( x2 y2 ) equal |x1 - x2| + |y1 - y2| distance point straight line minimum distance point point belong one line help sereja find maximum distance point optimally locate straight line first line contain integer n ( 1 ≤ n ≤ 105 ) next n line contain coordinate line i - th line contain two integers xi yi ( |xi| |yi| ≤ 109 ) a single line print a real number — answer problem answer consider correct iff absolute relative error n't exceed 10 - 6,['data structures'],2500.0
316/F3,smart beaver become interest draw draw sun however point smart beaver realize simply draw sun bore decide design a program process draw give a picture draw beaver two color : one background one sun image task count number sun image count number ray sun arbitrarily rotate ellipse ray ray a segment connect point boundary ellipse point outside ellipse guarantee : first line contain two integers h w — height width image ( 1 ≤ h w ≤ 1600 ) next h line contain w space - separated integers describe smart beaver ’ s picture number equal either a 0 ( image background ) a 1 ( sun color ) input limit score 30 point ( subproblem f1 ) : input limit score 70 point ( subproblems <unknown> ) : input limit score 100 point ( subproblems <unknown> ) : first line must contain a single number k — number sun beaver ’ s image second line must contain exactly k space - separated integers correspond number ray sun number second line must sort increase order complexity level suggest a sample initial data download sample http : <unknown> / <unknown>,['implementation'],2200.0
328/B,remember <unknown> construct word ` ` <unknown> '' use piece ice components ? little sheldon play piece ice piece exactly one digit 0 9 . want construct favourite number t. realize digits 6 9 similar rotate piece ice 6 use 9 ( vice versa ) <unknown> 2 5 work pair digits similar effect call effect ` ` digital <unknown> '' sheldon favourite number t. want many instance t possible many instance construct use give sequence ice piece use piece first line contain integer t ( 1 ≤ t ≤ 10000 ) second line contain sequence digits piece length line equal number piece 1 200 inclusive contain digits 0 9 . print require number instance problem contain weak pretests,['greedy'],1500.0
331/E1,"everybody know live matrix a long time new seventh matrix world rule beaver let 's take beaver neo neo so - called ` ` <unknown> <unknown> '' <unknown> get visions events place 's go let 's examine phenomenon detail say neo 's city represent a direct graph consist n shop m streets connect shop two streets connect pair shop ( besides ca n't one street a b one street b a ) street connect a shop neo pass streets get visions matter many time pass street k every time get visions order a vision a sequence shop know neo go get really shock pass way shop a shop b possible coincide a list visit shop real life visions coincide suggest beaver neo path non - zero length maybe even count number paths modulo 1000000007 ( 109 + 7 ) ?   first line contain integers n m — number shop number streets correspondingly 1 ≤ n ≤ 50 , next m line contain descriptions streets follow format : xi yi ki v1 v2 ... vk xi yi ( 1 ≤ xi yi ≤ n xi ≠ yi ) indices shop connect a street ki ( 0 ≤ ki ≤ n ) number visions way xi yi ; v1 v2 ... vk ( 1 ≤ vi ≤ n ) describe visions : number shop neo saw note order visions matter guarantee total number visions streets n't exceed 105 . subproblem e1 first line print integer k ( 1 ≤ k ≤ 2·n ) — number shop neo 's path next line print k integers — number shop order neo pass graph n't paths length shortest path include 2·n shop print a single line 0 . subproblem e2 print 2·n line i - th line must contain a single integer — number require paths length i modulo 1000000007 ( 109 + 7 ) input sample first sample contain answer first subproblem second sample contain answer second subproblem",['implementation'],2900.0
332/A,everybody know berland citizens keen health especially students berland students tough drink orange juice ! yesterday one student vasya mat make barbecue drink healthy drink run first barrel juice decide play a simple game n people come barbecue sit a circle ( thus person receive a unique index bi 0 n - 1 ) person number 0 start game ( time vasya ) turn game number integers start 1 . j - th turn make person index bi person act like : person point last turn make action problem vasya 's drink much juice ca n't remember goal game however vasya 's get record sequence participants ' action ( include ) vasya want find maximum amount juice could drink play optimally well ( players ' action change ) help assume scenario enough juice everybody first line contain a single integer n ( 4 ≤ n ≤ 2000 ) — number participants game second line describe actual game : i - th character line equal ' a ' participant move i - th point next person elbow ' b ' participant point a nod game continue least 1 2000 turn print a single integer — number glass juice vasya could drink play optimally well sample vasya get two turn — 1 5 . first sample vasya could drink a glass juice fifth turn point next person a nod case sequence move would look like ` ` abbbb '' second sample vasya would n't drink a single glass juice move perform turn 3 4 different,['implementation'],1300.0
332/B,reform continue enter berland example yesterday sit berland parliament <unknown> much n laws ( law assign a unique number 1 n ) today laws put table president berland g. w. boosch sign time mr . boosch plan sign 2k laws decide choose exactly two non - intersecting segment integers 1 n length k sign laws whose number fall segment formally mr . boosch go choose two integers a b ( 1 ≤ a ≤ b ≤ n - k + 1 b - a ≥ k ) sign laws number lie segment [ a ; a + k - 1 ] [ b ; b + k - 1 ] ( border include ) mr . boosch choose laws sign course consider public opinion <unknown> public opinion study centre ( <unknown> ) conduct opinion poll among citizens process result a report give president report contain absurdity value law public opinion mr . boosch a real <unknown> keen sign laws maximum total absurdity help first line contain two integers n k ( 2 ≤ n ≤ 2·105 0 < 2k ≤ n ) — number laws accept parliament length one segment law list correspondingly next line contain n integers x1 x2 ... xn — absurdity law ( 1 ≤ xi ≤ 109 ) print two integers a b — begin segment mr . boosch choose mean president sign laws number segment [ a ; a + k - 1 ] [ b ; b + k - 1 ] multiple solutions print one minimum number a. still multiple solutions print one minimum b. first sample mr . boosch sign laws number segment [ 1 ; 2 ] [ 4 ; 5 ] total absurdity sign laws equal 3 + 6 + 1 + 6 = 16 . second sample mr . boosch sign laws number segment [ 1 ; 2 ] [ 3 ; 4 ] total absurdity sign laws equal 1 + 1 + 1 + 1 = 4,"['data structures', 'dp', 'implementation']",1500.0
332/C,a student 's life <unknown> <unknown> berland university students know well study two years contract strong <unknown> towards chairperson department indeed person question n't <unknown> ladies begin : <unknown> reform group ban automatic pass mean deeds last students decide ca n't get away anymore ... students pull string higher level learn next university directors ' meet go discuss n order chairperson accept exactly p two value assign order : ai number chairperson 's hairs turn grey obey order bi — displeasement directors order n't obey students may make directors pass p order choose students know chairperson obey exactly k p order pick order obey way minimize first directors ' displeasement second number hairs head turn grey students want choose p order way maximize number hairs chairperson 's head turn grey multiple ways accept order students keen maximize directors ' displeasement chairperson 's action help first line contain three integers n ( 1 ≤ n ≤ 105 ) p ( 1 ≤ p ≤ n ) k ( 1 ≤ k ≤ p ) — number order directors go discuss number order pass number order obey chairperson correspondingly follow n line contain two integers ai bi ( 1 ≤ ai bi ≤ 109 ) describe correspond order print arbitrary order p distinct integers — number order accept students could carry revenge order index 1 n order occur input multiple solutions print first sample one optimal solutions pass order 1 2 3 . case chairperson obey order number 1 2 . get 10 new grey hairs head directors ' displeasement equal 3 . note result achieve order 4 instead order 3 . second sample chairperson obey order best strategy students pick order maximum sum ai value chairperson get 58 new gray hairs directors ' displeasement equal 0,"['data structures', 'greedy']",2200.0
34/C,"« bersoft » company work a new version popular text editor — bord 2010 . bord like many text editors able print <unknown> document a user key a sequence document page number want print ( separate a comma without space ) task write a part program responsible « standardization » sequence program get sequence key user input program output sequence format l1 - r1 l2 - r2 ... lk - rk ri + 1 < li + 1 i 1 k - 1 li ≤ ri new sequence contain page number key user nothing else page number appear input sequence several time appearances start second one ignore element i new sequence li = ri element output li « li - li » example sequence <unknown> output 1 - 3,6 . line contain sequence key user sequence contain least one 100 positive integer number 's guarantee sequence consist positive integer number exceed 1000 separate a comma n't contain character apart digits commas ca n't end a comma number n't contain lead zero also n't start a comma contain one comma a row output sequence require format",['implementation'],1300.0
342/A,xenia mathematician a sequence consist n ( n divisible 3 ) positive integers 7 . want split sequence group three group three a b c follow condition hold : naturally xenia want element sequence belong exactly one group three thus require partition exist group three help xenia find require partition else say n't exist first line contain integer n ( 3 ≤ n ≤ 99999 ) — number elements sequence next line contain n positive integers 7 . guarantee n divisible 3 . require partition exist print group three print group value elements contain print value increase order separate group integers group whitespaces multiple solutions print solution print -1,"['greedy', 'implementation']",1200.0
344/A,mad scientist mike entertain arrange row dominoes n't need dominoes though : use rectangular magnets instead magnet two pole positive ( a ` ` plus '' ) negative ( a ` ` minus '' ) two magnets put together a close distance like pole repel opposite pole attract mike start lay one magnet horizontally table follow step mike add one magnet horizontally right end row depend mike put magnet table either attract previous one ( form a group multiple magnets link together ) repel ( mike lay magnet distance right previous one ) assume a sole magnet link others form a group mike arrange multiple magnets a row determine number group magnets form first line input contain integer n ( 1 ≤ n ≤ 100000 ) — number magnets n line follow i - th line ( 1 ≤ i ≤ n ) contain either character ` ` 01 '' mike put i - th magnet ` ` plus - minus '' position character ` ` 10 '' mike put magnet ` ` minus - plus '' position single line output print number group magnets first testcase correspond figure testcase three group consist three one two magnets second testcase two group consist two magnets,['implementation'],800.0
346/C,give a sequence positive integers x1 x2 ... xn two non - negative integers a b. task transform a b. perform follow move : operation a mod xi mean take remainder division number a number xi want know minimum number move need transform a b. first line contain a single integer n ( 1 ≤ n ≤ 105 ) second line contain n space - separated integers x1 x2 ... xn ( 2 ≤ xi ≤ 109 ) third line contain two integers a b ( 0 ≤ b ≤ a ≤ 109 a - b ≤ 106 ) print a single integer — require minimum number move need transform number a number b,"['greedy', 'math']",2200.0
347/A,"want arrange n integers a1 a2 ... order a row let 's define value arrangement sum differences pair adjacent integers formally let 's denote arrangement a sequence integers x1 x2 ... xn sequence x a permutation sequence a. value arrangement ( x1 - x2 ) + ( x2 - x3 ) + ... + ( xn - 1 - xn ) find largest possible value arrangement , output lexicographically smallest sequence x correspond arrangement largest possible value first line input contain integer n ( 2 ≤ n ≤ 100 ) second line contain n space - separated integers a1 a2 ... ( |ai| ≤ 1000 ) print require sequence x1 x2 ... xn sequence x lexicographically smallest permutation a correspond arrangement largest possible value sample test case value output arrangement ( 100 - ( - 50 ) ) + ( ( - 50 ) - 0 ) + ( 0 - 50 ) + ( 50 - ( - 100 ) ) = 200 . arrangement a larger value among arrangements value 200 output arrangement lexicographically smallest one sequence x1 x2 ... xp lexicographically smaller sequence y1 y2 ... yp exist integer r ( 0 ≤ r < p ) x1 = y1 x2 = y2 ... xr = yr xr + 1 < yr + 1",['implementation'],1300.0
348/C,give array a1 a2 ... m set s1 s2 ... sm indices elements array let 's denote sk = { sk i } ( 1 ≤ i ≤ |sk| ) word sk i element set sk problem answer q query two type : first type query print require sum first line contain integers n m q ( 1 ≤ n m q ≤ 105 ) second line contain n integers a1 a2 ... ( |ai| ≤ 108 ) — elements array a. follow m line describe one set indices k - th line first contain a positive integer represent number elements set ( |sk| ) follow |sk| distinct integers sk 1 sk 2 ... sk |sk| ( 1 ≤ sk i ≤ n ) — elements set sk next q line contain query query look like either ` ` ? k '' ` ` + k x '' sit a single line query follow limit hold : 1 ≤ k ≤ m |x| ≤ 108 . query give order need answer guarantee sum size set sk n't exceed 105 . first type query print require sum a single line please write % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier,['data structures'],2500.0
351/A,jeff get 2n real number a1 a2 ... a2n a birthday present boy hat non - integer number decide slightly ` ` adjust '' number 's get namely jeff consecutively execute n operations go follow : nevertheless jeff n't want hurt feel person give sequence 's boy want perform operations make absolute value difference sum elements perform operations sum elements perform operations small possible help jeff find minimum absolute value difference first line contain integer n ( 1 ≤ n ≤ 2000 ) next line contain 2n real number a1 a2 ... a2n ( 0 ≤ ai ≤ 10000 ) give exactly three digits decimal point number separate space a single line print a single real number — require difference exactly three digits decimal point first test case need perform operations follow : ( i = 1 j = 4 ) ( i = 2 j = 3 ) ( i = 5 j = 6 ) case difference equal | ( 0 + 0.5 + 0.75 + 1 + 2 + 3 ) - ( 0 + 0 + 1 + 1 + 2 + 3 ) | = 0.25,"['dp', 'greedy', 'implementation', 'math']",1800.0
353/A,"valera get n domino piece a row piece consist two halve — upper one lower one halve contain a number 1 6 . valera love even integers much want sum number upper halve sum number lower halve even , valera rotate dominoes 180 degrees rotation upper lower halve swap place action take one second help valera find minimum time must spend rotate dominoes make wish come true first line contain integer n ( 1 ≤ n ≤ 100 ) denote number dominoes valera next n line contain two space - separated integers xi yi ( 1 ≤ xi yi ≤ 6 ) number xi initially write upper half i - th domino yi initially write lower half print a single number — minimum require number second valera ca n't task time print - 1 . first test case sum number upper halve equal 10 sum number lower halve equal 6 . number even valera n't require anything second sample valera one piece domino write 3 one halve therefore one sum always odd third case valera rotate first piece sum upper halve equal 10 sum lower halve equal 8","['implementation', 'math']",1200.0
353/B,"valera 2·n cub cube contain integer 10 99 . arbitrarily choose n cub put first heap remain cub form second heap valera decide play cub game take a cube first heap write number take a cube second heap write two digits near two digits write ( right ) end obtain a single fourdigit integer — first two digits write cube first heap second two digits write second cube second heap valera know arithmetic well , easily count number distinct fourdigit number get game question : split cub two heap number ( number distinct fourdigit integers valera get ) large possible ? first line contain integer n ( 1 ≤ n ≤ 100 ) second line contain 2·n space - separated integers ai ( 10 ≤ ai ≤ 99 ) denote number cub first line print a single number — maximum possible number distinct four - digit number valera obtain second line print 2·n number bi ( 1 ≤ bi ≤ 2 ) number mean : i - th cube belong bi - th heap division multiple optimal ways split cub heap print first test case valera put first cube first heap second cube — second heap case obtain number 1099 . put second cube first heap first cube second heap obtain number <unknown> . case maximum number distinct integers equal one second test case valera obtain number <unknown> 1345 <unknown> <unknown> . note put first third cub first heap obtain two number <unknown> 1345","['greedy', 'implementation', 'math']",1900.0
354/D,"vasya petya use interest data store structure : a pyramid pyramid consist n row i - th row contain i cells row shift half a cell leave relative previous row cells number integers 1 show picture example a pyramid n = 5 : data structure perform operations two type : formally : a subpyramid top i - th cell k - th row ( 5 - th cell second cell third row ) contain cells row k n ( k + p ) -th row contain cells i - th ( i + p ) -th ( 0 ≤ p ≤ n - k ) vasya petya two identical pyramid vasya change cells pyramid want send change petya , want find a sequence operations petya repeat vasya 's change among possible sequence vasya pick minimum one ( one contain fewest number ) a pyramid n row k change cells find sequence operations result k change cells change least one operation among possible sequence pick one contain fewest number first line contain two integers n k ( 1 ≤ n k ≤ 105 ) next k line contain coordinate modify cells ri ci ( 1 ≤ ci ≤ ri ≤ n ) — row cell 's number row cells distinct print a single number show many number final sequence one possible solutions first sample consist two <unknown> 4 v4 <unknown> <unknown> 6 v6 <unknown> <unknown> picture show change cells color - <unknown> subpyramid use first operation highlight blue subpyramid use first operation highlight yellow :",['dp'],2900.0
358/E,dima a good person fact 's great good things come end ... seryozha go kick dima time .. reason divide room unit square room a rectangle n × m consist unit square begin seryozha put dima a center square start kick dima ( know kick dima least ) time dima kick fly move one four directions ( leave right ) move dima pass k ( k > 1 ) unit length correspond direction seryozha really kind kick dima way dima never meet wall ( word dima never leave room 's space ) seryozha also dynamic character dima never fly segment connect a pair adjacent square twice seryozha kick dima a long time dima <unknown> — dima write dima mark square stay fly thank kick dima remember k value ask find possible value match dima 's record first line contain n m ( 1 ≤ n m ≤ 103 ) — size room next n line go contain m number aij — dima 's note : aij = 1 dima stay square ( i j ) fly otherwise aij = 0 . least one aij equal 1 . a single line <unknown> order print k ( k > 1 ) match dima 's note k dima invent story kick print -1,['implementation'],2300.0
359/D,"simon array a1 a2 ... , consist n positive integers today simon ask find a pair integers l r ( 1 ≤ l ≤ r ≤ n ) follow condition hold : help simon find require pair number ( l r ) multiple require pair find first line contain integer n ( 1 ≤ n ≤ 3·105 ) second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 106 ) print two integers first line — number require pair maximum value r - l. follow line print l value optimal pair increase order first sample pair number right number 6 9 3 divisible 3 . second sample number divisible number 1 . third sample number prime condition 1 2 true pair number ( 1 1 ) ( 2 2 ) ( 3 3 ) ( 4 4 ) ( 5 5 )","['data structures', 'math']",2000.0
36/A,recently vasya get interest find extra - terrestrial intelligence make a simple extra - terrestrial signal ’ receiver keep a record signal n days a row n days vasya write a 1 notebook receive a signal day a 0 ’ t vasya think find extra - terrestrial intelligence a system way signal receive i.e intervals successive signal equal otherwise vasya think signal send stupid alien one care help vasya deduce information give receiver find extra - terrestrial intelligence first line contain integer n ( 3 ≤ n ≤ 100 ) — amount days vasya check signal second line contain n character 1 0 — record vasya keep n days ’ s guarantee give record sequence contain least three 1s vasya find extra - terrestrial intelligence output yes otherwise output,['implementation'],1300.0
362/A,"a boy petya love chess much even come a chess piece a semiknight semiknight move four directions : 2 square forward 2 square right 2 square forward 2 square leave 2 square backward 2 right 2 square backward 2 leave naturally semiknight move beyond limit chessboard petya put two semiknights a standard chessboard petya simultaneously move semiknights square rather large move semiknights meet , end square meet semiknights move possible meet petya wonder sequence move semiknights meet petya consider square bad , suit meet semiknights move square meet square n't count petya prepare multiple chess board help petya find whether semiknights meet good square board please see test case analysis first line contain number t ( 1 ≤ t ≤ 50 ) — number board board describe a matrix character consist 8 row 8 columns matrix consist character ` ` ` ` ` ` # '' ` ` k '' represent empty good square a bad square semiknight 's position correspondingly guarantee matrix contain exactly 2 semiknights semiknight 's square consider good meet test separate empty line test print a single line answer problem : ` ` yes '' semiknights meet ` ` '' otherwise consider first board sample assume row columns matrix number 1 8 top bottom leave right correspondingly knight meet example square ( 2 7 ) semiknight square ( 4 1 ) go square ( 2 3 ) semiknight go square ( 8 1 ) square ( 6 3 ) semiknights go ( 4 5 ) square bad move together square ( 2 7 ) second board semiknights never meet","['greedy', 'math']",1500.0
362/C,petya a beginner programmer already master basics c++ language move learn algorithms first algorithm encounter insertion sort petya already write code implement algorithm sort give integer zero - indexed array a size n non - decreasing order petya use algorithm sort array permutations number 0 n - 1 . already choose permutation want sort first decide swap two elements petya want choose elements a way number time sort execute function swap minimum help petya find number ways make swap fulfill requirement guarantee 's always possible swap two elements input permutation a way number swap function call decrease first line contain a single integer n ( 2 ≤ n ≤ 5000 ) — length permutation second line contain n different integers 0 n - 1 inclusive — actual permutation print two integers : minimum number time swap function execute number pair ( i j ) swap elements input permutation index i j lead minimum number <unknown> first sample appropriate pair ( 0 3 ) ( 0 4 ) second sample appropriate pair ( 0 4 ) ( 1 4 ) ( 2 4 ) ( 3 4 ),"['data structures', 'dp', 'implementation', 'math']",1900.0
362/D,must hear foolland geography lessons specifically must know federal structure country many centuries country consist n cities pair cities connect bidirectional roads road describe length li fool live land joyfully a recent revolution change king king vasily bear vasily divide country cities regions two cities region a path along roads two cities different regions n't path vasily decide upgrade road network construct exactly p new roads country construct a road go like : vasily want road construct process result country consist exactly q regions task come road construct plan vasily meet requirement minimize total length build roads first line contain four integers n ( 1 ≤ n ≤ 105 ) m ( 0 ≤ m ≤ 105 ) p ( 0 ≤ p ≤ 105 ) q ( 1 ≤ q ≤ n ) — number cities foolland number exist roads number roads plan construct require number regions next m line describe roads exist moment upgrade roads begin line contain three integers xi yi li : xi yi — number cities connect road ( 1 ≤ xi yi ≤ n xi ≠ yi ) li — length road ( 1 ≤ li ≤ 109 ) note one pair cities connect multiple roads construct roads require way impossible print a single string ` ` '' ( without quote ) otherwise first line print word ` ` yes '' ( without quote ) next p line print road construction plan line plan must consist two distinct integers give number cities connect a road road must occur plan order need construct multiple optimal solutions print consider first sample reform foolland consist four regions first region include cities 1 2 3 second region cities 4 6 third region cities 5 7 8 fourth region city 9 . total length roads cities 11 20 5 0 correspondingly accord plan first build road length 6 cities 5 9 road length 23 cities 1 9 . thus total length build roads equal 29,"['data structures', 'greedy']",2100.0
363/E,"let 's assume give n × m table fill integers 'll mark a cell i - th row j - th column ( i j ) thus ( 1 1 ) upper leave cell table ( n m ) lower right cell 'll assume a circle radius r center cell ( i0 j0 ) a set cells ( i j ) 'll consider circle go beyond limit table , r + 1 ≤ i0 ≤ n - r r + 1 ≤ j0 ≤ m - r. find two non - intersecting circle give radius r sum number cells belong circle maximum two circle intersect a cell belong circle one way choose a pair circle maximum sum also interest number pair calculate number unordered pair circle instance a pair circle radius 2 center ( 3 4 ) ( 7 7 ) pair pair circle radius 2 center ( 7 7 ) ( 3 4 ) first line contain three integers n m r ( 2 ≤ n m ≤ 500 r ≥ 0 ) follow n line contain m integers 1 1000 — elements table row table list top bottom elements row list leave right guarantee least one circle radius r go beyond table limit print two integers — maximum sum number cells locate two non - intersecting circle number pair non - intersecting circle maximum sum n't a single pair non - intersecting circle print 0 0","['data structures', 'implementation']",2500.0
367/A,"sereja love sort algorithms recently come a new algorithm receive a string input let 's represent input string algorithm q = q1q2 ... qk algorithm consist two step : sereja think algorithm work correctly string q a non - zero probability algorithm terminate algorithm anyway work infinitely long a string consider algorithm work incorrectly string sereja want test algorithm , string s = s1s2 ... sn consist n character boy conduct a series m test i - th test send substring slisli + 1 ... sri ( 1 ≤ li ≤ ri ≤ n ) algorithm input unfortunately implementation algorithm work long sereja ask help test ( li ri ) determine algorithm work correctly test first line contain non - empty string s length ( n ) n't exceed 105 . guarantee string s contain character : ' x ' ' y ' ' z ' second line contain integer m ( 1 ≤ m ≤ 105 ) — number test next m line contain test i - th line contain a pair integers li ri ( 1 ≤ li ≤ ri ≤ n ) test print ` ` yes '' ( without quote ) algorithm work correctly correspond test ` ` '' ( without quote ) otherwise first example test one two algorithm always terminate one step fourth test get string ` ` <unknown> '' algorithm terminate test algorithm n't work correctly","['data structures', 'implementation']",1500.0
37/C,berland scientists know old berland language exactly n word word lengths l1 l2 ... ln letter every word consist two letter 0 1 . ancient berland people speak quickly ’ t make pause word time could always understand perfectly possible word a prefix another one prefix a string consider one substrings start initial symbol help scientists determine whether word old berland language reconstruct output word first line contain one integer n ( 1 ≤ n ≤ 1000 ) — number word old berland language second line contain n space - separated integers — lengths word lengths natural number exceed 1000 . ’ s set word single line output otherwise first line output yes next n line output word order lengths give input file answer unique output,"['data structures', 'greedy']",1900.0
37/D,petya free computer game time attend university class every day lessons petya ’ s faculty consist two double class floor lessons take place a long corridor m classrooms number 1 m situate along students petya ’ s year divide n group petya notice recently group ’ timetable follow peculiarity : number classroom first lesson a group take place exceed number classroom second lesson group take place petya decide count number ways one make a lesson timetable group timetable a set 2n number : group number room first second lessons take place unfortunately quickly lose track calculations decide count timetables satisfy follow conditions:1 ) first lesson classroom i exactly xi group must <unknown> ) classroom i yi group may place help petya count number timetables satisfy <unknown> a lot timetables output modulo 109 + 7 . first line contain one integer m ( 1 ≤ m ≤ 100 ) — number classrooms second line contain m space - separated integers — xi ( 0 ≤ xi ≤ 100 ) amount group present classroom i first lesson third line contain m space - separated integers — yi ( 0 ≤ yi ≤ 100 ) maximal amount group present classroom i time guarantee xi ≤ yi sum xi positive exceed 1000 . single line output answer problem modulo 109 + 7 . second sample test first second lessons group must take place classroom ’ s timetables different rearrangement classrooms ’ number group e.g 3 ! = 6,"['dp', 'math']",2300.0
370/D,"innocentius a problem — computer monitor break pixels ` ` dead '' , always black consequence innocentius ca n't play usual computer game recently play follow game younger brother polycarpus innocentius touch - type a program paint a white square one - pixel wide frame black screen monitor break pixels white remain black polycarpus look program display screen guess position size frame innocentius paint polycarpus n't like game innocentius persuade brother play ` ` game good imagination attention '' help polycarpus automatize part game process write code find possible square frame : formally a square frame represent pixels solid square square 's border , fully surround pixels square example frame 's size d = 3 consist 8 pixels size d = 2 contain 4 pixels d = 1 frame reduce a single pixel first line contain resolution monitor a pair integers n m ( 1 ≤ n m ≤ 2000 ) next n line contain exactly m character — state monitor pixels moment game character ` ` . '' ( period ascii code 46 ) correspond black pixel character ` ` w '' ( lowercase english letter w ) correspond white pixel guarantee least one pixel monitor white print monitor screen represent seek frame character ` ` + '' ( ` ` plus '' character ) pixels become white game must n't change print ` ` w '' multiple possible ways position frame minimum size print require frame n't exist print a single line contain number -1 . first sample require size optimal frame equal 4 . second sample size optimal frame equal 3 . third sample size optimal frame 1 . fourth sample require frame n't exist","['greedy', 'implementation']",2100.0
375/E,a weight tree consist n vertices vertex either paint black paint red a red black tree call beautiful vertex find a black vertex distance x. distance two nod shortest path a red black tree task make beautiful minimum number color swap operations one color swap operation choose two vertices different color paint color word choose a red vertex p a black vertex q one operation allow paint p black paint q red print minimum number require action first line contain two integers n x ( 2 ≤ n ≤ 500 ; 1 ≤ x ≤ 109 ) next line contain n integers either a zero one i - th number equal 1 vertex i tree black otherwise vertex i red next n - 1 line contain tree edge j - th line contain integers uj vj wj ( 1 ≤ uj vj ≤ n ; uj ≠ vj ; 1 ≤ wj ≤ 109 ) mean tree edge weight wj vertices vj uj assume tree vertices number 1 n. print a single integer — minimum number require swap operations impossible get a beautiful tree number operations print -1,"['dp', 'implementation', 'math']",3000.0
379/C,one well - known internet resource site ( let 's call x ) come a new year adventure specifically decide give rat visitors n users site user know rat value want get a new year present know user i want get least ai rat units a present x site <unknown> creative thrifty people one hand want give distinct rat hand total sum rat present must small possible help site x cope challenge task rat distribution find optimal distribution first line contain integer n ( 1 ≤ n ≤ 3·105 ) — number users site next line contain integer sequence a1 a2 ... ( 1 ≤ ai ≤ 109 ) print a sequence integers b1 b2 ... bn number bi mean user i get bi rat a present print sequence must meet problem condition multiple optimal solutions print,['greedy'],1400.0
380/C,"sereja a bracket sequence s1 s2 ... sn , word a string s length n consist character ` ` ( ` ` ` ` ) '' sereja need answer m query describe two integers li ri ( 1 ≤ li ≤ ri ≤ n ) answer i - th query length maximum correct bracket subsequence sequence sli sli + 1 ... sri help sereja answer query find definitions a subsequence a correct bracket sequence note first line contain a sequence character s1 s2 ... sn ( 1 ≤ n ≤ 106 ) without space character either a ` ` ( ` ` a ` ` ) '' second line contain integer m ( 1 ≤ m ≤ 105 ) — number query next m line contain a pair integers i - th line contain integers li ri ( 1 ≤ li ≤ ri ≤ n ) — description i - th query print answer question a single line print answer order go input a subsequence length |x| string s = s1s2 ... s|s| ( |s| length string s ) string x = sk1sk2 ... sk|x| ( 1 ≤ k1 < k2 < ... < k|x| ≤ |s| ) a correct bracket sequence a bracket sequence transform a correct <unknown> expression insert character ` ` 1 '' ` ` + '' character string example bracket sequence ` ` ( ) ( ) '' ` ` ( ( ) ) '' correct ( result expressions ` ` ( 1 ) + ( 1 ) '' ` ` ( ( 1 + 1 ) +1 ) '' ) ` ` ) ( ` ` ` ` ( ` ` third query require sequence « ( ) » fourth query require sequence « ( ) ( ( ) ) ( ( ) ) »",['data structures'],2000.0
381/B,sereja love integer sequence much especially like stairs sequence a1 a2 ... a|a| ( |a| length sequence ) stairs index i ( 1 ≤ i ≤ |a| ) follow condition meet : example sequence [ 1 2 3 2 ] [ 4 2 ] stairs sequence [ 3 1 2 ] n't sereja m card number want put card table a row get a stair sequence maximum number card put table ? first line contain integer m ( 1 ≤ m ≤ 105 ) — number sereja 's card second line contain m integers bi ( 1 ≤ bi ≤ 5000 ) — number sereja 's card first line print number card put table second line print result stairs,"['greedy', 'implementation']",1100.0
382/C,everybody know arithmetic progression let us remind case arithmetic progression sequence number a1 a2 ... length n follow condition fulfill : example sequence [ 1 5 ] [ 10 ] [ 5 4 3 ] arithmetic progressions sequence [ 1 3 2 ] [ 1 2 4 ] alexander n card contain integers arthur want give alexander exactly one card a number could use result n + 1 card make arithmetic progression ( alexander use card ) arthur already buy a card n't write a number help print integers write a card describe condition fulfil first line contain integer n ( 1 ≤ n ≤ 105 ) — number card next line contain sequence integers — number alexander 's card number positive integers n't exceed 108 . arthur write infinitely many distinct integers card print a single line -1 . otherwise print first line number integers suit second line print number increase order note number answer exceed 108 even negative ( see test sample ),['implementation'],1700.0
382/E,ksenia winter exams today learn combinatorics 's one problems need learn solve many distinct tree consist n vertices follow properties : two tree consider distinct two vertices u v one tree connect edge tree help ksenia solve problem give n k. answer problem huge output modulo 1000000007 ( 109 + 7 ) first line contain two integers n k ( 1 ≤ n k ≤ 50 ) print a single integer — answer problem modulo 1000000007 ( 109 + 7 ) n't familiar match please read follow link : http : //en.wikipedia.org / wiki / <unknown> _ ( graph_theory ),['dp'],2600.0
383/B,iahub get lose a big desert desert represent a n × n square matrix cell a zone desert cell ( i j ) represent cell row i column j ( 1 ≤ i j ≤ n ) iahub go one cell ( i j ) right cells ( i + 1 j ) ( i j + 1 ) also m cells occupy volcanoes iahub enter iahub initially cell ( 1 1 ) need travel cell ( n n ) know iahub need 1 second travel one cell another find minimum time arrive cell ( n n ) first line contain two integers n ( 1 ≤ n ≤ 109 ) m ( 1 ≤ m ≤ 105 ) next m line contain a pair integers x y ( 1 ≤ x y ≤ n ) represent coordinate volcanoes consider matrix row number 1 n top bottom matrix columns number 1 n leave right <unknown> cell ( 1 1 ) two volcanoes occupy location print one integer minimum time iahub arrive cell ( n n ) solution exist ( path final cell ) print -1 . consider first sample a possible road : ( 1 1 ) → ( 1 2 ) → ( 2 2 ) → ( 2 3 ) → ( 3 3 ) → ( 3 4 ) → ( 4 4 ),['implementation'],2500.0
384/A,iahub like chess much even invent a new chess piece name coder a coder move ( attack ) one square horizontally vertically precisely coder locate position ( x y ) move ( attack ) position ( x + 1 y ) ( <unknown> y ) ( x y + 1 ) ( x <unknown> ) iahub want know many coders place n × n chessboard coder attack coder first line contain integer n ( 1 ≤ n ≤ 1000 ) first line print integer maximum number coders place chessboard next n line print n character describe configuration coders empty cell print ' ' a coder print a ' c ' multiple correct answer print,['implementation'],800.0
388/B,fox ciel want write a task a program contest task : ` ` give a simple undirected graph n vertexes edge unit length calculate number shortest paths vertex 1 vertex 2 ` ` writers want make example certain output : example birthday number boyfriend help make a test case answer equal exactly k ? first line contain a single integer k ( 1 ≤ k ≤ 109 ) output a graph g n vertexes ( 2 ≤ n ≤ 1000 ) must exactly k shortest paths vertex 1 vertex 2 graph first line must contain integer n. adjacency matrix g n row n columns must follow element matrix must ' n ' ' y ' gij ' y ' graph g a edge connect vertex i vertex j. consider graph vertexes number 1 n. graph must undirected simple : gii = ' n ' gij = gji must hold must least one path vertex 1 vertex 2 . 's guarantee answer exist multiple correct answer output first example 2 shortest paths : 1 - 3 - 2 1 - 4 - 2 . second example 9 shortest paths : 1 - 3 - 6 - 2 1 - 3 - 7 - 2 1 - 3 - 8 - 2 1 - 4 - 6 - 2 1 - 4 - 7 - 2 1 - 4 - 8 - 2 1 - 5 - 6 - 2 1 - 5 - 7 - 2 1 - 5 - 8 - 2,"['implementation', 'math']",1900.0
39/J,petya notice type use a keyboard often press extra button add extra letter word course spell - <unknown> system underline word click every word choose right variant petya get feed correct mistake ’ s decide invent function correct word petya start analyze case happen time one need delete one letter word match a word dictionary thus petya face one mini - task : a print word a word dictionary delete one letter first word get second one non - trivial question petya face : letter delete ? input data contain two string consist lower - case latin letter length string 1 106 symbols inclusive first string contain exactly 1 symbol second one first line output number position symbols first string delete first string become identical second one second line output space - separated position symbols increase order position number start 1 . impossible make first string identical second string delete one symbol output one number 0,['implementation'],1500.0
400/B,"inna like sweets a game call ` ` candy matrix '' today come new game ` ` candy matrix 2 : reload '' field new game a rectangle table size n × m. line table contain one cell a dwarf <unknown> one cell a candy cells line empty game last several move move player choose line matrix dwarf cell candy shout ` ` let 's go ! ` ` , dwarves choose line start simultaneously move right second dwarf go adjacent cell locate right current cell movement continue one follow events occur : point game transport dwarves candy cells inna fabulous come interest game ? task play game optimally well specifically say give game field minimum number move player need reach goal game first line input contain two integers n m ( 1 ≤ n ≤ 1000 ; 2 ≤ m ≤ 1000 ) next n line contain m character — game field ` ` candy <unknown> 2 : reload '' character ` ` * '' represent empty cell field character ` ` g '' represent a dwarf character ` ` s '' represent a candy matrix n't contain character guarantee line contain exactly one character ` ` g '' one character ` ` s '' a single line print a single integer — either minimum number move need achieve aim game -1 aim achieve give game field",['implementation'],1200.0
401/B,sereja a coder like take part codesorfes round however <unknown> n't good internet connection sereja sometimes skip round codesorfes round two type : div1 ( advance coders ) div2 ( beginner coders ) two round div1 div2 go simultaneously ( div1 round hold without div2 ) case round n't overlap time round a unique identifier — a positive integer round sequentially ( without gap ) number identifiers start time round identifiers round run simultaneously different one also identifier div1 round always greater sereja a beginner coder take part round div2 type moment take part a div2 round identifier equal x. sereja remember well take part exactly k round round also remember identifiers round take part identifiers round go simultaneously sereja n't remember anything round miss sereja wonder : minimum maximum number div2 round could miss ? help find two number first line contain two integers : x ( 1 ≤ x ≤ 4000 ) — round sereja take part today k ( 0 ≤ k < 4000 ) — number round take part next k line contain descriptions round sereja take part sereja take part one two simultaneous round correspond line look like : ` ` 1 num2 num1 '' ( num2 identifier div2 round num1 identifier div1 round ) guarantee num1 - num2 = 1 . sereja take part a usual div2 round correspond line look like : ` ` 2 num '' ( num identifier div2 round ) guarantee identifiers give round less x. print a single line two integers — minimum maximum number round sereja could miss second sample unused identifiers round 1 6 7 . minimum number round sereja could miss equal 2 . case round identifier 1 a usual div2 round round identifier 6 <unknown> div1 round maximum number round equal 3 . case unused identifiers belong usual div2 round,"['greedy', 'implementation', 'math']",1200.0
405/A,little chris bore physics lessons ( easy ) build a toy box keep occupy box special since ability change gravity n columns toy cub box arrange a line i - th column contain ai cub first gravity box pull cub downwards chris switch gravity begin pull cub right side box figure show initial final configurations cub box : cub change position highlight orange give initial configuration toy cub box find amount cub n columns gravity switch ! first line input contain integer n ( 1 ≤ n ≤ 100 ) number columns box next line contain n space - separated integer number i - th number ai ( 1 ≤ ai ≤ 100 ) denote number cub i - th column output n integer number separate space i - th number amount cub i - th column gravity switch first example case show figure top cube first column fall top last column ; top cube second column fall top third column ; middle cube first column fall top second column second example case gravity switch change heights columns,"['greedy', 'implementation']",900.0
405/D,little chris keen toy block teacher however want chris solve problems decide play a trick chris exactly s block chris 's set block a unique number 1 s. chris 's teacher pick a subset block x keep give back chris pick a non - empty subset y remain block equality hold : example consider a case s = 8 chris 's teacher take block number 1 4 5 . one way chris choose a set pick block number 3 6 see figure require sum would equal : ( 1 - 1 ) + ( 4 - 1 ) + ( 5 - 1 ) = ( 8 - 3 ) + ( 8 - 6 ) = 7 . however chris exactly s = 106 block give set x block teacher choose help chris find require set y ! first line input contain a single integer n ( 1 ≤ n ≤ 5·105 ) number block set x. next line contain n distinct space - separated integers x1 x2 ... xn ( 1 ≤ xi ≤ 106 ) number block x. note : since size input output could large n't use slow output techniques language example use input output stream ( cin cout ) c++ first line output print a single integer m ( 1 ≤ m ≤ 106 - n ) number block set y. next line output m distinct space - separated integers y1 y2 ... ym ( 1 ≤ yi ≤ 106 ) require equality hold set x y intersect i.e xi ≠ yj i j ( 1 ≤ i ≤ n ; 1 ≤ j ≤ m ) guarantee least one solution always exist multiple solutions output,"['greedy', 'implementation', 'math']",1700.0
407/D,give matrix a size n × m elements integers assume row matrix number top bottom 1 n columns number leave right 1 m. denote element intersect i - th row j - th column aij 'll call submatrix i1 j1 i2 j2 ( 1 ≤ i1 ≤ i2 ≤ n ; 1 ≤ j1 ≤ j2 ≤ m ) elements aij give matrix i1 ≤ i ≤ i2 j1 ≤ j ≤ j2 'll call area submatrix number ( i2 - i1 + 1 ) · ( j2 - j1 + 1 ) 'll call a submatrix <unknown> elements distinct find largest ( area ) inhomogenous submatrix give matrix first line contain two integers n m ( 1 ≤ n m ≤ 400 ) — number row columns matrix correspondingly next n line contain m integers aij ( 1 ≤ aij ≤ <unknown> ) — elements matrix print a single integer — area optimal inhomogenous submatrix,['dp'],2700.0
41/A,translation berland language <unknown> language easy task languages similar : a berlandish word differ a birlandish word mean a little : spell ( pronounce ) reversely example a berlandish word code correspond a birlandish word <unknown> however 's easy make a mistake « translation » vasya translate word s berlandish birlandish t. help : find translate word correctly first line contain word s second line contain word t. word consist lowercase latin letter input data consist unnecessary space word empty lengths exceed 100 symbols word t a word s write reversely print yes otherwise print,['implementation'],800.0
411/A,probably register internet sit many time time enter invent password usually registration form automatically check password 's <unknown> resistance user 's password n't complex enough a message display today task implement automatic check web - developers company q assume a password complex enough meet follow condition : give a password please implement automatic check complexity company q. first line contain a non - empty sequence character ( 100 character ) character either a large english letter a small english letter a digit one character : ` ` ! ` ` ` ` ? ` ` ` ` ` ` ` ` '' ` ` _ '' password complex enough print message ` ` correct '' ( without quote ) otherwise print message ` ` weak '' ( without quote ),['implementation'],800.0
412/B,r1 company want hold a web search championship n computers give competition connect internet organizers believe data transfer speed directly affect result higher speed internet faster participant find necessary information therefore competition start computer maximum possible data transfer speed measure i - th computer ai kilobits per second k participants compete championship get a separate computer organize company want participants advantage others want provide data transfer speed participant 's computer also organizers want create comfortable condition participants data transfer speed participants ' computers large possible network settings r1 company a special option let cut initial maximum data transfer speed computer lower speed r1 company configure network use describe option least k n computers data transfer speed data transfer speed computers large possible ? first line contain two space - separated integers n k ( 1 ≤ k ≤ n ≤ 100 ) — number computers number participants respectively second line a space - separated sequence consist n integers : a1 a2 ... ( 16 ≤ ai ≤ 32768 ) ; number ai denote maximum data transfer speed i - th computer print a single integer — maximum internet speed value guarantee answer problem always integer first test case organizers cut first computer 's speed 30 kilobits two computers ( first third one ) speed 30 kilobits use participants ' computers answer optimal,['greedy'],900.0
413/B,"r2 company n employees work work involve constant exchange ideas share stories success upcoming challenge , r2 use a famous instant message program spyke r2 m spyke chat discuss sort issue chat group employees exchange message daily employee simultaneously talk multiple chat employee k - th chat write message chat receive notifications message chat employee write a message chat participants chat receive a message <unknown> r2 company conduct audit specialists study effective communication employees purpose a chat log description chat structure , one audit specialists commission write a program use data determine total number message notifications receive employee first line contain three space - separated integers n m k ( 2 ≤ n ≤ 2·104 ; 1 ≤ m ≤ 10 ; 1 ≤ k ≤ 2·105 ) — number employees number chat number events log correspondingly next n line contain matrix a size n × m consist number zero one element matrix record j - th column i - th line ( let 's denote aij ) equal 1 i - th employee participant j - th chat otherwise element equal 0 . assume employees number 1 n chat number 1 m. next k line contain description log events i - th line contain two space - separated integers xi yi ( 1 ≤ xi ≤ n ; 1 ≤ yi ≤ m ) mean employee number xi send one message chat number yi guarantee employee number xi a participant chat yi guarantee chat contain least two employees print single line n space - separated integers i - th integer show number message notifications i - th employee receive",['implementation'],1300.0
414/B,mashmokh 's boss bimokh n't like mashmokh fire mashmokh decide go university participate acm instead find a new job want become a member <unknown> 's team order join give program task one week solve mashmokh a experience programmer actually a programmer n't able solve 's ask help task one task follow a sequence l integers b1 b2 ... bl ( 1 ≤ b1 ≤ b2 ≤ ... ≤ bl ≤ n ) call good number divide ( without a remainder ) next number sequence formally i ( 1 ≤ i ≤ l - 1 ) give n k find number good sequence length k. answer rather large print modulo 1000000007 ( 109 + 7 ) first line input contain two space - separated integers n k ( 1 ≤ n k ≤ 2000 ) output a single integer — number good sequence length k modulo 1000000007 ( 109 + 7 ) first sample good sequence : [ 1 1 ] [ 2 2 ] [ 3 3 ] [ 1 2 ] [ 1 3 ],['dp'],1400.0
415/B,bimokh mashmokh 's boss follow n days decide pay workers a new way begin day give worker a certain amount tokens end day worker give tokens back get a certain amount money worker save rest tokens ca n't use day get money a worker give back w tokens 'll get dollars mashmokh like tokens however like money 's want save many tokens possible amount money get maximal possible day n number x1 x2 ... xn number xi number tokens give worker i - th day help calculate n days number tokens save first line input contain three space - separated integers n a b ( 1 ≤ n ≤ 105 ; 1 ≤ a b ≤ 109 ) second line input contain n space - separated integers x1 x2 ... xn ( 1 ≤ xi ≤ 109 ) output n space - separated integers i - th number tokens mashmokh save i - th day,"['greedy', 'implementation', 'math']",1500.0
417/B,"` ` russian code cup '' program competition test system store send solutions participant know many participants use random number program often send several solutions source code check participant identify unique positive integer k send solution a characterize two number : x — number different solutions send first solution identical a k — number participant author solution consequently identical solutions x. know data test system store chronological order , test system a solution number x ( x > 0 ) participant number k test system a solution number x - 1 participant store somewhere competition check system crash data submissions participants restore jury want verify recover data chronological order help jury first line input contain integer n ( 1 ≤ n ≤ 105 ) — number solutions follow n line contain two integers separate space x k ( 0 ≤ x ≤ 105 ; 1 ≤ k ≤ 105 ) — number previous unique solutions identifier participant a single line output contain « yes » data chronological order « » otherwise",['implementation'],1400.0
421/A,"pasha two hamsters : arthur alexander pasha put n apples front pasha know apples arthur like similarly pasha know apples alexander like pasha n't want conflict hamsters ( may like apple ) decide distribute apples hamsters go give apples arthur apples alexander n't matter many apples hamster get important hamster get apples like possible somebody n't get apples help pasha distribute apples hamsters note pasha want distribute apples , first line contain integers n a b ( 1 ≤ n ≤ 100 ; 1 ≤ a b ≤ n ) — number apples pasha number apples arthur like number apples alexander like correspondingly next line contain a distinct integers — number apples arthur like next line contain b distinct integers — number apples alexander like assume apples number 1 n. input answer exist print n character equal either 1 2 . i - h character equal 1 i - th apple give arthur otherwise give alexander multiple correct answer allow print",['implementation'],800.0
427/A,"police department city start journey initially ’ t <unknown> , start hire new recruit group meanwhile crimes keep occur within city one member police force investigate one crime his / her lifetime police officer free ( n't busy crime ) occurrence a crime go untreated give chronological order crime occurrences recruit hire find number crimes go untreated first line input contain integer n ( 1 ≤ n ≤ 105 ) number events next line contain n space - separated integers integer -1 mean a crime occur otherwise integer positive number officer recruit together time 10 officer recruit a time print a single integer number crimes go untreated let consider second example : answer one one crime ( step 5 ) go untreated",['implementation'],800.0
429/C,iahub iahubina go a picnic a forest full tree less 5 minutes pass iahub remember tree program moreover invent a new problem iahubina solve otherwise iahub wo n't give food iahub ask iahubina : build a root tree <unknown> guess tree a smart girl realize 's possible tree follow iahub 's restrictions way iahub eat food need help iahubina : determine 's least one tree follow iahub 's restrictions require tree must contain n nod first line input contain integer n ( 1 ≤ n ≤ 24 ) next line contain n positive integers : i - th number represent ci ( 1 ≤ ci ≤ n ) output first line ` ` yes '' ( without quote ) exist least one tree follow iahub 's restrictions otherwise output ` ` '' ( without quote ),"['dp', 'greedy']",2300.0
43/B,vasya decide write anonymous letter cut letter a newspaper head know head s1 text s2 want send vasya use every single head letter vasya n't cut space head — leave blank space mark help ; find manage compose need text first line contain a newspaper head s1 second line contain letter text s2 s1 и s2 non - empty line consist space uppercase lowercase latin letter whose lengths exceed 200 symbols uppercase lowercase letter differentiate vasya cut space head vasya write give anonymous letter print yes otherwise print,['implementation'],1100.0
431/D,one day a difficult lecture a diligent student sasha saw a <unknown> desk classroom come closer read : ` ` find positive integer n among number n + 1 n + 2 ... 2·n exactly m number binary representation contain exactly k digits one '' girl get interest task ask help solve sasha know afraid large number guarantee answer n't exceed 1018 . first line contain two space - separated integers m k ( 0 ≤ m ≤ 1018 ; 1 ≤ k ≤ 64 ) print require number n ( 1 ≤ n ≤ 1018 ) multiple answer print,"['dp', 'math']",2100.0
432/B,consider a football tournament n team participate team two football kit : home game away game kit home game i - th team color xi kit away game team color yi ( xi ≠ yi ) tournament team play exactly one home game exactly one away game team ( n ( n - 1 ) game total ) team play home game traditionally play home kit team play away game play away kit however two team kit color distinguish case away team play home kit calculate many game describe tournament team play home kit many game play away kit first line contain a single integer n ( 2 ≤ n ≤ 105 ) — number team next n line contain description team i - th line contain two space - separated number xi yi ( 1 ≤ xi yi ≤ 105 ; xi ≠ yi ) — color number home away kit i - th team team print a single line two space - separated integers — number game team go play home away kit correspondingly print answer team order appear input,"['greedy', 'implementation']",1200.0
433/D,nanami expert play game day nanami 's good friend <unknown> invite watch a game <unknown> unwilling follow stadium nanami interest game look around see something might interest 's saw digital board one end stadium digital board n pixels height m pixels width every pixel either light dark pixels describe coordinate j - th pixel i - th line pixel ( i j ) board display message switch a combination pixels light rest dark nanami notice state pixels board change time time certain time certain pixels board may switch light dark dark light nanami wonder area biggest light block a specific pixel side a light block a sub - rectangle board pixels light pixel ( i j ) belong a side sub - rectangle ( x1 y1 ) ( x2 y2 ) upper - left lower - right vertex satisfy logical condition : nanami history change pixels also question describe type answer ? first line contain three space - separated integers n m q ( 1 ≤ n m q ≤ 1000 ) — height width digital board number operations follow n line line contain m space - separated integers j - th integer i - th line ai j — initial state pixel ( i j ) follow q line line contain three space - separated integers op x y ( 1 ≤ op ≤ 2 ; 1 ≤ x ≤ n ; 1 ≤ y ≤ m ) describe operation query print a single line contain one integer — answer nanami 's query consider first sample first query specify pixel ( 2 2 ) dark valid light block thus answer 0 . second query specify pixel ( 1 2 ) biggest light block block ( 1 2 ) upper - left vertex ( 1 3 ) lower - right vertex last query specify pixel ( 2 2 ) become light third operation biggest light block block ( 1 2 ) upper - left vertex ( 3 3 ) lower - right vertex,['implementation'],2000.0
435/C,"problem task use ascii graphics paint a cardiogram a cardiogram a polyline follow corner : a cardiogram fully define a sequence positive integers a1 a2 ... , task paint a cardiogram give sequence ai first line contain integer n ( 2 ≤ n ≤ 1000 ) next line contain sequence integers a1 a2 ... ( 1 ≤ ai ≤ 1000 ) guarantee sum ai n't exceed 1000 . print max |yi - yj| line ( yk y coordinate k - th point polyline ) line print character character must equal either « / » ( slash ) « \ » ( <unknown> ) « » ( space ) print image must image give polyline please study test sample better understand print a cardiogram note problem checker check answer take space consideration print extra character remember wrong answer first pretest n't give a penalty due technical reason answer sample copy statement ' ve attach two text document answer <unknown> : //assets.codeforces.com / <unknown> : //assets.codeforces.com / <unknown>",['implementation'],1600.0
435/D,give n × m grid nod black others white moreover 's ordinary grid — unit square grid paint diagonals figure example grid size 3 × 5 . four nod grid black 11 nod white task count number triangles give grid : first line contain two integers n m ( 2 ≤ n m ≤ 400 ) follow n line contain m character ( zero ones ) — description grid j - th character i - th line equal zero node i - th horizontal line j - th vertical line paint white otherwise node paint black horizontal line number start one top bottom vertical line number start one leave right print a single integer — number require triangles figure show red blue triangles examples require triangles first sample one invalid triangles paint green invalid side go along grid line,"['dp', 'greedy']",2000.0
436/B,"om nom really like candy n't like spiders frequently steal candy one day om nom fancy a walk a park unfortunately park spiders om nom n't want see park represent a rectangular n × m field park k spiders spider time 0 cell field spiders move time spider always move one four directions ( leave right , ) a unit time a spider crawl cell side - adjacent cell correspond direction cell give direction spider leave park spiders interfere move specifically one cell multiple spiders time om nom n't yet sure start walk definitely want : know om nom move jump one jump take one time unit transport little monster cell either a side - adjacent cell lower row outside park boundaries time om nom land a cell see spiders come cell moment time om nom want choose optimal cell start walk 's wonder : possible start cell many spiders see walk start cell ? help calculate require value possible start cell first line contain three integers n m k ( 2 ≤ n m ≤ 2000 ; 0 ≤ k ≤ m ( n - 1 ) ) next n line contain m character — description park character i - th line describe i - th row park field character line equal ` ` ` ` mean correspond cell field empty ; otherwise character line equal one four character : ` ` l '' ( mean cell a spider time 0 move leave ) ` ` r '' ( a spider move right ) ` ` u '' ( a spider move ) ` ` d '' ( a spider move ) guarantee first row n't contain spiders guarantee description field contain extra character guarantee time 0 field contain exactly k spiders print m integers : j - th integer must show number spiders om nom see start walk j - th cell first row cells row field number leave right consider first sample note show spider arrangement change field time : character ` ` * '' represent a cell contain two spiders time","['implementation', 'math']",1400.0
439/B,devu a dumb guy learn curve slow suppose teach n subject ith subject ci chapters teach suppose teach chapters a subject continuously let us say initial per chapter learn power a subject x hours word learn a chapter a particular subject x hours well devu complete dumb a good thing teach a subject time require teach chapter next subject require exactly 1 hour less previously require ( see examples understand clearly ) note per chapter learn power less 1 hour teach n subject possible order find minimum amount time ( hours ) devu take understand subject free enjoy task rather teach a dumb guy please careful answer might fit 32 bite data type first line contain two space separate integers n x ( 1 ≤ n x ≤ 105 ) next line contain n space separate integers : c1 c2 ... cn ( 1 ≤ ci ≤ 105 ) output a single integer represent answer problem look first example consider order subject : 1 2 . teach devu first subject take 3 hours per chapter take 12 hours teach first subject teach first subject per chapter learn time 2 hours teach second subject take 2 × 1 = 2 hours hence need spend 12 + 2 = 14 hours consider order subject : 2 1 . teach devu second subject take 3 hours per chapter take 3 × 1 = 3 hours teach second subject teach second subject per chapter learn time 2 hours teach first subject take 2 × 4 = 8 hours hence need spend 11 hours overall minimum case 11 hours look third example order example n't matter teach devu first subject take 3 hours per chapter teach devu second subject take 2 hours per chapter teach devu third subject take 1 hours per chapter total take 6 hours,['implementation'],1200.0
439/C,devu a small kid like play a lot like play array play come interest question could solve please solve ? give array consist distinct integers possible partition whole array k disjoint non - empty part p part even sum ( must even sum ) remain k - p odd sum ? ( note part need continuous ) possible partition array also give possible way valid partition first line contain three space separate integers n k p ( 1 ≤ k ≤ n ≤ 105 ; 0 ≤ p ≤ k ) next line contain n space - separated distinct integers represent content array a : a1 a2 ... ( 1 ≤ ai ≤ 109 ) first line print ` ` yes '' ( without quote ) possible partition array require way otherwise print ` ` '' ( without quote ) require partition exist print k line first line ith contain content ith part print content part line follow way : firstly print number elements part print elements part arbitrary order must exactly p part even sum remain k - p part must odd sum multiple partition allow print valid partition,['implementation'],1700.0
44/B,"celebrate open winter computer school organizers decide buy n liters cola however unexpected difficulty occur shop : turn cola sell bottle 0.5 1 2 liters volume , exactly a bottle 0.5 volume b one - liter bottle c two - liter ones organizers enough money buy amount cola cause heat arguments many bottle every kind buy question <unknown> distribution cola among participants ( organizers well ) thus organizers argument discuss different variants buy cola winter school ca n't start task count number possible ways buy exactly n liters cola persuade organizers number large keep argue winter computer school organize summer bottle cola consider indistinguishable i.e two variants buy different differ number bottle least one kind first line contain four integers — n a b c ( 1 ≤ n ≤ 10000 0 ≤ a b c ≤ 5000 ) print unique number — solution problem impossible buy exactly n liters cola print 0",['implementation'],1500.0
440/D,"recently berland face <unknown> request often <unknown> propose divide country separate state moreover demand a state include exactly k towns currently berland n towns pair connect <unknown> roads berland n - 1 roads reach city capital , road network form a tree ministry roads fear reform roads connect towns different state bring a lot trouble task come a plan divide country state : first line contain integers n k ( 1 ≤ k ≤ n ≤ 400 ) follow n - 1 line describe a road berland roads give pair integers xi yi ( 1 ≤ xi yi ≤ n ; xi ≠ yi ) — number towns connect road assume towns number 1 n. first line print require minimum number ` ` problem '' roads t. print a sequence t integers — indices find division roads number start 1 order follow input multiple possible solutions print solution show ` ` problem '' roads print a single integer 0 either leave second line empty print",['dp'],2200.0
441/A,valera a collector want expand collection exactly one antique item valera know n sellers antique i - th auction ki items currently auction price j - th object i - th seller sij valera get well n sellers perfectly sure outbid current price one items auction ( word offer seller money strictly greater current price item auction ) seller object immediately sign a contract unfortunately valera v units money help determine n sellers make a deal first line contain two space - separated integers n v ( 1 ≤ n ≤ 50 ; 104 ≤ v ≤ 106 ) — number sellers units money valera n line follow i - th line first contain integer ki ( 1 ≤ ki ≤ 50 ) number items i - th seller go ki space - separated integers <unknown> <unknown> ... <unknown> ( 104 ≤ sij ≤ 106 ) — current price items i - th seller first line print integer p — number sellers valera make a deal second line print p space - separated integers q1 q2 ... <unknown> ( 1 ≤ qi ≤ n ) — number sellers valera make a deal print number sellers increase order first sample valera bargain sellers outbid follow items : a 40000 item first seller a 20000 item second seller a 10000 item third seller second sample valera make a deal sellers price items auction big,['implementation'],1000.0
449/A,jzzhu a big rectangular chocolate bar consist n × m unit square want cut bar exactly k time cut must meet follow requirements : picture show a possible way cut a 5 × 6 chocolate 5 time imagine jzzhu make k cut big chocolate splitted several piece consider smallest ( area ) piece chocolate jzzhu want piece large possible maximum possible area smallest piece get exactly k cut ? area a chocolate piece number unit square a single line contain three integers n m k ( 1 ≤ n m ≤ 109 ; 1 ≤ k ≤ 2·109 ) output a single integer represent answer impossible cut big chocolate k time print -1 . first sample jzzhu cut chocolate follow picture : second sample optimal division look like : third sample 's impossible cut a 2 × 3 chocolate 4 time,"['greedy', 'math']",1700.0
451/C,n game a football tournament three team participate currently k game already play avid football fan recently miss whole k game fortunately remember a guess friend k game friend tell exact number win team instead think absolute difference number win first second team d1 second third team d2 n't want team win tournament team number win n game 's want know : exist a valid tournament satisfy friend 's guess team win tournament ? note outcome a match a draw either win loss first line input contain a single integer correspond number test case t ( 1 ≤ t ≤ 105 ) next t line contain four space - separated integers n k d1 d2 ( 1 ≤ n ≤ 1012 ; 0 ≤ k ≤ n ; 0 ≤ d1 d2 ≤ k ) — data current test case test case output a single line contain either ` ` yes '' possible winner tournament ` ` '' otherwise ( without quote ) sample 1 . match ( k = 0 d1 = 0 d2 = 0 ) three match ( 1 - 2 2 - 3 3 - 1 ) team win end team 1 win sample 2 . miss game ( k = 3 ) d1 = 0 d2 = 0 a way play three game winner tournament ( describe previous sample ) answer ` ` yes '' sample 3 . miss 4 match d1 = 1 d2 = 0 . four match : 1 - 2 ( win 2 ) 1 - 3 ( win 3 ) 1 - 2 ( win 1 ) 1 - 3 ( win 1 ) currently first team 2 win second team 1 win third team 1 win two remain match : 1 - 2 ( win 2 ) 1 - 3 ( win 3 ) end team equal number win ( 2 win ),"['implementation', 'math']",1700.0
452/A,solve crossword problem k <unknown> 2014 . solve clue except one : eevee evolve ? pokemons quick google help find eevee evolve eight different pokemons : vaporeon jolteon flareon espeon umbreon leafeon glaceon sylveon know length word crossword already know letter designers crossword make sure answer unambiguous assume exactly one pokemon 8 eevee evolve fit length letter give task find first line contain integer n ( 6 ≤ n ≤ 8 ) – length string next line contain a string consist n character either a lower case english letter ( indicate a know letter ) a dot character ( indicate empty cell crossword ) print a name pokemon eevee evolve match pattern input use lower case letter print name ( particular capitalize first letter ) 's a set name a form paste solution : [ ` ` vaporeon '' ` ` jolteon '' ` ` flareon '' ` ` espeon '' ` ` umbreon '' ` ` leafeon '' ` ` glaceon '' ` ` sylveon '' ] { ` ` vaporeon '' ` ` jolteon '' ` ` flareon '' ` ` espeon '' ` ` umbreon '' ` ` leafeon '' ` ` glaceon '' ` ` sylveon '' },['implementation'],1000.0
457/F,pieguy piegirl play a game a root binary tree a property node either a leaf exactly two children leaf a number associate his / her turn a player choose two leaf share immediate parent remove associate either value parent become a leaf ( player decide two value associate ) game end one node ( one root tree ) leave pieguy go first goal maximize value associate root game end piegirl want minimize value assume players play optimally number associate root game end ? first line contain a single integer t ( 1 ≤ t ≤ 100 ) — number test case t test case follow test case begin empty line follow a line a single integer n ( 1 ≤ n ≤ 250 ) follow n line describe n nod tree n line either contain a non - negative number ai indicate a leaf node value ai ( 0 ≤ ai ≤ 1000 ) associate - 1 follow integers l r indicate a non - leaf node children l r ( 0 ≤ l r ≤ n - 1 ) nod number 0 n - 1 . root always node 0 . test case print one line one integer — number associate root game end,"['dp', 'greedy']",3200.0
459/A,"pashmak fall love <unknown> girl call parmida since one year ago ... today pashmak set a meet partner a <unknown> garden unfortunately pashmak forget garden remember garden look like a square side parallel coordinate ax also remember exactly one tree vertex square , pashmak know position two tree help find position two remain ones first line contain four space - separated x1 y1 x2 y2 ( - 100 ≤ x1 y1 x2 y2 ≤ 100 ) integers x1 y1 coordinate first tree x2 y2 coordinate second tree 's guarantee give point distinct solution problem print -1 . otherwise print four space - separated integers x3 y3 x4 y4 correspond coordinate two tree several solutions output note x3 y3 x4 y4 must range ( - 1000 ≤ x3 y3 x4 y4 ≤ 1000 )",['implementation'],1200.0
460/A,vasya n pair sock morning day vasya put a pair sock go school come home even vasya take use sock throw away every m - th day ( days number m 2 m 3 m ... ) mom buy a pair sock vasya late even vasya put a new pair sock next day many consecutive days pass vasya run sock ? single line contain two integers n m ( 1 ≤ n ≤ 100 ; 2 ≤ m ≤ 100 ) separate a space print a single integer — answer problem first sample vasya spend first two days wear sock initially day three put sock buy day two second sample vasya spend first nine days wear sock initially spend three days wear sock buy third sixth ninth days spend another day wear sock buy twelfth day,"['implementation', 'math']",900.0
463/C,gargari jealous friend caisa game previous problem want prove a genius a n × n chessboard cell chessboard a number write gargari want place two bishops chessboard a way cell attack consider a cell number x write cell attack one bishops gargari get x dollars tell gargari place bishops chessboard get maximum amount money assume a cell attack a bishop cell locate diagonal bishop ( cell bishop also consider attack ) first line contain a single integer n ( 2 ≤ n ≤ 2000 ) next n line contain n integers aij ( 0 ≤ aij ≤ 109 ) — description chessboard first line print maximal number dollars gargari get next line print four integers : x1 y1 x2 y2 ( 1 ≤ x1 y1 x2 y2 ≤ n ) xi number row i - th bishop place yi number column i - th bishop place consider row number 1 n top bottom columns number 1 n leave right several optimal solutions print,"['greedy', 'implementation']",1900.0
463/D,gargari get bore play bishops solve problem try math homework a math book find k permutations consist number 1 2 ... n order find length longest common subsequence permutations help gargari ? read longest common subsequence : https : //en.wikipedia.org / wiki / <unknown> first line contain two integers n k ( 1 ≤ n ≤ 1000 ; 2 ≤ k ≤ 5 ) next k line contain integers 1 2 ... n order — description current permutation print length longest common subsequence answer first test sample subsequence [ 1 2 3 ],"['dp', 'implementation']",1900.0
464/C,andrew eugene play a game initially andrew string s consist digits eugene send andrew multiple query type ` ` di → ti '' mean ` ` replace digits di string s substrings equal ti '' example s = <unknown> query ` ` 2 → 00 '' transform s <unknown> query ` ` 3 → ` ` ( ` ` replace 3 empty string '' ) transform s = <unknown> . query eugene ask andrew find remainder division number decimal representation equal s 1000000007 ( 109 + 7 ) represent s a decimal number please ignore lead zero ; also s empty string 's assume number equal zero andrew get tire process eugene 's request manually ask write a program help ! first line contain string s ( 1 ≤ |s| ≤ 105 ) consist digits — string process request second line contain a single integer n ( 0 ≤ n ≤ 105 ) — number query next n line contain descriptions query i - th query describe string ` ` <unknown> > ti '' di exactly one digit ( 0 9 ) ti a string consist digits ( ti empty string ) sum lengths ti query n't exceed 105 . query write order need perform print a single integer — remainder division result number 1000000007 ( 109 + 7 ) note lead zero remove string s replacement ( see third sample ),['dp'],2100.0
464/E,give a weight undirected graph n vertices m edge find shortest path vertex s vertex t else state path n't exist first line input contain two space - separated integers — n m ( 1 ≤ n ≤ 105 ; 0 ≤ m ≤ 105 ) next m line contain description graph edge i - th line contain three space - separated integers — ui vi xi ( 1 ≤ ui vi ≤ n ; 0 ≤ xi ≤ 105 ) mean vertices number ui vi connect edge length <unknown> ( 2 power xi ) last line contain two space - separated integers — number vertices s t. vertices number 1 n. graph contain multiple edge self - loops first line print remainder divide length shortest path 1000000007 ( 109 + 7 ) path exist -1 path n't exist path exist print second line integer k — number vertices shortest path vertex s vertex t ; third line print k space - separated integers — vertices shortest path visit order first vertex vertex s last vertex vertex t. multiple shortest paths print a path vertex s vertex t a sequence v0 ... vk v0 = s vk = t i 0 k - 1 vertices vi vi + 1 connect edge length path sum weight edge vi vi + 1 i 0 k - 1 . shortest path s t path length minimum among possible paths s t,['data structures'],3000.0
465/A,sergey test a next - generation processor instead bytes processor work memory cells consist n bits bits number 1 n. integer store cell follow way : least significant bite store first bite cell next significant bite store second bite ; significant bite store n - th bite sergey want test follow instruction : ` ` add 1 value cell '' a result instruction integer write cell must increase one ; significant bits result number fit cell must discard sergey write certain value ​​of bits cell go add one value many bits cell change operation ? first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number bits cell second line contain a string consist n character — initial state cell first character denote state first bite cell second character denote second least significant bite last character denote state significant bite print a single integer — number bits cell change state add 1 cell first sample cell end value 0010 second sample — 0000,['implementation'],900.0
466/C,"' ve get array a [ 1 ] a [ 2 ] ... a [ n ] consist n integers count number ways split elements array three contiguous part sum elements part formally need find number pair indices i j ( 2 ≤ i ≤ j ≤ n - 1 ) , first line contain integer n ( 1 ≤ n ≤ 5·105 ) show many number array second line contain n integers a [ 1 ] a [ 2 ] ... a [ n ] ( |a [ i ] | ≤ 109 ) — elements array a. print a single integer — number ways split array three part sum","['data structures', 'dp']",1700.0
468/A,little x use play a card game call ` ` 24 game '' recently find easy invent a new game initially a sequence n integers : 1 2 ... n. a single step pick two let 's denote a b erase sequence append sequence either a + b a - b a × b. n - 1 step one number leave make number equal 24 ? first line contain a single integer n ( 1 ≤ n ≤ 105 ) 's possible print ` ` yes '' first line otherwise print ` ` '' ( without quote ) a way obtain 24 result number follow n - 1 line print require operations operation per line operation form : ` ` a op b = c '' a b number ' ve pick operation ; op either ` ` + '' ` ` - '' ` ` * '' ; c result correspond operation note absolute value c must n't greater 1018 . result last operation must equal 24 . separate operator sign equality sign number space multiple valid answer may print,"['greedy', 'math']",1500.0
468/E,little x solve # p - complete problem polynomial time recently give task a special n × n matrix a calculate permanent modulo 1000000007 ( 109 + 7 ) special property matrix a almost elements equal 1 . k elements specify value find definition permanent link : https : //en.wikipedia.org / wiki / <unknown> first line contain two space - separated integers n k ( 1 ≤ n ≤ 105 ; 1 ≤ k ≤ 50 ) next k line contain description matrix i - th line contain three space - separated integers xi yi wi ( 1 ≤ xi yi ≤ n ; 0 ≤ wi ≤ 109 ) number denote axi yi = wi elements matrix except give elements equal 1 . 's guarantee position ( xi yi ) distinct print permanent matrix modulo 1000000007 ( 109 + 7 ),"['dp', 'math']",3100.0
47/E,bertown siege ! attackers block ways cannon <unknown> city fortunately berland intelligence manage intercept enemies ' shoot plan let 's introduce cartesian system coordinate origin coincide cannon 's position ox axis direct rightwards city 's direction oy axis direct upwards ( sky ) cannon make n shots cannon ball ' initial speed shots equal v every shoot characterize one number alphai represent angle cannon fire due cannon 's technical peculiarities angle exceed 45 angle ( π / 4 ) disregard cannon size consider fire make point ( 0 0 ) ball fly accord know physical laws a body throw towards <unknown> angle : think acceleration gravity g equal <unknown> . bertown defend m wall i - th wall represent a vertical segment ( xi 0 ) - ( xi yi ) a ball hit a wall get stick n't fly a ball n't hit wall fall grind ( y = 0 ) stop ball exactly hit point ( xi yi ) consider stick task find ball coordinate point locate end first line contain integers n v ( 1 ≤ n ≤ 104 1 ≤ v ≤ 1000 ) represent number shots initial speed every ball second line contain n space - separated real number alphai ( 0 < alphai < π / 4 ) represent angle <unknown> cannon fire third line contain integer m ( 1 ≤ m ≤ 105 ) represent number wall follow m line contain two real number xi yi ( 1 ≤ xi ≤ 1000 0 ≤ yi ≤ 1000 ) represent wall ’ s coordinate real number 4 decimal digits wall may partially overlap even coincide print n line contain two real number — calculate every ball coordinate land point answer relative absolute error less 10 - 4,['data structures'],2200.0
474/D,"saw little game marmot make mole 's lunch 's marmot 's dinner time know marmot eat flower every dinner eat red white flower therefore a dinner represent a sequence several flower white red , a dinner tasty a rule : marmot want eat white flower group size k. marmot wonder many ways eat a b flower number ways could large print modulo 1000000007 ( 109 + 7 ) input contain several test case first line contain two integers t k ( 1 ≤ t k ≤ 105 ) t represent number test case next t line contain two integers ai bi ( 1 ≤ ai ≤ bi ≤ 105 ) describe i - th test print t line standard output i - th line contain number ways marmot eat ai bi flower dinner modulo 1000000007 ( 109 + 7 )",['dp'],1700.0
476/B,dreamoon stand position 0 a number line drazil send a list command wi - fi dreamoon 's smartphone dreamoon follow command one follow two type : wi - fi condition poor dreamoon 's smartphone report command ca n't recognize dreamoon know might even wrong though successfully recognize dreamoon decide follow every recognize command toss a fair coin decide unrecognized ones ( mean move 1 unit negative positive direction probability 0.5 ) give original list command send drazil list receive dreamoon probability dreamoon end position originally suppose final drazil 's command ? first line contain a string s1 — command drazil send dreamoon string consist character set { ' + ' ' - ' } second line contain a string s2 — command dreamoon 's smartphone recognize string consist character set { ' + ' ' - ' ' ? ' } ' ? ' denote unrecognized command lengths two string equal exceed 10 . output a single real number correspond probability answer consider correct relative absolute error n't exceed 10 - 9 . first sample s1 s2 lead dreamoon finish position + 1 . second sample s1 lead dreamoon finish position 0 four possibilites s2 : { ` ` + -++ '' ` ` + <unknown> '' ` ` + -- + '' ` ` + -- - '' } end position { +2 0 0 -2 } respectively 2 correct case 4 probability finish correct position 0.5 . third sample s2 could lead us finish position { +1 -1 -3 } probability finish correct position + 3 0,"['dp', 'math']",1300.0
477/D,dreamoon saw a large integer x write grind want print binary form dreamoon accomplish part turn x binary format go print follow manner integer n = 0 perform follow two operations order unlimited time : let 's define ideal sequence a sequence operations successfully print binary representation x without lead zero end a print operation ( i.e operation 1 ) dreamoon want know many different ideal sequence length ( operations ) shortest ideal sequence answer might large please print modulo 1000000007 ( 109 + 7 ) let 's define string representation ideal sequence a string ' 1 ' ' 2 ' i - th character string match i - th operation perform two ideal sequence call different string representations different single line input contain a binary integer represent x ( 1 ≤ x < 25000 ) without lead zero first line output contain integer represent number different ideal sequence modulo 1000000007 ( 109 + 7 ) second line output contain integer represent minimal length ideal sequence modulo 1000000007 ( 109 + 7 ) first sample shortest ideal sequence « <unknown> » length 6 . second sample three ideal sequence « <unknown> » « <unknown> » « <unknown> » among shortest one length 5,['dp'],2700.0
479/B,know kid berland love play cub little petya n tower consist cub size tower number i consist ai cub stack one top petya define instability a set tower a value equal difference heights highest lowest tower example petya build five cube tower heights ( 8 3 2 6 3 ) instability set equal 6 ( highest tower height 8 lowest one height 2 ) boy want instability set tower low possible perform follow operation several time : take top cube tower put top tower set please note petya would never put cube tower remove think 's a waste time go school boy time perform k operations petya want late class help accomplish task first line contain two space - separated positive integers n k ( 1 ≤ n ≤ 100 1 ≤ k ≤ 1000 ) — number tower give set maximum number operations petya perform second line contain n space - separated positive integers ai ( 1 ≤ ai ≤ 104 ) — tower ' initial heights first line print two space - separated non - negative integers s m ( m ≤ k ) first number value minimum possible instability obtain perform k operations second number number operations need next m line print description operation two positive integers i j lie within limit 1 n. represent petya take top cube i - th tower put j - th one ( i ≠ j ) note process perform operations heights tower become equal zero multiple correct sequence minimum possible instability achieve allow print first sample need move cub two time second tower third one second one first one heights tower equal 6,"['greedy', 'implementation']",1400.0
479/E,imagine a build exactly n floor move floor a lift let 's number floor bottom top integers 1 n. 're floor number a. bore want take lift floor number b a secret lab entry forbid however already mood decide make k consecutive trip lift let us suppose moment floor number x ( initially floor a ) another trip floor choose floor number y ( y ≠ x ) lift travel floor visit floor b secret lab decide distance current floor x choose y must strictly less distance current floor x floor b secret lab formally mean follow inequation must fulfill : |x - y| < |x - b| lift successfully transport floor y write number y notepad task find number distinct number sequence could write notebook result k trip lift seek number trip rather large find remainder divide number 1000000007 ( 109 + 7 ) first line input contain four space - separated integers n a b k ( 2 ≤ n ≤ 5000 1 ≤ k ≤ 5000 1 ≤ a b ≤ n a ≠ b ) print a single integer — remainder divide seek number sequence 1000000007 ( 109 + 7 ) two sequence p1 p2 ... pk q1 q2 ... qk distinct integer j ( 1 ≤ j ≤ k ) pj ≠ qj note sample :,['dp'],1900.0
48/F,"new year celebrations berland last n days year winter <unknown> ’ s winter celebrations ’ organizers buy artificial snow m snow sell company berland every day i - th company produce wi cubic meter snow next day snow <unknown> company produce wi cubic meter snow celebration new year discount ’ s snow cost decrease every day know first day total cost snow produce i - th company equal ci bourles every day total cost decrease ai bourles i.e second day equal ci - ai third day — ci - <unknown> , know one company cost snow produce get negative equal zero organize snow purchase buy every day exactly w snow cubic meter necessary buy company snow produce buy ni cubic meter snow ( 0 ≤ ni ≤ wi number ni necessarily integer ! ) i - th company one days cost snow equal si price total bourles one day one buy snow several company different days one buy snow different company require make purchase spend little money possible guarantee snow produce company enough first line contain integers n m w ( 1 ≤ n ≤ 100 1 ≤ m ≤ 500000 1 ≤ w ≤ 109 ) represent number days number company amount snow need purchase every one n days second line contain m integers wi third line contain m integers ci fourth line contain m integers ai number strictly positive exceed 109 . i inequation ci - ( n - 1 ) ai > 0 hold true print a single number — answer give problem print answer format decimal point ( even answer integer must contain decimal point ) without ` ` e '' without lead zero answer differ right one 10 - 9",['greedy'],2800.0
48/G,"a far away galaxy n inhabit planets number number 1 n. one day presidents n planets independently come idea create galaxy union need share wonderful idea <unknown> ’ s president busy work a project <unknown> presidents negotiations pair planets bidirectional communication channel characterize ` ` dial duration '' ti a rule take several hours exceed call duration greatly overall galaxy n communication channel unite planets a uniform network mean possible phone planet v planet u perhaps use <unknown> planets v1 v2 ... vm via exist channel u v1 v1 v2 ... vm - 1 vm vm v. dial duration u v equal sum dial durations use channel , every president talk one one presidents rest n - 1 planets negotiations take place strictly consecutively negotiations a planet stop dial another one begin matter urgent different ways call need planet every time quickest one choose little time need assure another president importance galaxy union ’ s duration negotiations planet consider equal dial duration time planets presidents know nothing ’ s plan take consideration possibility example seek president may call already know found galaxy union source <unknown> n planets ask work <unknown> plan first find every president much time suppose negotiations take first line contain integer n ( 3 ≤ n ≤ 200000 ) represent number planets galaxy number communication channel equal next n line contain three integers ai bi ti ( 1 ≤ ai bi ≤ n ai ≠ bi 1 ≤ ti ≤ 103 ) represent number planet join a communication channel ` ` dial duration '' one communication channel a pair planets first line output n integers — durations suppose negotiations president separate number space",['dp'],2700.0
482/B,'ll call array n non - negative integers a [ 1 ] a [ 2 ] ... a [ n ] interest meet m constraints i - th m constraints consist three integers li ri qi ( 1 ≤ li ≤ ri ≤ n ) mean value equal qi task find interest array n elements state array n't exist expression x & y mean bitwise number x y. program languages c++ java python operation represent ` ` & '' pascal — ` ` '' first line contain two integers n m ( 1 ≤ n ≤ 105 1 ≤ m ≤ 105 ) — number elements array number limit next m line contain three integers li ri qi ( 1 ≤ li ≤ ri ≤ n 0 ≤ qi < 230 ) describe i - th limit interest array exist first line print ` ` yes '' ( without quote ) second line print n integers a [ 1 ] a [ 2 ] ... a [ n ] ( 0 ≤ a [ i ] < 230 ) <unknown> interest array multiple answer print interest array n't exist print ` ` '' ( without quote ) single line,['data structures'],1800.0
484/C,many specific order know ? ascend order descend order order ascend length order ascend polar angle ... let 's a look another specific order : d - sorting sort apply string length least d d positive integer character string sort follow manner : first come 0 - th character initial string 1 - st ones 2 - nd ones end go ( d - 1 ) -th character initial string i - th character mean character whose position exactly i modulo d. two character stand position remainder integer division d relative order sort n't change string zero - indexed example string ' qwerty ' : 1 - sorting string ' qwerty ' ( character stand 0 position ) 2 - sorting string ' <unknown> ' ( character ' q ' ' e ' ' t ' stand 0 position character ' w ' ' r ' ' y ' 1 position ) 3 - sorting string ' <unknown> ' ( character ' q ' ' r ' stand 0 position character ' w ' ' t ' stand 1 position character ' e ' ' y ' stand 2 position ) 4 - sorting string ' <unknown> ' 5 - sorting string ' <unknown> ' give string s length n m shuffle operations string shuffle operation accept two integer arguments k d transform string s follow i 0 n - k increase order apply operation d - sorting substring s [ i .. i + k - 1 ] s [ a .. b ] represent a substring consist character position a b inclusive shuffle operation need print string s. first line input contain a non - empty string s length n consist lowercase uppercase english letter digits 0 9 . second line input contain integer m – number shuffle operations ( 1 ≤ <unknown> ≤ 106 ) follow m line contain descriptions operations consist two integers k d ( 1 ≤ d ≤ k ≤ n ) operation print current state string s. detail explanation sample first modification execute arguments k = 4 d = 2 . mean need apply 2 - sorting substring length 4 one one move leave right string transform follow manner : qwerty → <unknown> → <unknown> → <unknown> string s equal ' qertwy ' end first query second modification execute arguments k = 6 d = 3 . a result operation whole string s replace 3 - sorting : qertwy → <unknown> third modification execute arguments k = 5 d = 2 . <unknown> → qertwy → <unknown>,"['implementation', 'math']",2600.0
485/A,one industrial factory reform work plan director suggest set a mythical detail production norm begin day x detail factory storage end day factory produce ( remainder divide x m ) detail unfortunately customer ever buy mythical detail detail produce stay factory board directors worry production give plan may eventually stop ( mean а moment current number detail factory divisible m ) give number detail a first day number m check production stop moment first line contain two integers a m ( 1 ≤ a m ≤ 105 ) print ` ` yes '' ( without quote ) production eventually stop otherwise print ` ` '',"['implementation', 'math']",1400.0
486/C,"nam play a string computer string consist n lowercase english letter meaningless nam decide make string beautiful make a palindrome use 4 arrow key : leave right , a cursor point symbol string suppose cursor position i ( 1 ≤ i ≤ n string use 1 - based index ) leave right arrow key use move cursor around string string cyclic mean nam press leave arrow key cursor move position i - 1 i > 1 end string ( i. e. position n ) otherwise hold press right arrow key ( i = n cursor appear begin string ) nam press arrow key letter text cursor point change next letter english alphabet ( assume alphabet also cyclic i. e. ' z ' follow ' a ' ) hold press arrow key initially text cursor position p. nam a lot homework want complete fast possible help calculate minimum number arrow key press make string a palindrome ? first line contain two space - separated integers n ( 1 ≤ n ≤ 105 ) p ( 1 ≤ p ≤ n ) length nam 's string initial position text cursor next line contain n lowercase character nam 's string print minimum number press need change string a palindrome a string a palindrome read forward reverse sample test initial nam 's string : ( cursor position show bold ) optimal solution nam may 6 follow step : result , a palindrome","['greedy', 'implementation']",1700.0
486/D,know undirected connect graph n nod n - 1 edge call a tree give integer d a tree consist n nod node i a value ai associate call a set s tree nod valid follow condition satisfy : task count number valid set since result large must print remainder modulo 1000000007 ( 109 + 7 ) first line contain two space - separated integers d ( 0 ≤ d ≤ 2000 ) n ( 1 ≤ n ≤ 2000 ) second line contain n space - separated positive integers a1 a2 ... ( 1 ≤ ai ≤ 2000 ) next n - 1 line contain pair integers u v ( 1 ≤ u v ≤ n ) denote edge u v. guarantee edge form a tree print number valid set modulo 1000000007 . first sample exactly 8 valid set : { 1 } { 2 } { 3 } { 4 } { 1 2 } { 1 3 } { 3 4 } { 1 3 4 } set { 1 2 3 4 } valid third condition n't satisfy set { 1 4 } satisfy third condition conflict second condition,"['dp', 'math']",2100.0
486/E,next ` ` data structure algorithms '' lesson longest increase subsequence ( lis short ) a sequence better understand nam decide learn a days lesson nam create a sequence a consist n ( 1 ≤ n ≤ 105 ) elements a1 a2 ... ( 1 ≤ ai ≤ 105 ) a subsequence ai1 ai2 ... aik 1 ≤ i1 < i2 < ... < ik ≤ n call increase ai1 < ai2 < <unknown> < ... < aik increase subsequence call longest maximum length among increase subsequences nam realize a sequence may several longest increase subsequences hence divide index i ( 1 ≤ i ≤ n ) three group : since number longest increase subsequences a may large <unknown> process difficult task help finish job first line contain single integer n ( 1 ≤ n ≤ 105 ) denote number elements sequence a. second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 105 ) print a string consist n character i - th character ' 1 ' ' 2 ' ' 3 ' depend group among list index i belong second sample sequence a consist 4 elements : { a1 a2 a3 a4 } = { 1 3 2 5 } sequence a exactly 2 longest increase subsequences length 3 { a1 a2 a4 } = { 1 3 5 } { a1 a3 a4 } = { 1 2 5 } third sample sequence a consist 4 elements : { a1 a2 a3 a4 } = { 1 5 2 3 } sequence a exactly 1 longest increase subsequence length 3 { a1 a3 a4 } = { 1 2 3 },"['data structures', 'dp', 'greedy', 'math']",2200.0
489/B,berland state university host a <unknown> dance celebration 100500 - th anniversary ! n boys m girls already busy rehearse <unknown> <unknown> <unknown> <unknown> move know several boy & girl pair go invite ball however partner ' dance skill pair must differ one boy know dance skills similarly girl know dance skills write a code determine largest possible number pair form n boys m girls first line contain integer n ( 1 ≤ n ≤ 100 ) — number boys second line contain sequence a1 a2 ... ( 1 ≤ ai ≤ 100 ) ai i - th boy 's dance skill similarly third line contain integer m ( 1 ≤ m ≤ 100 ) — number girls fourth line contain sequence b1 b2 ... bm ( 1 ≤ bj ≤ 100 ) bj j - th girl 's dance skill print a single number — require maximum possible number pair,"['dp', 'greedy']",1200.0
489/E,a traveler plan a water hike along river note suitable rest point night write distance start point locations characterize picturesqueness i - th rest point distance start equal xi picturesqueness equal bi traveler move river one direction assume start point 0 coordinate axis rest point point coordinate xi every day traveler want cover distance l. practice turn always possible need end day one rest point addition traveler choose two desire : cover distance l every day visit <unknown> place let 's assume traveler cover distance rj a day feel frustration total frustration hike calculate total frustration days help plan route minimize relative total frustration : total frustration divide total picturesqueness rest point use traveler 's path must end farthest rest point first line input contain integers n l ( 1 ≤ n ≤ 1000 1 ≤ l ≤ 105 ) — number rest point optimal length one day path n line follow line describe one rest point a pair integers xi bi ( 1 ≤ xi bi ≤ 106 ) two rest point xi line give order strictly increase xi print traveler 's path a sequence number rest point use order use number point 1 n order increase xi last print number must equal n. sample test minimum value relative total frustration approximately equal <unknown> . value calculate,['dp'],2300.0
490/E,"peter write board a strictly increase sequence positive integers a1 a2 ... , <unknown> replace digits number sequence question mark thus question mark correspond exactly one lose digit restore original sequence know digits remain board first line input contain integer n ( 1 ≤ n ≤ 105 ) — length sequence next n line contain one element sequence element consist digits question mark element start digit 0 . element length 1 8 character inclusive answer exist print first line ` ` yes '' ( without quote ) next n line must contain sequence positive integers — a possible variant peter 's sequence find sequence must strictly increase must transform give one replace question mark a single digit number result sequence must write without lead zero multiple solutions print answer print a single line ` ` '' ( without quote )","['greedy', 'implementation']",2000.0
493/D,vasya decide learn play chess classic chess n't seem interest play sort chess queen piece capture square vertical horizontal diagonal line cell locate vertical horizontal diagonal line queen cell contain a piece enemy color queen able move square enemy 's piece remove board queen move a cell contain enemy piece piece queen n × n chessboard 'll denote a cell intersection r - th row c - th column ( r c ) square ( 1 1 ) contain white queen square ( 1 n ) contain black queen square contain green pawn n't belong anyone players move turn player move first play white queen opponent play black queen move player capture piece queen ( move a square contain either a green pawn enemy queen ) player lose either capture piece move opponent take queen previous move help vasya determine win players play optimal strategy board n × n. input contain a single number n ( 2 ≤ n ≤ 109 ) — size board first line print answer problem — string ` ` white '' string ` ` black '' depend win players play optimally answer ` ` white '' also print two integers r c represent cell ( r c ) first player make first move win multiple cells print one minimum r. still multiple square print one minimum c. first sample test white queen capture black queen first move white player win second test statement white queen capture green pawn locate central vertical line capture black queen next move move white player capture green pawn locate ( 2 1 ) similarly black queen n't options capture green pawn locate ( 2 3 ) otherwise go middle vertical line capture white queen next move thing happen — neither white black queen options rather capture green pawn situate thus white queen end square ( 3 1 ) black queen end square ( 3 3 ) situation white queen capture green pawn locate middle vertical line capture black queen thus player play black queen win,['math'],1700.0
496/E,assistant director a new musical play play consist n musical part part must perform exactly one actor cast director choose m actors take part play task assign part actors however several limitations first actor a certain voice range part sing formally two integers actor ci di ( ci ≤ di ) — pitch lowest highest note actor sing also two integers part — aj bj ( aj ≤ bj ) — pitch lowest highest note present part i - th actor perform j - th part ci ≤ aj ≤ bj ≤ di i.e note part actor 's voice range accord contract i - th actor perform ki part besides allow give part actors ( take part crowd scenes ) rehearsal start two hours need assignment quickly ! first line contain a single integer n — number part play ( 1 ≤ n ≤ 105 ) next n line contain two space - separated integers aj bj — range note j - th part ( 1 ≤ aj ≤ bj ≤ 109 ) next line contain a single integer m — number actors ( 1 ≤ m ≤ 105 ) next m line contain three space - separated integers ci di ki — range i - th actor number part perform ( 1 ≤ ci ≤ di ≤ 109 1 ≤ ki ≤ 109 ) assignment meet criteria <unknown> print a single word ` ` yes '' ( without quote ) first line next line print n space - separated integers i - th integer number actor perform i - th part multiple correct assignments print correct assignment print a single word ` ` '' ( without quote ),['greedy'],2100.0
50/A,give a rectangular board m × n square also give unlimited number standard domino piece 2 × 1 square allow rotate piece ask place many dominoes possible board meet follow conditions:1 . domino completely cover two <unknown> two dominoes <unknown> domino lie entirely inside board allow touch edge board find maximum number dominoes place restrictions a single line give two integers m n — board size square ( 1 ≤ m ≤ n ≤ 16 ) output one number — maximal number dominoes place,"['greedy', 'math']",800.0
501/C,let 's define a forest a non - directed acyclic graph ( also without loop parallel edge ) one day misha play forest consist n vertices vertex v 0 n - 1 write two integers degreev sv first integer number vertices adjacent vertex v second integer xor sum number vertices adjacent v ( adjacent vertices write 0 ) next day misha could n't remember graph initially misha value degreev sv leave though help find number edge edge initial graph guarantee exist a forest correspond number write misha first line contain integer n ( 1 ≤ n ≤ 216 ) number vertices graph i - th next line contain number degreei si ( 0 ≤ degreei ≤ n - 1 0 ≤ si < 216 ) separate a space first line print number m number edge graph next print m line contain two distinct number a b ( 0 ≤ a ≤ n - 1 0 ≤ b ≤ n - 1 ) correspond edge ( a b ) edge print order ; vertices edge also print order xor sum number result bitwise add number modulo 2 . operation exist many modern program languages example languages c++ java python represent ` ` ^ '' pascal — ` ` xor '',"['data structures', 'greedy']",1500.0
505/E,mr . kitayuta 's garden plant n bamboos ( bamboos tall fast - growing <unknown> plant hollow stem . ) moment height i - th bamboo hi meter grow ai meter end day actually mr . kitayuta hat bamboos attempt cut fail stem hard mr . kitayuta give however craft magical hammer intelligence drive grind use magical hammer k time day due limit magic power time beat a bamboo magical hammer height decrease p meter height would become negative change become 0 meter instead ( disappear ) word a bamboo whose height h meter beat magical hammer new height max ( 0 h - p ) meter possible beat bamboo a day mr . kitayuta fight bamboos m days start today purpose minimize height tallest bamboo m days ( m iterations ` ` mr . kitayuta beat bamboos grow '' ) find lowest possible height tallest bamboo m days first line input contain four space - separated integers n m k p ( 1 ≤ n ≤ 105 1 ≤ m ≤ 5000 1 ≤ k ≤ 10 1 ≤ p ≤ 109 ) represent number bamboos mr . kitayuta 's garden duration mr . kitayuta 's fight days maximum number time mr . kitayuta beat bamboos day power magic hammer respectively follow n line describe properties bamboos i - th ( 1 ≤ i ≤ n ) contain two space - separated integers hi ai ( 0 ≤ hi ≤ 109 1 ≤ ai ≤ 109 ) denote initial height growth rate i - th bamboo respectively print lowest possible height tallest bamboo m days,['greedy'],2900.0
51/D,"polycarp love geometric progressions — collect however progressions occur rarely also love sequence number enough delete a single element get a geometric progression task shall define geometric progressions finite sequence number a1 a2 ... ak ai = <unknown> - 1 real number c b. example sequence [ 2 -4 8 ] [ 0 0 0 0 ] [ 199 ] geometric progressions [ 0 1 2 3 ] recently polycarp find a sequence ca n't classify help determine whether a geometric progression , check become a geometric progression element delete first line contain integer n ( 1 ≤ n ≤ 105 ) — number elements give sequence second line contain give sequence number space - separated elements give sequence integers absolute value exceed 104 . print 0 give sequence a geometric progression otherwise check possible make sequence a geometric progression delete a single element possible print 1 . impossible print 2",['implementation'],2200.0
512/D,fox ciel go travel new foxland summer new foxland n attractions link m undirected roads two attractions call adjacent link a road fox ciel k days visit city day visit exactly one attraction one important rule new foxland : ca n't visit attraction one adjacent attraction n't visit yet begin fox ciel n't visit attraction travel may move <unknown> attraction visit attraction a may travel attraction b satisfy condition n't visit yet even reachable a use roads ( ciel use boat travel attractions possible ) want know many different travel plan make calculate number modulo 109 + 9 every k 0 n since n't decide many days visit new foxland first line contain two integers : n m ( 1 ≤ n ≤ 100 ) number attractions number undirected roads next m line contain two integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) describe a road one road connect pair attractions output n + 1 integer : number possible travel plan modulo 109 + 9 k 0 n. first sample test k = 3 4 travel plan : { 1 2 3 } { 1 3 2 } { 3 1 2 } { 3 2 1 } second sample test ciel ca n't visit attraction first day k > 0 answer 0 . third sample test <unknown> look like :,['dp'],2900.0
518/C,"anya buy a new smartphone use berdroid operate system smartphone menu exactly n applications application icon icons locate different screen one screen contain k icons icons first k - th one locate first screen ( k + 1 ) -th 2k - th ones second screen ( last screen may partially empty ) initially smartphone menu show screen number 1 . launch application icon locate screen t anya need make follow gesture : first scroll require screen number t make t - 1 gesture ( icon screen t ) make another gesture — press icon require application exactly launch application launch menu return first screen , launch next application need scroll menu start screen number 1 . applications number 1 n. know a certain order icons applications locate menu begin change long use operate system berdroid intelligent system change order icons move frequently use icons begin list formally right application launch berdroid swap application icon icon a precede application ( icon application position smaller one order menu ) precede icon may possibly locate adjacent screen exception icon launch application already occupy first place case icon arrangement n't change anya plan order launch applications many gesture anya make launch applications plan order ? note one application may launch multiple time first line input contain three number n m k ( 1 ≤ n m k ≤ 105 ) — number applications anya smartphone number applications launch number icons locate screen next line contain n integers permutation a1 a2 ... — initial order icons leave right menu ( first last one ) ai — i d application whose icon go i - th menu integer 1 n occur exactly among ai third line contain m integers b1 b2 ... bm ( 1 ≤ bi ≤ n ) — ids launch applications plan order one application may launch multiple time print a single number — number gesture anya need make launch applications desire order first test initial configuration look like ( 123 ) ( <unknown> ) ( 78 ) , first screen contain icons applications 1 2 3 second screen contain icons 4 5 6 third screen contain icons 7 8 . application 7 launch get new arrangement icons — ( 123 ) ( 457 ) ( 68 ) launch anya make 3 gesture application 8 launch get configuration ( 123 ) ( 457 ) ( <unknown> ) launch anya make 3 gesture application 1 launch arrangement icons menu n't change launch anya make 1 gesture total anya make 7 gesture","['data structures', 'implementation']",1600.0
518/D,ilya get tire sport program leave university get a job subway give task determine escalator load factor let 's assume n people stand queue escalator second one two follow possibilities take place : either first person queue enter escalator probability p first person queue n't move probability ( 1 - p ) <unknown> fear <unknown> make whole queue wait behind formally speak i - th person queue enter escalator people indices 1 i - 1 inclusive enter one second one person enter escalator escalator infinite a person enter never leave stand escalator follow second ilya need count expect value number people stand escalator t second task help solve complicate task first line input contain three number n p t ( 1 ≤ n t ≤ 2000 0 ≤ p ≤ 1 ) number n t integers number p real give exactly two digits decimal point print a single real number — expect number people stand escalator t second absolute relative error must n't exceed 10 - 6,"['dp', 'math']",1700.0
52/C,give circular array a0 a1 ... - 1 . two type operations : assume segment circular n = 5 lf = 3 rg = 1 mean index sequence : 3 4 0 1 . write program process give sequence operations first line contain integer n ( 1 ≤ n ≤ 200000 ) next line contain initial state array : a0 a1 ... - 1 ( - 106 ≤ ai ≤ 106 ) ai integer third line contain integer m ( 0 ≤ m ≤ 200000 ) m — number <unknown> next m line contain one operation line contain two integer lf rg ( 0 ≤ lf rg ≤ n - 1 ) mean rmq operation contain three integers lf rg v ( 0 ≤ lf rg ≤ n - 1 ; - 106 ≤ v ≤ 106 ) — inc operation rmq operation write result please use % lld specificator read write 64 - bit integers c++ preffered use cout ( also may use % i64d ),['data structures'],2200.0
520/D,vasya petya assemble a figure m cub associate a number 0 m - 1 ( inclusive number appear exactly ) let 's consider a coordinate system ox grind oy direct upwards cube associate coordinate lower leave corner coordinate integers cube figure turn stable mean cube grind least one cube two cub touch a side a corner formally mean cube coordinate ( x y ) either y = 0 a cube coordinate ( x - 1 y - 1 ) ( x y - 1 ) ( x + 1 y - 1 ) boys want disassemble figure put cub a row one step cube remove figure put right block already lay guy remove cub order figure remain stable make process interest guy decide play follow game guy take cub figure turn easy see figure disassemble integers write cub form a number write m - ary positional numerical system ( possibly a lead zero ) vasya want result number maximum possible petya contrary try make small possible vasya start game task determine number form figure disassemble boys play optimally determine remainder answer modulo 109 + 9 . first line contain number m ( 2 ≤ m ≤ 105 ) follow m line contain coordinate cub xi yi ( - 109 ≤ xi ≤ 109 0 ≤ yi ≤ 109 ) ascend order number write guarantee original figure stable two cub occupy place line print answer problem,"['greedy', 'implementation']",2100.0
525/C,even contest ilya bore really felt like maximize remember a set n stick instrument stick characterize length li ilya decide make a rectangle stick due whim decide make rectangles a way maximize total area stick use make one rectangle possible stick remain unused bend stick allow stick lengths a1 a2 a3 a4 make a rectangle follow properties observe : a rectangle make stick lengths example 3 3 3 3 2 2 4 4 . a rectangle make example stick 5 5 5 7 . ilya also instrument reduce length stick stick make a special material length stick reduce one example a stick length 5 either stay length transform a stick length 4 . answer question — maximum total area rectangles ilya get a file make rectangles available stick ? first line input contain a positive integer n ( 1 ≤ n ≤ 105 ) — number available stick second line input contain n positive integers li ( 2 ≤ li ≤ 106 ) — lengths stick first line output must contain a single non - negative integer — maximum total area rectangles ilya make available stick,"['greedy', 'math']",1600.0
526/G,spiders om nom 's old enemies love eat candy much 's keep try keep monster away favorite candy come evil plan trap om nom let 's consider a rope structure consist n nod n - 1 rope connect nod structure connect thus rope nod form a tree rope form structure associate length a candy tie node x structure om nom really want eat candy y spiders try stop decide entangle candy part structure a web thus attach candy large possible part rope structure spider use web cover rope path two arbitrary nod a b. thus y spiders cover set rope a union y paths give tree y paths arbitrarily intersect spiders want follow condition hold : spiders n't yet decide node structure tie candy many spiders cover structure web ask help help calculate optimal plan multiple value x y. first line contain number n q ( 1 ≤ n q ≤ 105 ) — number nod structure number question spiders want ask next n - 1 line determine rope structure i - th line contain three integers ui vi li ( 1 ≤ ui vi ≤ n ui ≠ vi 1 ≤ li ≤ 1000 ) show a rope length li nod ui vi next q line describe spiders ' question want answer question online encode message a special manner next q line contain two number xi yi first question spiders x = x1 y = y1 calculate value x y spiders ' i - th ( 2 ≤ i ≤ q ) question need use follow formulas : ansi - 1 total length rope cover a web answer ( i - 1 ) -th question follow inequality hold : 1 ≤ xi yi ≤ n. question spiders print a separate line a single integer ansi — total length rope cover web optimal plan,['greedy'],3300.0
527/C,"leonid want become a glass carver ( person create beautiful artworks cut glass ) already a rectangular w mm × h mm sheet glass a diamond glass <unknown> lot enthusiasm lack understand carve order waste time decide practice technique carve , make vertical horizontal cut entire sheet process result make smaller rectangular fragment glass leonid move newly make glass fragment particular a cut divide fragment glass go smaller fragment cut leonid try determine area largest currently available glass fragment since appear fragment question take time distract fascinate process leonid offer divide labor — cut glass calculate area maximum fragment cut agree ? first line contain three integers w h n ( 2 ≤ w h ≤ 200 000 1 ≤ n ≤ 200 000 ) next n line contain descriptions cut description form h y v x. first case leonid make horizontal cut distance y millimeters ( 1 ≤ y ≤ h - 1 ) lower edge original sheet glass second case leonid make a vertical cut distance x ( 1 ≤ x ≤ w - 1 ) millimeters leave edge original sheet glass guarantee leonid wo n't make two identical cut cut print a single line area maximum available glass fragment <unknown> picture first sample test :","['data structures', 'implementation']",1500.0
527/D,clique problem one well - known np - complete problems <unknown> formulate follow consider undirected graph g. require find a subset vertices c maximum size two connect edge graph g. sound simple n't ? nobody yet know algorithm find a solution problem polynomial time size graph however many np - complete problems clique problem easier consider a specific type a graph consider n distinct point a line let i - th point coordinate xi weight wi let 's form graph g whose vertices point edge connect exactly pair point ( i j ) distance less sum weight formally : |xi - xj| ≥ wi + wj find size maximum clique graph first line contain integer n ( 1 ≤ n ≤ 200 000 ) — number point next n line contain two number xi wi ( 0 ≤ xi ≤ 109 1 ≤ wi ≤ 109 ) — coordinate weight a point xi different print a single number — number vertexes maximum clique give graph happen know solve problem without use specific properties graph formulate problem statement able get a prize one million dollars ! picture sample test,"['data structures', 'dp', 'greedy', 'implementation']",1800.0
533/C,polycarp vasiliy love simple logical game today play a game infinite chessboard one pawn player polycarp vasiliy move turn polycarp start turn polycarp move pawn cell ( x y ) ( x - 1 y ) ( x y - 1 ) vasiliy move pawn ( x y ) one cells : ( x - 1 y ) ( x - 1 y - 1 ) ( x y - 1 ) players also allow skip move additional restrictions — a player forbid move pawn a cell negative x - coordinate y - coordinate cell contain opponent 's pawn winner first person reach cell ( 0 0 ) give start coordinate pawn determine win play optimally well first line contain four integers : xp yp xv yv ( 0 ≤ xp yp xv yv ≤ 105 ) — polycarp 's vasiliy 's start coordinate guarantee begin pawn different cells none cell ( 0 0 ) output name winner : ` ` polycarp '' ` ` vasiliy '' first sample test polycarp start ( 2 1 ) move ( 1 1 ) first turn matter opponent second turn polycarp move ( 1 0 ) finally ( 0 0 ) third turn,"['greedy', 'implementation', 'math']",1700.0
534/E,"berland a bus travel along main street capital street begin main square look like a long segment n bus stop locate along street i - th locate distance ai central square distance distinct stop number order increase distance square , ai < ai + 1 i 1 n - 1 . bus start journey first stop pass stop 2 3 reach stop number n turn around go opposite direction stop 1 pass intermediate stop reverse order , start move towards stop n. day bus run non - stop route bus equip berland local position system bus pass a stop system note number one key feature system respond query distance cover bus part path pair stop a special module system take input information a set stop a segment path a stop number occur set many time bus drive past module return length travel segment path ( -1 impossible determine length uniquely ) operation module complicate fact stop number occur request order visit non - decreasing order example number stop 6 part bus path start bus stop number 5 end stop number 3 pass stop follow : request segment path form : 3 4 5 5 6 . bus segment path stop 5 stop 3 time drive past 1 - th stop ( i.e. consider a segment end second visit stop 3 way 5 ) request form : 1 2 2 3 3 4 5 5 6 . repeat berland programmers achievement implement function first line contain integer n ( 2 ≤ n ≤ 2·105 ) — number stop second line contain n integers ( 1 ≤ ai ≤ 109 ) — distance i - th stop central square number second line go increase order third line contain integer m ( 1 ≤ m ≤ 4·105 ) — number stop bus visit segment path fourth line contain m integers ( 1 ≤ bi ≤ n ) — sort list number stop visit bus segment path number a stop occur many time visit a bus guarantee query correspond segment path single line please print distance cover a bus impossible determine unambiguously print - 1 . first test statement demonstrate first example show statement problem second test statement demonstrate second example show statement problem third sample two possible paths distinct lengths consequently seek length segment n't define uniquely fourth sample even though two distinct paths correspond query lengths seek length segment define uniquely","['greedy', 'implementation']",2400.0
535/C,"karafs kind <unknown> shape 1 × h rectangle <unknown> people love karafs use karafs almost kind food tavas , crazy karafs karafs a positive integer height tavas infinite 1 - based sequence karafses height i - th karafs si = a + ( i - 1 ) × b. a give m let 's define m - bite operation decrease height m distinct eat karafses 1 . karafs consider eat height become zero <unknown> ask n query query give number l t m find largest number r l ≤ r sequence sl sl + 1 ... sr eat perform m - bite t time print -1 number r. first line input contain three integers a b n ( 1 ≤ a b ≤ 106 1 ≤ n ≤ 105 ) next n line contain information query i - th line contain integers l t m ( 1 ≤ l t m ≤ 106 ) i - th query query print answer a single line","['greedy', 'math']",1900.0
538/H,"t students apply zpp class summer irrelevant school organize committee school may enroll number least t students must enrol enrol students divide two group manner ( possible one group empty ! ) a shift students zpp grade tutor n teachers due nature educational process teachers assign exactly one two group ( possible teacher assign group ! ) i - th teacher will work a group long group least li ri students ( otherwise would either bore hard ) besides pair teachers n't like therefore work group ; total m pair conflict teachers , head teacher summer irrelevant school get a difficult task : determine many students enroll group group teacher teach first line contain two space - separated integers t t ( 1 ≤ t ≤ t ≤ 109 ) second line contain two space - separated integers n m ( 1 ≤ n ≤ 105 0 ≤ m ≤ 105 ) i - th next n line contain integers li ri ( 0 ≤ li ≤ ri ≤ 109 ) next m line describe pair conflict teachers line contain two space - separated integers — indices teachers pair teachers index start one guarantee teacher a conflict pair conflict teachers occur list distribution possible print first line a single word ' possible ' ( without quote ) second line print two space - separated integers n1 n2 — number students first second group correspondingly <unknown> t ≤ n1 + n2 ≤ t meet third line print n character i - th 1 2 i - th teacher assign first second group correspondingly multiple possible distributions students teachers group print seek distribution n't exist print a single word ' impossible ' ( without quote )","['data structures', 'greedy']",3200.0
542/A,ivan anatolyevich 's agency start become famous town already order make n tv commercial videos video make a special way : color <unknown> adjust time day viewers ' mood 's i - th video show within time range [ li ri ] ( necessary use whole segment broadcast time within segment ) 's time choose a tv channel broadcast commercial overall m tv channel broadcast city j - th one cj viewers ready sell time [ aj bj ] broadcast commercial ivan anatolyevich face a hard choice : choose exactly one video i exactly one tv channel j broadcast video also a time range broadcast [ x y ] time range choose within range [ li ri ] within range [ aj bj ] let 's define efficiency broadcast value ( y - x ) · cj — total sum time viewers tv channel go spend watch commercial help ivan anatolyevich choose broadcast maximum efficiency ! first line contain two integers n m ( 1 ≤ n m ≤ 2·105 ) — number commercial videos channel respectively follow n line contain two integers li ri ( 0 ≤ li ≤ ri ≤ 109 ) — segment time possible show correspond video follow m line contain three integers aj bj cj ( 0 ≤ aj ≤ bj ≤ 109 1 ≤ cj ≤ 109 ) characterize tv channel first line print integer — maximum possible efficiency broadcast correct way get a strictly positive efficiency print a zero maximum efficiency strictly positive second line also print number video i ( 1 ≤ i ≤ n ) number tv channel j ( 1 ≤ j ≤ m ) effective broadcast multiple optimal answer print first sample test optimal solution show second commercial use first tv channel time [ 2 4 ] efficiency solution equal ( 4 - 2 ) · 2 = 4 . second sample test ivan <unknown> 's wish meet options tv channel segment intersect answer zero,['data structures'],2400.0
545/D,little girl susie go shop mom wonder improve service quality n people queue person know time ti need serve a person disappoint time wait time need serve time a person wait total time people stand queue front serve susie think swap people queue decrease number people disappoint help susie find maximum number disappoint people achieve swap people queue first line contain integer n ( 1 ≤ n ≤ 105 ) next line contain n integers ti ( 1 ≤ ti ≤ 109 ) separate space print a single number — maximum number disappoint people queue value 4 achieve arrangement example : 1 2 3 5 15 . thus make everything feel disappoint except person time 5,"['greedy', 'implementation']",1300.0
545/E,"little girl susie accidentally find elder brother 's notebook many things important solve problems find problem interest want know solution decide ask , problem statement follow let 's assume give a connect weight undirected graph g = ( v e ) ( v set vertices e set edge ) shortest - path tree vertex u graph g1 = ( v e1 ) a tree set edge e1 subset set edge initial graph e lengths shortest paths u vertex g g1 give a connect weight undirected graph g vertex u. task find shortest - path tree give graph vertex u total weight whose edge minimum possible first line contain two number n m ( 1 ≤ n ≤ 3·105 0 ≤ m ≤ 3·105 ) — number vertices edge graph respectively next m line contain three integers represent edge — ui vi wi — number vertices connect edge weight edge ( ui ≠ vi 1 ≤ wi ≤ 109 ) guarantee graph connect one edge pair vertices last line input contain integer u ( 1 ≤ u ≤ n ) — number start vertex first line print minimum total weight edge tree next line print indices edge include tree separate space edge number start 1 order follow input may print number edge order multiple answer print first sample two possible shortest path tree : example a tree edge 1 – 2 1 – 3 wo n't a shortest path tree vertex 3 distance vertex 3 vertex 2 tree equal 3 original graph 1",['greedy'],2000.0
546/D,two soldier play a game begin first choose a positive integer n give second soldier second one try make maximum possible number round round consist choose a positive integer x > 1 n divisible x replace n n / x. n become equal 1 possible valid move game score second soldier equal number round perform make game interest first soldier choose n form a ! / b ! positive integer a b ( a ≥ b ) k ! denote factorial k define a product positive integers large k. maximum possible score second soldier ? first line input consist single integer t ( 1 ≤ t ≤ 1 000 000 ) denote number game soldier play follow t line contain pair integers a b ( 1 ≤ b ≤ a ≤ 5 000 000 ) define value n a game game output a maximum score second soldier get,"['dp', 'math']",1700.0
549/D,first algorithm detect a face image work <unknown> develop paul <unknown> michael jones 2001 . a part algorithm a procedure compute haar feature part task consider a simplify model concept let 's consider a rectangular image represent a table size n × m. table elements integers specify brightness pixel image a feature also a rectangular table size n × m. cell a feature paint black white calculate value give feature give image must perform follow step first table feature put table image ( without rotations reflections ) thus pixel entirely cover either black white cell value a feature image value w - b w total brightness pixels image cover white feature cells b total brightness pixels cover black feature cells examples popular haar feature give task determine number operations require calculate feature use so - called prefix rectangles a prefix rectangle rectangle image upper leave corner coincide upper leave corner image a variable value whose value initially zero one operation count sum pixel value <unknown> prefix rectangle multiply integer add variable value give a feature necessary calculate minimum number operations require calculate value attribute arbitrary image a better understand statement read explanation first sample first line contain two space - separated integers n m ( 1 ≤ n m ≤ 100 ) — number row columns feature next n line contain description feature line consist m character j - th character i - th line equal ` ` w '' element feature white ` ` b '' black print a single number — minimum number operations need make calculate value feature first sample correspond feature b one show picture value feature image size 6 × 8 equal difference total brightness pixels lower upper half image calculate value perform follow two operations : thus pixels lower three row image include factor 1 pixels upper three row image include factor 1 - 2 = - 1 require,"['greedy', 'implementation']",1900.0
549/G,like summer ? residents berland especially love eat ice cream hot summer summer day a large queue n berland residents line front ice cream stall know a certain amount berland dollars residents berland nice people person agree swap place person right behind 1 dollar formally person a stand behind person b person a pay person b 1 dollar a b get swap course person a zero dollars swap place person b. residents berland strange people particular get upset someone a strictly smaller sum money line front help residents berland form order line happy ? a happy resident one stand first line one front another resident stand less number dollars note people berland people honor agree swap place manner describe first line contain integer n ( 1 ≤ n ≤ 200 000 ) — number residents stand line second line contain n space - separated integers ai ( 0 ≤ ai ≤ 109 ) ai number berland dollars a man stand i - th position line position number start end line impossible make residents happy print ` ` : ( ` ` without quote otherwise print single line n space - separated integers i - th must equal number money person position i new line multiple answer print first sample two residents swap place first resident 10 dollars head line second resident 9 coin end line second sample impossible achieve desire result third sample first person swap second one follow number dollars : 4 11 3 second person ( new line ) swap third one result number dollars equal : 4 4 10 . line everybody happy,['greedy'],2200.0
551/E,professor gukiz play array accidentally discover new function call gukiziana give array a index integers 1 n number y gukiziana ( a y ) represent maximum value j - i aj = ai = y. y element a gukiziana ( a y ) equal - 1 . gukiz also prepare a problem time two type query : query type 2 print answer make gukiz happy ! first line contain two integers n q ( 1 ≤ n ≤ 5 * 105 1 ≤ q ≤ 5 * 104 ) size array a number query second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) form array a. next q line contain either four two number describe statement : line start 1 query look like 1 l r x ( 1 ≤ l ≤ r ≤ n 0 ≤ x ≤ 109 ) first type query line start 2 th query look like 2 y ( 1 ≤ y ≤ 109 ) second type query query type 2 print value gukiziana ( a y ) y value query,"['data structures', 'implementation']",2500.0
552/C,vanya a scale weigh load weight mass w0 w1 w2 ... <unknown> grams w integer less 2 ( exactly one weight nominal value ) vanya wonder whether weight item mass m use give weight weight put pan scale formally speak task determine whether possible place item mass m weight leave pan scale weight right pan scale pan scale balance first line contain two integers w m ( 2 ≤ w ≤ 109 1 ≤ m ≤ 109 ) — number define mass weight mass item print word ' yes ' item weight ' no ' note first sample test one pan item mass 7 a weight mass 3 second pan two weight mass 9 1 correspondingly 7 + 3 = 9 + 1 . note second sample test one pan scale item mass 99 weight mass 1 second pan weight mass 100 . note third sample test impossible measure weight item manner describe input,"['dp', 'greedy', 'math']",1900.0
552/D,vanya get bore paint n distinct point plane connect point pairwise saw a result many triangles form vertices paint point ask count number form triangles non - zero area first line contain integer n ( 1 ≤ n ≤ 2000 ) — number point paint plane next n line contain two integers xi yi ( - 100 ≤ xi yi ≤ 100 ) — coordinate i - th point guarantee two give point coincide first line print integer — number triangles non - zero area among paint point note first sample test 3 triangles form : ( 0 0 ) - ( 1 1 ) - ( 2 0 ) ; ( 0 0 ) - ( 2 2 ) - ( 2 0 ) ; ( 1 1 ) - ( 2 2 ) - ( 2 0 ) note second sample test 1 triangle form : ( 0 0 ) - ( 1 1 ) - ( 2 0 ) note third sample test a single point n't form a single triangle,"['data structures', 'math']",1900.0
557/E,tomorrow ann take hardest exam program get excellent mark last <unknown> class teacher introduce notion a half - palindrome string t a half - palindrome odd position i ( ) follow condition hold : ti = t|t| - i + 1 |t| length string t position index 1 . example string ` ` abaa '' ` ` a '' ` ` bb '' ` ` abbbaa '' half - palindromes string ` ` ab '' ` ` bba '' ` ` aaabaa '' ann know exam get string s consist letter a b number k. get excellent mark find k - th lexicographical order string among substrings s half - <unknown> note substring order consider many time many time occur s. teachers guarantee give number k n't exceed number substrings give string half - palindromes cope problem ? first line input contain string s ( 1 ≤ |s| ≤ 5000 ) consist character ' a ' ' b ' |s| length string s. second line contain a positive integer k — lexicographical number request string among half - palindrome substrings give string s. string number start one guarantee number k n't exceed number substrings give string half - palindromes print a substring give string k - th lexicographical order substrings give string half - palindromes definition string a = a1a2 ... lexicographically less string b = <unknown> ... bm either a a prefix b n't coincide b exist i a1 = b1 a2 = b2 ... ai - 1 = bi - 1 ai < bi first sample half - palindrome substrings follow string — a a a a aa aba abaa abba <unknown> b b b b baab bab bb bbab <unknown> ( list give lexicographical order ),"['data structures', 'dp']",2300.0
559/A,gerald get a curious hexagon birthday boy find angle hexagon equal measure length side find equal integer number centimeters properties hexagon end gerald decide draw paint a line parallel side hexagon line split hexagon regular triangles side 1 centimeter gerald wonder many triangles get many gerald lose track count help boy count triangles first single line input contain 6 space - separated integers a1 a2 a3 a4 a5 a6 ( 1 ≤ ai ≤ 1000 ) — lengths side hexagons centimeters clockwise order guarantee hexagon indicate properties exactly side exist print a single integer — number triangles side one 1 centimeter hexagon split gerald 's hexagon look like first sample : 's look like second sample :,['math'],1600.0
559/C,"giant chess quite common geraldion <unknown> rule game 'll say game take place h × w field paint two color like chess almost cells field white black currently gerald finish a game giant chess friend pollard gerald almost thing need win bring pawn upper leave corner board stand lower right corner gerald confident victory become interest many ways win ? pawn gerald get leave go two ways : one cell one cell right addition go black cells otherwise gerald still lose pawn piece leave field , accord rule giant chess gerald move pawn game pollard watch process first line input contain three integers : h w n — side board number black cells ( 1 ≤ h w ≤ 105 1 ≤ n ≤ 2000 ) next n line contain description black cells i - th line contain number ri ci ( 1 ≤ ri ≤ h 1 ≤ ci ≤ w ) — number row column i - th cell guarantee upper leave lower right cell white cells description distinct print a single line — remainder number ways move gerald 's pawn upper leave lower right corner modulo 109 + 7","['dp', 'math']",2200.0
568/B,little johnny recently learn set theory study binary relations ' ve probably hear term ` ` equivalence relation '' relations important many areas mathematics example equality two number equivalence relation a set ρ pair ( a b ) elements set a call a binary relation set a. two elements a b set a say relation ρ pair case use a notation binary relation equivalence relation : little johnny completely a fool notice first condition necessary ! ` ` proof '' : take two elements a b. ( accord property ( 2 ) ) mean ( accord property ( 3 ) ) 's simple n't ? however notice johnny 's ` ` proof '' wrong decide show a lot examples prove wrong 's task : count number binary relations a set size n symmetric transitive equivalence relations ( i.e <unknown> ) since number may large ( 0 accord little johnny ) print remainder integer division number 109 + 7 . a single line contain a single integer n ( 1 ≤ n ≤ 4000 ) a single line print answer problem modulo 109 + 7 . n = 1 one relation — empty one i.e   word a single element x set a follow hold : n = 2 three relations let 's assume set a consist two elements x y. valid relations ρ = { ( x x ) } ρ = { ( y y ) } easy see three list binary relations symmetric transitive relations equivalence relations,"['dp', 'math']",1900.0
570/E,peppa pig walk walk forest a strange coincidence ! forest shape a rectangle consist n row m columns enumerate row rectangle top bottom number 1 n columns — leave right number 1 m. let 's denote cell intersection r - th row c - th column ( r c ) initially pig stand cell ( 1 1 ) end want cell ( n m ) since pig a hurry get home go cell ( r c ) either cell ( r + 1 c ) ( r c + 1 ) leave forest forest pig unusual cells forest similar look different peppa enjoy take picture every step take a picture cell path forest consider beautiful photograph take way view forward reverse order show sequence photos formally line form cells order visit a palindrome ( read a formal definition a palindrome previous problem ) count number beautiful paths cell ( 1 1 ) cell ( n m ) since number large determine remainder divide 109 + 7 . first line contain two integers n m ( 1 ≤ n m ≤ 500 ) — height width field follow n line contain m lowercase english letter identify type cells forest identical cells represent identical letter different cells represent different letter print a single integer — number beautiful paths modulo 109 + 7 . picture illustrate possibilities sample test,['dp'],2300.0
571/A,give three stick positive integer lengths a b c centimeters increase length positive integer number centimeters ( different stick increase a different length ) total l centimeters particular allow increase length stick determine number ways increase lengths stick form a non - degenerate ( a positive area ) triangle two ways consider different length stick increase different number centimeters single line contain 4 integers a b c l ( 1 ≤ a b c ≤ 3·105 0 ≤ l ≤ 3·105 ) print a single integer — number ways increase size stick total l centimeters make a non - degenerate triangle first sample test either increase stick increase two stick 1 centimeter second sample test increase either first second stick one centimeter note triangle make initial stick degenerate thus n't meet condition,"['implementation', 'math']",2100.0
573/E,"limak old brown bear often go bowl friends today feel really good try beat record ! roll a ball one get a score — integer ( maybe negative ) number point score i - th roll multiply i score sum , k roll score s1 s2 ... sk total score total score 0 roll limak make n roll get score ai i - th want maximize total score come interest idea cancel roll say something distract a strong wind limak able cancel number roll maybe even none total score calculate non - <unknown> roll look sample test clarification maximum total score limak get ? first line contain single integer n ( 1 ≤ n ≤ 105 ) second line contain n space - separated integers a1 a2 ... ( |ai| ≤ 107 ) - score limak 's roll print maximum possible total score choose roll cancel first sample limak cancel roll score - 8 - 3 . leave three roll score - 2 0 5 . total score 1 · ( - 2 ) + <unknown> + 3·5 = 13 . second sample limak cancel roll score - 50 . total score 1 · ( - 10 ) + <unknown> + 3 · ( - 30 ) + <unknown> + <unknown> = 400","['data structures', 'greedy']",3200.0
575/I,company ` ` robots <unknown> '' produce robots territory protection robots protect triangle territories — right isosceles triangles <unknown> parallel north - south east - west directions owner land buy set robots territory protect time time businessmen want build offices land want know many robots guard handle query first line contain integer n — width height land integer q — number query handle next q line contain query need process two type query : second type query output many robots guard point answer a separate line,['data structures'],2800.0
578/E,a sand trail front alice 's home <unknown> people walk leave a footprint trail every single step alice distinguish order footprints tell whether footprint make leave foot right foot also 's certain people walk alternate leave foot right foot example suppose one person walk trail leave footprints footprints <unknown> order along trail ( ' r ' mean right foot ' l ' mean leave foot ) might think outcome footprints strange fact step result walk backwards ! possible order step produce footprints 1 → 3 → 2 → 5 → 4 2 → 3 → 4 → 5 → 1 ( suppose distance two consecutive step arbitrarily long ) number backward step two examples 2 1 separately alice interest footprints whenever a person walk <unknown> trail take a picture footprints along trail erase next person leave a new set footprints know people walk alternate right foot leave foot n't know first step make leave foot right foot alice want know minimum possible number backward step make a person 's a little hard please help alice calculate also need construct one possible history footprints one line contain string s ( 1 ≤ |s| ≤ 100 000 ) contain footprints order along trail entrance exit guarantee least one possible footprint history output 2 line first line contain a number denote minimum number backward step second line contain a permutation integers 1 |s| permutation denote order footprints may possible use person walk several possible answer may output first sample one possible order 2 → 5 → 1 → 3 → 4 among step 5 → 1 backward step answer 1 . second example one possible order follow order input thus backward step third sample 4 backward step every step l r a backward step,['greedy'],2700.0
581/B,"capital berland n <unknown> build architect build capital creative house build one row let 's enumerate house leave right start one a house consider luxurious number floor strictly greater house larger number word a house luxurious number floor strictly greater house locate right task assume heights floor house new architect interest n question i - th follow : ` ` many floor add i - th house make luxurious ? '' ( i 1 n inclusive ) need help cope task note question independent — answer question house i affect answer ( i.e. floor house actually add ) first line input contain a single number n ( 1 ≤ n ≤ 105 ) — number house capital berland second line contain n space - separated positive integers hi ( 1 ≤ hi ≤ 109 ) hi equal number floor i - th house print n integers a1 a2 ... , number ai number floor need add house number i make luxurious house already luxurious nothing need add ai equal zero house number leave right start one","['implementation', 'math']",1100.0
581/D,three company decide order a billboard picture logos a billboard a big square board a logo company a rectangle a non - zero area advertisers put ad possible place three logos billboard overlap billboard empty space leave put a logo billboard rotate side parallel side billboard task determine possible put logos three company square billboard without break describe rule first line input contain six positive integers x1 y1 x2 y2 x3 y3 ( 1 ≤ x1 y1 x2 y2 x3 y3 ≤ 100 ) xi yi determine length width logo i - th company respectively impossible place three logos a square shield print a single integer ` ` -1 '' ( without quote ) possible print first line length a side square n place three logos next n line contain n uppercase english letter ` ` a '' ` ` b '' ` ` c '' set letter form solid rectangles provide : note logos company rotate print billboard billboard must n't empty space a square billboard fill logos multiple ways allow print see sample better understand statement,"['implementation', 'math']",1700.0
584/A,<unknown> love number consist n digits <unknown> like number divisible t. find number satisfy task : give n t print integer strictly larger zero consist n digits divisible t. number n't exist print - 1 . single line contain two number n t ( 1 ≤ n ≤ 100 2 ≤ t ≤ 10 ) — length number number divisible print one positive number without lead zero — answer problem - 1 number n't exist multiple possible answer allow print,['math'],1000.0
59/B,marina love sasha keep wonder whether sasha love course best way know fortune tell many ways tell fortune marina pick easiest one take hand one several camomiles tear petals one one petal pronounce alternatively ` ` love '' ` ` n't love '' marina always start ` ` love '' n camomiles grow field possess number petals equal a1 a2 ... marina want pick a bouquet maximal possible total number petals result would still ` ` love '' help ; find maximal number petals possible bouquet first line contain integer n ( 1 ≤ n ≤ 100 ) number flower grow field second line contain n integers ai ( 1 ≤ ai ≤ 100 ) represent number petals a give i - th <unknown> print a single number maximal number petals bouquet fortune tell would result ` ` love '' bouquet print 0 instead bouquet may consist a single flower,['implementation'],1200.0
593/C,every day ruslan try count sheep fall asleep n't help find a interest thing first think set circle a plane try choose a beautiful set point least one point set inside border imagine circle yesterday ruslan try solve problem case set point consider beautiful give ( xt = f ( t ) yt = g ( t ) ) argument t take integer value 0 50 . moreover f ( t ) g ( t ) correct function assume w ( t ) h ( t ) correct function c integer range 0 50 . function s ( t ) correct 's obtain one follow rule : yesterday ruslan think could cope task ask write a program compute appropriate f ( t ) g ( t ) set 50 circle function f ( t ) g ( t ) allow use 50 multiplications length function exceed <unknown> character function contain space ruslan ca n't keep big number memory choose f ( t ) g ( t ) integer t 0 50 value f ( t ) g ( t ) intermediate calculations wo n't exceed 109 absolute value first line input contain number n ( 1 ≤ n ≤ 50 ) — number circle ruslan think next follow n line contain three integers xi yi ri ( 0 ≤ xi yi ≤ 50 2 ≤ ri ≤ 50 ) — coordinate center <unknown> i - th circle first line print a correct function f ( t ) second line print a correct function g ( t ) set point ( xt = f ( t ) yt = g ( t ) ) ( 0 ≤ t ≤ 50 ) must satisfy condition least one point inside border circle ruslan think begin correct function : incorrect function :,['math'],2200.0
594/C,edo get a collection n refrigerator magnets ! decide buy a refrigerator hang magnets door shop make refrigerator size door meet follow restrictions : refrigerator door must rectangle length width door must positive integers edo figure want place magnets refrigerator introduce a system coordinate plane magnet represent a rectangle side parallel coordinate ax want remove k magnets ( may choose keep ) attach remain magnets refrigerator door area ​​the door small possible a magnet consider attach refrigerator door center lie door boundary relative position remain magnets must correspond plan let us explain last two sentence let 's suppose want hang two magnets refrigerator magnet plan coordinate lower leave corner ( x1 y1 ) upper right corner ( x2 y2 ) center locate ( ) ( may integers ) say relative position correspond plan mean available operation translation i.e vector connect center two magnets original plan must equal vector connect center two magnets refrigerator side refrigerator door must also parallel coordinate ax first line contain two integers n k ( 1 ≤ n ≤ 100 000 0 ≤ k ≤ min ( 10 n - 1 ) ) — number magnets edo maximum number magnets edo may place refrigerator next n line describe initial plan place magnets line contain four integers x1 y1 x2 y2 ( 1 ≤ x1 < x2 ≤ 109 1 ≤ y1 < y2 ≤ 109 ) — coordinate lower leave upper right corner current magnet magnets partially overlap even fully coincide print a single integer — minimum area door refrigerator use place least n - k magnets preserve relative position first test sample optimal remove either first third magnet remove first magnet center two others lie point ( 2.5 2.5 ) ( 3.5 3.5 ) thus enough buy a fridge door width 1 door height 1 area door also equal one correspondingly second test sample n't matter magnet remove answer change — need a fridge door width 8 door height 8 . third sample remove anything k = 0,"['greedy', 'implementation']",2300.0
6/D,simplify version problem use original contest original problem seem <unknown> solution constraints input data reduce polycarp like play computer role - playing game « <unknown> <unknown> » moment play a magician one last level fight line archers spell damage a fire ball polycarp hit i - th archer fire ball ( number leave right ) archer lose a health point time spell damage archers adjacent i - th ( ) — lose b ( 1 ≤ b < a ≤ 10 ) health point extreme archers ( i.e archers number 1 n ) far fire ball reach polycarp hit archer fire ball amount health point archer know archer kill amount less 0 . minimum amount spell polycarp use kill enemies ? polycarp throw fire ball archer latter already kill first line input contain three integers n a b ( 3 ≤ n ≤ 10 ; 1 ≤ b < a ≤ 10 ) second line contain a sequence n integers — h1 h2 ... hn ( 1 ≤ hi ≤ 15 ) hi amount health point i - th archer first line print t — require minimum amount fire ball second line print t number — index archers polycarp hit kill archers t shots number 2 n - 1 . separate number space several solutions output print number order,['dp'],2600.0
600/C,a string call palindrome read leave right right leave example ` ` <unknown> '' ` ` oo '' ` ` r '' ` ` <unknown> '' <unknown> string ` ` abb '' ` ` ij '' give string s consist lowercase latin letter choose position string change letter position lowercase letter change length string n't change first change letter s. permute order letter want permutation n't count change obtain palindrome minimal number change several ways get lexicographically ( alphabetically ) smallest palindrome firstly minimize number change minimize palindrome lexicographically line contain string s ( 1 ≤ |s| ≤ 2·105 ) consist lowercase latin letter print lexicographically smallest palindrome obtain minimal number change,['greedy'],1800.0
604/B,kevin sun want move precious collection n cowbells <unknown> <unknown> actually grass instead corn move must pack cowbells k box a fix size order keep collection safe transportation wo n't place two cowbells a single box since kevin wish minimize expense curious smallest size box use pack entire collection kevin a meticulous cowbell collector know size i - th ( 1 ≤ i ≤ n ) cowbell integer si fact keep cowbells sort size si - 1 ≤ si i > 1 . also expert <unknown> kevin fit one two cowbells a box size s sum size exceed s. give information help kevin determine smallest s possible put cowbells k box size s. first line input contain two space - separated integers n k ( 1 ≤ n ≤ 2·k ≤ 100 000 ) denote number cowbells number box respectively next line contain n space - separated integers s1 s2 ... sn ( 1 ≤ s1 ≤ s2 ≤ ... ≤ sn ≤ 1 000 000 ) size kevin 's cowbells guarantee size si give non - decreasing order print a single integer smallest s possible kevin put cowbells k box size s. first sample kevin must pack two cowbells box second sample kevin pack together follow set cowbells : { 2 3 } { 5 } { 9 } third sample optimal solution { 3 5 } { 7 },['greedy'],1400.0
610/D,vika infinite sheet square paper initially square white introduce a two - dimensional coordinate system sheet draw n black horizontal vertical segment parallel coordinate ax segment width equal 1 square mean every segment occupy set neighbour square situate one row one column task calculate number paint cells a cell paint calculate exactly first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number segment draw vika next n line contain four integers x1 y1 x2 y2 ( - 109 ≤ x1 y1 x2 y2 ≤ 109 ) — coordinate endpoints segment draw vika guarantee segment parallel coordinate ax segment may touch overlap even completely coincide print number cells paint vika a cell paint calculate exactly answer first sample vika paint square ( 0 1 ) ( 1 1 ) ( 2 1 ) ( 1 2 ) ( 1 3 ) ( 1 4 ) ( 0 3 ) ( 2 3 ),['data structures'],2300.0
611/C,say ` ` years like dominoes <unknown> one '' would a year fit a grid ? i n't think limak a little polar bear love play recently get a rectangular grid h row w columns cell a square either empty ( denote ' . ' ) forbid ( denote ' # ' ) row number 1 h top bottom columns number 1 w leave right also limak a single domino want put somewhere a grid a domino occupy exactly two adjacent cells locate either one row one column adjacent cells must empty must inside a grid limak need fun thus go consider query query choose rectangle wonder many way put a single domino inside choose rectangle ? first line input contain two integers h w ( 1 ≤ h w ≤ 500 ) – number row number columns respectively next h line describe a grid line contain a string length w. character either ' . ' ' # ' — denote empty forbid cell respectively next line contain a single integer q ( 1 ≤ q ≤ 100 000 ) — number query next q line contain four integers r1i c1i r2i c2i ( 1 ≤ r1i ≤ r2i ≤ h 1 ≤ c1i ≤ c2i ≤ w ) — i - th query number r1i c1i denote row column ( respectively ) upper leave cell rectangle number r2i c2i denote row column ( respectively ) bottom right cell rectangle print q integers i - th equal number ways put a single domino inside i - th rectangle a red frame correspond first query first sample a domino place 4 possible ways,"['dp', 'implementation']",1500.0
612/C,give string s consist open close bracket four kinds < > { } [ ] ( ) two type bracket : open close replace bracket another type example replace < bracket { ca n't replace ) > follow definition a regular bracket sequence well - known familiar let 's define a regular bracket sequence ( rbs ) empty string rbs let s1 s2 a rbs string < s1 > s2 { s1 } s2 [ s1 ] s2 ( s1 ) s2 also rbs example string ` ` [ [ ( ) { } ] < > ] '' rbs string ` ` [ ) ( ) '' ` ` ] [ ( ) ( ) '' determine least number replace make string s rbs line contain a non empty string s consist open close bracket four kinds length s exceed 106 . 's impossible get rbs s print impossible otherwise print least number replace need get rbs s,"['data structures', 'math']",1400.0
613/C,ivan want make a necklace a present beloved girl a necklace a cyclic sequence bead different color ivan say necklace beautiful relative cut point two adjacent bead chain bead remain cut a palindrome ( read forward backward ) ivan bead n color want make a necklace 's beautiful relative many cut possible certainly want use bead help make beautiful necklace first line input contain a single number n ( 1 ≤ n ≤ 26 ) — number color bead second line contain n positive integers ai — quantity bead i - th color guarantee sum ai least 2 exceed 100 000 . first line print a single number — maximum number beautiful cut a necklace compose give bead may second line print example necklace color bead represent correspond lowercase english letter ( start a ) necklace cyclic print start point first sample a necklace one beautiful cut example a necklace show picture second sample one way compose a necklace,['math'],2500.0
613/E,oleg petrov love crossword puzzle every thursday buy favorite magazine crosswords word puzzle last magazine oleg find a curious puzzle magazine promise a valuable prize 's solution give a formal description problem puzzle field consist two row row contain n cells cell contain exactly one small english letter also give a word w consist k small english letter a solution puzzle a sequence field cells c1 ... ck : oleg petrov quickly find a solution puzzle wonder many distinct solutions puzzle oleg petrov n't like large number calculate answer modulo 109 + 7 . two solutions ci c ' i consider distinct sequence cells match least one position j range 1 k cj ≠ c ' j first two line contain state field puzzle non - empty line contain exactly n small english letter next line leave empty next line non - empty contain word w consist small english letter length line n't exceed 2 000 . print a single integer — number distinct solutions puzzle modulo 109 + 7,['dp'],3200.0
615/B,"christmas santa give masha a magic picture a pencil picture consist n point connect m segment ( might cross way n't matter ) two segment connect pair point segment connect point masha want color segment order paint a hedgehog <unknown> mind every hedgehog consist a tail spin want paint tail satisfy follow condition : masha define length tail number point also want paint spin , masha paint segment one end endpoint tail masha define beauty a hedgehog length tail multiply number spin masha want color beautiful hedgehog help calculate result may hope get note accord masha 's definition a hedgehog one segment may simultaneously serve a <unknown> a part tail ( a little girl ) take a look picture clarifications first line input contain two integers n m ( 2 ≤ n ≤ 100 000 1 ≤ m ≤ 200 000 ) — number point number segment picture respectively follow m line contain two integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) — number point connect correspond segment 's guarantee two segment connect pair point print maximum possible value hedgehog 's beauty picture correspond first sample segment form hedgehog paint red tail consist a sequence point number 1 2 5 . follow segment spin : ( 2 5 ) ( 3 5 ) ( 4 5 ) therefore beauty hedgehog equal 3·3 = 9",['dp'],1600.0
620/A,professor gukiz make a new robot robot point coordinate ( x1 y1 ) go point ( x2 y2 ) a single step robot change coordinate ( maybe ) one ( decrease increase ) robot move one 8 directions find minimal number step robot make get finish position first line contain two integers x1 y1 ( - 109 ≤ x1 y1 ≤ 109 ) — start position robot second line contain two integers x2 y2 ( - 109 ≤ x2 y2 ≤ 109 ) — finish position robot print integer d — minimal number step get finish position first example robot increase coordinate one four time position ( 4 4 ) robot simply increase y coordinate get finish position second example robot simultaneously increase x coordinate decrease y coordinate one three time,"['implementation', 'math']",800.0
622/F,"well - known formulas : , also mathematicians find similar formulas higher degrees find value sum modulo 109 + 7 ( find remainder divide answer value 109 + 7 ) line contain two integers n k ( 1 ≤ n ≤ 109 0 ≤ k ≤ 106 ) print integer a — remainder divide value sum value 109 + 7",['math'],2600.0
623/E,let 's define transformation p a sequence integers a1 a2 ... b1 b2 ... bn bi = a1 | a2 | ... | ai i = 1 2 ... n | bitwise operation vasya consequently apply transformation p sequence length n consist integers 1 2k - 1 inclusive want know many sequence property transformation a strictly increase sequence help calculate number modulo 109 + 7 . line input contain two integers n k ( 1 ≤ n ≤ 1018 1 ≤ k ≤ 30 000 ) print a single integer — answer problem modulo 109 + 7,"['dp', 'math']",3300.0
624/B,give alphabet consist n letter task make a string maximum possible length follow condition satisfy : first line input contain a single integer n ( 2 ≤ n ≤ 26 ) — number letter alphabet next line contain n integers ai ( 1 ≤ ai ≤ 109 ) — i - th integers give limitation number occurrences i - th character string print a single integer — maximum length string meet requirements convenience let 's consider alphabet consist three letter : ` ` a '' ` ` b '' ` ` c '' first sample optimal string : ` ` <unknown> '' ` ` <unknown> '' second sample optimal string : ` ` acc '' ` ` <unknown> '',['greedy'],1100.0
625/E,"ostap bender recently visit frog farm inspire create frog game number frog place a cyclic gameboard divide m cells cells number 1 m board cyclic cell number 1 go right cell number m direction movement i - th frog turn jump ai cells frog move turn game start a move frog 1 . turn i - th frog move ai cells forward knock frog way a frog last cell path i - th frog frog also knock value ai decrease number frog knock turn ai zero go negative i - th frog n't make move anymore frog number 1 finish turn frog number 2 start move frog number 3 frog number n make move frog 1 start move frog 2 process go forever frog already knock board consider skip move help ostap identify frog stay board end a game ? first line input contain two integers n m ( 1 ≤ n ≤ 100000 1 ≤ m ≤ 109 n ≤ m ) — number frog gameboard size respectively follow n line contain frog descriptions — two integers pi ai ( 1 ≤ pi ai ≤ m ) — number cell occupy i - th frog initially initial jump length pi guarantee distinct first line output number frog final gameboard second line output number order first sample first frog jump 1 cell finish cell number 3 . second frog jump 3 cells finish cell number 3 knock frog number 1 . current jump length frog number 2 2 . third frog jump cell 2 second frog jump cell 5 . third frog turn finish cell 5 remove frog 2 gameboard , 's remain frog game second sample first frog jump 2 cells knock frog cells 2 3 . value ai 0 . fourth frog jump knock fifth frog ai 0 two frog remain gameboard forever","['data structures', 'greedy']",2800.0
626/C,students a class make tower block student make a ( non - zero ) tower stack piece <unknown> top n students use piece make two block m students use piece make three block students ’ t want use many block also want unique two students ’ tower may contain number block find minimum height necessary tallest students ' tower first line input contain two space - separated integers n m ( 0 ≤ n m ≤ 1 000 000 n + m > 0 ) — number students use two - block piece number students use three - block piece respectively print a single integer denote minimum possible height tallest tower first case student use two - block piece make a tower height 4 students use three - block piece make tower height 3 6 9 block tallest tower a height 9 block second case students make tower heights 2 4 8 two - block piece tower heights 3 6 three - block piece a maximum height 8 block,"['greedy', 'math']",1600.0
628/B,max want buy a new skateboard calculate amount money need buy a new skateboard leave a calculator floor go ask money parent meanwhile little brother yusuf come start press key randomly unfortunately max forget number calculate thing know number divisible 4 . give a string s consist digits ( number display calculator yusuf randomly press key ) task find number substrings divisible 4 . a substring start a zero a substring a string a nonempty sequence consecutive character example string s 124 four substrings divisible 4 : 12 4 24 124 . string 04 answer three : 0 4 04 . input / output reach huge size recommend use fast input / output methods : example prefer use gets / scanf / printf instead getline / cin / cout c++ prefer use bufferedreader / printwriter instead scanner / system.out java line contain string s ( 1 ≤ |s| ≤ 3·105 ) string s contain digits 0 9 . print integer a — number substrings string s divisible 4 . note answer huge use 64 - bit integer type store c++ use long long integer type java use long integer type,['dp'],1300.0
628/E,a tourist want visit country zeydabad zbazi ( a local game zeydabad ) country zeydabad a rectangular table consist n row m columns cell country either ' z ' ' . ' tourist know country name zeydabad lot ` ` z - pattern '' s country a ` ` z - pattern '' a square anti - diagonal completely fill ' z ' upper lower row also completely fill ' z ' cells a square arbitrary note a ` ` z - pattern '' consist one cell ( see examples ) want count number ` ` z - pattern '' s country ( a necessary skill zbazi ) task help tourist count number ` ` z - pattern '' s. input / output reach huge size recommend use fast input / output methods : example prefer use gets / scanf / printf instead getline / cin / cout c++ prefer use bufferedreader / printwriter instead scanner / system.out java first line contain two integers n m ( 1 ≤ n m ≤ 3000 ) — number row columns respectively next n line contain m character ' z ' ' . ' — description zeydabad print integer a — number ` ` z - pattern '' s zeydabad,"['data structures', 'implementation']",2300.0
629/C,famil door ’ s birthday come friends ( like gabi ) decide buy a present friends go buy a string consist round bracket since famil door love string bracket length n string ! sequence round bracket call valid : gabi buy a string s length m ( m ≤ n ) want complete obtain a valid sequence bracket length n. go pick string p q consist round bracket merge a string p + s + q add string p begin string s string q end string s. wonder many pair string p q exist string p + s + q a valid sequence round bracket number may pretty large want calculate modulo 109 + 7 . first line contain n m ( 1 ≤ m ≤ n ≤ 100 000 n - m ≤ 2000 ) — desire length string length string buy gabi respectively second line contain string s length m consist character ' ( ' ' ) ' print number pair string p q p + s + q a valid sequence round bracket modulo 109 + 7 . first sample four different valid pair : second sample way obtain a desire string choose empty p q. third sample way get a valid sequence bracket,['dp'],2000.0
63/E,karlsson visit lillebror find a box chocolates a big <unknown> cream cake lillebror 's place karlsson immediately suggest divide sweets fairly lillebror specifically play together a game invent chocolates winner get cake a reward box chocolates form a hexagon contain 19 cells chocolates contain a chocolate players move turn one move allow eat one several chocolates lay neighbor cells one line parallel one box 's side picture show examples allow move unacceptable one player make a move lose karlsson make first move lillebror 's guest vice versa players play optimally determine get cake input data contain 5 line contain 19 word consist one symbol word ` ` o '' mean cell contain a chocolate a ` ` . '' stand empty cell guarantee box contain least one chocolate see examples better understand karlsson get cake print ` ` karlsson '' ( without quote ) otherwise print ` ` lillebror '' ( yet without quote ),"['dp', 'implementation']",2000.0
630/D,a <unknown> period game development company city petya include a group programmers develop a new turn - based strategy game resemble well know ` ` heroes might & magic '' a part game turn - based fight big <unknown> enemies infinite field every cell form a hexagon magic effect able affect several field cells cells situate farther n cells away cell effect apply distance cells minimum number cell border cross a path one cell another easy see number cells affect a magic effect grow rapidly n increase <unknown> affect game performance 's petya decide write a program give n determine number cells repaint effect application game designers balance scale effect game performance help find number hexagons situate farther n cells away a give cell line input contain one integer n ( 0 ≤ n ≤ 109 ) output one integer — number hexagons situate farther n cells away a give cell,['math'],1100.0
630/J,city company develop computer game invent a new way reward employees a new game release users start buy actively company track number sales precision transaction every time next number sales divisible number 2 10 every developer game get a small bonus a game designer petya know company release a new game partly develop basis experience predict n people buy game first month petya want determine many time get bonus help know line input contain one integer n ( 1 ≤ n ≤ 1018 ) — prediction number people buy game output one integer show many number 1 n divisible number 2 10,['math'],1100.0
630/M,vasya start work a machine vision company city vasya 's team create software hardware identification people face one project 's know - how a camera rotate around <unknown> axis shoot people see eye - <unknown> gadget — a rotate camera — come see better look camera take photo time could better high quality identification ? everything simple picture camera appear rotate ( clockwise camera rotation frame content become rotate counter - clockwise ) identification algorithm work face slightly deviate vertical vasya entrust correct situation — rotate a capture image image would minimally deviate vertical requirements severe firstly picture rotate angle divisible 90 degrees lose a bite information image secondly frame camera huge fps big adequate rotation speed provide hardware fpga solution solution rotate 90 degrees clockwise course one apply 90 degrees turn several time sake performance number turn minimize help vasya implement program give rotation angle camera determine minimum number 90 degrees clockwise turn necessary get a picture direction deviation vertical minimum next figure contain frame take <unknown> camera rotate 90 degrees clockwise rotate 90 degrees counter - clockwise arrows show direction ` ` true '' next figure show 90 degrees clockwise turn fpga hardware line input contain one integer x ( - 1018 ≤ x ≤ 1018 ) — camera angle degrees positive value denote clockwise camera rotation negative — counter - clockwise output one integer — minimum require number 90 degrees clockwise turn camera rotate 60 degrees counter - clockwise ( second example ) image rotate 60 degrees clockwise one 90 degrees clockwise turn image result 150 degrees clockwise total rotation deviation ` ` true '' one turn 150 degrees two 90 degrees clockwise turn image result 240 degrees clockwise total rotation deviation ` ` true '' two turn 120 degrees 240 degrees clockwise equal 120 degrees counter - clockwise three 90 degrees clockwise turn image result 330 degrees clockwise total rotation deviation ` ` true '' three turn 30 degrees 330 degrees clockwise equal 30 degrees counter - clockwise 60 150 120 30 degrees <unknown> smallest 30 achieve three 90 degrees clockwise turn,['math'],1800.0
631/D,"employee ` ` blake <unknown> '' company use a special message app ` ` blake messenger '' stuff like app use constantly however important <unknown> miss example many users want able search message history already announce new feature appear nearest update developers face trouble may help solve message represent a string consist lowercase english letter order reduce network load string represent special compress form compression algorithm work follow : string represent a concatenation n block block contain equal character one block may describe a pair ( li ci ) li length i - th block ci correspond letter thus string s may write sequence pair task write program give two compress string t s find occurrences s t. developers know may many occurrences ask find number note p start position occurrence s t <unknown> + 1 ... tp + |s| - 1 = s ti i - th character string t. note way represent string compress form may unique example string ` ` aaaa '' may give , ... first line input contain two integers n m ( 1 ≤ n m ≤ 200 000 ) — number block string t s respectively second line contain descriptions n part string t format ` ` li - ci '' ( 1 ≤ li ≤ 1 000 000 ) — length i - th part correspond lowercase english letter second line contain descriptions m part string s format ` ` li - ci '' ( 1 ≤ li ≤ 1 000 000 ) — length i - th part correspond lowercase english letter print a single integer — number occurrences s t. first sample t = ` ` <unknown> '' string s = ` ` aabbc '' occurrence string s string t start position p = 2 . second sample t = ` ` <unknown> '' s = ` ` aaa '' occurrences s t start position p = 1 p = 10 p = 11 p = 12 p = 13 p = 14","['data structures', 'implementation']",2100.0
633/B,mr . santa ask great programmers world solve a trivial problem give integer m ask number positive integers n factorial n end exactly m zero among great programmers solve problem ? line input contain integer m ( 1 ≤ m ≤ 100 000 ) — require number trail zero factorial first print k — number value n factorial n end m zero print k integers increase order factorial n equal product integers 1 n inclusive n ! = 1·2·3 · ... · n first sample 5 ! = 120 6 ! = 720 7 ! = 5040 8 ! = <unknown> 9 ! = <unknown>,['math'],1300.0
633/D,"yash recently learn fibonacci sequence excite call a sequence fibonacci - ish give sequence integers a1 a2 ... , task rearrange elements sequence a way longest possible prefix fibonacci - ish sequence first line input contain a single integer n ( 2 ≤ n ≤ 1000 ) — length sequence ai second line contain n integers a1 a2 ... ( |ai| ≤ 109 ) print length longest possible fibonacci - ish prefix give sequence rearrangement first sample rearrange elements sequence - 1 2 1 whole sequence ai would fibonacci - ish second sample optimal way rearrange elements , , 28","['dp', 'implementation', 'math']",2000.0
637/B,polycarp a big lover kill time social network a page a <unknown> favourite network make a message send friend friend 's chat rise top page relative order chat n't change chat friend a new chat simply insert top list assume chat list initially empty give sequence polycaprus ' message make a list chat message process assume friend write message polycarpus first line contain integer n ( 1 ≤ n ≤ 200 000 ) — number polycarpus ' message next n line <unknown> message recipients order message send name participant a non - empty sequence lowercase english letter length 10 . print recipients polycarp talk order chat top bottom first test case polycarpus first write friend name ` ` alex '' list look follow : polycarpus write friend name ` ` ivan '' list look follow : polycarpus write third message friend name ` ` roman '' list look follow : polycarpus write fourth message friend name ` ` ivan '' already send a message list chat change follow :,['data structures'],1200.0
637/D,a sportsman start point <unknown> = 0 run point coordinate <unknown> = m ( a straight line ) also sportsman jump — jump first take a run length less s meter ( case s meter path obstacles ) jump a length d meter run jump permit direction leave right start <unknown> a jump point integer coordinate obstacles overcome obstacle necessary land a point strictly right obstacle way athlete n obstacles coordinate x1 x2 ... xn go obstacles jump task determine whether athlete able get finish point first line input <unknown> four integers n m s d ( 1 ≤ n ≤ 200 000 2 ≤ m ≤ 109 1 ≤ s d ≤ 109 ) — number obstacles runner 's way coordinate finish point length run jump maximum length jump correspondingly second line contain a sequence n integers a1 a2 ... ( 1 ≤ ai ≤ m - 1 ) — coordinate obstacles guarantee start finish point obstacles also point one obstacle coordinate obstacles give arbitrary order runner reach finish point print first line output ` ` impossible '' ( without quote ) athlete get start finish print way follow format : command ` ` run '' ` ` jump '' strictly alternate start ` ` run '' besides print chronologically allow jump finish point allow land a jump athlete stop soon reach finish,"['data structures', 'dp', 'greedy']",1600.0
639/D,"codeforces a wonderful platform one feature show much someone contribute community every register user contribution — integer number necessarily positive n register users i - th contribution ti limak a little polar bear 's new competitive program n't even account codeforces able upvote exist blog comment assume every register user infinitely many blog comment note 's possible limak read blog faster comment limak like tie think would awesome see a tie least k register users make happen go spend time read <unknown> , exist integer value x least k register users contribution exactly x. much time limak need achieve goal ? first line contain four integers n k b c ( 2 ≤ k ≤ n ≤ 200 000 1 ≤ b c ≤ 1000 ) — number register users require minimum number users contribution time need read upvote a blog time need read upvote a comment respectively second line contain n integers t1 t2 ... tn ( |ti| ≤ 109 ) ti denote contribution i - th register user print minimum number minutes limak spend get a tie least k register users first sample 4 register users limak want a tie least 3 limak behave follow give scenario limak spend 100 + <unknown> = 220 minutes users 2 3 4 contribution 6 . second sample limak need 30 minutes read a blog 100 minutes read a comment time get 3 users contribution equal 12 spend 100 + <unknown> = 190 minutes :","['data structures', 'greedy']",2400.0
64/A,print factorial give integer number n. factorial n equal 1·2 · ... · n line contain n ( 1 ≤ n ≤ 10 ) print factorial n,['implementation'],1300.0
644/B,problem simulate workflow one - thread server n query process i - th receive moment ti need process di units time ti guarantee distinct a query appear server may react three possible ways : soon server finish process query pick new one queue ( 's empty course ) a new query come moment x server finish process another query exactly moment consider first query pick queue new query appear query find moment server finish process print -1 query reject first line input contain two integers n b ( 1 ≤ n b ≤ 200 000 ) — number query maximum possible size query queue follow n line query descriptions ( chronological order ) description consist two integers ti di ( 1 ≤ ti di ≤ 109 ) ti moment time i - th query appear di time server need process guarantee ti - 1 < ti i > 1 . print sequence n integers e1 e2 ... en ei moment server finish process i - th query ( query number order appear input ) - 1 correspond query reject consider first sample,['data structures'],1700.0
645/F,attempt make peace <unknown> mess makers bessie farmer john plan plant flower garden complement <unknown> <unknown> field bovinia good horticulturist know garden plant must exact arrangement flower initially farmer john n different species flower plant ai flower i - th species next q days farmer john receive a batch flower a new species day j receive cj flower species a different species farmer john already farmer john know right balance <unknown> <unknown> want exactly k species flower use furthermore reduce waste flower k species farmer john choose must plant garden garden must identical ; say k choose species equal number flower garden farmer john a proponent national equality would like create greatest number garden possible receive flower q days farmer john would like know sum possible choices k species maximum number garden could create since could a large number output result modulo 109 + 7 . first line input contain three integers n k q ( 1 ≤ k ≤ n ≤ 100 000 1 ≤ q ≤ 100 000 ) i - th ( 1 ≤ i ≤ n ) next n line input contain integer ai ( 1 ≤ ai ≤ 1 000 000 ) number flower species i farmer john initially j - th ( 1 ≤ j ≤ q ) next q line input contain integer cj ( 1 ≤ cj ≤ 1 000 000 ) number flower a new species farmer john receive day j. q days output sum maximum possible number garden sum take possible choices k species modulo 109 + 7 . first sample case first day farmer john ( 4 6 9 8 ) type flower k = 3 . choose ( 4 6 8 ) let make 2 garden ( 2 3 4 ) flower respectively choose ( 4 6 9 ) ( 4 9 8 ) ( 6 9 8 ) let make one garden since number garden species evenly split sum choices k = 3 flower 2 + 1 + 1 + 1 = 5 . second day farmer john ( 4 6 9 8 6 ) flower sum choices 1 + 2 + 2 + 1 + 1 + 2 + 2 + 3 + 1 + 1 = 16 . second sample case k = 1 . x flower farmer john make x garden answer query 6 + 5 + 4 + 3 + 2 = 20 6 + 5 + 4 + 3 + 2 + 1 = 21,['math'],2500.0
651/A,friends go play console two joysticks one charger initially first joystick charge a1 percent second one charge a2 percent connect charger a joystick begin minute one minute joystick either discharge 2 percent ( connect a charger ) charge 1 percent ( connect a charger ) game continue joysticks a positive charge hence begin minute joystick charge 1 percent connect a charger otherwise game stop joystick completely discharge ( charge turn 0 ) game also stop determine maximum number minutes game last prohibit pause game i. e. moment joysticks enable allow joystick charge 100 percent first line input contain two positive integers a1 a2 ( 1 ≤ a1 a2 ≤ 100 ) initial charge level first second joystick respectively output integer maximum number minutes game last game continue joystick discharge first sample game last 6 minute use follow algorithm : first joystick completely discharge game stop,"['dp', 'greedy', 'implementation', 'math']",1100.0
659/C,berland recently a new collection toy go sale collection consist 109 type toy number integers 1 109 . a toy new collection i - th type cost i bourles tania manage collect n different type toy a1 a2 ... new collection today tanya 's birthday mother decide spend m bourles gift daughter tanya choose several different type toy new collection a gift course want get a type toy already tanya want many distinct type toy collection possible result new collection diverse tanya little ask help first line contain two integers n ( 1 ≤ n ≤ 100 000 ) m ( 1 ≤ m ≤ 109 ) — number type toy tanya already number bourles mom will spend buy new toy next line contain n distinct integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — type toy tanya already first line print a single integer k — number different type toy tanya choose number different type toy collection maximum possible course total cost select toy exceed m. second line print k distinct space - separated integers t1 t2 ... tk ( 1 ≤ ti ≤ 109 ) — type toy tanya choose multiple answer may print value ti print order first sample mom buy two toy : one toy 2 - nd type one toy 5 - th type purchase 7 bourles ( assume toy type 1 3 4 already buy ) impossible buy two toy,"['greedy', 'implementation']",1200.0
659/G,"long ago vasily build a good fence country house vasily call a fence good a series n consecutively <unknown> vertical board centimeter width height centimeters a positive integer house owner remember height i - th board leave hi today vasily decide change design fence build cut top connect part fence remain good cut part consist upper part board adjacent part must <unknown> ( share a non - zero length cut fence ) , vasily 's curious neighbor count number possible ways cut exactly one part describe two ways cut a part call distinct remain fence i height i - th board vary vasily 's fence high long get remainder divide require number ways 1 000 000 007 ( 109 + 7 ) first line contain integer n ( 1 ≤ n ≤ 1 000 000 ) — number board vasily 's fence second line contain n space - separated number h1 h2 ... hn ( 1 ≤ hi ≤ 109 ) hi equal height i - th board leave print remainder divide r 1 000 000 007 r number ways cut exactly one connect part part consist upper part board remain fence good fence first example impossible cut exactly one piece remain fence good possible variants result fence second sample look follow ( grey show cut part ) :",['dp'],2300.0
66/C,"recently a program lesson little petya show quickly create file folders computer get soon feed activity decide a much useful thing decide calculate folder contain subfolders ( include nest folders nest folders nest folders ) folder contain file ( include file subfolders ) formally subfolders folder directly nest folders subfolders nest folders give folder consider subfolder a file regard lie a folder either lie directly folder lie subfolder folder a better understand count subfolders file calculate answer see note answer sample give a file petya manage create path file look follow : diskname : <unknown> ... \ <unknown> also know file whose path look like diskname : <unknown> , file store folder file directly root also let us assume disk root a folder help petya find largest number subfolders folder largest number file folder count subfolders line input data contain description one file path length line exceed 100 overall 100 line guarantee paths correct meet rule also guarantee two completely equal line , file describe exactly least one line input data print two space - separated number first one maximal number possible subfolders a folder ( include nest folders nest folders nest folders ) second one maximal number file a folder ( include nest file subfolders ) note disk regard folders first sample one folder ` ` c '' disk subfolders first number answer 0 . folder contain one file second number answer 1 . second sample several different folders consider ` ` folder1 '' folder ` ` c '' disk folder directly contain one folder ` ` folder2 '' ` ` folder2 '' folder contain two folders — ` ` <unknown> '' ` ` <unknown> '' thus ` ` folder1 '' folder ` ` c '' drive exactly 3 subfolders also folder contain two file even though lie directly folder locate subfolders ` ` folder1 '' third example see name folders subfolders identical consider ` ` file '' folder lie directly ` ` c '' disk folder contain another ` ` file '' folder turn contain another ` ` file '' folder contain two folders ` ` file '' ` ` <unknown> '' thus ` ` file '' folder lie directly ` ` c '' disk contain 4 subfolders","['data structures', 'implementation']",1800.0
660/C,give array a n elements element a either 0 1 . let 's denote length longest subsegment consecutive elements a consist number one f ( a ) change k zero ones maximize f ( a ) first line contain two integers n k ( 1 ≤ n ≤ 3·105 0 ≤ k ≤ n ) — number elements a parameter k. second line contain n integers ai ( 0 ≤ ai ≤ 1 ) — elements a. first line print a non - negative integer z — maximal value f ( a ) k change zero ones second line print n integers aj — elements array a change multiple answer print one,['dp'],1600.0
67/A,a teacher decide give toffees students ask n students stand a queue since teacher partial follow follow rule distribute toffees look first two students give toffees student higher mark one mark get number toffees procedure follow pair adjacent students start first one last one give student receive least one <unknown> find number toffees give student teacher total number toffees minimum first line input contain number students n ( 2 ≤ n ≤ 1000 ) second line give ( n - 1 ) character consist ` ` l '' ` ` r '' ` ` = '' pair adjacent students ` ` l '' mean leave student higher mark ` ` r '' mean right student higher mark ` ` = '' mean equal mark output consist n integers separate a space represent number toffees student receive queue start first one last one,"['dp', 'greedy', 'implementation']",1800.0
673/B,"n problems prepare next codeforces round arrange ascend order difficulty two problems difficulty moreover m pair similar problems author want split problems two division accord follow rule : goal count number ways split problem two divisions satisfy rule two ways split problems consider different least one problem belong division 1 one division 2 note relation similarity transitive , problem i similar problem j problem j similar problem k n't follow i similar k. first line input contain two integers n m ( 2 ≤ n ≤ 100 000 0 ≤ m ≤ 100 000 ) — number problems prepare round number pair similar problems respectively follow m line contain a pair similar problems ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) 's guarantee pair problems meet twice input print one integer — number ways split problems two divisions first sample problems 1 2 use division 2 problems 4 5 division 1 . problem 3 may use either division 1 division 2 . second sample pair problems similar way split problem two divisions without break rule third sample remind similarity relation transitive problem 3 similar 1 2 1 similar 2 may use together","['greedy', 'implementation']",1300.0
675/B,vasya work a watchman gallery unfortunately one expensive paint steal duty n't want fire quickly restore paint remember facts help vasya find number distinct square satisfy condition note number may equal 0 mean vasya remember something wrong two square consider different exist a cell contain two different integers different square first line input contain five integers n a b c d ( 1 ≤ n ≤ 100 000 1 ≤ a b c d ≤ n ) — maximum possible value integer cell four integers vasya remember print one integer — number distinct valid square possible paint first sample second sample paint display satisfy rule,['math'],1400.0
675/C,"n bank city vasya live locate a circle two bank neighbour indices differ 1 . also bank 1 bank n neighbour n > 1 . bank a neighbour vasya account bank balance may negative mean vasya owe money bank one type operations available : transfer amount money bank account neighbour bank restrictions size sum transfer balance requirements perform operation vasya n't like deal large number ask determine minimum number operations require change balance bank account zero 's guarantee possible achieve , total balance vasya bank equal zero first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number bank second line contain n integers ai ( - 109 ≤ ai ≤ 109 ) i - th equal initial balance account i - th bank 's guarantee sum ai equal 0 . print minimum number operations require change balance bank zero first sample vasya may transfer 5 first bank third second sample vasya may first transfer 1 third bank second 1 second first third sample follow sequence provide optimal answer :","['data structures', 'greedy']",2100.0
675/E,vasya commute train every day n train station city i - th station 's possible buy ticket station i + 1 ai inclusive ticket sell last station let ρi j minimum number ticket one need buy order get station i station j. vasya fond different useless statistic ask compute sum value ρi j among pair 1 ≤ i < j ≤ n. first line input contain a single integer n ( 2 ≤ n ≤ 100 000 ) — number station second line contain n - 1 integer ai ( i + 1 ≤ ai ≤ n ) i - th mean i - th station one may buy ticket station i + 1 ai inclusive print sum ρi j among pair 1 ≤ i < j ≤ n. first sample 's possible get station ( greater index ) use one ticket total number pair 6 answer also 6 . consider second sample : thus answer equal 1 + 2 + 3 + 3 + 1 + 2 + 2 + 1 + 1 + 1 = 17,"['data structures', 'dp', 'greedy']",2300.0
679/B,"limak a little polar bear play build tower block every block a cube positive integer length side limak infinitely many block side length a block side a volume a3 a tower consist block side a1 a2 ... ak total volume <unknown> + <unknown> + ... + <unknown> limak go build a tower first ask tell a positive integer x — require total volume tower , limak add new block greedily one one time add biggest block total volume n't exceed x. limak ask choose x greater m. also want maximize number block tower end ( however still behave greedily ) secondarily want maximize x. help limak ? find maximum number block tower maximum x ≤ m result number block line input contain one integer m ( 1 ≤ m ≤ 1015 ) mean limak want choose x 1 m inclusive print two integers — maximum number block tower maximum require total volume x result maximum number block first sample test 9 block choose x = 23 x = 42 . limak want maximize x secondarily choose 42 . detail choose x = 42 process build a tower : 9 block tower total volume 33 + 23 + <unknown> = 27 + 8 + 7 = 42","['dp', 'greedy']",2200.0
68/A,little petya give problem homework : give function ( represent operation take remainder ) task count number integers x range [ a ; b ] property f ( x ) = x. a pity petya forget order remainder take write 4 number 24 possible order take remainder equal probability choose example petya number 1 2 3 4 take remainder order first take remainder modulo 4 modulo 2 3 1 . also 22 permutations number represent order remainder take problem 4 number write petya pairwise distinct impossible petya complete task give teacher fun decide find number integers property probability f ( x ) = x less <unknown> % word petya pick number x exist least 7 permutations number p1 p2 p3 p4 f ( x ) = x. first line input contain 6 integers separate space : p1 p2 p3 p4 a b ( 1 ≤ p1 p2 p3 p4 ≤ 1000 0 ≤ a ≤ b ≤ 31415 ) guarantee number p1 p2 p3 p4 pairwise distinct output number integers give range give property,['implementation'],1100.0
682/D,return forest alyona start read a book notice string s t lengths n m respectively usual read bore alyona decide pay attention string s t consider similar alyona favourite positive integer k small k exceed 10 . girl want choose k disjoint non - empty substrings string s string appear disjoint substrings string t order string s. also interest length maximum possible among variants formally alyona want find a sequence k non - empty string p1 p2 p3 ... pk satisfy follow condition : please help alyona solve complicate problem find least sum lengths string a desire sequence a substring a string a subsequence consecutive character string first line input three integers n m k ( 1 ≤ n m ≤ 1000 1 ≤ k ≤ 10 ) give — length string s length string t alyona 's favourite number respectively second line input contain string s consist lowercase english letter third line input contain string t consist lowercase english letter line print non - negative integer — sum lengths string a desire sequence guarantee least one desire sequence exist follow image describe answer second sample case :,['dp'],1900.0
685/A,robbers attack gerda 's cab successful cover kingdom police make goal catch even harder use watch first know kingdom police bad math robbers use positional numeral system base 7 . second divide one day n hours hour m minutes personal watch robber divide two part : first smallest possible number place necessary display integer 0 n - 1 second smallest possible number place necessary display integer 0 m - 1 . finally value hours minutes display use less number place base 7 watch require number zero add begin notation note display number 0 section watch require least one place little robber want know number moments time ( particular value hours minutes ) digits display watch distinct help calculate number first line input contain two integers give decimal notation n m ( 1 ≤ n m ≤ 109 ) — number hours one day number minutes one hour respectively print one integer decimal notation — number different pair hour minute digits display watch distinct first sample possible pair : ( 0 : 1 ) ( 0 : 2 ) ( 1 : 0 ) ( 1 : 2 ) second sample possible pair : ( 02 : 1 ) ( 03 : 1 ) ( 04 : 1 ) ( <unknown> : 1 ) ( <unknown> : 1 ),"['dp', 'math']",1700.0
685/C,river bring gerda house old lady know magic lady decide make gerda daughter want gerda forget kay put roses garden underground mole live garden watch roses without go surface typical mole blind mole grant special vision old lady watch underground object distance even obstacles object however quality picture depend manhattan distance object observe mole want find optimal point watch roses point integer coordinate maximum manhattan distance rise minimum possible usual ask help manhattan distance point ( x1 y1 z1 ) ( x2 y2 z2 ) define |x1 - x2| + |y1 - y2| + <unknown> - <unknown> first line input contain integer t t ( 1 ≤ t ≤ 100 000 ) — number test case follow exactly t block contain description exactly one test first line block contain integer ni ( 1 ≤ ni ≤ 100 000 ) — number roses test follow ni line contain three integers — coordinate correspond rise note two roses may share position 's guarantee sum ni n't exceed 100 000 coordinate greater 1018 absolute value t test case print three integers — coordinate optimal point watch roses many optimal answer print coordinate optimal point may coincide coordinate rise first sample maximum manhattan distance point rise equal 4 . second sample maximum possible distance 0 . note position roses may coincide position optimal point,['math'],2900.0
687/B,today pari arya play a game call remainder pari choose two positive integer x k tell arya k x. arya find value n ancient number c1 c2 ... cn pari tell arya arya want give k ancient value tell us arya a win strategy independent value x formally true arya understand value positive integer x ? note mean remainder x divide y. first line input contain two integers n k ( 1 ≤ n k ≤ 1 000 000 ) — number ancient integers value k choose pari second line contain n integers c1 c2 ... cn ( 1 ≤ ci ≤ 1 000 000 ) print ` ` yes '' ( without quote ) arya a win strategy independent value x ` ` '' ( without quote ) otherwise first sample arya understand 5 one ancient number second sample arya ca n't sure example 1 7 remainder divide 2 3 differ remainder divide 7,['math'],1800.0
687/D,long time ago a great kingdom rule great arya pari great two problems number like decide divide great kingdom great kingdom consist n cities number 1 n m bidirectional roads cities number 1 m. i - th road length equal wi great arya pari great discuss <unknown> prefix ( road number less x ) suffix ( roads number greater x ) roads remain roads number l l + 1 ... r - 1 r. divide great kingdom two piece ( city belong exactly one piece ) hardness division minimize hardness a division maximum length a road endpoints piece kingdom case road hardness division consider equal - 1 . historians find map great kingdom q guess l r choose great <unknown> give data guess li ri print minimum possible hardness division kingdom first line input contain three integers n m q ( 1 ≤ n q ≤ 1000 ) — number cities roads great kingdom number guess respectively i - th line follow m line contain three integers ui vi wi ( 1 ≤ ui vi ≤ n 0 ≤ wi ≤ 109 ) denote road number i connect cities ui vi length equal wi 's guarantee road connect city pair cities connect one road next q line contain a pair integers li ri ( 1 ≤ li ≤ ri ≤ m ) — a guess historians remain roads kingdom guess print minimum possible hardness division describe scenario,['data structures'],2500.0
690/B3,"zombies find zombie contamination level checker manage damage ! detect shape main compound a real challenge heidi , a lair represent a strictly convex polygon a lattice vertex polygon occupy a point lattice however damage zombie contamination level checker tell cell whether level zombie contamination cell set { 1 2 3 } word heidi know cells lattice contamination level 0 4 . give information heidi still want know exact shape lair rain destruction zombies help ! input contain multiple test case first line test case contain two space - separated integers n m n size lattice grid ( 5 ≤ n ≤ 100000 ) m number lattice point zombie contamination level 1 2 3 ( 8 ≤ m ≤ 200000 ) second line test case contain m pair integers x1 y1 ... xm ym – coordinate cells zombie contamination level equal 0 4 . guarantee 1 ≤ xi yi ≤ n. pair xi yi different cells enumerate base coordinate upper right corner mean bottommost leftmost cell touch origin coordinate ( 1 1 ) uppermost leftmost cell identify ( 1 n ) last line file contain two zero line treat a test case sum m value test one file exceed 200000 . test case follow output expect : first line output contain one integer v number vertices polygon secret lair next v line contain two integers denote vertices polygon clockwise order start lexicographically smallest vertex guarantee solution always exist unique guarantee correct solution coordinate polygon vertices 1 n - 1 . a vertex ( x1 y1 ) lexicographically smaller vertex ( x2 y2 ) x1 < x2",['data structures'],2600.0
696/A,barney live nyc nyc infinite number intersections number positive integers start 1 . exist a bidirectional road intersections i 2i another road i 2i + 1 every positive integer i. clearly see exist a unique shortest path two intersections initially anyone pass road free since <unknown> ahead us q consecutive events happen soon two type <unknown> . government make a new rule a rule denote integers v u w. result action pass fee roads shortest path u v increase w dollars 2 . barney start move intersection v go intersection u 's a girl want cuddle ( use fake name <unknown> <unknown> <unknown> ) always use shortest path ( visit minimum number intersections roads ) two intersections government need calculations time barney go cuddle a girl need tell government much money pay ( sum pass fee roads pass ) first line input contain a single integer q ( 1 ≤ q ≤ 1 000 ) next q line contain information events chronological order event describe form 1 v u w 's event government make a new rule increase pass fee roads shortest path u v w dollars form 2 v u 's event <unknown> go cuddle intersection v intersection <unknown> ≤ v u ≤ 1018 v ≠ u 1 ≤ w ≤ 109 state every description line event second type print sum pass fee roads barney pass event one line print answer chronological order correspond events example testcase : intersections use :,"['data structures', 'implementation']",1500.0
696/B,barney live country usc ( unite state <unknown> ) usc n cities number 1 n n - 1 roads cities roads usc form a root tree ( barney 's sure root ) root tree city number 1 . thus one start journey city 1 visit city want follow roads girl steal barney 's heart barney want find start look root tree ( since barney <unknown> a random guy ) use a random dfs search cities a pseudo code algorithm follow : tell barney start journey root tree ( equivalent call dfs ( 1 ) ) barney need pack a backpack want know upcoming journey : every city i barney want know expect value starting_time [ i ] 's a friend jon snow know nothing 's ask help first line input contain a single integer n ( 1 ≤ n ≤ 105 ) — number cities usc second line contain n - 1 integers p2 p3 ... pn ( 1 ≤ pi < i ) pi number parent city city number i tree mean a road cities number pi i usc first line output print n number i - th number expect value starting_time [ i ] answer city consider correct absolute relative error exceed 10 - 6,['math'],1700.0
698/C,"create high load systems one pay a special attention cache problem one popular cache algorithms call <unknown> ( least recently use ) suppose cache may store k object begin workflow cache empty object query check present cache move 's k object cache least recently use one remove word remove object smallest time last query consider n videos store server size cache store k videos cache algorithm describe apply know time a user enter server pick video i probability pi choice video independent events goal problem count videos probability present cache 10100 query first line input contain two integers n k ( 1 ≤ k ≤ n ≤ 20 ) — number videos size cache respectively next line contain n real number pi ( 0 ≤ pi ≤ 1 ) give two digits decimal point 's guarantee sum pi equal 1 . print n real number i - th equal probability i - th video present cache 10100 query answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer a answer jury b. checker program consider answer correct ,","['dp', 'math']",2400.0
702/E,give a functional graph a direct graph vertex go exactly one arc vertices numerate 0 n - 1 . graph give array f0 f1 ... fn - 1 fi — number vertex go arc vertex i. besides give array weight arc w0 w1 ... wn - 1 wi — arc weight i fi also give integer k ( length path ) need find vertex two number si mi : length path number arc path first line contain two integers n k ( 1 ≤ n ≤ 105 1 ≤ k ≤ 1010 ) second line contain sequence f0 f1 ... fn - 1 ( 0 ≤ fi < n ) third — sequence w0 w1 ... wn - 1 ( 0 ≤ wi ≤ 108 ) print n line pair integers si mi line,['data structures'],2100.0
702/F,big <unknown> t - shirts go sale shop begin spring n type t - shirts go sale t - shirt i - th type two integer parameters — ci qi ci — price i - th type t - shirt qi — quality i - th type t - shirt assume unlimited number t - shirts type go sale shop general quality concern price predict k customers come shop within next month j - th customer get ready spend bj buy t - shirts customers strategy first customer want buy maximum possible number highest quality t - shirts buy maximum possible number highest quality t - shirts <unknown> t - shirts time among several quality t - shirts customer buy one cheaper customers n't like t - shirts customer buy one t - shirt one type determine number t - shirts customer buy use describe strategy customers act independently purchase one affect purchase another first line contain positive integer n ( 1 ≤ n ≤ 2·105 ) — number t - shirt type follow n line contain two integers ci qi ( 1 ≤ ci qi ≤ 109 ) — price quality i - th type t - shirt next line contain positive integer k ( 1 ≤ k ≤ 2·105 ) — number customers next line contain k positive integers b1 b2 ... bk ( 1 ≤ bj ≤ 109 ) j - th number equal sum j - th customer get ready spend t - shirts first line input data contain sequence k integers i - th number equal number t - shirts i - th customer buy first example first customer buy t - shirt second type t - shirt first type spend 10 able buy t - shirt third type cost 4 customer owe 3 . second customer buy three t - shirts ( first t - shirt second type t - shirt first type t - shirt third type ) spend money,['data structures'],2800.0
704/A,thor get use earth a gift loki give a smartphone n applications phone thor fascinate phone one minor issue : ca n't count number unread notifications generate applications ( maybe loki put a curse ca n't ) <unknown> events happen ( chronological order ) three type : please help thor tell number unread notifications event may assume initially notifications phone first line input contain two integers n q ( 1 ≤ n q ≤ 300 000 ) — number applications number events happen next q line contain events i - th line start integer typei — type i - th event typei = 1 typei = 2 follow integer xi otherwise follow integer ti ( 1 ≤ typei ≤ 3 1 ≤ xi ≤ n 1 ≤ ti ≤ q ) print number unread notifications event first sample : second sample test :,"['data structures', 'implementation']",1600.0
704/B,scott <unknown> war <unknown> cross n chair a hall number 1 2 ... n leave right i - th chair locate coordinate xi scott chair number s cross chair number e. scott jump chair ( neighbor chair ) want start position ( chair number s ) visit chair exactly end chair number e cross know scott shrink grow big ( grow big normal size ) moment time either small large ( normal ) thing shrink grow big a chair ( air jump another chair ) jump take time shrink grow big take time jump chair number i chair number j take |xi - xj| second also jump a chair land a chair take extra amount time scott want jump a chair leave small want jump a chair right large jump i - th chair take : also land i - th chair take : simpler word jump i - th chair j - th chair take exactly : give value x a b c d find minimum time scott get cross assume want visit chair exactly first line input contain three integers n s e ( 2 ≤ n ≤ 5000 1 ≤ s e ≤ n s ≠ e ) — total number chair start end position scott second line contain n integers x1 x2 ... xn ( 1 ≤ x1 < x2 < ... < xn ≤ 109 ) third line contain n integers a1 a2 ... ( 1 ≤ a1 a2 ... ≤ 109 ) fourth line contain n integers b1 b2 ... bn ( 1 ≤ b1 b2 ... bn ≤ 109 ) fifth line contain n integers c1 c2 ... cn ( 1 ≤ c1 c2 ... cn ≤ 109 ) sixth line contain n integers d1 d2 ... dn ( 1 ≤ d1 d2 ... dn ≤ 109 ) print minimum amount time scott need get cross visit chair exactly sample testcase optimal solution would spend time would 17 + 24 + 23 + 20 + 33 + 22 = <unknown>,"['dp', 'greedy']",2500.0
71/B,a progress bar element graphical interface display progress a process moment complete let 's take a look follow form a bar a bar represent n square locate line add clarity let 's number positive integers 1 n leave right square saturation ( ai i - th square ) measure integer 0 k. bar i ( 1 ≤ i ≤ n ) display square 1 2 ... i - 1 saturation k square i + 1 i + 2 ... n saturation 0 saturation square i value 0 k. first square progress bar always saturation k. last square always saturation 0 . one square saturation different 0 k. degree process 's completion measure percents let process t % complete follow inequation fulfil : example a bar see picture give n k t determine measure saturation square ai progress bar give 3 space - separated integers n k t ( 1 ≤ n k ≤ 100 0 ≤ t ≤ 100 ) print n number i - th equal ai,"['implementation', 'math']",1300.0
710/C,find n × n matrix different number 1 n2 sum row column main diagonals odd line contain odd integer n ( 1 ≤ n ≤ 49 ) print n line n integers integers different 1 n2 sum row column main diagonals odd,['math'],1500.0
710/D,give two arithmetic progressions : a1k + b1 a2l + b2 find number integers x l ≤ x ≤ r x = a1k ' + b1 = a2l ' + b2 integers k ' l ' ≥ 0 . line contain six integers a1 b1 a2 b2 l r ( 0 < a1 a2 ≤ 2·109 - 2·109 ≤ b1 b2 l r ≤ 2·109 l ≤ r ) print desire number integers x,['math'],2500.0
711/C,zs coder chris baboon arrive udayland ! walk park n tree grow decide naughty color tree park tree number integers 1 n leave right initially tree i color ci zs coder chris baboon recognize m different color 0 ≤ ci ≤ m ci = 0 mean tree i uncolored zs coder chris baboon decide color uncolored tree i.e tree ci = 0 . color m color 1 m. color i - th tree color j require exactly pi j litres paint two friends define beauty a color tree minimum number contiguous group ( group contain subsegment tree ) split n tree group contain tree color example color tree leave right 2 1 1 1 3 2 2 3 1 3 beauty color 7 since partition tree 7 contiguous group color : { 2 } { 1 1 1 } { 3 } { 2 2 } { 3 } { 1 } { 3 } zs coder chris baboon want color uncolored tree beauty color exactly k. need help determine minimum amount paint ( litres ) need finish job please note friends ca n't color tree already color first line contain three integers n m k ( 1 ≤ k ≤ n ≤ 100 1 ≤ m ≤ 100 ) — number tree number color beauty result color respectively second line contain n integers c1 c2 ... cn ( 0 ≤ ci ≤ m ) initial color tree ci equal 0 tree number i uncolored otherwise i - th tree color ci n line follow contain m integers j - th number i - th line denote pi j ( 1 ≤ pi j ≤ 109 ) — amount litres friends need color i - th tree color j. pi j 's specify even initially color tree tree still ca n't color print a single integer minimum amount paint need color tree valid tree color beauty k print - 1 . first sample case color tree color 2 1 1 minimize amount paint use equal 2 + 3 + 5 = 10 . note 1 1 1 would valid beauty color equal 1 ( { 1 1 1 } a way group tree a single group color ) second sample case tree color beauty color 3 valid color answer - 1 . last sample case tree color beauty color match k paint use answer 0,['dp'],1700.0
717/F,"i ’ m stroll <unknown> yeah - ah ! ’ t feel good ! well certainly feel good heroes make magic <unknown> walk a one - directional road fight imps imps weak <unknown> creatures good much however heroes enjoy fight fun nothing else hero ignatius simply adore imps observe a line imps represent a zero - indexed array integers a length n ai denote number imps i - th position sometimes imps appear nowhere heroes fight imps select a segment line start one end segment finish end without ever exit segment move exactly one cell leave right current position defeat one imp cell move , number imps cell decrease one also apply heroes appear one end segment begin walk goal defeat imps segment without ever move empty cell ( without imps ) since would get bore since ignatius love imps ’ t really want fight imps harm events task however would like tell whether would possible clear a certain segment imps mention way want give q query two type : first line contain a single integer n ( 1 ≤ n ≤ 200 000 ) length array a. follow line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 5 000 ) initial number imps cell third line contain a single integer q ( 1 ≤ q ≤ 300 000 ) number query remain q line contain one query query provide integers a b possibly k ( 0 ≤ a ≤ b < n 0 ≤ k ≤ 5 000 ) second type query output 1 possible clear segment 0 first query one easily check indeed impossible get first last cell clear everything add 1 second position clear segment example move follow way :",['data structures'],2600.0
717/H,welcome world pokermon yellow little mouse - like creatures absolutely love play poker ! yeah right … <unknown> pokermon league n register pokermon trainers t exist trainer team belong one two conferences since a lot <unknown> trainers e pair trainers hate hate mutual identical pair among trainer hat ( world pokermon a joyful place ! ) trainer a wish - list length li team ’ d like join task divide players team team two conferences : total hate conferences calculate number pair trainers team different conferences hate first line input contain two integer n ( 4 ≤ n ≤ 50 000 ) e ( 2 ≤ e ≤ 100 000 ) — total number pokermon trainers number pair trainers hate pokermon trainers number 1 n. next e line contain two integers a b ( 1 ≤ a b ≤ n ) indicate pokermon trainers a b hate next 2n line a follow format start pokermon trainer 1 trainer consecutive order : first number li ( 16 ≤ li ≤ 20 ) — a size pokermon trainers wish list li positive integers ti j ( 1 ≤ ti j ≤ t ) provide team i - th trainer would like trainers wish list contain team team wish list number a way set team appear least 1 wish list set consecutive positive integers { 1 2 3 … t } t might 1 000 000 . print two line first line contain n number specify trainer team second line contain t number specify conference team ( 1 2 ),['math'],2400.0
72/A,"goshtasp know a good programmer school one day vishtasp goshtasp 's friend ask solve task : give a positive integer n determine whether n rich positive integer x rich exist set distinct number a1 a2 ... , addition : every ai either a prime number equal 1 . vishtasp say would share eidi 50 / 50 goshtasp could solve task eidi money give children <unknown> parent and/or relatives goshtasp need solve problem get money need solve get score ! input contain a single positive integer n ( 1 ≤ n ≤ 10000 ) number rich print 0 . otherwise print number a1 ... , several solutions exist print lexicographically latest solution answer compare sequence number string compare two sequence a1 ... b1 ... bn first find first index i ai ≠ bi ai < bi a lexicographically earlier bi < ai b lexicographically earlier m ≠ n add zero end smaller sequence ( moment comparison ) perform comparison need minimize number elements sequence ( i.e m ) need print lexicographically latest solution see sample find print sequence","['greedy', 'math']",1800.0
72/F,"<unknown> oil industry dr . mosaddegh want dig oil well extract oil persian gulf persian gulf huge infinite amount oil dr . mosaddegh work a rectangular plane size n × m persian gulf cells rectangle either contain infinite amount oil nothing two cells consider adjacent a common edge a path a sequence c1 c2 ... cx cells contain oil i ci adjacent ci - 1 ci + 1 ( exist ) two cells consider connect exist a path dig a well a certain cell extract oil cells connect oil paths allow dig well empty cells dr . mosaddegh also know persian gulf empty cells form row columns i. e. cell empty 's column completely empty 's row completely empty , help dr . mosaddegh find many well dig access oil region first line two positive integers n m ( 1 ≤ n m ≤ 100 ) second line integer t ( 0 ≤ t ≤ n ) number empty row t distinct positive integers follow number empty row range [ 1 n ] second line integer s ( 0 ≤ s ≤ m ) show number columns oil s distinct positive integers follow number empty columns range [ 1 m ] note row number 1 n ( top bottom ) columns number 1 m ( leave right ) a single integer minimum number well dr . <unknown> dig actually find many regions make remove give row columns","['greedy', 'math']",1900.0
720/A,close ceremony <unknown> code cup hold big hall n × m seat arrange n row m seat a row seat two coordinate ( x y ) ( 1 ≤ x ≤ n 1 ≤ y ≤ m ) two queue people wait enter hall : k people stand ( 0 0 ) n·m - k people stand ( 0 m + 1 ) person a ticket a specific seat person p ( x y ) ticket seat ( xp yp ) walk |x - <unknown> + |y - <unknown> get seat person a stamina — maximum distance person agree walk find possible distribute n·m ticket a way person enough stamina get seat first line input contain two integers n m ( 1 ≤ n·m ≤ 104 ) — size hall second line contain several integers first integer k ( 0 ≤ k ≤ n·m ) — number people ( 0 0 ) follow k integers indicate stamina person third line also contain several integers first integer l ( l = n·m - k ) — number people ( 0 m + 1 ) follow l integers indicate stamina person stamina person a positive integer less equal n + m. possible distribute ticket people describe manner print ` ` yes '' otherwise print ` ` '',['greedy'],2000.0
720/D,little girl masha like winter sport today 's plan take part <unknown> ski track represent a grid compose n × m square rectangular obstacles track compose grid square masha must get square ( 1 1 ) square ( n m ) move a square adjacent square : either right upwards square occupy obstacle allow move square one see obstacle actually pass two ways : either right masha 's path leave masha like try ways things would like know many ways pass track two ways consider different obstacle right path one way leave path way help masha find number ways pass track number ways quite big masha would like know modulo 109 + 7 . picture show different ways pass track sample test first line input data contain three positive integers : n m k ( 3 ≤ n m ≤ 106 0 ≤ k ≤ 105 ) — size track number obstacles follow k line contain four positive integers : x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ m ) — coordinate bottom leave top right square obstacle guarantee obstacles square ( 1 1 ) ( n m ) obstacles overlap ( may touch ) output one integer — number ways pass track modulo 109 + 7,"['data structures', 'dp']",3100.0
720/E,borya recently find a big electronic display computer manage display store integer number number n decimal digits display show encode version number digit show use lowercase letter english alphabet a legend near display describe number encode digit position i digit j character c know encode digit position different digits code character second number increase 1 . one second a moment number reach value represent n 9 - s decimal notation <unknown> <unknown> sound andrew know number store computer want know many second must pass borya definitely tell original number encode display assume borya precisely measure time encode number first increase exactly one second borya start watch display input data contain multiple test case first line input contain t ( 1 ≤ t ≤ 100 ) — number test case test case describe follow first line description contain n ( 1 ≤ n ≤ 18 ) — number digits number second line contain n decimal digits without space ( possibly lead zero ) — number initially store display computer follow n line contain 10 character j - th character i - th line code character a digit j - 1 position i significant digit position describe first test case print integer : number second borya definitely know initial number store display computer print lead zero,['implementation'],3100.0
721/B,"vanya manage enter favourite site codehorses vanya use n distinct passwords sit however ca n't remember one exactly specify codehorses registration vanya enter passwords order non - decreasing lengths enter passwords length arbitrary order vanya enter correct password immediately authorize site vanya enter password twice enter passwords take one second vanya vanya enter wrong password k time able make next try 5 second vanya make try immediately , moment vanya able enter password , determine many second vanya need enter codehorses best case ( spend minimum possible number second ) worst case ( spend maximum possible amount second ) first line input contain two integers n k ( 1 ≤ n k ≤ 100 ) — number vanya 's passwords number fail try access site block 5 second next n line contain passwords one per line — pairwise distinct non - empty string consist latin letter digits password length exceed 100 character last line input contain vanya 's codehorses password guarantee vanya 's codehorses password equal n passwords print two integers — time ( second ) vanya need authorize codehorses best case worst case respectively consider first sample case soon passwords length vanya enter right password first try well last try enter first try spend exactly 1 second thus best case answer 1 . hand enter last try enter another 4 passwords spend 2 second enter first 2 passwords wait 5 second soon make 2 wrong try spend 2 second enter 2 wrong passwords wait 5 second finally enter correct password spend 1 second summary worst case able authorize 15 second consider second sample case way enter passwords get access site block soon require password length 2 vanya enter passwords length 1 anyway spend 2 second , best case immediately enter correct password answer best case 3 worst case enter wrong password length 2 right one spend 4 second","['implementation', 'math']",1100.0
723/C,"polycarp a music editor radio station receive a playlist tomorrow represent a sequence a1 a2 ... , ai a band perform i - th song polycarp like band number 1 m n't really like others define bj number songs group j go perform tomorrow polycarp want change playlist a way minimum among number b1 b2 ... bm large possible find maximum possible value minimum among bj ( 1 ≤ j ≤ m ) minimum number change playlist polycarp need make achieve one change playlist a replacement performer i - th song group first line input contain two integers n m ( 1 ≤ m ≤ n ≤ 2000 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) ai performer i - th song first line print two integers : maximum possible value minimum among bj ( 1 ≤ j ≤ m ) bj number songs change playlist perform j - th band minimum number change playlist polycarp need make second line print change playlist multiple answer print first sample polycarp 's change first band perform two songs ( b1 = 2 ) second band also perform two songs ( b2 = 2 ) thus minimum value equal 2 . impossible achieve a higher minimum value change playlist second sample polycarp 's change first band perform two songs ( b1 = 2 ) second band perform three songs ( b2 = 3 ) third band also perform two songs ( b3 = 2 ) thus best minimum value 2",['greedy'],1600.0
724/B,give a table consist n row m columns number row form a permutation integers 1 m. allow pick two elements one row swap row also allow pick two columns swap thus allow perform 0 n + 1 action total operations perform order check whether 's possible obtain identity permutation 1 2 ... m row word check one perform operation follow give rule make row sort increase order first line input contain two integers n m ( 1 ≤ n m ≤ 20 ) — number row number columns give table next n line contain m integers — elements table 's guarantee number line form a permutation integers 1 m. a way obtain identity permutation row follow give rule print ` ` yes '' ( without quote ) line output otherwise print ` ` '' ( without quote ) first sample one act follow way :,"['greedy', 'implementation', 'math']",1500.0
725/E,alfred want buy a toy moose cost c dollars store ’ t give change must give store exactly c dollars less n coin make c dollars coin follow follow algorithm : let s set coin use s initially empty alfred repeatedly add s highest - valued coin total value coin s add coin ’ t exceed c. coin value coin s still less c give go home note alfred never remove a coin s add a programmer might aware alfred ’ s algorithm fail even a set coin value exactly c. example alfred one coin worth $ 3 one coin worth $ 4 two coin worth $ 5 moose cost $ 12 alfred add $ 5 coin s give since add coin would cause value coin s exceed $ 12 course alfred could instead combine one $ 3 coin one $ 4 coin one $ 5 coin reach total bob try convince alfred algorithm flaw alfred ’ t believe bob want give alfred coin ( addition alfred already ) alfred ’ s algorithm fail bob give alfred number coin denomination ( subject constraint coin must worth a positive integer number dollars ) multiple coin a single denomination would like minimize total value coin give alfred please find minimum value solution print ` ` greed good '' assume answer exist positive word alfred 's algorithm work bob n't give coin first line contain c ( 1 ≤ c ≤ 200 000 ) — price alfred want pay second line contain n ( 1 ≤ n ≤ 200 000 ) — number coin alfred initially n line follow contain a single integer x ( 1 ≤ x ≤ c ) represent value one alfred 's coin a solution print minimum possible total value coin a solution otherwise print ` ` greed good '' ( without quote ) first sample bob give alfred a single coin worth $ 5 create situation describe problem statement second sample set coin cause alfred 's algorithm fail,['greedy'],2600.0
73/B,vasya play need <unknown> play present a new computer wheel birthday ! sure win first place championship favourite race computer game ! n racers take part championship consist a number race race racers arrange place first n - th ( two racers share place ) first m place award racer gain bi point i - th award place add total point obtain previous race know current summary score racer i ai point final stand championship racers sort descend order point racers equal amount point sort increase name lexicographical order unfortunately championship come end one race leave vasya decide find highest lowest place take a result championship first line contain number n ( 1 ≤ n ≤ 105 ) — number racers next n line contain si ai — nick racer ( nonempty string consist 20 lowercase latin letter ) racer 's point ( 0 ≤ ai ≤ 106 ) racers give arbitrary order next line contain number m ( 0 ≤ m ≤ n ) m nonnegative integer number bi follow i - th number equal amount point i - th award place ( 0 ≤ bi ≤ 106 ) last line contain vasya 's racer nick output two number — highest lowest place vasya take a result championship,['greedy'],2000.0
730/H,polycarp a beginner programmer study use a command line polycarp face follow problem n file a directory need delete polycarp want run a single delete command filename pattern argument file delete match pattern file n't match pattern polycarp n't know asterisk ' * ' special character know a question mark ' ? ' match single character character pattern match formally a pattern match a filename equal lengths character correspond position equal except character pattern ' ? ' case correspond filename character matter example filename pattern ` ` a ? ba ? ` ` : help polycarp find a pattern match file delete report pattern first line input contain two integers n m ( 1 ≤ m ≤ n ≤ 100 ) — total number file number file delete follow n line contain filenames single filename per line filenames non - empty string contain lowercase english letter digits dot ( ' . ' ) length filename n't exceed 100 . guarantee filenames distinct last line input contain m distinct integer number ascend order a1 a2 ... ( 1 ≤ ai ≤ n ) — indices file delete file index 1 n order appearance input require pattern exist print ` ` yes '' first line output second line contain require pattern multiple solutions print require pattern n't exist print line contain ` ` '',['implementation'],1300.0
730/J,"nick n bottle soda leave birthday bottle describe two value : remain amount soda ai bottle volume bi ( ai ≤ bi ) nick decide pour remain soda minimal number bottle moreover soon possible nick spend x second pour x units soda one bottle another nick ask help determine k — minimal number bottle store remain soda t — minimal time pour soda k bottle a bottle ca n't store soda volume remain soda save first line contain positive integer n ( 1 ≤ n ≤ 100 ) — number bottle second line contain n positive integers a1 a2 ... ( 1 ≤ ai ≤ 100 ) ai amount soda remain i - th bottle third line contain n positive integers b1 b2 ... bn ( 1 ≤ bi ≤ 100 ) bi volume i - th bottle guarantee ai ≤ bi i. line contain two integers k t k minimal number bottle store soda t minimal time pour soda k bottle first example nick pour soda first bottle second bottle take 3 second second bottle contain 3 + 3 = 6 units soda pour soda fourth bottle second bottle third bottle : one unit second two units third take 1 + 2 = 3 second , soda two bottle spend 3 + 3 = 6 second",['dp'],1900.0
730/L,a simplify arithmetic expression ( sae ) arithmetic expression define follow grammar : word 's a correct arithmetic expression allow contain bracket number ( possibly lead zero ) multiplications additions example expressions ` ` ( 0 + 01 ) '' ` ` 0 '' ` ` 1 * ( 0 ) '' simplify arithmetic expressions expressions ` ` 2 - 1 '' ` ` +1 '' ` ` 1 + 2 ) '' give a string s1s2 ... s|s| represent a sae ; si denote i - th character string either a digit ( ' 0'- ' 9 ' ) a plus sign ( ' + ' ) a multiplication sign ( ' * ' ) open round bracket ' ( ' a close round bracket ' ) ' a part slsl + 1 ... sr string call a sub - expression a sae task answer m query a pair integers li ri ( 1 ≤ li ≤ ri ≤ |s| ) query determine whether correspond part give string a sub - expression case 's a sub - expression calculate value modulo 1000000007 ( 109 + 7 ) value calculate use standard operator priorities first line input contain non - empty string s ( 1 ≤ |s| ≤ 4·105 ) represent a correct sae character string one follow character : ' * ' ' + ' ' ( ' ' ) ' a digit ( ' 0'- ' 9 ' ) expression might contain extra - huge number second line contain integer m ( 1 ≤ m ≤ 4·105 ) number query next m line contain two space - separated integers li ri ( 1 ≤ li ≤ ri ≤ |s| ) — i - th query i - th number output answer i - th query i - th query correspond a valid sub - expression output value sub - expression modulo 1000000007 ( 109 + 7 ) otherwise output -1 answer query print number separate line,['data structures'],3200.0
733/C,epidemic <unknown> monsters become sick recover monsters line queue appointment doctor city soon monsters become hungry begin eat one monster eat monster weight strictly greater weight monster eat stand queue next monsters eat instantly monsters eat moment monster a eat monster b weight monster a increase weight eat monster b. result eat length queue decrease one monsters eat one step forward empty place queue a monster eat several monsters one another initially n monsters queue i - th weight ai example weight [ 1 2 2 2 1 2 ] ( order queue monsters number 1 6 leave right ) options : time someone say a good joke monsters recover moment k ( k ≤ n ) monsters queue j - th weight bj sequence ( a b ) contain weight monsters order first last require provide one possible order eat monsters lead current queue determine could happen assume doctor n't make <unknown> monsters eat first line contain single integer n ( 1 ≤ n ≤ 500 ) — number monsters initial queue second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 106 ) — initial weight monsters third line contain single integer k ( 1 ≤ k ≤ n ) — number monsters queue joke fourth line contain k integers b1 b2 ... bk ( 1 ≤ bj ≤ 5·108 ) — weight monsters joke monsters list order begin queue end case action could lead final queue print ` ` '' ( without quote ) line otherwise print ` ` yes '' ( without quote ) first line next n - k line print action chronological order line print x — index number monster current queue eat separate space symbol ' l ' monster stay x - th queue eat monster front ' r ' monster stay x - th queue eat monster behind eat queue enumerate one monster eat another queue decrease several answer print first example initially n = 6 monsters weight [ 1 2 2 2 1 2 ] ( order queue first monster last monster ) final queue [ 5 5 ] follow sequence eat lead final queue : note step output contain number monsters current order queue,"['dp', 'greedy']",1800.0
734/A,anton like play chess friend danik play n game a row game 's know winner — anton danik none game end a tie anton wonder game danik ? help determine first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number game play second line contain a string s consist n uppercase english letter ' a ' 'd ' — outcome game i - th character string equal ' a ' anton i - th game 'd ' danik i - th game anton game danik print ` ` anton '' ( without quote ) line output danik game anton print ` ` danik '' ( without quote ) line output anton danik number game print ` ` friendship '' ( without quote ) first sample anton 6 game danik — 1 . hence answer ` ` anton '' second sample anton 3 game danik 4 game answer ` ` danik '' third sample anton danik 3 game answer ` ` friendship '',['implementation'],800.0
735/C,famous <unknown> city rio de janeiro hold a tennis tournament ostap bender n't want miss event n players participate tournament follow knockout rule first game mean someone lose a game leave tournament immediately organizers still arrange tournament grid ( i.e order game happen go play ) already fix one rule : two players play number game one already play differ one number game one already play course players win game order continue participate tournament tournament n't start yet audience a bite bore ostap decide find maximum number game winner tournament take part ( assume rule use ) however <unknown> deal problem without help line input contain a single integer n ( 2 ≤ n ≤ 1018 ) — number players participate tournament print maximum number game winner tournament take part sample consider player number 1 winner first sample would one game answer 1 . second sample player 1 consequently beat players 2 3 . third sample player 1 ca n't play player play players 2 3 ca n't play player 4 0 game play player 1 already play 2 . thus answer 2 achieve make pair ( 1 2 ) ( 3 4 ) <unknown> winners,"['greedy', 'math']",1600.0
737/F,one celebrations a stack dirty plat nikita 's kitchen nikita wash put a dryer dryer plat also place a stack also plat size increase size plat distinct nikita much free space specifically a place one stack plat therefore perform two operations : note perform operations plat put order operation give size plat s1 s2 ... sn order dirty stack integers a b. size distinct write a program determine whether nikita put plat increase order dryer able program find sequence operations ( necessary optimal ) achieve first line contain three integers n a b ( 1 ≤ n ≤ 2000 1 ≤ a b ≤ n ) second line contain integers s1 s2 ... sn ( 1 ≤ si ≤ n ) — size plat order size distinct first line print ` ` yes '' a solution case second line print integer k — number operations k line print operations one per line operation describe two integers tj cj tj = 1 operation wash top cj place dirty stack put onto intermediate stack tj = 2 operation move th top cj plat intermediate stack dryer case solution print single line ` ` '' multiple solutions print note necessary minimize number operations first example initial order plat 2 3 6 4 1 5 . stack look like operations : possible third example permit move one plate time possible wash plat one one place onto <unknown> stack reverse order move plat one one dryer final order correct,['math'],3300.0
739/A,alyona 's mother want present array n non - negative integers alyona array special alyona a capricious girl get array inspect m subarrays subarray a set subsequent elements array i - th subarray describe two integers li ri elements a [ li ] a [ li + 1 ] ... a [ ri ] alyona go find mex choose subarrays among m mexes girl go find smallest want minimum mex large possible find array a n elements minimum mex among choose alyona subarrays large possible mex a set s a minimum possible non - negative integer s. first line contain two integers n m ( 1 ≤ n m ≤ 105 ) next m line contain information subarrays choose alyona i - th line contain two integers li ri ( 1 ≤ li ≤ ri ≤ n ) describe subarray a [ li ] a [ li + 1 ] ... a [ ri ] first line print single integer — maximum possible minimum mex second line print n integers — array a. elements a 0 109 . guarantee optimal answer elements a 0 109 . multiple solutions print first example : mex subarray ( 1 3 ) equal 3 mex subarray ( 2 5 ) equal 3 mex subarray ( 4 5 ) equal 2 well thus <unknown> mex among subarrays choose alyona equal 2,['greedy'],1700.0
741/A,notice lovely girls arpa ’ s land people arpa 's land number 1 n. everyone exactly one crush i - th person 's crush person number crushi someday arpa shout owf loudly top palace a funny game start arpa 's land rule follow game consist round assume person x want start a round call crushx say : ` ` oww ... wwf '' ( letter w repeat t time ) cut phone immediately t > 1 crushx call <unknown> say : ` ` oww ... wwf '' ( letter w repeat t - 1 time ) cut phone immediately round continue person receive ` ` owf '' ( t = 1 ) person call joon - joon round ca n't two round time mehrdad evil plan make game funny want find smallest t ( t ≥ 1 ) person x x start round y become joon - joon round start y x would become joon - joon round find t mehrdad 's possible strange fact arpa 's land someone 's crush ( i.e crushi = i ) first line input contain integer n ( 1 ≤ n ≤ 100 ) — number people arpa 's land second line contain n integers i - th crushi ( 1 ≤ crushi ≤ n ) — number i - th person 's crush t satisfy condition print -1 . otherwise print smallest t. first sample suppose t = 3 . first person start round : first person call second person say ` ` owwwf '' second person call third person say ` ` owwf '' third person call first person say ` ` owf '' first person become joon - joon round condition satisfy x 1 . process similar second third person fourth person start round : fourth person call say ` ` owwwf '' call say ` ` owwf '' call another time say ` ` owf '' fourth person become joon - joon round condition satisfy x 4 . last example first person start a round second person become joon - joon vice versa,['math'],1600.0
742/A,exist island call arpa ’ s land beautiful girls live ugly ones mehrdad want become minister arpa ’ s land arpa prepare exam exam one question give n print last digit 1378n mehrdad become quite confuse want help please help although 's a naive cheat single line input contain one integer n ( 0 ≤ n ≤ 109 ) print single integer — last digit 1378n first example last digit <unknown> = <unknown> 8 . second example last digit <unknown> = <unknown> = <unknown> 4,"['implementation', 'math']",1000.0
747/B,process mammoth 's genome decode berland come end ! one remain task restore unrecognized nucleotides a find chain s. nucleotide cod a capital letter english alphabet : ' a ' ' c ' ' g ' ' t ' unrecognized nucleotides cod a question mark ' ? ' thus s a string consist letter ' a ' ' c ' ' g ' ' t ' character ' ? ' know number nucleotides four type decode genome mammoth berland equal task decode genome replace unrecognized nucleotide one four type number nucleotides four type become equal first line contain integer n ( 4 ≤ n ≤ 255 ) — length genome second line contain string s length n — cod genome consist character ' a ' ' c ' ' g ' ' t ' ' ? ' possible decode genome print multiple answer print possible print three equal sign a row : ` ` = = = '' ( without quote ) first example replace first question mark letter ' a ' second question mark letter ' g ' third question mark letter ' t ' nucleotide genome would present twice second example genome already decode correctly nucleotide exactly third fourth examples impossible decode <unknown>,['implementation'],900.0
748/B,"santa claus decide disassemble keyboard clean return key back suddenly realize pair key take 's place ! , santa suspect key either place place another key locate exactly first key order make sure 's right restore correct order key santa type favorite patter look keyboard give santa 's favorite patter string actually type determine pair key could mix key must occur pair input consist two string s t denote favorite santa 's patter result string s t empty length 1000 . string consist lowercase english letter santa wrong way divide key pair swap key pair keyboard fix print « -1 » ( without quote ) otherwise first line output contain integer k ( k ≥ 0 ) — number pair key swap follow k line contain two space - separated letter denote key swap print letter must distinct several possible answer print free choose order pair order key a pair letter must occur santa consider keyboard fix print favorite patter without mistake",['implementation'],1500.0
749/C,n employees alternative cake manufacture ( acm ) vote important question lead world media try predict outcome vote employees belong one two fraction : depublicans remocrats two fraction opposite opinions outcome vote vote procedure rather complicate : know order employees go vote behave optimal ( also know order belong fraction ) predict outcome vote first line input contain a single integer n ( 1 ≤ n ≤ 200 000 ) — number employees next line contain n character i - th character 'd ' i - th employee depublicans fraction ' r ' remocrats print 'd ' outcome vote suitable depublicans ' r ' remocrats win consider one vote scenarios first sample :,"['greedy', 'implementation']",1500.0
75/D,ahmed mostafa use compete together many program contest several years coach <unknown> ask solve one challenge problem course ahmed able solve mostafa could n't problem similar a standard problem a different format constraints standard problem give array integers find one consecutive elements array sum maximum possible sum problem give n small array create one big array concatenation one instance small array ( small array could occur ) big array give array index ( 1 - based ) small array concatenation do order array apply standard problem mention result big array example let 's suppose small array { 1 6 -2 } { 3 3 } { -5 1 } index big array { 2 3 1 3 } actual value big array format concatenation small array { 3 3 -5 1 1 6 -2 -5 1 } example maximum sum 9 . help mostafa solve problem ? first line contain two integers n m n number small array ( 1 ≤ n ≤ 50 ) m number index big array ( 1 ≤ m ≤ 250000 ) follow n line i - th line start one integer l size i - th array ( 1 ≤ l ≤ 5000 ) follow l integers one greater equal -1000 less equal 1000 . last line contain m integers index big array concatenate small array order index greater equal 1 less equal n. small array number 1 n order give input give small array may use big array note array big try build <unknown> probably get time or / and memory limit exceed print one line contain maximum sum big array format describe must choose least one element sum i. e. empty please use % lld specificator write 64 - bit integers c++ prefer use cout ( also may use % i64d ),"['data structures', 'dp', 'greedy', 'implementation', 'math']",2000.0
750/B,problem assume earth a completely round ball surface a perfect sphere length equator <unknown> consider exactly 40 000 kilometers thus travel north pole south pole vice versa take exactly 20 000 kilometers limak a polar bear live north pole close new year help somebody deliver package around world instead coordinate place visit limak get a description move assume start north pole description consist n part i - th part journey limak move ti kilometers direction represent a string diri one : ` ` north '' ` ` south '' ` ` west '' ` ` east '' limak ’ t sure whether description valid must help check follow condition : check condition satisfy print ` ` yes '' ` ` '' a single line first line input contain a single integer n ( 1 ≤ n ≤ 50 ) i - th next n line contain integer ti a string diri ( 1 ≤ ti ≤ 106 ) — length direction i - th part journey accord description limak get print ` ` yes '' description satisfy three condition otherwise print ` ` '' without quote draw show limak 's journey would look like first two sample second sample answer ` ` '' n't end north pole,['implementation'],1300.0
750/E,a string t call nice a string ` ` 2017 '' occur t a subsequence a string ` ` 2016 '' n't occur t a subsequence example string ` ` <unknown> '' ` ` <unknown> '' nice string ` ` <unknown> '' ` ` 1234 '' ` ` <unknown> '' n't nice ugliness a string minimum possible number character remove order obtain a nice string 's impossible make a string nice remove character ugliness - 1 . limak a string s length n character index 1 n. ask q query i - th query compute print ugliness a substring ( continuous subsequence ) s start index ai end index bi ( inclusive ) first line input contain two integers n q ( 4 ≤ n ≤ 200 000 1 ≤ q ≤ 200 000 ) — length string s number query respectively second line contain a string s length n. every character one digits ' 0 ' – ' 9 ' i - th next q line contain two integers ai bi ( 1 ≤ ai ≤ bi ≤ n ) describe a substring i - th query query print ugliness give substring first sample : second sample :,"['data structures', 'dp']",2600.0
750/F,interactive problem interaction section find information flush output new year tree height h a perfect binary tree vertices number 1 2h - 1 order problem assume h least 2 . draw show one example new year tree height 3 : polar bear love decorate new year tree limak exception decorate tree must first find root i.e a vertex exactly two neighbour ( assume h ≥ 2 ) wo n't easy limak a little bear n't even see whole tree help ? t testcases testcase first read h input ask 16 question format ` ` ? x '' ( without quote ) x integer 1 2h - 1 inclusive a reply get list neighbour vertex x ( detail ` ` interaction '' section ) example a tree draw ask ` ` ? 1 '' would get a response 3 neighbour : 4 5 7 . goal find index root y print format ` ` ! y '' able read h a next testcase print answer a previous testcase flush output tree fix begin n't change question first line input contain a single integer t ( 1 ≤ t ≤ 500 ) — number testcases begin testcase read input a single integer h ( 2 ≤ h ≤ 7 ) — height tree ca n't read value h a next testcase answer a previous testcase ask a question neighbour vertex x print ` ` ? x '' ( without quote ) a separate line note must print end - of - line character last character line flush output get a response response consist two line first line contain a single integer k ( 1 ≤ k ≤ 3 ) — number neighbour vertex x. second line contain k distinct integers t1 ... tk ( 1 ≤ t1 < ... < tk ≤ 2h - 1 ) — indices neighbour vertex x give increase order ask 16 question say y — index root print ` ` ! y '' ( without quote ) end - of - line character flush output tree fix begin n't change question get idleness limit exceed n't print anything forget flush output flush use ( print a query / answer end - of - line ) : moment program read h = 0 k = 0 immediately terminate normally ( example call exit ( 0 ) ) mean system detect incorrect request / output program print 0 ca n't process request anymore case 'll receive verdict ` ` wrong answer '' ignore case h = 0 k = 0 could lead ` ` runtime error '' ` ` time / memory limit exceed '' verdict program could read a trash close input stream hack hack someone use follow format : first line contain a single integer t equal 1 ( one testcase allow hack ) second line contain a single integer h. next 2h - 2 line contain two distinct integers ai bi ( 1 ≤ ai bi ≤ 2h - 1 ) denote two nod connect edge print edge must form a perfect binary tree height h. course contestant program able see input first sample a tree correspond draw statement second sample two two testcases a tree first testcase height 2 thus 3 vertices a tree second testcase height 4 thus 15 vertices see tree draw,['implementation'],2800.0
754/B,ilya experience player tic - tac - toe 4 × 4 field always start play xs play a lot game today friend arseny friends become tire n't finish last game ilya 's turn game leave determine whether ilya could game make single turn rule tic - tac - toe 4 × 4 field follow first turn field cells empty two players take turn place sign empty cells ( first player place xs second player place os ) player place xs go first another one go second winner player first get three sign a row next ( horizontal vertical diagonal ) tic - tac - toe position give four line line contain four character character ' . ' ( empty cell ) ' x ' ( lowercase english letter x ) ' o ' ( lowercase english letter o ) guarantee position reachable play tic - tac - toe ilya 's turn ( particular mean game finish ) possible cells empty mean friends leave without make single turn print single line : ` ` yes '' case ilya could make single turn ` ` '' otherwise first example ilya two win move : empty cell leave column leftmost empty cell first row second example n't possible win make single turn third example ilya could place x last row two exist xs fourth example n't possible win make single turn,['implementation'],1100.0
754/D,character hobbies true fedor enjoy shop neighbor supermarket goods supermarket unique integer ids also every integer a product i d equal integer fedor n discount coupons i - th use products ids range li ri inclusive today fedor want take exactly k coupons fedor want choose k coupons a way number products x coupons use product x large possible ( better understand see examples ) fedor want save time well ask choose coupons help fedor ! first line contain two integers n k ( 1 ≤ k ≤ n ≤ 3·105 ) — number coupons fedor number coupons want choose next n line contain two integers li ri ( - 109 ≤ li ≤ ri ≤ 109 ) — description i - th coupon coupons equal first line print single integer — maximum number products choose coupons use products least one coupon use n't count second line print k distinct integers p1 p2 ... pk ( 1 ≤ pi ≤ n ) — ids coupons fedor choose multiple answer print first example take first two coupons products ids range [ 40 70 ] buy coupons 31 products total second example product buy two coupons answer 0 . fedor choose two coupons example,"['data structures', 'greedy']",2100.0
757/F,"'s turn year bash want send present friends n cities himalayan region connect m bidirectional roads bash live city s. bash exactly one friend cities since bash want surprise friends decide send a pikachu since may cities reachable bash 's city send a pikachu friends live a city reachable city also want send soon possible find minimum time <unknown> reach destination city since a perfectionist inform friends time gift reach a pikachu travel a speed 1 meter per second friends excite hear would unhappy present get delay unfortunately team rocket loose come know bash 's plan want maximize number friends unhappy bash destroy exactly one n - 1 cities imply friend reside city die unhappy well note a city destroy roads directly connect city also destroy pikachu may force take a longer alternate route please also note friends wait a gift count unhappy even die since bash already a legend help team rocket time find maximum number bash 's friends make unhappy destroy exactly one city first line contain three space separate integers n m s ( 2 ≤ n ≤ 2·105 , 1 ≤ s ≤ n ) — number cities number roads himalayan region city bash live next m line contain three space - separated integers u v w ( 1 ≤ u v ≤ n u ≠ v 1 ≤ w ≤ 109 ) denote exist a road city u city v length w meter guarantee road connect a city two roads connect pair cities print a single integer answer problem first sample destroy city 2 length shortest distance pair cities ( 3 2 ) ( 3 4 ) change hence answer 2",['data structures'],2800.0
758/A,"berland holiday equality honor holiday king decide equalize welfare citizens berland expense state treasury totally berland n citizens welfare estimate integer ai burl ( burle currency berland ) royal <unknown> need count minimum charge kingdom king 's present king give money n't a power take away first line contain integer n ( 1 ≤ n ≤ 100 ) — number citizens kingdom second line contain n integers a1 a2 ... , ai ( 0 ≤ ai ≤ 106 ) — welfare i - th citizen line print integer s — minimum number burl spend first example add first citizen 4 burl second 3 third 2 fourth 1 welfare citizens equal 4 . second example enough give one burle third citizen third example necessary give two burl first third citizens make welfare citizens equal 3 . fourth example possible give nothing everyone citizens 12 burl","['implementation', 'math']",800.0
758/D,alexander learn convert number decimal system however n't know english letter write number a decimal number mean instead letter a write number 10 . thus convert number 475 decimal hexadecimal system get <unknown> ( 475 = <unknown> + <unknown> + <unknown> ) alexander live calmly try convert number back decimal number system alexander remember work little number ask find minimum decimal number convert system base n get number k. first line contain integer n ( 2 ≤ n ≤ 109 ) second line contain integer k ( 0 ≤ k < <unknown> ) guarantee number k contain 60 symbols digits second line strictly less n. alexander guarantee answer exist exceed 1018 . number k n't contain lead zero print number x ( 0 ≤ x ≤ 1018 ) — answer problem first example 12 could obtain convert two number system base 13 : 12 = <unknown> 15 = <unknown> + <unknown>,"['dp', 'greedy', 'math']",2000.0
758/F,give n l r find number distinct geometrical progression contain n distinct integers less l greater r. word progression follow must hold : l ≤ ai ≤ r ai ≠ aj a1 a2 ... geometrical progression 1 ≤ i j ≤ n i ≠ j. geometrical progression a sequence number a1 a2 ... term first find multiply previous one a fix non - zero number d call common ratio note task d may non - integer example progression 4 6 9 common ratio two progressions a1 a2 ... b1 b2 ... bn consider different i ( 1 ≤ i ≤ n ) ai ≠ bi first line <unknown> three integers n l r ( 1 ≤ n ≤ 107 1 ≤ l ≤ r ≤ 107 ) print integer k — answer problem possible progressions first test examples : possible progressions second test examples : possible progressions third test examples : possible progressions fourth test examples :,['math'],2400.0
76/B,modern research show a flock hungry mice search a piece cheese act follow : several piece cheese mouse choose closest one mice start move towards choose piece cheese a mouse several mice achieve destination point still a piece cheese eat become well - <unknown> mice reach point remain hungry move speed mice equal several ways choose closest piece mice choose a way would minimize number hungry mice check theory scientists decide conduct experiment locate n mice m piece cheese a cartesian plane mice locate line y = y0 piece cheese — another line y = y1 check result experiment scientists need a program simulate behavior a flock hungry mice write a program compute minimal number mice remain hungry i.e without cheese first line input contain four integer number n ( 1 ≤ n ≤ 105 ) m ( 0 ≤ m ≤ 105 ) y0 ( 0 ≤ y0 ≤ 107 ) y1 ( 0 ≤ y1 ≤ 107 y0 ≠ y1 ) second line contain a strictly increase sequence n number — x coordinate mice third line contain a strictly increase sequence m number — x coordinate cheese coordinate integers exceed 107 absolute value line output contain one number — minimal number mice remain without cheese three mice choose first piece cheese second third mice eat piece first one remain hungry run towards piece late second piece cheese remain uneaten,['greedy'],2100.0
76/C,scientists planet <unknown> conduct experiment mutation primitive organisms genome organism planet represent a string first k capital english letter pair type genes assign ai j — a risk disease occurence organism provide genes type adjacent genome i — 1 - based index first gene j — index second gene gene ' a ' index 1 ' b ' index 2 example a3 2 stand risk ' cb ' fragment risk disease occurence organism equal sum risk pair adjacent genes genome scientists already obtain a base organism new organisms obtain mutation organism mutation involve removal genes particular type removal increase total risk disease occurence additionally type genes scientists determine ti — increasement total risk disease occurence provide removal genes type index i. example t4 stand value additional total risk increasement case remove 'd ' genes scientists want find a number different organisms obtain give one total risk disease occurence greater t. use process mutation describe two organisms consider different string represent genomes different genome contain least one gene first line input contain three integer number n ( 1 ≤ n ≤ 200 000 ) — length genome base organism k ( 1 ≤ k ≤ 22 ) — maximal index gene type genome t ( 1 ≤ t ≤ 2·109 ) — maximal allowable risk disease occurence second line contain genome give organism a string first k capital english letter length n. third line contain k number t1 t2 ... tk ti additional risk value disease occurence provide remove genes i - th type follow k line contain elements give matrix ai j. i - th line contain k number j - th number i - th line stand a risk disease occurence pair genes first correspond i - th letter second correspond j - th letter give matrix necessarily symmetrical number input integer non - negative except t greater 109 . guarantee maximal possible risk organism obtain give organism strictly smaller 231 . output number organisms obtain base one total risk disease occurence greater t. explanation : one obtain follow organisms ( risk state bracket ) : <unknown> ( 11 ) acac ( 10 ) baa ( 5 ) b ( 6 ) aa ( 4 ),"['dp', 'math']",2700.0
761/C,overcome stairs dasha come class need write a password begin class password a string length n satisfy follow requirements : consider program class easy write password character password a fix string length m n string a pointer character i - th character display screen point character i - th string initially pointers character index 1 correspond string ( position number start one ) one operation dasha move a pointer one string one character leave right string cyclic mean move pointer character index 1 leave move character index m move right position m move position 1 . need determine minimum number operations necessary make string display screen a valid password first line contain two integers n m ( 3 ≤ n ≤ 50 1 ≤ m ≤ 50 ) — length password length string assign password symbols next n line contain string assign i - th symbol password string length m consist digits lowercase english letter character ' # ' ' * ' ' & ' input data always get a valid password print one integer — minimum number operations necessary make string display screen a valid password first test necessary move pointer third string one leave get optimal answer second test one possible algorithms :,"['dp', 'implementation']",1500.0
764/A,comrade <unknown> busy choose artists timofey 's birthday <unknown> call taymyr ilia - alpinist ilia - alpinist call every n minutes i.e minutes n 2n 3n artists come comrade every m minutes i.e minutes m 2 m 3 m day z minutes long i.e day consist minutes 1 2 ... z. many artists kill artists room ilia call ? consider a call a talk artist take exactly one minute string contain three integers — n m z ( 1 ≤ n m z ≤ 104 ) print single integer — minimum number artists kill artists room ilia call taymyr a place north russia first test artists come minute well call need kill second test need kill artists come second fourth minutes third test — artist come sixth minute,"['implementation', 'math']",800.0
765/A,literally dozens <unknown> competitions hold year team jinotega try attend ( reason prefer name ` ` <unknown> '' ) ! a competition take place somewhere far hometown ivan artsem <unknown> take a flight contest back jinotega 's best friends team base find a list itinerary receipt information departure arrival airports wonder jinotega : home competition far away ? know : please help determine jinotega 's location ! first line input a single integer n : number jinotega 's flight ( 1 ≤ n ≤ 100 ) second line a string 3 capital latin letter : name jinotega 's home airport next n line flight information one flight per line form ` ` <unknown> > yyy '' ` ` xxx '' name departure airport ` ` yyy '' name arrival airport exactly one airports jinotega 's home airport guarantee flight information consistent knowledge jinotega 's friends describe main part statement jinotega home print ` ` home '' ( without quote ) otherwise print ` ` contest '' first sample jinotega might first fly svo <unknown> back svo <unknown> back home second sample jinotega must rap a flight rap back svo list,"['implementation', 'math']",900.0
766/C,mahmoud write a message s length n. want send a birthday present friend <unknown> like string write a magical paper surprise character disappear write string 's magical paper n't allow character number i english alphabet write a string length ai example a1 = 2 ca n't write character ' a ' paper a string length 3 string ` ` aa '' allow string ` ` aaa '' mahmoud decide split message non - empty substrings write every substring independent magical paper fulfill condition sum lengths n n't overlap example a1 = 2 want send string ` ` aaa '' split ` ` a '' ` ` aa '' use 2 magical paper ` ` a '' ` ` a '' ` ` a '' use 3 magical paper ca n't split ` ` aa '' ` ` aa '' sum lengths greater n. split message single string fulfill condition a substring string s a string consist consecutive character string s string ` ` ab '' ` ` abc '' ` ` b '' substrings string ` ` abc '' string ` ` acb '' ` ` ac '' string a substring mahmoud think split message ehab tell many ways split mahmoud ask three question : two ways consider different set split position differ example split ` ` <unknown> '' ` ` <unknown> '' consider different splittings message ` ` aaa '' first line contain integer n ( 1 ≤ n ≤ 103 ) denote length message second line contain message s length n consist lowercase english letter third line contain 26 integers a1 a2 ... <unknown> ( 1 ≤ ax ≤ 103 ) — maximum lengths substring letter appear print three line first line print number ways split message substrings fulfill condition mention problem modulo 109 + 7 . second line print length longest substring ways third line print minimum number substrings ways first example three ways split message : longest substrings ` ` aa '' ` ` ab '' length 2 . minimum number substrings 2 ` ` <unknown> '' ` ` <unknown> '' notice ` ` aab '' a possible split letter ' a ' appear a substring length 3 a1 = 2,"['dp', 'greedy']",1700.0
767/E,student arseny like plan life n days ahead visit a canteen every day already decide order follow n days price canteen change mean arseny spend ci rubles i - th day 1 - ruble coin 100 - ruble note circulation moment arseny m coin a sufficiently large amount note ( assume infinite amount ) arseny love modern technologies use credit card everywhere except canteen pay cash canteen accept card cashier always ask student pay change - free however 's always possible arseny try minimize dissatisfaction cashier cashier 's dissatisfaction days determine total amount note coin change precise cashier give arseny x note coin i - th day dissatisfaction day equal <unknown> cashier always give change use little coin note possible always enough able arseny want pay a way total dissatisfaction cashier n days would small possible help find need pay n days ! note arseny always enough money pay infinite amount note arseny use note coin receive change follow days first line contain two integers n m ( 1 ≤ n ≤ 105 0 ≤ m ≤ 109 ) — amount days arseny plan action amount coin currently second line contain a sequence integers c1 c2 ... cn ( 1 ≤ ci ≤ 105 ) — amount money rubles arseny go spend follow days third line contain a sequence integers w1 w2 ... wn ( 1 ≤ wi ≤ 105 ) — cashier 's dissatisfaction coefficients follow days first line print one integer — minimum possible total dissatisfaction cashier print n line i - th contain two number — amount note amount coin arseny use pay canteen i - th day course total amount money arseny give <unknown> days less amount money plan spend also n't exceed 106 rubles : arseny never carry large sum money multiple answer print,['greedy'],2400.0
769/B,polycarp study university group consist n students ( include ) <unknown> social net ` ` <unknown> ! ` ` students equally <unknown> student know value ai — maximum number message i - th student agree send per day student ca n't send message early morning polycarp know important news program credit tomorrow reason necessary urgently inform groupmates news use private message task make a plan use private message : let 's consider students numerate distinct number 1 n polycarp always number 1 . task n't minimize number message moment time know credit parameters find way use private message satisfy requirements first line contain positive integer n ( 2 ≤ n ≤ 100 ) — number students second line contain sequence a1 a2 ... ( 0 ≤ ai ≤ 100 ) ai equal maximum number message i - th student agree send consider polycarp always number 1 . print -1 first line impossible inform students credit otherwise first line print integer k — number message send next k line print two distinct integers f t mean student number f send message news student number t. message print chronological order mean student send message must already know news assume students receive repeat message news credit several answer acceptable print first test polycarp ( student number 1 ) send message student number 2 send message students number 3 4 . thus students know credit,['greedy'],1200.0
77/A,year 2012 come ... accord ancient <unknown> legend year 2012 diablo brothers mephisto baal escape hell <unknown> hordes demons <unknown> human world seven brave heroes already gather top a mountain <unknown> protect us mere mortals effect terrible evil seven great heroes : amazon anka <unknown> chapay <unknown> cleo <unknown> troll <unknown> dracul <unknown> snowy a professional hit girl hexadecimal heroes already know much experience give three megabosses : a mephisto b diablo c baal 's problem : heroes much seven megabosses three ! heroes decide split three team team go destroy megaboss team member receive a experience round x amount experience kill megaboss y — number people team heroes want hurt 's feel want split team difference hero receive maximum number experience hero receive minimum number experience minimal since several divisions team need find one total amount like team maximum know heroes like others hero p like hero q mean hero q like hero p. hero like total amount like team amount order pair ( p q ) heroes p q group hero p like hero q ( important hero q like hero p ) case heroes p q like group pair count twice ( p q ) ( q p ) a team consist even a single hero important every megaboss destroy heroes must involve campaign evil none heroes one team guarantee every hero able destroy megaboss alone first line contain a single non - negative integer n ( 0 ≤ n ≤ 42 ) — amount like heroes next n line describe like form ` ` p like q '' mean hero p like hero q ( p ≠ q ) every like describe input exactly hero like last line give three integers a b c ( 1 ≤ a b c ≤ 2·109 ) separate space : experience mephisto experience diablo experience baal pretests except examples statement follow condition satisfy : a = b = c. print two integers — minimal difference experience two heroes receive maximum minimum number experience point maximal total amount like team ( number friendships heroes end one team ) calculate second answer team division satisfy difference - <unknown> <unknown> i.e primary minimize difference experience secondary maximize total amount like a note first example : first team dracul troll anka second one hexadecimal snowy third cleo и chapay,['implementation'],1400.0
77/C,` ` eat a beaver save a tree ! '' — motto <unknown> ' urgent meet <unknown> hill whole point population beaver earth reach incredible size ! day number increase several time n't even realize much <unknown> <unknown> tree harm nature <unknown> amount oxygen atmosphere drop 17 per cent best mind world think end middle 50 - s previous century a group soviet scientists succeed foresee situation beaver work a secret technology clean territory technology bear a mysterious title ` ` beavermuncher-0xff '' fate planet lie fragile <unknown> a small group people dedicate live science prototype ready need urgently carry experiment practice give a tree completely occupy beaver a tree a connect undirected graph without cycle tree consist n vertices i - th vertex contain ki beaver ` ` beavermuncher-0xff '' work follow principle : vertex u go vertex v connect edge eat exactly one beaver locate vertex v. impossible move vertex v beaver leave v. ` ` beavermuncher-0xff '' stand vertex eat beaver ` ` beavermuncher-0xff '' must move without stop ` ` beavermuncher-0xff '' work like ? developers provide place battery eat beaver necessary convert mass pure energy guarantee beaver shock happen able move a vertex tree another one ` ` beavermuncher-0xff '' move along edge directions condition describe fulfil root tree locate vertex s. mean ` ` beavermuncher-0xff '' begin mission vertex s must return end experiment one go take a high place determine maximum number beaver ` ` beavermuncher-0xff '' eat return start vertex first line contain integer n — number vertices tree ( 1 ≤ n ≤ 105 ) second line contain n integers ki ( 1 ≤ ki ≤ 105 ) — amount beaver correspond vertices follow n - 1 line describe tree line contain two integers separate space integers represent two vertices connect edge vertices number 1 n. last line contain integer s — number start vertex ( 1 ≤ s ≤ n ) print maximum number beaver <unknown> ` ` beavermuncher-0xff '' please use % lld specificator write 64 - bit integers c++ prefer use cout ( also may use % i64d ),"['dp', 'greedy']",2100.0
773/B,vasya petya take part a codeforces round round last two hours contain five problems round dynamic problem score use lucky participate codeforces round dynamic problem score mean maximum point value problem depend ratio number participants solve problem total number round participants everyone make least one submission consider participate round pay attention range bound example 40 people take part round 10 solve a particular problem solvers fraction equal 1 / 4 problem 's maximum point value equal 1500 . problem 's maximum point value equal x whole minute pass begin contest moment participant 's correct submission participant lose x / 250 point example problem 's maximum point value 2000 participant submit a correct solution 40 minutes round participant award 2000 · ( 1 - 40 / 250 ) = <unknown> point problem n participants round include vasya petya participant problem number minutes pass begin contest submission participant problem know 's also possible participant make submissions problem two second end round participants ' submissions pass pretests a single hack attempt make vasya believe submissions hack attempt make remain two second every submission pass system test unfortunately vasya a cheater register 109 + 7 new account round vasya submit solutions new account order change maximum point value problems vasya also submit wrong solutions problems note vasya submit correct solutions problems n't solve vasya seek score strictly point petya current round vasya already prepare script allow obfuscate solutions submit system new account fraction second however vasya n't want make cheat obvious want achieve goal make submissions smallest possible number new account find smallest number new account vasya need order beat petya ( provide vasya 's assumptions correct ) report vasya ca n't achieve goal first line contain a single integer n ( 2 ≤ n ≤ 120 ) — number round participants include vasya petya next n line contain five integers ai 1 ai 2 ... ai 5 ( - 1 ≤ ai j ≤ 119 ) — number minutes pass begin round submission problem j participant i -1 participant i n't solve problem j. guarantee participant make least one successful submission vasya list participant number 1 petya list participant number 2 participants list particular order output a single integer — number new account vasya need beat petya -1 vasya ca n't achieve goal first example vasya 's optimal strategy submit solutions last three problems two new account case first two problems maximum point value 1000 last three problems maximum point value 500 . vasya 's score equal <unknown> + <unknown> + 420 + 360 + 270 = <unknown> point petya score 800 + 820 + 420 + <unknown> + 470 = <unknown> point second example vasya make a single unsuccessful submission problem two new account a single successful submission first problem third new account case maximum point value problems equal 500 1500 1000 1500 3000 . vasya score <unknown> point petya score <unknown> point third example vasya achieve goal submit solutions first four problems 27 new account maximum point value problems equal 500 500 500 500 2000 . thank high cost fifth problem vasya manage beat petya solve first four problems quickly could n't solve fifth one,['greedy'],2000.0
773/E,'s well - known blog post important part codeforces platform every blog post a global characteristic change time — community rat a newly create blog post 's community rat 0 . codeforces users may visit blog post page rate change community rat +1 -1 . consider follow model codeforces users ' behavior i - th user estimate blog post rat denote integer ai a user visit a blog post page compare estimate blog post rat community rat estimate rat higher rat blog post +1 ( thus blog post 's community rat increase 1 ) estimate rat lower rat blog post -1 ( decrease community rat 1 ) estimate rat community rat equal user n't rate blog post ( case 'll say user rat blog post 0 ) case procedure user close blog post page never open consider a newly create blog post initial community rat 0 . n codeforces users number 1 n estimate blog post rat ai know k 1 n inclusive follow question ask let users indices 1 k order visit blog post page rate blog post close page user open blog post previous user close could maximum possible community rat blog post k visit ? first line contain a single integer n ( 1 ≤ n ≤ 5·105 ) — number codeforces users second line contain n integers a1 a2 ... ( - 5·105 ≤ ai ≤ 5·105 ) — estimate blog post rat users order 1 n. k 1 n output a single integer equal maximum possible community rat blog post users indices 1 k order visit blog post page rate blog post close page,['data structures'],3000.0
777/C,lesson small girl alyona work one famous <unknown> computer program learn edit table a table fill integers table consist n row m columns ai j denote integer locate i - th row j - th column say table sort non - decreasing order column j ai j ≤ ai + 1 j i 1 n - 1 . teacher give alyona k task task two integers l r give alyona answer follow question : one keep row l r inclusive delete others table sort non - decreasing order least one column ? formally exist j ai j ≤ ai + 1 j i l r - 1 inclusive alyona small deal task ask help ! first line input contain two positive integers n m ( 1 ≤ n·m ≤ 100 000 ) — number row number columns table respectively note give a constraint bind product two integers i.e number elements table follow n line contain m integers j - th integers i line stand ai j ( 1 ≤ ai j ≤ 109 ) next line input contain integer k ( 1 ≤ k ≤ 100 000 ) — number task teacher give alyona i - th next k line contain two integers li ri ( 1 ≤ li ≤ ri ≤ n ) print ` ` yes '' i - th line output table consist row li ri inclusive sort non - decreasing order least one column otherwise print ` ` '' sample whole table sort column however row <unknown> sort column 1 row <unknown> sort column 3,"['data structures', 'dp', 'greedy', 'implementation']",1600.0
788/A,something happen uzhlyandia ... riot streets ... famous uzhlyandian superheroes <unknown> sheep stas giraffe call order save situation upon arrive find citizens worry maximum value main uzhlyandian function f define follow : formula 1 ≤ l < r ≤ n must hold n size main uzhlyandian array a |x| mean absolute value x. heroes skip math lessons school ask help help calculate maximum value f among possible value l r give array a. first line contain single integer n ( 2 ≤ n ≤ 105 ) — size array a. second line contain n integers a1 a2 ... ( -109 ≤ ai ≤ 109 ) — array elements print integer — maximum value f. first sample case optimal value f reach intervals [ 1 2 ] [ 2 5 ] second case maximal value f reachable whole array,['dp'],1600.0
792/F,vova play a computer game know <unknown> monsters vova 's character a mage though start character know spell vova 's character learn new spell game every spell characterize two value xi yi — damage per second mana cost per second respectively vova n't use a spell integer amount second formally use a spell damage x mana cost y z second deal <unknown> damage spend y·z mana ( round ) mana leave ( mana amount set start game remain begin every fight ) character wo n't able use spell prohibit use multiple spell simultaneously also vova fight monsters every monster characterize two value tj hj — monster kill vova 's character tj second hj health point mana refill every fight ( vova 's character <unknown> full mana reserve ) previous fight influence ones vova 's character kill a monster deal hj damage tj second use spell ( allow use one spell a fight ) spend mana begin fight monster 's health become zero exactly tj second ( mean monster vova 's character kill time ) vova win fight write a program answer two type query : note query give a different form also remember vova 's character know spell begin game every query second type determine vova able win fight correspond monster first line contain two integer number q m ( 2 ≤ q ≤ 105 1 ≤ m ≤ 1012 ) — number query amount mana begin every <unknown> - th next q line contain three number ki ai bi ( 1 ≤ ki ≤ 2 1 ≤ ai bi ≤ 106 ) use restore query way : let j index last query second type positive answer ( j = 0 none ) every query second type print yes vova able win fight correspond monster otherwise first example vova 's character first learn spell 5 damage 10 mana cost per second next query a fight monster kill character 20 second 50 health point vova kill 10 second ( spend 100 mana ) next monster 52 health vova ca n't deal much damage 100 mana,['data structures'],3100.0
793/C,"igor analyst fell asleep work a strange dream dream desk crowd computer mice buy a mousetrap catch desk consider infinite plane mousetrap a rectangle side parallel ax opposite side locate point ( x1 y1 ) ( x2 y2 ) igor want catch mice igor analyse behavior discover mouse move along a straight line constant speed speed i - th mouse equal ( vix viy ) mean x coordinate mouse increase vix units per second y coordinate increase viy units mousetrap open initially mice able move freely desk igor close mousetrap moment catch mice strictly inside mousetrap igor work a lot busy dream well ask write a program give mousetrap 's coordinate initial coordinate mice speed determine earliest time moment able catch mice please note igor close mousetrap first line contain single integer n ( 1 ≤ n ≤ 100 000 ) — number computer mice desk second line contain four integers x1 y1 x2 y2 ( 0 ≤ x1 ≤ x2 ≤ 100 000 ) ( 0 ≤ y1 ≤ y2 ≤ 100 000 ) — coordinate opposite corner mousetrap next n line contain information mice i - th line contain four integers rix riy vix viy ( 0 ≤ rix riy ≤ 100 000 - 100 000 ≤ vix viy ≤ 100 000 ) ( rix riy ) initial position mouse ( vix viy ) speed line print minimum possible non - negative number t igor close mousetrap t second begin mice strictly inside mousetrap t print -1 . answer consider correct absolute relative error n't exceed 10 - 6 . formally let answer a jury 's answer b. answer consider correct a picture first samplepoints a b c d - start mice position segment paths , first time mice rectangle look like : a picture second samplepoints a d b never enter rectangle","['implementation', 'math']",2300.0
798/E,mike discover a new way encode permutations a permutation p = [ p1 p2 ... pn ] encode follow way : denote a = [ a1 a2 ... ] a sequence length n represent code permutation i 1 n sequentially choose smallest unmarked j ( 1 ≤ j ≤ n ) pi < pj assign ai number j ( word perform ai = j ) mark j. j 'll assign ai number - 1 ( perform ai = - 1 ) mike forget original permutation remember code task simple : find permutation code code mike 's original permutation may assume always least one valid permutation first line contain single integer n ( 1 ≤ n ≤ 500 000 ) — length permutation second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ n ai = - 1 ) — code mike 's permutation may assume positive value a different first line print n number p1 p2 ... pn ( 1 ≤ pi ≤ n ) — a permutation p code give one note number permutation distinct permutation first example : i = 1 smallest j 2 p2 = 6 > p1 = <unknown> = 2 j p2 = 6 greatest element <unknown> = 3 smallest j 1 p1 = 2 > p3 = <unknown> = 4 smallest j 5 ( 2 already mark ) p5 = 5 > p4 = <unknown> = 5 j 2 already <unknown> = 6 smallest j 4 p4 = 4 > <unknown> = 3,['data structures'],3000.0
805/A,tavak seyyed good friends seyyed funny tell tavak solve follow problem instead longest - path give l r. integers l r inclusive write integer divisors except 1 . find integer write maximum number time solve problem show 's a np problem first line contain two integers l r ( 2 ≤ l ≤ r ≤ 109 ) print single integer integer appear maximum number time divisors multiple answer print definition a divisor : https : <unknown> / definitions / divisor - of - <unknown> - <unknown> first example : 19 29 number divisible 2 : { 20 22 24 26 28 } second example : 3 6 number divisible 3 : { 3 6 },"['greedy', 'math']",1000.0
808/D,vasya array a consist positive integer number vasya want divide array two non - empty consecutive part ( prefix suffix ) sum elements first part equal sum elements second part always possible vasya move element divide array ( vasya erase element insert arbitrary position ) insert element position erase also consider move vasya divide array choose right element move new position ? first line contain single integer n ( 1 ≤ n ≤ 100000 ) — size array second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — elements array print yes vasya divide array move one element otherwise print first example vasya move second element end array second example move make division possible third example vasya move fourth element one position leave,"['data structures', 'implementation']",1900.0
811/C,vladik often travel train remember trip especially well i would like tell one trip : vladik initial train station n people ( include vladik ) want get train already line order city code ai know ( code city go ) train chief select number disjoint segment original sequence people ( cover entire sequence segment necessary ) people segment train carriage segment select way least one person travel city x people go city x railway carriage mean ’ t belong different segment note people travel city x either go railway carriage go anywhere comfort a train trip people segment position l position r equal xor distinct cod cities people segment position l position r. xor operation also know exclusive total comfort a train trip equal sum comfort segment help vladik know maximal possible total comfort first line contain single integer n ( 1 ≤ n ≤ 5000 ) — number people second line contain n space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 5000 ) ai denote code city i - th person go output contain a single integer — maximal possible total comfort first test case best partition segment : [ 4 4 ] [ 2 5 2 ] [ 3 ] answer calculate follow : 4 + ( 2 xor 5 ) + 3 = 4 + 7 + 3 = 14 in second test case best partition segment : 5 1 [ 3 ] 1 5 [ 2 4 2 ] 5 answer calculate follow : 3 + ( 2 xor 4 ) = 3 + 6 = 9,"['dp', 'implementation']",1900.0
814/A,"a years ago hitagi encounter a giant <unknown> steal whole body weight ever since try avoid contact others fear secret might notice get rid oddity recover weight a special integer sequence need hitagi 's sequence break a long time kaiki provide opportunity hitagi 's sequence a a length n. lose elements denote zero kaiki provide another sequence b whose length k equal number lose elements a ( i.e number zero ) hitagi replace zero a element b element b use exactly hitagi know however , apart 0 integer occur a b total result sequence increase sequence power recover hitagi oddity determine whether possible kaiki 's sequence another fake word detect whether possible replace zero a integer b integer b use exactly result sequence increase first line input contain two space - separated positive integers n ( 2 ≤ n ≤ 100 ) k ( 1 ≤ k ≤ n ) — lengths sequence a b respectively second line contain n space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 200 ) — hitagi 's break sequence exactly k zero elements third line contain k space - separated integers b1 b2 ... bk ( 1 ≤ bi ≤ 200 ) — elements fill hitagi 's sequence input guarantee apart 0 integer occur a b total output ` ` yes '' 's possible replace zero a elements b make result sequence increase ` ` '' otherwise first sample : second sample possible result sequence 2 3 5 8 9 10 increase sequence therefore invalid","['greedy', 'implementation']",900.0
815/A,way school karen become <unknown> puzzle game phone ! game play follow level a grid n row m columns cell originally contain number 0 . one move consist choose one row column add 1 cells row column win level move number cell i - th row j - th column equal gi j. karen stick one level want know a way beat level use minimum number move please help task ! first line input contain two integers n m ( 1 ≤ n m ≤ 100 ) number row number columns grid respectively next n line contain m integers particular j - th integer i - th row contain gi j ( 0 ≤ gi j ≤ 500 ) error actually possible beat level output a single integer -1 . otherwise first line output a single integer k minimum number move necessary beat level next k line contain one follow describe move order must do : multiple optimal solutions output one first test case karen a grid 3 row 5 columns perform follow 4 move beat level : second test case karen a grid 3 row 3 columns clear impossible beat level ; perform move create three 1s grid require one 1 center third test case karen a grid 3 row 3 columns perform follow 3 move beat level : note solution ; another solution among others col 1 col 2 col 3,"['greedy', 'implementation']",1700.0
816/B,stay wake attentive class karen need coffee ! karen a coffee <unknown> want know optimal temperature brew perfect cup coffee indeed spend time read several recipe book include <unknown> <unknown> ` ` art <unknown> '' know n coffee recipes i - th recipe suggest coffee brew li ri degrees inclusive achieve optimal taste karen think a temperature admissible least k recipes recommend karen a rather <unknown> mind ask q question question give want prepare coffee a temperature a b inclusive tell many admissible integer temperatures fall within range ? first line input contain three integers n k ( 1 ≤ k ≤ n ≤ 200000 ) q ( 1 ≤ q ≤ 200000 ) number recipes minimum number recipes a certain temperature must recommend admissible number question karen respectively next n line describe recipes specifically i - th line among contain two integers li ri ( 1 ≤ li ≤ ri ≤ 200000 ) describe i - th recipe suggest coffee brew li ri degrees inclusive next q line describe question line contain a b ( 1 ≤ a ≤ b ≤ 200000 ) describe want know number admissible integer temperatures a b degrees inclusive question output a single integer a line number admissible integer temperatures a b degrees inclusive first test case karen know 3 recipes a temperature admissible least 2 recipes recommend ask 4 question first question want know number admissible integer temperatures 92 94 degrees inclusive 3 : 92 93 94 degrees admissible second question want know number admissible integer temperatures 93 97 degrees inclusive 3 : 93 94 97 degrees admissible third question want know number admissible integer temperatures 95 96 degrees inclusive none final question want know number admissible integer temperatures 90 100 degrees inclusive 4 : 92 93 94 97 degrees admissible second test case karen know 2 recipes a temperature admissible least 1 recipe recommend first question want know number admissible integer temperatures actually reasonable none,"['data structures', 'implementation']",1400.0
818/A,n students take part olympiad 's time award students receive diplomas <unknown> get certificate others wo n't receive anything students diplomas certificate call winners rule count number diplomas certificate number certificate must exactly k time greater number diplomas number winners must greater half number students ( i.e greater half n ) 's possible winners identify maximum possible number winners accord rule also case calculate number students diplomas number students certificate number students winners first ( ) line input contain two integers n k ( 1 ≤ n k ≤ 1012 ) n number students k ratio number certificate number diplomas output three number : number students diplomas number students certificate number students winners case number winners maximum possible 's possible winners,"['implementation', 'math']",800.0
818/D,alice bob get bore a long car trip decide play a game window see cars different color run past cars go one another game rule like firstly alice choose color a bob choose color b ( a ≠ b ) car update number cars choose color run past let 's define number i - th car <unknown> ( i ) <unknown> ( i ) bob know color cars encounter order appearance alice already choose color a bob want choose color b win game ( draw a win ) help find color multiple solutions print color print -1 . first line contain two integer number n a ( 1 ≤ n ≤ 105 1 ≤ a ≤ 106 ) – number cars color choose alice second line contain n integer number c1 c2 ... cn ( 1 ≤ ci ≤ 106 ) — color cars alice bob encounter order appearance output color b ( 1 ≤ b ≤ 106 ) bob choose win game multiple solutions print color print -1 . guarantee exist solution exist solution ( 1 ≤ b ≤ 106 ) let 's consider <unknown> color first example : third example every color acceptable except 10,"['data structures', 'implementation']",1700.0
819/A,sometimes mister b free even n't know fortunately mister b find a new game player play alien character game lowercase english letter two players : mister b competitor initially players a string s consist first a english letter alphabetical order ( example a = 5 s equal ` ` abcde '' ) players take turn append letter string s. mister b move first mister b must append exactly b letter move arbitrary choose letter opponent add exactly a letter move mister b quickly understand opponent a computer use a simple algorithm computer turn consider suffix string s length a generate a string t length a letter string t distinct n't appear consider suffix multiple variants t lexicographically minimal choose ( a = 4 suffix ` ` <unknown> '' computer choose string t equal ` ` <unknown> '' ) choose string t append end s. mister b soon find game bore come follow question : minimum possible number different letter string s segment position l r inclusive letter string s numerate start 1 . first line contain four space - separated integers : a b l r ( 1 ≤ a b ≤ 12 1 ≤ l ≤ r ≤ 109 ) — number letter player append bound segment print one integer — minimum possible number different letter segment position l position r inclusive string s. first sample test one optimal strategies generate string s = ` ` abababab ... '' 's answer 2 . second sample test string s = ` ` <unknown> ... '' obtain choose segment look like ` ` <unknown> '' 's answer 3 . third sample test string s = ` ` <unknown> ... '' obtain choose segment look like ` ` zzz '' 's answer 1,['greedy'],2200.0
82/A,"sheldon leonard penny rajesh howard queue a ` ` double cola '' drink <unknown> machine ; people queue first one queue ( sheldon ) buy a drink double ! result two <unknown> go end queue next queue ( leonard ) buy a drink get end queue two <unknown> , process continue ad <unknown> example penny drink third cola queue look like : rajesh howard sheldon sheldon leonard leonard penny penny write a program print name a man drink n - th note begin queue look like : sheldon leonard penny rajesh howard first person sheldon input data consist a single integer n ( 1 ≤ n ≤ 109 ) guarantee pretests check spell five name , contain five possible answer print single line — name person drink n - th cola can number start 1 . please note spell name like : ` ` sheldon '' ` ` leonard '' ` ` penny '' ` ` rajesh '' ` ` howard '' ( without quote ) order precisely friends queue initially","['implementation', 'math']",1100.0
821/E,"okabe like take walk know spy organization could anywhere ; 's want know many different walk take city safely okabe 's city represent point ( x y ) x y non - negative okabe start origin ( point ( 0 0 ) ) need reach point ( k 0 ) okabe currently point ( x y ) one step go ( x + 1 y + 1 ) ( x + 1 y ) ( x + 1 y - 1 ) additionally n horizontal line segment i - th go x = ai x = bi inclusive y = ci guarantee a1 = 0 ≤ k ≤ bn ai = bi - 1 2 ≤ i ≤ n. i - th line segment force okabe walk y - value range 0 ≤ y ≤ ci x value satisfy ai ≤ x ≤ bi else might spy also mean require two line segment one segment end another begin okabe want know many walk origin point ( k 0 ) satisfy condition modulo 109 + 7 . first line input contain integers n k ( 1 ≤ n ≤ 100 1 ≤ k ≤ 1018 ) — number segment destination x coordinate next n line contain three space - separated integers ai bi ci ( 0 ≤ ai < bi ≤ 1018 0 ≤ ci ≤ 15 ) — leave right end a segment y coordinate guarantee a1 = 0 ≤ k ≤ bn ai = bi - 1 2 ≤ i ≤ n. print number walk satisfy condition modulo 1000000007 ( 109 + 7 ) graph correspond sample 1 . possible walk : graph correspond sample 2 . one walk okabe reach ( 3 0 ) , possible walk :",['dp'],2100.0
822/D,"pavlopolis university noora study decide hold beauty contest ` ` miss pavlopolis university '' let 's describe process choose beautiful girl university detail contest hold several stag suppose exactly n girls participate competition initially participants divide equal group x participants group furthermore number x choose arbitrarily i. e. every stage number x different within group jury contest compare beauty girls format ` ` '' way group consist x girls comparisons occur , group beautiful participant select select girls enter next stage competition thus n girls divide group x participants group exactly participants enter next stage contest continue exactly one girl leave ` ` miss pavlopolis university '' jury contest a tedious task would like divide girls group stage total number pairwise comparisons girls possible let f ( n ) minimal total number comparisons make select beautiful participant admit n girls first stage organizers competition insane give noora three integers t l r ask poor girl calculate value follow expression : <unknown> ( l ) + <unknown> ( l + 1 ) + ... + tr - <unknown> ( r ) however since value expression quite large organizers ask calculate modulo 109 + 7 . noora calculate value expression organizers promise help beauty contest poor girl strong mathematics turn help leha turn first single line contain three integers t l r ( 1 ≤ t < 109 + 7 2 ≤ l ≤ r ≤ 5·106 ) first line print single integer — value expression modulo 109 + 7 . consider sample necessary find value <unknown> ( 2 ) = 1 . two girls form one group two people one <unknown> ( 3 ) = 3 . three girls form one group three people three <unknown> ( 4 ) = 3 . four girls form two group two girls first stage two comparisons one two group second stage two girls one comparison total 2 + 1 = 3 comparisons also leave girls group first stage comparisons occur obviously 's better split girls group first way value expression","['dp', 'greedy', 'math']",1800.0
827/A,ivan string s consist small english letter however friend julia decide make fun hide string s. ivan prefer make a new string find old one ivan know information string s. namely remember string ti occur string s least ki time also remember exactly ki position string ti occur string s : position xi 1 xi 2 ... xi ki remember n string ti reconstruct lexicographically minimal string s fit information ivan remember string ti string s consist small english letter first line contain single integer n ( 1 ≤ n ≤ 105 ) — number string ivan remember next n line contain information string i - th line contain non - empty string ti positive integer ki equal number time string ti occur string s ki distinct positive integers xi 1 xi 2 ... xi ki increase order — position occurrences string ti string s start guarantee sum lengths string ti n't exceed 106 1 ≤ xi j ≤ 106 1 ≤ ki ≤ 106 sum ki n't exceed 106 . string ti coincide guarantee input data self - contradictory thus least one answer always exist print lexicographically minimal string fit information ivan remember,"['data structures', 'greedy']",1700.0
827/C,"everyone know dna strand consist nucleotides four type nucleotides : ` ` a '' ` ` t '' ` ` g '' ` ` c '' a dna strand a sequence nucleotides scientists decide track evolution a rare species dna strand string s initially evolution species describe a sequence change dna every change a change nucleotide example follow change happen dna strand ` ` <unknown> '' : second nucleotide change ` ` t '' result dna strand ` ` <unknown> '' scientists know segment dna strand affect unknown infections represent infection a sequence nucleotides scientists interest change cause infections thus sometimes want know value impact infection segment dna value compute follow : a developer innokenty interest bioinformatics also scientists ask help innokenty busy prepare vk cup decide delegate problem competitors help scientists ! first line contain string s ( 1 ≤ |s| ≤ 105 ) describe initial dna strand consist capital english letter ` ` a '' ` ` t '' ` ` g '' ` ` c '' next line contain single integer q ( 1 ≤ q ≤ 105 ) — number events , q line follow describe one event line one two format : scientists ' query ( second type query ) print a single integer a new line — value impact infection dna consider first example first query second type character coincide answer 8 . second query compare string ` ` <unknown> ... '' substring ` ` <unknown> '' two match third query dna change compare string ` ` <unknown> ... '' ' substring ` ` <unknown> '' 4 match",['data structures'],2100.0
827/E,grigory love string recently find a metal strip a <unknown> strip length n consist letter ` ` v '' ` ` k '' unfortunately <unknown> eat letter 's impossible understand letter write grigory could n't understand a long time letter remind become interest follow question : put a letter ` ` v '' ` ` k '' unreadable position value period result string equal ? a period a string integer d 1 length string put string shift d position right overlap letter coincide example 3 5 periods ` ` vkkvk '' several ( least one ) test case input first line contain single integer — number test case empty line test case test case describe two line : first line contain single integer n ( 1 ≤ n ≤ 5·105 ) — length string second line contain string length n consist letter ` ` v '' ` ` k '' character ` ` ? ` ` latter mean letter position unreadable guarantee sum lengths among test case n't exceed 5·105 hack use test one test case test case print two line first line print number possible periods replace unreadable letter ` ` v '' ` ` k '' next line print value increase order first test case example obtain example ` ` vkkvk '' periods 3 5 . second test case obtain ` ` <unknown> '' periods 1 6 . third test case string ` ` <unknown> '' periods 2 4 string ` ` <unknown> '' periods 3 4,['math'],2700.0
830/B,"vasily a deck card consist n card integer card integer 1 100 000 inclusive possible card integers vasily decide sort card , repeatedly take top card deck number equal minimum number write card deck place card away otherwise put deck take next card top , process end soon card deck assume vasily always know minimum number write card remain deck n't know card ( card ) determine total number time vasily take top card deck first line contain single integer n ( 1 ≤ n ≤ 100 000 ) — number card deck second line contain a sequence n integers a1 a2 ... ( 1 ≤ ai ≤ 100 000 ) ai number write i - th top card deck print total number time vasily take top card deck first example vasily first look card number 6 put deck card number 3 put deck card number 1 . place away card 1 number write minimum among remain card card top bottom [ 2 6 3 ] vasily look top card number 2 put away card top bottom [ 6 3 ] vasily look card 6 put deck card 3 put away one card number 6 vasily look put away thus total vasily look 7 card","['data structures', 'implementation']",1600.0
835/A,"two boys decide compete text type site ` ` key race '' competition type a text consist s character first participant type one character v1 milliseconds ping t1 milliseconds second participant type one character v2 milliseconds ping t2 milliseconds connection ping ( delay ) t milliseconds competition pass a participant follow : winner participant whose information success come earlier information come participants time consider a draw give length text information participants determine result game first line contain five integers s v1 v2 t1 t2 ( 1 ≤ s v1 v2 t1 t2 ≤ 1000 ) — number character text time type one character first participant time type one character second participant ping first participant ping second participant first participant win print ` ` first '' second participant win print ` ` second '' case a draw print ` ` friendship '' first example information success first participant come 7 milliseconds second participant — 14 milliseconds , first win second example information success first participant come 11 milliseconds second participant — 5 milliseconds , second win third example information success first participant come 22 milliseconds second participant — 22 milliseconds , a draw",['math'],800.0
837/D,let 's call roundness number number zero end array n number need choose a subset exactly k number roundness product select number maximum possible first line contain two integer number n k ( 1 ≤ n ≤ 200 1 ≤ k ≤ n ) second line contain n space - separated integer number a1 a2 ... ( 1 ≤ ai ≤ 1018 ) print maximal roundness product choose subset length k. first example 3 subsets 2 number [ 50 4 ] product 200 roundness 2 [ 4 20 ] — product 80 roundness 1 [ 50 20 ] — product 1000 roundness 3 . second example subset [ 15 16 25 ] product 6000 roundness 3 . third example subsets product roundness 0,"['dp', 'math']",2100.0
838/C,alice bob play a game a string character alice go first string consist n character one first k letter alphabet a player ’ s turn either arbitrarily permute character word delete exactly one character word ( least one character ) addition result word appear throughout entire game player unable make a valid move lose game give n k p find number word exactly n character consist first k letter alphabet alice win alice bob play optimally return number modulo prime number p. first line input contain three integers n k p ( 1 ≤ n ≤ 250 000 1 ≤ k ≤ 26 108 ≤ p ≤ 109 + 100 p prime ) print a single integer number win word alice modulo p. 14 string alice win example string ` ` bbaa '' ` ` <unknown> '' alice lose string like ` ` aaaa '' ` ` bbbb '',['dp'],2800.0
838/D,airplane n row front back m people board airplane airplane entrance front back plane person assign seat possible multiple people assign seat people board plane one one start person 1 . person independently choose either front entrance back entrance enter plane a person walk plane walk directly assign seat try sit occupy continue walk direction walk empty seat - take earliest empty seat find get end row without find a seat angry find number ways assign ticket passengers board plane without anyone get angry two ways different exist a passenger choose a different entrance ways assign seat different print count modulo 109 + 7 . first line input contain two integers n m ( 1 ≤ m ≤ n ≤ 1 000 000 ) number seat number passengers respectively print a single number number ways modulo 109 + 7 . denote a passenger seat assign side come ( either ` ` f '' ` ` b '' front back respectively ) example one valid way 3b 3b 3b ( i.e passengers assign seat 3 come back entrance ) another valid way would 2f <unknown> 3f one invalid way would 2b 2b 2b since third passenger would get front without find a seat,['math'],2700.0
839/D,winter north white walkers close john snow army consist n soldier rest world fight iron throne go get ready attack white walkers create a method know strong army let i - th soldier ’ s strength ai k call i1 i2 ... ik a clan i1 < i2 < i3 < ... < ik gcd ( ai1 ai2 ... aik ) > 1 call strength clan <unknown> ( ai1 ai2 ... aik ) define strength army sum strengths possible clans task find strength army number may large print modulo 1000000007 ( 109 + 7 ) greatest common divisor ( gcd ) a sequence integers maximum possible integer element sequence divisible first line contain integer n ( 1 ≤ n ≤ 200000 ) — size army second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 1000000 ) — denote strengths soldier print one integer — strength john snow 's army modulo 1000000007 ( 109 + 7 ) first sample clans { 1 } { 2 } { 1 2 } answer 1·3 + 1·3 + 2·3 = 12,"['dp', 'math']",2200.0
840/B,leha play a computer game level give a connect graph n vertices m edge graph contain multiple edge contain self loop vertex integer di equal 0 1 - 1 . pass level need find a « good » subset edge graph say n't exist subset call « good » leave edge subset original graph obtain follow : every vertex i di = - 1 's degree modulo 2 equal di leha want pass game soon possible ask help case multiple correct answer print first line contain two integers n m ( 1 ≤ n ≤ 3·105 n - 1 ≤ m ≤ 3·105 ) — number vertices edge second line contain n integers d1 d2 ... dn ( - 1 ≤ di ≤ 1 ) — number vertices next m line contain two integers u v ( 1 ≤ u v ≤ n ) — edge 's guarantee graph input connect print - 1 a single line solution n't exist otherwise first line k — number edge a subset next k line index edge edge numerate order give input start 1 . first sample single vertex without edge 's degree 0 get 1,"['data structures', 'dp']",2100.0
840/C,a year ago bench public park leha find array n number leha believe permutation p right 1 ≤ i < n condition <unknown> + 1 perfect square hold leha want find number right permutations modulo 109 + 7 . first line input data contain single integer n ( 1 ≤ n ≤ 300 ) — length array next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — find array output single integer — number right permutations modulo 109 + 7 . first example : [ 1 2 4 ] — right permutation 2 8 perfect square [ 1 4 2 ] — wrong permutation 4 square 2 [ 2 1 4 ] — wrong permutation 4 square 2 [ 2 4 1 ] — wrong permutation 4 square 2 [ 4 1 2 ] — wrong permutation 4 square 2 [ 4 2 1 ] — right permutation 8 2 perfect square,['dp'],2500.0
841/B,leha somehow find array consist n integers look come a task two players play game array players move one one first player choose move a subsegment non - zero length odd sum number remove array remain part glue together one array game continue second player choose a subsegment non - zero length even sum remove lose one make a move win play optimally ? first line input data contain single integer n ( 1 ≤ n ≤ 106 ) — length array next line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 109 ) output answer single line ` ` first '' first player win ` ` second '' otherwise ( without quote ) first sample first player remove whole array one move win second sample first player ca n't make a move lose,['math'],1100.0
846/B,polycarp take part a math show give n task consist k subtasks number 1 k. take tj minutes solve j - th subtask task thus time require solve a subtask depend index task polycarp solve subtasks order solve subtask arbitrary problem earn one point thus number point task equal number solve subtasks moreover polycarp completely solve task ( solve k subtasks ) recieves one extra point thus total number point recieves complete solution task k + 1 . polycarp m minutes time maximum number point earn ? first line contain three integer number n k m ( 1 ≤ n ≤ 45 1 ≤ k ≤ 45 0 ≤ m ≤ 2·109 ) second line contain k integer number value tj ( 1 ≤ tj ≤ 1000000 ) tj time minutes require solve j - th subtask task print maximum amount point polycarp earn m minutes first example polycarp complete first task spend 1 + 2 + 3 + 4 = 10 minutes also time solve one subtask second task one minute second example polycarp solve first subtask five task spend 5·1 = 5 minutes also solve second subtasks two task spend 2·2 = 4 minutes thus earn 5 + 2 = 7 point total,['greedy'],1800.0
847/I,"berland 's capital form a rectangle size n × m quarter quarter divide three type : a quarter label letter ' a ' produce q units noise a quarter label letter ' b ' produce <unknown> units noise , a quarter label letter ' z ' produce <unknown> units noise number quarter label letter city propagate source noise noise level halve move one quarter a quarter share a side ( odd number halve 's round ) noise spread along chain example quarter locate a distance 2 noise source value noise reach quarter divide 4 . noise level come source quarter determine solely length shortest path heavily built - up quarter obstacles noise penetrate noise level quarter define sum noise source <unknown> quality life population capital berland require find number quarter whose noise level exceed allow level p. first line contain four integers n m q p ( 1 ≤ n m ≤ 250 1 ≤ q p ≤ 106 ) — size berland 's capital number noise units a quarter ' a ' produce allowable noise level follow n line contain m character — description capital quarter format describe statement possible berland 's capital quarter type print number quarter noise level exceed allow level p. illustration first example main part statement","['implementation', 'math']",1900.0
847/K,even polycarp decide analyze today 's travel expense public transport bus system capital berland arrange a way bus run along route two stop bus intermediate stop bus continuously run along route one stop back one bus run a pair stop polycarp make n trip bus trip stop start trip stop finish know trip follow chronological order polycarp 's note know one trip bus cost a burl case passenger make a transshipment cost trip decrease b burl ( b < a ) a passenger make a transshipment stop board bus coincide stop leave previous bus obviously first trip make transshipment example polycarp make three consecutive trip : ` ` berbank '' ` ` university '' ` ` university '' ` ` bermall '' ` ` university '' ` ` berbank '' pay a + b + a = 2a + b burl berbank arrive university make transshipment bus depart bermall walk university return berbank bus also polycarp buy k travel card travel card cost f burl travel card a single bus route make free charge trip route ( directions ) purchase a travel card use number time direction smallest amount money polycarp could spend today buy k travel card ? first line contain five integers n a b k f ( 1 ≤ n ≤ 300 1 ≤ b < a ≤ 100 0 ≤ k ≤ 300 1 ≤ f ≤ 1000 ) : follow n line describe trip chronological order line contain exactly two different word separate a single space — name start stop name finish stop trip name consist uppercase lowercase english letter lengths 1 20 letter inclusive uppercase lowercase letter consider different print smallest amount money polycarp could spend today purchase k travel card first example polycarp buy travel card route ` ` berbank university '' spend 8 burl note second trip ` ` university '' ` ` bermall '' make transshipment trip polycarp pay 3 burl minimum total sum equal 8 + 3 = 11 burl second example n't make sense buy travel card note polycarp trip ( except first ) make transshipment minimum total sum equal 2 + 1 + 1 + 1 = 5 burl,"['greedy', 'implementation']",1800.0
849/A,<unknown> begin end ? hope <unknown> ever break ? give integer sequence a1 a2 ... length n. decide whether possible divide odd number non - empty subsegments odd length begin end odd number a subsegment a contiguous slice whole sequence example { 3 4 5 } { 1 } subsegments sequence { 1 2 3 4 5 6 } { 1 2 4 } { 7 } first line input contain a non - negative integer n ( 1 ≤ n ≤ 100 ) — length sequence second line contain n space - separated non - negative integers a1 a2 ... ( 0 ≤ ai ≤ 100 ) — elements sequence output ` ` yes '' 's possible fulfill requirements ` ` '' otherwise output letter case ( upper lower ) first example divide sequence 1 subsegment : { 1 3 5 } requirements meet second example divide sequence 3 subsegments : { 1 0 1 } { 5 } { 1 } third example one subsegments must start 4 even number thus requirements meet fourth example sequence divide 2 subsegments : { 3 9 9 } { 3 } a valid solution 2 even number,['implementation'],1000.0
85/B,embassy a well - known kingdom electronic queue organise every person come embassy need make follow three action : show i d pay money cashier fingerprint besides action perform give order action several separate windows single : k1 separate windows first action ( first type windows ) k2 windows second one ( second type windows ) k3 third one ( third type windows ) service time one person first type window equal t1 similarly take t2 time serve a person second type windows take t3 serve one person third type windows thus service time depend window type independent person apply visa moment n people come embassy i - th person come moment time ci person register number sit hall wait number show a special board besides person 's number board show number window one go person go immediately let 's consider time need approach window negligible table show information one person a time electronic queue work immediately start work person approach window people front window client service quality inspectors notice several people spend much time embassy ( particularly tiresome embassy mobile phone reception 3 g ) decide organise system largest time a person spend embassy minimum help inspectors organise queue consider action except serve window happen instantly first line contain three space - separated integers k1 k2 k3 ( 1 ≤ ki ≤ 109 ) number windows first second third type correspondingly second line contain three space - separated integers t1 t2 t3 ( 1 ≤ ti ≤ 105 ) periods time need serve one person window first second third type correspondingly third line contain integer n ( 1 ≤ n ≤ 105 ) number people fourth line contain n space - separated integers ci ( 1 ≤ ci ≤ 109 ) non - decreasing order ; ci time person number i come embassy print single number maximum time a person spend embassy queue organize optimally please use % lld specificator read write 64 - bit integers c++ prefer use cin cout stream ( also may use % i64d specificator ) first test 5 people come simultaneously moment time equal 1 . one window every type take 1 unit time serve window 's maximal time a person spend embassy time need serve windows ( 3 units time ) plus time last person come first window wait ( 4 units time ) windows second test work like : first window first type : [ 1 6 ) — first person [ 6 11 ) — third person [ 11 16 ) — fifth personthe second window first type : [ 2 7 ) — second person [ 7 12 ) — fourth personthe second type window : [ 6 7 ) — first [ 7 8 ) — second [ 11 12 ) — third [ 12 13 ) — fourth [ 16 17 ) — <unknown> third type window : [ 7 8 ) — first [ 8 9 ) — second [ 12 13 ) — third [ 13 14 ) — fourth [ 17 18 ) — <unknown> see take time serve fifth person,"['data structures', 'greedy']",1800.0
850/A,"give set n point 5 - dimensional space point label 1 n. two point coincide call point a bad different point b c equal a give set angle vectors acute ( i.e strictly less ) otherwise point call good angle vectors 5 - dimensional space define <unknown> product length give list point print indices good point ascend order first line input contain a single integer n ( 1 ≤ n ≤ 103 ) — number point next n line input contain five integers ai bi ci di ei ( |ai| |bi| |ci| <unknown> <unknown> ≤ 103 ) — coordinate i - th point point distinct first print a single integer k — number good point , print k integers line — indices good point ascend order first sample first point form exactly a angle pair point good second sample along cd plane see point look follow : see angle acute point good",['math'],1700.0
852/E,"john buy a new car plan a journey around country country n cities connect bidirectional roads n - 1 roads every city reachable city cities label 1 n. john first select city start journey , spend one day a city travel a randomly <unknown> city directly connect current one yet visit ca n't continue obey rule select start city call friend jack advice jack also start a big casino business want open casinos cities ( max 1 per city maybe nowhere ) jack know john well know visit a city a casino gamble exactly continue journey also know john enter a casino a good mood leave a bad mood vice versa since john 's friend want a good mood moment finish journey john a good mood start journey many ways jack select a start city john cities build casinos matter john travel a good mood end ? print answer modulo 109 + 7 . first line a positive integer n ( 1 ≤ n ≤ 100000 ) number cities next n - 1 line two number a b ( 1 ≤ a b ≤ n ) separate a single space mean cities a b connect a bidirectional road output one number answer problem modulo 109 + 7 . example 1 : jack select city 1 john 's start city either build 0 casinos john happy time build a casino cities john would visit a casino city 1 become unhappy go city 2 visit a casino become happy journey end ca n't go back city 1 . jack select city 2 start everything symmetrical answer 4 . example 2 : jack tell john start city 1 either build casinos 0 2 cities ( total 4 possibilities ) tell start city 2 john 's journey either contain cities 2 1 2 3 . therefore jack either build casinos build three cities options risk john end journey unhappy start 3 symmetric start 1 total 4 + 2 + 4 = 10 options",['dp'],2100.0
853/D,michael buy a new electric car move across city michael like overwork day drive one two job michael 's day start charge electric car get work back spend 1000 burl charge go first job 2000 burl go second job a charge station use a <unknown> program involve bonus card bonus card may non - negative amount bonus burl time customer go buy something price x burl allow pay amount y ( 0 ≤ y ≤ x ) burl exceed bonus card balance bonus burl case pay x - y burl cash balance bonus card decrease y bonus burl customer pay whole price cash ( i.e. y = 0 ) 10 % price return back bonus card mean bonus card balance increase bonus burl initially bonus card balance equal 0 bonus burl michael plan next n days know much charge cost days help michael determine minimum amount burl cash spend optimal use bonus card assume michael able cover part price cash day necessary spend bonus burl end give period first line input contain a single integer n ( 1 ≤ n ≤ 300 000 ) number days michael plan next line contain n integers a1 a2 ... ( ai = 1000 ai = 2000 ) ai denote charge cost day i. output minimum amount burl michael spend first sample case optimal way michael pay first two days spend 3000 burl get 300 bonus burl return able pay 700 burl third days cover rest price bonus burl second sample case optimal way michael pay whole price first five days get 1000 bonus burl return able use last day without pay anything cash,"['dp', 'greedy']",2400.0
856/F,vasya petya play online game online game hero progress system allow players gain experience make heroes stronger course vasya would like get many experience point possible careful study experience point allocation find play game alone get one experience point second however two players play together current experience value differ c point boost progress get 2 experience point second since vasya petya middle school students parent n't allow play day around friends schedule : vasya play intervals [ a1 ; b1 ] [ a2 ; b2 ] ... [ ; bn ] petya play intervals [ c1 ; d1 ] [ c2 ; d2 ] ... [ cm ; dm ] time periods give second current moment vasya good math notice sometimes profitable play alone experience difference could become big progress would boost even play together would like create schedule play vasya 's final experience greatest possible current players experience petya concern experience ready cooperate play need maximize vasya 's experience first line input data contain integers n m c — number intervals vasya play number intervals petya play maximal difference experience level play together still give a progress boost ( 1 ≤ n m ≤ 2·105 0 ≤ c ≤ 1018 ) follow n line contain two integers : ai bi — intervals vasya play ( 0 ≤ ai < bi ≤ 1018 bi < ai + 1 ) follow m line contain two integers : ci di — intervals petya play ( 0 ≤ ci < di ≤ 1018 di < ci + 1 ) output one integer — maximal experience vasya end players try maximize value,['greedy'],3000.0
858/E,all - berland national olympiad informatics end ! vladimir want upload contest olympiad a gym a popular codehorses website unfortunately archive olympiad 's data a mess example file test name arbitrary without logic vladimir want rename file test name distinct integers start 1 without gap namely ` ` 1 '' ` ` 2 '' ... ` ` n ' n total number test file contain test statements ( examples ) others contain regular test possible examples possible test examples vladimir want rename file examples first several test next file contain regular test operation vladimir perform ` ` move '' command vladimir want write a script file line ` ` move file_1 file_2 '' mean file ` ` file_1 '' rename ` ` file_2 '' a file ` ` file_2 '' moment line run file rewrite line ` ` move file_1 file_2 '' file ` ` file_1 '' n't exist a file ` ` file_2 '' content equal content ` ` file_1 '' ` ` move '' command help vladimir write script file minimum possible number line script run : first line contain single integer n ( 1 ≤ n ≤ 105 ) — number file <unknown> line follow describe a file test line a form ` ` name_i type_i '' ` ` name_i '' filename ` ` type_i '' equal ` ` 1 '' i - th file contain example test ` ` 0 '' contain a regular test filenames file string digits small english letter length 1 6 character filenames guarantee distinct first line print minimum number line vladimir 's script file print script file line ` ` move file_1 file_2 '' ` ` file_1 '' exist moment line run filename ` ` file_2 '' — a string digits small english letter length 1 6,"['greedy', 'implementation']",2200.0
859/F,'s another start [ c ] mean t - shirts order order make sure t - shirts ship soon possible ' ve decide year 're go order necessary t - shirts actual competition top c contestants go award t - shirts obviously n't know contestants plan get t - shirt size contestants actual competition order enough t - shirts matter top c 'll t - shirts available order award order get t - shirt size contestants send a survey survey allow contestants either specify a single desire t - shirt size two adjacent t - shirt size a contestant specify two size mean award either size probably tell plan could require order a lot unnecessary t - shirts 'd like help determine minimum number t - shirts 'll need order ensure 'll able award t - shirts matter outcome competition input begin two integers n c ( 1 ≤ n ≤ 2·105 1 ≤ c ) number t - shirt size number t - shirts award respectively follow a line 2·n - 1 integers s1 <unknown> - 1 ( 0 ≤ si ≤ 108 ) odd i si indicate number contestants desire t - shirt size ( ( i + 1 ) / 2 ) even i si indicate number contestants okay receive either t - shirt size ( i / 2 ) ( i / 2 + 1 ) c exceed total number contestants print minimum number t - shirts need buy first example buy 100 size,['greedy'],2800.0
86/B,<unknown> woll like play one relax game search theory everything game interface consist a rectangular n × m play field a dashboard initially cells play field fill others empty dashboard contain image various connect ( mean connectivity side ) figure 2 3 4 5 cells rotations reflections player copy figure dashboard place anywhere still empty cells play field course figure use many time need woll 's aim fill whole field a way empty cells leave also ... fun every initially empty cell fill exactly one cell figure every figure entirely inside board picture black cells stand initially fill cells field one - colour regions represent figure first line contain integers n m ( 1 ≤ n m ≤ 1000 ) — height width field correspondingly next n line contain m symbols represent field a natural way : j - th character i - th line ` ` # '' correspond cell fill ` ` . '' empty chance win game output number ` ` -1 '' ( without quote ) otherwise output fill field figure follow format : figure represent digit figure touch side represent distinct digits every initially fill cell represent ` ` # '' third sample way fill a cell empty neighbour forth sample woll fill anything output field input,"['greedy', 'math']",2200.0
865/C,"'re try set record favorite video game game consist n level must complete sequentially order beat game usually complete level fast possible sometimes finish a level slower specifically complete i - th level either fi second si second fi < si 's a pi percent chance complete fi second complete a level may decide either continue game play next level reset game start first level decision action instant goal complete level sequentially r total second want minimize expect amount time play achieve goal continue reset optimally much total time expect spend play ? first line input contain integers n r number level number second want complete game respectively n line follow ith line contain integers fi si pi ( 1 ≤ fi < si ≤ 100 80 ≤ pi ≤ 99 ) fast time level i slow time level i probability ( a percentage ) complete level i fast time print total expect time answer must correct within absolute relative error 10 - 9 . formally let answer a jury 's answer b. answer consider correct , first example never need reset 's 81 % chance complete level 2 second a 19 % chance need 8 second within goal time expect time <unknown> + <unknown> = <unknown> . second example reset first level complete slowly average take 0.25 slow attempt first fast attempt n't matter whether complete second level fast slow expect time <unknown> + 20 + <unknown> + <unknown> = <unknown>",['dp'],2400.0
867/A,"may know memsql american offices san francisco seattle a manager company travel a lot two cities always plane prefer fly seattle san francisco direction 's <unknown> san francisco busy n't remember number flight make either direction however last n days know whether san francisco office seattle office always fly nights never offices day give information determine fly time seattle san francisco last n days , first line input contain single integer n ( 2 ≤ n ≤ 100 ) — number days second line contain a string length n consist capital 's ' ' f ' letter i - th letter 's ' seattle office day otherwise san francisco days give chronological order i.e today last day sequence print ` ` yes '' fly time seattle san francisco ` ` '' otherwise print letter case ( upper lower ) first example initially san francisco fly seattle two days return san francisco make one flight direction answer ` ` '' second example fly seattle san francisco answer ` ` yes '' third example stay whole period san francisco answer ` ` '' fourth example replace 's ' ones ' f ' zero 'll get first digits π binary representation useful information though",['implementation'],800.0
869/A,"rock ... paper ! karen find deterministic win ( lose ? ) strategy rock - paper - scissors brother koyomi come a new game a substitute game work follow a positive integer n decide first koyomi karen independently choose n distinct positive integers denote x1 x2 ... xn y1 y2 ... yn respectively reveal sequence repeat 2n integers become distinct final state keep consider count number order pair ( i j ) ( 1 ≤ i j ≤ n ) value xi xor yj equal one 2n integers xor mean bitwise exclusive operation two integers denote operators ^ and/or xor program languages karen claim a win number pair even koyomi otherwise 're help determine winner latest game first line input contain a positive integer n ( 1 ≤ n ≤ 2 000 ) — length sequence second line contain n space - separated integers x1 x2 ... xn ( 1 ≤ xi ≤ 2·106 ) — integers finally choose koyomi third line contain n space - separated integers y1 y2 ... yn ( 1 ≤ yi ≤ 2·106 ) — integers finally choose karen input guarantee give 2n integers pairwise distinct , pair ( i j ) ( 1 ≤ i j ≤ n ) exist one follow hold : xi = yj ; i ≠ j xi = xj ; i ≠ j yi = yj output one line — name winner , ` ` koyomi '' ` ` karen '' ( without quote ) please aware capitalization first example 6 pair satisfy constraint : ( 1 1 ) ( 1 2 ) ( 2 1 ) ( 2 3 ) ( 3 2 ) ( 3 3 ) thus karen win since 6 even number second example 16 pair karen win",['implementation'],1100.0
870/F,give a positive integer n. let 's build a graph vertices 1 2 ... n a way edge vertices u v let d ( u v ) shortest distance u v 0 path compute sum value d ( u v ) 1 ≤ u < v ≤ n. gcd ( greatest common divisor ) two positive integers maximum positive integer divide integers single integer n ( 1 ≤ n ≤ 107 ) print sum d ( u v ) 1 ≤ u < v ≤ n. shortest paths first example : paths pair vertices total distance 2 + 1 + 1 + 2 + 1 + 1 = 8,['data structures'],2700.0
873/C,"ivan play a strange game a matrix a n row m columns element matrix equal either 0 1 . row columns 1 - indexed ivan replace number ones matrix zero , score game calculate follow : course ivan want maximize score strange game also n't want change many elements replace minimum possible number ones zero help determine maximum possible score get minimum possible number replacements require achieve score first line contain three integer number n m k ( 1 ≤ k ≤ n ≤ 100 1 ≤ m ≤ 100 ) n line follow i - th contain m integer number — elements i - th row matrix a. number either 0 1 . print two number : maximum possible score ivan get minimum number replacements require get score first example ivan replace element a1 2",['greedy'],1600.0
875/B,"recently dima meet sasha a <unknown> store since collect coin together favorite <unknown> sort <unknown> coin sasha like things order want coin arrange a row a way firstly come coin circulation come coin still circulation arrange coin dima use follow algorithm one step algorithm look like follow : dima repeat procedure happen two coin exchange procedure dima call hardness order number step require accord algorithm sort sequence e.g number time look coin begin example order sequence hardness order equal one today sasha invite dima propose a game first put n coin a row circulation sasha choose one coin circulation replace a coin circulation n time process sasha constantly ask dima hardness order sequence task complicate dima touch coin determine hardness order mind help dima task first line contain single integer n ( 1 ≤ n ≤ 300 000 ) — number coin sasha put behind dima second line contain n distinct integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) — position sasha put coin circulation first sasha replace coin locate position p1 coin locate position p2 coin number leave right print n + 1 number a0 a1 ... , a0 a hardness order begin a1 a hardness order first replacement let 's denote o coin circulation x — coin circulation first sample initially row coin circulation dima look leave right wo n't make exchange replacement first coin a coin circulation dima exchange coin next three time finally look coin finish process <unknown> → <unknown> replacement third coin dima 's action look way : <unknown> → <unknown> → <unknown> replacement fourth coin dima 's action look way : <unknown> → <unknown> replacement second coin row become consist coin circulation dima look coin leave right without exchange",['implementation'],1500.0
877/B,one day nikita find string contain letter ` ` a '' ` ` b '' nikita think string beautiful cut 3 string ( possibly empty ) without change order letter 1 - st 3 - rd one contain letter ` ` a '' 2 - nd contain letter ` ` b '' nikita want make string beautiful remove ( possibly none ) character without change order maximum length string get ? first line contain a non - empty string length greater 5 000 contain lowercase english letter ` ` a '' ` ` b '' print a single integer — maximum possible size beautiful string nikita get first sample string already beautiful second sample need delete one ` ` b '' make beautiful,['dp'],1500.0
879/A,"seem borya seriously sick go visit n doctor find exact <unknown> doctor need information previous visit borya visit prescribe order ( i.e borya first visit doctor 1 doctor 2 doctor 3 ) borya get information health last doctor doctor a strange work schedule doctor i go work si - th day work every di day , work days si si + di si + <unknown> .... doctor 's appointment take quite a long time borya see one doctor per day minimum time need visit doctor ? first line contain integer n — number doctor ( 1 ≤ n ≤ 1000 ) next n line contain two number si di ( 1 ≤ si di ≤ 1000 ) output a single integer — minimum day borya visit last doctor first sample case borya visit doctor days 2 3 4 . second sample case borya visit doctor days 10 11",['implementation'],900.0
883/D,game field represent a line n square cells cells packmen cells asterisk rest cells empty packmen eat asterisk game start choose a movement direction leave right packman game begin packmen simultaneously start move accord directions a packman ca n't change give direction a packman enter a cell contain asterisk packman immediately eat asterisk packman leave cell become empty packman move speed 1 cell per second a packman enter a border cell packman stop packmen interfere movement packmen ; one cell number packmen move directions task assign a direction packman eat maximal number asterisk multiple ways assign directions eat maximal number asterisk choose way minimize time first line contain integer number n ( 2 ≤ n ≤ 1 000 000 ) — number cells game field second line contain n character i - th character ' ' i - th cell empty i - th character ' * ' i - th cell contain asterisk i - th character ' p ' i - th cell contain a packman field contain least one asterisk least one packman print two integer number — maximal number asterisk packmen eat minimal time first example leftmost packman move right rightmost packman move leave asterisk eat last asterisk eat 4 second,"['dp', 'math']",2500.0
883/I,evlampiy find one cool application process photos however application certain limitations photo i a contrast vi order process truly high quality application must receive least k photos contrast differ little possible evlampiy already know contrast vi n photos want split photos group group contain least k photos a result photo must belong exactly one group consider a process time j - th group difference maximum minimum value vi group <unknown> process time a division group maximum process time among group split n photos group a way process time division minimum possible i.e maximum process time group least possible first line contain two integers n k ( 1 ≤ k ≤ n ≤ 3·105 ) — number photos minimum size a group second line contain n integers v1 v2 ... vn ( 1 ≤ vi ≤ 109 ) vi contrast i - th photo print minimal process time division group first example photos split 2 group : [ 40 50 ] [ 110 120 130 ] process time first group 10 process time second group 20 . maximum among 10 20 20 . impossible split photos group a way process time division less 20 . second example photos split four group contain one photo minimal possible process time a division 0,['dp'],1900.0
883/L,berland taxi a new taxi company k cars start operate capital berland recently capital n house a straight line number 1 ( leftmost ) n ( rightmost ) distance two neighbor house help company schedule taxi rid come throughout day accord follow rule : a request taxi ride receive time ti berland taxi operator assign a car follow : a car get assign taxi ride request : available cars time ti a request taxi ride come : operator process taxi ride request one one multiple passengers wait cars become available operator move process ( i + 1 ) -th ride request car get assign i - th ride request task write a program process give list m taxi ride request request find car get assign long passenger wait a car arrive note already car locate house ai correspond wait time 0 . first line input contain integers n k m ( 2 ≤ n ≤ 2·105 1 ≤ k m ≤ 2·105 ) — number house number cars number taxi ride request second line contain integers x1 x2 ... xk ( 1 ≤ xi ≤ n ) — initial position cars xi a house number i - th car locate initially 's allow one car locate next house follow m line contain information ride request ride request represent integers tj aj bj ( 1 ≤ tj ≤ 1012 1 ≤ aj bj ≤ n aj ≠ bj ) tj time minutes a request make aj a house passenger need pick bj a house passenger need drop taxi ride request give increase order tj tj distinct print m line : j - th line contain two integer number answer j - th ride request — car number assign operator passenger wait time first sample test a request come time 5 car need get house 3 house 2 pick passenger therefore wait time 1 ride complete time 5 + 1 + 6 = 12 . second request come time 9 passenger wait car become available time 12 car need another 2 minutes get house 8 house 10 . total wait time 3 + 2 = 5 . second sample test cars 1 2 locate distance first passenger ` ` wait time since become available '' car 1 win a <unknown> accord rule lowest number come house 3 time 3 wait time 2,['data structures'],2500.0
886/E,one day petya solve a interest problem although use many optimization techniques solution still get time limit exceed verdict petya conduct a thorough analysis program find function find maximum element array n positive integers slow desperate petya decide use a somewhat unexpected optimization use parameter k function contain follow code : way function iteratively check array elements store intermediate maximum k consecutive iterations maximum change return answer petya interest fault rate function ask find number permutations integers 1 n return value function permutations equal n. since number could big output answer modulo 109 + 7 . line contain two integers n k ( 1 ≤ n k ≤ 106 ) separate a space — length permutations parameter k. output answer problem modulo 109 + 7 . permutations second example : [ 4 1 2 3 5 ] [ 4 1 3 2 5 ] [ 4 2 1 3 5 ] [ 4 2 3 1 5 ] [ 4 3 1 2 5 ] [ 4 3 2 1 5 ],"['dp', 'math']",2400.0
887/A,top - model izabella participate competition want impress judge show mathematical skills problem follow : give string consist 0 1 tell 's possible remove digits a way remain number a representation positive integer divisible 64 binary numerical system line give a non - empty binary string s length 100 . print « yes » ( without quote ) 's possible remove digits require way « » otherwise first test case get string 1 000 000 remove two ones a representation number 64 binary numerical system read binary numeral system representation : https : //en.wikipedia.org / wiki / <unknown>,['implementation'],1000.0
887/D,two main kinds events life top - model : fashion show photo shoot participate events affect rat appropriate top - model photo shoot model 's rat increase a fashion show decrease b ( designers many experiment nowadays ) moreover sometimes top - <unknown> participate talk show participate talk show model become popular increase rat photo shoot become c decrease rat fashion show become d. izabella want participate a talk show want a way rat never become negative help find a suitable moment participate talk show let 's assume model 's career begin moment 0 . moment izabella 's rat equal start talk show happen moment t affect events model 's life interval time [ t .. t + len ) ( include t include t + len ) len duration influence izabella want participate a talk show want a way rat become become negative talk show period influence talk show help find a suitable moment participate talk show first line 7 positive integers n a b c d start len ( 1 ≤ n ≤ 3·105 0 ≤ start ≤ 109 1 ≤ a b c d len ≤ 109 ) n a number fashion show photo shoot a b c d rat change describe start initial rat model len a duration influence talk show next n line descriptions events give line contain two integers ti qi ( 1 ≤ ti ≤ 109 0 ≤ q ≤ 1 ) — moment event happen type event type 0 correspond fashion show type 1 — photo shoot events give order increase ti ti different print one non - negative integer t — moment time talk show happen make izabella 's rat non - negative talk show period influence talk show multiple answer print smallest moments print - 1,['data structures'],2400.0
888/B,ivan a robot situate infinite grid initially robot stand start cell ( 0 0 ) robot process command four type command perform : ivan enter a sequence n command robot process sequence robot end start cell ( 0 0 ) ivan doubt sequence perform correctly robot end cell think command ignore robot acknowledge whether robot severely bug need calculate maximum possible number command perform correctly help ivan calculations ! first line contain one number n — length sequence command enter ivan ( 1 ≤ n ≤ 100 ) second line contain sequence — a string consist n character character u d l r. print maximum possible number command sequence robot could perform end start cell,['greedy'],1000.0
89/B,vasya write library build graphical user interface vasya call creation <unknown> ( <unknown> ) one interest aspects library widgets pack a widget element graphical interface widget width height occupy rectangle screen widget vasya 's library type widget simplicity identify widget type type hbox vbox <unknown> type widget also type widget widgets hbox vbox special store widgets widgets use pack ( ) method pack directly widget widgets type hbox vbox store several widgets even several equal widgets — simply appear several time a result use method pack ( ) link pack widget save pack widget change image widget pack also change shall assume widget a pack widget b exist a chain widgets a = c1 c2 ... ck = b k ≥ 2 ci pack directly ci + 1 1 ≤ i < k. vasya 's library situation widget a pack widget a ( ) allow try pack widgets manner immediately result error also widgets hbox vbox parameters border space determine methods <unknown> ( ) <unknown> ( ) respectively default options equal 0 . picture show widgets pack hbox vbox hbox vbox automatically change size depend size pack widgets hbox vbox differ hbox widgets pack horizontally vbox — vertically parameter space set distance adjacent widgets border — a frame around pack widgets desire width pack widgets place exactly order pack ( ) method call within hbox vbox pack widgets size equal 0 × 0 regardless options border space construction widgets perform use a script language vasyascript description language find input data final <unknown> code vasya ask write a program calculate size widgets source code language vasyascript first line contain integer n — number instructions ( 1 ≤ n ≤ 100 ) next n line contain instructions language vasyascript — one instruction per line a list possible instructions instructions write without space begin end string word inside instruction separate exactly one space space directly number directly case matter example ` ` widget x '' a correct instruction case letter correct input data name widgets consist lowercase latin letter length 1 10 character inclusive name widgets pairwise different number script integers 0 100 <unknown> guarantee above - given script correct operations widgets take place widgets create widget pack guarantee script create least one widget widget print a single line name width height separate space line must order lexicographically a widget 's name please use % lld specificator read write 64 - bit integers c++ prefer use cout stream ( also may use % i64d specificator ) first sample widgets arrange follow :,"['dp', 'implementation']",2300.0
891/B,give array a n distinct integers construct array b permute a every non - empty subset indices s = { x1 x2 ... xk } ( 1 ≤ xi ≤ n 0 < k < n ) sum elements position a b different i. e. first line contain one integer n ( 1 ≤ n ≤ 22 ) — size array second line contain n space - separated distinct integers a1 a2 ... ( 0 ≤ ai ≤ 109 ) — elements array array b print -1 . otherwise line print n space - separated integers b1 b2 ... bn note b must a permutation a. multiple answer print array x a permutation y shuffle elements y coincide x. note empty subset subset contain indices count,['greedy'],2000.0
893/D,<unknown> luba get a credit card start use let 's consider n consecutive days luba use card start 0 money account even i - th day a transaction ai occur ai > 0 ai bourles deposit luba 's account ai < 0 ai bourles withdraw ai = 0 amount money luba 's account check morning n days luba go bank deposit positive integer amount burl account a limitation : amount money account never exceed d. happen amount money go greater d transaction even case answer « -1 » luba must exceed limit also want every day account check ( days ai = 0 ) amount money account non - negative take a lot time go bank luba want know minimum number days need deposit money account ( possible meet requirements ) help ! first line contain two integers n d ( 1 ≤ n ≤ 105 1 ≤ d ≤ 109 ) — the number days money limitation second line contain n integer number a1 a2 ... ( - 104 ≤ ai ≤ 104 ) ai represent transaction i - th day print -1 luba deposit money account a way requirements meet otherwise print minimum number days luba deposit money,"['data structures', 'dp', 'greedy', 'implementation']",1900.0
894/C,"a dream marco meet elderly man a pair black glass man tell key <unknown> disappear wind time wake remember key a sequence positive integers length n forget exact sequence let elements sequence a1 a2 ... , remember calculate gcd ( ai ai + 1 ... aj ) every 1 ≤ i ≤ j ≤ n put a set s. gcd mean greatest common divisor note even a number put set s twice appear set marco give set s ask help figure initial sequence many solutions print also possible sequence produce set s case print -1 . first line contain a single integer m ( 1 ≤ m ≤ 1000 ) — size set s. second line contain m integers s1 s2 ... sm ( 1 ≤ si ≤ 106 ) — elements set s. 's guarantee elements set give strictly increase order mean s1 < s2 < ... < sm solution print a single line contain -1 . otherwise first line print a single integer n denote length sequence n exceed 4000 . second line print n integers a1 a2 ... ( 1 ≤ ai ≤ 106 ) — sequence show a solution exist a solution n exceed 4000 ai exceed 106 . multiple solutions print first example 2 = gcd ( 4 6 ) elements set appear sequence show value different 2 4 6 12 among gcd ( ai ai + 1 ... aj ) every 1 ≤ i ≤ j ≤ n",['math'],1900.0
894/E,"ralph go collect mushroom mushroom forest m direct paths connect n tree mushroom forest path grow mushroom ralph pass a path collect mushroom path mushroom forest a magical fertile grind mushroom grow a fantastic speed new mushroom regrow soon ralph finish mushroom collection a path specifically ralph pass a path i - th time regrow i mushroom less pass , initially x mushroom a path ralph collect x mushroom first time x - 1 mushroom second time x - 1 - 2 mushroom third time , however number mushroom never less 0 . example let 9 mushroom a path initially number mushroom collect path 9 8 6 3 ralph pass first fourth time fifth time later ralph ca n't collect mushroom path ( still pass ) ralph decide start tree s. many mushroom collect use describe paths ? first line contain two integers n m ( 1 ≤ n ≤ 106 0 ≤ m ≤ 106 ) represent number tree number direct paths mushroom forest respectively follow m line contain three integers x y w ( 1 ≤ x y ≤ n 0 ≤ w ≤ 108 ) denote a path lead tree x tree y w mushroom initially paths lead a tree multiple paths pair tree last line contain a single integer s ( 1 ≤ s ≤ n ) — start position ralph print integer denote maximum number mushroom ralph collect route first sample ralph pass three time circle collect 4 + 4 + 3 + 3 + 1 + 1 = 16 mushroom mushroom ralph collect second sample ralph go tree 3 collect 8 mushroom path tree 1 tree 3",['dp'],2100.0
895/A,students vasya petya study bsu ( byteland state university ) one break decide order a pizza problem pizza a circle radius pizza deliver already cut n piece i - th piece a sector angle equal ai vasya petya want divide piece pizza two continuous sectors way difference angle sectors minimal sector angle sum angle piece pay attention one sectors empty first line contain one integer n ( 1 ≤ n ≤ 360 ) — number piece deliver pizza cut second line contain n integers ai ( 1 ≤ ai ≤ 360 ) — angle sectors pizza cut sum ai 360 . print one integer — minimal difference angle sectors go vasya petya first sample vasya take 1 2 piece petya take 3 4 piece answer | ( 90 + 90 ) - ( 90 + 90 ) | = 0 . third sample one piece pizza take one vasya petya answer <unknown> - 0| = 360 . fourth sample vasya take 1 4 piece petya take 2 3 piece answer | ( 170 + 10 ) - ( 30 + 150 ) | = 0 . picture <unknown> fourth sample : red green sectors consist two adjacent piece pizza vasya take green sector petya take red sector,['implementation'],1200.0
898/E,ann borya n pile candy n even number ai candy pile number i. ann like number square integer borya n't like number square integer one move guy select pile candy add one candy ( candy new n't belong pile ) remove one candy ( least one candy pile ) find minimal number move require make exactly n / 2 pile contain number candy a square integer exactly n / 2 pile contain number candy a square integer first line contain one even integer n ( 2 ≤ n ≤ 200 000 ) — number pile candy second line contain sequence integers a1 a2 ... ( 0 ≤ ai ≤ 109 ) — amount candy pile output minimal number step require make exactly n / 2 pile contain number candy a square integer exactly n / 2 pile contain number candy a square integer condition already satisfy output 0 . first example satisfy condition two move move add one candy second pile size second pile become 16 . borya ann two pile number candy a square integer ( second fourth pile ) two pile number candy a square integer ( first third pile ) second example add two candy three pile,['greedy'],1600.0
899/F,petya a string length n consist small large english letter digits perform m operations operation describe two integers l r a character c : petya remove string character c position l r inclusive 's obvious length string remain decrease operation find string look like petya perform m operations first string contain two integers n m ( 1 ≤ n m ≤ 2·105 ) — length string number operations second line contain string length n consist small large english letter digits position string enumerate 1 . next m line contain two integers l r ( 1 ≤ l ≤ r ) follow a character c a small large english letter a digit line describe one operation guarantee r n't exceed length string s current operation print string petya obtain perform m operations string become empty operations print empty line first example first operation letter ' a ' remove string become ` ` bc '' second operation letter ' c ' ( second position ) remove string become ` ` b '' second example first operation petya remove ' 0 ' second position string become ` ` az '' second operations string n't change,['data structures'],2100.0
900/B,a fraction need find first occurrence digit c decimal notation fraction decimal point first contain three single positive integers a b c ( 1 ≤ a < b ≤ 105 0 ≤ c ≤ 9 ) print position first occurrence digit c fraction position number 1 decimal point position print -1 . fraction first example follow decimal notation : first zero stand second position fraction second example follow decimal notation : digit 7 decimal notation fraction,['math'],1300.0
900/D,count number distinct sequence a1 a2 ... ( 1 ≤ ai ) consist positive integers gcd ( a1 a2 ... ) = x number could large print answer modulo 109 + <unknown> mean greatest common divisor line contain two positive integers x y ( 1 ≤ x y ≤ 109 ) print number sequence modulo 109 + 7 . three suitable sequence first test : ( 3 3 3 ) ( 3 6 ) ( 6 3 ) suitable sequence second test,"['dp', 'math']",2000.0
903/G,problem deal a special network network consist two part : part a part b. part consist n vertices ; i - th vertex part a denote ai i - th vertex part b denote bi index i ( 1 ≤ i < n ) a direct edge vertex ai vertex ai + 1 bi bi + 1 respectively capacities edge give input also might several direct edge go part a part b ( never b a ) calculate maximum flow value a1 bn network capacities edge connect ai ai + 1 might sometimes change also maintain maximum flow value change apart network fix ( change part b change edge go a b edge insertions deletions ) take a look example note understand structure network better first line contain three integer number n m q ( 2 ≤ n m ≤ 2·105 0 ≤ q ≤ 2·105 ) — number vertices part number edge go a b number change respectively n - 1 line follow i - th line contain two integers xi yi denote edge ai ai + 1 capacity xi edge bi bi + 1 capacity yi ( 1 ≤ xi yi ≤ 109 ) m line follow describe edge a b. line contain three integers x y z denote edge ax capacity z ( 1 ≤ x y ≤ n 1 ≤ z ≤ 109 ) might multiple edge ax q line follow describe a sequence change network i - th line contain two integers vi wi denote capacity edge avi avi + 1 set wi ( 1 ≤ vi < n 1 ≤ wi ≤ 109 ) firstly print maximum flow value original network print q integers i - th must equal maximum flow value i - th change original network example :,['data structures'],2700.0
909/A,prefer way generate user login polygon concatenate a prefix user 's first name a prefix last name order prefix must non - empty prefix full name typically multiple possible <unknown> person give first last name a user return alphabetically earliest login get ( regardless potential polygon users ) a reminder a prefix a string s substring occur begin s : ` ` a '' ` ` ab '' ` ` abc '' etc prefix string ` ` { abcdef } '' ` ` b '' ' bc '' a string a alphabetically earlier a string b a a prefix b a b coincide position a a letter alphabetically earlier correspond letter b : ` ` a '' ` ` ab '' alphabetically earlier ` ` ac '' ` ` b '' ` ` ba '' alphabetically later ` ` ac '' input consist a single line contain two space - separated string : first last name character string a lowercase english letter length string 1 10 inclusive output a single string — alphabetically earliest possible login form name output give lowercase well,['greedy'],1000.0
911/A,give array n integer number a0 a1 ... - 1 . find distance two closest ( nearest ) minimums guarantee array a minimum occur least two time first line contain positive integer n ( 2 ≤ n ≤ 105 ) — size give array second line contain n integers a0 a1 ... - 1 ( 1 ≤ ai ≤ 109 ) — elements array guarantee array a minimum occur least two time print number — distance two nearest minimums array,['implementation'],1100.0
911/E,let 's suppose array a a stack s ( initially empty ) array b ( also initially empty ) may perform follow operations a s empty : perform operations arbitrary order exist a way perform operations array b sort non - descending order end array a call stack - sortable example [ 3 1 2 ] stack - sortable b sort perform follow operations : operations b = [ 1 2 3 ] [ 3 1 2 ] stack - sortable [ 2 3 1 ] stack - sortable give k first elements permutation p size n ( recall a permutation size n array size n integer 1 n occur exactly ) restore remain n - k elements permutation stack - sortable multiple answer choose answer p lexicographically maximal ( array q lexicographically greater array p iff exist integer k every i < k qi = pi qk > pk ) may swap change first k elements permutation print lexicographically maximal permutation p obtain exist answer output -1 . first line contain two integers n k ( 2 ≤ n ≤ 200000 1 ≤ k < n ) — size a desire permutation number elements give respectively second line contain k integers p1 p2 ... pk ( 1 ≤ pi ≤ n ) — first k elements p. integers pairwise distinct possible restore a stack - sortable permutation p size n first k elements p equal elements give input print lexicographically maximal permutation otherwise print -1,"['data structures', 'greedy', 'implementation']",2000.0
912/D,"grisha celebrate new year ded moroz misha gift sasha a small rectangular pond size n × m divide cells size 1 × 1 inhabit tiny evil fish ( one fish per cell otherwise 'll <unknown> ! ) gift <unknown> also include a square scoop size r × r design fish lower - left corner scoop - net locate cell ( x y ) fish inside square ( x y ) ... ( x + r - 1 y + r - 1 ) get catch note scoop - net lie completely inside pond use unfortunately sasha skilled fish hence throw scoop randomly order frustrate sasha misha decide release k fish empty pond a way expect value number catch fish high possible help misha ! word put k fish pond distinct cells a way scoop - net place a random position among ( n - r + 1 ) · ( m - r + 1 ) possible position average number catch fish high possible line contain four integers n m r k ( 1 ≤ n m ≤ 105 1 ≤ r ≤ min ( n m ) 1 ≤ k ≤ min ( n·m 105 ) ) print a single number — maximum possible expect number catch fish answer consider correct absolute relative error exceed 10 - 9 . namely let answer a jury 's answer b. answer consider correct , first example put fish cells ( 2 1 ) ( 2 2 ) ( 2 3 ) case four possible position scoop - net ( highlight light green ) number fish inside equal two expect value","['data structures', 'greedy']",2100.0
913/A,follow problem well - known : give integers n m <unknown> 2n = 2·2 · ... · 2 ( n factor ) denote remainder division x y. ask solve ` ` reverse '' problem give integers n m <unknown> first line contain a single integer n ( 1 ≤ n ≤ 108 ) second line contain a single integer m ( 1 ≤ m ≤ 108 ) output a single integer — value first example remainder division 42 24 = 16 equal 10 . second example 58 divisible 21 = 2 without remainder answer 0,"['implementation', 'math']",900.0
913/C,a new year party a new year party without lemonade ! usual expect a lot guests buy lemonade already become a pleasant necessity favorite store sell lemonade bottle n different volumes different cost a single bottle type i volume 2i - 1 liters cost ci roubles number bottle type store consider infinite want buy least l liters lemonade many roubles spend ? first line contain two integers n l ( 1 ≤ n ≤ 30 ; 1 ≤ l ≤ 109 ) — number type bottle store require amount lemonade liters respectively second line contain n integers c1 c2 ... cn ( 1 ≤ ci ≤ 109 ) — cost bottle different type output a single integer — smallest number roubles pay order buy least l liters lemonade first example buy one 8 - liter bottle 90 roubles two 2 - liter bottle 30 roubles total 'll get 12 liters lemonade 150 roubles second example even though need 3 liters 's cheaper buy a single 8 - liter bottle 10 roubles third example 's best buy three 1 - liter bottle 10 roubles get three liters 30 roubles,"['dp', 'greedy']",1600.0
913/H,"generate real number s1 s2 ... sn follow : give real number x1 x2 ... xn interest probability si ≤ xi true i simultaneously show represent p q coprime integers , print value p·q - 1 modulo 998244353 . first line contain integer n ( 1 ≤ n ≤ 30 ) next n line contain real number x1 x2 ... xn give six digits decimal point ( 0 < xi ≤ n ) print a single integer answer problem first example seek probability 1 since sum i real number n't exceed 1 n't exceed i. second example probability x1 third example seek probability 3 / 8",['math'],3400.0
914/B,"<unknown> conan get tire solve case invite friend professor agasa , decide play a game card conan n card i - th card a number ai write take turn play start conan turn player choose a card remove also remove card a number strictly lesser number choose card formally player choose i - th card remove card remove j - th card j aj < ai a player lose make a move turn , lose card leave predict outcome game assume players play optimally first line contain integer n ( 1 ≤ n ≤ 105 ) — number card conan next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 105 ) ai number i - th card conan win print ` ` conan '' ( without quote ) otherwise print ` ` agasa '' ( without quote ) first example conan choose card number 7 hence remove card , card leave agasa 's turn second example matter card conan choose one one card leave agasa choose , card leave become conan 's turn","['greedy', 'implementation']",1200.0
915/A,luba think water garden garden represent a segment length k. luba get n bucket i - th bucket allow water continuous subsegment garden length exactly ai hour luba ca n't water part garden already water also ca n't water grind outside garden luba choose one bucket order water garden fast possible ( mention hour water continuous subsegment length ai choose i - th bucket ) help determine minimum number hours spend water garden guarantee luba always choose a bucket possible water garden see examples better understand first line input contain two integer number n k ( 1 ≤ n k ≤ 100 ) — number bucket length garden respectively second line input contain n integer number ai ( 1 ≤ ai ≤ 100 ) — length segment water i - th bucket one hour guarantee least one bucket possible water garden integer number hours use bucket print one integer number — minimum number hours require water garden first test best option choose bucket allow water segment length 3 . ca n't choose bucket allow water segment length 5 ca n't water whole garden second test choose bucket allow us water segment length 1,['implementation'],900.0
919/A,"often go supermarkets buy fruit <unknown> tag print price a kilo supermarkets ask much items clerk say $$$ a $$$ yuan $$$ b $$$ kilos ( n't need care ` ` yuan '' ) $$$ a / b $$$ yuan a kilo imagine 'd like buy $$$ m $$$ kilos apples ' ve ask $$$ n $$$ supermarkets get price find minimum cost apples assume enough apples supermarkets first line contain two positive integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 5\,000 $$$ $$$ 1 \leq m \leq 100 $$$ ) denote $$$ n $$$ supermarkets want buy $$$ m $$$ kilos apples follow $$$ n $$$ line describe information supermarkets line contain two positive integers $$$ a b $$$ ( $$$ 1 \leq a b \leq 100 $$$ ) denote supermarket suppose pay $$$ a $$$ yuan $$$ b $$$ kilos apples line denote minimum cost $$$ m $$$ kilos apples please make sure absolute relative error answer correct answer wo n't exceed $$$ 10^ { -6 } $$$ formally let answer $$$ x $$$ jury 's answer $$$ y $$$ answer consider correct $$$ \frac { |x - y| } { \max { ( 1 |y| ) } } \le 10^ { -6 } $$$ first sample suppose buy $$$ 5 $$$ kilos apples supermarket $$$ 3 $$$ cost $$$ <unknown> $$$ yuan second sample suppose buy $$$ 1 $$$ kilo apples supermarket $$$ 2 $$$ cost $$$ <unknown> $$$ yuan","['greedy', 'implementation']",800.0
919/B,"consider a positive integer perfect sum digits exactly $$$ 10 $$$ give a positive integer $$$ k $$$ task find $$$ k $$$ -th smallest perfect positive integer a single line a positive integer $$$ k $$$ ( $$$ 1 \leq k \leq 10\,000 $$$ ) a single number denote $$$ k $$$ -th smallest perfect integer first perfect integer $$$ 19 $$$ second one $$$ 28 $$$","['dp', 'implementation']",1100.0
919/D,"give a graph $$$ n $$$ nod $$$ m $$$ direct edge one lowercase letter assign node define a path 's value number frequently occur letter example letter a path ` ` abaca '' value path $$$ 3 $$$ task find a path whose value largest first line contain two positive integers $$$ n m $$$ ( $$$ 1 \leq n m \leq 300\,000 $$$ ) denote graph $$$ n $$$ nod $$$ m $$$ direct edge second line contain a string $$$ s $$$ lowercase english letter $$$ i $$$ -th character letter assign $$$ i $$$ -th node $$$ m $$$ line follow line contain two integers $$$ x y $$$ ( $$$ 1 \leq x y \leq n $$$ ) describe a direct edge $$$ x $$$ $$$ y $$$ note $$$ x $$$ equal $$$ y $$$ multiple edge $$$ x $$$ $$$ y $$$ also graph connect output a single line a single integer denote largest value value arbitrarily large output -1 instead first sample path largest value $$$ 1 \to 3 \to 4 \to 5 $$$ value $$$ 3 $$$ letter ' a ' appear $$$ 3 $$$ time",['dp'],1700.0
920/A,"winter max decide 's time water garden garden represent n consecutive garden bed number 1 n. k bed contain water tap ( i - th tap locate bed xi ) , turn start deliver water neighbour bed tap bed xi turn one second pass bed xi water ; two second pass bed segment [ xi - 1 xi + 1 ] water ( exist ) ; j second pass ( j integer number ) bed segment [ xi - ( j - 1 ) xi + ( j - 1 ) ] water ( exist ) nothing change second , example ca n't say segment [ xi - 2.5 xi + 2.5 ] water 2.5 second pass ; segment [ xi - 2 xi + 2 ] water moment max want turn water tap moment wonder minimum number second pass turn tap whole garden water help find answer ! first line contain one integer t — number test case solve ( 1 ≤ t ≤ 200 ) t test case follow first line test case contain two integers n k ( 1 ≤ n ≤ 200 1 ≤ k ≤ n ) — number garden bed water tap respectively next line contain k integers xi ( 1 ≤ xi ≤ n ) — location i - th water tap guarantee condition xi - 1 < xi hold guarantee sum n test case n't exceed 200 . note hack set t = 1 . test case print one integer — minimum number second pass max turn water tap whole garden water first example consist 3 test :",['implementation'],1000.0
920/B,recently n students city s move city p attend a program camp move train even students train decide want drink tea course two people use teapot simultaneously students form a queue get <unknown> - th student come end queue begin li - th second multiple students come queue moment student greater index come student lesser index students queue behave follow : nobody queue student use teapot exactly one second leave queue tea ; otherwise student wait people get tea begin ri - th second student i still get tea ( someone queue ) leave queue without get tea student determine second use teapot get tea ( actually get ) first line contain one integer t — number test case solve ( 1 ≤ t ≤ 1000 ) t test case follow first line test case contain one integer n ( 1 ≤ n ≤ 1000 ) — number students n line follow line contain two integer li ri ( 1 ≤ li ≤ ri ≤ 5000 ) — second i - th student come end queue second leave queue still get tea guarantee every condition li - 1 ≤ li hold sum n test case n't exceed 1000 . note hack set t = 1 . test case print n integers i - th must equal second i - th student get tea 0 leave without tea example contain 2 test :,['implementation'],1200.0
922/D,pushok dog chase imp a hours already fortunately imp know pushok afraid a robot <unknown> cleaner move robot generate a string t consist letter 's ' ' h ' produce a lot noise define noise string t number occurrences string ` ` sh '' a subsequence word number pair ( i j ) i < j robot moment imp know a sequence string ti memory arbitrary change order robot start generate string t a concatenation string give order noise result string equal noise concatenation help imp find maximum noise achieve change order string first line contain a single integer n ( 1 ≤ n ≤ 105 ) — number string robot 's memory next n line contain string t1 t2 ... tn one per line guarantee string non - empty contain english letter 's ' ' h ' total length exceed 105 . print a single integer — <unknown> possible noise imp achieve change order string optimal concatenation first sample <unknown>,['greedy'],1800.0
924/A,a rectangular grid n row m initially - white cells arkady perform a certain number ( possibly zero ) operations i - th operation a non - empty subset row ri a non - empty subset columns ci choose row r ri column c ci intersection row r column c colour black 's another constraint : a row a column choose among operations word mean pair ( i j ) ( i < j ) exist denote intersection set denote empty set determine whether a valid sequence operations exist produce a give final grid first line contain two space - separated integers n m ( 1 ≤ n m ≤ 50 ) — number row columns grid respectively follow n line contain a string m character either ' . ' ( denote a white cell ) ' # ' ( denote a black cell ) represent desire setup give grid achieve valid sequence operations output ` ` yes '' ; otherwise output ` ` '' ( without quote ) print character case ( upper lower ) first example desire setup produce 3 operations show second example desire setup produce since order colour center row third row columns must select one operation column select hence wo n't possible colour cells center column,"['greedy', 'implementation']",1300.0
924/F,call a positive integer x a k - beautiful integer possible split multiset digits decimal representation two subsets difference sum digits one subset sum digits subset less equal k. digit belong exactly one subset split n query query describe three integers l r k mean ask many integers x l r ( inclusive ) k - beautiful first line contain a single integer n ( 1 ≤ n ≤ 5·104 ) indicate number query next n line describe a query contain three integers l r k ( 1 ≤ l ≤ r ≤ 1018 0 ≤ k ≤ 9 ) query print a single number — answer query 1 ≤ x ≤ 9 integer x k - beautiful x ≤ k. 10 ≤ x ≤ 99 integer x = <unknown> + b k - beautiful |a - b| ≤ k a b integers 0 9 <unknown> k - beautiful k ≥ 1,['dp'],3200.0
926/C,a camera accidentally leave a desert take interest photo photo a resolution n pixels width column photo white black thus represent photo a sequence n zero ones 0 mean correspond column white 1 mean correspond column black think photo contain a zebra case whole photo consist several ( possibly one ) alternate black white strip equal width example photo [ 0 0 0 1 1 1 0 0 0 ] a photo zebra photo [ 0 0 0 1 1 1 1 ] width black stripe 3 width white stripe 4 . give photo a photo zebra ? first line contain a single integer n ( 1 ≤ n ≤ 100 000 ) — width photo second line contain a sequence integers a1 a2 ... ( 0 ≤ ai ≤ 1 ) — description photo ai zero i - th column black ai one i - th column white photo a photo zebra print ` ` yes '' ( without quote ) otherwise print ` ` '' print letter case ( upper lower ) first two examples describe statements third example pixels white photo a photo zebra fourth example width first stripe equal three ( white color ) width second stripe equal three ( black ) width third stripe equal two ( white ) thus strip equal length photo a photo zebra,['implementation'],1700.0
929/C,<unknown> у <unknown> <unknown> <unknown> <unknown> евгений <unknown> <unknown> <unknown> нужно выбрать <unknown> игроков которые выйдут на лед в <unknown> <unknown> : один вратарь два <unknown> и три нападающих так как это стартовый состав евгения больше <unknown> <unknown> <unknown> будет <unknown> на <unknown> чем <unknown> игроков а <unknown> евгений <unknown> выбрать такой стартовый состав чтобы номера <unknown> двух игроков из <unknown> состава <unknown> не более чем в два <unknown> например игроки с номерами 13 14 10 18 15 и 20 <unknown> евгения а если например на лед выйдут игроки с номерами 8 и 17 то это не <unknown> евгения <unknown> каждого из игроков вам известно на какой <unknown> он <unknown> ( вратарь защитник или нападающий ) а также его номер в <unknown> номера игроков не обязательно идут подряд <unknown> число <unknown> стартовых составов из одного <unknown> двух защитников и <unknown> нападающих которые может выбрать евгений чтобы <unknown> его условие <unknown> первая строка содержит три целых числа g d и f ( 1 ≤ g ≤ 1 000 1 ≤ d ≤ 1 000 1 ≤ f ≤ 1 000 ) — число вратарей защитников и нападающих в <unknown> евгения вторая строка содержит g целых чисел каждое в пределах от 1 до 100 000 — номера вратарей <unknown> строка содержит d целых чисел каждое в пределах от 1 до 100 000 — номера защитников <unknown> строка содержит f целых чисел каждое в пределах от 1 до 100 000 — номера нападающих гарантируется что <unknown> количество игроков не превосходит 1 000 т . <unknown> . g + d + f ≤ 1 000 . все g + d + f <unknown> игроков <unknown> выведите одно целое число — количество возможных стартовых составов в первом примере всего один <unknown> для выбора состава который <unknown> <unknown> <unknown> поэтому ответ 1 . во втором примере <unknown> <unknown> <unknown> <unknown> ( в порядке вратарь - защитник - защитник - нападающий - нападающий - нападающий ) : таким образом ответ на <unknown> <unknown> — 6,['math'],1700.0
93/A,"throughout igor k. 's life many situations worthy attention remember story virus story mathematical career course famous program achievements however one always adopt new hobbies one quit something well time igor k. get disappoint one hobbies : edit voice videos moreover get disappoint much decide destroy secret archive good igor k. use pindows xr operation system represent file folders small icons , m icons fit a horizontal row window igor k. 's computer contain n folders d : disk 's root catalog folders number 1 n order leave right top bottom ( see image ) folders secret videos number a b inclusive igor k. want delete forever make frame <unknown> possible press <unknown> exactly minimum number time igor k. select folder order select folders a b ? let us note select folder select repeatedly <unknown> selection possess shape rectangle side parallel screen 's border line contain four integers n m a b ( 1 ≤ n m ≤ 109 1 ≤ a ≤ b ≤ n ) number folders igor k. 's computer width a window number first last folders need delete print a single number : least possible number time igor k. select folders use frame select folders number a b. image illustrate statement test first test : test select folders 3 4 first selection folders 5 6 7 8 second selection folder 9 third last selection second test : test first select folders first row ( 2 3 4 5 ) — ones",['implementation'],1700.0
933/A,"a dragon symbolize <unknown> power wealth lunar new year 's day people model a dragon bamboo strip clothe raise rods hold rods high low resemble a fly dragon a performer hold rod low represent a 1 one hold high represent a 2 . thus line performers represent a sequence a1 a2 ... , little tommy among would like choose interval [ l r ] ( 1 ≤ l ≤ r ≤ n ) reverse al al + 1 ... ar length longest non - decreasing subsequence new sequence maximum a non - decreasing subsequence a sequence indices p1 p2 ... pk p1 < p2 < ... < pk <unknown> ≤ <unknown> ≤ ... ≤ <unknown> length subsequence k. first line contain integer n ( 1 ≤ n ≤ 2000 ) denote length original sequence second line contain n space - separated integers describe original sequence a1 a2 ... ( 1 ≤ ai ≤ 2 i = 1 2 ... n ) print a single integer mean maximum possible length longest non - decreasing subsequence new sequence first example reverse [ 2 3 ] array become [ 1 1 2 2 ] length longest non - decreasing subsequence 4 . second example reverse [ 3 7 ] array become [ 1 1 1 1 2 2 2 2 2 1 ] length longest non - decreasing subsequence 9",['dp'],1800.0
933/E,east west home best 's family reunion <unknown> necessity lunar new year celebration put a position reunion dinner little tommy play a game family a concise <unknown> game : obviously every game end n - 1 descensions please share solution game lowest cost first line contain one integer n ( 1 ≤ n ≤ 3·105 ) second line contain n space - separated integers p1 p2 ... pn ( 0 ≤ pi ≤ 109 i = 1 2 ... n ) first line print one integer number descensions m ( 0 ≤ m ≤ n - 1 ) next m line print descensions chronologically precisely line next m line print one integer i ( 1 ≤ i < n ) represent a <unknown> would operate pi pi + 1 descensions could utilize top bottom many possible solutions reach minimal cost print first sample one possible best solution cost 1 + 1 = 2 . second sample one possible best solution cost 1 + 1 + 1 = 3,['dp'],3200.0
934/B,apart nian a daemon name sui terrify children cause become sick parent give children money wrap red packets put pillow sui try approach drive away fairies inside big banban hesitate amount money give consider loop lucky since symbolize unity harmony would like find a positive integer n greater 1018 exactly k loop decimal representation n determine n exist a loop a planar area enclose line digits ' decimal representation write <unknown> numerals example one loop digit 4 two loop 8 loop 5 . refer figure exact form first line contain integer k ( 1 ≤ k ≤ 106 ) — desire number loop output integer — n exist output -1 ; otherwise output n. latter case output a positive decimal integer exceed 1018,['implementation'],1200.0
935/E,ancient egyptians know understand difficult <unknown> mathematics ancient <unknown> mathematician ahmes like write a kind arithmetic expressions papyrus paper call ahmes arithmetic expression ahmes arithmetic expression define : trip egypt fafa find a piece papyrus paper one ahmes arithmetic expressions write ancient papyrus piece wear a result operators erase keep number bracket since fafa love mathematics decide challenge follow task : give number plus minus operators original expression find maximum possible value expression papyrus paper put plus minus operators place original erase operators first line contain a string e ( 1 ≤ <unknown> ≤ 104 ) — a valid ahmes arithmetic expression operators erase replace ' ? ' second line contain two space - separated integers p m ( 0 ≤ min ( p m ) ≤ 100 ) — number plus minus operators respectively guarantee p + m = number erase operators print one line contain answer problem,['dp'],2300.0
935/F,fafa array a n positive integers function f ( a ) define want q query two type : note query type 1 n't affect array elements first line contain one integer n ( 3 ≤ n ≤ 105 ) — length array second line contain n positive integers a1 a2 ... ( 0 < ai ≤ 109 ) — array elements third line contain integer q ( 1 ≤ q ≤ 105 ) — number query q line follow line i describe i - th query contain four integers ti li ri xi guarantee least one query type 1 . query type 1 print answer query,"['data structures', 'greedy']",2600.0
936/C,"welcome another task break code lock ! explorers whitfield martin come across unusual safe inside accord rumor <unknown> <unknown> among one find solution problem discrete logarithm ! course a code lock instal safe lock a screen display a string n lowercase latin letter initially screen display string s. whitfield martin find safe open string t display screen string screen change use operation « shift x » order apply operation explorers choose integer x 0 n inclusive , current string p = <unknown> change <unknown> length β x length α n - x. word suffix length x string p reverse move begin string example operation « shift 4 » string « abcacb » change string « <unknown> » since α = ab β = <unknown> <unknown> = bcac explorers afraid apply many operations « shift » lock lock forever ask find a way get string t screen use 6100 operations first line contain integer n length string s t ( 1 ≤ n ≤ 2 000 ) , two string s t consist n lowercase latin letter impossible get string t string s use 6100 operations « shift » print a single number - 1 . otherwise first line output number operations k ( 0 ≤ k ≤ 6100 ) next line output k number xi correspond operations « shift xi » ( 0 ≤ xi ≤ n ) order apply first example apply operations string screen change follow :",['implementation'],2300.0
938/E,give array a length n. define fa follow way : calculate sum fa n ! permutations array a modulo 109 + 7 . note : two elements consider different indices differ every array a exactly n ! permutations first line contain integer n ( 1 ≤ n ≤ 1 000 000 ) — size array a. second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) print integer sum fa n ! permutations array a modulo 109 + 7 . second example permutations : p array indices initial array a. sum fa equal 4,['math'],2300.0
946/A,give a sequence a consist n integers may partition sequence two sequence b c a way every element belong exactly one sequence let b sum elements belong b c sum elements belong c ( sequence empty sum 0 ) maximum possible value b - c ? first line contain one integer n ( 1 ≤ n ≤ 100 ) — number elements a. second line contain n integers a1 a2 ... ( - 100 ≤ ai ≤ 100 ) — elements sequence a. print maximum possible value b - c b sum elements sequence b c sum elements sequence c. first example may choose b = { 1 0 } c = { - 2 } b = 1 c = - 2 b - c = 3 . second example choose b = { 16 23 16 15 42 8 } c = { } ( empty sequence ) b = 120 c = 0 b - c = 120,['greedy'],800.0
95/D,petya like horse race much horse number l r take part race petya want evaluate probability victory ; reason need know amount nearly lucky horse ' number a nearly lucky number integer number least two lucky digits distance exceed k. petya learn mat <unknown> lucky digits digits 4 7 . distance digits absolute difference position number a horse example k = 2 number <unknown> 404 <unknown> nearly lucky number 4 <unknown> <unknown> petya prepare t intervals [ li ri ] invent number k common task find many nearly happy number segment since answer quite large output modulo 1000000007 ( 109 + 7 ) first line contain two integers t k ( 1 ≤ t k ≤ 1000 ) — number segment distance number correspondingly next t line contain pair integers li ri ( 1 ≤ l ≤ r ≤ 101000 ) number give without lead zero number line separate exactly one space character output t line line print one integer — answer correspond segment modulo 1000000007 ( 109 + 7 ) first sample four nearly lucky number 44 47 74 77 . second sample 74 77 give segment,"['dp', 'math']",2500.0
955/C,'re give q query form ( l r ) query find number x l ≤ x ≤ r exist integer number a > 0 p > 1 x = ap first line contain number query q ( 1 ≤ q ≤ 105 ) next q line contain two integers l r ( 1 ≤ l ≤ r ≤ 1018 ) output q line — answer query query one suitable number 1 4,['math'],2100.0
958/B1,resistance try take control planets a particular solar system solar system shape like a tree precisely planets connect bidirectional hyperspace tunnel a way a path every pair planets remove tunnel would disconnect resistance already measure place time right enable control every planet remote a planet consider remote connect rest planets via a single hyperspace tunnel much work leave do : many remote planets ? first line input contain integer n ( 2 ≤ n ≤ 1000 ) – number planets galaxy next n - 1 line describe hyperspace tunnel planets n - 1 line contain two space - separated integers u v ( 1 ≤ u v ≤ n ) indicate a bidirectional hyperspace tunnel planets u v. guarantee every two planets connect a path tunnel tunnel connect a different pair planets a single integer denote number remote planets first example planets 2 3 5 connect a single tunnel second example remote planets 2 3 . note problem two versions – easy medium,['implementation'],1000.0
958/B2,resistance try take control many planets a particular solar system possible princess heidi charge fleet must send ship planets order maximize number control planets galaxy contain n planets connect bidirectional hyperspace tunnel a way a unique path every pair planets a planet control resistance a resistance ship orbit planet lie shortest path two planets resistance ship orbit heidi yet make mind many ship use therefore ask compute every k = 1 2 3 ... n maximum number planets control a fleet consist k ship first line input contain integer n ( 1 ≤ n ≤ 105 ) – number planets galaxy next n - 1 line describe hyperspace tunnel planets n - 1 line contain two space - separated integers u v ( 1 ≤ u v ≤ n ) indicate a bidirectional hyperspace tunnel planets u v. guarantee every two planets connect a path tunnel tunnel connect a different pair planets a single line print n space - separated integers k - th number correspond maximum number planets control resistance use a fleet k ship consider first example k = 1 heidi send one ship planet control however k ≥ 2 send ship planets 1 3 allow resistance control planets,"['data structures', 'greedy']",2200.0
958/C2,heidi break first level encryption death star plan star screen present description next code enter look surprisingly similar first one – seem like empire engineer quite lazy ... heidi give a sequence a also give two integers k p. need find encryption key s let x a sequence integers p a positive integer define score x sum elements x modulo p. heidi give a sequence a consist n integers also give integers k p. goal split a k part : output sum s – encryption code first line input contain three space - separated integer n k p ( k ≤ n ≤ 20 000 2 ≤ k ≤ 50 2 ≤ p ≤ 100 ) – number elements a number part a split modulo compute score respectively second line contain n space - separated integers elements a. integer interval [ 1 1 000 000 ] output number s describe problem statement first example input sequence split ( 3 4 ) ( 7 ) ( 2 ) total score would easy see score maximum second example one possible way obtain score 37 make follow split : ( 16 3 24 ) ( 13 9 ) ( 8 ) ( 7 ) ( 5 12 12 ),['dp'],2000.0
958/E1,rebel fleet afraid empire might want strike back princess heidi need know possible assign r rebel spaceships guard b base every base exactly one guardian spaceship exactly one assign base ( word assignment a perfect match ) since know <unknown> pilot want sure two ( straight ) paths – a base assign spaceship – intersect galaxy plane ( 2d ) risk collision first line contain two space - separated integers r b ( 1 ≤ r b ≤ 10 ) 1 ≤ i ≤ r i + 1 - th line contain two space - separated integers xi yi ( |xi| |yi| ≤ 10000 ) denote coordinate i - th rebel spaceship follow b line format denote position base guarantee two point coincide three point line possible connect rebel spaceships base satisfy constraint output yes otherwise output ( without quote ) first example one possible way connect rebel base order second example perfect match rebel base,"['greedy', 'math']",1600.0
958/E2,princess heidi decide give order k rebel ship commanders person unfortunately currently travel hyperspace leave n specific moments t1 t2 ... tn meet commanders must therefore start stop time namely commander board ship time ti <unknown> later time tj course heidi need meet commanders two meet hold time two commanders even meet <unknown> / <unknown> hyperspace jump many ship one position could give coordinate enemy task find minimum time princess heidi spend meet schedule satisfy condition first line contain two integers k n ( 2 ≤ 2k ≤ n ≤ 500000 k ≤ 5000 ) second line contain n distinct integers t1 t2 ... tn ( 1 ≤ ti ≤ 109 ) represent time heidi leave hyperspace output one integer : minimum time spend meet first example five valid schedule : [ 1 4 ] [ 6 7 ] total time 4 [ 1 4 ] [ 6 12 ] total time 9 [ 1 4 ] [ 7 12 ] total time 8 [ 1 6 ] [ 7 12 ] total time 10 [ 4 6 ] [ 7 12 ] total time 7 . answer 4 . second example 1 valid schedule : [ 1 2 ] [ 3 4 ] [ 5 6 ] third example one possible schedule total time 6 : [ 1 3 ] [ 4 5 ] [ 14 15 ] [ 23 25 ],"['dp', 'greedy']",2200.0
962/C,give a positive integer $$$ n $$$ write without lead zero ( example number 04 incorrect ) one operation delete digit give integer result remain a positive integer without lead zero determine minimum number operations need consistently apply give integer $$$ n $$$ make square positive integer report impossible integer $$$ x $$$ square positive integer $$$ x = y^2 $$$ positive integer $$$ y $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 2 \cdot 10^ { 9 } $$$ ) number give without lead zero impossible make square positive integer $$$ n $$$ print -1 . case print minimal number operations require first example delete $$$ 8314 $$$ digits $$$ 3 $$$ $$$ 4 $$$ $$$ 8314 $$$ become equal $$$ 81 $$$ square integer $$$ 9 $$$ second example give $$$ <unknown> $$$ square integer $$$ 25 $$$ delete anything third example impossible make square $$$ 333 $$$ answer -1,"['implementation', 'math']",1400.0
975/A,aramic language word represent object word aramic special properties : ancient script aramic number different object mention script ? first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000 $$$ ) — number word script second line contain $$$ n $$$ word $$$ s_1 s_2 \ldots s_n $$$ — script length string exceed $$$ 1000 $$$ guarantee character string small latin letter output one integer — number different object mention give ancient aramic script first test two object mention root represent ` ` a '' '' ab '' second test one object root ` ` amer '' string permutations ` ` amer '',['implementation'],900.0
975/B,mancala a game famous middle east play a board consist 14 hole initially hole $$$ a_i $$$ stone a player make a move choose a hole contain a positive number stone take stone inside redistribute stone one one next hole a counter - clockwise direction note counter - clockwise order mean player take stone hole $$$ i $$$ put one stone $$$ ( i+1 ) $$$ -th hole $$$ ( i+2 ) $$$ -th etc put a stone $$$ 14 $$$ -th hole next one put first hole move player collect stone hole contain even number stone number stone collect player score accord resli resli a famous mancala player want know maximum score obtain one move line contain 14 integers $$$ a_1 a_2 \ldots a _ { 14 } $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) — number stone hole guarantee $$$ i $$$ ( $$$ 1\leq i \leq 14 $$$ ) $$$ a_i $$$ either zero odd least one stone board output one integer maximum possible score one move first test case board move hole $$$ 7 $$$ stone look like 1 2 2 0 0 0 0 0 0 0 1 1 1 1 . player collect even number end a score equal $$$ 4 $$$,['implementation'],1100.0
977/D,polycarp like play number take integer number $$$ x $$$ write board perform $$$ n - 1 $$$ operations two kinds : operation polycarp write result board replace $$$ x $$$ result $$$ n $$$ number board give a sequence length $$$ n $$$ — number polycarp write sequence give arbitrary order i.e order sequence <unknown> order number write board problem rearrange ( reorder ) elements sequence a way match possible polycarp 's game order number write board i.e next number exactly two time previous number exactly one third previous number guarantee answer exist first line input <unknown> integer number $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — number elements sequence second line input contain $$$ n $$$ integer number $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 3 \cdot 10^ { 18 } $$$ ) — rearrange ( reorder ) sequence polycarp write board print $$$ n $$$ integer number — rearrange ( reorder ) input sequence sequence polycarp could write board guarantee answer exist first example give sequence rearrange follow way : $$$ [ 9 3 6 12 4 8 ] $$$ match possible polycarp 's game start $$$ x = 9 $$$,['math'],1400.0
978/B,take file send polycarp try send a file social network ` ` codehorses '' encounter unexpected problem name file contain three ` ` x '' ( lowercase latin letter ` ` x '' ) a row system consider file content correspond social network topic case file send error message display determine minimum number character remove file name name contain ` ` xxx '' a substring print 0 file name initially contain a forbid substring ` ` xxx '' delete character arbitrary position ( necessarily consecutive ) delete a character length a string reduce $$$ 1 $$$ example delete character position $$$ 2 $$$ string ` ` <unknown> '' result string ` ` <unknown> '' first line contain integer $$$ n $$$ $$$ ( 3 \le n \le 100 ) $$$ — length file name second line contain a string length $$$ n $$$ consist lowercase latin letter — file name print minimum number character remove file name name contain ` ` xxx '' a substring initially file name <unknown> contain a forbid substring ` ` xxx '' print 0 . first example polycarp try send a file name contain number $$$ 33 $$$ write roman numerals send file name contain three letter ` ` x '' a row send file need remove one letter,['greedy'],800.0
978/C,$$$ n $$$ dormitories berland state university number integers $$$ 1 $$$ $$$ n $$$ dormitory consist room $$$ a_i $$$ room $$$ i $$$ -th dormitory room $$$ i $$$ -th dormitory number $$$ 1 $$$ $$$ a_i $$$ a postman deliver letter sometimes specific dormitory room number envelope instead a room number among room $$$ n $$$ dormitories write envelope case assume room number $$$ 1 $$$ $$$ a_1 + a_2 + \dots + a_n $$$ room first dormitory go first room second dormitory go example case $$$ n=2 $$$ $$$ <unknown> $$$ $$$ a_2=5 $$$ envelope integer $$$ 1 $$$ $$$ 8 $$$ write number $$$ 7 $$$ write envelope mean letter deliver room number $$$ 4 $$$ second dormitory $$$ m $$$ letter room number among $$$ n $$$ dormitories determine particular dormitory room number a dormitory letter deliver first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 1 \le n m \le 2 \cdot 10^ { 5 } ) $$$ — number dormitories number letter second line contain a sequence $$$ a_1 a_2 \dots a_n $$$ $$$ ( 1 \le a_i \le 10^ { 10 } ) $$$ $$$ a_i $$$ equal number room $$$ i $$$ -th dormitory third line contain a sequence $$$ b_1 b_2 \dots b_m $$$ $$$ ( 1 \le b_j \le a_1 + a_2 + \dots + a_n ) $$$ $$$ b_j $$$ equal room number ( among room dormitories ) $$$ j $$$ -th letter $$$ b_j $$$ give increase order print $$$ m $$$ line letter print two integers $$$ f $$$ $$$ k $$$ — dormitory number $$$ f $$$ $$$ ( 1 \le f \le n ) $$$ room number $$$ k $$$ dormitory $$$ ( 1 \le k \le <unknown> ) $$$ deliver letter first example letter deliver follow order :,['implementation'],1000.0
980/A,a necklace describe a string link ( ' - ' ) pearl ( ' o ' ) last link pearl connect first one remove a link a pearl insert two exist link pearl ( a link a pearl ) necklace process repeat many time like ca n't throw away part make number link every two adjacent pearl equal ? two pearl consider adjacent pearl note final necklace remain one circular part length initial necklace line input contain a string $$$ s $$$ ( $$$ 3 \leq |s| \leq 100 $$$ ) represent necklace a dash ' - ' represent a link lowercase english letter ' o ' represent a pearl print ` ` yes '' link pearl <unknown> number link adjacent pearl equal otherwise print ` ` '' print letter case ( upper lower ),"['implementation', 'math']",900.0
980/F,give a special connect undirected graph vertex belong one simple cycle task remove many edge need convert graph a tree ( connect graph cycle ) node independently output maximum distance a leaf result tree assume remove edge a way minimize distance first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 5\cdot 100000 $$$ ) number nod number edge respectively follow $$$ m $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \leq u v \leq n $$$ $$$ u \ne v $$$ ) represent edge connect two nod $$$ u $$$ $$$ v $$$ pair nod connect one edge guarantee give graph connect vertex belong one simple cycle print $$$ n $$$ space - separated integers $$$ i $$$ -th integer represent maximum distance node $$$ i $$$ a leaf remove edge choose a way minimize distance first sample a possible way minimize maximum distance vertex $$$ 1 $$$ remove mark edge follow image : note minimize answer different nod remove different edge,['dp'],2900.0
981/C,ram know a lot problems involve tree ( undirected connect graph without cycle ) ! create a new useful tree decomposition know construct ask help ! decomposition split edge tree simple paths a way two paths least one common vertex edge tree exactly one path help <unknown> find a decomposition tree <unknown> decomposition first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 10^ { 5 } $$$ ) number nod tree next $$$ n - 1 $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a_i b_i \leq n $$$ $$$ a_i \neq b_i $$$ ) — edge tree guarantee give edge form a tree decompositions print line contain ` ` '' otherwise first line print ` ` yes '' second line print number paths decomposition $$$ m $$$ next $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ u_i \neq v_i $$$ ) denote one paths decomposition simple path nod $$$ u_i $$$ $$$ v_i $$$ pair paths decomposition least one common vertex edge tree present exactly one path print paths end path arbitrary order multiple decompositions print tree first example show picture : number next edge correspond path number decomposition easy see decomposition suit require condition tree second example show picture : show valid decompositions tree tree third example show picture : number next edge correspond path number decomposition easy see decomposition suit require condition,['implementation'],1400.0
982/B,"bus character $$$ n $$$ row seat $$$ 2 $$$ seat width seat $$$ i $$$ -th row $$$ w_i $$$ centimeters integers $$$ w_i $$$ distinct initially bus empty $$$ 2n $$$ stop one passenger enter bus two type passengers : give seat width row order passengers enter bus determine row passenger take first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200\,000 $$$ ) — number row bus second line contain sequence integers $$$ w_1 w_2 \dots w_n $$$ ( $$$ 1 \le w_i \le 10^ { 9 } $$$ ) $$$ w_i $$$ width seat $$$ i $$$ -th row guarantee $$$ w_i $$$ distinct third line contain a string length $$$ 2n $$$ consist digits ' 0 ' ' 1 ' — description order passengers enter bus $$$ j $$$ -th character ' 0 ' passenger enter bus $$$ j $$$ -th stop introvert $$$ j $$$ -th character ' 1 ' passenger enter bus $$$ j $$$ -th stop extrovert guarantee number <unknown> equal number introvert ( i. e. number equal $$$ n $$$ ) extrovert always a suitable row print $$$ 2n $$$ integers — row passengers take order passengers input first example first passenger ( introvert ) choose row $$$ 2 $$$ seat smallest width second passenger ( introvert ) choose row $$$ 1 $$$ empty row third passenger ( extrovert ) choose row $$$ 1 $$$ exactly one occupy seat seat width largest among row fourth passenger ( extrovert ) choose row $$$ 2 $$$ row empty place","['data structures', 'greedy', 'implementation']",1300.0
982/C,'re give a tree $$$ n $$$ vertices task determine maximum possible number edge remove a way remain connect components even size first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) denote size tree next $$$ n - 1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) describe vertices connect $$$ i $$$ -th edge 's guarantee give edge form a tree output a single integer $$$ k $$$ — maximum number edge remove leave connect components even size $$$ -1 $$$ impossible remove edge order satisfy property first example remove edge vertices $$$ 1 $$$ $$$ 4 $$$ graph two connect components two vertices second example ca n't remove edge a way components even number vertices answer $$$ -1 $$$,"['dp', 'greedy']",1500.0
983/D,"arkady get infinite plane paint color $$$ 0 $$$ draw $$$ n $$$ rectangles fill paint side parallel cartesian coordinate ax one another color $$$ i $$$ -th rectangle $$$ i $$$ ( rectangles enumerate $$$ 1 $$$ $$$ n $$$ order draw ) possible new rectangles cover previous ones completely partially count number different color plane arkady draw rectangles first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100\,000 $$$ ) — number rectangles $$$ i $$$ -th next $$$ n $$$ line contain $$$ 4 $$$ integers $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ -1000000000 \le x_1 < x_2 \le 1000000000 $$$ $$$ -1000000000 \le y_1 < y_2 \le 1000000000 $$$ ) — coordinate corner $$$ i $$$ -th rectangle single line print number different color plane include color $$$ 0 $$$ 's plane look second sample $$$ 0 $$$ = white $$$ 1 $$$ = cyan $$$ 2 $$$ = blue $$$ 3 $$$ = purple $$$ 4 $$$ = yellow $$$ 5 $$$ = red",['data structures'],3300.0
984/B,one day alex decide remember childhood computers powerful lot people play default game alex enjoy play minesweeper time imagine save world bomb plant terrorists rarely alex grow since easily win difficult level quickly bore think : computer give invalid field childhood alex could win ? need help check a minesweeper field a rectangle $$$ n \times m $$$ cell either empty contain a digit $$$ 1 $$$ $$$ 8 $$$ a bomb field valid cell : two cells neighbor a common side a corner ( i. e. a cell $$$ 8 $$$ neighbor cells ) first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100 $$$ ) — size field next $$$ n $$$ line contain description field line contain $$$ m $$$ character ` ` . '' ( cell empty ) ` ` * '' ( bomb cell ) a digit $$$ 1 $$$ $$$ 8 $$$ inclusive print ` ` yes '' field valid ` ` '' otherwise choose case ( lower upper ) letter arbitrarily second example answer ` ` '' position bomb preserve first line field * 2 * 1 . read minesweeper wikipedia 's article,['implementation'],1100.0
986/A,company go hold a fair byteland $$$ n $$$ towns byteland $$$ m $$$ two - way roads towns course reach town town use roads $$$ k $$$ type goods produce byteland every town produce one type hold a fair bring least $$$ s $$$ different type goods cost $$$ d ( u v ) $$$ coin bring goods town $$$ u $$$ town $$$ v $$$ $$$ d ( u v ) $$$ length shortest path $$$ u $$$ $$$ v $$$ length a path number roads path organizers cover travel expense choose towns bring goods want calculate minimum expense hold a fair $$$ n $$$ towns $$$ 4 $$$ integers $$$ n $$$ $$$ m $$$ $$$ k $$$ $$$ s $$$ first line input ( $$$ 1 \le n \le 10^ { 5 } $$$ $$$ 0 \le m \le 10^ { 5 } $$$ $$$ 1 \le s \le k \le min ( n 100 ) $$$ ) — number towns number roads number different type goods number different type goods necessary hold a fair next line $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a _ { i } \le k $$$ ) $$$ a_i $$$ type goods produce $$$ i $$$ -th town guarantee integers $$$ 1 $$$ $$$ k $$$ occur least among integers $$$ a _ { i } $$$ next $$$ m $$$ line roads describe road describe two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) — towns connect road guarantee one road every two towns guarantee go town town via roads print $$$ n $$$ number $$$ i $$$ -th minimum number coin need spend travel expense hold a fair town $$$ i $$$ separate number space let 's look first sample hold a fair town $$$ 1 $$$ bring goods towns $$$ 1 $$$ ( $$$ 0 $$$ coin ) $$$ 2 $$$ ( $$$ 1 $$$ coin ) $$$ 4 $$$ ( $$$ 1 $$$ coin ) total number coin $$$ 2 $$$ town $$$ 2 $$$ : goods towns $$$ 2 $$$ ( $$$ 0 $$$ ) $$$ 1 $$$ ( $$$ 1 $$$ ) $$$ 3 $$$ ( $$$ 1 $$$ ) sum equal $$$ 2 $$$ town $$$ 3 $$$ : goods towns $$$ 3 $$$ ( $$$ 0 $$$ ) $$$ 2 $$$ ( $$$ 1 $$$ ) $$$ 4 $$$ ( $$$ 1 $$$ ) sum equal $$$ 2 $$$ town $$$ 4 $$$ : goods towns $$$ 4 $$$ ( $$$ 0 $$$ ) $$$ 1 $$$ ( $$$ 1 $$$ ) $$$ 5 $$$ ( $$$ 1 $$$ ) sum equal $$$ 2 $$$ town $$$ 5 $$$ : goods towns $$$ 5 $$$ ( $$$ 0 $$$ ) $$$ 4 $$$ ( $$$ 1 $$$ ) $$$ 3 $$$ ( $$$ 2 $$$ ) sum equal $$$ 3 $$$,['greedy'],1600.0
986/F,"surely see insane videos south korean rapper psy ` ` <unknown> style '' ` ` gentleman '' ` ` <unknown> '' might also hear psy record video ` ` <unknown> <unknown> style '' two years ago ( unfortunately could n't find internet ) remind hit look like ( find original description ) : grind $$$ n $$$ platforms number integers $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th platform a dancer number $$$ i $$$ , every second dancers stand platform number $$$ i $$$ jump platform number $$$ f ( i ) $$$ move rule $$$ f $$$ select advance change throughout clip duration clip $$$ k $$$ second rule $$$ f $$$ choose a way $$$ k $$$ second dancers initial position ( i.e $$$ i $$$ -th dancer stand platform number $$$ i $$$ ) allow loop clip collect even like psy know enhance versions old artworks become popular every day decide release a remastered - version video case ` ` enhance version '' mean even <unknown> number platforms $$$ 10^ { 18 } $$$ ! video director say dancer stay platform time viewer get bore turn video immediately therefore $$$ x $$$ $$$ 1 $$$ $$$ n $$$ $$$ f ( x ) \neq x $$$ must hold big part classic video 's success loop remastered version dancers return initial position end clip well psy n't decide exact number platforms video duration yet ask check a good rule $$$ f $$$ different options first line input one integer $$$ t $$$ ( $$$ 1 \le t \le 10^ { 4 } $$$ ) — number options $$$ n $$$ $$$ k $$$ check next $$$ t $$$ line options give : option describe two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 10^ { 18 } $$$ $$$ 1 \le k \le 10^ { 15 } $$$ ) — number dancers duration second guarantee number different value $$$ k $$$ one test greater $$$ 50 $$$ print $$$ t $$$ line $$$ i $$$ -th option video feasible print ` ` yes '' ( without quote ) $$$ i $$$ -th line otherwise print ` ` '' ( without quote )",['math'],3300.0
987/A,take a peek thanos wear infinity gauntlet gauntlet a place six infinity gems : use color gems saw gauntlet determine name absent gems first line input one integer $$$ n $$$ ( $$$ 0 \le n \le 6 $$$ ) — number gems infinity gauntlet next $$$ n $$$ line color gems saw word use color : purple green blue orange red yellow guarantee color distinct color give lowercase english letter first line output one integer $$$ m $$$ ( $$$ 0 \le m \le 6 $$$ ) — number absent gems $$$ m $$$ line print name absent gems line word use name : power time space soul reality mind name print order keep first letter uppercase others lowercase first sample thanos already reality power mind soul gems need two : time space second sample thanos n't gems need six,['implementation'],800.0
988/A,$$$ n $$$ students a school class rat $$$ i $$$ -th student codehorses $$$ a_i $$$ form a team consist $$$ k $$$ students ( $$$ 1 \le k \le n $$$ ) rat team members distinct impossible form a suitable team print ` ` '' ( without quote ) otherwise print ` ` yes '' print $$$ k $$$ distinct number indices students team form multiple answer print first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 100 $$$ ) — number students size team form second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100 $$$ ) $$$ a_i $$$ rat $$$ i $$$ -th student impossible form a suitable team print ` ` '' ( without quote ) otherwise print ` ` yes '' print $$$ k $$$ distinct integers $$$ 1 $$$ $$$ n $$$ indices students team form rat students team distinct may print indices order multiple answer print assume students number $$$ 1 $$$ $$$ n $$$ possible answer first example : note order matter,['implementation'],800.0
990/B,"a petri dish bacteria prepare dive harsh <unknown> - world , unfortunately n't microscope nearby ca n't watch know $$$ n $$$ bacteria petri dish size $$$ i $$$ -th bacteria $$$ a_i $$$ also know intergalactic positive integer constant $$$ k $$$ $$$ i $$$ -th bacteria swallow $$$ j $$$ -th bacteria $$$ a_i > a_j $$$ $$$ a_i \le a_j + k $$$ $$$ j $$$ -th bacteria disappear $$$ i $$$ -th bacteria n't change size bacteria perform multiple swallow swallow operation bacteria $$$ i $$$ swallow bacteria $$$ j $$$ $$$ a_i > a_j $$$ $$$ a_i \le a_j + k $$$ swallow operations go one another example sequence bacteria size $$$ a= [ 101 53 42 102 101 55 54 ] $$$ $$$ k=1 $$$ one possible sequence swallow : $$$ [ 101 53 42 102 \underline { 101 } 55 54 ] $$$ $$$ \to $$$ $$$ [ 101 \underline { 53 } 42 102 55 54 ] $$$ $$$ \to $$$ $$$ [ \underline { 101 } 42 102 55 54 ] $$$ $$$ \to $$$ $$$ [ 42 102 55 \underline { 54 } ] $$$ $$$ \to $$$ $$$ [ 42 102 55 ] $$$ total $$$ 3 $$$ bacteria remain petri dish since n't a microscope guess minimal possible number bacteria remain petri dish finally find microscope first line contain two space separate positive integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le k \le 1000000 $$$ ) — number bacteria intergalactic constant $$$ k $$$ second line contain $$$ n $$$ space separate integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) — size bacteria print integer — minimal possible number bacteria remain first example clarify problem statement second example optimal possible sequence swallow : $$$ [ 20 15 10 15 \underline { 20 } 25 ] $$$ $$$ \to $$$ $$$ [ 20 15 10 \underline { 15 } 25 ] $$$ $$$ \to $$$ $$$ [ 20 15 \underline { 10 } 25 ] $$$ $$$ \to $$$ $$$ [ 20 \underline { 15 } 25 ] $$$ $$$ \to $$$ $$$ [ \underline { 20 } 25 ] $$$ $$$ \to $$$ $$$ [ 25 ] $$$ third example bacteria swallow bacteria",['greedy'],1200.0
990/C,a bracket sequence a string contain character ` ` ( ` ` ` ` ) '' a regular bracket sequence a bracket sequence transform a correct arithmetic expression insert character ` ` 1 '' ` ` + '' original character sequence example bracket sequence ` ` ( ) ( ) '' ` ` ( ( ) ) '' regular ( result expressions : ` ` ( 1 ) + ( 1 ) '' ` ` ( ( 1 + 1 ) +1 ) '' ) ` ` ) ( ` ` ` ` ( ` ` give $$$ n $$$ bracket sequence $$$ s_1 s_2 \dots s_n $$$ calculate number pair $$$ i j \ ( 1 \le i j \le n ) $$$ bracket sequence $$$ s_i + s_j $$$ a regular bracket sequence operation $$$ + $$$ mean concatenation i.e ` ` ( ) ( ` ` + ` ` ) ( ) '' = ` ` ( ) ( ) ( ) '' $$$ s_i + s_j $$$ $$$ s_j + s_i $$$ regular bracket sequence $$$ i \ne j $$$ pair $$$ ( i j ) $$$ $$$ ( j i ) $$$ must count answer also $$$ s_i + s_i $$$ a regular bracket sequence pair $$$ ( i i ) $$$ must count answer first line contain one integer $$$ n \ ( 1 \le n \le 3 \cdot 100000 ) $$$ — number bracket sequence follow $$$ n $$$ line contain bracket sequence — non - empty string consist character ` ` ( ` ` ` ` ) '' sum lengths bracket sequence exceed $$$ 300000 $$$ single line print a single integer — number pair $$$ i j \ ( 1 \le i j \le n ) $$$ bracket sequence $$$ s_i + s_j $$$ a regular bracket sequence first example suitable pair $$$ ( 3 1 ) $$$ $$$ ( 2 2 ) $$$ second example pair suitable namely $$$ ( 1 1 ) ( 1 2 ) ( 2 1 ) ( 2 2 ) $$$,['implementation'],1500.0
991/C,"pass a test vasya get a box $$$ n $$$ candy decide eat equal amount candy morning candy however petya also notice box decide get candy mean process eat candy follow : begin vasya choose a single integer $$$ k $$$ days , morning eat $$$ k $$$ candy box ( less $$$ k $$$ candy box eat ) even petya eat $$$ 10\ % $$$ candy remain box still candy leave box process repeat — next day vasya eat $$$ k $$$ candy petya — $$$ 10\ % $$$ candy leave a box , amount candy box divisible $$$ 10 $$$ petya round amount take box example $$$ 97 $$$ candy box petya would eat $$$ 9 $$$ particular less $$$ 10 $$$ candy a box petya wo n't eat task find minimal amount $$$ k $$$ choose vasya would eat least half $$$ n $$$ candy initially get note number $$$ k $$$ must integer first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 10^ { 18 } $$$ ) — initial amount candy box output a single integer — minimal amount $$$ k $$$ would allow vasya eat least half candy get sample amount candy $$$ k=3 $$$ would change follow way ( vasya eat first ) : $$$ 68 \to 65 \to 59 \to 56 \to 51 \to 48 \to 44 \to 41 \\ \to 37 \to 34 \to 31 \to 28 \to 26 \to 23 \to 21 \to 18 \to 17 \to 14 \\ \to 13 \to 10 \to 9 \to 6 \to 6 \to 3 \to 3 \to 0 $$$ total vasya would eat $$$ 39 $$$ candy petya — $$$ 29 $$$",['implementation'],1500.0
991/D,<unknown> a chess figure consist three square resemble ` ` l - bar '' figure rotate 90 180 270 degrees four possible state : bishwocks n't attack square even occupy adjacent square long n't occupy square vasya a board $$$ 2\times n $$$ square onto want put bishwocks <unknown> several square board already occupy pawn vasya ca n't put bishwocks however pawn also n't attack bishwocks occupy adjacent square peacefully know position pawn board help vasya determine maximum amount bishwocks put onto board would n't occupy square would n't occupy square pawn input contain two nonempty string describe vasya 's board string contain symbols ` ` 0 '' ( zero ) denote empty square symbols ` ` x '' ( uppercase english letter ) denote square occupy pawn string nonempty length exceed $$$ 100 $$$ output a single integer — maximum amount bishwocks place onto give board,"['dp', 'greedy']",1500.0
991/E,night n't easy vasya favorite team lose n't find victorious either — although play perfectly teammates let every time win least one time <unknown> grow longer longer ... 's wonder n't get sleep night morning vasya wait bus university bus stop vasya 's thoughts <unknown> could n't remember right bus ' number quite right get onto bus number $$$ n $$$ bus vasya think could get order digits number bus wrong <unknown> could ` ` see '' digits several time digits saw definitely real number bus example vasya saw number 2028 could mean real bus number could 2028 8022 2820 820 . however number 80 <unknown> 52 definitely could n't number bus also real bus number could n't start digit 0 mean example number <unknown> could n't real bus number give $$$ n $$$ determine total number possible bus number variants first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 10^ { 18 } $$$ ) — number bus see vasya guarantee number start $$$ 0 $$$ output a single integer — amount possible variants real bus number first sample variants $$$ 97 $$$ $$$ 79 $$$ possible second sample variants ( increase order ) follow : $$$ 208 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ 820 $$$ $$$ 2028 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ 2820 $$$ $$$ 8022 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$,['math'],1800.0
992/C,"nastya receive a gift new year — a magic wardrobe magic end month number dress double ( i.e number dress become twice large begin month ) unfortunately right double wardrobe eat one dress ( ) 50 % probability happen every month except last one year nastya own x dress become interest expect number dress one year nastya live byteland year last k + 1 months nastya really busy want solve problem programmer , also find answer modulo 109 + 7 easy see always integer line contain two integers x k ( 0 ≤ x k ≤ 1018 ) x initial number dress k + 1 number months a year byteland line print a single integer — expect number dress nastya one year later modulo 109 + 7 . first example a year consist one month wardrobe eat dress second example first month 3 dress 50 % probability 4 dress 50 % probability thus end year 6 dress 50 % probability 8 dress 50 % probability way answer test ( 6 + 8 ) / 2 = 7",['math'],1600.0
992/D,nastya receive one array birthday array use play a traditional byteland game however play game players first select a subsegment array p product integers give array s sum k a give constant subsegments nastya wonder many subsegments array fit describe condition a subsegment array several consecutive integers array first line contain two integers n k ( 1 ≤ n ≤ 2·105 1 ≤ k ≤ 105 ) n length array k constant describe second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 108 ) — elements array line print number subsegments ratio product sum equal k. first example subsegment [ 1 ] sum equal 1 product equal 1 suit us two suitable subsegments second example — [ 6 3 ] [ 3 8 1 ] subsegment [ 6 3 ] sum 9 product 18 suit us subsegment [ 3 8 1 ] sum 12 product 24 suit us,"['implementation', 'math']",2100.0
993/A,give two square one side parallel coordinate ax another one side 45 degrees coordinate ax find whether two square intersect interior square consider part square i.e one square completely inside another intersect two square share one common point also consider intersect input data consist two line one square contain 4 pair integers pair represent coordinate one vertex square coordinate within line either clockwise counterclockwise order first line contain coordinate square side parallel coordinate ax second line contain coordinate square 45 degrees value integer $$$ -100 $$$ $$$ 100 $$$ print ` ` yes '' square intersect otherwise print ` ` '' print letter case ( upper lower ) first example second square lie entirely within first square intersect second sample square point common image correspond sample :,['implementation'],1600.0
993/E,nikita like task order statistics example easily find $$$ k $$$ -th number increase order a segment array nikita wonder many segment array a give number $$$ x $$$ $$$ k $$$ -th number increase order segment word find number segment a give array exactly $$$ k $$$ number segment less $$$ x $$$ nikita want get answer question $$$ k $$$ $$$ 0 $$$ $$$ n $$$ $$$ n $$$ size array first line contain two integers $$$ n $$$ $$$ x $$$ $$$ ( 1 \le n \le 2 \cdot 100000 -1000000000 \le x \le 1000000000 ) $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( -1000000000 \le a_i \le 1000000000 ) $$$ — give array print $$$ n+1 $$$ integers $$$ i $$$ -th number answer nikita 's question $$$ k = i-1 $$$,['math'],2300.0
994/A,lock a room a door a keypad 10 key correspond digits 0 9 . escape room need enter a correct code also a sequence digits key keypad fingerprint believe correct code longest necessarily contiguous subsequence sequence contain digits fingerprint correspond key find code first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 10 $$$ ) represent number digits sequence number key keypad fingerprint next line contain $$$ n $$$ distinct space - separated integers $$$ x_1 x_2 \ldots x_n $$$ ( $$$ 0 \le x_i \le 9 $$$ ) represent sequence next line contain $$$ m $$$ distinct space - separated integers $$$ y_1 y_2 \ldots y_m $$$ ( $$$ 0 \le y_i \le 9 $$$ ) — key fingerprint a single line print a space - separated sequence integers represent code result sequence empty print nothing print a single line break acceptable first example digits fingerprint $$$ 1 $$$ $$$ 2 $$$ $$$ 7 $$$ three appear sequence know $$$ 7 $$$ first $$$ 1 $$$ $$$ 2 $$$ therefore output 7 1 2 . note order important shall order original sequence second example digits $$$ 0 $$$ $$$ 1 $$$ $$$ 7 $$$ $$$ 9 $$$ fingerprint however $$$ 0 $$$ $$$ 1 $$$ appear original sequence $$$ 1 $$$ appear earlier output 1 0 . order important,['implementation'],800.0
995/A,allen dream one day own a enormous fleet electric cars car future ! know give a big status boost allen plan different type cars arrange realize a problem allen 's future park lot represent a rectangle $$$ 4 $$$ row $$$ n $$$ ( $$$ n \le 50 $$$ ) columns rectangular space contain one car time imagine $$$ k $$$ ( $$$ k \le 2n $$$ ) cars grid cars initially second third row cars also a different designate park space first fourth row allen put cars correspond park place however since allen would never entrust cars anyone else one car move a time drive a car a space four cardinal directions a neighbor empty space furthermore allen move one cars a space first fourth row car 's designate park space allen know a busy man time move cars $$$ 20000 $$$ time realize move cars worth time help allen determine bother park cars leave someone less important first line input contain two space - separated integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 50 $$$ $$$ 1 \le k \le 2n $$$ ) represent number columns number cars respectively next four line contain $$$ n $$$ integers $$$ 0 $$$ $$$ k $$$ inclusive represent initial state park lot row number $$$ 1 $$$ $$$ 4 $$$ top bottom columns number $$$ 1 $$$ $$$ n $$$ leave right first last line integer $$$ 1 \le x \le k $$$ represent a park spot assign car $$$ x $$$ ( move car place ) integer $$$ 0 $$$ represent a empty space ( ca n't move car place ) second third line integer $$$ 1 \le x \le k $$$ represent initial position car $$$ x $$$ integer $$$ 0 $$$ represent empty space ( move car place ) $$$ x $$$ $$$ 1 $$$ $$$ k $$$ appear exactly second third line exactly first fourth line a sequence move bring cars park space $$$ 20000 $$$ car move print $$$ m $$$ number move first line follow $$$ m $$$ line print move ( one move per line ) format $$$ i $$$ $$$ r $$$ $$$ c $$$ correspond allen move car $$$ i $$$ neighbor space row $$$ r $$$ column $$$ c $$$ possible allen move cars correct space $$$ 20000 $$$ car move print a single line integer $$$ -1 $$$ first sample test case cars front spot except car $$$ 5 $$$ front park spot adjacent example show shortest possible sequence move sequence length $$$ 20000 $$$ accept second sample test case one column cars wrong order cars move task impossible,['implementation'],2100.0
995/C,a vector $$$ \vec { v } = ( x y ) $$$ define $$$ |v| = \sqrt { x^2 + y^2 } $$$ allen a bite much drink bar origin $$$ n $$$ vectors $$$ \vec { v_1 } \vec { v_2 } \cdots \vec { v_n } $$$ allen make $$$ n $$$ move allen 's sense direction <unknown> $$$ i $$$ -th move either move direction $$$ \vec { v_i } $$$ $$$ <unknown> { v_i } $$$ word position currently $$$ p = ( x y ) $$$ either move $$$ p + \vec { v_i } $$$ $$$ p - \vec { v_i } $$$ allen n't want wander far home ( happen also bar ) need help figure a sequence move ( a sequence sign vectors ) final position $$$ p $$$ satisfy $$$ |p| \le 1.5 \cdot 1000000 $$$ stay safe first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number move follow line contain two space - separated integers $$$ x_i $$$ $$$ y_i $$$ mean $$$ \vec { v_i } = ( x_i y_i ) $$$ $$$ <unknown> \le 1000000 $$$ $$$ i $$$ output a single line contain $$$ n $$$ integers $$$ c_1 c_2 \cdots c_n $$$ either $$$ 1 $$$ $$$ -1 $$$ solution correct value $$$ p = \sum _ { i = 1 } ^n c_i \vec { v_i } $$$ satisfy $$$ |p| \le 1.5 \cdot 1000000 $$$ show a solution always exist give constraints,"['data structures', 'greedy', 'math']",2300.0
995/F,"allen graduate moo institute <unknown> ( <unknown> ) start a startup ! allen president startup also hire $$$ n-1 $$$ employees assign a direct superior $$$ u $$$ a superior $$$ v $$$ $$$ v $$$ a superior $$$ w $$$ also $$$ u $$$ a superior $$$ w $$$ additionally $$$ u $$$ $$$ v $$$ $$$ u $$$ superior $$$ v $$$ $$$ v $$$ superior $$$ u $$$ allen superior allen employee number $$$ 1 $$$ others employee number $$$ 2 $$$ $$$ n $$$ finally allen must assign salaries employee company include due budget constraints employee 's salary integer $$$ 1 $$$ $$$ d $$$ additionally employee make strictly superior help allen find number ways assign salaries number may large output modulo $$$ 1000000000 + 7 $$$ first line input contain two integers $$$ n $$$ $$$ d $$$ ( $$$ 1 \le n \le 3000 $$$ $$$ 1 \le d \le 1000000000 $$$ ) remain $$$ n-1 $$$ line contain a single positive integer $$$ i $$$ -th line contain integer $$$ p_i $$$ ( $$$ 1 \le p_i \le i $$$ ) $$$ p_i $$$ denote direct superior employee $$$ i+1 $$$ output a single integer : number ways assign salaries modulo $$$ 1000000000 + 7 $$$ first sample case employee 2 3 report directly allen three salaries order $$$ ( 1,1,1 ) $$$ $$$ ( 2,1,1 ) $$$ $$$ ( 2,1,2 ) $$$ $$$ ( 2,2,1 ) $$$ $$$ ( 2,2,2 ) $$$ second sample case employee 2 report allen employee 3 report employee 2 . order possible salaries $$$ ( 1,1,1 ) $$$ $$$ ( 2,1,1 ) $$$ $$$ ( 2,2,1 ) $$$ $$$ ( 2,2,2 ) $$$ $$$ ( 3,1,1 ) $$$ $$$ ( 3,2,1 ) $$$ $$$ ( 3,2,2 ) $$$ $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ $$$ ( 3,3,3 ) $$$","['dp', 'math']",2700.0
997/A,"' ve get a string $$$ a_1 a_2 \dots a_n $$$ consist zero ones let 's call a sequence consecutive elements $$$ a_i a _ { i + 1 } \ldots a_j $$$ ( $$$ 1\leq i\leq j\leq n $$$ ) a substring string $$$ a $$$ apply follow operations number time : apply operations order allow apply operations multiple time substring minimum number coin need spend get a string consist ones ? first line input contain integers $$$ n $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq n \leq 300\,000 0 \leq x y \leq 1000000000 $$$ ) — length string cost first operation ( substring reverse ) cost second operation ( invert elements substring ) second line contain string $$$ a $$$ length $$$ n $$$ consist zero ones print a single integer — minimum total cost operations need spend get a string consist ones print $$$ 0 $$$ need perform operations first sample first need reverse substring $$$ [ 1 \dots 2 ] $$$ need invert substring $$$ [ 2 \dots 5 ] $$$ string change follow : « 01000 » $$$ \to $$$ « 10000 » $$$ \to $$$ « 11111 » total cost operations $$$ 1 + 10 = 11 $$$ second sample first need invert substring $$$ [ 1 \dots 1 ] $$$ need invert substring $$$ [ 3 \dots 5 ] $$$ string change follow : « 01000 » $$$ \to $$$ « 11000 » $$$ \to $$$ « 11111 » overall cost $$$ 1 + 1 = 2 $$$ third example string already consist ones answer $$$ 0 $$$","['greedy', 'implementation', 'math']",1500.0
