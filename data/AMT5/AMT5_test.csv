,description,tags,rating
1747/D,give array $$$ a $$$ $$$ n $$$ integers $$$ a_1 a_2 a_3 \ldots a_n $$$ answer $$$ q $$$ independent query consist two integers $$$ l $$$ $$$ r $$$ find detail xor operation first line contain two integers $$$ n $$$ $$$ q $$$ $$$ ( 1 \le n q \le 2 \cdot 100000 ) $$$ — length array $$$ a $$$ number query next line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 0 \le a_i \lt 2^ { 30 } ) $$$ — elements array $$$ a $$$ $$$ i $$$ -th next $$$ q $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ $$$ ( 1 \le l_i \le r_i \le n ) $$$ — description $$$ i $$$ -th query query output a single integer — answer query first query $$$ l = 3 r = 4 $$$ subarray = $$$ [ 3 3 ] $$$ apply operation subarrays length $$$ 1 $$$ wo n't change array ; hence impossible make elements equal $$$ 0 $$$ second query $$$ l = 4 r = 6 $$$ subarray = $$$ [ 3 1 2 ] $$$ choose whole subarray $$$ ( l = 4 r = 6 ) $$$ replace elements xor $$$ ( 3 \oplus 1 \oplus 2 ) = 0 $$$ make subarray $$$ [ 0 0 0 ] $$$ fifth query $$$ l = 1 r = 6 $$$ subarray = $$$ [ 3 0 3 3 1 2 ] $$$ make operations follow :,['data structures'],1900.0
1771/F,hossam give a sequence integers $$$ a_1 \ a_2 \ \dots \ a_n $$$ length $$$ n $$$ moreover give $$$ q $$$ query type $$$ ( l \ r ) $$$ query consider elements $$$ a_l \ a _ { l + 1 } \ \dots \ a_r $$$ hossam want know smallest number sequence occur sequence odd number time need compute answer query process next query first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) length sequence second line contain $$$ n $$$ integers $$$ a_1 \ a_2 \ \dots \ a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) third line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) number query next $$$ q $$$ line contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 0 \le a \ b \le 2000000000 $$$ ) number use encode query let $$$ \mathrm { ans } _ i $$$ answer $$$ i $$$ -th query $$$ \mathrm { ans } _ 0 $$$ zero $$$ $$$ l_i = a_i \oplus \mathrm { ans } _ { i - 1 } $$$ $$$ $$$ $$$ r_i = b_i \oplus \mathrm { ans } _ { i - 1 } $$$ $$$ $$$ l_i \ r_i $$$ parameters $$$ i $$$ -th query $$$ \oplus $$$ mean bitwise exclusive operation guarantee $$$ 1 \le l \le r \le n $$$ query print smallest number occur odd number time give segment sequence number print $$$ 0 $$$ example $$$ $$$ l_1 = 1 \ r_1 = 2 $$$ $$$ $$$ $$$ l_2 = 1 \ r_2 = 3 $$$ $$$ $$$ $$$ <unknown> = 2 \ r_3 = 4 $$$ $$$ $$$ $$$ <unknown> = 1 \ <unknown> = 4 $$$ $$$ $$$ $$$ <unknown> = 2 \ <unknown> = 2 $$$ $$$ $$$ $$$ <unknown> = 1 \ <unknown> = 5 $$$ $$$,['data structures'],2500.0
1777/F,give array $$$ a $$$ consist $$$ n $$$ non - negative integers numbness a subarray $$$ a_l a _ { l+1 } \ldots a_r $$$ ( arbitrary $$$ l \leq r $$$ ) define $$$ $$$ \max ( a_l a _ { l+1 } \ldots a_r ) \oplus ( a_l \oplus a _ { l+1 } \oplus \ldots \oplus a_r ) $$$ $$$ $$$ \oplus $$$ denote bitwise xor operation find maximum numbness subarrays test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print one integer — maximum numbness subarrays give array first test case subarray $$$ [ 3 4 5 ] $$$ maximum value $$$ 5 $$$ hence numbness $$$ 3 \oplus 4 \oplus 5 \oplus 5 $$$ = $$$ 7 $$$ maximum possible numbness array second test case subarray $$$ [ 47 52 ] $$$ provide maximum numbness,['data structures'],2400.0
1556/G,mention previously william really like play video game one favorite game player character a universe every planet <unknown> a binary number $$$ 0 $$$ $$$ 2^n - 1 $$$ planet gate allow player move planet $$$ i $$$ planet $$$ j $$$ binary representations $$$ i $$$ $$$ j $$$ differ exactly one bite william want test see handle process follow query game universe : first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 50 $$$ $$$ 1 \leq m \leq 50000 $$$ ) number bits binary representation planets ' <unknown> number query respectively next $$$ m $$$ line contain a query two type : block l r — query destruction planets number $$$ l $$$ $$$ r $$$ inclusively ( $$$ 0 \le l \le r < 2^n $$$ ) 's guarantee planet destroy <unknown> a b — query reachability planets $$$ a $$$ $$$ b $$$ ( $$$ 0 \le a b < 2^n $$$ ) 's guarantee planets $$$ a $$$ $$$ b $$$ n't destroy yet query type ask must output ` ` 1 '' a new line possible reach planet $$$ b $$$ planet $$$ a $$$ ` ` 0 '' otherwise ( without <unknown> mark ) first example test <unknown> follow way : response a query ask 0 7 positive next query block 3 6 graph look follow way ( destroy vertices highlight ) : response a query ask 0 7 negative since path vertex $$$ 0 $$$ vertex $$$ 7 $$$ must go one destroy vertices,['data structures'],3300.0
235/C,days ago <unknown> learn answer query ` ` many time a string x occur a string s '' quickly <unknown> string s. want make harder want ask ` ` many consecutive substrings s cyclical isomorphic a give string x '' give string s n string xi string xi find many consecutive substrings s cyclical isomorphic xi two string call cyclical isomorphic one rotate one string get one ' rotate ' mean ' to take consecutive <unknown> ( maybe none ) begin a string put back end string order ' example string ` ` abcde '' rotate string ` ` <unknown> '' take character ` ` abc '' begin put end ` ` <unknown> '' first line contain a non - empty string s. length string s greater 106 character second line contain integer n ( 1 ≤ n ≤ 105 ) — number query n line follow : i - th line contain string xi — string i - th query total length xi less equal 106 character problem string consist lowercase english letter query xi print a single integer show many consecutive substrings s cyclical isomorphic xi print answer query order give input,['data structures'],2700.0
1437/G,simplicity let 's say ` ` death note '' a notebook kill a person name write 's easy kill 's pretty hard keep track people n't kill still plan decide make a ` ` death database management system '' — a computer program provide easy access database possible victims let describe <unknown> let 's define a victim <unknown> : a victim a name ( necessarily unique ) consist lowercase latin letter integer suspicion value start program user enter a list $$$ n $$$ victim name a database suspicion value set $$$ 0 $$$ user make query two type : remind program n't kill people help search name write actual notebook thus list victims database n't change throughout query wait ? write program ! first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 300000 $$$ ) — number victims number query respectively next $$$ n $$$ line contain a single string $$$ s_i $$$ — name $$$ i $$$ -th victim name consist lowercase latin letter next $$$ m $$$ line contain a query one two type : least one query second type total length string $$$ s_i $$$ n't exceed $$$ 300000 $$$ total length string $$$ q $$$ n't exceed $$$ 300000 $$$ query second type print integer value victim name a contiguous substring $$$ q $$$ print $$$ -1 $$$ otherwise print maximum suspicion value a victim whose name a contiguous substring $$$ q $$$,['data structures'],2600.0
1608/G,give $$$ m $$$ string a tree $$$ n $$$ nod edge letter write answer $$$ q $$$ query query describe $$$ 4 $$$ integers $$$ u $$$ $$$ v $$$ $$$ l $$$ $$$ r $$$ answer query total number occurrences $$$ str ( u v ) $$$ string indices $$$ l $$$ $$$ r $$$ $$$ str ( u v ) $$$ define string make concatenate letter write edge shortest path $$$ u $$$ $$$ v $$$ ( order traverse ) first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 2 \le n \le 100000 $$$ $$$ 1 \le m q \le 100000 $$$ ) $$$ i $$$ -th follow $$$ n-1 $$$ line contain two integers $$$ u_i v_i $$$ a lowercase latin letter $$$ c_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \neq v_i $$$ ) denote edge nod $$$ u_i v_i $$$ a character $$$ c_i $$$ 's guarantee edge form a tree follow $$$ m $$$ line contain string consist lowercase latin letter total length string exceed $$$ 100000 $$$ $$$ q $$$ line follow contain four integers $$$ u $$$ $$$ v $$$ $$$ l $$$ $$$ r $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ $$$ 1 \le l \le r \le m $$$ ) denote query query print a single integer — answer query,['data structures'],3500.0
1621/I,consider array integers $$$ c = [ c_1 c_2 \ldots c_n ] $$$ length $$$ n $$$ let 's build sequence array $$$ <unknown> d_1 d_2 \ldots d _ { n } $$$ length $$$ n+1 $$$ follow way : array $$$ x $$$ subarray array $$$ y $$$ $$$ x $$$ obtain deletion several ( possibly zero ) elements begin $$$ y $$$ several ( possibly zero ) elements end $$$ y $$$ array $$$ c $$$ let 's denote array $$$ d_n $$$ $$$ op ( c ) $$$ alice array integers $$$ a = [ a_1 a_2 \ldots a_n ] $$$ length $$$ n $$$ build sequence array $$$ b_0 b_1 \ldots b_n $$$ length $$$ n+1 $$$ follow way : ask $$$ q $$$ query elements sequence array $$$ b_0 b_1 \ldots b_n $$$ query consist two integers $$$ i $$$ $$$ j $$$ answer query value $$$ j $$$ -th element array $$$ b_i $$$ first line contain single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — array $$$ a $$$ third line contain single integer $$$ q $$$ ( $$$ 1 \leq q \leq 1000000 $$$ ) — number query next $$$ q $$$ line contain two integers $$$ i $$$ $$$ j $$$ ( $$$ 1 \leq i j \leq n $$$ ) — parameters query output $$$ q $$$ integers : value $$$ b _ { i j } $$$ require $$$ i $$$ $$$ j $$$ first test case $$$ b_0 = a = [ 2 1 3 1 ] $$$ $$$ b_1 $$$ construct follow way :,['data structures'],3500.0
1801/G,", take string $$$ t $$$ a set $$$ n $$$ string $$$ s_1 $$$ $$$ s_2 $$$ $$$ s_3 $$$ ... $$$ s_n $$$ philip $$$ m $$$ query $$$ i $$$ th philip want take a substring string $$$ t $$$ $$$ l_i $$$ th $$$ r_i $$$ th character count number substrings match string set formally philip want count number pair position $$$ a $$$ $$$ b $$$ $$$ l_i \le a \le b \le r_i $$$ substring string $$$ t $$$ $$$ a $$$ th $$$ b $$$ th character coincide string $$$ s_j $$$ set a substring string $$$ t $$$ $$$ a $$$ th $$$ b $$$ th character a string obtain $$$ t $$$ remove $$$ a - 1 $$$ character begin $$$ |t| - b $$$ character end $$$ |t| $$$ denote length string $$$ t $$$ philip already solve problem ? first line contain two positive integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 500\,000 $$$ ) — number row set number query second line contain a single string $$$ t $$$ consist lowercase letter english alphabet ( $$$ 1 \le |t| \le 5000000 $$$ ) follow $$$ n $$$ line describe string set $$$ i $$$ th a single string $$$ s_i $$$ give consist lowercase letter english alphabet denote $$$ s $$$ total length string set guarantee $$$ s \le 1000000 $$$ well string $$$ s_i $$$ different follow line query enter $$$ i $$$ th contain two positive integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le |t| $$$ ) — leave right border substring $$$ t $$$ $$$ i $$$ -th query a single line print $$$ m $$$ integers $$$ i $$$ th equal answer $$$ i $$$ th query first example first query require entire string count number substrings include set substrings $$$ [ 1 3 ] $$$ $$$ [ 4 6 ] $$$ coincide string ` ` aba '' substrings match string ` ` a '' $$$ [ 1 1 ] $$$ $$$ [ 3 3 ] $$$ $$$ [ 5 5 ] $$$ $$$ [ 7 7 ] $$$ substring $$$ [ 3 4 ] $$$ match string ` ` ac '' total turn 7 substrings string ` ` abacaba '' match string set second query a substring position 1 position 3 take source string string ` ` aba '' string ` ` aba '' enter 1 time string ` ` a '' enter 2 time string ` ` ac '' enter a substring third query a substring 2nd <unknown> position take source string string ` ` <unknown> '' string ` ` aba '' include 1 time string ` ` a '' include 3 time string ` ` ac '' include 1 time a substring",['data structures'],3400.0
727/E,several years ago tolya n computer game point time decide burn cd write name game one another a circle cd clockwise order name distinct length name equal k. name n't overlap thus a cyclic string length n·k write cd several years pass tolya ca n't remember game burn cd know g popular game days game burn among g game game burn restore valid list game tolya could burn cd several years ago first line input contain two positive integers n k ( 1 ≤ n ≤ 105 1 ≤ k ≤ 105 ) — amount game tolya burn cd length name second line input contain one string consist lowercase english letter — string tolya write cd split arbitrary place length string n·k guarantee length greater 106 . third line input contain one positive integer g ( n ≤ g ≤ 105 ) — amount popular game could write cd guarantee total length name popular game greater 2·106 next g line contain a single string — name popular game name consist lowercase english letter length k. guarantee name distinct answer print ` ` '' ( without quote ) otherwise print two line first line print ` ` yes '' ( without quote ) second line print n integers — game name write cd print game order could write cd mean clockwise order print game start position remember game burn cd several possible answer print,['data structures'],2300.0
1207/G,mishka 's favourite <unknown> <unknown> band recently drop a new album ! songs album share one <unknown> name $$$ s_i $$$ one follow type : songs number $$$ 1 $$$ $$$ n $$$ 's guarantee first song always type $$$ 1 $$$ vova rather interest new album really n't time listen entirely thus ask mishka question determine song worth listen question follow format : mishka n't question purpose information yet <unknown> provide please help mishka answer vova 's question ? first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 400000 $$$ ) — number songs album next $$$ n $$$ line contain desciption $$$ i $$$ -th song album follow format : next line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 400000 $$$ ) — number vova 's question next $$$ m $$$ line contain desciption $$$ j $$$ -th vova 's question follow format : 's guarantee total length question string $$$ t $$$ n't exceed $$$ 400000 $$$ question print a single integer — number occurrences question string $$$ t $$$ name $$$ i $$$ -th song album a continuous substring song name first example : thus occurrences question string :,['data structures'],2700.0
1073/G,let $$$ \text { lcp } ( s t ) $$$ length longest common prefix string $$$ s $$$ $$$ t $$$ also let $$$ s [ x \dots y ] $$$ substring $$$ s $$$ index $$$ x $$$ index $$$ y $$$ ( inclusive ) example $$$ s = $$$ ` ` abcde '' $$$ s [ 1 \dots 3 ] = $$$ ` ` abc '' $$$ s [ 2 \dots 5 ] = $$$ ` ` <unknown> '' give a string $$$ s $$$ length $$$ n $$$ $$$ q $$$ query query a pair integer set $$$ a_1 a_2 \dots a_k $$$ $$$ b_1 b_2 \dots b_l $$$ calculate $$$ \sum\limits _ { i = 1 } ^ { i = k } \sum\limits _ { j = 1 } ^ { j = l } { \text { lcp } ( s [ a_i \dots n ] s [ b_j \dots n ] ) } $$$ query first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n q \le 200000 $$$ ) — length string $$$ s $$$ number query respectively second line contain a string $$$ s $$$ consist lowercase latin letter ( $$$ |s| = n $$$ ) next $$$ <unknown> $$$ line contain descriptions query — three line per query first line query contain two integers $$$ k_i $$$ $$$ l_i $$$ ( $$$ 1 \le k_i l_i \le n $$$ ) — size set $$$ a $$$ $$$ b $$$ respectively second line query contain $$$ k_i $$$ integers $$$ a_1 a_2 \dots a _ { k_i } $$$ ( $$$ 1 \le a_1 < a_2 < \dots < a _ { k_i } \le n $$$ ) — set $$$ a $$$ third line query contain $$$ l_i $$$ integers $$$ b_1 b_2 \dots b _ { l_i } $$$ ( $$$ 1 \le b_1 < b_2 < \dots < b _ { l_i } \le n $$$ ) — set $$$ b $$$ guarantee $$$ \sum\limits _ { i = 1 } ^ { i = q } { k_i } \le 200000 $$$ $$$ \sum\limits _ { i = 1 } ^ { i = q } { l_i } \le 200000 $$$ print $$$ q $$$ integers — answer query order query give input description query :,['data structures'],2600.0
1043/G,"ildar take a band ( a <unknown> strip <unknown> ) color formally band $$$ n $$$ cells color one $$$ 26 $$$ color denote color one lowercase letter english alphabet ildar decide take segment band $$$ [ l r ] $$$ ( $$$ 1 \le l \le r \le n $$$ ) like cut band create a new band represent a string $$$ t = s_l s _ { l+1 } \ldots s_r $$$ ildar play follow game : cut band $$$ t $$$ new band count number different band among formally ildar choose $$$ 1 \le k \le |t| $$$ index $$$ 1 \le i_1 < i_2 < \ldots < i_k = |t| $$$ cut $$$ t $$$ $$$ k $$$ <unknown> - strings $$$ t_1 t_2 \ldots t _ { i_1 } t _ { i_1 + 1 } \ldots t _ { i_2 } \ldots { t _ { i _ { k-1 } + 1 } } \ldots t _ { i_k } $$$ count number different band among want know minimal possible number different band get constraint least one band repeat least two time result game number impossible cut $$$ t $$$ a way result game -1 . unfortunately ildar n't yet decide segment like $$$ q $$$ <unknown> - candidates $$$ [ l_1 r_1 ] $$$ $$$ [ l_2 r_2 ] $$$ ... $$$ [ <unknown> <unknown> ] $$$ task calculate result game first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200\,000 $$$ ) — length band ildar second line contain a string $$$ s $$$ consist $$$ n $$$ lowercase english letter — band ildar third line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 200\,000 $$$ ) — number segment ildar choose candidates next $$$ q $$$ line contain two integer integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) denote end $$$ i $$$ -th segment output $$$ q $$$ line $$$ i $$$ -th contain result game segment $$$ [ l_i r_i ] $$$ consider first example ildar choose segment $$$ [ 1 6 ] $$$ cut a string $$$ t = abcabc $$$ cut $$$ t $$$ two band $$$ abc $$$ $$$ abc $$$ band $$$ abc $$$ repeat two time number different tap $$$ 1 $$$ , result game $$$ 1 $$$ ildar choose segment $$$ [ 4 7 ] $$$ cut a string $$$ t = abcd $$$ impossible cut band a way least one band repeat least two time , result game $$$ -1 $$$ ildar choose segment $$$ [ 3 6 ] $$$ cut a string $$$ t = <unknown> $$$ cut $$$ t $$$ three band $$$ c $$$ $$$ ab $$$ $$$ c $$$ band $$$ c $$$ repeat two time number different band $$$ 2 $$$ , result game $$$ 2 $$$",['data structures'],3500.0
1037/H,program website establish a secure communication protocol security reason want choose several less random string initially a string $$$ s $$$ consist lowercase english letter want choose $$$ q $$$ string use follow step help string $$$ a $$$ lexicographically less string $$$ b $$$ either $$$ a $$$ a prefix $$$ b $$$ $$$ a \ne b $$$ exist a position $$$ i $$$ ( $$$ 1 \le i \le min ( |a| |b| ) $$$ ) $$$ a_i < b_i $$$ $$$ j $$$ ( $$$ 1 \le j < i $$$ ) $$$ a_j = b_j $$$ $$$ |a| $$$ denote length string $$$ a $$$ first line input contain a non - empty string $$$ s $$$ ( $$$ 1 \leq |s| \leq 10^ { 5 } $$$ ) consist lowercase english letter second line contain integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number string select next $$$ q $$$ line contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l \leq r \leq |s| $$$ ) a non - empty string $$$ x $$$ consist lowercase english letter total length string $$$ x $$$ query exceed $$$ 2 \cdot 10^ { 5 } $$$ output $$$ q $$$ line contain desire string $$$ -1 $$$ string consider first example string $$$ s $$$ ` ` <unknown> '' query follow,['data structures'],3200.0
452/E,give three string ( s1 s2 s3 ) integer l ( 1 ≤ l ≤ min ( |s1| |s2| |s3| ) need find many triple ( i1 i2 i3 ) exist three string sk [ ik ... ik + l - 1 ] ( k = 1 2 3 ) pairwise equal print find number modulo 1000000007 ( 109 + 7 ) see note sure <unknown> use statement first three line contain three non - empty input string sum lengths string 3·105 string consist lowercase english letter need output min ( |s1| |s2| |s3| ) number separate space — answer problem modulo 1000000007 ( 109 + 7 ) consider a string t = <unknown> ... <unknown> ti denote i - th character string |t| denote length string t [ i ... j ] ( 1 ≤ i ≤ j ≤ |t| ) represent string <unknown> + 1 ... tj ( substring t position i position j inclusive ),['data structures'],2400.0
514/C,watto owner a spare part store recently get order mechanism process string a certain way initially memory mechanism fill n string mechanism able process query follow type : ` ` give string s determine memory mechanism contain string t consist number character s differ s exactly one position '' watto already compile mechanism 's leave write a program check data consist n initial line m query decide <unknown> job first line contain two non - negative number n m ( 0 ≤ n ≤ 3·105 0 ≤ m ≤ 3·105 ) — number initial string number query respectively next follow n non - empty string <unknown> memory mechanism next follow m non - empty string query mechanism total length line input n't exceed 6·105 line consist letter ' a ' ' b ' ' c ' query print a single line ` ` yes '' ( without quote ) memory mechanism contain require string otherwise print ` ` '' ( without quote ),['data structures'],2000.0
547/E,<unknown> - the - <unknown> a strange country ! phone number string consist lowercase english letter double strange a phone number associate several bear ! country a rock band call cf consist n bear ( include mike ) number 1 n. phone number i - th member cf si may <unknown> a holiday name phone call day last phone call day everyone call number substrings his / her number ( one may call number several time ) particular everyone call ( really strange country ) denote call ( i j ) number time i - th member cf call j - th member cf <unknown> mike q question want ask question give number l r k tell number first line input contain integers n q ( 1 ≤ n ≤ 2 × 105 1 ≤ q ≤ 5 × 105 ) next n line contain phone number i - th line contain a string si consist lowercase english letter ( ) next q line contain information question contain integers l r k ( 1 ≤ l ≤ r ≤ n 1 ≤ k ≤ n ) print answer question a separate line,['data structures'],2800.0
653/F,alex program valentina ( <unknown> daughter ) get start ask many question round bracket ( parenthesis ) code explain a bite get give a task order finish code time purpose problem consider string consist open close round bracket character ' ( ' ' ) ' sequence bracket call correct : example sequence ` ` ( ) ( ) '' ` ` ( ( ( ) ) ) ( ( ) ) '' correct ` ` ) ( ( ) '' ` ` ( ( ( ( ( ` ` ` ` ( ) ) '' alex take a piece paper write a string s consist bracket ask valentina count number distinct non - empty substrings s correct sequence bracket word task count number non - empty correct sequence bracket occur a string s a substring ( n't mix subsequences ) valentina finish task alex notice n't know answer help n't loose face front valentina solve problem ! first line input contain integer n ( 1 ≤ n ≤ 500 000 ) — length string s. second line contain a string s length n consist ' ( ' ' ) ' print number distinct non - empty correct sequence occur s substring first sample 5 distinct substrings count : ` ` ( ) '' ` ` ( ) ( ) '' ` ` ( ) ( ) ( ) '' ` ` ( ) ( ) ( ) ( ) '' ` ` ( ) ( ) ( ) ( ) ( ) '' second sample 3 distinct substrings count : ` ` ( ) '' ` ` ( ( ) ) '' ` ` ( ( ) ) ( ) '',['data structures'],2600.0
666/E,country <unknown> <unknown> berland recently authorities berland arrest a <unknown> spy try bring leaflets intend <unknown> <unknown> berland <unknown> leaflets contain substrings absolutely inadmissible swearword maybe even whole word berland <unknown> system use difficult algorithm order determine <unknown> spy main part algorithm follow procedure m leaflets bring spy number 1 m. 's need get answer q query follow kind : ` ` leaflet segment number [ l r ] substring absolutely inadmissible swearword [ pl pr ] occur often ? ` ` expert want automate procedure time texts leaflets long help ! first line contain string s ( 1 ≤ |s| ≤ 5·105 ) — absolutely inadmissible swearword string s consist lowercase english letter second line contain integer m ( 1 ≤ m ≤ 5·104 ) — number texts leaflets expertise next m line contain string ti — text i - th leaflet sum lengths leaflet texts n't exceed 5·104 text leaflets consist lowercase english letter next line contain integer q ( 1 ≤ q ≤ 5·105 ) — number query expertise finally last q line contain four integers l r pl pr ( 1 ≤ l ≤ r ≤ m 1 ≤ pl ≤ pr ≤ |s| ) |s| length absolutely inadmissible swearword print q line i - th contain two integers — number text occurences number occurences substring [ pl pr ] string s. several text number print smallest one,['data structures'],3100.0
710/F,process m query a set d string query one three kinds : note solve problem online mode mean ca n't read whole input read query write answer last query third type use function fflush c++ bufferedwriter.flush java languages write program first line contain integer m ( 1 ≤ m ≤ 3·105 ) — number query next m line contain integer t ( 1 ≤ t ≤ 3 ) nonempty string s — kind query string process string consist lowercase english letter sum lengths string input exceed 3·105 query third kind print integer c — desire number occurrences string s,['data structures'],2400.0
741/E,us know girls arpa ’ s land ... ok ’ get idea : <unknown> know arpa n't a normal man ... well sorry i ca n't explain mehrdad interest reason ask sipa one best biology scientists arpa 's land help sipa a dna editor sipa put arpa dna editor dna editor show arpa 's dna a string s consist n lowercase english letter also sipa another dna t consist lowercase english letter belong a normal man ( n + 1 ) options change arpa 's dna number 0 n. i - th put t i - th ( i + 1 ) -th character s ( 0 ≤ i ≤ n ) i = 0 t put s i = n put s. mehrdad want choose interest option arpa 's dna among n + 1 options dna a interest b a lexicographically smaller b. mehrdad ask sipa q question : give integers l r k x y interest option consider options i l ≤ i ≤ r ? several interest options mehrdad want know one smallest number i. since sipa a biology scientist a programmer help first line contain string s t integer q ( 1 ≤ |s| |t| q ≤ 105 ) — arpa 's dna dna a normal man number mehrdad 's question string s t consist small english letter next q line describe mehrdad 's question line contain five integers l r k x y ( 0 ≤ l ≤ r ≤ n 1 ≤ k ≤ n 0 ≤ x ≤ y < k ) print q integers j - th number i interest option among satisfy condition j - th question option i satisfy condition question print -1 . explanation first sample case : first question sipa two options : <unknown> ( i = 0 ) abdc ( i = 2 ) latter ( abcd ) better abdc answer 2 . last question i 0 ≤ i ≤ 1,['data structures'],3400.0
914/F,give a string s process q query one follow form : first line input contain string s ( 1 ≤ |s| ≤ 105 ) lowercase english letter second line contain integer q ( 1 ≤ q ≤ 105 ) — number query process next q line describe query may one follow form : c a lowercase english letter y a non - empty string consist lowercase english letter sum |y| query second type 105 . guarantee least one query second type string 1 - <unknown> length string s. query type 2 output require answer a separate line consider first sample case initially string aba occur 3 time range [ 1 7 ] note two occurrences may overlap update string become <unknown> aba occur range [ 1 7 ],['data structures'],3000.0
1515/H,"phoenix love play bits — specifically use bitwise operations , xor $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ perform $$$ q $$$ follow query : query phoenix give $$$ l $$$ $$$ r $$$ $$$ x $$$ note consider value number indices first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 1 \le q \le 100000 $$$ ) — number integers number query respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i < 2^ { 20 } $$$ ) — integers phoenix start next $$$ q $$$ line contain query query first integer line $$$ t $$$ ( $$$ 1 \le t \le 4 $$$ ) — type query $$$ t \in \ { 1 2 3\ } $$$ three integers $$$ l_i $$$ $$$ r_i $$$ $$$ x_i $$$ follow ( $$$ 0 \le l_i r_i x_i < 2^ { 20 } $$$ ; $$$ l_i \le r_i $$$ ) otherwise $$$ t=4 $$$ two integers $$$ l_i $$$ $$$ r_i $$$ follow ( $$$ 0 \le l_i \le r_i < 2^ { 20 } $$$ ) guarantee least one query $$$ t=4 $$$ print answer query $$$ t=4 $$$ first example :",['data structures'],3500.0
817/E,"might remember previous round vova currently play a <unknown> game know rage empires vova manage build a large army forget main person army - commander try hire a commander want choose person respect warriors warrior represent personality — integer number pi commander two characteristics — personality pj leadership lj ( integer number ) warrior i respect commander j ( bitwise exclude x y ) initially vova 's army empty three different type events happen army : event third type vova want know many warriors ( count join army n't leave yet ) respect commander try hire first line contain one integer q ( 1 ≤ q ≤ 100000 ) — number events q line follow line describe event : event third type print one integer — number warriors respect commander vova try hire event example army consist two warriors <unknown> 3 4 first two events vova try hire a commander personality 6 leadership 3 one warrior respect ( 2 < 3 , 5 ≥ 3 ) warrior personality 4 leave vova try hire commander warriors respect",['data structures'],2000.0
875/D,<unknown> : lot <unknown> <unknown> russian version statement one reason learn russian : ) rick morty like go ridge high cry cry loudly — <unknown> <unknown> recently discover interest <unknown> characteristic ridge : rick morty begin cry simultaneously different mountains cry would hear mountains height equal bitwise mountains ' ve climb mountains bitwise a binary operation determine follow way consider representation number x y binary <unknown> system ( probably lead zero ) x = xk ... <unknown> y = <unknown> ... <unknown> z = x | y define follow way : z = <unknown> ... <unknown> zi = 1 xi = 1 yi = 1 zi = 0 otherwise word digit bitwise two number equal zero digits correspond position number equal zero example bitwise number 10 = 10102 9 = 10012 equal 11 = <unknown> . program languages c / c++/java / python operation define « | » pascal « » help rick morty calculate number ways select two mountains a way start cry mountains cry hear mountains mountains formally find number pair l r ( 1 ≤ l < r ≤ n ) bitwise heights mountains l r ( inclusive ) larger height mountain interval first line contain integer n ( 1 ≤ n ≤ 200 000 ) number mountains ridge second line contain n integers ai ( 0 ≤ ai ≤ 109 ) heights mountains order locate ridge print integer number ways choose two different mountains first test case ways pair mountains number ( number one ) : second test case pair pair mountains height cry 3 height equal height mountain,['data structures'],2200.0
888/G,give a complete undirected graph n vertices a number ai assign vertex weight edge vertices i j equal ai xor aj calculate weight minimum span tree graph first line contain n ( 1 ≤ n ≤ 200000 ) — number vertices graph second line contain n integers a1 a2 ... ( 0 ≤ ai < 230 ) — number assign vertices print one number — weight minimum span tree graph,['data structures'],2300.0
914/E,give a tree ( a connect acyclic undirected graph ) n vertices vertices number 1 n vertex assign a character a t. a path tree say palindromic least one permutation label path a palindrome vertex output number palindromic paths pass note : path vertex u vertex v consider path vertex v vertex u path count vertices pass first line contain integer n ( 2 ≤ n ≤ 2·105 ) — number vertices tree next n - 1 line contain two integers u v ( 1 ≤ u v ≤ n u ≠ v ) denote edge connect vertex u vertex v. guarantee give graph a tree next line contain a string consist n lowercase character a t i - th ( 1 ≤ i ≤ n ) character label vertex i tree print n integers a single line i - th number palindromic paths pass vertex i tree first sample case follow paths <unknown> - 3 - 42 - 3 - <unknown> - 3 - <unknown> paths contain one vertex palindromic list a paths first sample <unknown> - 2 - 31 - 2 - 3 - 41 - 2 - 3 - 5,['data structures'],2400.0
938/G,give undirected connect graph weight edge length path two vertices bitwise xor weight edge belong path ( edge traverse include bitwise xor number time ) three type query process : print answer query type 3 . first line contain two number n m ( 1 ≤ n m ≤ 200000 ) — number vertices number edge graph respectively m line follow denote edge graph line contain three integers x y d ( 1 ≤ x < y ≤ n 0 ≤ d ≤ 230 - 1 ) pair ( x y ) list initial graph connect one line follow contain integer q ( 1 ≤ q ≤ 200000 ) — number query process q line follow denote query follow form : guarantee least one query type 3 . print answer query type 3 order appear input,['data structures'],2900.0
1004/F,sonya array $$$ a_1 a_2 \ldots a_n $$$ consist $$$ n $$$ integers also one non - negative integer $$$ x $$$ perform $$$ m $$$ query two type : help sonya perform query ? bitwise a binary operation a pair non - negative integers calculate bitwise two number need write number binary notation result a number binary contain a one digit a one binary notation least one two number example $$$ 10 $$$ $$$ 19 $$$ = $$$ 1010_2 $$$ $$$ <unknown> $$$ = $$$ <unknown> $$$ = $$$ 27 $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ x $$$ ( $$$ 1\leq n m\leq 100000 $$$ $$$ 0\leq x < 2^ { 20 } $$$ ) — number number number query constant query second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0\leq a_i < 2^ { 20 } $$$ ) — number array follow $$$ m $$$ line describe query a line one follow format : query type 2 print number subarrays bitwise number range least $$$ x $$$ first example array [ $$$ 0 $$$ $$$ 3 $$$ $$$ 6 $$$ $$$ 1 $$$ ] query : second example array [ $$$ 6 $$$ $$$ 0 $$$ $$$ 3 $$$ $$$ 15 $$$ $$$ 2 $$$ ] query :,['data structures'],2600.0
1017/D,childan make a legendary story try sell <unknown> — a necklace a strong sense ` ` wu '' <unknown> mr . kasoura challenge truth childan 's story go ask a question childan 's so - called ` ` personal treasure '' necklace ` ` personal treasure '' a multiset $$$ s $$$ $$$ m $$$ ` ` 01 - strings '' a ` ` 01 - string '' a string contain $$$ n $$$ character ` ` 0 '' ` ` 1 '' example $$$ n=4 $$$ string ` ` 0110 '' ` ` 0000 '' ` ` 1110 '' ` ` 01 - strings '' ` ` <unknown> '' ( $$$ 5 $$$ character $$$ 4 $$$ ) ` ` zero '' ( <unknown> character ) note multiset $$$ s $$$ contain equal elements frequently mr . kasoura provide a ` ` 01 - string '' $$$ t $$$ ask childan many string $$$ s $$$ multiset $$$ s $$$ ` ` wu '' value pair $$$ ( s t ) $$$ greater $$$ k $$$ <unknown> . kasoura mr . kasoura think $$$ s_i = t_i $$$ ( $$$ 1\leq <unknown> n $$$ ) ` ` wu '' value character pair equal $$$ w_i $$$ otherwise $$$ 0 $$$ ` ` wu '' value ` ` 01 - string '' pair sum ` ` wu '' value every character pair note length every ` ` 01 - string '' equal $$$ n $$$ example $$$ <unknown> [ 4 5 3 6 ] $$$ ` ` wu '' ( ` ` 1001 '' ` ` 1100 '' ) $$$ 7 $$$ string equal character first third position $$$ <unknown> + <unknown> $$$ need help childan answer mr . kasoura 's query find number string multiset $$$ s $$$ ` ` wu '' value pair greater $$$ k $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1\leq n\leq 12 $$$ $$$ 1\leq q m\leq 5\cdot 100000 $$$ ) — length ` ` 01 - strings '' size multiset $$$ s $$$ number query second line contain $$$ n $$$ integers $$$ w_1 w_2 \ldots w_n $$$ ( $$$ 0 \le w_i \le 100 $$$ ) — value $$$ i $$$ -th <unknown> next $$$ m $$$ line contain ` ` 01 - string '' $$$ s $$$ length $$$ n $$$ — string multiset $$$ s $$$ next $$$ q $$$ line contain ` ` 01 - string '' $$$ t $$$ length $$$ n $$$ integer $$$ k $$$ ( $$$ 0\leq k\leq 100 $$$ ) — query query print answer query first example get : '' wu '' ( ` ` 01 '' ` ` 00 '' ) $$$ 40 $$$ ` ` wu '' ( ` ` 10 '' ` ` 00 '' ) $$$ 20 $$$ ` ` wu '' ( ` ` 11 '' ` ` 00 '' ) $$$ 0 $$$ ` ` wu '' ( ` ` 01 '' ` ` 11 '' ) $$$ 20 $$$ ` ` wu '' ( ` ` 10 '' ` ` 11 '' ) $$$ 40 $$$ ` ` wu '' ( ` ` 11 '' ` ` 11 '' ) $$$ 60 $$$ first query pair ( ` ` 11 '' ` ` 00 '' ) ( ` ` 10 '' ` ` 00 '' ) satisfy condition since ` ` wu '' greater $$$ 20 $$$ second query string satisfy condition third query pair ( ` ` 01 '' ` ` 11 '' ) ( ` ` 01 '' ` ` 11 '' ) satisfy condition note since two ` ` 01 '' string multiset answer $$$ 2 $$$ $$$ 1 $$$ fourth query since $$$ k $$$ increase pair ( ` ` 10 '' ` ` 11 '' ) satisfy condition fifth query since $$$ k $$$ increase pair ( ` ` 11 '' ` ` 11 '' ) satisfy condition,['data structures'],1900.0
877/E,danil decide earn money find a part - time job interview go well a light <unknown> danil work a root tree ( undirected connect acyclic graph ) n vertices vertex 1 root tree a room vertex light switch room danil 's duties include switch light room subtree vertex mean light switch room subtree switch otherwise switch unfortunately ( fortunately ) danil lazy know boss go <unknown> check work instead send danil task use <unknown> personal message two type task : a subtree vertex v a set vertices shortest path root pass v. particular vertex v subtree v. danil go perform duties ask write a program answer boss instead first line contain a single integer n ( 1 ≤ n ≤ 200 000 ) — number vertices tree second line contain n - 1 space - separated integers p2 p3 ... pn ( 1 ≤ pi < i ) pi ancestor vertex i. third line contain n space - separated integers t1 t2 ... tn ( 0 ≤ ti ≤ 1 ) ti 1 light turn vertex i 0 otherwise fourth line contain a single integer q ( 1 ≤ q ≤ 200 000 ) — number task next q line get v pow v ( 1 ≤ v ≤ n ) — task describe task get v print number room subtree v light turn tree task pow 1,['data structures'],2000.0
917/E,know eleven special abilities thus hopper convince close gate upside world mind upside monsters like move <unknown> go attack hopper eleven order make stop monsters live vines vines form a tree n vertices number 1 n. 's a lowercase english letter write tunnel ( edge ) upside a magical world m type monsters upside number 1 m. type monster a special word give power special word type i si q monsters upside one a junction ( vertex ) go junction monster type k go junction i junction j power gain number time see special world ( sk ) consecutively tunnel formally : f ( i j ) string get concatenate letter write tunnel shortest path i j power monster gain number occurrences sk f ( i j ) hopper eleven want get prepare monster want know power monster gain move first line input contain three integers n m q ( 2 ≤ n ≤ 105 1 ≤ m q ≤ 105 ) next n - 1 line contain tunnel ( edge ) line contain two integers v u ( 1 ≤ v u ≤ n v ≠ u ) a lowercase english letter c mean 's a tunnel connect junctions v u write c guarantee give graph a tree next m line contain special word i - th line contain a single string si ( 1 ≤ <unknown> ≤ 105 ) consist lowercase english letter guarantee |s1| + |s2| + ... + <unknown> ≤ 105 ) next q line contain monsters line contain three integers i j k ( 1 ≤ i j ≤ n i ≠ j 1 ≤ k ≤ m ) mean a monster type k go junction number i junction number j. print q line i - th line contain a single integer power i - th monster gain move,['data structures'],3400.0
472/G,a simple way create hard task : take one simple problem query try find algorithm solve faster <unknown> kind task usually appear <unknown> contest usually involve data structure let 's try create a task example take ` ` ham distance problem '' : two binary string s t length ham distance number position correspond symbols different example ham distance ` ` 00111 '' ` ` <unknown> '' 2 ( different symbols mark bold ) use ham distance problem a query follow way : give two string a b several query query : ham distance two string <unknown> + 1 ... ap1 + len - 1 <unknown> + 1 ... <unknown> + len - 1 ? note problem string zero - based s = <unknown> ... s|s| - 1 . first line contain a string a ( 1 ≤ |a| ≤ 200000 ) second line contain a string b ( 1 ≤ |b| ≤ 200000 ) character string either ` ` 0 '' ` ` 1 '' third line contain integer q ( 1 ≤ q ≤ 400000 ) — number query follow q line contain three integers : p1 p2 len ( 0 ≤ p1 ≤ |a| - len ; 0 ≤ p2 ≤ |b| - len ) number denote parameters current query output q integers — answer query,['data structures'],2800.0
620/E,new year holiday <unknown> n't want throw away new year tree invite best friends <unknown> <unknown> help <unknown> new year tree new year tree undirected tree n vertices root vertex 1 . process query two type : first line contain two integers n m ( 1 ≤ n m ≤ <unknown> ) — number vertices tree number query second line contain n integers ci ( 1 ≤ ci ≤ 60 ) — colour i - th vertex next n - 1 line contain two integers xj yj ( 1 ≤ xj yj ≤ n ) — vertices j - th edge guarantee give correct undirected tree last m line contain description query description start integer tk ( 1 ≤ tk ≤ 2 ) — type k - th query query first type follow two integers vk ck ( 1 ≤ vk ≤ n 1 ≤ ck ≤ 60 ) — number vertex whose subtree <unknown> colour ck query second type follow integer vk ( 1 ≤ vk ≤ n ) — number vertex subtree find number different colour query second type print integer a — number different colour subtree vertex give query number print a separate line order query appear input,['data structures'],2100.0
706/D,"author go stories vasiliy a formal task description give q query a multiset a initially contain integer 0 . three type query : multiset a set equal elements allow first line input contain a single integer q ( 1 ≤ q ≤ 200 000 ) — number query vasiliy perform follow q line input contain one three character ' + ' ' - ' ' ? ' integer xi ( 1 ≤ xi ≤ 109 ) 's guarantee least one query third type note integer 0 always present set a. query type ' ? ' print one integer — maximum value bitwise exclusive ( xor ) integer xi integer multiset a. first five operations multiset a contain integers 0 8 9 11 6 1 . answer sixth query integer — maximum among integers , ,",['data structures'],1800.0
1093/G,give array $$$ a $$$ $$$ n $$$ point $$$ k $$$ <unknown> space let distance two point $$$ a_x $$$ $$$ <unknown> $$$ $$$ \sum \limits _ { i = 1 } ^ { k } |a _ { x i } - a _ { y i } | $$$ ( also know manhattan distance ) process $$$ q $$$ query follow two type : first line contain two number $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le k \le 5 $$$ ) — number elements $$$ a $$$ number dimension space respectively $$$ n $$$ line follow contain $$$ k $$$ integers $$$ a _ { i 1 } $$$ $$$ a _ { i 2 } $$$ ... $$$ a _ { i k } $$$ ( $$$ -1000000 \le a _ { i j } \le 1000000 $$$ ) — coordinate $$$ i $$$ -th point next line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query $$$ q $$$ line follow denote a query two type query : least one query second type print answer query second type,['data structures'],2300.0
1386/C,"joker return gotham city execute another evil plan gotham city $$$ n $$$ street junctions ( number $$$ 1 $$$ $$$ n $$$ ) $$$ m $$$ streets ( number $$$ 1 $$$ $$$ m $$$ ) street connect two distinct junctions two junctions connect one street evil plan joker need use odd number streets together form a cycle , a junction $$$ s $$$ even positive integer $$$ k $$$ a sequence junctions $$$ s s_1 \ldots s_k s $$$ streets connect ( a ) $$$ s $$$ $$$ s_1 $$$ ( b ) $$$ s_k $$$ $$$ s $$$ ( c ) $$$ s _ { i-1 } $$$ $$$ s_i $$$ $$$ i = 2 \ldots k $$$ however police control streets gotham city day $$$ i $$$ monitor a different subset streets consecutive number $$$ j $$$ : $$$ l_i \leq j \leq r_i $$$ monitor streets a part joker 's plan course unfortunately police joker spy within gotham city police department ; tell streets monitor day joker want find give number days whether execute evil plan a day must a cycle streets consist odd number streets monitor day first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \leq n m q \leq 200\,000 $$$ ) : number junctions number streets number days investigate follow $$$ m $$$ line describe streets $$$ j $$$ -th line ( $$$ 1 \le j \le m $$$ ) contain two junction number $$$ u $$$ $$$ v $$$ ( $$$ u \neq v $$$ ) say street $$$ j $$$ connect two junctions guarantee two junctions connect one street follow $$$ q $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ say streets $$$ j $$$ $$$ l_i \leq j \leq r_i $$$ check police day $$$ i $$$ ( $$$ 1 \leq i \leq q $$$ ) output contain $$$ q $$$ line line $$$ i $$$ ( $$$ 1 \leq i \leq q $$$ ) contain ` ` yes '' joker execute plan day $$$ i $$$ ` ` '' otherwise subtasks : graph example test :",['data structures'],2800.0
1401/F,give array $$$ a $$$ length $$$ 2^n $$$ process $$$ q $$$ query query one follow $$$ 4 $$$ type : write a program quickly process give query first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 0 \le n \le 18 $$$ ; $$$ 1 \le q \le 100000 $$$ ) — length array $$$ a $$$ number query second line contain $$$ 2^n $$$ integers $$$ a_1 a_2 \ldots a _ { 2^n } $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) next $$$ q $$$ line contain query — one per line query one $$$ 4 $$$ type : guarantee least one $$$ sum $$$ query print answer $$$ sum $$$ query first sample initially array $$$ a $$$ equal $$$ \ { <unknown> } $$$ process first query array $$$ a $$$ become $$$ \ { <unknown> } $$$ process second query array $$$ a_i $$$ become $$$ \ { <unknown> } $$$ therefore answer third query $$$ 9 + 7 + <unknown> $$$ second sample initially array $$$ a $$$ equal $$$ \ { <unknown> } $$$ happen next :,['data structures'],2400.0
1439/E,"let 's consider a $$$ ( 1000000000 + 1 ) \times ( 1000000000 + 1 ) $$$ field row number integers $$$ 0 $$$ $$$ 1000000000 $$$ columns number integers $$$ 0 $$$ $$$ 1000000000 $$$ let 's define $$$ ( x y ) $$$ cell locate $$$ x $$$ -th row $$$ y $$$ -th column let 's call a cell $$$ ( x y ) $$$ good $$$ x \ & y = 0 $$$ $$$ \ & $$$ bitwise operation let 's build a graph vertices good cells field make edge pair adjacent side good cells prove graph a tree — connect graph without cycle let 's hang tree vertex $$$ ( 0 0 ) $$$ a root tree root $$$ ( 0 0 ) $$$ two players play game initially good cells black others white player turn choose a black good cell a subset ancestors ( possibly empty ) invert color ( white black vice versa ) player ca n't move ( good cells white ) lose prove game always finite initially cells white give $$$ m $$$ pair cells pair color cells a simple path black note invert color paint black sohrab mashtali go play game sohrab first player mashtali second mashtali want win decide cheat make follow operation multiple time game start : choose a cell invert color vertices path root tree <unknown> watch wonder : ` ` minimum number operations mashtali a win strategy ? ` ` find answer question initial paint tree prove least one possible way cheat always exist first line contain one integer $$$ m $$$ ( $$$ 1 \leq m \leq 100000 $$$ ) next $$$ m $$$ line contain four integers $$$ x _ { 1 } $$$ $$$ y _ { 1 } $$$ $$$ x _ { 2 } $$$ $$$ y _ { 2 } $$$ ( $$$ 0 \leq x_i y_i \leq 1000000000 $$$ $$$ x_i \ & y_i = 0 $$$ ) color cells path vertices $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ black print a single integer — minimum number cheat operations second player first test make one cheat operation root tree , second player win use a symmetric strategy second test make cheat operations cells $$$ ( 0 2 ) ( 0 0 ) ( 3 4 ) $$$ third test second player already win strategy n't need make cheat operations",['data structures'],3500.0
1476/E,"give $$$ n $$$ pattern $$$ p_1 p_2 \dots p_n $$$ $$$ m $$$ string $$$ s_1 s_2 \dots <unknown> $$$ pattern $$$ p_i $$$ consist $$$ k $$$ character either lowercase latin letter wildcard character ( denote underscore ) pattern pairwise distinct string $$$ s_j $$$ consist $$$ k $$$ lowercase latin letter a string $$$ a $$$ match a pattern $$$ b $$$ $$$ i $$$ $$$ 1 $$$ $$$ k $$$ either $$$ b_i $$$ a wildcard character $$$ b_i = a_i $$$ ask rearrange pattern a way first pattern $$$ j $$$ -th string match $$$ p [ mt_j ] $$$ allow leave order pattern unchanged perform a rearrangement ? , print valid order first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n m \le 100000 $$$ $$$ 1 \le k \le 4 $$$ ) — number pattern number string length pattern string next $$$ n $$$ line contain a pattern — $$$ k $$$ character either lowercase latin letter underscore pattern pairwise distinct next $$$ m $$$ line contain a string — $$$ k $$$ lowercase latin letter integer $$$ mt $$$ ( $$$ 1 \le mt \le n $$$ ) — index first pattern correspond string match print ` ` '' way rearrange pattern a way first pattern $$$ j $$$ -th string match $$$ p [ mt_j ] $$$ otherwise print ` ` yes '' first line second line contain $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ — order pattern multiple answer print order pattern rearrangement first example follow : thus first string match pattern ab _ _ _ bcd _ b_d order first ab _ _ indeed $$$ p [ 4 ] $$$ second string match _ _ b _ ab _ _ first _ _ b _ $$$ p [ 2 ] $$$ last string match _ bcd _ b_d first _ bcd $$$ p [ 5 ] $$$ answer test unique valid order also exist second example cba n't match _ _ c thus valid order exist third example order ( a _ _ b ) make string match pattern $$$ 1 $$$ first order ( _ b a _ ) make string match pattern $$$ 2 $$$ first thus order produce result $$$ 1 $$$ $$$ 2 $$$",['data structures'],2300.0
1479/D,"homer 's country $$$ n $$$ cities number $$$ 1 $$$ $$$ n $$$ form a tree , $$$ ( n-1 ) $$$ undirected roads $$$ n $$$ cities every two cities reach roads homer 's country industrial country $$$ n $$$ cities contain mineral resource mineral resource city $$$ i $$$ label $$$ a_i $$$ homer give plan country follow $$$ q $$$ years plan $$$ i $$$ -th year describe four parameters $$$ u_i v_i l_i $$$ $$$ r_i $$$ ask find mineral resource $$$ c_i $$$ follow two condition hold : best friend homer ask help every plan find mineral resource $$$ c_i $$$ tell n't exist one first line contain two integers $$$ n $$$ ( $$$ 1 \leq n \leq 300000 $$$ ) $$$ q $$$ ( $$$ 1 \leq q \leq 300000 $$$ ) indicate number cities number plan second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) $$$ i $$$ -th line follow $$$ ( n-1 ) $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \leq x_i y_i \leq n $$$ ) $$$ x_i \neq y_i $$$ indicate a bidirectional road city $$$ x_i $$$ city $$$ y_i $$$ guarantee give roads form a tree $$$ i $$$ -th line follow $$$ q $$$ line contain four integers $$$ u_i $$$ $$$ v_i $$$ $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \leq u_i \leq n $$$ $$$ 1 \leq v_i \leq n $$$ $$$ 1 \leq l_i \leq r_i \leq n $$$ ) indicate plan $$$ i $$$ -th year print $$$ q $$$ line $$$ i $$$ -th contain integer $$$ c_i $$$ first three query four cities city $$$ 3 $$$ city $$$ 5 $$$ city $$$ 1 $$$ city $$$ 2 $$$ city $$$ 3 $$$ city $$$ 5 $$$ mineral resources appear mineral resources $$$ 1 $$$ ( appear city $$$ 3 $$$ city $$$ 5 $$$ ) $$$ 2 $$$ ( appear city $$$ 2 $$$ ) $$$ 3 $$$ ( appear city $$$ 1 $$$ ) note",['data structures'],2900.0
1214/G,"recently <unknown> come a fascinate conclusion find a chameleon mood consider chameleon body a rectangular table $$$ n \times m $$$ cell may green blue may change two color denote $$$ ( x y ) $$$ ( $$$ 1 \leq x \leq n $$$ $$$ 1 \leq y \leq m $$$ ) cell row $$$ x $$$ column $$$ y $$$ let us define a chameleon good mood certificate four cells corner subrectangle table color opposite cells among four similar time four cell color similar formally a group four cells $$$ ( x_1 y_1 ) $$$ $$$ ( x_1 y_2 ) $$$ $$$ ( x_2 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ $$$ 1 \leq x_1 < x_2 \leq n $$$ $$$ 1 \leq y_1 < y_2 \leq m $$$ color $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ coincide color $$$ ( x_1 y_2 ) $$$ $$$ ( x_2 y_1 ) $$$ coincide four cells share color find whenever four cells present chameleon good mood vice versa : four cells chameleon bad mood ask help scientists write a program determine mood chameleon let us consider initially cells chameleon green chameleon color may change several time one change color contiguous segment table row replace opposite formally color change define three integers $$$ a $$$ $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq a \leq n $$$ $$$ 1 \leq l \leq r \leq m $$$ ) change color cells $$$ ( a b ) $$$ $$$ l \leq b \leq r $$$ replace opposite write a program report mood chameleon change additionally chameleon mood good program find four number $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ four cells $$$ ( x_1 y_1 ) $$$ $$$ ( x_1 y_2 ) $$$ $$$ ( x_2 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ good mood certificate first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \leq n m \leq 2000 $$$ $$$ 1 \leq q \leq 500\,000 $$$ ) size table number change respectively follow $$$ q $$$ line contain 3 integers $$$ a_i $$$ $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \leq a_i \leq n $$$ $$$ 1 \leq l_i \leq r_i \leq m $$$ ) describe $$$ i $$$ -th color change print $$$ q $$$ line $$$ i $$$ -th line report chameleon mood first $$$ i $$$ color change $$$ 1 \leq i \leq q $$$ chameleon bad mood print integer $$$ -1 $$$ otherwise print four integers $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \leq x_1 < x_2 \leq n $$$ $$$ 1 \leq y_1 < y_2 \leq m $$$ ) four cells $$$ ( x_1 y_1 ) $$$ $$$ ( x_1 y_2 ) $$$ $$$ ( x_2 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ good mood certificate several ways choose four integers print valid one",['data structures'],3200.0
1194/E,$$$ n $$$ segment draw a plane ; $$$ i $$$ -th segment connect two point ( $$$ x _ { i 1 } $$$ $$$ y _ { i 1 } $$$ ) ( $$$ x _ { i 2 } $$$ $$$ y _ { i 2 } $$$ ) segment non - degenerate either horizontal vertical — formally every $$$ i \in [ 1 n ] $$$ either $$$ x _ { i 1 } = x _ { i 2 } $$$ $$$ y _ { i 1 } = y _ { i 2 } $$$ ( one condition hold ) segment different type may intersect : pair horizontal segment share common point pair vertical segment share common point say four segment indices $$$ h_1 $$$ $$$ h_2 $$$ $$$ v_1 $$$ $$$ v_2 $$$ $$$ h_1 < h_2 $$$ $$$ v_1 < v_2 $$$ form a rectangle follow condition hold : please calculate number ways choose four segment form a rectangle note condition $$$ h_1 < h_2 $$$ $$$ v_1 < v_2 $$$ hold first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 5000 $$$ ) — number segment $$$ n $$$ line follow $$$ i $$$ -th line contain four integers $$$ x _ { i 1 } $$$ $$$ y _ { i 1 } $$$ $$$ x _ { i 2 } $$$ $$$ y _ { i 2 } $$$ denote endpoints $$$ i $$$ -th segment coordinate endpoints range $$$ [ -5000 5000 ] $$$ guarantee segment non - degenerate either horizontal vertical furthermore two segment share a common point one segment horizontal another one vertical print one integer — number ways choose four segment form a rectangle follow picture represent sample case :,['data structures'],2200.0
400/E,inna feed joke <unknown> logic start use binary logic instead inna array n elements a1 [ 1 ] a1 [ 2 ] ... a1 [ n ] girl like train binary logic exercise consist n stag : first stage inna write number array a1 i - th ( i ≥ 2 ) stage girl write elements array ai consist n - i + 1 integers ; k - th integer array ai define follow : ai [ k ] = ai - 1 [ k ] ai - 1 [ k + 1 ] bit - wise binary logical operation dima decide check inna 's skill ask inna change array perform exercise say sum elements write current exercise help inna answer question ! first line contain two integers n m ( 1 ≤ n m ≤ 105 ) — size array a1 number dima 's question next line contain n integers a1 [ 1 ] a1 [ 2 ] ... a1 [ n ] ( 0 ≤ ai ≤ 105 ) — initial array elements next m line contain two integers — dima 's question description question consist two integers pi vi ( 1 ≤ pi ≤ n ; 0 ≤ vi ≤ 105 ) question inna make a1 [ pi ] equal vi perform exercise please note change save question question question print inna 's answer a single line,['data structures'],2100.0
1520/F2,"interactive problem a hard version problem difference easy version hard version $$$ 1 \le t \le \min ( n 10000 ) $$$ total number query limit $$$ 60000 $$$ polycarp play a computer game game array consist zero ones hide polycarp win guess position $$$ k $$$ -th zero leave $$$ t $$$ time polycarp make $$$ 60000 $$$ request totally follow type : make game interest guess zero turn one game continue change array formally position $$$ k $$$ -th zero $$$ x $$$ polycarp guess position $$$ x $$$ -th element array replace $$$ 0 $$$ $$$ 1 $$$ help polycarp win game first program must read two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le t \le \min ( n 10000 ) $$$ ) $$$ t $$$ line follow contain one integer $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) guarantee moment request array contain least $$$ k $$$ zero order get next value $$$ k $$$ must output answer previous value $$$ k $$$ , make $$$ 60000 $$$ request total use follow format output answer ( a request n't count $$$ 60000 $$$ ) : position array number leave right $$$ 1 $$$ $$$ n $$$ inclusive print $$$ t $$$ answer program exit immediately task interactor adaptive mean within test hide array query change case incorrect query -1 display value receive program must immediately exit normally ( example call exit ( 0 ) ) otherwise test system may issue arbitrary verdict number request exceed verdict wrong answer display solution may get verdict idleness limit exceed n't print anything forget flush output buffer flush output buffer need follow immediately query output end - <unknown> - line character : <unknown> follow format hack : first line print string $$$ s $$$ ( $$$ 1 \le |s| \le 200000 $$$ ) consist zero ones integer $$$ t $$$ ( $$$ 1 \le t \le \min ( |s| 10000 ) $$$ ) — hide array number request respectively next $$$ t $$$ line output number $$$ k $$$ ( $$$ 1 \le k \le |s| $$$ ) hack solution direct access hide array first test array $$$ [ 1 0 1 1 0 1 ] $$$ hide answer query $$$ k=2 $$$ array change $$$ [ 1 0 1 1 1 1 ] $$$",['data structures'],2200.0
82/C,"berland kingdom a set n cities connect n - 1 railways road connect exactly two different cities capital locate city 1 . city a way get capital rail i - th city a soldier division number i division characterize a number ai represent priority smaller number higher priority division value ai different one day berland king <unknown> great declare a general <unknown> , division arrive capital every day every city except capital a train depart exactly n - 1 depart train day train move toward capital finish movement opposite endpoint railway next day finite capacity cj express maximum number divisions train transport one go train move direction reduce distance capital train pass exactly one railway move a city neighbor ( stop ) toward capital first place among divisions city division smallest number ai get train next smallest either train full divisions load possible a division stay a city a several days duration train 's progress one city another always equal 1 day divisions start move time end capital n't go anywhere else division move along a simple path city capital regardless much time journey take goal find division many days arrive capital berland <unknown> begin day 0 . first line contain single integer n ( 1 ≤ n ≤ 5000 ) number cities berland second line contain n space - separated integers a1 a2 ... , ai represent priority division locate city number i. number a1 a2 ... different ( 1 ≤ ai ≤ 109 ) n - 1 line contain descriptions railway roads description consist three integers vj uj cj vj uj number cities connect j - th rail cj stand maximum capacity a train rid road ( 1 ≤ vj uj ≤ n vj ≠ uj 1 ≤ cj ≤ n ) print sequence t1 t2 ... tn ti stand number days take division city i arrive capital separate number space",['data structures'],2000.0
1403/A,"upon a time land shamans everyone live sky - high <unknown> shaman a unique identify number $$$ i $$$ $$$ 0 $$$ $$$ n-1 $$$ altitude value $$$ h_i $$$ represent high live grind level distance two <unknown> absolute value difference shamans live together peace one steal formula world - famous <unknown> great power cover his / her track thief put a curse land : inhabitants could longer trust ... despite difficult <unknown> order good <unknown> gain follow information curse : believe thief whisper formula evil shaman avoid <unknown> visit home one ( respective ) trust friends visit thief whisper formula evil shaman window ( note : trust friend home time fact 's even possible visit 's house – shamans weird ) fortunately whisper travel short distance order know two trust friends visit ( thief evil shaman ) must live close ask help investigation would like test <unknown> : thief $$$ x $$$ evil shaman $$$ y $$$ formula whisper day $$$ v $$$ ? smallest distance whisper formula travel ? , minimum distance apartments shamans $$$ x ' $$$ $$$ y ' $$$ ( i.e $$$ <unknown> ( <unknown> _ { x ' } - h _ { y ' } <unknown> ) $$$ ) $$$ x ' $$$ a trust friend $$$ x $$$ $$$ y ' $$$ a trust friend $$$ y $$$ day $$$ v $$$ ? share information ask a number question need answer question immediately receive next one interaction begin a line contain $$$ n $$$ $$$ d $$$ $$$ u $$$ $$$ q $$$ $$$ ( 2 \leq n \leq 100000 $$$ $$$ 1 \leq d \leq 500 $$$ $$$ 0 \leq u \leq 200000 $$$ $$$ 1 \leq q \leq 50000 ) $$$ – number shamans maximum number trust friends a shaman give point number days number question next line $$$ n $$$ space separate integers follow $$$ i $$$ th $$$ ( 1\leq i \leq n ) $$$ $$$ h _ { i-1 } $$$ $$$ ( 0\leq h _ { i-1 } \leq 1000000000 ) $$$ altitude shaman $$$ i-1 $$$ next $$$ u $$$ line two integers $$$ i $$$ th ( $$$ 1 \leq i \leq u $$$ ) $$$ a_i $$$ $$$ b_i $$$ $$$ ( 0 \leq a_i b_i < n $$$ $$$ a_i \neq b_i ) $$$ represent a pair shamans start stop trust end day $$$ i-1 $$$ , $$$ a_i $$$ $$$ b_i $$$ trust day $$$ i-1 $$$ trust day $$$ i $$$ vice versa read integers interactor ask $$$ q $$$ question follow interaction happen $$$ q $$$ time : print line forget output end line flush output otherwise get idleness limit exceed , use : example query : <unknown> <unknown> :",['data structures'],2400.0
1264/C,"creatnx $$$ n $$$ mirror number $$$ 1 $$$ $$$ n $$$ every day creatnx ask exactly one mirror ` ` i beautiful ? ` ` $$$ i $$$ -th mirror tell creatnx beautiful probability $$$ \frac { p_i } { 100 } $$$ $$$ 1 \le i \le n $$$ mirror call checkpoints initially $$$ 1 $$$ st mirror a checkpoint remain a checkpoint time creatnx ask mirror one one start $$$ 1 $$$ -st mirror every day ask $$$ i $$$ -th mirror two possibilities : change occur time : mirror become new checkpoints mirror longer checkpoints give $$$ q $$$ query query represent integer $$$ u $$$ : $$$ u $$$ -th mirror n't a checkpoint set a checkpoint otherwise $$$ u $$$ -th mirror longer a checkpoint query need calculate expect number days creatnx become happy number find modulo $$$ 998244353 $$$ formally let $$$ m = 998244353 $$$ show answer express irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \not \equiv 0 \pmod { m } $$$ output integer equal $$$ p \cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \le x < m $$$ $$$ x \cdot q \equiv p \pmod { m } $$$ first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \leq n q \le 200000 $$$ ) — number mirror query second line contain $$$ n $$$ integers : $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \leq p_i \leq 100 $$$ ) $$$ q $$$ follow line contain a single integer $$$ u $$$ ( $$$ 2 \leq u \leq n $$$ ) — next query print $$$ q $$$ number – answer query modulo $$$ 998244353 $$$ first test first query first second mirror checkpoints creatnx ask first mirror say beautiful ask second mirror say beautiful second mirror a checkpoint , become happy probabilities mirror say beautiful equal $$$ \frac { 1 } { 2 } $$$ , expect number days one mirror say beautiful equal $$$ 2 $$$ answer equal $$$ 4 = 2 + 2 $$$",['data structures'],2400.0
1316/F,"$$$ n $$$ officer army byteland officer power associate power $$$ i $$$ -th officer denote $$$ p _ { i } $$$ war fast approach general would like know strength army strength army calculate a strange way byteland general select a random subset officer $$$ n $$$ officer call subset a battalion ( $$$ 2^n $$$ subsets $$$ n $$$ officer choose equally likely include empty subset subset officer ) strength a battalion calculate follow way : let power choose officer $$$ a _ { 1 } a _ { 2 } \ldots a _ { k } $$$ $$$ a_1 \le a_2 \le \dots \le a_k $$$ strength battalion equal $$$ a_1a_2 + <unknown> + \dots + a _ { k-1 } a_k $$$ ( size battalion $$$ \leq 1 $$$ strength battalion $$$ 0 $$$ ) strength army equal expect value strength battalion war really long power officer may change precisely $$$ q $$$ change one form $$$ i $$$ $$$ x $$$ indicate $$$ p _ { i } $$$ change $$$ x $$$ need find strength army initially $$$ q $$$ update note change permanent strength find modulo $$$ 10^ { 9 } +7 $$$ formally let $$$ <unknown> { 9 } +7 $$$ show answer express irreducible fraction $$$ p / q $$$ $$$ p $$$ $$$ q $$$ integers $$$ <unknown> 0 \bmod m $$$ ) output integer equal $$$ <unknown> q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \leq x < m $$$ $$$ x <unknown> q \equiv p \bmod m $$$ ) first line input contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 3⋅10^ { 5 } $$$ ) — number officer byteland 's army second line contain $$$ n $$$ integers $$$ p _ { 1 } p _ { 2 } \ldots p _ { n } $$$ ( $$$ 1 \leq p _ { i } \leq 10^ { 9 } $$$ ) third line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 3⋅10^ { 5 } $$$ ) — number update next $$$ q $$$ line contain two integers $$$ i $$$ $$$ x $$$ ( $$$ 1 \leq i \leq n $$$ $$$ 1 \leq x \leq 10^ { 9 } $$$ ) indicate $$$ p _ { i } $$$ update $$$ x $$$ first line output initial strength army $$$ i $$$ -th next $$$ q $$$ line output strength army $$$ i $$$ -th update first testcase initially four possible <unknown> change $$$ p _ { 1 } $$$ $$$ 2 $$$ strength <unknown> { $$$ 1,2 $$$ } change $$$ 4 $$$ strength army become $$$ 1 $$$ change $$$ p _ { 2 } $$$ $$$ 1 $$$ strength battalion { $$$ 1,2 $$$ } become $$$ 2 $$$ strength army become $$$ \frac { 1 } { 2 } $$$",['data structures'],2800.0
1746/F,array $$$ a $$$ consist $$$ n $$$ positive integers handle $$$ q $$$ query follow type : first line input contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n q \le 300000 $$$ ) length $$$ a $$$ number query next line contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ ( $$$ 1 \le a _ { i } \le 1000000000 $$$ ) — elements $$$ a $$$ next $$$ q $$$ line describe a query one follow form query second type answer query yes print ` ` yes '' otherwise print ` ` '' first query request subarray $$$ [ 1234 2 3 3 2 1 ] $$$ 's obvious number occurrence $$$ 1 $$$ n't divisible $$$ k = 2 $$$ answer ` ` '' third query request subarray $$$ [ 1 2 3 3 2 1 ] $$$ see number occurrence every integer sub array divisible $$$ k = 2 $$$ answer ` ` yes '' sixth query request subarray $$$ [ 1 2 3 3 2 1 1 2 3 ] $$$ see number occurrence every integer sub array divisible $$$ k = 3 $$$ answer ` ` yes '',['data structures'],2800.0
1633/F,give a tree consist $$$ n $$$ vertices ( number $$$ 1 $$$ $$$ n $$$ ) $$$ n-1 $$$ edge ( number $$$ 1 $$$ $$$ n-1 $$$ ) initially vertices except vertex $$$ 1 $$$ <unknown> process query three type : note solve problem online mode mean ca n't read whole input read query write answer last query use function fflush c++ bufferedwriter.flush java languages write program first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number vertices tree $$$ n-1 $$$ line follow $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ; $$$ u_i \ne v_i $$$ ) — endpoints $$$ i $$$ -th edge edge form a tree query follow format describe statement one line per query least $$$ 2 $$$ $$$ <unknown> $$$ query last query ( last one ) type $$$ 3 $$$ note read $$$ i $$$ -th query already give answer query $$$ i-1 $$$ ( except $$$ i = 1 $$$ ) answer one query incorrect judge program recognize instead next query may receive integer $$$ 0 $$$ a separate line receive program terminate <unknown> receive ` ` wrong answer '' verdict program n't terminate solution may receive verdict like ` ` time limit exceed '' ` ` idleness limit exceed '' etc note fact solution n't receive integer $$$ 0 $$$ mean answer correct check program terminate query type $$$ 1 $$$ $$$ 2 $$$ print answer a separate line describe statement n't forget flush output,['data structures'],2800.0
1575/C,"denote a cyclic sequence size $$$ n $$$ array $$$ s $$$ $$$ s_n $$$ adjacent $$$ s_1 $$$ segment $$$ s [ r l ] $$$ $$$ l < r $$$ concatenation $$$ s [ r n ] $$$ $$$ s [ 1 l ] $$$ give array $$$ a $$$ consist $$$ n $$$ integers define $$$ b $$$ cyclic sequence obtain concatenate $$$ m $$$ copy $$$ a $$$ note $$$ b $$$ size $$$ n \cdot m $$$ give integer $$$ k $$$ $$$ k = 1 $$$ $$$ k $$$ a prime number find number different segment $$$ b $$$ sum elements segment divisible $$$ k $$$ two segment consider different set indices segment different example $$$ n = 3 $$$ $$$ m = 2 $$$ set indices segment $$$ s [ 2 5 ] $$$ $$$ \ { 2 3 4 5\ } $$$ segment $$$ s [ 5 2 ] $$$ $$$ \ { 5 6 1 2\ } $$$ particular segment $$$ s [ 1 6 ] s [ <unknown> ] \ldots s [ 6 5 ] $$$ consider segment output answer modulo $$$ 1000000000 + 7 $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \leq n m k \leq 200000 $$$ $$$ k = 1 $$$ $$$ k $$$ a prime number ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 200000 $$$ ) output integer denote number different segment $$$ b $$$ sum elements segment divisible $$$ k $$$ modulo $$$ 1000000000 + 7 $$$ first example valid segment $$$ [ 1,4 ] $$$ $$$ [ 2 3 ] $$$ $$$ [ 3 5 ] $$$ $$$ [ 4 2 ] $$$ second example one valid segment $$$ [ 1 5 ] $$$",['data structures'],3000.0
916/D,i finish many assignments ? ? ? jamie get busy school life start forget assignments decide write things a to - do list assign a value priority assignment ( lower value mean important ) decide need spend time a days jamie find list large ca n't even manage list ! a good friend jamie help write a program support follow operations to - do list : day 0 to - do list empty follow q days jamie exactly one four operations operation a query output result query proceed next day poor jamie make appropriate <unknown> first line consist a single integer q ( 1 ≤ q ≤ 105 ) — number operations follow q line consist description operations i - th line consist operation jamie do i - th day query follow format : first word line indicate type operation must one follow four : set remove query <unknown> assignment name ai consist lowercase english letter a length 1 ≤ |ai| ≤ 15 . guarantee last operation a query operation query operation output a single integer — number assignments a priority lower assignment ai - 1 ai to - do list operation a query output result query flush output stream proceed next operation otherwise may get verdict idleness limit exceed flush output stream please refer documentation choose program language flush function common program languages list :,['data structures'],2200.0
1080/F,"a important day <unknown> a test a program class always give interest problem solve fast solve problem ? give $$$ n $$$ order segment set segment represent a pair two integers $$$ [ l r ] $$$ $$$ l\leq r $$$ set contain arbitrary number segment ( even $$$ 0 $$$ ) possible segment equal also give $$$ m $$$ query represent four number : $$$ a b x y $$$ segment find whether true set $$$ p $$$ ( $$$ a\leq p\leq b $$$ ) contain least one segment $$$ [ l r ] $$$ lie entirely segment $$$ [ x y ] $$$ $$$ x\leq l\leq r\leq y $$$ find answer query note need solve problem online , get a new query print answer previous query first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ $$$ ( 1\leq n m\leq 100000 1\leq k\leq 3\cdot100000 ) $$$ — number set query segment respectively next $$$ k $$$ line contain three integers $$$ l $$$ $$$ r $$$ $$$ p $$$ $$$ ( 1\leq l\leq r\leq 1000000000 1\leq p\leq n ) $$$ — limit segment index a set segment belong next $$$ m $$$ line contain four integers $$$ a b x y $$$ $$$ ( 1\leq a\leq <unknown> n 1\leq x\leq <unknown> 1000000000 ) $$$ — description query query print ` ` yes '' ` ` '' a new line print a query forget output end line flush output otherwise get idleness limit exceed , use : first query answer negative since second set contain a segment lie segment $$$ [ 2 3 ] $$$ second query first set contain $$$ [ 2 3 ] $$$ second set contain $$$ [ 2 4 ] $$$ third query first set contain $$$ [ 2 3 ] $$$ second set contain $$$ [ 2 4 ] $$$ third set contain $$$ [ 2 5 ] $$$ fourth query second set contain a segment lie segment $$$ [ 3 6 ] $$$ fifth query second set contain $$$ [ 2 4 ] $$$ third set contain $$$ [ 2 5 ] $$$ fourth contain $$$ [ 7 9 ] $$$",['data structures'],2400.0
144/D,"a country call berland consist n cities number integer number 1 n. connect bidirectional roads road length a path city one roads accord super duper document berland protect super duper <unknown> exact position super duper secret missile silos keep secret bob manage get hold information information say silos locate exactly a distance l capital capital locate city number s. document give formal definition : super duper secret missile silo locate place ( either city a point a road ) shortest distance place capital along roads country equal exactly l. bob want know many missile silos locate berland sell information enemy spy help bob first line contain three integers n m s ( 2 ≤ n ≤ 105 , 1 ≤ s ≤ n ) — number cities number roads country number capital correspondingly capital city s. m line contain descriptions roads describe three integers vi ui wi ( 1 ≤ vi ui ≤ n vi ≠ ui 1 ≤ wi ≤ 1000 ) vi ui number cities connect road wi length last input line contain integer l ( 0 ≤ l ≤ 109 ) — distance capital missile silos guarantee : print single number — number super duper secret missile silos locate berland first sample silos locate cities 3 4 road ( 1 3 ) a distance 2 city 1 ( correspondingly a distance 1 city 3 ) second sample one missile silo locate right middle road ( 1 2 ) two silos road ( 4 5 ) a distance 3 city 4 direction city 5 a distance 3 city 5 city 4",['data structures'],1900.0
176/E,"time help a team researchers island <unknown> <unknown> research culture ancient tribes use inhabit island many years ago overall ' ve <unknown> n villages pair villages connect roads people could go roads directions overall exactly n - 1 roads village one could get one tribes peaceful many war a result war villages destroy completely peaceful years villages restore moment time people use roads belong shortest way two villages exist give moment word people use minimum subset roads a way possible get exist village exist one note throughout island 's whole history exist exactly n - 1 roads find researchers never roads researchers think observe total sum use roads ’ lengths different moments time help better understand tribes ' culture answer several historical question give full history tribes ' existence task determine total length use roads moments time first line contain integer n ( 1 ≤ n ≤ 105 ) — number villages next n - 1 line describe roads i - th line contain three integers ai bi ci ( 1 ≤ ai bi ≤ n ai ≠ bi 1 ≤ ci ≤ 109 1 ≤ i < n ) — number villages connect i - th road road 's length number line separate a space next line contain integer q ( 1 ≤ q ≤ 105 ) — number query follow q query one per line order time query belong one three type : guarantee query contradict , wo n't query destroy non - existing villages restore already exist ones guarantee least one query type ` ` ? ` ` also guarantee one get village one give roads initial moment time village consider exist query type ` ` ? '' print total length use roads a single line print answer query order give input please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier",['data structures'],3100.0
372/D,a tree consist n vertices vertices number 1 n. let 's define length interval [ l r ] value r - l + 1 . score a subtree tree maximum length interval [ l r ] vertices number l l + 1 ... r belong subtree consider subtrees tree whose size k return maximum score subtree note problem tree root a subtree — arbitrary connect subgraph tree two integers first line n k ( 1 ≤ k ≤ n ≤ 105 ) next n - 1 line contain integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) mean ai bi connect a tree edge guarantee input represent a tree output contain a single integer — maximum possible score first case subtree whose size 6 include 3 consecutive number vertices example subtree consist { 1 3 4 5 7 8 } { 1 4 6 7 8 10 } include 3 consecutive number vertices subtree whose size 6 include 4 consecutive number vertices,['data structures'],2600.0
375/D,a root tree consist n vertices vertex tree color assume tree vertices number integers 1 n. represent color vertex v cv tree root a vertex number 1 . problem need answer m query query describe two integers vj kj answer query vj kj number color vertices x subtree vertex vj contain least kj vertices color x. find definition a root tree follow link : http : //en.wikipedia.org / wiki / tree _ ( graph_theory ) first line contain two integers n m ( 2 ≤ n ≤ 105 ; 1 ≤ m ≤ 105 ) next line contain a sequence integers c1 c2 ... cn ( 1 ≤ ci ≤ 105 ) next n - 1 line contain edge tree i - th line contain number ai bi ( 1 ≤ ai bi ≤ n ; ai ≠ bi ) — vertices connect edge tree next m line contain query j - th line contain two integers vj kj ( 1 ≤ vj ≤ n ; 1 ≤ kj ≤ 105 ) print m integers — answer query order query appear input a subtree vertex v a root tree root r a set vertices { u : dist ( r v ) + dist ( v u ) = dist ( r u ) } dist ( x y ) length ( edge ) shortest path vertices x y,['data structures'],2400.0
487/E,n cities cyberland number 1 n connect m bidirectional roads j - th road connect city aj bj tourists <unknown> sell every city cyberland particular city i sell a price wi q query handle two type query : formally define rout follow : first line input contain three integers n m q ( 1 ≤ n m q ≤ 105 ) separate a single space next n line contain integers wi ( 1 ≤ wi ≤ 109 ) next m line contain pair space - separated integers aj bj ( 1 ≤ aj bj ≤ n aj ≠ bj ) guarantee one road connect pair cities always least one valid route two cities next q line describe a query format ` ` c a w '' ` ` a a b '' ( 1 ≤ a b ≤ n 1 ≤ w ≤ 109 ) query type ` ` a '' output correspond answer second sample optimal rout : 2 3 [ 2 3 ] 6 4 [ 6 5 1 2 4 ] 6 7 [ 6 5 7 ] 3 3 [ 3 ],['data structures'],3200.0
383/C,iahub like tree much recently discover interest tree name propagate tree tree consist n nod number 1 n node i initial value ai root tree node 1 . tree a special property : a value val add a value node i value -val add value children node i. note add value -val a child node i also add - ( -val ) children child node i look example explanation understand better work tree support two type query : order help iahub understand tree better must answer m query precede type first line contain two integers n m ( 1 ≤ n m ≤ 200000 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 1000 ) next <unknown> line contain two integers vi ui ( 1 ≤ vi ui ≤ n ) mean edge nod vi ui next m line contain a query format describe guarantee follow constraints hold query : 1 ≤ x ≤ n 1 ≤ val ≤ 1000 . query type two ( print value node x ) must print answer query a separate line query must answer order give input value nod [ 1 2 1 1 2 ] begin value 3 add node 2 . propagate value -3 add 's sons node 4 node 5 . propagate value nod [ 1 5 1 - 2 - 1 ] value 2 add node 1 . propagate value -2 add 's sons node 2 node 3 . node 2 propagate add value 2 's sons node 4 node 5 . node 3 sons propagate value nod [ 3 3 - 1 0 1 ] see definitions tree follow link : http : //en.wikipedia.org / wiki / tree _ ( graph_theory ),['data structures'],2000.0
366/D,"dima inna love spend time together problem seryozha n't <unknown> leave room reason dima inna love much decide get criminal ... dima construct a trap graph <unknown> : ` ` <unknown> seryozha a look cool graph ! '' get <unknown> interest <unknown> first node a trap graph undirected graph consist n nod m edge edge number k dima denote a range integers lk rk ( lk ≤ rk ) order get trap graph seryozha initially ( start movements ) pick integer ( let 's call x ) seryozha must go way start node number 1 final node number n. seryozha go along edge k lk ≤ x ≤ rk seryozha a mathematician define loyalty path 1 - st node n - th one number integers x initially choose one pass whole path help seryozha find path maximum loyalty return room quickly possible ! first line input contain two integers n m ( 2 ≤ n ≤ 103 0 ≤ m ≤ <unknown> ) follow m line describe edge line contain four integers ak bk lk rk ( 1 ≤ ak bk ≤ n 1 ≤ lk ≤ rk ≤ 106 ) number mean trap graph k - th edge connect nod ak bk edge correspond range integers lk rk note give graph loop multiple edge a single line output print integer — maximum loyalty among paths first node n - th one paths exist maximum loyalty equal 0 print a single line ` ` nice work dima ! '' without quote explanation first example overall 2 ways get node 1 node 4 : first must go along edge 1 - 2 range [ 1 - 10 ] along one two edge 2 - 4 . one contain range [ 3 - 5 ] , pass number 3 4 5 . loyalty path 3 . go along edge 2 - 4 range [ 2 - 7 ] pass number 2 3 4 5 6 7 . loyalty 6 . answer edge 1 - 2 influence answer range include range follow edge",['data structures'],2000.0
191/C,say berland exactly two problems fool roads besides berland n cities <unknown> fool connect roads berland roads bidirectional many fool berland pair cities a path ( else fool would get upset ) also pair cities one simple path ( else fool would get lose ) end berland 's special feature country fool sometimes visit thus spoil roads fool n't smart always use simple paths a simple path path go every berland city berland government know paths fool use help government count road many distinct fool go note fool ' paths give input first line contain a single integer n ( 2 ≤ n ≤ 105 ) — number cities next n - 1 line contain two space - separated integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) mean a road connect cities ui vi next line contain integer k ( 0 ≤ k ≤ 105 ) — number pair fool visit next k line contain two space - separated number i - th line ( i > 0 ) contain number ai bi ( 1 ≤ ai bi ≤ n ) mean fool number 2i - 1 live city ai visit fool number 2i live city bi give pair describe simple paths every pair cities one simple path print n - 1 integer integers separate space i - th number equal number fool go i - th road roads number start one order occur input first sample fool number one go first third road fool number 3 go second first fourth ones second sample fool number 1 3 5 go first road fool number 5 go second road third road go fool number 3 fourth one go fool number 1,['data structures'],1900.0
208/E,polycarpus get hold a family relationship tree tree describe family relationships n people number 1 n. person tree one parent let 's call person a a 1 - ancestor person b a parent b. let 's call person a a k - ancestor ( k > 1 ) person b person b a 1 - ancestor a a ( k - 1 ) <unknown> b 's 1 - ancestor family relationships n't form cycle find tree word person ancestor directly indirectly ( x - ancestor x x > 0 ) let 's call two people x y ( x ≠ y ) p - th cousins ( p > 0 ) person z a p - ancestor x a p - ancestor y. polycarpus wonder many <unknown> kinds everybody take a piece paper write m pair integers vi pi help calculate number pi - th cousins person vi pair vi pi first input line contain a single integer n ( 1 ≤ n ≤ 105 ) — number people tree next line contain n space - separated integers r1 r2 ... <unknown> ri ( 1 ≤ ri ≤ n ) number person i 's parent 0 person i parent guarantee family relationships n't form cycle third line contain a single number m ( 1 ≤ m ≤ 105 ) — number family relationship query <unknown> next m line contain pair space - separated integers i - th line contain number vi pi ( 1 ≤ vi pi ≤ n ) print m space - separated integers — answer polycarpus ' query print answer query order query occur input,['data structures'],2100.0
258/E,little elephant love tree much especially love root tree 's get a tree consist n nod ( nod number 1 n ) root node number 1 . node tree contain list number initially empty little elephant want apply m operations i - th operation ( 1 ≤ i ≤ m ) first add number i list nod a subtree root node number ai add number i list nod subtree root node bi apply operations little elephant want count node i number ci — number integers j ( 1 ≤ j ≤ n ; j ≠ i ) list i - th j - th nod contain least one common number help little elephant count number ci first line contain two integers n m ( 1 ≤ n m ≤ 105 ) — number tree nod number operations follow n - 1 line contain two space - separated integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) mean edge nod number ui vi follow m line contain two space - separated integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) stand index nod i - th operation guarantee give graph undirected tree a single line print n space - separated integers — c1 c2 ... cn,['data structures'],2400.0
343/D,mad scientist mike construct a root tree consist n vertices vertex a reservoir either empty fill water vertices tree number 1 n root vertex 1 . vertex <unknown> children locate reservoir vertex vertex connect children a pipe water flow downwards mike want follow operations tree : mike already compile a full list operations want perform order experiment tree mike decide run list a <unknown> help mike determine result get perform operations first line input contain integer n ( 1 ≤ n ≤ 500000 ) — number vertices tree follow n - 1 line contain two space - separated number ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) — edge tree next line contain a number q ( 1 ≤ q ≤ 500000 ) — number operations perform follow q line contain two space - separated number ci ( 1 ≤ ci ≤ 3 ) vi ( 1 ≤ vi ≤ n ) ci operation type ( accord number give statement ) vi vertex operation perform guarantee give graph a tree type 3 operation print 1 a separate line vertex full 0 vertex empty print answer query order query give input,['data structures'],2100.0
660/F,"limak old brown bear often go <unknown> friends today feel really good try beat record ! roll a ball one get a score — integer ( maybe negative ) number point score i - th roll multiply i score sum , k roll score s1 s2 ... sk total score total score 0 roll limak make n roll get score ai i - th want maximize total score come interest idea say first roll a warm - up n't focus last roll formally cancel prefix suffix sequence a1 a2 ... , allow cancel roll cancel none total score calculate non - canceled roll , first non - canceled roll score multiply 1 second one score multiply 2 , till last non - canceled roll maximum total score limak get ? first line contain a single integer n ( 1 ≤ n ≤ 2·105 ) — total number roll make limak second line contain n integers a1 a2 ... ( |ai| ≤ 107 ) — score limak 's roll print maximum possible total score cancel roll first sample test limak cancel first two roll one last roll leave roll 1 - 3 7 give total score 1·1 + 2 · ( - 3 ) + <unknown> = 1 - 6 + 21 = 16",['data structures'],2500.0
665/E,"one day zs coder write array integers a elements a1 a2 ... , a subarray array a a sequence al al + 1 ... ar integers ( l r ) 1 ≤ l ≤ r ≤ n. zs coder think a subarray a beautiful bitwise xor elements subarray least k. help zs coder find number beautiful subarrays a ! first line contain two integers n k ( 1 ≤ n ≤ 106 1 ≤ k ≤ 109 ) — number elements array a value parameter k. second line contain n integers ai ( 0 ≤ ai ≤ 109 ) — elements array a. print integer c — number beautiful subarrays array a",['data structures'],2100.0
678/F,lena a programmer get a task solve work empty set pair integers n query process query one three type : help lena process query first line input contain integer n ( 1 ≤ n ≤ 3·105 ) — number query next n line start integer t ( 1 ≤ t ≤ 3 ) — type query a pair integers a b ( - 109 ≤ a b ≤ 109 ) follow query first type integer i ( 1 ≤ i ≤ n ) follow query second type guarantee i less number query query number i first type pair i - th query already remove integer q ( - 109 ≤ q ≤ 109 ) follow query third type query third type print a separate line desire maximal value <unknown> + y. pair set print ` ` empty set '',['data structures'],2500.0
757/G,<unknown> ! a great job help team rocket manage capture pokemons send bash meowth part team rocket already master human language want become a master program well agree free pokemons bash answer question initially meowth give bash a weight tree contain n nod a sequence a1 a2 ... a permutation 1 2 ... n. <unknown> make q query one follow form : help bash answer question ! first line contain two integers n q ( 1 ≤ n ≤ 2·105 1 ≤ q ≤ 2·105 ) — number nod tree number query respectively next line contain n space - separated integers — sequence a1 a2 ... a permutation 1 2 ... n. next n - 1 line contain three space - separated integers u v w denote exist undirected edge node u node v weight w ( 1 ≤ u v ≤ n u ≠ v 1 ≤ w ≤ 106 ) guarantee give graph a tree query consist two line first line contain single integer t indicate type query next line contain description query : ansi answer i - th query assume <unknown> = 0 . i - th query type 2 ansi = ansi - 1 . guarantee : operation mean bitwise exclusive query type 1 output a single integer a separate line denote answer query sample actual query follow :,['data structures'],3400.0
763/E,birthday party timofey go favorite tree alley a park want fee favorite bird — crow 's widely know tree occupy a single crow family tree alley form a row number 1 n. families friends reason two families friends live far precisely k - 1 tree pair friend families formally family u - th tree family v - th tree friends |u - v| ≤ k hold one friendship feature family learn timofey feed crow somewhere <unknown> friend families thus timofey start fee crow tree families friends family live tree well friends fly feed place course family live tree also come feed place today timofey come alley notice families live tree number strictly less l strictly greater r fly away thus possible pass information feed moreover need fee help timofey learn minimum number tree fee crow families remain get information feed give several situations describe integers l r need calculate answer first line contain integers n k ( 1 ≤ n ≤ 105 1 ≤ k ≤ 5 ) n number tree k maximum possible distance friend families next line contain single integer m ( 0 ≤ m ≤ n·k ) — number pair friend families next m line contain two integers u v ( 1 ≤ u v ≤ 105 ) mean families tree u v friends guarantee u ≠ v |u - v| ≤ k. give pair distinct next line contain single integer q ( 1 ≤ q ≤ 105 ) — number situations need calculate answer next q line contain two integers l r ( 1 ≤ l ≤ r ≤ 105 ) mean situation families fly away live tree x either x < l x > r. print q line line i contain single integer — answer i - th situation first example follow family pair friends : ( 1 3 ) ( 2 3 ) ( 4 5 ),['data structures'],2900.0
786/C,rick morty want find mr . <unknown> ca n't alone need mr . meeseeks generate n mr . meeseeks stand a line number 1 n. color i - th mr . meeseeks ' color ai rick morty gather army want divide mr . meeseeks squads n't want squads colorful squad mr . meeseeks k different color also squad a continuous subarray mr . meeseeks line mean 1 ≤ i ≤ e ≤ j ≤ n mr . meeseeks number i mr . meeseeks number j squad mr . meeseeks number e squad also squad need presidio build a presidio need money want total number squads minimize rick morty n't finalize exact value k order choose k 1 n ( inclusive ) need know minimum number presidios need first line input contain a single integer n ( 1 ≤ n ≤ 105 ) — number mr . meeseeks second line contain n integers a1 a2 ... separate space ( 1 ≤ ai ≤ n ) — color mr . meeseeks order stand a line first line input print n integers separate space i - th integer minimum number presidios need value k i. first sample testcase optimal ways divide army squads k : second testcase optimal ways divide army squads k :,['data structures'],2400.0
793/G,oleg bank client solve interest chess problem : place n × n chessboard maximum number rook n't beat course two rook share cell remind a rook stand cell ( a b ) beat a rook stand cell ( x y ) a = x b = y. unfortunately ( fortunately ? ) oleg answer problem always n task bore oleg soon decide make difficult remove cells board a cell delete oleg ca n't put a rook rook beat ` ` '' delete cells oleg delete cells group namely repeatedly choose a rectangle side parallel board side delete cells inside rectangle formally choose a rectangle lower leave cell coordinate ( x1 y1 ) upper right cell coordinate ( x2 y2 ) delete cells coordinate ( x y ) x1 ≤ x ≤ x2 y1 ≤ y ≤ y2 guarantee cell delete twice i.e choose rectangles intersect version problem oleg ca n't solve friend igor busy a conference ca n't help oleg last hope oleg ! help : give size board delete rectangles find maximum possible number rook could place board two rook beat first line contain single integer n ( 1 ≤ n ≤ 10000 ) — size board second line contain single integer q ( 0 ≤ q ≤ 10000 ) — number delete rectangles next q line contain information delete rectangles line contain four integers x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ n ) — coordinate lower leave upper right cells a delete rectangle guarantee rectangles intersect line print maximum number rook oleg place board two rook beat board example rook <unknown> first example :,['data structures'],3400.0
817/D,give array a consist n elements imbalance value subsegment array difference maximum minimum element segment imbalance value array sum imbalance value subsegments array example imbalance value array [ 1 4 1 ] 9 6 different subsegments array : determine imbalance value array a. first line contain one integer n ( 1 ≤ n ≤ 106 ) — size array a. second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 106 ) — elements array print one integer — imbalance value a,['data structures'],1900.0
848/C,i wo n't feel <unknown> i <unknown> ... everything <unknown> a string n bead leave message leave bead number 1 n leave right a shape number integers 1 n inclusive bead may shape memory a shape x a certain subsegment bead define difference last position first position shape x appear segment memory a subsegment sum memories shape occur time time shape bead change well memories sometimes past <unknown> subsegments recall find memory first line input contain two space - separated integers n m ( 1 ≤ n m ≤ 100 000 ) — number bead string total number change query respectively second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ n ) — initial shape bead 1 2 ... n respectively follow m line describe either a change bead a query subsegment a line one follow format : query print one line integer — memory recall subsegment initial string bead shape ( 1 2 3 1 3 2 1 ) consider change query order :,['data structures'],2600.0
549/F,"yura a team k developers a list n task number 1 n. yura go choose task do week due strange looksery habit number choose task a segment consecutive integers contain less 2 number i. e. a sequence form l l + 1 ... r 1 ≤ l < r ≤ n. every task i integer number ai associate denote many man - hours require complete i - th task developers self - <unknown> actually afraid difficult task know yura decide pick a hardest task ( one take biggest number man - hours complete among several hardest task difficulty level choose arbitrary one ) complete , task number [ l r ] choose developers leave r - l task do every developer spend integer amount hours task do whole assignment exactly ai man - hours spend i - th task last least problem developers one get angry work another developer a set task [ l r ] consider good possible find a distribution work allow complete task every developer work amount time ( amount work perform yura n't matter workers well ) example let 's suppose yura choose task follow difficulties : a = [ 1 2 3 4 ] three developers disposal take hardest fourth task finish developers leave task difficulties [ 1 2 3 ] first one spend hour first task hour third one second developer spend two hours second task third developer spend two hours third task do since every developer work exactly two hours every task work require amount time another example first task require two hours instead one complete would impossible assign task a way describe besides work yura fond problem solve wonder many pair ( l r ) ( 1 ≤ l < r ≤ n ) exist a segment [ l r ] good ? yura already solve problem time write code please help yura implement solution problem first line input contain two positive integers : n k ( 1 ≤ n ≤ 300 000 1 ≤ k ≤ 1 000 000 ) number task list number developers yura 's disposal second line contain n integers ai ( 1 ≤ ai ≤ 109 ) output a single integer — number pair ( l r ) satisfy condition statement first sample three good segment :",['data structures'],2800.0
1000/F,give array $$$ a $$$ consist $$$ n $$$ integers $$$ q $$$ query $$$ i $$$ -th query denote two integers $$$ l_i $$$ $$$ r_i $$$ query find integer occur exactly subarray $$$ a $$$ index $$$ l_i $$$ index $$$ r_i $$$ ( a subarray a contiguous subsegment array ) example $$$ a = [ 1 1 2 3 2 4 ] $$$ query $$$ ( l_i = 2 r_i = 6 ) $$$ subarray interest $$$ [ 1 2 3 2 4 ] $$$ possible answer $$$ 1 $$$ $$$ 3 $$$ $$$ 4 $$$ ; query $$$ ( l_i = 1 r_i = 2 ) $$$ subarray interest $$$ [ 1 1 ] $$$ element occur exactly answer query ? first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 500000 $$$ ) third line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 500000 $$$ ) $$$ q $$$ line follow $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ represent $$$ i $$$ -th query ( $$$ 1 \le l_i \le r_i \le n $$$ ) answer query follow : integer occur subarray index $$$ l_i $$$ index $$$ r_i $$$ exactly print $$$ 0 $$$ otherwise print integer,['data structures'],2400.0
1042/D,"petya array $$$ a $$$ consist $$$ n $$$ integers learn <unknown> sum recently calculate sum elements segment array really fast segment a non - empty sequence elements stand one next another array wonder number segment array sum less $$$ t $$$ help petya calculate number formally require calculate number pair $$$ l r $$$ ( $$$ l \le r $$$ ) $$$ a_l + a _ { l+1 } + \dots + a _ { r-1 } + a_r < t $$$ first line contain two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 200\,000 |t| \le 2\cdot10^ { 14 } $$$ ) second line contain a sequence integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ |a _ { i } | \le 10^ { 9 } $$$ ) — description petya 's array note might negative zero positive elements print number segment petya 's array sum elements less $$$ t $$$ first example follow segment sum less $$$ 4 $$$ :",['data structures'],1800.0
1139/F,$$$ m $$$ people live a city $$$ n $$$ dish sell city dish $$$ i $$$ a price $$$ p_i $$$ a standard $$$ s_i $$$ a beauty $$$ b_i $$$ person $$$ j $$$ income $$$ inc_j $$$ a prefer beauty $$$ pref_j $$$ a person would never buy a dish whose standard less person 's income also a person ca n't afford a dish a price greater income person word a person $$$ j $$$ buy a dish $$$ i $$$ $$$ p_i \leq inc_j \leq s_i $$$ also a person $$$ j $$$ buy a dish $$$ i $$$ $$$ <unknown> - <unknown> \leq ( inc_j - p_i ) $$$ word price dish less person 's income $$$ k $$$ person allow absolute difference $$$ k $$$ beauty dish his / her prefer beauty print number dish buy person city first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ 1 \leq m \leq 100000 $$$ ) number dish available city number people live city second line contain $$$ n $$$ integers $$$ p_i $$$ ( $$$ 1 \leq p_i \leq 1000000000 $$$ ) price dish third line contain $$$ n $$$ integers $$$ s_i $$$ ( $$$ 1 \leq s_i \leq 1000000000 $$$ ) standard dish fourth line contain $$$ n $$$ integers $$$ b_i $$$ ( $$$ 1 \leq b_i \leq 1000000000 $$$ ) beauty dish fifth line contain $$$ m $$$ integers $$$ inc_j $$$ ( $$$ 1 \leq inc_j \leq 1000000000 $$$ ) income every person sixth line contain $$$ m $$$ integers $$$ pref_j $$$ ( $$$ 1 \leq pref_j \leq 1000000000 $$$ ) prefer beauty every person guarantee integers $$$ i $$$ $$$ 1 $$$ $$$ n $$$ follow condition hold : $$$ p_i \leq s_i $$$ print $$$ m $$$ integers number dish buy every person live city first example first person buy dish $$$ 2 $$$ second person buy dish $$$ 1 $$$ $$$ 2 $$$ third person buy dish second example first person buy dish second person buy dish $$$ 1 $$$ $$$ 4 $$$ third person buy dish $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$,['data structures'],2500.0
1140/F,"a give set two - dimensional point $$$ s $$$ let 's denote <unknown> $$$ e ( s ) $$$ result follow algorithm : create another set two - dimensional point $$$ r $$$ initially equal $$$ s $$$ , exist four number $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ $$$ ( x_1 y_1 ) \in r $$$ $$$ ( x_1 y_2 ) \in r $$$ $$$ ( x_2 y_1 ) \in r $$$ $$$ ( x_2 y_2 ) <unknown> r $$$ add $$$ ( x_2 y_2 ) $$$ $$$ r $$$ impossible find four integers let $$$ r $$$ result algorithm problem give a set two - dimensional point $$$ s $$$ initially empty process two type query : add point $$$ s $$$ remove point query compute size $$$ e ( s ) $$$ first line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 300000 $$$ ) — number query $$$ q $$$ line follow contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le 300000 $$$ ) denote $$$ i $$$ -th query follow : $$$ ( x_i y_i ) \in s $$$ erase $$$ s $$$ otherwise insert $$$ ( x_i y_i ) $$$ $$$ s $$$ print $$$ q $$$ integers $$$ i $$$ -th integer equal size $$$ e ( s ) $$$ process first $$$ i $$$ query",['data structures'],2600.0
536/E,tavas live tavaspolis tavaspolis n cities number 1 n connect n - 1 bidirectional roads exist a path two cities also road a length tavas ' favorite string binary string ( contain 0 1 ) binary string like s = s1s2 ... sk t ( s ) goodness t ( s ) calculate follow : consider exactly m block 1s string ( a block 1s s a maximal consecutive substring s contain 1 ) lengths x1 x2 ... xm define f a give sequence ( m = 0 t ( s ) = 0 ) tavas love query ask answer q query query give number v u l print follow number : consider roads path city v city u : <unknown> e2 ... <unknown> build binary string b length x : bi = 1 l ≤ w ( ei ) w ( e ) length road e. print t ( b ) query first line input contain integers n q ( 2 ≤ n ≤ 105 1 ≤ q ≤ 105 ) next line contain n - 1 space separate integers f1 f2 ... fn - 1 ( <unknown> ≤ 1000 ) next n - 1 line contain detail roads line contain integers v u w mean 's a road cities v u length w ( 1 ≤ v u ≤ n 1 ≤ w ≤ 109 ) next q line contain detail query line contain integers v u l ( 1 ≤ v u ≤ n v ≠ u 1 ≤ l ≤ 109 ) print answer query a single line,['data structures'],3100.0
1140/G,"give a special undirected graph consist $$$ 2n $$$ vertices number $$$ 1 $$$ $$$ 2n $$$ follow properties hold graph : graph represent two tree structure $$$ n $$$ edge connect vertex first tree correspond vertex second tree edge graph weight length simple path graph sum weight traverse edge give $$$ q $$$ query graph ; query ask compute length shortest path pair vertices graph answer query ? first line input contain one integer $$$ n $$$ ( $$$ 2 \le n \le 300000 $$$ ) second line contain $$$ n $$$ integers $$$ w _ { 1 2 } $$$ $$$ w _ { 3,4 } $$$ ... $$$ w _ { 2n - 1 2n } $$$ ( $$$ 1 \le w _ { i i + 1 } \le 10^ { 12 } $$$ ) integers describe weight edge connect odd vertices even ones $$$ n-1 $$$ line follow $$$ i $$$ -th line contain four integers $$$ x_i $$$ $$$ y_i $$$ $$$ w _ { i 1 } $$$ $$$ w _ { i 2 } $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ $$$ 1 \le w _ { i j } \le 10^ { 12 } $$$ ) ; describe two edge : one connect $$$ 2x_i - 1 $$$ $$$ 2y_i - 1 $$$ weight $$$ w _ { i 1 } $$$ ; another connect $$$ 2x_i $$$ $$$ 2y_i $$$ weight $$$ w _ { i 2 } $$$ next line contain one integer $$$ q $$$ ( $$$ 1 \le q \le <unknown> $$$ ) — number query $$$ q $$$ line follow $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le 2n $$$ $$$ u_i \ne v_i $$$ ) describe a query ` ` compute length shortest path vertices $$$ u_i $$$ $$$ v_i $$$ ` ` print $$$ q $$$ integers $$$ i $$$ -th integer equal answer $$$ i $$$ -th query graph first test look like :",['data structures'],2700.0
526/F,problem meet simplify model game pudding monsters important process develop game create level a game field pudding monsters n × n rectangular grid n cells contain monsters cells contain game object gameplay move monsters around field two monsters touch glue together a single big one ( pudding remember ? ) statistics show interest map appear initially row column contain exactly one monster rest map <unknown> set correct position game object a technique 's widely use make development process efficient <unknown> available resources example a large n × n map choose a smaller k × k square part contain exactly k monsters suggest a simplify version original map wonder many ways choose initial map a k × k ( 1 ≤ k ≤ n ) square fragment contain exactly k pudding monsters calculate number first line contain a single integer n ( 1 ≤ n ≤ 3 × 105 ) — size initial field next n line contain coordinate cells initially contain monsters i - th next line contain two number ri ci ( 1 ≤ ri ci ≤ n ) — row number column number cell initially contain i - th monster guarantee ri distinct number ci distinct number print number distinct square fragment original field form a new map,['data structures'],3000.0
459/D,"parmida a clever girl want participate olympiads year course want partner clever ( although 's ) ! parmida prepare follow test problem pashmak a sequence a consist n integers a1 a2 ... , let 's denote f ( l r x ) number indices k : l ≤ k ≤ r ak = x. task calculate number pair <unknown> i j ( 1 ≤ i < j ≤ n ) f ( 1 i ai ) > f ( j n aj ) help pashmak test first line input contain integer n ( 1 ≤ n ≤ 106 ) second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) print a single integer — answer problem",['data structures'],1800.0
1019/E,"year 3018 summer informatics school <unknown> grow hotel « <unknown> » choose a location school camp consist $$$ n $$$ house $$$ n-1 $$$ pathways possible reach every house use pathways everything perfect rain start weather <unknown> promise rain continue $$$ m $$$ days a special squad teachers able measure $$$ i $$$ -th pathway connect house $$$ u_i $$$ $$$ v_i $$$ rain could pass $$$ b_i $$$ second unfortunately rain <unknown> roads every day time pass road increase $$$ a_i $$$ second word $$$ t $$$ -th ( zero ) day start rain take $$$ a_i \cdot t + b_i $$$ second pass road unfortunately despite <unknown> teachers even year 3018 students house midnight midnight students go bed important find maximal time pair house day every student would know time run house find maximal time paths every pair house $$$ t=0 $$$ $$$ t=1 $$$ ... $$$ t = m-1 $$$ days first line give two integers $$$ n $$$ $$$ m $$$ — number house camp number rain days ( $$$ 1 \le n \le 100\,000 $$$ ; $$$ 1 \le m \le <unknown> $$$ ) next $$$ n-1 $$$ line give integers $$$ u_i $$$ $$$ v_i $$$ $$$ a_i $$$ $$$ b_i $$$ — description pathways ( $$$ 1 \le u_i v_i \le n $$$ ; $$$ 0 \le a_i \le 100000 $$$ ; $$$ 0 \le b_i \le 1000000000 $$$ ) $$$ i $$$ -th pathway connect house $$$ u_i $$$ $$$ v_i $$$ day $$$ t $$$ require $$$ a_i \cdot t + b_i $$$ second pass guarantee every two house connect a sequence pathways print $$$ m $$$ integers — lengths longest path camp a $$$ t=0 t=1 \ldots t = m-1 $$$ days start rain let 's consider first example first three days ( $$$ 0 \le t \le 2 $$$ ) longest path 2nd 3rd house length equal $$$ 100 + <unknown> $$$ second third day ( $$$ t=2 $$$ ) road house 1 4 length $$$ 100 $$$ keep increase , days $$$ t=2 3 4 5 $$$ longest path vertices 4 ( 1 2 ) length $$$ 180 + 10 t $$$ notice day $$$ t=2 $$$ three pathways length 100 three maximal paths equal length sixth day ( $$$ t=5 $$$ ) pathway first fifth house get length 100 . every day $$$ t=5 $$$ longest path house 4 5 length $$$ 80 + 30 t $$$",['data structures'],3200.0
150/E,winter ... well ' ve get idea : - ) nvodsk road system represent n junctions connect n - 1 bidirectional roads a path two junctions organizers event want choose a place accommodate participants ( junction v ) place set contest ( junction u ) besides one hand want participants walk city see <unknown> ( 's distance v u less l ) hand n't want participants <unknown> ( distance v u r ) besides every street know beauty — integer 0 109 . task choose path fit length limit largest average beauty <unknown> define average beauty a median sequence beauties roads along path put formally like : let a path length k. let ai a non - decreasing sequence contain exactly k elements number occur exactly number time a road beauty occur along path represent path median number <unknown> / <unknown> assume <unknown> start zero use <unknown> — number <unknown> round nearest integer example a = { 0 5 12 } median equal 5 a = { 0 5 7 12 } median number 7 . guarantee least one path suitable quantity roads first line contain three integers n l r ( 1 ≤ l ≤ r < n ≤ 105 ) next n - 1 line contain descriptions roads nvodsk line contain three integers ai bi ci ( 1 ≤ ai bi ≤ n 0 ≤ ci ≤ 109 ai ≠ bi ) — junctions ai bi connect a street whose beauty equal ci print two integers — number junctions accommodate participants set contest correspondingly multiple optimal variants print first sample roads beauty mean paths positive length median thus path length 3 4 inclusive valid us second sample city look like : 1 - 2 - 3 - 4 - 5 - 6 . two last roads <unknown> choose path contain suitable length either path 2 6 path 3 6,['data structures'],3000.0
293/E,' ve get a weight tree consist n vertices edge a non - negative weight length path two vertices tree number edge path weight path total weight edge contain two vertices close exist a path length l a path weight w count number pair vertices v u ( v < u ) vertices v u close first line contain three integers n l w ( 1 ≤ n ≤ 105 1 ≤ l ≤ n 0 ≤ w ≤ 109 ) next n - 1 line contain descriptions tree edge i - th line contain two integers pi wi ( 1 ≤ pi < ( i + 1 ) 0 ≤ wi ≤ 104 ) mean i - th edge connect vertex ( i + 1 ) pi weight wi consider tree vertices index 1 n way print a single integer — number close pair please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier,['data structures'],2700.0
342/E,xenia programmer a tree consist n nod consider tree nod index 1 n. also consider first node initially paint red nod — paint blue distance two tree nod v u number edge shortest path v u. xenia need learn quickly execute query two type : task write a program execute describe query first line contain two integers n m ( 2 ≤ n ≤ 105 1 ≤ m ≤ 105 ) — number nod tree number query next n - 1 line contain tree edge i - th line contain a pair integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) — edge tree next m line contain query query specify a pair integers ti vi ( 1 ≤ ti ≤ 2 1 ≤ vi ≤ n ) ti = 1 a reply query need paint a blue node vi red ti = 2 reply query print shortest distance red node node vi guarantee give graph a tree query correct second type query print reply a single line,['data structures'],2400.0
413/E,"last product r2 company 2d game ' field a new revolutionary algorithm search shortest path a 2 × n maze imagine a maze look like a 2 × n rectangle divide unit square unit square either empty cell obstacle one unit time a person move empty cell maze side - adjacent empty cell shortest path problem formulate follow give two free maze cells need determine minimum time require go one cell unfortunately develop algorithm work well one request find shortest path practice request occur quite often , chief r2 programmer commission <unknown> algorithm find shortest path write a program effectively respond multiple request find shortest path a 2 × n maze first line contain two integers n m ( 1 ≤ n ≤ 2·105 ; 1 ≤ m ≤ 2·105 ) — width maze number query correspondingly next two line contain maze line contain n character character equal either ' . ' ( empty cell ) ' x ' ( obstacle ) next m line contain two integers vi ui ( 1 ≤ vi ui ≤ 2n ) — description i - th request number vi ui mean need print value shortest path cell maze number vi cell number ui assume cells first line maze number 1 n leave right cells second line number n + 1 2n leave right guarantee give cells empty print m line i - th line print answer i - th request — either size shortest path -1 ca n't reach second cell first one",['data structures'],2200.0
1190/D,$$$ n $$$ point plane $$$ i $$$ -th $$$ ( x_i y_i ) $$$ tokitsukaze want draw a strange rectangular area pick point area strange area enclose three line $$$ x = l $$$ $$$ y = a $$$ $$$ x = r $$$ leave side bottom side right side respectively $$$ l $$$ $$$ r $$$ $$$ a $$$ real number satisfy $$$ l < r $$$ upper side area <unknown> <unknown> a line parallel $$$ x $$$ -axis infinity follow figure show a strange rectangular area a point $$$ ( x_i y_i ) $$$ strange rectangular area $$$ l < x_i < r $$$ $$$ y_i > a $$$ example figure $$$ p_1 $$$ area $$$ p_2 $$$ tokitsukaze want know many different non - empty set obtain pick point a strange rectangular area think two set different exist least one point one set first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 2 \times 100000 $$$ ) — number point plane $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \leq x_i y_i \leq 1000000000 $$$ ) — coordinate $$$ i $$$ -th point point distinct print a single integer — number different non - empty set point obtain first example exactly one set $$$ k $$$ point $$$ k = 1 2 3 $$$ total number $$$ 3 $$$ second example number set $$$ k $$$ point $$$ k = 1 2 3 $$$ $$$ 3 $$$ $$$ 2 $$$ $$$ 1 $$$ respectively sum $$$ 6 $$$ third example follow figure show <unknown> number different non - empty set example $$$ 2 + 3 + 0 + 1 = 6 $$$,['data structures'],2000.0
1217/F,give undirected graph $$$ n $$$ vertices number $$$ 1 $$$ $$$ n $$$ initially edge ask perform query graph let $$$ last $$$ answer latest query second type set $$$ 0 $$$ first query query follow : good luck ! first line contain two integer number $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n m \le 200000 $$$ ) — number vertices number query respectively follow $$$ m $$$ line contain a query one two aforementioned type guarantee least one query second type print a string consist character ' 0 ' ' 1 ' $$$ i $$$ -th character answer $$$ i $$$ -th query second type therefore length string equal number query second type convert query first example : convert query second example :,['data structures'],2600.0
429/D,iahub <unknown> best competitive programmers town however ca n't qualify important contest selection make help a single problem <unknown> a friend iahub manage get hold problem contest want make sure iahub one qualify tell iahub follow task 're give ( 1 - based ) array a n elements let 's define function f ( i j ) ( 1 ≤ i j ≤ n ) ( i - j ) 2 + g ( i j ) 2 . function g calculate follow pseudo - code : find a value mini ≠ j f ( i j ) probably iahub already figure solution problem ? first line input contain a single integer n ( 2 ≤ n ≤ 100000 ) next line contain n integers a [ 1 ] a [ 2 ] ... a [ n ] ( - 104 ≤ a [ i ] ≤ 104 ) output a single integer — value mini ≠ j f ( i j ),['data structures'],2200.0
1156/E,give a permutation $$$ p $$$ $$$ n $$$ integers $$$ 1 $$$ $$$ 2 $$$ ... $$$ n $$$ ( a permutation array element $$$ 1 $$$ $$$ n $$$ occur exactly ) let 's call subsegment $$$ p [ l r ] $$$ permutation special $$$ <unknown> + <unknown> = \max \limits _ { i = l } ^ { r } p_i $$$ please calculate number special subsegments first line contain one integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) second line contain $$$ n $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) integers pairwise distinct print number special subsegments give permutation special subsegments first example $$$ [ 1 5 ] $$$ $$$ [ 1 3 ] $$$ special subsegment second example $$$ [ 1 3 ] $$$,['data structures'],2200.0
749/E,"give a permutation integers 1 n. exactly apply follow operation permutation : pick a random segment shuffle elements formally : inversion a pair elements ( necessary neighbour ) wrong relative order word number inversion equal number pair ( i j ) i < j ai > aj find expect number inversions apply exactly one operation mention first line contain a single integer n ( 1 ≤ n ≤ 100 000 ) — length permutation second line contain n distinct integers 1 n — elements permutation print one real value — expect number inversions answer consider correct absolute relative error exceed 10 - 9 . namely : let 's assume answer a answer jury b. checker program consider answer correct ,",['data structures'],2400.0
895/E,vasya petya tire study decide play a game game begin vasya look array a consist n integers soon remember elements a game begin vasya close eye petya q action one two <unknown> ) petya say 4 integers l1 r1 l2 r2 — boundaries two non - intersecting segment swap one random element [ l1 r1 ] segment another random element [ l2 r2 ] <unknown> ) petya ask vasya sum elements a [ l r ] segment vasya a mathematician answer petya mathematical expectation sum elements segment task write a program answer second type question vasya would word program print mathematical expectation sum elements a [ l r ] segment every second type query first line contain two integers n q ( 2 ≤ n ≤ 105 1 ≤ q ≤ 105 ) — number elements array number query need handle second line contain n integers ai ( 1 ≤ ai ≤ 109 ) — elements array next q line contain petya 's action type 1 2 . a type 1 action line contain 5 integers 1 l1 r1 l2 r2 ( 1 ≤ l1 ≤ r1 ≤ n 1 ≤ l2 ≤ r2 ≤ n ) a type 2 query line contain 3 integers 2 l r ( 1 ≤ l ≤ r ≤ n ) guarantee least one type 2 query segment [ l1 r1 ] [ l2 r2 ] n't common elements type 2 query print one real number — mathematical expectation sum elements segment answer consider correct absolute relative error n't exceed 10 - 4 — formally answer correct x jury 's answer y,['data structures'],2300.0
896/C,— willem ... — 's matter ? — seem 's something wrong seniorious ... — i 'll a look ... seniorious make link special <unknown> particular order 500 years <unknown> bad condition willem decide examine <unknown> seniorious n piece talisman willem put a line i - th integer ai order maintain willem need perform m operations four type operations : line contain four integers n m seed vmax ( 1 ≤ n m ≤ 105 0 ≤ seed < 109 + 7 1 ≤ vmax ≤ 109 ) initial value operations generate use follow pseudo code : op type operation mention legend operation type 3 4 output a line contain answer first example initial array { 8 9 7 2 3 1 5 6 4 8 } operations :,['data structures'],2600.0
138/C,one day natalia walk woods meet a little mushroom gnome gnome tell follow story : everybody know mushroom gnomes ' power lie magic mushroom grow native woods gnomes n tree m magic mushroom woods : i - th tree grow a point a straight line coordinate ai height hi j - th mushroom grow point coordinate bj magical power zj one day <unknown> <unknown> <unknown> enemies mushroom gnomes <unknown> a terrible storm home forest a result tree begin fall crush magic mushroom supreme oracle mushroom gnomes calculate advance probability tree fall leave right stand tree coordinate x height h fall leave mushroom belong right - open interval [ x - h x ) destroy a tree fall right mushroom belong left - open interval ( x x + h ] destroy mushroom hit a single tree survive know tree fall independently ( i.e. events <unknown> independent besides tree interfere tree fall arbitrary direction ) supreme oracle also able quickly calculate would expectation total power mushroom survive storm calculations ultimately save mushroom gnomes <unknown> death natalia a good olympiad programmer get interest story decide come a way quickly calculate expectation sum survive mushroom ' power first line contain two integers n m ( 1 ≤ n ≤ 105 1 ≤ m ≤ 104 ) — number tree mushroom respectively next n line contain four integers — ai hi li ri ( |ai| ≤ 109 1 ≤ hi ≤ 109 0 ≤ li ri li + ri ≤ 100 ) represent coordinate i - th tree height percentage probabilities tree fall leave right respectively ( remain percentage probability tree stand ) next m line contain two integers bj zj ( <unknown> ≤ 109 1 ≤ zj ≤ 103 ) represent coordinate magical power j - th mushroom respectively arbitrary number tree mushroom grow one point print a real number — expectation total magical power survive mushroom result accept relative absolute accuracy 10 - 4 . believe mushroom coordinate x belong right - open interval [ l r ) l ≤ x < r. similarly mushroom coordinate x belong left - open interval ( l r ] l < x ≤ r. first test mushroom survive probability 50 % depend single tree fall second test mushroom survive neither two tree fall occur probability 50 % × 50 % = 25 % <unknown> <unknown> 12 large test 105 tree one mushroom,['data structures'],2200.0
1295/E,"give a permutation $$$ p_1 p_2 \dots p_n $$$ ( array integer $$$ 1 $$$ $$$ n $$$ appear exactly ) weight $$$ i $$$ -th element permutation $$$ a_i $$$ first separate permutation two non - empty set — prefix suffix formally first set contain elements $$$ p_1 p_2 \dots p_k $$$ second — $$$ p _ { k+1 } p _ { <unknown> } \dots p_n $$$ $$$ 1 \le k < n $$$ , may move elements set operation allow choose element first set move second set vice versa ( move second set first ) pay $$$ a_i $$$ dollars move element $$$ p_i $$$ goal make element first set less element second set note one set empty condition meet example $$$ p = [ 3 1 2 ] $$$ $$$ a = [ 7 1 4 ] $$$ optimal strategy : separate $$$ p $$$ two part $$$ [ 3 1 ] $$$ $$$ [ 2 ] $$$ move $$$ 2 $$$ -element first set ( cost $$$ 4 $$$ ) $$$ p = [ 3 5 1 6 2 4 ] $$$ $$$ a = [ 9 1 9 9 1 9 ] $$$ optimal strategy : separate $$$ p $$$ two part $$$ [ 3 5 1 ] $$$ $$$ [ 6 2 4 ] $$$ move $$$ 2 $$$ -element first set ( cost $$$ 1 $$$ ) $$$ 5 $$$ -element second set ( also cost $$$ 1 $$$ ) calculate minimum number dollars spend first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — length permutation second line contain $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) 's guarantee sequence contain element $$$ 1 $$$ $$$ n $$$ exactly third line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) print one integer — minimum number dollars spend",['data structures'],2200.0
1303/G,define sum prefix sum array $$$ [ s_1 s_2 \dots s_k ] $$$ $$$ s_1 + ( s_1 + s_2 ) + ( s_1 + s_2 + s_3 ) + \dots + ( s_1 + s_2 + \dots + s_k ) $$$ give a tree consist $$$ n $$$ vertices vertex $$$ i $$$ integer $$$ a_i $$$ write define value simple path vertex $$$ u $$$ vertex $$$ v $$$ follow : consider vertices appear path $$$ u $$$ $$$ v $$$ write number write vertices order appear path compute sum prefix sum result sequence task calculate maximum value paths tree first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le <unknown> $$$ ) — number vertices tree $$$ n - 1 $$$ line follow represent edge tree line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) denote edge vertices $$$ u_i $$$ $$$ v_i $$$ guarantee edge form a tree last line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) print one integer — maximum value paths tree best path first example vertex $$$ 3 $$$ vertex $$$ 1 $$$ give sequence $$$ [ 3 3 7 1 ] $$$ sum prefix sum $$$ 36 $$$,['data structures'],2700.0
1418/G,give array $$$ a $$$ consist $$$ n $$$ integers denote subarray $$$ a [ l .. r ] $$$ array $$$ [ a_l a _ { l + 1 } \dots a_r ] $$$ ( $$$ 1 \le l \le r \le n $$$ ) a subarray consider good every integer occur subarray occur exactly <unknown> example array $$$ [ 1 2 2 2 1 1 2 2 2 ] $$$ three good subarrays : calculate number good subarrays give array $$$ a $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) print one integer — number good subarrays array $$$ a $$$,['data structures'],2500.0
1523/G,william own a flat central <unknown> decide rent flat next $$$ n $$$ days earn money since flat center city instantly get $$$ m $$$ offer form $$$ ( l_i r_i ) $$$ mean someone want book flat day $$$ l_i $$$ day $$$ r_i $$$ inclusive avoid spend a lot time figure whether 's profitable accept offer william decide develop algorithm algorithm process offer arrive accept offer $$$ i $$$ follow two condition satisfy : william n't sure value $$$ x $$$ ask help $$$ x $$$ $$$ 1 $$$ $$$ n $$$ want calculate total number days flat would occupy correspond value assign $$$ x $$$ first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 1 \le n \le 5 \cdot 10000 1 \le m \le 100000 ) $$$ number days number offer respectively next $$$ m $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ $$$ ( 1 \le l_i \le r_i \le n ) $$$ describe $$$ i $$$ -th rent offer offer give chronological order print $$$ n $$$ integers number $$$ i $$$ -th line must equal number days flat would occupy algorithm use value $$$ x $$$ equal $$$ i $$$ description segment first sample test $$$ x $$$ :,['data structures'],3200.0
1547/F,give array positive integers $$$ a = [ a_0 a_1 \dots a _ { n - 1 } ] $$$ ( $$$ n \ge 2 $$$ ) one step array $$$ a $$$ replace another array length $$$ n $$$ element greatest common divisor ( gcd ) two neighbor elements ( element right neighbor ; consider right neighbor $$$ ( n - 1 ) $$$ -th element $$$ 0 $$$ -th element ) formally speak a new array $$$ b = [ b_0 b_1 \dots b _ { n - 1 } ] $$$ build array $$$ a = [ a_0 a_1 \dots a _ { n - 1 } ] $$$ $$$ b_i $$$ $$$ = \gcd ( a_i a _ { ( i + 1 ) \mod n } ) $$$ $$$ \gcd ( x y ) $$$ greatest common divisor $$$ x $$$ $$$ y $$$ $$$ x \mod y $$$ remainder $$$ x $$$ divide $$$ y $$$ one step array $$$ b $$$ build array $$$ a $$$ replace $$$ b $$$ ( assignment $$$ a $$$ : = $$$ b $$$ take place ) example $$$ a = [ 16 24 10 5 ] $$$ $$$ b = [ \gcd ( 16 24 ) $$$ $$$ \gcd ( 24 10 ) $$$ $$$ \gcd ( 10 5 ) $$$ $$$ \gcd ( 5 16 ) ] $$$ $$$ = [ 8 2 5 1 ] $$$ thus one step array $$$ a = [ 16 24 10 5 ] $$$ equal $$$ [ 8 2 5 1 ] $$$ a give array $$$ a $$$ find minimum number step value $$$ a_i $$$ become equal ( $$$ a_0 = a_1 = \dots = a _ { n - 1 } $$$ ) original array $$$ a $$$ consist identical elements consider number step equal $$$ 0 $$$ first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) $$$ t $$$ test case follow test case contain two line first line contain integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — length sequence $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_0 a_1 \dots a _ { n - 1 } $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ print $$$ t $$$ number — answer test case,['data structures'],1900.0
1583/H,"omkar host tour country omkarland ! $$$ n $$$ cities omkarland , rather <unknown> exactly $$$ n-1 $$$ bidirectional roads connect cities guarantee reach city city road network every city enjoyment value $$$ e $$$ road a capacity $$$ c $$$ denote maximum number vehicles associate toll $$$ t $$$ however toll system omkarland interest <unknown> : a vehicle travel multiple roads a single journey pay highest toll single road travel ( word pay $$$ \max t $$$ roads travel . ) a vehicle traverse roads pay $$$ 0 $$$ toll omkar decide host $$$ q $$$ tour group tour group consist $$$ v $$$ vehicles start city $$$ x $$$ ( keep mind a tour group $$$ v $$$ vehicles travel roads capacity $$$ \geq v $$$ . ) tour <unknown> omkar want group much fun possibly also must reimburse group toll pay thus tour group omkar want know two things : first enjoyment value city $$$ y $$$ maximum enjoyment value tour group reach start city second much per vehicle omkar pay reimburse entire group trip $$$ x $$$ $$$ y $$$ ? ( trip $$$ x $$$ $$$ y $$$ always shortest path $$$ x $$$ $$$ y $$$ ) case multiple reachable cities maximum enjoyment value omkar let tour group choose one want go therefore prepare possible <unknown> want know amount money per vehicle need guarantee reimburse group regardless city choose first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \leq n \leq 200000 $$$ $$$ 1 \leq q \leq 200000 $$$ ) represent number cities number group respectively next line contain $$$ n $$$ integers $$$ e_1 e_2 \ldots <unknown> $$$ ( $$$ 1 \leq e_i \leq 1000000000 $$$ ) $$$ e_i $$$ represent enjoyment value city $$$ i $$$ next $$$ n-1 $$$ line contain four integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ t $$$ ( $$$ 1 \leq a b \leq n $$$ $$$ 1 \leq c \leq 1000000000 $$$ $$$ 1 \leq t \leq 1000000000 $$$ ) represent road city $$$ a $$$ city $$$ b $$$ capacity $$$ c $$$ toll $$$ t $$$ next $$$ q $$$ line contain two integers $$$ v $$$ $$$ x $$$ ( $$$ 1 \leq v \leq 1000000000 $$$ $$$ 1 \leq x \leq n $$$ ) represent number vehicles tour group start city respectively output $$$ q $$$ line $$$ i $$$ -th line contain two integers : highest possible enjoyment value a city reachable $$$ i $$$ -th tour group amount money per vehicle omkar need guarantee reimburse $$$ i $$$ -th tour group a map first sample show nod unbolded number represent indices bolded number represent enjoyment value edge unbolded number represent <unknown> bolded number represent toll first query a tour group size $$$ 1 $$$ start city $$$ 3 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ thus largest enjoyment value reach $$$ 3 $$$ tour group choose go city $$$ 4 $$$ omkar pay $$$ 8 $$$ per vehicle maximum second query a tour group size $$$ 9 $$$ start city $$$ 5 $$$ reach city $$$ 5 $$$ thus largest reachable enjoyment value still $$$ 3 $$$ omkar pay $$$ 0 $$$ per vehicle third query a tour group size $$$ 6 $$$ start city $$$ 2 $$$ reach cities $$$ 2 $$$ $$$ 4 $$$ largest reachable enjoyment value $$$ 3 $$$ tour group choose go city $$$ 4 $$$ omkar pay $$$ 2 $$$ per vehicle maximum a map second sample show : first query a tour group size $$$ 5 $$$ start city $$$ 1 $$$ reach city $$$ 1 $$$ thus maximum enjoyment value $$$ 1 $$$ cost omkar pay $$$ 0 $$$ per vehicle second query a tour group size $$$ 4 $$$ start city $$$ 1 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ thus maximum enjoyment value $$$ 2 $$$ omkar pay $$$ 1 $$$ per vehicle third query a tour group size $$$ 3 $$$ start city $$$ 1 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ thus maximum enjoyment value $$$ 3 $$$ omkar pay $$$ 1 $$$ per vehicle fourth query a tour group size $$$ 2 $$$ start city $$$ 1 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ thus maximum enjoyment value $$$ 4 $$$ omkar pay $$$ 1 $$$ per vehicle fifth query a tour group size $$$ 1 $$$ start city $$$ 1 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ thus maximum enjoyment value $$$ 5 $$$ omkar pay $$$ 1 $$$ per vehicle",['data structures'],3300.0
1615/H,$$$ n $$$ reindeer north <unknown> battle highest spot ` ` top reindeer '' leaderboard front page <unknown> ( a popular competitive reindeer game website ) <unknown> ` ` top reindeer '' title a measure upvotes nothing skill level reindeer game still give utmost importance currently $$$ i $$$ -th reindeer a score $$$ a_i $$$ would like influence leaderboard operations operation choose a reindeer either increase decrease score $$$ 1 $$$ unit negative score allow $$$ m $$$ requirements result score requirement give order pair $$$ ( u v ) $$$ mean operations score reindeer $$$ u $$$ must less equal score reindeer $$$ v $$$ task perform minimum number operations requirements satisfy first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2\le n\le 1000 $$$ ; $$$ 1\le m\le 1000 $$$ ) — number reindeer requirements respectively second line contain $$$ n $$$ integers $$$ a_1 \ldots a_n $$$ ( $$$ 1\le a_i\le 1000000000 $$$ ) $$$ a_i $$$ current score reindeer $$$ i $$$ next $$$ m $$$ line describe requirements $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1\le u_i v_i\le n $$$ ; $$$ u_i\ne v_i $$$ ) — two reindeer $$$ i $$$ -th requirement print $$$ n $$$ integers $$$ b_1 \ldots b_n $$$ ( $$$ -10^ { 15 } \le b_i\le 10^ { 15 } $$$ ) $$$ b_i $$$ score $$$ i $$$ -th reindeer operations multiple solutions achieve minimum number operations may output prove always optimal solution $$$ <unknown> 10^ { 15 } $$$ $$$ i $$$,['data structures'],3000.0
1619/H,give a permutation $$$ p $$$ $$$ n $$$ elements a permutation $$$ n $$$ elements array length $$$ n $$$ contain integer $$$ 1 $$$ $$$ n $$$ exactly example $$$ [ 1 2 3 ] $$$ $$$ [ 4 3 5 1 2 ] $$$ permutations $$$ [ 1 2 4 ] $$$ $$$ [ 4 3 2 1 2 ] $$$ permutations perform $$$ q $$$ query two type query : first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n q \le 100000 $$$ ) second line contain $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ next $$$ q $$$ line contain three integers first integer $$$ t $$$ ( $$$ 1 \le t \le 2 $$$ ) — type query $$$ t = 1 $$$ next two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ ; $$$ x \ne y $$$ ) — first - type query $$$ t = 2 $$$ next two integers $$$ i $$$ $$$ k $$$ ( $$$ 1 \le i k \le n $$$ ) — second - type query guarantee least one second - type query every second - type query print one integer a new line — answer query first example $$$ p = \ { 5 3 4 2 1\ } $$$ first query print $$$ p_3 $$$ answer $$$ 4 $$$ second query print $$$ p _ { p_1 } $$$ answer $$$ 1 $$$ third query swap $$$ p_1 $$$ $$$ p_3 $$$ $$$ p = \ { 4 3 5 2 1\ } $$$ fourth query print $$$ p _ { p_1 } $$$ answer $$$ 2 $$$,['data structures'],2400.0
633/E,"e - <unknown> startup <unknown> investors get fund functional n weeks also a website ! week know number unique visitors week vi revenue ci evaluate potential startup range weeks l r inclusive investors use minimum among maximum number visitors multiply 100 minimum revenue period : truth investors idea <unknown> evaluate startup go pick k random distinct weeks li give managers startup li pick ri ≥ li report maximum number visitors minimum revenue period , investors calculate potential startup range take minimum value p ( li ri ) total evaluation grade startup assume managers startup always report optimal value ri particular li i.e. value result grade startup maximize expect result grade startup ? first line input contain two integers n k ( 1 ≤ k ≤ n ≤ 1 000 000 ) second line contain n integers vi ( 1 ≤ vi ≤ 107 ) — number unique visitors week third line contain n integers ci ( 1 ≤ ci ≤ 107 ) — the revenue week print a single real value — expect grade startup answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer a answer jury b. checker program consider answer correct , consider first sample investors ask li = 1 onwards startup choose ri = 1 max number visitors 3 minimum revenue 300 . thus potential case min ( <unknown> 300 ) = 300 . investors ask li = 2 onwards startup choose ri = 3 max number visitors 2 minimum revenue 200 . thus potential case min ( <unknown> 200 ) = 200 . investors ask li = 3 onwards startup choose ri = 3 max number visitors 1 minimum revenue 300 . thus potential case min ( <unknown> 300 ) = 100 . choose a set size 2 equi - probably take minimum possible set : { 200 300 } { 100 300 } { 100 200 } effectively set possible value <unknown> investors equi - probably : { 200 100 100 } thus expect value ( 100 + 200 + 100 ) / 3 = <unknown> ( 3 )",['data structures'],2400.0
1379/F2,"note difference easy hard versions hard version unavailable cells become available easy version ca n't make hack versions solve ildar ivan tire chess really like chessboard invent a new game field a chessboard $$$ 2n \times 2 m $$$ : $$$ 2n $$$ row $$$ 2 m $$$ columns cell row $$$ i $$$ column $$$ j $$$ color white $$$ <unknown> $$$ even color black otherwise game proceed follow : ildar mark white cells chessboard unavailable ask ivan place $$$ n \times m $$$ kings remain white cells way kings attack a king attack another king locate adjacent cells share edge a corner ildar would like <unknown> different combinations cells initially cells mark available $$$ q $$$ query query either mark a cell unavailable mark previously unavailable cell available query would like know whether possible place kings available cells a desire way please help ! first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \leq n m q \leq 200\,000 $$$ ) — size board number query $$$ q $$$ line follow contain a description a query : two integers $$$ i $$$ $$$ j $$$ denote a white cell board ( $$$ 1 \leq i \leq 2n $$$ $$$ 1 \leq j \leq 2 m $$$ $$$ i + j $$$ even ) cell $$$ ( i j ) $$$ available query become unavailable otherwise cell unavailable become available output $$$ q $$$ line $$$ i $$$ -th line contain answer a board $$$ i $$$ query ildar line contain ` ` yes '' possible place kings available cells desire way ` ` '' otherwise first example case second query cells $$$ ( 1 1 ) $$$ $$$ ( 1 5 ) $$$ unavailable ivan place three kings cells $$$ ( 2 2 ) $$$ $$$ ( 2 4 ) $$$ $$$ ( 2 6 ) $$$ third query three cells $$$ ( 1 1 ) $$$ $$$ ( 1 5 ) $$$ $$$ ( 2 4 ) $$$ unavailable remain 3 available cells : $$$ ( 2 2 ) $$$ $$$ ( 1 3 ) $$$ $$$ ( 2 6 ) $$$ ivan put 3 kings cells kings cells $$$ ( 2 2 ) $$$ $$$ ( 1 3 ) $$$ attack since cells share a corner",['data structures'],2800.0
840/D,", leha find leave pocket array consist n integers right pocket q query form l r k. query must answer answer query minimal x x occur interval l r strictly time - 1 number help leha a difficult task first line input data contain two integers n q ( 1 ≤ n q ≤ 3·105 ) — number elements array number query respectively next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ n ) — leha 's array next q line contain three integers l r k ( 1 ≤ l ≤ r ≤ n 2 ≤ k ≤ 5 ) — description query output answer query new line",['data structures'],2500.0
1676/H2,difference two versions version $$$ n \leq 200000 $$$ sum $$$ n $$$ test case exceed $$$ 200000 $$$ a terminal a row $$$ n $$$ equal segment number $$$ 1 $$$ $$$ n $$$ order two <unknown> one give array $$$ a $$$ length $$$ n $$$ $$$ i = 1 2 \dots n $$$ a straight wire point segment $$$ i $$$ top terminal point segment $$$ a_i $$$ bottom terminal ca n't select endpoints a segment example follow picture show two possible wire $$$ n=7 $$$ $$$ a= [ <unknown> ] $$$ a cross occur two wire share a point common picture cross circle red maximum number cross place wire optimally ? first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — elements array sum $$$ n $$$ across test case exceed $$$ 200000 $$$ test case output a single integer — maximum number cross place wire optimally first test case show second picture statement second test case wire possible two wire cross answer $$$ 1 $$$ third test case wire possible one wire answer $$$ 0 $$$,['data structures'],1500.0
1609/F,william array non - negative number $$$ a_1 a_2 \dots a_n $$$ want find many segment $$$ l \le r $$$ pass check check perform follow manner : first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) size array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 10^ { 18 } $$$ ) content array $$$ a $$$ output a single number — total number segment pass check,['data structures'],2800.0
600/E,give a root tree root vertex 1 . vertex colour colour let 's call colour c dominate subtree vertex v colour appear subtree vertex v time colour c. 's possible two colour dominate subtree vertex subtree vertex v vertex v vertices contain vertex v path root vertex v find sum dominate colour subtree vertex v. first line contain integer n ( 1 ≤ n ≤ 105 ) — number vertices tree second line contain n integers ci ( 1 ≤ ci ≤ n ) ci — colour i - th vertex next n - 1 line contain two integers xj yj ( 1 ≤ xj yj ≤ n ) — edge tree first vertex root tree print n integers — sum dominate colour vertex,['data structures'],2300.0
1578/J,kingdom rule a king $$$ n $$$ lord number $$$ 1 $$$ $$$ n $$$ lord a <unknown> overlord might king a different lord closer king king lord kind lord certain need express a certain amount money need however a lord king receive money first split equally vassals still unmet need need vassals meet take money fulfill need money leave return excess overlord ( follow standard procedure distribute money ) begin year king receive a certain sum tax money proceed split accord rule amount tax money greater total need lord procedure guarantee everybody 's need fulfil excess money leave king however enough money lord need meet lord determine minimum amount tax money king receive lord 's need meet first line input contain number lord $$$ n $$$ ( $$$ 0 \le n \le 300000 $$$ ) next $$$ n $$$ line describe one lord $$$ i $$$ -th line contain two integers : $$$ o_i $$$ ( $$$ 0 \le o_i < i $$$ ) — index overlord $$$ i $$$ -th lord ( zero mean king overlord ) $$$ m_i $$$ ( $$$ 1 \le m_i \le 1000000 $$$ ) — amount money $$$ i $$$ -th lord need print $$$ n $$$ integer number $$$ t_i $$$ $$$ i $$$ -th number minimum integer amount tax money king receive need $$$ i $$$ -th lord meet sample input king receive $$$ 5 $$$ units tax money split equally vassals — lord $$$ 1 $$$ $$$ 3 $$$ $$$ 5 $$$ receive $$$ \frac { 5 } { 3 } $$$ money lord $$$ 1 $$$ split money equally vassals — $$$ 2 $$$ $$$ 4 $$$ receive $$$ \frac { 5 } { 6 } $$$ lord $$$ 5 $$$ keep money ( vassals ) lord $$$ 3 $$$ keep $$$ 1 $$$ unit money give remain $$$ \frac { 2 } { 3 } $$$ king king split $$$ \frac { 2 } { 3 } $$$ vassals unmet need — $$$ 1 $$$ $$$ 5 $$$ pass $$$ \frac { 1 } { 3 } $$$ lord $$$ 5 $$$ keep extra cash ( a total $$$ 2 $$$ still enough meet need ) lord $$$ 1 $$$ split equally vassals extra $$$ \frac { 1 } { 6 } $$$ enough meet need lord $$$ 4 $$$,['data structures'],3100.0
1801/E,"one gas station city berland gas station special price gas station a fix range price ready sell gasoline a gas station city number $$$ i $$$ ready sell gasoline price $$$ l_i $$$ $$$ r_i $$$ inclusive king berland — <unknown> family man $$$ m $$$ years two sons bear every year king 's children involve public affairs since early childhood end year check <unknown> gasoline price birth king 's children bear year $$$ i $$$ responsible check gasoline price ways city $$$ a_i $$$ city $$$ b_i $$$ city $$$ c_i $$$ city $$$ d_i $$$ respectively check follow : children simultaneously start journey cities $$$ a_i $$$ $$$ c_i $$$ respectively first son king bear year $$$ i $$$ move along path city $$$ a_i $$$ city $$$ b_i $$$ second — city $$$ c_i $$$ city $$$ d_i $$$ children check price gasoline city $$$ a_i $$$ coincide price gasoline city $$$ c_i $$$ next check price gasoline second city way $$$ a_i $$$ $$$ b_i $$$ coincide price second city way $$$ c_i $$$ $$$ d_i $$$ repeat thing a couple third cities paths end check price gasoline city $$$ b_i $$$ coincide price gasoline city $$$ d_i $$$ guarantee length path city $$$ a_i $$$ city $$$ b_i $$$ coincide length path city $$$ c_i $$$ city $$$ d_i $$$ gas station must strictly obey laws therefore check gasoline price reveal violations help berland gas station find many ways set gasoline price $$$ m $$$ years word $$$ i $$$ $$$ 1 $$$ $$$ m $$$ calculate many ways set gasoline price gas station birth first $$$ i $$$ pair king 's children check reveal violations gas station price acceptable price range since number methods large calculate answer modulo $$$ 1000000000 + 7 $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200\,000 $$$ ) — number cities berland second line contain $$$ ( n - 1 ) $$$ number $$$ p_2 \ p_3 \ <unknown> \ \ldots \ p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) $$$ p_i $$$ denote number next city way city $$$ i $$$ city $$$ 1 $$$ follow line two integers give $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i < 1000000000 + 7 $$$ ) specify acceptable range price gas station number $$$ i $$$ follow line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 200\,000 $$$ ) — number years two sons bear king follow $$$ m $$$ line four integers give $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ $$$ d_i $$$ ( $$$ 1 \le a_i b_i c_i d_i \le n $$$ ) specify two paths king 's children check gasoline price bear year $$$ i $$$ guarantee length path cities $$$ a_i $$$ $$$ b_i $$$ equal length path cities $$$ c_i $$$ $$$ d_i $$$ $$$ m $$$ line print one number number $$$ i $$$ line equal number ways set gasoline price cities king 's children bear years include $$$ i $$$ reveal violations <unknown> output number modulo $$$ 1000000000 + 7 $$$ consider first example birth first two sons price cities $$$ 1 $$$ $$$ 2 $$$ equal total 2 ways choose gasoline price cities $$$ 1 $$$ $$$ 2 $$$ fall within acceptable price range cities , ways set gasoline price : $$$ 6 \cdot 3 = 18 $$$ second pair sons check price paths $$$ 1 - 2 $$$ $$$ 2 - 1 $$$ mean gasoline price cities $$$ 1 $$$ $$$ 2 $$$ must match already do therefore birth second pair sons answer change way third pair sons check price track $$$ 3 - 1 - 2 - 4 $$$ $$$ 4 - 2 - 1 - 3 $$$ price non - gasoline city $$$ 3 $$$ equal price city $$$ 4 $$$ price city $$$ 1 $$$ equal price city $$$ 2 $$$ price cities $$$ 1 $$$ $$$ 2 $$$ already cities $$$ 3 $$$ $$$ 4 $$$ 2 ways choose price gasoline fall within acceptable price range cities , ways set gasoline price : $$$ 4 \cdot 1 = 4 $$$ fourth pair sons check price track $$$ 3 - 1 - 2 - 4 $$$ $$$ 3 - 1 - 2 - 5 $$$ mean price cities $$$ 4 $$$ $$$ 5 $$$ equal since price cities $$$ 3 $$$ $$$ 4 $$$ already coincide cities $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ price gasoline price gasoline city $$$ 3 $$$ 3 price gasoline city $$$ 5 $$$ less 4 . birth fourth pair sons ways set gasoline price check carry price require range",['data structures'],3000.0
1625/E2,"hard version problem difference easy hard versions removal query present hard version ` ` interplanetary software inc . '' together ` ` robots <unknown> <unknown> . '' develop release robot cat electronic <unknown> <unknown> catch <unknown> entertain owner various ways developers ` ` interplanetary software inc . '' recently decide release a software update robots update cat must solve problems bracket sequence one problems describe first need learn a bite bracket sequence theory consider string contain character ` ` ( ` ` ` ` ) '' ` ` . ` ` call a string regular bracket sequence ( rbs ) transform empty string one operations remove either single ` ` . '' character a continuous substring ` ` ( ) '' instance string ` ` ( ( ) ( . ) ) '' rbs transform empty string follow sequence <unknown> : get empty string initial string rbs time string ` ` ) ( ` ` rbs possible apply removal operations rbs simple rbs empty n't start ` ` ` ` n't end ` ` . ` ` denote substring string $$$ s $$$ sequential subsegment particular $$$ s [ <unknown> r ] = s_ls _ { l+1 } \dots s_r $$$ $$$ s_i $$$ $$$ i $$$ -th character string $$$ s $$$ , move problem statement give a string $$$ s $$$ initially consist character ` ` ( ` ` ` ` ) '' need answer follow query : employee ` ` interplanetary software inc . '' give task teach cat solve problem update first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \le n \le 3\cdot100000 $$$ $$$ 1 \le q \le 3\cdot100000 $$$ ) length string number query second line contain string $$$ s $$$ consist $$$ n $$$ character ` ` ( ` ` ` ` ) '' follow $$$ q $$$ line contain three integers $$$ t $$$ $$$ l $$$ $$$ r $$$ ( $$$ t \in \ { 1 2\ } $$$ $$$ 1 \le l < r \le n $$$ ) query need answer guarantee query valid correspond problem statements query print a single integer a separate line number substrings simple rbs answer must print order query specify input consider example test case answer first query $$$ 3 $$$ three suitable substrings : $$$ s [ 3\dots6 ] $$$ $$$ s [ 3\dots4 ] $$$ $$$ s [ 5\dots6 ] $$$ answer second query $$$ 4 $$$ substrings $$$ s [ 3\dots6 ] $$$ $$$ s [ 3\dots4 ] $$$ $$$ s [ 5\dots6 ] $$$ $$$ s [ 2\dots7 ] $$$ third query string become ` ` ) ( .. ( ) ) ( ) '' answer fourth query $$$ 2 $$$ substrings $$$ s [ 5\dots6 ] $$$ $$$ s [ 2\dots7 ] $$$ note $$$ s [ 3\dots6 ] $$$ a simple rbs anymore start ` ` . ` ` answer fifth query $$$ 4 $$$ substrings $$$ s [ 5\dots6 ] $$$ $$$ s [ 2\dots7 ] $$$ $$$ s [ 8\dots9 ] $$$ $$$ s [ <unknown> ] $$$ sixth query string become ` ` ) ( <unknown> ) ( ) '' seventh query string become ` ` ) <unknown> ( ) '' answer eighth query $$$ 1 $$$ substring $$$ s [ 8\dots9 ] $$$",['data structures'],2800.0
1632/E1,version problem differ next one constraint $$$ n $$$ a tree a connect undirected graph without cycle a weight tree a weight assign edge distance two vertices minimum sum weight path connect give a weight tree $$$ n $$$ vertices edge a weight $$$ 1 $$$ denote $$$ d ( v ) $$$ distance vertex $$$ 1 $$$ vertex $$$ v $$$ let $$$ f ( x ) $$$ minimum possible value $$$ \max\limits _ { 1 \leq v \leq n } \ { d ( v ) } $$$ <unknown> add edge weight $$$ x $$$ two vertices $$$ a $$$ $$$ b $$$ $$$ ( 1 \le a b \le n ) $$$ note operation graph longer a tree integer $$$ x $$$ $$$ 1 $$$ $$$ n $$$ find $$$ f ( x ) $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 3000 $$$ ) next $$$ n−1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) indicate edge vertices $$$ u $$$ $$$ v $$$ guarantee give edge form a tree guarantee sum $$$ n $$$ test case n't exceed $$$ 3000 $$$ test case print $$$ n $$$ integers a single line $$$ x $$$ -th equal $$$ f ( x ) $$$ $$$ x $$$ $$$ 1 $$$ $$$ n $$$,['data structures'],2400.0
1634/E,"give $$$ m $$$ array positive integers array even length need split integers two equal multisets $$$ l $$$ $$$ r $$$ , element array go one two multisets ( ) additionally $$$ m $$$ array exactly half elements go $$$ l $$$ rest go $$$ r $$$ give example a division determine division exist first line contain integer $$$ m $$$ ( $$$ 1 \le m \le 10 ^ 5 $$$ ) — number array next $$$ 2 \cdot m $$$ line contain descriptions array array first line contain even integer $$$ n $$$ ( $$$ 2 \le n \le 20 ^ 5 $$$ ) — length array second line consist $$$ n $$$ space - separated integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 10 ^ 9 $$$ ) — array elements guarantee sum $$$ n $$$ array exceed $$$ 200000 $$$ answer exist print ` ` yes '' print $$$ m $$$ line line element print letter ` ` l '' ` ` r '' ( <unknown> without space ) depend multiset element go answer print ` ` '' line first array add first element $$$ r $$$ second $$$ l $$$ $$$ l = \ { 2\ } $$$ $$$ r = \ { 1\ } $$$ second array add first third elements $$$ l $$$ rest $$$ r $$$ $$$ l = \ { 1 2 3\ } $$$ $$$ r = \ { 1 2 3\ } $$$ third array add elements 2 3 6 $$$ l $$$ others — $$$ r $$$ a result $$$ l = r = \ { 1 1 2 2 3 3\ } $$$",['data structures'],2400.0
1648/F,"order make capital berland a <unknown> place tourists great king come follow plan : choose two streets city call avenues certainly avenues <unknown> extremely important historical place <unknown> tourists world capital berland represent a graph vertices crossroads edge streets connect two crossroads total $$$ n $$$ vertices $$$ m $$$ edge graph move directions along street get crossroad move along streets street connect two different crossroads two streets connect pair crossroads order reduce flow ordinary citizens move along great avenues decide introduce a toll avenue directions need pay $$$ 1 $$$ <unknown> one passage along avenue n't pay rest streets <unknown> collect a sample $$$ k $$$ citizens $$$ i $$$ -th need go work crossroad $$$ a_i $$$ crossroad $$$ b_i $$$ two avenues choose citizen go work along path minimal cost order earn much money possible decide choose two streets two avenues total number tugriks pay $$$ k $$$ citizens maximize help king : accord give scheme city a sample citizens find two streets make avenues many tugriks citizens pay accord choice test consist multiple test case first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 3 \leq n \leq 500\,000 $$$ $$$ n - 1 \leq m \leq 500\,000 $$$ $$$ m \le \frac { n ( n - 1 ) } { 2 } $$$ ) — number crossroads streets respectively next $$$ m $$$ line contain description streets $$$ i $$$ -th line contain two integers $$$ s_i $$$ $$$ f_i $$$ ( $$$ 1 \leq s_i f_i \leq n $$$ $$$ s_i \neq f_i $$$ ) — index crossroads connect $$$ i $$$ -th street guarantee two streets connect pair crossroads get crossroad move along streets next line contain a single integer $$$ k $$$ ( $$$ 1 \leq k \leq 500\,000 $$$ ) — amount citizens sample next $$$ k $$$ line contain description citizens $$$ i $$$ -th line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a_i b_i \leq n $$$ $$$ a_i \neq b_i $$$ ) — $$$ i $$$ -th citizen go work crossroad $$$ a_i $$$ crossroad $$$ b_i $$$ let $$$ m $$$ sum $$$ m $$$ test case $$$ k $$$ sum $$$ k $$$ test case guarantee $$$ m k \le 500\,000 $$$ test case print answer problem first line print total amount tugriks pay citizens second line print two integers $$$ x_1 $$$ $$$ y_1 $$$ — number crossroads connect first avenue third line print two integers $$$ x_2 $$$ $$$ y_2 $$$ — number crossroads connect second avenue number crossroads connect avenue print order print streets among $$$ m $$$ streets city choose streets different",['data structures'],3500.0
1585/E,petya a root tree integer write vertex vertex $$$ 1 $$$ root answer question tree a tree a connect graph without cycle a root tree a special vertex call root parent a node $$$ v $$$ next vertex shortest path $$$ v $$$ root question define three integers $$$ v $$$ $$$ l $$$ $$$ k $$$ get answer question need perform follow step : example sequence integers path $$$ v $$$ root $$$ [ 2 2 1 7 1 1 4 4 4 4 ] $$$ $$$ l = 2 $$$ $$$ k = 2 $$$ answer $$$ 1 $$$ please answer question tree test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 1000000 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \leq n q \leq 1000000 $$$ ) — number vertices tree number question second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) $$$ a_i $$$ number write $$$ i $$$ -th vertex third line contain $$$ n-1 $$$ integers $$$ p_2 p_3 \ldots p_n $$$ ( $$$ 1 \leq p_i \leq n $$$ ) $$$ p_i $$$ parent node $$$ i $$$ 's guarantee value $$$ p $$$ define a correct tree next $$$ q $$$ line contain three integers $$$ v $$$ $$$ l $$$ $$$ k $$$ ( $$$ 1 \leq v l k \leq n $$$ ) — descriptions question guarantee sum $$$ n $$$ sum $$$ q $$$ test case exceed $$$ 1000000 $$$ question test case print answer question case multiple answer print,['data structures'],2400.0
1730/E,give array $$$ a_1 a_2 \ldots a_n $$$ positive integers find number pair indices $$$ ( l r ) $$$ $$$ 1 \le l \le r \le n $$$ pass check check perform follow manner : first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) — number test case test case follow test case consist two line first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) — size array second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 500000 $$$ test case print a single integer — number pair indices pass check $$$ x \mid y $$$ denote $$$ y $$$ divisible $$$ x $$$ first test case one pair $$$ ( 1 1 ) $$$ maximum pair $$$ 1 $$$ minimum also $$$ 1 $$$ $$$ 1 \mid 1 $$$ check pass answer $$$ 1 $$$ second test case $$$ 3 $$$ segment : third test case $$$ 3 $$$ segment :,['data structures'],2700.0
1651/D,give $$$ n $$$ distinct point a plane coordinate $$$ i $$$ -th point $$$ ( x_i y_i ) $$$ point $$$ i $$$ find nearest ( term manhattan distance ) point integer coordinate among give $$$ n $$$ point multiple point — choose manhattan distance two point $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ $$$ <unknown> - <unknown> + <unknown> - <unknown> $$$ first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number point set next $$$ n $$$ line describe point $$$ i $$$ -th contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le 200000 $$$ ) — coordinate $$$ i $$$ -th point guarantee point input distinct print $$$ n $$$ line $$$ i $$$ -th line print point integer coordinate among give $$$ n $$$ point nearest ( term manhattan distance ) $$$ i $$$ -th point input output coordinate range $$$ [ -1000000 ; 1000000 ] $$$ show optimal answer meet constraints several answer print,['data structures'],1900.0
1403/B,spring clean probably bore part live except year flóra mother find a <unknown> old tree graph <unknown> tree $$$ n $$$ nod ( number $$$ 1 $$$ $$$ n $$$ ) connect $$$ n-1 $$$ edge edge gather much <unknown> flóra 's mom decide clean clean edge arbitrary tree do repeat follow process : choose 2 different leave ( a node a leaf connect exactly one node edge ) clean every edge lie shortest path path $$$ d $$$ edge cost clean path $$$ d $$$ n't want <unknown> leave tree choose every one a tree clean edge clean cost sum cost clean paths flóra think tree find small simple imagine $$$ q $$$ variations $$$ i $$$ -th variation add a total $$$ d_i $$$ extra leave original tree : new leaf choose a node original tree connect node new leaf edge note nod may stop leave step $$$ q $$$ variations interest minimum cost require clean tree first line contain two space - separated integer $$$ n $$$ $$$ q $$$ ( $$$ 3 \leq n \leq 10^ { 5 } $$$ $$$ 1 \leq q \leq 10^ { 5 } $$$ ) – number nod tree number variations next $$$ n-1 $$$ line contain two space - separated integers $$$ u $$$ $$$ v $$$ denote nod $$$ u $$$ $$$ v $$$ connect edge ( $$$ 1 \leq u v \leq n $$$ ) next $$$ q $$$ line describe variations first integer $$$ i $$$ th line $$$ d_i $$$ ( $$$ 1 \leq d_i \leq 10^ { 5 } $$$ ) $$$ d_i $$$ space - separated integers follow : $$$ j $$$ th number $$$ a_j $$$ mean flóra add a new leaf node $$$ a_j $$$ ( $$$ 1 \leq a_j \leq n $$$ ) may add one leaf node $$$ \sum _ { 1 } ^ { q } d_i \leq 10^ { 5 } $$$ i.e sum $$$ d_i $$$ <unknown> $$$ 100000 $$$ variation flóra <unknown> add extra leave original tree print $$$ q $$$ line $$$ i $$$ -th line print a single integer : minimum cost require clean $$$ i $$$ -th variation tree tree clean print $$$ -1 $$$ follow picture show second variation a possible solution clean path leave $$$ 1 - 6 $$$ $$$ a - 7 $$$ $$$ b - 3 $$$ download example additional ( bigger ) sample input : https : <unknown> / <unknown>,['data structures'],2300.0
1444/C,"new academic year start berland 's university $$$ n $$$ first - year students divide $$$ k $$$ academic group however group might empty among students $$$ m $$$ pair acquaintances acquaintance pair might a common group two different group alice <unknown> first years want host entertain game make everyone know , select two different academic group divide students group two team game require acquaintance pair inside team alice wonder many pair group select 'll possible play a game students two select group must take part game please note team alice form game n't need coincide group students learn moreover team may different size ( even empty ) first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n \le 500\,000 $$$ ; $$$ 0 \le m \le 500\,000 $$$ ; $$$ 2 \le k \le 500\,000 $$$ ) — number students number pair acquaintances number group respectively second line contain $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \le c_i \le k $$$ ) $$$ c_i $$$ equal group number $$$ i $$$ -th student next $$$ m $$$ line follow $$$ i $$$ -th contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ ) denote students $$$ a_i $$$ $$$ b_i $$$ acquaintances 's guarantee $$$ a_i \neq b_i $$$ ( unordered ) pair mention print a single integer — number ways choose two different group 's possible select two team play game acquaintances graph first example show picture ( next student group number write ) test select follow group : second example select group pair please note even though third group students still select ( group ) game",['data structures'],2500.0
1508/E,yuu <unknown> touko <unknown> <unknown> ! we d day yuu gift touko a direct tree $$$ n $$$ nod root $$$ 1 $$$ a label $$$ a $$$ dfs order tree every edge tree direct away root call dfs ( 1 ) follow algorithm return $$$ a $$$ a dfs order a tree root $$$ 1 $$$ : note may different dfs order a give tree touko like present much decide play ! day follow we d day touko perform procedure : days pass since we d touko somehow forget date we d original label $$$ a $$$ ! fear yuu might get angry touko decide ask <unknown> two piece information use current label good friend need find number days pass since we d original label tree however a chance touko might mess procedures result current label impossible obtain original label ; case please inform touko well first line input contain integer $$$ n $$$ ( $$$ 2 \le n \le 300000 $$$ ) — number nod tree second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le n $$$ $$$ a_i $$$ distinct ) — current label tree next $$$ n - 1 $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ ) describe direct edge $$$ u_i $$$ $$$ v_i $$$ edge form a direct tree root $$$ 1 $$$ current label impossible arrive dfs order print else first line print yes second line print a single integer denote number days since we d third line print $$$ n $$$ number space - separated denote original label tree multiple correct output print mean : allow output pair ( dfs order number days ) get current configuration dfs order provide exactly number days provide follow <unknown> <unknown> first sample test case white label inside node represent index node $$$ i $$$ box orange label represent value $$$ a_i $$$,['data structures'],3100.0
1714/G,give a root tree contain $$$ n $$$ vertices number $$$ 1 $$$ $$$ n $$$ root vertex $$$ 1 $$$ edge two positive integer value thus two positive integers $$$ a_j $$$ $$$ b_j $$$ give edge output $$$ n-1 $$$ number $$$ r_2 r_3 \dots r_n $$$ $$$ r_i $$$ define follow consider path root ( vertex $$$ 1 $$$ ) $$$ i $$$ ( $$$ 2 \le i \le n $$$ ) let sum cost $$$ a_j $$$ along path $$$ a_i $$$ $$$ r_i $$$ equal length maximum prefix path sum $$$ b_j $$$ along prefix exceed $$$ a_i $$$ consider example case : first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test descriptions test case follow description begin a line contain integer $$$ n $$$ ( $$$ 2 \le n \le 2\cdot100000 $$$ ) — number vertices tree follow $$$ n-1 $$$ string contain three number $$$ p_j a_j b_j $$$ ( $$$ 1 \le p_j \le n $$$ ; $$$ 1 \le a_j b_j \le 1000000000 $$$ ) — ancestor vertex $$$ j $$$ first second value edge lead $$$ p_j $$$ $$$ j $$$ value $$$ j $$$ run value $$$ 2 $$$ $$$ n $$$ inclusive guarantee set input data a correct hang tree a root vertex $$$ 1 $$$ guarantee sum $$$ n $$$ input test case exceed $$$ 2\cdot100000 $$$ test case output $$$ n-1 $$$ integer one line : $$$ r_2 r_3 \dots r_n $$$ first example clarify statement second example :,['data structures'],1700.0
242/E,"' ve get array a consist n integers a1 a2 ... , allow perform two operations array : expression mean apply bitwise xor operation number x y. give operation exist modern program languages example language c++ java mark ` ` ^ '' pascal — ` ` xor '' ' ve get a list m operations indicate type task perform give operations sum query print result get first line contain integer n ( 1 ≤ n ≤ 105 ) — size array second line contain space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 106 ) — original array third line contain integer m ( 1 ≤ m ≤ 5·104 ) — number operations array i - th follow m line first contain integer ti ( 1 ≤ ti ≤ 2 ) — type i - th query ti = 1 query sum ti = 2 query change array elements i - th operation type 1 next follow two integers li ri ( 1 ≤ li ≤ ri ≤ n ) i - th operation type 2 next follow three integers li ri xi ( 1 ≤ li ≤ ri ≤ n 1 ≤ xi ≤ 106 ) number line separate single space query type 1 print a single line sum number give segment print answer query order query go input please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier",['data structures'],2000.0
282/E,<unknown> quite weird people problems solutions thoughts <unknown> value <unknown> dish sausages ! bitland a sausage array integers ! a sausage 's deliciousness equal bitwise exclude ( xor operation ) integers sausage one day mr . bitkoch ( local cook ) go close <unknown> bithaval bitaryo famous citizens bitland enter restaurant order a sausage mr . bitkoch one sausage leave decide cut a prefix ( several may zero first array elements ) sausage give bithaval a <unknown> ( several may zero last array elements ) sausage give bitaryo note one piece sausage empty course cut piece must n't intersect ( array element occur piece ) pleasure bithaval bitaryo equal bitwise xor sausages ' deliciousness empty sausage 's deliciousness equal zero find a way cut a piece sausage bithaval bitaryo maximize pleasure <unknown> citizens first line contain integer n ( 1 ≤ n ≤ 105 ) next line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 1012 ) — mr . bitkoch 's sausage please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print a single integer — maximum pleasure bithaval bitaryo get <unknown>,['data structures'],2200.0
1702/G2,a hard version problem difference easy a hard version number query polycarp grow a tree $$$ n $$$ vertices remind a tree $$$ n $$$ vertices undirected connect graph $$$ n $$$ vertices $$$ n-1 $$$ edge contain cycle call a set vertices passable a path tree pass vertex set without pass edge twice path visit vertices ( set ) word a set vertices call passable a simple path pass vertices set ( possibly ) example a tree set $$$ \ { 3 2 5\ } $$$ $$$ \ { 1 5 4\ } $$$ $$$ \ { 1 4\ } $$$ passable $$$ \ { 1 3 5\ } $$$ $$$ \ { 1 2 3 4 5\ } $$$ polycarp ask answer $$$ q $$$ query query a set vertices query need determine whether correspond set vertices passable first line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number vertices follow $$$ n - 1 $$$ line a description tree .. line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) — indices vertices connect edge follow line contain single integer $$$ q $$$ ( $$$ 1 \le q \le 100000 $$$ ) — number query follow $$$ 2 \cdot q $$$ line contain descriptions set first line description contain integer $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) — size set second line description contain $$$ k $$$ distinct integers $$$ p_1 p_2 \dots p_k $$$ ( $$$ 1 \le p_i \le n $$$ ) — indices vertices set guarantee sum $$$ k $$$ value query exceed $$$ 200000 $$$ output $$$ q $$$ line contain answer correspond query answer output ` ` yes '' set passable ` ` '' otherwise output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ),['data structures'],2000.0
1712/F,a tree a connect undirected graph without cycle a weight tree a weight assign edge degree a vertex number edge connect vertex give a weight tree $$$ n $$$ vertices edge a weight $$$ 1 $$$ let $$$ l $$$ set vertices degree equal $$$ 1 $$$ answer $$$ q $$$ independent query $$$ i $$$ -th query : diameter a graph equal $$$ \max\limits _ { 1 \le u < v \le n } { \operatorname { d } ( u v ) } $$$ $$$ \operatorname { d } ( u v ) $$$ length shortest path vertex $$$ u $$$ vertex $$$ v $$$ first line contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 1000000 $$$ ) second line contain $$$ n - 1 $$$ integers $$$ p_2 p_3 \ldots p_n $$$ ( $$$ 1 \le p_i < i $$$ ) indicate edge vertices $$$ i $$$ $$$ p_i $$$ guarantee give edge form a tree third line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 10 $$$ ) fourth line contain $$$ q $$$ integers $$$ x_1 x_2 \ldots <unknown> $$$ ( $$$ 1 \le x_i \le n $$$ ) $$$ x_i $$$ distinct print $$$ q $$$ integers a single line — answer query graph first test add edge :,['data structures'],3200.0
1738/D,give a permutation $$$ a_1 a_2 \dots a_n $$$ integers $$$ 1 $$$ $$$ n $$$ a threshold $$$ k $$$ $$$ 0 \leq k \leq n $$$ compute a sequence $$$ b_1 b_2 \dots b_n $$$ follow every $$$ 1 \leq i \leq n $$$ increase order let $$$ x = a_i $$$ unfortunately sequence $$$ b_1 b_2 \dots b_n $$$ completely compute permutation $$$ a_1 a_2 \dots a_n $$$ threshold $$$ k $$$ discard sequence $$$ b_1 b_2 \dots b_n $$$ task find possible permutation $$$ a_1 a_2 \dots a_n $$$ threshold $$$ k $$$ produce sequence $$$ b_1 b_2 \dots b_n $$$ guarantee exist least one pair permutation $$$ a_1 a_2 \dots a_n $$$ threshold $$$ k $$$ produce sequence $$$ b_1 b_2 \dots b_n $$$ a permutation integers $$$ 1 $$$ $$$ n $$$ a sequence length $$$ n $$$ contain integers $$$ 1 $$$ $$$ n $$$ exactly test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case follow line contain description test case first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) indicate length permutation $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ 0 \leq b_i \leq n+1 $$$ ) indicate elements sequence $$$ b $$$ guarantee exist least one pair permutation $$$ a_1 a_2 \dots a_n $$$ threshold $$$ k $$$ produce sequence $$$ b_1 b_2 \dots b_n $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output threshold $$$ k $$$ ( $$$ 0 \leq k \leq n $$$ ) first line output permutation $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) second line permutation $$$ a_1 a_2 \dots a_n $$$ threshold $$$ k $$$ produce sequence $$$ b_1 b_2 \dots b_n $$$ multiple solutions output first test case permutation $$$ a = [ <unknown> ] $$$ threshold $$$ k = 2 $$$ produce sequence $$$ b $$$ follow second test case permutation $$$ a = [ <unknown> ] $$$ threshold $$$ k = 3 $$$ produce sequence $$$ b $$$ follow third test case permutation $$$ a = [ <unknown> ] $$$ threshold $$$ k = 3 $$$ produce sequence $$$ b $$$ follow,['data structures'],1900.0
739/B,alyona a tree n vertices root tree vertex 1 . vertex alyona write positive integer vertex i write ai moreover girl write a positive integer every edge tree ( possibly different integers different edge ) let 's define dist ( v u ) sum integers write edge simple path v u. vertex v control vertex u ( v ≠ u ) u subtree v dist ( v u ) ≤ au alyona want <unknown> vertex order want know vertex v number vertices u v control u. first line contain single integer n ( 1 ≤ n ≤ 2·105 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — integers write vertices next ( n - 1 ) line contain two integers i - th line contain integers pi wi ( 1 ≤ pi ≤ n 1 ≤ wi ≤ 109 ) — parent ( i + 1 ) -th vertex tree number write edge pi ( i + 1 ) guarantee give graph a tree print n integers — i - th number equal number vertices i - th vertex control example test case vertex 1 control vertex 3 vertex 3 control vertex 5 ( note n't mean vertex 1 control vertex 5 ),['data structures'],1900.0
1797/F,"li hua a tree $$$ n $$$ vertices $$$ n-1 $$$ edge vertices number $$$ 1 $$$ $$$ n $$$ a pair vertices $$$ ( u v ) $$$ ( $$$ u < v $$$ ) consider cute exactly one follow two statements true : $$$ m $$$ operations operation decide integer $$$ k_j $$$ insert a vertex number $$$ n+j $$$ tree connect vertex number $$$ k_j $$$ want calculate number cute pair operations operation suppose li hua please solve problem first line contain single integer $$$ n $$$ ( $$$ 2\le n\le 2\cdot 100000 $$$ ) — number vertices tree next $$$ n-1 $$$ line contain edge tree $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1\le u_i v_i\le n $$$ ; $$$ u_i\ne v_i $$$ ) — correspond edge give edge form a tree next line contain single integer $$$ m $$$ ( $$$ 1\le m\le 2\cdot 100000 $$$ ) — number operations next $$$ m $$$ line contain operations — one operation per line $$$ j $$$ -th operation contain one integer $$$ k_j $$$ ( $$$ 1\le k_j < n+j $$$ ) — a vertex print $$$ m+1 $$$ integers — number cute pair operations operation initial tree show follow picture : $$$ 11 $$$ cute pair — $$$ ( <unknown> ) ( 2,3 ) ( 2,4 ) ( <unknown> ) ( <unknown> ) ( 3,4 ) ( <unknown> ) ( 3,7 ) ( 4,5 ) ( <unknown> ) ( <unknown> ) $$$ similarly count cute pair operation result $$$ 15 $$$ $$$ 19 $$$",['data structures'],3000.0
1806/E,give a tree $$$ n $$$ weight vertices label $$$ 1 $$$ $$$ n $$$ root vertex $$$ 1 $$$ parent vertex $$$ i $$$ $$$ p_i $$$ weight vertex $$$ i $$$ $$$ a_i $$$ convenience define $$$ <unknown> $$$ two vertices $$$ x $$$ $$$ y $$$ depth $$$ ^\dagger $$$ define $$$ f ( x y ) $$$ follow : process $$$ q $$$ query $$$ i $$$ -th query give two integers $$$ x_i $$$ $$$ y_i $$$ need calculate $$$ f ( x_i y_i ) $$$ $$$ ^\dagger $$$ depth vertex $$$ v $$$ number edge unique simple path root tree vertex $$$ v $$$ first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \le n \le 100000 $$$ ; $$$ 1 \le q \le 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 100000 $$$ ) third line contain $$$ n-1 $$$ integers $$$ p_2 \ldots p_n $$$ ( $$$ 1 \le p_i < i $$$ ) next $$$ q $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1\le x_i <unknown> n $$$ ) guarantee $$$ x_i $$$ $$$ y_i $$$ depth output $$$ q $$$ line $$$ i $$$ -th line contain a single integer value $$$ f ( x_i y_i ) $$$ consider first example : first query answer $$$ <unknown> <unknown> <unknown> a_2+a_1\cdot <unknown> + 4 + 25 + <unknown> $$$ second query answer $$$ <unknown> <unknown> a_2+a_1\cdot <unknown> + 25 + <unknown> $$$,['data structures'],2200.0
786/D,rick love unity mr . meeseeks also love unity rick mr . meeseeks ` ` love rival '' unity love rap decide compete a rap game ( battle ) order choose best rick <unknown> instead 's gon na make verse run original algorithm <unknown> ` ` rap god '' song algorithm a little bite complicate 's make a tree n vertices number 1 n 's a lowercase english letter write edge denote str ( a b ) string make write character edge shortest path a b one one ( a string length equal distance a b ) note str ( a b ) reverse str ( b a ) str ( a a ) empty order make best verse need answer query 's a computer scientist able answer query ask help query characterize two vertices x y ( x ≠ y ) answer query number vertices like z z ≠ x z ≠ y str ( x y ) lexicographically larger str ( x z ) string x = x1x2 ... x|x| lexicographically larger string y = y1y2 ... y|y| either |x| > |y| x1 = y1 x2 = y2 ... x|y| = y|y| exist number r ( r < |x| r < |y| ) x1 = y1 x2 = y2 ... xr = yr xr + 1 > yr + 1 . character compare like ascii cod ( <unknown> order ) help rick get girl ( whatever <unknown> unity ) first line input contain two integers n q ( 2 ≤ n ≤ 20000 1 ≤ q ≤ 20000 ) — number vertices tree number query respectively next n - 1 line contain edge line contain two integers v u ( endpoints edge ) follow english lowercase letter c ( 1 ≤ v u ≤ n v ≠ u ) next q line contain query line contain two integers x y ( 1 ≤ x y ≤ n x ≠ y ) print answer query one line 's tree first sample testcase : 's tree second sample testcase : test : first query third query answer,['data structures'],3400.0
797/D,let t arbitrary binary tree — tree every vertex two children give tree root exist one vertex n't a parent — 's root a tree every vertex integer number write follow algorithm run every value tree t : pseudo - code describe algorithm : describe algorithm work correctly tree binary search tree ( i.e node value leave subtree less value node value right subtree greater value node ) return invalid result tree a binary search tree since give tree necessarily a binary search tree number find way task calculate many time search fail run every value tree tree multiple vertices value run algorithm every one separately first line contain integer number n ( 1 ≤ n ≤ 105 ) — number vertices tree next n line contain 3 number v l r ( 0 ≤ v ≤ 109 ) — value current vertex index leave child vertex index right child vertex respectively child n't exist number - 1 set instead note different vertices tree may contain value print number time search algorithm fail example root tree vertex 2 . search number 5 15 return fail first step algorithm choose subtree n't contain number look,['data structures'],2100.0
1749/F,give a tree consist $$$ n $$$ vertices initially vertex a value $$$ 0 $$$ need perform $$$ m $$$ query two type : distance two vertices $$$ x $$$ $$$ y $$$ equal number edge path $$$ x $$$ $$$ y $$$ example distance $$$ x $$$ $$$ x $$$ equal $$$ 0 $$$ distance vertex $$$ v $$$ path $$$ x $$$ $$$ y $$$ equal minimum among distance $$$ v $$$ vertex path $$$ x $$$ $$$ y $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number vertices tree next $$$ n - 1 $$$ line contain edge tree — one per line line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ; $$$ u \neq v $$$ ) represent one edge tree 's guarantee give edge form a tree next line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 200000 $$$ ) — number query next $$$ m $$$ line contain query — one per line query one follow two type : additional constraint input : least one query first type query first type print value correspond vertex tree first example :,['data structures'],2800.0
860/E,"arkady word a large company n employees work a system a strict hierarchy namely employee exception ceo exactly one immediate manager ceo a manager ( a chain immediate managers ) employees employee integer rank ceo rank equal 1 employee rank equal rank immediate manager plus 1 . arkady a good post company however feel nobody company 's structure a lot people replace introduce value replaceability consider employee a employee b latter manager a ( necessarily immediate ) replaceability r ( a b ) a respect b number subordinate ( necessarily immediate ) manager b whose rank greater rank a. apart replaceability arkady introduce value negligibility negligibility <unknown> employee a equal sum <unknown> respect managers i.e , sum take managers b. arkady interest negligibility also negligibility employees company find negligibility employee arkady first line contain single integer n ( 1 ≤ n ≤ 5·105 ) — number employees company second line contain n integers p1 p2 ... pn ( 0 ≤ pi ≤ n ) pi = 0 i - th employee ceo otherwise pi equal i d immediate manager employee i d i. employees number 1 n. guarantee exactly one 0 among value also ceo a manager ( necessarily immediate ) employees print n integers — <unknown> employees order ids : z1 z2 ... zn consider first example :",['data structures'],2700.0
877/D,"olya love energy drink love much room full empty can energy drink formally room represent a field n × m cells cell empty litter can olya drink a lot energy drink run k meter per second second choose one four directions ( , leave right ) run 1 k meter direction course run empty cells olya need get cell ( x1 y1 ) cell ( x2 y2 ) many second take move optimally ? 's guarantee cells ( x1 y1 ) ( x2 y2 ) empty cells coincide first line contain three integers n m k ( 1 ≤ n m k ≤ 1000 ) — size room olya 's speed n line follow contain m character i - th contain j - th position ` ` # '' cell ( i j ) litter can ` ` . '' otherwise last line contain four integers x1 y1 x2 y2 ( 1 ≤ x1 x2 ≤ n 1 ≤ y1 y2 ≤ m ) — coordinate first last cells print a single integer — minimum time take olya get ( x1 y1 ) ( x2 y2 ) 's impossible get ( x1 y1 ) ( x2 y2 ) print -1 . first sample olya run 3 meter right first second 2 meter second second 3 meter leave third second second sample olya run right 3 second 2 second leave 3 second olya recommend drink energy drink <unknown> believe bad",['data structures'],2100.0
601/D,give a tree t n vertices ( number 1 n ) a letter vertex tree root vertex 1 . let 's look subtree tv vertex v. possible read a string along simple path start v end vertex tv ( possibly v ) let 's denote number distinct string read way also 's a number cv assign vertex v. interest vertices maximum value compute two statistics : maximum value number vertices v maximum first line input contain one integer n ( 1 ≤ n ≤ 300 000 ) — number vertices tree second line contain n space - separated integers ci ( 0 ≤ ci ≤ 109 ) third line contain a string s consist n lowercase english letter — i - th character string letter vertex i. follow n - 1 line describe tree t. contain two space - separated integers u v ( 1 ≤ u v ≤ n ) indicate edge vertices u v. 's guarantee input describe a tree print two line first line print 1 ≤ i ≤ n. second line print number vertices v first sample tree look like : set string read individual vertices : finally value : second sample value ( 5 4 2 1 1 1 ) distinct string read t2 ; note read vertices 3 4,['data structures'],2400.0
609/E,connect undirected weight graph without self - loops multiple edge give graph contain n vertices m edge edge ( u v ) find minimal possible weight span tree contain edge ( u v ) weight span tree sum weight edge include span tree first line contain two integers n m ( 1 ≤ n ≤ 2·105 n - 1 ≤ m ≤ 2·105 ) — number vertices edge graph next m line contain three integers ui vi wi ( 1 ≤ ui vi ≤ n ui ≠ vi 1 ≤ wi ≤ 109 ) — endpoints i - th edge weight print m line i - th line contain minimal possible weight span tree contain i - th edge edge number 1 m order appear input,['data structures'],2100.0
838/B,give a direct weight graph n nod 2n - 2 edge nod label 1 n edge label 1 2n - 2 . graph 's edge split two part give q query two type <unknown> query print shortest path lengths first line input contain two integers n q ( 2 ≤ n q ≤ 200 000 ) number nod number query respectively next 2n - 2 integers contain 3 integers ai bi ci denote a direct edge node ai node bi weight ci first n - 1 line describe a root span tree point away node 1 last n - 1 line bi = 1 . specifically next q line contain 3 integers describe a query format describe statement edge weight 1 106 . type 2 query print length shortest path line,['data structures'],2100.0
639/F,"limak a smart brown bear love chemistry <unknown> transform elements bearland ( limak 's home ) n elements number 1 n. also special machine transform elements machine describe two integers ai bi represent two elements necessarily distinct one use a machine either transform element ai bi transform bi ai machine bearland n't <unknown> use possible ai = bi many machine pair ai bi radewoosh limak 's biggest enemy rival want test limak chemistry meet tomorrow bring machine limak m machine n't know much enemy agree radewoosh choose two distinct elements let 's denote x y. limak allow use radewoosh 's machine may use zero ( maybe even ) machine achieve goal machine limak start element x task first get element y get element x — say succeed radewoosh would agree limak know chemistry ( radewoosh would go away ) radewoosh like particular non - empty set favorite elements choose x y set limak n't know exactly elements set also n't know machine radewoosh limak hear q gossip ( query ) though consist radewoosh 's machine favorite elements gossip limak wonder would able succeed tomorrow every pair x y choose set favorite elements yes print ` ` yes '' ( without quote ) exist a pair ( x y ) give set limak would n't able succeed print ` ` '' ( without quote ) first line contain three integers n m q ( 1 ≤ n q ≤ 300 000 0 ≤ m ≤ 300 000 ) — number elements number limak 's machine number gossip respectively next m line contain two integers ai bi ( 1 ≤ ai bi ≤ n ) describe one limak 's machine , description q gossip follow first line description i - th gossip contain two integers ni mi ( 1 ≤ ni ≤ 300 000 0 ≤ mi ≤ 300 000 ) second line contain ni distinct integers xi 1 xi 2 ... xi ni ( 1 ≤ xi j ≤ n ) — radewoosh 's favorite elements i - th gossip note ni = 1 allow case pair distinct elements limak automatically win ( answer ` ` yes '' ) mi line follow contain two integers ai j bi j ( 1 ≤ ai j bi j ) describe one radewoosh 's machine i - th gossip sum ni gossip wo n't exceed 300 000 . also sum mi gossip wo n't exceed 300 000 . important : want process gossip online order know elements radewoosh 's favorite set elements machine transform number denote input use follow function : r initially equal 0 increase number query time answer ` ` yes '' query number start 1 order appear input print q line i - th contain ` ` yes '' ( without quote ) i - th gossip pair elements x y ( set xi 1 xi 2 ... xi ni ) limak able succeed otherwise print ` ` '' ( without quote ) let look first sample : first gossip radewoosh 's favorite set { 4 2 } machine limak <unknown> element 4 2 ( half a task complete ) 2 3 3 4 . answer ` ` yes '' r increase 1 . second gossip set input denote { 6 2 } machine ( 3 4 ) r equal 1 set { 1 3 } machine ( 4 5 ) answer ` ` '' r n't change third gossip set { 6 4 3 } machine ( 2 5 ) ( 4 6 ) decipher { 1 5 4 } ( 3 6 ) ( 5 1 ) consider radewoosh 's choices : limak able execute task answer ` ` yes '' r increase 3 ( 's equal 4 ) last gossip { 1 2 } ( 1 2 ) decipher { 5 6 } ( 5 6 ) 2 machine ( 5 6 ) limak able execute task",['data structures'],3300.0
827/D,give a connect weight graph n vertices m edge graph n't contain loop multiple edge consider edge i d i. let 's determine edge maximum integer weight give contain minimum span tree graph n't change weight determine maximum weight describe edge calculate answer edge independently mean ca n't two edge change weight time first line contain two integers n m ( 2 ≤ n ≤ 2·105 n - 1 ≤ m ≤ 2·105 ) n m number vertices number edge graph respectively next m line contain three integers u v c ( 1 ≤ v u ≤ n v ≠ u 1 ≤ c ≤ 109 ) mean edge vertices u v weight c. print answer edge order edge give input edge contain every minimum span tree weight print -1 answer,['data structures'],2700.0
741/D,case somebody miss : wonderful girls arpa ’ s land arpa a root tree ( connect acyclic graph ) consist n vertices vertices number 1 n vertex 1 root a letter write edge tree mehrdad a fan dokhtar - kosh things call a string dokhtar - kosh shuffle character string become palindrome ask arpa vertex v length longest simple path subtree v form a dokhtar - kosh string first line contain integer n ( 1 ≤ n ≤ 5·105 ) — number vertices tree ( n - 1 ) line follow i - th contain integer pi + 1 a letter ci + 1 ( 1 ≤ pi + 1 ≤ i ci + 1 lowercase english letter a v inclusively ) mean edge nod pi + 1 i + 1 a letter ci + 1 write edge print n integers i - th length longest simple path subtree i - th vertex form a dokhtar - kosh string,['data structures'],2900.0
1178/G,give a root tree $$$ n $$$ vertices vertices number $$$ 1 $$$ $$$ n $$$ ; root vertex number $$$ 1 $$$ vertex two integers associate : $$$ a_i $$$ $$$ b_i $$$ denote set ancestors $$$ v $$$ ( include $$$ v $$$ ) $$$ r ( v ) $$$ awesomeness a vertex $$$ v $$$ define $$$ $$$ <unknown> \sum _ { w \in r ( v ) } <unknown> \cdot <unknown> _ { w \in r ( v ) } <unknown> $$$ $$$ $$$ |x| $$$ denote absolute value $$$ x $$$ process $$$ q $$$ query one follow form : first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \leq n \leq 2\cdot 100000 1 \leq q \leq 100000 $$$ ) — number vertices tree number query respectively second line contain $$$ n - 1 $$$ integers $$$ p_2 p_3 \dots p_n $$$ ( $$$ 1 \leq p_i < i $$$ ) $$$ p_i $$$ mean edge vertices $$$ i $$$ $$$ p_i $$$ third line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ -5000 \leq a_i \leq 5000 $$$ ) initial value $$$ a_i $$$ vertex fourth line contain $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ -5000 \leq b_i \leq 5000 $$$ ) value $$$ b_i $$$ vertex next $$$ q $$$ line describe a query one follow form : query second type print a single line maximum awesomeness respective subtree initial awesomeness vertices $$$ [ 100 91 57 64 57 ] $$$ awesome vertex subtree vertex $$$ 1 $$$ ( first query ) $$$ 1 $$$ awesome vertex subtree vertex $$$ 2 $$$ ( second query ) $$$ 2 $$$ first update ( third query ) awesomeness change $$$ [ 100 <unknown> 57 160 57 ] $$$ thus awesome vertex whole tree ( fourth query ) $$$ 2 $$$ second update ( fifth query ) awesomeness become $$$ [ 100 <unknown> 57 <unknown> <unknown> ] $$$ hence awesome vertex ( sixth query ) $$$ 4 $$$,['data structures'],3000.0
1209/F,koala land consist $$$ m $$$ bidirectional roads connect $$$ n $$$ cities roads number $$$ 1 $$$ $$$ m $$$ order input guarantee one reach city every city koala start travel city $$$ 1 $$$ whenever travel a road write number notebook n't put space number get concatenate a single number embark trip koala curious result number possible <unknown> possible destination smallest number could write ? since number may quite large print remainder modulo $$$ 1000000000 + 7 $$$ please note need compute remainder minimum possible number minimum possible remainder first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 100000 n - 1 \le m \le 100000 $$$ ) number cities number roads respectively $$$ i $$$ -th follow $$$ m $$$ line contain integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ ) represent a bidirectional road cities $$$ x_i $$$ $$$ y_i $$$ guarantee pair cities one road connect one reach city every city print $$$ n - 1 $$$ integers answer every city except first city $$$ i $$$ -th integer equal smallest number could write destination $$$ i+1 $$$ since number may large output remainder modulo $$$ 1000000000 + 7 $$$,['data structures'],2600.0
901/C,give undirected graph n vertices edge - simple cycle even length word cycle even length pass edge let 's enumerate vertices 1 n. answer q query query describe a segment vertices [ l ; r ] count number subsegments [ x ; y ] ( l ≤ x ≤ y ≤ r ) delete vertices except segment vertices [ x ; y ] ( include x y ) edge result graph bipartite first line contain two integers n m ( 1 ≤ n ≤ 3·105 1 ≤ m ≤ 3·105 ) — number vertices number edge graph next m line describe edge graph i - th line contain two integers ai bi ( 1 ≤ ai bi ≤ n ; ai ≠ bi ) denote edge vertices ai bi guarantee graph contain edge - simple cycle even length next line contain a single integer q ( 1 ≤ q ≤ 3·105 ) — number query next q line contain query i - th line contain two integers li ri ( 1 ≤ li ≤ ri ≤ n ) — query parameters print q number new line : i - th number subsegments [ x ; y ] ( li ≤ x ≤ y ≤ ri ) graph include vertices segment [ x ; y ] edge bipartite first example show picture : first query subsegments [ 1 ; 3 ] except segment suitable first query subsegments [ 4 ; 6 ] except segment suitable third query subsegments [ 1 ; 6 ] suitable except [ 1 ; 3 ] [ 1 ; 4 ] [ 1 ; 5 ] [ 1 ; 6 ] [ 2 ; 6 ] [ 3 ; 6 ] [ 4 ; 6 ] second example show picture :,['data structures'],2300.0
1304/E,gildong hike a mountain walk millions tree inspire suddenly come interest idea tree data structure : add another edge a tree ? find tree - like graph call 1 - trees since gildong bore solve many tree problems want see similar techniques tree use 1 - trees well instead solve 's go test provide query 1 - trees first 'll provide a tree ( 1 - tree ) $$$ n $$$ vertices ask $$$ q $$$ query query contain $$$ 5 $$$ integers : $$$ x $$$ $$$ y $$$ $$$ a $$$ $$$ b $$$ $$$ k $$$ mean 're ask determine exist a path vertex $$$ a $$$ $$$ b $$$ contain exactly $$$ k $$$ edge add a bidirectional edge vertices $$$ x $$$ $$$ y $$$ a path contain vertices edge multiple time query independent ; i.e add edge a query remove next query first line contain integer $$$ n $$$ ( $$$ 3 \le n \le 100000 $$$ ) number vertices tree next $$$ n-1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) mean edge vertex $$$ u $$$ $$$ v $$$ edge bidirectional distinct next line contain integer $$$ q $$$ ( $$$ 1 \le q \le 100000 $$$ ) number query gildong want ask next $$$ q $$$ line contain five integers $$$ x $$$ $$$ y $$$ $$$ a $$$ $$$ b $$$ $$$ k $$$ ( $$$ 1 \le x y a b \le n $$$ $$$ x \ne y $$$ $$$ 1 \le k \le 1000000000 $$$ ) – integers explain description guarantee edge $$$ x $$$ $$$ y $$$ exist original tree query print ` ` yes '' exist a path contain exactly $$$ k $$$ edge vertex $$$ a $$$ $$$ b $$$ add edge vertices $$$ x $$$ $$$ y $$$ otherwise print ` ` '' print letter case ( upper lower ) image describe tree ( circle <unknown> line ) add edge query ( dot line ) possible paths query ` ` yes '' answer :,['data structures'],2000.0
932/B,let us define two function f g positive integer number need process q query query give three integers l r k. need print number integers x l r inclusive g ( x ) = k. first line input contain integer q ( 1 ≤ q ≤ 2 × 105 ) represent number query q line follow contain 3 integers l r k ( 1 ≤ l ≤ r ≤ 106 1 ≤ k ≤ 9 ) query print a single line contain answer query first example :,['data structures'],1300.0
920/E,give undirected graph consist n vertices edge instead give edge exist graph give m unordered pair ( x y ) edge x y pair vertices list input edge vertices find number connect components graph size component a connect component a set vertices x every two vertices set exist least one path graph connect vertices add vertex x violate rule first line contain two integers n m ( 1 ≤ n ≤ 200000 ) m line follow contain a pair integers x y ( 1 ≤ x y ≤ n x ≠ y ) denote edge x y. pair list ; ( x y ) ( y x ) consider ( never list test ) pair vertices list input exist edge vertices firstly print k — number connect components graph print k integers — size components output integers non - descending order,['data structures'],2100.0
1458/E,"<unknown> mobile game ` ` nim '' blow decide make a <unknown> call ` ` nim 2 '' game <unknown> trust nim game formula add much <unknown> second heap ! game two heap contain a non - negative number stone two players make move turn turn a player take positive number stone either one heap a player unable move lose game make game easier <unknown> ' ve introduce developer shortcuts $$$ n $$$ shortcut position $$$ ( x_1 y_1 ) \ldots ( x_n y_n ) $$$ change game follow : suppose a player 's turn first second heap contain $$$ x $$$ $$$ y $$$ stone respectively pair $$$ ( x y ) $$$ equal one pair $$$ ( x_i y_i ) $$$ player move lose instantly otherwise able make move normal note explanation two heap pair order , $$$ x $$$ must refer size first heap $$$ y $$$ must refer size second heap game release follow much <unknown> next thing know developer shortcuts make way next official update game ! players <unknown> ai opponent become <unknown> certain stag game write a program figure give initial position start player assume players act optimally first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 100000 $$$ ) — number shortcut position number initial position need evaluate follow $$$ n $$$ line describe shortcut position $$$ i $$$ -th line contain two integers $$$ x_i y_i $$$ ( $$$ 0 \leq x_i y_i \leq 1000000000 $$$ ) guarantee shortcut position distinct follow $$$ m $$$ line describe initial position $$$ i $$$ -th line contain two integers $$$ a_i b_i $$$ ( $$$ 0 \leq a_i b_i \leq 1000000000 $$$ ) — number stone first second heap respectively guarantee initial position distinct however initial position necessarily distinct shortcut position initial position a separate line print ` ` win '' start player able win position ` ` lose '' otherwise",['data structures'],3100.0
1195/E,"seryozha conduct a course dedicate build a map heights <unknown> recreation center lay a rectangle grid size $$$ n \times m $$$ cells a map ( row grid number $$$ 1 $$$ $$$ n $$$ north south columns number $$$ 1 $$$ $$$ m $$$ west east ) measure average height cell <unknown> sea level obtain a matrix heights size $$$ n \times m $$$ cell $$$ ( i j ) $$$ lie intersection $$$ i $$$ -th row $$$ j $$$ -th column height $$$ h _ { i j } $$$ seryozha go look result work <unknown> screen seryozha 's laptop fit a subrectangle size $$$ a \times b $$$ matrix heights ( $$$ 1 \le a \le n $$$ $$$ 1 \le b \le m $$$ ) seryozha try decide weather affect recreation center — example rain <unknown> gather , go find cell minimum height among cells show screen laptop help seryozha calculate sum heights cells possible <unknown> see screen word calculate sum minimum heights <unknown> size $$$ a \times b $$$ top leave corner $$$ ( i j ) $$$ $$$ 1 \le i \le n - a + 1 $$$ $$$ 1 \le j \le m - b + 1 $$$ consider sequence $$$ g_i = ( g _ { i - 1 } \cdot x + y ) \bmod z $$$ give integers $$$ g_0 $$$ $$$ x $$$ $$$ y $$$ $$$ z $$$ <unknown> coincidence $$$ h _ { i j } = g _ { ( i - 1 ) \cdot m + j - 1 } $$$ ( $$$ ( i - 1 ) \cdot m + j - 1 $$$ index ) first line input contain four integers $$$ n $$$ $$$ m $$$ $$$ a $$$ $$$ b $$$ ( $$$ 1 \le n m \le <unknown> $$$ $$$ 1 \le a \le n $$$ $$$ 1 \le b \le m $$$ ) — number row columns matrix seryozha number row columns show screen laptop respectively second line input contain four integers $$$ g_0 $$$ $$$ x $$$ $$$ y $$$ $$$ z $$$ ( $$$ 0 \le g_0 x y < z \le 1000000000 $$$ ) print a single integer — answer problem matrix first example :",['data structures'],2100.0
514/D,"army n droids line one row droid describe m integers a1 a2 ... , ai number detail i - th type droid 's mechanism r2 - d2 want destroy sequence consecutive droids maximum length m weapons i - th weapon affect droids army destroy one detail i - th type ( droid n't detail type nothing happen ) a droid consider destroy detail destroy r2 - d2 make k shots many shots weapon type r2 - d2 make destroy sequence consecutive droids maximum length ? first line contain three integers n m k ( 1 ≤ n ≤ 105 1 ≤ m ≤ 5 0 ≤ k ≤ 109 ) — number droids number detail type number available shots respectively next n line follow describe droids line contain m integers a1 a2 ... ( 0 ≤ ai ≤ 108 ) ai number detail i - th type respective robot print m space - separated integers i - th number number shots weapon i - th type robot make destroy subsequence consecutive droids maximum length multiple optimal solutions print necessary make exactly k shots number shots less first test second third fourth droids destroy second test first second droids destroy",['data structures'],2000.0
212/D,vasya <unknown> <unknown> separate wood a fence fence consist n plank put a line fence close a circle plank number leave right 1 n i - th plank height ai plank width lower edge plank locate grind level recently a local newspaper ` ` malevich life '' write <unknown> way decorate a fence summer draw a fuchsia - colored rectangle lower side rectangle must locate lower edge fence vasya <unknown> idea ! immediately buy fuchsia - colored paint begin decide kind rectangle paint vasya sure rectangle cover k consecutive plank word paint plank number x x + 1 ... x + k - 1 x ( 1 ≤ x ≤ n - k + 1 ) want paint rectangle maximal area rectangle height equal min ai x ≤ i ≤ x + k - 1 x number first color plank vasya already make mind rectangle width equal one number sequence k1 k2 ... km ki want know expect height paint rectangle provide select x fence uniformly among n - ki + 1 possible value help find expect heights first line contain a single integer n ( 1 ≤ n ≤ 106 ) — number plank fence second line contain a sequence integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) ai height i - th plank fence third line contain integer m ( 1 ≤ m ≤ 106 ) next line contain m space - separated integers k1 k2 ... km ( 1 ≤ ki ≤ n ) ki width desire fuchsia - colored rectangle plank print m <unknown> - separated real number i - th number equal expect value rectangle height width plank equal ki value consider correct absolute relative error n't exceed 10 - 9 . let 's consider first sample test,['data structures'],2500.0
616/D,array a n integers give let 's call sequence one consecutive elements a segment also let 's call segment k - good contain k different value find longest k - good segment input / output reach huge size recommend use fast input / output methods : example prefer use scanf / printf instead cin / cout c++ prefer use bufferedreader / printwriter instead scanner / system.out java first line contain two integers n k ( 1 ≤ k ≤ n ≤ 5·105 ) — number elements a parameter k. second line contain n integers ai ( 0 ≤ ai ≤ 106 ) — elements array a. print two integers l r ( 1 ≤ l ≤ r ≤ n ) — index leave index right end k - good longest segment several longest segment print elements a number 1 n leave right,['data structures'],1600.0
689/D,mike ! mike old childhood rival opposite everything except program today a problem solve together ( ) — know ? every one integer sequence a b length n. give a query form pair integers ( l r ) mike instantly tell value ! mike instantly tell value suppose a robot ( ! ) ask possible different query pair integers ( l r ) ( 1 ≤ l ≤ r ≤ n ) ( make exactly n ( n + 1 ) / 2 query ) count many time answer coincide thus many pair satisfy many occasion robot count ? first line contain integer n ( 1 ≤ n ≤ 200 000 ) second line contain n integer number a1 a2 ... ( - 109 ≤ ai ≤ 109 ) — sequence a. third line contain n integer number b1 b2 ... bn ( - 109 ≤ bi ≤ 109 ) — sequence b. print integer number — number occasion robot count thus many pair satisfy occasion first sample case <unknown> = 4 r = 4 since max { 2 } = min { 2 } <unknown> = 4 r = 5 since max { 2 1 } = min { 2 3 } occasion second sample case since mike answer 3 query pair ! mike always answer 1,['data structures'],2100.0
713/D,owl sonya give a huge lake puzzle size n × m hedgehog filya a birthday present friends immediately start assemble puzzle part turn empty — picture part picture denote 1 empty part denote 0 . row puzzle number top bottom integers 1 n columns number leave right integers 1 m. animals decide complete picture play might even fun ! owl hedgehog ask query query provide four integers x1 y1 x2 y2 define rectangle ( x1 y1 ) stand coordinate leave cell rectangle ( x2 y2 ) stand coordinate bottom right cell answer query size maximum square consist picture part ( part denote 1 ) locate fully inside query rectangle help sonya filya answer t query first line input contain two integers n m ( 1 ≤ n m ≤ 1000 ) — size puzzle follow n line contain m integers aij equal 1 correspond cell contain a picture 0 's empty next line contain integer t ( 1 ≤ t ≤ 1 000 000 ) — number query follow t line query ' descriptions contain four integers x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ m ) — coordinate leave bottom right cells query rectangle print t line i - th contain maximum size square consist 1 - s lie fully inside query rectangle,['data structures'],2700.0
749/D,n people take part auction today rule auction classical n bid make though 's guarantee different people might happen people make bid bid define two integers ( ai bi ) ai index person make bid bi size bid give chronological order mean bi < bi + 1 i < n. moreover participant never make two bid a row ( one update bid ) i.e ai ≠ ai + 1 i < n. curious follow question : ( bid ) win auction participants absent ? consider someone absent bid remove new bid add note <unknown> <unknown> participants happen remain participants make a bid twice ( time ) a row first bid count better understand take a look sample several question mind compute answer first line input contain integer n ( 1 ≤ n ≤ 200 000 ) — number participants bid follow n line contain two integers ai bi ( 1 ≤ ai ≤ n 1 ≤ bi ≤ 109 bi < bi + 1 ) — number participant make i - th bid size bid next line contain integer q ( 1 ≤ q ≤ 200 000 ) — number question mind next q line contain integer k ( 1 ≤ k ≤ n ) follow k integers lj ( 1 ≤ lj ≤ n ) — number people come question indices <unknown> lj value different a single question 's guarantee sum k question wo n't exceed 200 000 . question print two integer — index winner size win bid winner ( remain bid ) print two zero consider first sample :,['data structures'],2000.0
387/E,"george a cat love play much vitaly put n card a row front george card one integer write card distinct number write let 's number card leave right integers 1 n. i - th card leave contain number pi ( 1 ≤ pi ≤ n ) vitaly want row exactly k card leave also want i - th card leave number bi write vitaly give a task george get require sequence card use remove operation n - k time one remove operation george choose w ( 1 ≤ w ; w greater current number card row ) contiguous card ( contiguous subsegment card ) let 's denote number write card x1 x2 ... <unknown> ( leave right ) , george remove card xi xi ≤ xj j ( 1 ≤ j ≤ w ) describe operation george get w piece sausage george wonder : maximum number piece sausage get total reach goal act optimally well ? help george find answer question ! first line contain integers n k ( 1 ≤ k ≤ n ≤ 106 ) — initial final number card second line contain n distinct space - separated integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) — initial row card third line contain k space - separated integers b1 b2 ... bk — row card need get guarantee 's possible obtain give row use remove operation n - k time print a single integer — maximum number piece sausage george get act optimally well",['data structures'],2200.0
1684/F,give array $$$ a $$$ $$$ n $$$ integers also give $$$ m $$$ subsegments array leave right endpoints $$$ j $$$ -th segment $$$ l_j $$$ $$$ r_j $$$ respectively allow make one operation operation choose subsegment array $$$ a $$$ replace value segment integer ( also allow keep elements ) apply operation give $$$ m $$$ segment elements segment distinct formally $$$ 1 \le j \le m $$$ elements $$$ a _ { l _ { j } } a _ { l _ { j } +1 } \ldots a _ { r _ { j } -1 } a _ { r _ { j } } $$$ distinct n't want use operation a big segment find smallest length a segment apply operation segment meet <unknown> - <unknown> condition need use operation answer $$$ 0 $$$ input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200000 $$$ ) — size array number segment respectively next line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements $$$ a $$$ next $$$ m $$$ line contain two integers $$$ l_j $$$ $$$ r_j $$$ ( $$$ 1 \le l_j \le r_j \le n $$$ ) — leave right endpoints $$$ j $$$ -th segment 's guarantee sum $$$ n $$$ sum $$$ m $$$ test case exceed $$$ 200000 $$$ test case output a single integer — smallest length a segment apply operation make elements give segment distinct need use operation output $$$ 0 $$$ first test case perform operation segment $$$ [ 1 2 ] $$$ make $$$ a = [ 5 6 2 1 3 3 5 ] $$$ elements segment distinct way give segment elements distinct also impossible change single integer make elements distinct segment answer $$$ 2 $$$ second test case elements segment already distinct perform operation third test case replace first $$$ 5 $$$ $$$ 1 $$$ way get $$$ [ 1 7 5 6 ] $$$ elements distinct give segment elements distinct,['data structures'],2600.0
6/E,several days leave <unknown> birthday a famous berland 's writer berlbury connection local library decide make exposition work famous science - <unknown> writer decide well necessary include exposition book publish a particular time period obvious book differ much size visitors like organizers come opinion difference highest lowest book exposition k millimeters library n volumes book berlbury arrange chronological order <unknown> height book millimeters know hi berlbury highly respect city organizers want include exposition many book possible find periods creative work manage cover ask help organizers cope hard task first line input data contain two integer number separate a space n ( 1 ≤ n ≤ 105 ) k ( 0 ≤ k ≤ 106 ) — amount book berlbury library maximum allow height difference lowest highest book second line contain n integer number separate a space number hi ( 1 ≤ hi ≤ 106 ) height i - th book millimeters first line output data print two number a b ( separate a space ) a maximum amount book organizers include exposition b — amount time periods berlbury publish a book height difference lowest highest among book k <unknown> follow b line print two integer number separate a space — index first last volumes require time periods berlbury 's creative work,['data structures'],1900.0
571/D,<unknown> city a campus consist n student dormitories n universities n military offices initially i - th dormitory belong i - th university assign i - th military office life go campus continuously go change change four type : thus moment time dormitory assign exactly one university one military office initially dormitory empty task process change take place campus answer query many people currently live dormitory qj first line contain two integers n m ( 1 ≤ n m ≤ 5·105 ) — number dormitories number query respectively next m line contain query give one follow format : i - th line print answer i - th query ask number people dormitory consider first sample test :,['data structures'],3100.0
185/E,"imagine cartesian coordinate system k different point contain subway station one get subway station one instantly , duration transfer two subway station consider equal zero allow travel subway station , allow leave subway somewhere middle path in - <unknown> station n dwarves represent coordinate plane dwarves want come together watch a soap <unknown> integer point plane , choose gather point start move towards simultaneously one second a dwarf move point ( x y ) one follow point : ( x - 1 y ) ( x + 1 y ) ( x y - 1 ) ( x y + 1 ) besides dwarves use subway many time want ( subway transfer dwarves instantly ) dwarves interfere move ( dwarves move simultaneously independently ) help dwarves find minimum time need gather one point first line contain two integers n k ( 1 ≤ n ≤ 105 ; 0 ≤ k ≤ 105 ) — number dwarves number subway station correspondingly next n line contain coordinate dwarves i - th line contain two space - separated integers xi yi ( |xi| |yi| ≤ 108 ) — coordinate i - th dwarf guarantee dwarves locate different point next k line contain coordinate subway station t - th line contain two space - separated integers xt yt ( <unknown> <unknown> ≤ 108 ) — coordinate t - th subway station guarantee subway station locate different point print a single number — minimum time dwarves gather together one point watch soap",['data structures'],3000.0
191/E,dark time berland <unknown> <unknown> fund a neighbor state organize a demonstration berland capital bertown work intelligence know demonstrations plan last k days fortunately berland a special police unit save country exactly n soldier number 1 n. berland general commander detachment must schedule detachment 's work difficult k days days general must send a certain number police officer disperse <unknown> since detachment large general smart select a set soldier number l r inclusive l r select arbitrarily general exactly two problems first send group twice — soldier get bore <unknown> second soldier equally reliable every soldier a reliability ai reliability detachment count sum reliabilities soldier reliability a single soldier negative include detachment spoil things general distinguish great greed <unknown> day send <unknown> reliable group soldier possible ( group send yet ) berland government decide know would minimum reliability detachment send disperse demonstrations k days general cope a difficult task help <unknown> front <unknown> ! first line contain two integers n k — number soldier detachment number time somebody go duty second line contain n space - separated integers ai absolute value n't exceed 109 — soldier ' reliabilities please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print a single number — seek minimum reliability group go duty k days,['data structures'],2200.0
367/B,"sereja two sequence a b number p. sequence a consist n integers a1 a2 ... , similarly sequence b consist m integers b1 b2 ... bm usual sereja study sequence today want find number position q ( q + ( m - 1 ) · p ≤ n ; q ≥ 1 ) sequence b obtain sequence aq aq + p aq + <unknown> ... aq + ( m - 1 ) p rearrange elements sereja need rush gym ask find describe position q. first line contain three integers n m p ( 1 ≤ n m ≤ 2·105 1 ≤ p ≤ 2·105 ) next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) next line contain m integers b1 b2 ... bm ( 1 ≤ bi ≤ 109 ) first line print number valid <unknown> second line print valid value increase order",['data structures'],1900.0
369/E,valera love segment recently come one interest problem ox axis coordinate n segment i - th segment start position li end position ri ( mark [ li ri ] ) task process m query consist number cnti a set cnti coordinate point locate ox axis answer query number segment contain least one point query segment [ l r ] contain point q l ≤ q ≤ r. valera find solution problem difficult ask help help valera first line contain two integers n m ( 1 ≤ n m ≤ 3·105 ) — number segment axis coordinate number query next n line contain descriptions segment i - th line contain two positive integers li ri ( 1 ≤ li ≤ ri ≤ 106 ) — border i - th segment next m line contain description query one per line line start integer cnti ( 1 ≤ cnti ≤ 3·105 ) — number point i - th query line contain cnti distinct positive integers p1 p2 ... pcnti ( 1 ≤ p1 < p2 < ... < pcnti ≤ 106 ) — coordinate point i - th query guarantee total number point query n't exceed 3·105 print m non - negative integers i - th number response i - th query,['data structures'],2200.0
431/E,one day two students <unknown> diana find university chemistry lab lab students find n test tube mercury number 1 n decide conduct experiment experiment consist q step step one follow action occur : unfortunately calculations prove complex students ask help help conduct describe experiment first line contain two integers n q ( 1 ≤ n q ≤ 105 ) — number tube ans number experiment step next line contain n space - separated integers : h1 h2 ... hn ( 0 ≤ hi ≤ 109 ) hi volume mercury і - th tube begin experiment next q line contain game action follow format : guarantee least one action second type guarantee number describe experiment integers action second type print calculate value answer consider correct relative absolute error n't exceed 10 - 4,['data structures'],2200.0
762/E,"lattice point coordinate line n radio station i - th describe three integers : say two radio station number i j reach broadcast range equal distance word min ( ri rj ) ≥ |xi - xj| let 's call a pair radio station ( i j ) bad i < j station i j reach close frequency , <unknown> - <unknown> ≤ k. find number bad pair radio station first line contain two integers n k ( 1 ≤ n ≤ 105 0 ≤ k ≤ 10 ) — number radio station maximum difference frequencies pair station reach consider bad next n line follow descriptions radio station line contain three integers xi ri fi ( 1 ≤ xi ri ≤ 109 1 ≤ fi ≤ 104 ) — coordinate i - th radio station 's broadcast range 's broadcast frequency two radio station share a coordinate output number bad pair radio station",['data structures'],2200.0
768/G,give a root tree n nod night king remove exactly one node tree edge associate split tree form a forest node remove a part forest root a tree forest node tree a parent define strength forest size largest tree forest jon snow want minimize strength forest perform follow operation remove edge a node parent insert a new edge node node forest total number tree forest remain node v need find minimum value strength forest form node v remove first line input contain integer n ( 1 ≤ n ≤ 105 ) — number vertices tree next n line contain a pair vertex indices ui vi ( 1 ≤ ui vi ≤ n ) ui parent vi ui = 0 vi root print n line contain a single integer i - th equal minimum value strength forest form i - th node remove jon snow perform operation describe tree first test case depict remove first node tree split form follow forest strength forest 4 . jon snow change parent vertex 10 5 3 . strength forest become 3,['data structures'],3300.0
204/B,little elephant love play color card n card exactly two color ( color front side color back side ) initially card lay table front side one move little elephant turn card side little elephant think a set card table funny least half card color ( card color upper side consider ) help little elephant find minimum number move need make set n card funny first line contain a single integer n ( 1 ≤ n ≤ 105 ) — number card follow n line contain description card one card per line card describe a pair positive integers exceed 109 — color side first number a line color front card second one — back color front card may coincide color back card number line separate single space a single line print a single integer — seek minimum number move impossible make set funny print -1 . first sample initially three card lie color 4 4 7 . since two three card color 4 need change anything answer 0 . second sample turn first fourth card three five card color 7,['data structures'],1500.0
774/B,stepan a experience olympiad participant n cup physics olympiads m cup informatics olympiads cup characterize two parameters — significance ci width wi stepan decide expose cup a shelf width d a way : task determine maximum possible total significance stepan get expose cup shelf width d consider rule describe total significance sum <unknown> expose cup first line contain three integers n m d ( 1 ≤ n m ≤ 100 000 1 ≤ d ≤ 109 ) — number cup physics olympiads number cup informatics olympiads width shelf follow n line contain two integers ci wi ( 1 ≤ ci wi ≤ 109 ) — significance width i - th cup physics olympiads follow m line contain two integers cj wj ( 1 ≤ cj wj ≤ 109 ) — significance width j - th cup informatics olympiads print maximum possible total significance stepan get expose cup shelf width d consider rule describe statement way expose cup shelf print 0 . first example stepan one informatics cup must expose shelf significance equal 3 width equal 2 stepan expose width free space shelf become equal 6 . also stepan must expose second physics cup ( width 5 ) significant cup physics ( significance equal 5 ) stepan expose cup shelf enough free space thus maximum total significance expose cup equal 8,['data structures'],2100.0
1041/D,a plane fly a constant height $$$ h $$$ meter grind surface let 's consider fly point $$$ ( -1000000000 h ) $$$ point $$$ ( 1000000000 h ) $$$ parallel $$$ ox $$$ axis a glider inside plane ready start flight moment ( sake simplicity let 's consider may start plane 's coordinate integers ) jump plane fly direction plane parallel $$$ ox $$$ axis cover a unit distance every second naturally also descend ; thus second coordinate decrease one unit every second ascend air flow certain segment segment characterize two number $$$ x_1 $$$ $$$ x_2 $$$ ( $$$ x_1 < x_2 $$$ ) represent endpoints two segment share common point glider inside one segment n't descend second coordinate stay second glider still fly along $$$ ox $$$ axis cover one unit distance every second determine maximum distance along $$$ ox $$$ axis point glider 's flight start point flight end glider choose integer coordinate jump plane start flight touch grind glider stop altogether <unknown> ascend <unknown> segment second coordinate $$$ 0 $$$ first line contain two integers $$$ n $$$ $$$ h $$$ $$$ ( 1 \le n \le 2\cdot10^ { 5 } 1 \le h \le 10^ { 9 } ) $$$ — number ascend air flow segment altitude plane fly respectively next $$$ n $$$ line contain two integers $$$ x _ { i1 } $$$ $$$ x _ { i2 } $$$ $$$ ( 1 \le x _ { i1 } < x _ { i2 } \le 10^ { 9 } ) $$$ — endpoints $$$ i $$$ -th ascend air flow segment two segment intersect give ascend order print one integer — maximum distance along $$$ ox $$$ axis glider fly point jump plane point land start flight integer coordinate first example glider jump $$$ ( 2 4 ) $$$ land point $$$ ( 12 0 ) $$$ distance $$$ 12 - 2 = 10 $$$ second example glider fly $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ distance $$$ 34 - <unknown> $$$ third example glider fly $$$ ( <unknown> ) $$$ $$$ ( <unknown> ) $$$ distance $$$ <unknown> ( <unknown> ) = <unknown> $$$,['data structures'],1700.0
1070/E,polycarp a lot work recently learn a new time management rule : ` ` a task take five minutes less immediately '' polycarp like new rule however sure five minutes optimal value suppose value $$$ d $$$ choose base exist task list polycarp a list $$$ n $$$ task complete $$$ i $$$ -th task difficulty $$$ p_i $$$ i.e require exactly $$$ p_i $$$ minutes do polycarp read task one one first $$$ n $$$ -th a task difficulty $$$ d $$$ less polycarp start work task immediately a task difficulty strictly greater $$$ d $$$ task allow rearrange task list polycarp n't spend time read a task skip polycarp $$$ t $$$ minutes total complete maximum number task want work time decide make a break group $$$ m $$$ consecutive task work break take amount time spend total completion $$$ m $$$ task example $$$ n=7 $$$ $$$ p= [ 3 1 4 1 5 9 2 ] $$$ $$$ <unknown> $$$ $$$ m=2 $$$ polycarp work follow schedule : polycarp stop exactly $$$ t $$$ minutes polycarp start a task finish time task consider complete allow complete less $$$ m $$$ task last group also polycarp consider acceptable shorter break need last group task even break — work day enough time rest anyway please help polycarp find value $$$ d $$$ would allow complete maximum possible number task $$$ t $$$ minutes first line input contain single integer $$$ c $$$ ( $$$ 1 \le c \le 50000 $$$ ) — number test case description $$$ c $$$ test case follow solve test case separately test case completely independent affect test case describe two line first line contain three space - separated integers $$$ n $$$ $$$ m $$$ $$$ t $$$ ( $$$ 1 \le n \le 2 \cdot 100000 1 \le m \le 2 \cdot 100000 1 \le t \le 4 \cdot 10^ { 10 } $$$ ) — number task polycarp 's list number task without a break total amount time polycarp work task second line test case contain $$$ n $$$ space separate integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le 200000 $$$ ) — difficulties task sum value $$$ n $$$ test case input exceed $$$ 200000 $$$ print $$$ c $$$ line line contain answer correspond test case — maximum possible number task polycarp complete integer value $$$ d $$$ ( $$$ 1 \le d \le t $$$ ) polycarp use time management rule separate space several possible value $$$ d $$$ a test case output first test case first example $$$ n=5 $$$ $$$ m=2 $$$ $$$ <unknown> $$$ sequence difficulties $$$ [ 5 6 1 4 7 ] $$$ polycarp choose $$$ d=5 $$$ complete $$$ 3 $$$ task polycarp work follow schedule : total first test case polycarp complete $$$ 3 $$$ task $$$ d=5 $$$ ca n't choose value $$$ d $$$ increase number complete task,['data structures'],2100.0
1136/E,task nastya ask us write a formal statement array $$$ a $$$ length $$$ n $$$ array $$$ k $$$ length $$$ n-1 $$$ give two type query process : 's guarantee initially $$$ a_i + k_i \leq a _ { i+1 } $$$ $$$ 1 \leq i \leq n-1 $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 10^ { 5 } $$$ ) — number elements array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -10^ { 9 } \leq a_i \leq 10^ { 9 } $$$ ) — elements array $$$ a $$$ third line contain $$$ n-1 $$$ integers $$$ k_1 k_2 \ldots k _ { n-1 } $$$ ( $$$ -10^ { 6 } \leq k_i \leq 10^ { 6 } $$$ ) — elements array $$$ k $$$ fourth line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 10^ { 5 } $$$ ) — number query follow $$$ q $$$ line contain a query one two type : query second type print a single integer a new line — sum correspond subarray first example : second example :,['data structures'],2200.0
1167/E,give array consist $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ integer $$$ x $$$ guarantee every $$$ i $$$ $$$ 1 \le a_i \le x $$$ let 's denote a function $$$ f ( l r ) $$$ erase value $$$ l \le a_i \le r $$$ array $$$ a $$$ return result array example $$$ a = [ 4 1 1 4 5 2 4 3 ] $$$ $$$ f ( 2 4 ) = [ 1 1 5 ] $$$ task calculate number pair $$$ ( l r ) $$$ $$$ 1 \le l \le r \le x $$$ $$$ f ( l r ) $$$ sort non - descending order note empty array also consider sort first line contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \le n x \le 1000000 $$$ ) — length array $$$ a $$$ upper limit elements respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le x $$$ ) print number pair $$$ 1 \le l \le r \le x $$$ $$$ f ( l r ) $$$ sort non - descending order first test case correct pair $$$ ( 1 1 ) $$$ $$$ ( 1 2 ) $$$ $$$ ( 1 3 ) $$$ $$$ ( 2 3 ) $$$ second test case correct pair $$$ ( 1 3 ) $$$ $$$ ( 1 4 ) $$$ $$$ ( 2 3 ) $$$ $$$ ( 2 4 ) $$$ $$$ ( 3 3 ) $$$ $$$ ( 3 4 ) $$$,['data structures'],2100.0
1034/D,"little d a friend little c love intervals much instead number ` ` $$$ 3 $$$ ` ` $$$ n $$$ intervals number axis $$$ i $$$ -th $$$ [ a_i b_i ] $$$ $$$ n $$$ intervals satisfy define value interval intervals $$$ [ l r ] $$$ ( $$$ 1 \leq l \leq r \leq n $$$ $$$ l $$$ $$$ r $$$ integers ) total length union intervals $$$ l $$$ -th $$$ r $$$ -th want select exactly $$$ k $$$ different intervals intervals sum value maximal please help calculate maximal sum first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 300000 $$$ $$$ 1 \leq k \leq <unknown> { \frac { n ( n+1 ) } { 2 } , <unknown> } $$$ ) — number intervals little d number intervals intervals select next $$$ n $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ $$$ i $$$ -th line $$$ n $$$ line describe $$$ i $$$ -th interval ( $$$ 1 \leq a_i < b_i \leq 1000000000 $$$ ) print one integer — maximal sum value little d get first example little d select $$$ [ 1,2 ] $$$ union first interval second interval $$$ [ 1,4 ] $$$ whose length $$$ 3 $$$ second example little d select $$$ [ 1,2 ] $$$ $$$ [ 2,3 ] $$$ $$$ [ 1,3 ] $$$ answer $$$ 5 + 6 + <unknown> $$$",['data structures'],3500.0
576/E,note unusual memory limit problem give undirected graph consist n vertices m edge vertices number integers 1 n edge number integers 1 m. edge <unknown> paint one k color number integers 1 k. initially none edge paint color get query form ` ` repaint edge ei color ci '' time graph form edge color must bipartite repaint condition violate query consider invalid edge ei keep color otherwise edge ei repaint color ci query consider valid recall graph call bipartite set vertices divide two part edge connect vertices part example suppose give a triangle graph a graph three vertices edge ( 1 2 ) ( 2 3 ) ( 3 1 ) suppose first two edge paint color 1 third one paint color 2 . query ` ` repaint third edge color 1 '' incorrect execution graph form edge color 1 bipartite hand possible repaint second edge color 2 . receive q query query either apply report query valid report query invalid first line contain integers n m k q ( 2 ≤ n ≤ 5·105 1 ≤ m q ≤ 5·105 1 ≤ k ≤ 50 ) — number vertices number edge number color number query follow m edge graph form ai bi ( 1 ≤ ai bi ≤ n ) follow q query form ei ci ( 1 ≤ ei ≤ m 1 ≤ ci ≤ k ) guarantee graph n't contain multiple edge loop query print ` ` yes '' ( without quote ) valid ` ` '' ( without quote ) query destroy <unknown> graph form edge color,['data structures'],3300.0
1006/C,give array $$$ d_1 d_2 \dots d_n $$$ consist $$$ n $$$ integer number task split array three part ( may empty ) a way element array belong exactly one three part part form a consecutive contiguous subsegment ( possibly empty ) original array let sum elements first part $$$ sum_1 $$$ sum elements second part $$$ sum_2 $$$ sum elements third part $$$ sum_3 $$$ among possible ways split array choose a way $$$ sum_1 = sum_3 $$$ $$$ sum_1 $$$ maximum possible formally first part array contain $$$ a $$$ elements second part array contain $$$ b $$$ elements third part contain $$$ c $$$ elements : $$$ $$$ sum_1 = \sum\limits _ { 1 \le i \le a } d_i $$$ $$$ $$$ $$$ sum_2 = \sum\limits _ { a + 1 \le i \le a + b } d_i $$$ $$$ $$$ $$$ sum_3 = \sum\limits _ { a + b + 1 \le i \le a + b + c } d_i $$$ $$$ sum empty array $$$ 0 $$$ task find a way split array $$$ sum_1 = sum_3 $$$ $$$ sum_1 $$$ maximum possible first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements array $$$ d $$$ second line input contain $$$ n $$$ integers $$$ d_1 d_2 \dots d_n $$$ ( $$$ 1 \le d_i \le 1000000000 $$$ ) — elements array $$$ d $$$ print a single integer — maximum possible value $$$ sum_1 $$$ consider condition $$$ sum_1 = sum_3 $$$ must meet obviously least one valid way split array exist ( use $$$ a = <unknown> $$$ $$$ b = n $$$ ) first example one possible split maximize $$$ sum_1 $$$ : $$$ [ 1 3 1 ] [ ~ ] [ 1 4 ] $$$ second example way $$$ <unknown> $$$ : $$$ [ 1 3 ] [ 2 1 ] [ 4 ] $$$ third example one way split array : $$$ [ ~ ] [ 4 1 2 ] [ ~ ] $$$,['data structures'],1200.0
992/E,nastya like read even spend whole days a library sometimes today find a chronicle byteland library state live shamans long time ago know every moment exactly one shaman byteland n shamans total enumerate integers 1 n order live also shaman a magic power express integer chronicle include a list power n shamans also shamans king - shamans gather power <unknown> i.e power exactly sum power previous shamans nastya interest whether least one king - shaman byteland unfortunately many power unreadable list nastya follow : unfortunately list large nastya want help first line contain two integers n q ( 1 ≤ n q ≤ 2·105 ) second line contain n integers a1 ... ( 0 ≤ ai ≤ 109 ) ai magic power i - th shaman q line follow i - th contain two integers pi xi ( 1 ≤ pi ≤ n 0 ≤ xi ≤ 109 ) mean new power pi - th shaman xi print q line i - th contain - 1 i - th change shaman - kings otherwise a single integer j j index king - shaman i - th change multiple king - shamans change print index first example power shamans first change equal ( 2 3 ) answer equal - 1 sum power shamans first shaman equal 0 second equal 2 . second example first change power equal ( 1 2 3 ) answer equal 3 power third shaman equal 3 sum power first second shaman also 1 + 2 = 3 . second change power become equal ( 2 2 3 ) answer equal 2 . third change power become equal ( 2 4 3 ) answer equal - 1 . fourth change power become equal ( 2 4 6 ) answer equal 3,['data structures'],2500.0
983/E,<unknown> country $$$ n $$$ cities number $$$ 1 $$$ $$$ n $$$ $$$ n - 1 $$$ roads connect a roads path two cities $$$ m $$$ bidirectional bus rout cities bus drive two cities take shortest path stop every city drive travel bus travel stop route travel cities bus interest $$$ q $$$ question : possible get one city another minimum number bus need use ? first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number cities second line contain $$$ n - 1 $$$ integers $$$ p_2 p_3 \ldots p_n $$$ ( $$$ 1 \le p_i < i $$$ ) $$$ p_i $$$ mean cities $$$ p_i $$$ $$$ i $$$ connect road third line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 200000 $$$ ) — number bus rout next $$$ m $$$ line contain $$$ 2 $$$ integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le n $$$ $$$ a \neq b $$$ ) mean a bus route cities $$$ a $$$ $$$ b $$$ possible one route two cities next line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number question interest next $$$ q $$$ line contain $$$ 2 $$$ integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le n $$$ $$$ v \neq u $$$ ) mean interest possible get city $$$ v $$$ city $$$ u $$$ minimum number bus need use print answer question a separate line way get one city another print $$$ -1 $$$ otherwise print minimum number bus use,['data structures'],2800.0
799/G,arkady reach n - th level <unknown> game masha decide bake a pie ! course pie a shape convex n - gon i.e a polygon n vertices arkady decide cut pie two equal area part cut a straight line eat one give masha a difficulty arkady already put a knife point pie cut pie a straight line pass trough point help arkady : find a line pass point arkady put a knife cut pie two part equal area determine 's impossible program quickly answer many query pie different point arkady put a knife first line contain two integers n q ( 3 ≤ n ≤ 104 1 ≤ q ≤ 105 ) — number vertices pie number <unknown> line follow describe polygon vertices clockwise order i - th line contain two integers xi yi ( - 106 ≤ xi yi ≤ 106 ) — coordinate i - th vertex guarantee polygon strictly convex particular three vertices line line empty line <unknown> line follow describe query point i - th line contain two integers xi yi ( - 106 ≤ xi yi ≤ 106 ) — coordinate point arkady put knife i - th query guarantee query give point strictly inside polygon particular edge query print single integer — polar angle line answer correspond query <unknown> angle segment [ 0 ; <unknown> ] angle measure direction ox axis counter - clockwise order example polar angle oy axis answer query print -1 . several answer print answer consider correct difference areas part divide total area polygon n't exceed 10 - 4 absolute value word a b areas part cut answer correct,['data structures'],3500.0
802/O,plan hc2 rather far - <unknown> : 500 000 days away hc2 <unknown> example accordingly plan a couple hundred thousand problems <unknown> ( hope program contest become <unknown> popular ) <unknown> need get work could use a good plan ... medium version limit change : 1 ≤ k ≤ n ≤ 500 000 . medium version,['data structures'],2900.0
813/E,might remember previous round vova really like computer game play a strategy game know rage empires game vova hire n different warriors ; ith warrior type ai vova want create a balance army hire subset warriors army call balance type warrior present game k warriors type army course vova want army large possible make things complicate vova consider q different plan create army ith plan allow hire warriors whose number less li greater ri help vova determine largest size a balance army plan aware plan give a modify way see input section detail first line contain two integers n k ( 1 ≤ n k ≤ 100000 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 100000 ) third line contain one integer q ( 1 ≤ q ≤ 100000 ) q line follow ith line contain two number xi yi represent ith plan ( 1 ≤ xi yi ≤ n ) keep track answer last plan ( let 's call last ) begin last = 0 . restore value li ri ith plan follow : print q number ith number must equal maximum size a balance army consider ith plan first example real plan :,['data structures'],2200.0
815/D,"karen get home <unknown> get ready go sleep take a <unknown> change <unknown> look shelf saw album curious open saw a trade card collection recall use play card a child , although grown - up still wonder a things card three characteristics : strength defense speed value characteristics card positive integers maximum possible strength card p maximum possible defense q maximum possible speed r. n card collection i - th card a strength ai defense bi speed ci respectively a card beat another card least two characteristics strictly greater correspond characteristics card wonder many different card beat card collection two card consider different least one characteristics different value first line input contain four integers n p q r ( 1 ≤ n p q r ≤ 500000 ) number card collection maximum possible strength maximum possible defense maximum possible speed respectively next n line contain three integers particular i - th line contain ai bi ci ( 1 ≤ ai ≤ p 1 ≤ bi ≤ q 1 ≤ ci ≤ r ) strength defense speed i - th collection card respectively output a single integer a line number different card beat card collection first test case maximum possible strength 4 maximum possible defense 4 maximum possible speed 5 . karen three card : 10 card beat card : second test case maximum possible strength 10 maximum possible defense 10 maximum possible speed 10 . karen five card strength 1 defense 1 speed 1 . <unknown> card least two characteristics greater 1 beat card collection",['data structures'],2800.0
842/D,today lesson vitya learn a interest function — mex mex a sequence number minimum non - negative number present sequence element example mex ( [ 4 33 0 1 1 5 ] ) = 2 mex ( [ 1 2 3 ] ) = 0 . vitya quickly understand task teacher ? give array consist n non - negative integers m query query characterize one number x consist follow consecutive step : note query array change first line contain two integer number n m ( 1 ≤ n m ≤ 3·105 ) — number elements array number query next line contain n integer number ai ( 0 ≤ ai ≤ 3·105 ) — elements array next m line contain query — one integer number x ( 0 ≤ x ≤ 3·105 ) query print answer a separate line,['data structures'],2000.0
847/B,ivan array consist n different integers decide reorder elements increase order ivan love merge sort decide represent array one several increase sequence plan merge one sort array ivan represent array increase sequence help follow algorithm least one <unknown> number array ivan repeat follow procedure : example ivan 's array look like [ 1 3 2 5 4 ] perform two iterations first iteration ivan use write number [ 1 3 5 ] second one — [ 2 4 ] write a program help ivan find representation give array one several increase sequence accordance algorithm describe first line contain a single integer n ( 1 ≤ n ≤ 2·105 ) — number elements ivan 's array second line contain a sequence consist distinct integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — ivan 's array print representation give array form one increase sequence accordance algorithm describe sequence must print a new line,['data structures'],1600.0
855/F,nagini a horcrux <unknown> - know - <unknown> create murder <unknown> <unknown> <unknown> army snake launch attack hogwarts school hogwarts ' entrance imagine a straight line ( x - axis ) 1 105 . nagini launch various snake hogwarts entrance snake land parallel entrance cover a segment a distance k x = l x = r. formally snake imagine a line segment point ( l k ) ( r k ) note k positive negative 0 . let x - coordinate x = i snake point ( i y1 ) point ( i y2 ) y1 > 0 y2 < 0 . point ( i y3 ) contain a snake y3 > 0 y1 ≤ y3 hold point ( i y4 ) contain a snake y4 < 0 |y2| ≤ <unknown> hold danger value coordinate x = i y1 + |y2| y1 y2 exist danger value 0 . harry want calculate danger value various segment hogwarts entrance danger value a segment [ l r ) entrance calculate take sum danger value integer x - coordinate present segment formally implement two type query : first line input contain a single integer q ( 1 ≤ q ≤ 5·104 ) denote number query next q line describe a query query description first contain query type typei ( 1 ≤ typei ≤ 2 ) follow description query case type 1 follow integers li ri ki ( - 109 ≤ ki ≤ 109 k ≠ 0 ) otherwise contain two integers li ri ( 1 ≤ li < ri ≤ 105 ) output answer query type 2 a separate line first sample case danger value x - coordinates 1 0 y2 satisfy condition x = 1 . danger value x - coordinates 2 3 10 + | - <unknown> = 17 . danger value x - coordinates 4 9 0 y2 satisfy condition coordinate thus total danger value 17 + 17 = 34,['data structures'],3100.0
923/B,alice like snow a lot ! unfortunately year 's winter already ca n't expect bob thus buy a gift — a large snow <unknown> plan make amount snow every day day i make a pile snow volume vi put garden day every pile shrink a little due melt precisely temperature a give day ti pile reduce volume ti would reduce volume a pile zero disappear forever snow pile independent note pile make day i already lose part volume day <unknown> case may mean pile leave end a particular day give initial pile size temperature day determine total volume snow melt day first line contain a single integer n ( 1 ≤ n ≤ 105 ) — number days second line contain n integers v1 v2 ... vn ( 0 ≤ vi ≤ 109 ) vi initial size a snow pile make day i. third line contain n integers t1 t2 ... tn ( 0 ≤ ti ≤ 109 ) ti temperature day i. output a single line n integers i - th integer represent total volume snow melt day i. first sample bob first make a snow pile volume 10 melt size 5 day second day make another pile size 10 . since a bite <unknown> day first pile disappear completely second pile shrink 3 . end second day a single pile size 3 . third day make a smaller pile usual temperature drop pile survive till end day,['data structures'],1600.0
817/F,give a set integer number initially empty perform n query three different type query : query output mex set — smallest positive ( mex ≥ 1 ) integer number present set first line contain one integer number n ( 1 ≤ n ≤ 105 ) next n line contain three integer number t l r ( 1 ≤ t ≤ 3 1 ≤ l ≤ r ≤ 1018 ) — type query leave right bound print mex set query content set query first example :,['data structures'],2300.0
1220/F,"<unknown> alex love grow tree remind tree a connect acyclic graph $$$ n $$$ vertices today decide grow a root binary tree a binary tree a tree vertex two sons luckily alex a permutation number $$$ 1 $$$ $$$ n $$$ present last birthday decide grow a tree accord permutation follow process : find a minimum element make a root tree permutation divide two part : everything leave minimum element everything right minimum element leave part become leave son root minimum element right part become right son root , process repeat recursively part alex want grow a forest tree : one tree cyclic shift permutation interest cyclic shift give tree minimum depth unfortunately grow a forest a hard long process alex want answer right help ? remind cyclic shift permutation $$$ a_1 a_2 \ldots a_k \ldots a_n $$$ $$$ k $$$ elements leave permutation $$$ a _ { k + 1 } a _ { k + 2 } \ldots a_n a_1 a_2 \ldots a_k $$$ first line contain integer number $$$ n ~ ( 1 \leqslant n \leqslant 200\,000 ) $$$ — length permutation second line contain $$$ n $$$ integer number $$$ a_1 a_2 \ldots a_n ~ ( 1 \leqslant a_i \leqslant n ) $$$ guarantee number occur exactly one time print two number separate space : minimum possible depth a tree many elements need shift leave achieve depth number elements a number $$$ 0 $$$ $$$ n - 1 $$$ several possible answer print follow picture depict possible tree sample test cyclic shift achieve",['data structures'],2700.0
845/E,capital berland look like a rectangle size n × m square block size fire ! know k + 1 block get catch fire ( k + 1 ≤ n·m ) block center ignition moreover position k center know one stay unknown k + 1 position distinct fire go follow way : zero minute fire k + 1 center ignition burn every next minute fire go neighbour block one burn consider block burn long time exceed time take problem neighbour block touch current block a side a corner berland fire <unknown> want estimate minimal time take fire lighten whole city remember position k block ( center ignition ) know ( k + 1 ) -th position block help berland fire department estimate minimal time take fire lighten whole city first line contain three integers n m k ( 1 ≤ n m ≤ 109 1 ≤ k ≤ 500 ) next k line contain two integers xi yi ( 1 ≤ xi ≤ n 1 ≤ yi ≤ m ) — coordinate i - th center ignition guarantee locations center ignition distinct print minimal time take fire lighten whole city ( minutes ) first example last block coordinate ( 4 4 ) second example last block coordinate ( 8 3 ),['data structures'],2400.0
587/C,recently duff a soldier army malek commander country andarz gu n cities ( number 1 n ) n - 1 bidirectional roads road connect two different cities exist a unique path two cities also m people live andarz gu ( number 1 m ) person i d number i d number i - th person i he / she live city number ci note may one person a city also may people live city malek love order 's ask duff answer q query query give number v u a. answer a query : assume x people live cities lie path city v city u. assume people 's ids p1 p2 ... px increase order k = min ( x a ) duff tell malek number k p1 p2 ... pk order word malek want know a <unknown> path ( less less a people ) duff busy moment ask help answer query first line input contain three integers n m q ( 1 ≤ n m q ≤ 105 ) next n - 1 line contain roads line contain two integers v u endpoints a road ( 1 ≤ v u ≤ n v ≠ u ) next line contain m integers c1 c2 ... cm separate space ( 1 ≤ ci ≤ n 1 ≤ i ≤ m ) next q line contain query contain three integers v u a ( 1 ≤ v u ≤ n 1 ≤ a ≤ 10 ) query print number k p1 p2 ... pk separate space one line graph andarz gu sample case follow ( i d people city write next ) :,['data structures'],2200.0
620/F,give array n integers ai m query query describe two integers ( lj rj ) let 's define function function define u ≤ v. query print maximal value function f ( ax ay ) lj ≤ x y ≤ rj ax ≤ ay first line contain two integers n m ( 1 ≤ n ≤ 5·104 1 ≤ m ≤ 5·103 ) — size array number query second line contain n integers ai ( 1 ≤ ai ≤ 106 ) — elements array a. next m line contain two integers lj rj ( 1 ≤ lj ≤ rj ≤ n ) – parameters j - th query query print value aj a separate line — maximal value function f ( ax ay ) lj ≤ x y ≤ rj ax ≤ ay,['data structures'],2800.0
675/D,"program class vasya assign a difficult problem however n't know code unable find solution internet ask help give a sequence $$$ a $$$ consist $$$ n $$$ distinct integers use construct binary search tree formal description construction process first line input contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100\,000 $$$ ) — length sequence $$$ a $$$ second line contain $$$ n $$$ distinct integers $$$ a_i $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — sequence $$$ a $$$ output $$$ n - 1 $$$ integers $$$ i > 1 $$$ print value write node parent node value $$$ a_i $$$",['data structures'],1800.0
696/E,barney search dream girl live nyc nyc n junctions number 1 n n - 1 roads connect consider nyc a root tree root junction 1 . m girls live nyc i - th live along junction ci weight initially equal i pound barney consider a girl x better a girl y : girl x weight strictly less girl y girl x girl y equal weight index girl x live junction index strictly less girl y live junction index i.e cx < <unknown> thus two girls one always better another one next q days one event happen day two type events : task event first type tell barney indices girls invite home event first line input contain three integers n m q ( 1 ≤ n m q ≤ 105 ) — number junctions nyc number girls live nyc number events respectively next n - 1 line describe roads line contain two integers v u ( 1 ≤ v u ≤ n v ≠ u ) mean a road connect junctions v u next line contain m integers c1 c2 ... cm ( 1 ≤ ci ≤ n ) — girl 's live junctions next q line describe events chronological order line start integer t ( 1 ≤ t ≤ 2 ) — type event t = 1 line describe event first type three integers v u k ( 1 ≤ v u k ≤ n ) follow — endpoints barney 's path number girls invite otherwise line describe event second type two integers v k ( 1 ≤ v ≤ n 1 ≤ k ≤ 109 ) follow — root subtree value girls ' weight subtree increase event first type print number t t integers g1 <unknown> ... gt one line mean event barney invite t girls whose indices g1 ... gt order best worst accord barney 's <unknown> first sample case : description events :,['data structures'],3000.0
704/E,tony <unknown> play a game suit ( <unknown> - pilot ) live malibu malibu n junctions number 1 n connect n - 1 roads one get a junction junction use roads ( graph malibu form a tree ) tony m suit 's a special plan suit i - th suit appear moment time ti junction vi move junction ui use shortest path vi ui speed ci roads per second ( pass a junctions take time ) vanish immediately arrive ui ( reach ui time q 's available moment q moments ) also suit move continuously ( example vi ≠ ui time 's middle a road please note vi = ui mean suit junction number vi moment ti vanish explosion happen moment time two suit share exact location ( may a junction somewhere a road ; appear vanish move ) task tell tony moment first explosion ( ) first line input contain two integers n m ( 1 ≤ n m ≤ 100 000 ) — number junctions number suit respectively next n - 1 line contain roads descriptions line contain two integers ai bi — endpoints i - th road ( 1 ≤ ai bi ≤ n ai ≠ bi ) next m line contain suit descriptions i - th contain four integers ti ci vi ui ( 0 ≤ ti ≤ 10 000 1 ≤ ci ≤ 10 000 1 ≤ vi ui ≤ n ) mean i - th suit appear moment time ti junction vi move junction ui a speed ci roads per second would explosions print -1 first line output otherwise print moment first explosion answer consider correct relative absolute error n't exceed 10 - 6,['data structures'],3300.0
916/E,surprise jamie final boss ! <unknown> jamie give a tree n vertices number 1 n. initially root tree vertex number 1 . also vertex a value jamie also give three type query <unknown> v — change tree 's root vertex number <unknown> u v x — vertex subtree smallest size contain u v add x <unknown> v — find sum value vertices subtree vertex number v. a subtree vertex v a set vertices v lie shortest path vertex root tree pay attention subtree a vertex change change tree 's root show strength program jamie perform query accurately ! first line input contain two space - separated integers n q ( 1 ≤ n ≤ 105 1 ≤ q ≤ 105 ) — number vertices tree number query process respectively second line contain n space - separated integers a1 a2 ... ( - 108 ≤ ai ≤ 108 ) — initial value vertices next n - 1 line contain two space - separated integers ui vi ( 1 ≤ ui vi ≤ n ) describe edge vertices ui vi tree follow q line describe query query one follow format depend <unknown> v ( 1 ≤ v ≤ n ) query first <unknown> u v x ( 1 ≤ u v ≤ n - 108 ≤ x ≤ 108 ) query second <unknown> v ( 1 ≤ v ≤ n ) query third type number query ' descriptions integers query must carry give order guarantee tree valid query third type output require answer guarantee least one query third type give jamie follow picture show tree vary query first sample,['data structures'],2400.0
925/E,'s may flatland $$$ m $$$ days month despite fact may holiday cancel long time ago employees software company still a habit take short long vacation may course managers company like $$$ n $$$ employees company form a tree - like structure subordination : employee a unique integer i d $$$ i $$$ $$$ 1 $$$ $$$ n $$$ employee i d $$$ i $$$ ( except head manager whose i d 1 ) exactly one direct manager i d $$$ p_i $$$ structure subordination cyclic i.e start move employee direct manager eventually reach head manager define employee $$$ u $$$ a subordinate employee $$$ v $$$ $$$ v $$$ a direct manager $$$ u $$$ direct manager $$$ u $$$ a subordinate $$$ v $$$ let $$$ s_i $$$ number subordinate $$$ i $$$ -th employee ( example $$$ s_1 = n - 1 $$$ employees except subordinate head manager ) employee $$$ i $$$ a bear limit $$$ t_i $$$ integer $$$ 0 $$$ $$$ s_i $$$ denote maximum number subordinate $$$ i $$$ -th employee vacation moment bear moment strictly $$$ t_i $$$ subordinate $$$ i $$$ -th employee vacation $$$ i $$$ -th employee a vacation become displease $$$ m $$$ days may exactly one event follow two type happen : either one employee leave a vacation begin day one employee return a vacation begin day know sequence events follow $$$ m $$$ days task compute $$$ m $$$ days number displease employees day first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n m \leq 100000 $$$ ) — number employees company number days may second line contain $$$ n - 1 $$$ integers $$$ p_2 p_3 \ldots p_n $$$ ( $$$ 1 \leq p_i \leq n $$$ ) denote direct managers employees third line contain $$$ n $$$ integers $$$ t_1 t_2 \ldots t_n $$$ ( $$$ 0 \leq t_i \leq s_i $$$ ) denote bear limit <unknown> fourth line contain $$$ m $$$ integers $$$ q_1 q_2 \ldots <unknown> $$$ ( $$$ 1 \leq <unknown> \leq n $$$ $$$ q_i \ne 0 $$$ ) denote events $$$ q_i $$$ positive employee i d $$$ q_i $$$ leave a vacation start day $$$ q_i $$$ negative employee $$$ <unknown> $$$ return a vacation start day begin may employee vacation guarantee employee leave a vacation a vacation moment vice versa print a sequence $$$ m $$$ integers $$$ a_1 a_2 \ldots a_m $$$ $$$ a_i $$$ number displease employees $$$ i $$$ -th day first sample test employee i d 2 leave a vacation first day head manager i d 1 become displease want subordinate go a vacation fourth day employee i d 5 become displease last remain employee i d 7 leave a vacation fifth day employee i d 2 return vacation affect number displease employees employees 5 1 still displease sixth day employee i d 3 return back vacation prevent employee i d 5 displease last day head manager i d 1 leave a vacation leave company without displease people,['data structures'],2900.0
960/H,santa infinite number candy $$$ m $$$ flavour give a root tree $$$ n $$$ vertices root tree vertex $$$ 1 $$$ vertex contain exactly one candy $$$ i $$$ -th vertex a candy flavour $$$ f_i $$$ sometimes santa fear candy flavour $$$ k $$$ melt choose vertex $$$ x $$$ randomly send subtree $$$ x $$$ bakers a replacement a replacement candy flavour $$$ k $$$ replace a new candy flavour candy flavour $$$ k $$$ leave unchanged replacement tree restore actual cost replace one candy flavour $$$ k $$$ $$$ c_k $$$ ( give $$$ k $$$ ) baker keep price fix order make calculation simple every time a subtree come a replacement baker charge $$$ c $$$ matter subtree flavour suppose a give flavour $$$ k $$$ probability santa choose a vertex replacement vertices need find expect value error calculate cost replacement flavour $$$ k $$$ error calculate cost define follow $$$ $$$ <unknown> e ( k ) = \ ( actual <unknown> – \ <unknown> <unknown> <unknown> <unknown> bakers ) ^ 2 $$$ $$$ note actual cost cost replacement one candy flavour $$$ k $$$ multiply number candy subtree also sometimes santa may wish replace a candy vertex $$$ x $$$ a candy flavour pocket need handle two type operations : first line input contain four integers $$$ n $$$ ( $$$ 2 \leqslant n \leqslant 50000 $$$ ) $$$ m $$$ $$$ q $$$ $$$ c $$$ ( $$$ 1 \leqslant m q \leqslant 50000 $$$ $$$ 0 \leqslant c \leqslant 1000000 $$$ ) — number nod total number different flavour candy number query price charge bakers replacement respectively second line contain $$$ n $$$ integers $$$ f_1 f_2 \dots f_n $$$ ( $$$ 1 \leqslant f_i \leqslant m $$$ ) $$$ f_i $$$ initial flavour candy $$$ i $$$ -th node third line contain $$$ n - 1 $$$ integers $$$ p_2 p_3 \dots p_n $$$ ( $$$ 1 \leqslant p_i \leqslant n $$$ ) $$$ p_i $$$ parent $$$ i $$$ -th node next line contain $$$ m $$$ integers $$$ c_1 c_2 \dots c_m $$$ ( $$$ 1 \leqslant c_i \leqslant 100 $$$ ) $$$ c_i $$$ cost replace one candy flavour $$$ i $$$ next $$$ q $$$ line describe query line start integer $$$ t $$$ ( $$$ 1 \leqslant t \leqslant 2 $$$ ) — type query $$$ t = 1 $$$ line describe a query first type two integers $$$ x $$$ $$$ w $$$ follow ( $$$ 1 \leqslant x \leqslant n $$$ $$$ 1 \leqslant w \leqslant m $$$ ) mean santa replace candy vertex $$$ x $$$ flavour $$$ w $$$ otherwise $$$ t = 2 $$$ line describe a query second type integer $$$ k $$$ ( $$$ 1 \leqslant k \leqslant m $$$ ) follow mean print expect value error calculate cost replacement a give flavour $$$ k $$$ vertices index $$$ 1 $$$ $$$ n $$$ vertex $$$ 1 $$$ root output answer query second type a separate line answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ checker program consider answer correct $$$ \frac { |a - b| } { max ( 1 b ) } \leqslant 10^ { -6 } $$$ $$$ 1 $$$ -st query error calculate cost replacement flavour $$$ 1 $$$ vertex $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ choose $$$ 66 ^ 2 $$$ $$$ 66 ^ 2 $$$ $$$ ( -7 ) ^2 $$$ respectively since probability choose vertex therefore expect value error $$$ \frac { 66 ^ 2 + 66 ^ 2 + ( -7 ) ^2 } { 3 } $$$ similarly $$$ 2 $$$ -nd query expect value error $$$ \frac { 41 ^ 2 + ( -7 ) ^2 + ( -7 ) ^2 } { 3 } $$$ $$$ 3 $$$ -rd query flavour vertex $$$ 2 $$$ change $$$ 1 $$$ $$$ 3 $$$ $$$ 4 $$$ -th query expect value error $$$ \frac { ( -7 ) ^2 + ( -7 ) ^2 + ( -7 ) ^2 } { 3 } $$$ similarly $$$ 5 $$$ -th query expect value error $$$ \frac { 89 ^ 2 + 41 ^ 2 + ( -7 ) ^2 } { 3 } $$$,['data structures'],3100.0
962/G,"petya a polygon consist $$$ n $$$ vertices side petya 's polygon parallel coordinate ax two adjacent side petya 's polygon perpendicular guarantee polygon simple , n't self - intersections self - touches internal area polygon ( border include ) paint black color petya also petya a rectangular window define coordinate look polygon a rectangular window move side rectangular window parallel coordinate ax determine number black connect areas petya 's polygon see rectangular window first line contain four integers $$$ x_1 y_1 x_2 y_2 $$$ ( $$$ x_1 < x_2 $$$ $$$ y_2 < y_1 $$$ ) — coordinate top - left bottom - right corner rectangular window second line contain a single integer $$$ n $$$ ( $$$ 4 \le n \le 15\,000 $$$ ) — number vertices petya 's polygon follow $$$ n $$$ line contain two integers — coordinate vertices petya 's polygon counterclockwise order guarantee give polygon satisfy condition describe statement coordinate rectangular window coordinate vertices polygon non - negative exceed $$$ 15\,000 $$$ print number black connect areas petya 's polygon see rectangular window example correspond picture",['data structures'],2800.0
1009/F,give a root undirected tree consist $$$ n $$$ vertices vertex $$$ 1 $$$ root let 's denote a depth array vertex $$$ x $$$ infinite sequence $$$ [ d _ { x 0 } d _ { x 1 } d _ { x 2 } \dots ] $$$ $$$ d _ { x i } $$$ number vertices $$$ y $$$ condition hold : dominant index a depth array vertex $$$ x $$$ ( shortly dominant index vertex $$$ x $$$ ) index $$$ j $$$ : every vertex tree calculate dominant index first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — number vertices a tree $$$ n - 1 $$$ line follow contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ $$$ x \ne y $$$ ) line denote edge tree guarantee edge form a tree output $$$ n $$$ number $$$ i $$$ -th number equal dominant index vertex $$$ i $$$,['data structures'],2300.0
1023/G,"a group researchers study fish population a natural system lakes rivers system contain $$$ n $$$ lakes connect $$$ n - 1 $$$ rivers river integer length ( kilometers ) traverse directions possible travel pair lakes traverse rivers ( network lakes rivers form a tree ) unknown number indistinguishable fish live lakes day $$$ 1 $$$ fish arbitrary lakes fish travel lakes swim rivers fish swim a river $$$ l $$$ kilometers long direction $$$ l $$$ days , fish stay number days particular lake visit fish ever appear disappear lake system lake <unknown> number fish time researchers make several observations $$$ j $$$ -th observations ` ` day $$$ d_j $$$ least $$$ f_j $$$ distinct fish lake $$$ p_j $$$ ` ` help researchers determine smallest possible total number fish live lake system n't contradict observations first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — number lakes system next $$$ n - 1 $$$ line describe rivers $$$ i $$$ -th line contain three integers $$$ u_i $$$ $$$ v_i $$$ $$$ l_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ u_i \neq v_i $$$ $$$ 1 \leq l_i \leq 1000 $$$ ) — $$$ 1 $$$ -based indices lakes connect $$$ i $$$ -th river length river next line contain a single integer $$$ k $$$ ( $$$ 1 \leq k \leq 100000 $$$ ) — number observations next $$$ k $$$ line describe observations $$$ j $$$ -th line contain three integers $$$ d_j $$$ $$$ f_j $$$ $$$ p_j $$$ ( $$$ 1 \leq d_j \leq 100000000 $$$ $$$ 1 \leq f_j \leq 10000 $$$ $$$ 1 \leq p_j \leq n $$$ ) — day number fish lake index $$$ j $$$ -th <unknown> two observations happen day lake simultaneously print one integer — smallest total number fish contradict observations first example could one fish swim lakes $$$ 2 $$$ $$$ 1 $$$ $$$ 4 $$$ second fish swim lakes $$$ 3 $$$ $$$ 1 $$$ $$$ 2 $$$ second example a single fish possibly part observations simultaneously two fish swim $$$ 2 \to 1 \to 4 $$$ $$$ 3 \to 1 \to 5 $$$ third example one fish move lake $$$ 1 $$$ lake $$$ 5 $$$ others stay lakes time : two fish lake $$$ 4 $$$ six fish lake $$$ 5 $$$ one fish lake $$$ 3 $$$ system lakes show picture",['data structures'],3400.0
482/E,a root tree contain n vertexes let 's number tree vertexes integers 1 n. tree root vertex 1 . vertex ( except <unknown> tree root ) v a direct ancestor pv also vertex v integer value <unknown> task perform follow query : task follow start perform query query calculate expect value write lowest common ancestor two equiprobably select vertices i j. lowest common ancestor i j <unknown> vertex lie path root vertex i path root vertex j. please note vertices i j ( case lowest common ancestor coincide ) first line input contain integer n ( 2 ≤ n ≤ 5·104 ) — number tree vertexes second line contain n - 1 integer p2 p3 ... pn ( 1 ≤ pi ≤ n ) — description tree edge guarantee number form a tree third line contain n integers — s1 s2 ... sn ( 0 ≤ si ≤ 106 ) — value write vertex tree next line contain integer q ( 1 ≤ q ≤ 5·104 ) — number query follow q line contain description query format describe statement guarantee query <unknown> u v lie 1 n. guarantee argument t query type v meet limit 0 ≤ t ≤ 106 . print q + 1 number — correspond expect value answer consider correct absolute relative error n't exceed 10 - 9 . note query p v u u lie subtree v must perform assignment pu = v. example case last query sample,['data structures'],3200.0
893/F,give a root tree consist n vertices vertex a number write ; number ai write vertex i. let 's denote d ( i j ) distance vertices i j tree ( number edge shortest path i j ) also let 's denote k - blocked subtree vertex x set vertices y condition meet : give m query tree i - th query represent two number xi ki answer query minimum value aj among vertices j j belong ki - blocked subtree xi write a program would process query quickly ! note query give a modify way first line contain two integers n r ( 1 ≤ r ≤ n ≤ 100000 ) — number vertices tree index root respectively second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — number write vertices n - 1 line follow contain two integers x y ( 1 ≤ x y ≤ n ) represent edge vertices x y. guarantee edge form a tree next line contain one integer m ( 1 ≤ m ≤ 106 ) — number query process m line follow i - th line contain two number pi qi use restore i - th query ( 1 ≤ pi qi ≤ n ) <unknown> - th query restore follow : let last answer previous query ( 0 i = 1 ) xi = ( ( pi + last ) mod n ) + 1 ki = ( qi + last ) mod n. print m integers i - th equal answer i - th query,['data structures'],2300.0
61/E,romans attack time much <unknown> shapur ready defeat say : ` ` a <unknown> never afraid a hundred <unknown> '' nevertheless shapur find <unknown> roman army defeat give army a weakness number shapur 's opinion weakness army equal number triplets i j k i < j < k ai > aj > ak ax power man stand position x. roman army one special <unknown> — power people distinct help shapur find <unknown> romans first line input contain a single number n ( 3 ≤ n ≤ 106 ) — number men roman army next line contain n different positive integers ai ( 1 ≤ i ≤ n 1 ≤ ai ≤ 109 ) — power men roman army a single integer number weakness roman army please use % lld specificator read write 64 - bit integers c++ preffered use cout ( also may use % i64d ),['data structures'],1900.0
165/D,"let 's define a non - oriented connect graph n vertices n - 1 edge a beard vertices except perhaps one degree 2 1 ( exist one vertex whose degree two ) let us remind degree a vertex number edge connect let edge either black white initially edge black give description beard graph task analyze request follow type : vertices number integers 1 n edge number integers 1 n - 1 . first line input contain integer n ( 2 ≤ n ≤ 105 ) — number vertices graph next n - 1 line contain edge describe number vertices vi ui ( 1 ≤ vi ui ≤ n vi ≠ ui ) connect edge guarantee give graph connect form a beard graph self - loops multiple edge next line contain integer m ( 1 ≤ m ≤ 3·105 ) — number request next m line contain request follow form : first a line contain integer type take value <unknown> 1 3 represent request type type = 1 current request a request paint edge black case addition number type line contain integer i d ( 1 ≤ i d ≤ n - 1 ) represent number edge paint type = 2 current request a request paint edge white form similar previous request type = 3 current request a request find distance case addition type line contain two integers a b ( 1 ≤ a b ≤ n a equal b ) — number vertices distance must find number line separate exactly one space edge number order give input request ` ` find distance vertices a b '' print result path go along black edge vertices a b print ` ` -1 '' ( without quote ) print result order receive request separate number space line break first sample vertices 1 2 connect edge number 1 vertices 2 3 connect edge number 2 . repaint edge number 2 vertex reachable one along black edge specifically shortest path 1 3 go along edge paint edge number 2 white vertex 3 end cut vertices , path exist vertex along black edge",['data structures'],2100.0
217/E,"professor bajtocy conduct experiment alien dna discover subject <unknown> mutations — mutation happen way : continuous subsequence alien dna become active copy copy get mangle insert right original subsequence mangle copy activate continuous subsequence form first join elements even position subsequence join elements odd ones end , activate subsequence consist 11 elements represent s1s2 ... <unknown> mangle copy <unknown> example original sequence ` ` <unknown> '' mutation happen segment [ 2 4 ] ( activate subsequence ` ` <unknown> '' ) mutate dna : ` ` <unknown> '' mangle copy activate subsequence mark bold <unknown> professor bajtocy write original dna sequence mutations <unknown> happen ask recover first k elements dna sequence mutations first line input contain original dna sequence consist letter ` ` a '' ` ` c '' ` ` t '' ` ` g '' exceed 3·106 length second line contain a single integer k ( 1 ≤ k ≤ 3·106 ) third line contain a single integer n ( 0 ≤ n ≤ 5000 ) — number mutations next n line describe mutations chronological order — mutation describe two number li ri ( 1 ≤ li ≤ ri ≤ 109 ) mean continuous subsequence [ li ri ] become active <unknown> join mangle copy guarantee input data correct , mutation act non - existing elements dna sequence result dna sequence least k elements assume dna elements index start 1 notation [ l r ] mean continuous subsequence dna sequence consist r - l + 1 elements start l - th dna sequence element end r - th dna sequence element output a single line contain first k letter mutate dna sequence second example first mutation sequence ` ` <unknown> '' second mutation 's ` ` <unknown> ''",['data structures'],2800.0
226/E,berland feudal own exactly one castle castle belong exactly one feudal feudal except one ( king ) subordinate another feudal a feudal number vassals ( subordinate ) castle connect roads allow move along roads ways two castle a road owner one castle a direct subordinate owner year exactly one two events may happen berland let 's consider second event detail journey a b short knight might want stop a castle encounter way rest however ca n't stop castle : <unknown> n't let stay castle desecrate enemy 's <unknown> a castle desecrate attack year y. knight choose k - th castle encounter start a ( castle a b n't take consideration ) n't attack years y + 1 till current year knight n't remember castle attack years ask court <unknown> aka help ' ve get a sequence events berland history tell knight city stop else deliver sad news — path city a city b less k cities meet requirements knight wo n't able rest first input line contain integer n ( 2 ≤ n ≤ 105 ) — number feudals next line contain n space - separated integers : i - th integer show either number i - th feudal 's master a 0 i - th feudal king third line contain integer m ( 1 ≤ m ≤ 105 ) — number query follow m line describe events i - th line ( line index start 1 ) contain description event occur year i. event characterise type ti ( 1 ≤ ti ≤ 2 ) description first type event look two space - separated integers ti ci ( ti = 1 ; 1 ≤ ci ≤ n ) ci number castle attack barbarians i - th year description second type contain five space - separated integers : ti ai bi ki yi ( ti = 2 ; 1 ≤ ai bi ki ≤ n ; ai ≠ bi ; 0 ≤ yi < i ) ai number castle knight set bi number castle knight go ki yi k y second event 's description consider feudals index 1 n. guarantee one king among feudals guarantee first type events value ci different second type event print integer — number castle knight must stay rest -1 cover distance ai bi without a rest separate answer <unknown> print answer order second type events give input first sample castle 2 knight 's way castle 1 castle 3 . knight cover path 1 - 3 first time castle 2 wo n't desecrate enemy knight stay second year castle 2 become desecrate knight wo n't anywhere stay next two years ( find a castle n't desecrate years 1 2 correspondingly important ) fifth year knight wo n't consider castle 2 desecrate stay,['data structures'],2900.0
339/D,xenia beginner programmer a sequence a consist 2n non - negative integers : a1 a2 ... a2n xenia currently study bite operations better understand work xenia decide calculate value v a. namely take several iterations calculate value v. first iteration xenia write a new sequence a1 a2 a3 a4 ... a2n - 1 a2n consist 2n - 1 elements word write bit - wise adjacent elements sequence a. second iteration xenia write bitwise exclusive adjacent elements sequence obtain first iteration third iteration xenia write bitwise adjacent elements sequence obtain second iteration ; operations bitwise exclusive bitwise alternate end obtain a sequence consist one element element v. let 's consider example suppose sequence a = ( 1 2 3 4 ) let 's write transformations ( 1 2 3 4 ) → ( 1 2 = 3 3 4 = 7 ) → ( 3 xor 7 = 4 ) result v = 4 . give xenia 's initial sequence calculate value v a give sequence would easy give additional m query query a pair integers p b. query p b mean need perform assignment ap = b. query need print new value v new sequence a. first line contain two integers n m ( 1 ≤ n ≤ 17 1 ≤ m ≤ 105 ) next line contain 2n integers a1 a2 ... a2n ( 0 ≤ ai < 230 ) next m line contain query i - th line contain integers pi bi ( 1 ≤ pi ≤ 2n 0 ≤ bi < 230 ) — i - th query print m integers — i - th integer denote value v sequence a i - th query information bite operations follow link : http : //en.wikipedia.org / wiki / <unknown>,['data structures'],1700.0
442/D,adam get a root tree ( connect non - directed graph without cycle ) immediately start color formally assign a color edge tree meet follow two condition : tree paint equally good adam let 's consider path vertex root let 's call number distinct color path cost vertex cost tree 's color maximum cost among vertexes help adam determine minimum possible cost paint tree initially adam 's tree consist a single vertex number one root one move adam add a new vertex already exist one new vertex get number equal minimum positive available integer operation need calculate minimum cost color result tree first line contain integer n ( 1 ≤ n ≤ 106 ) — number time a new vertex add second line contain n number pi ( 1 ≤ pi ≤ i ) — number vertexes add another vertex print n integers — minimum cost tree paint addition figure show one possible variants paint a tree sample last moment cost vertexes number 11 12 equal 3,['data structures'],2600.0
1045/J,since astronauts <unknown> xi mission finish mission moon big fan famous <unknown> decide spend fun time return earth hence create a call ` ` <unknown> challenge '' game team astronauts give map craters moon direct bidirectional paths craters others safe ` ` <unknown> '' direct paths color one color unique path two craters goal game find two craters give array color appear time continuous subarray path two craters ( overlap <unknown> count ) help favorite team win make a program give map answer query follow type : two craters array color answer many time give array appear continuous subarray path first <unknown> second color represent lowercase english alphabet letter first line integer $$$ n $$$ $$$ ( 2 \leq n \leq 100000 ) $$$ — number craters moon craters numerate number $$$ 1 $$$ $$$ n $$$ next $$$ n-1 $$$ line three value $$$ u v l $$$ $$$ ( 1 \leq u v \leq n l \in \ { a ... <unknown> } ) $$$ — denote a direct path color $$$ l $$$ craters $$$ u $$$ $$$ v $$$ next line contain integer $$$ q $$$ $$$ ( 1 \leq q \leq 100000 ) $$$ — number query next $$$ q $$$ line contain three value $$$ u v $$$ $$$ ( 1 \leq u v \leq n ) $$$ $$$ s $$$ $$$ ( |s| \leq 100 ) $$$ $$$ u $$$ $$$ v $$$ two <unknown> find many time array color $$$ s $$$ ( represent string ) appear path $$$ u $$$ $$$ v $$$ query output one number represent number occurrences array s path $$$ u $$$ $$$ v $$$,['data structures'],2600.0
1076/E,vasya a tree consist $$$ n $$$ vertices root vertex $$$ 1 $$$ first vertices $$$ 0 $$$ write let $$$ d ( i j ) $$$ distance vertices $$$ i $$$ $$$ j $$$ i.e number edge shortest path $$$ i $$$ $$$ j $$$ also let 's denote $$$ k $$$ -subtree vertex $$$ x $$$ — set vertices $$$ y $$$ next two condition meet : vasya need process $$$ m $$$ query $$$ i $$$ -th query a triple $$$ v_i $$$ $$$ d_i $$$ $$$ x_i $$$ query vasya add value $$$ x_i $$$ vertex $$$ d_i $$$ -subtree $$$ v_i $$$ report vasya value write vertices tree process query first line contain single integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) — number vertices tree next $$$ n - 1 $$$ line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ ) — edge vertices $$$ x $$$ $$$ y $$$ <unknown> give graph a tree next line contain single integer $$$ m $$$ ( $$$ 1 \le m \le 300000 $$$ ) — number query next $$$ m $$$ line contain three integers $$$ v_i $$$ $$$ d_i $$$ $$$ x_i $$$ ( $$$ 1 \le v_i \le n $$$ $$$ 0 \le d_i \le 1000000000 $$$ $$$ 1 \le x_i \le 1000000000 $$$ ) — description $$$ i $$$ -th query print $$$ n $$$ integers $$$ i $$$ -th integers value write $$$ i $$$ -th vertex process query first <unknown> initial value vertices $$$ 0 0 0 0 0 $$$ first query value equal $$$ 1 1 1 0 0 $$$ second query value equal $$$ 1 11 1 0 0 $$$ third query value equal $$$ 1 11 1 100 0 $$$,['data structures'],1900.0
1740/H,give a root tree define value vertex $$$ u $$$ tree recursively mex $$$ ^\dagger $$$ value children note children <unknown> particular value a leaf $$$ 0 $$$ pak chanek a root tree initially contain a single vertex index $$$ 1 $$$ root pak chanek go $$$ q $$$ query $$$ i $$$ -th query pak chanek give integer $$$ x_i $$$ pak chanek need add a new vertex index $$$ i+1 $$$ child vertex $$$ x_i $$$ add new vertex pak chanek need recalculate value vertices report sum value vertices current tree $$$ ^\dagger $$$ mex ( minimum exclude ) array smallest non - negative integer belong array example mex $$$ [ <unknown> ] $$$ $$$ 3 $$$ mex $$$ [ <unknown> ] $$$ $$$ 0 $$$ first line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 300000 $$$ ) — number operations next $$$ q $$$ line contain a single integer $$$ x_i $$$ ( $$$ 1 \leq x_i \leq i $$$ ) — description $$$ i $$$ -th query query print a line contain integer represent sum new value vertices tree add vertex first example tree $$$ 6 $$$ -th query look like sum value vertices $$$ 0 + 0 + 1 + 0 + 1 + 2 + <unknown> $$$,['data structures'],3300.0
1767/F,give a root tree consist $$$ n $$$ vertices vertex $$$ 1 $$$ root vertex integer write ; integer $$$ val_i $$$ vertex $$$ i $$$ give $$$ q $$$ query tree $$$ i $$$ -th query represent two vertices $$$ u_i $$$ $$$ v_i $$$ answer query consider vertices $$$ w $$$ lie subtree $$$ u_i $$$ $$$ v_i $$$ ( a vertex subtrees count twice ) vertices two subtrees list integers write find integer maximum number occurrences multiple integers maximum number occurrences minimum among answer first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number vertices tree second line contain $$$ n $$$ integers $$$ <unknown> <unknown> \dots <unknown> $$$ ( $$$ 1 \le val_i \le 200000 $$$ ) — number write vertices $$$ n - 1 $$$ line follow contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ ) represent edge vertices $$$ x $$$ $$$ y $$$ edge form a tree next line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query process $$$ q $$$ line follow $$$ i $$$ -th contain two number $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ) — root subtrees $$$ i $$$ -th query query print one integer — number maximum amount occurrences correspond pair subtrees ( multiple number print minimum one among ) $$$ 1 $$$ -st query pair subtrees consist vertices $$$ [ 2 4 7 8 ] $$$ number write $$$ \ { 1 2 2 4\ } $$$ number $$$ 2 $$$ occur twice number — answer $$$ 2 $$$ $$$ 2 $$$ -nd query pair subtrees consist vertices $$$ [ 3 5 6 7 7 8 8 ] $$$ number write $$$ \ { 3 3 3 2 2 4 4\ } $$$ number $$$ 3 $$$ maximum number occurrences $$$ 4 $$$ -th query pair subtrees consist vertices $$$ [ 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 ] $$$ number write $$$ \ { 2 2 1 1 3 3 2 2 3 3 3 3 2 2 4 4\ } $$$ number $$$ 2 $$$ $$$ 3 $$$ common minimum $$$ 2 $$$,['data structures'],3100.0
1824/E,"luotianyi watch <unknown> make <unknown> find make a cartridge interest describe process make a cartridge clearly abstract original problem give follow problem give a tree $$$ t $$$ consist $$$ n $$$ vertices vertex value $$$ a_i $$$ $$$ b_i $$$ edge value $$$ c_j $$$ $$$ d_j $$$ aim build a tree $$$ t ' $$$ follow : let $$$ a $$$ minimum value $$$ a_i $$$ $$$ t ' $$$ $$$ c $$$ minimum value $$$ c_i $$$ $$$ t ' $$$ let $$$ b $$$ sum $$$ b_i $$$ $$$ t ' $$$ $$$ d $$$ sum value $$$ d_i $$$ $$$ t ' $$$ let $$$ \min ( a c ) \cdot ( b + d ) $$$ cost $$$ t ' $$$ need find maximum possible cost $$$ t ' $$$ first line contain one integer $$$ n $$$ ( $$$ <unknown> n \le 2\cdot 100000 $$$ ) — number vertices tree $$$ t $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1\le a_i\le 2\cdot 100000 $$$ ) $$$ i $$$ -th integer represent $$$ a_i $$$ value $$$ i $$$ -th vertex third line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1\le b_i\le 2\cdot 100000 $$$ ) $$$ i $$$ -th integer represent $$$ b_i $$$ value $$$ i $$$ -th vertex $$$ n-1 $$$ line follow $$$ j $$$ -th contain four integers $$$ x_j y_j c_j d_j $$$ ( $$$ 1\le x_j <unknown> <unknown> c_j <unknown> 2\cdot 100000 $$$ ) represent edge $$$ ( x_j y_j ) $$$ value $$$ c_j $$$ $$$ d_j $$$ respectively 's guarantee edge form a tree print a single integer — maximum possible cost $$$ t ' $$$ tree first example show statement tree second example show : $$$ a = 1 b = 18 c = 1 d = 17 $$$ cost $$$ \min ( 1,1 ) \cdot ( 18 + 17 ) = 35 $$$",['data structures'],3500.0
1741/G,kirill live a connect undirected graph $$$ n $$$ vertices $$$ m $$$ edge vertex $$$ 1 $$$ one fine even gather $$$ f $$$ friends $$$ i $$$ -th friend live vertex $$$ h_i $$$ friends vertex $$$ 1 $$$ $$$ i $$$ -th friend must get home vertex $$$ h_i $$$ even end time leave turn $$$ k $$$ ( $$$ k \le 6 $$$ ) friends cars would walk one give a ride one friend a car give a ride number friends without cars give a ride drive along one shortest paths house example graph a friend vertex $$$ <unknown> $$$ give a ride friends follow set vertices : $$$ [ 2 3 ] $$$ $$$ [ 2 4 ] $$$ $$$ [ 2 ] $$$ $$$ [ 3 ] $$$ $$$ [ 4 ] $$$ ca n't give a ride friend vertex $$$ 6 $$$ a set $$$ [ 3 4 ] $$$ kirill want friends possible walk help find minimum possible number first line input data contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 10000 $$$ $$$ n-1 \le m \le min ( 10000 $$$ $$$ \frac { n \cdot ( n - 1 ) } { 2 } $$$ $$$ ) $$$ ) — number vertices edge respectively next $$$ m $$$ line test case contain a description edge two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) — index vertices connect edge guarantee one edge pair vertices ( i.e multiple edge graph ) follow line contain number $$$ f $$$ ( $$$ 1 \le f \le 10000 $$$ ) — number kirill 's friends next line test case contain $$$ f $$$ integers : $$$ h_1 h_2 \dots <unknown> $$$ ( $$$ 2 \le h_i \le n $$$ ) — vertices live vertices may repeat next line set contain number $$$ k $$$ ( $$$ 1 \le k \le min ( 6 f ) $$$ ) — number friends without cars last line test case contain $$$ k $$$ integers : $$$ p_1 p_2 \dots p_k $$$ ( $$$ 1 \le p_i \le f $$$ $$$ p_i < p _ { i+1 } $$$ ) — index friends without cars guarantee sum $$$ n $$$ case exceed $$$ 10000 $$$ well sum $$$ m $$$ $$$ f $$$ output $$$ t $$$ line contain answer correspond test case answer output a single integer — minimum possible number friends walk first test case first example explain statement second test case first example two friends cars live vertex $$$ 5 $$$ one give a ride friends vertices $$$ 2 $$$ $$$ 3 $$$ second vertex $$$ 4 $$$ a friend vertex $$$ 6 $$$ walk,['dp'],2200.0
1779/F,misha ban play chess good since <unknown> cheat engine therefore retire decide become a <unknown> one day take a walk a park misha come across a root tree nod number $$$ 1 $$$ $$$ n $$$ root tree node $$$ 1 $$$ $$$ 1\le i\le n $$$ node $$$ i $$$ contain $$$ a_i $$$ stone misha recently learn a new spell <unknown> class want test a spell consist : misha perform $$$ 2n $$$ spell want remove stone tree formally want $$$ a_i=0 $$$ hold $$$ 1\leq i \leq n $$$ help perform spell ? a tree $$$ n $$$ nod a connect acyclic graph contain $$$ n-1 $$$ edge subtree node $$$ i $$$ set nod $$$ j $$$ $$$ i $$$ lie simple path $$$ 1 $$$ ( root ) $$$ j $$$ consider $$$ i $$$ contain subtree first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 2\cdot 100000 $$$ ) — size <unknown> second line contain array integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 31 $$$ ) describe number stone node initially third line contain array integers $$$ p_2 p_3 \ldots p_n $$$ ( $$$ 1 \leq p_i \leq i-1 $$$ ) $$$ p_i $$$ mean edge connect $$$ p_i $$$ $$$ i $$$ a valid sequence spell output $$$ -1 $$$ otherwise output a single integer $$$ q $$$ ( $$$ 0 \leq q \leq 2n $$$ ) first line — number perform spell second line output a sequence integers $$$ v_1 v_2 \ldots <unknown> $$$ ( $$$ 1 \leq v_i \leq n $$$ ) — $$$ i $$$ -th spell perform subtree node $$$ v_i $$$ please note order matter multiple solutions exist output n't minimize number operations please refer follow picture explanation third test first $$$ 4 $$$ spell show since last $$$ 2 $$$ nothing first picture represent tree initially number stone node write green change apply current spell highlight red,['dp'],2500.0
1799/H,"give a tree $$$ n $$$ vertices a hero $$$ k $$$ time follow operation : give initial tree a sequence write number find number ways make operations write number equal give number due answer big find modulo $$$ 998\,244\,353 $$$ two ways consider different operation edge remain part select differently first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 5000 $$$ ) — number vertices next $$$ n-1 $$$ line contain two integers $$$ s $$$ $$$ f $$$ ( $$$ 1 \leq s f \leq n $$$ $$$ s \neq f $$$ ) — description edge $$$ ( s f ) $$$ next line contain a single integer $$$ k $$$ ( $$$ 1 \leq k \leq \min { ( 6 n - 1 ) } $$$ ) — number operations next line contain $$$ k $$$ integers $$$ s_1 s_2 \ldots s_k $$$ ( $$$ n > s_1 > s_2 > \ldots > s_k \geq 1 $$$ ) — write number print a single integer — answer problem modulo $$$ 998\,244\,353 $$$ first test four possible ways make operations : second test two possible ways make operations :",['dp'],3200.0
1804/E,ada operate a network consist $$$ n $$$ servers $$$ m $$$ direct connections direct connection a pair distinct servers allow bidirectional transmission information two servers ada know $$$ m $$$ direct connections allow directly indirectly transmit information two servers network say server $$$ v $$$ a neighbor server $$$ u $$$ exist a direct connection two servers ada need configure network 's wrp ( weird rout protocol ) server $$$ u $$$ need select exactly one neighbor auxiliary server $$$ a ( u ) $$$ $$$ a ( u ) $$$ set rout work follow suppose server $$$ u $$$ want find a path server $$$ v $$$ ( different $$$ u $$$ ) see procedure either produce a correct path finish keep run forever thus <unknown> important ada configure network 's wrp properly goal assign auxiliary server $$$ a ( u ) $$$ server $$$ u $$$ give network assignment make possible construct a path server $$$ u $$$ server $$$ v $$$ use aforementioned procedure report assignment n't exist first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 20 $$$ $$$ n - 1 \leq m \leq \frac { n \cdot ( n - 1 ) } { 2 } $$$ ) — number servers number direct connections give network follow $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ u_i \ne v_i $$$ ) $$$ i $$$ -th line describe $$$ i $$$ -th direct connection guarantee one direct connection two servers guarantee a direct <unknown> route ( consist give direct connections ) two servers way assign auxiliary server $$$ a ( u ) $$$ server $$$ u $$$ a way wrp able find a path server $$$ u $$$ server $$$ v $$$ print ` ` '' line output otherwise print ` ` yes '' first line output second line output print $$$ n $$$ integers $$$ i $$$ -th integers equal $$$ a ( i ) $$$ – index auxiliary server server $$$ i $$$ forget must a direct connection server $$$ i $$$ server $$$ a ( i ) $$$ output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses,['dp'],2400.0
1804/H,"lara a safe lock a circle - shaped code lock consist a rotate arrow a <unknown> circumference around arrow input screen input button circumference lock split $$$ k $$$ equal section number $$$ 1 $$$ $$$ k $$$ clockwise order arrow always point one section section mark one first $$$ k $$$ letter english alphabet two section mark letter due lock limitations safe 's password a string length $$$ n $$$ consist first $$$ k $$$ letter english alphabet lara enter password rotate lock 's arrow press input button initially lock 's arrow point section $$$ 1 $$$ input screen empty one second one follow action lara recently find safe re - <unknown> take first $$$ k $$$ letter english alphabet assign sectors order like want re - arrange letter a way minimize number second take input password compute minimum number second number ways assign letter minimum number second achieve two ways assign letter sectors consider distinct exist least one <unknown> $$$ i $$$ assign different letter first line input contain two integers $$$ k $$$ $$$ n $$$ ( $$$ 2 \leq k \leq 16 $$$ $$$ 2 \leq n \leq 100\,000 $$$ ) — number sectors lock 's circumference length lara 's password respectively second line input contain a string length $$$ n $$$ consist first $$$ k $$$ lowercase letter english alphabet string password first line print minimum possible number second take lara enter password open safe assign letter sectors optimally second line print number ways assign letter optimally initial state optimal arrangements first example show figure initial state optimal arrangements second example show figure initial state optimal arrangements third example show figure",['dp'],3300.0
1739/E,"consider a hallway represent matrix $$$ 2 $$$ row $$$ n $$$ columns let 's denote cell intersection $$$ i $$$ -th row $$$ j $$$ -th column $$$ ( i j ) $$$ distance cells $$$ ( i_1 <unknown> ) $$$ $$$ ( i_2 <unknown> ) $$$ $$$ <unknown> - <unknown> + <unknown> - <unknown> $$$ a clean robot cell $$$ ( 1 1 ) $$$ cells hallway clean cells dirty ( cell robot clean ) want clean hallway go launch robot robot launch work follow least one cell dirty robot choose closest ( current cell ) cell among dirty move clean ( cell longer dirty ) clean a cell robot find closest dirty cell current cell , process repeat whole hallway clean however a <unknown> bug robot 's program moment multiple closest ( robot 's current position ) dirty cells robot malfunction want clean hallway a way robot n't malfunction launch robot clean ( possibly zero ) dirty cells however n't want much dirty work nice smart ( yet <unknown> ) robot note make a clean cell dirty calculate maximum possible number cells leave dirty launch robot n't malfunction first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number columns hallway two line follow denote $$$ 1 $$$ -st $$$ 2 $$$ -nd row hallway line contain $$$ n $$$ character 0 denote a clean cell 1 denote a dirty cell start cell robot $$$ ( 1 1 ) $$$ clean print one integer — maximum possible number cells leave dirty launch robot n't malfunction first example clean cell $$$ ( 1 2 ) $$$ path robot $$$ ( 1 1 ) \rightarrow ( 2 1 ) \rightarrow ( 2 2 ) $$$ second example leave hallway path robot $$$ ( 1 1 ) \rightarrow ( 1 2 ) \rightarrow ( 2 2 ) $$$ third example clean cell $$$ ( 1 2 ) $$$ path robot $$$ ( 1 1 ) \rightarrow ( 2 1 ) \rightarrow ( 2 3 ) \rightarrow ( 2 4 ) \rightarrow ( 1 4 ) $$$ fourth example hallway already clean maybe launch robot earlier ?",['dp'],2400.0
217/C,bytelandian institute <unknown> research ( <unknown> ) investigate properties two species bacteria name simply 0 1 . even a <unknown> bacteria two species difficult distinguish fact thing scientists possess able <unknown> a plant call formurosa scientists place a sample colonies bacteria formurosa 's leave activate a complicate nutrition process process color formurosa change reflect result a — possibly complicate — logical formula species bacteria involve constants operators | ( ) & ( ) ^ ( xor ) 0 plant turn red otherwise — turn blue example nutrition process formurosa describe formula : ( ( ( ? ^ ? ) | ? ) & ( <unknown> ? ) ) ; formurosa four leave ( ` ` ? '' sign denote leave ) place 0 1 0 0 respective leave result nutrition process ( ( ( 0 ^ 1 ) <unknown> ) & ( 1 ^ 0 ) ) = 1 therefore plant turn blue scientists n colonies bacteria know type ; thing know sure colonies type want attempt determine bacteria 's species repeat <unknown> formurosa evaluation must place exactly one sample every leaf plant however may use multiple sample one colony a single evaluation ; even cover whole plant bacteria one colony ! possible always determine species colony matter ( assume ) ? first line input contain a single integer n ( 2 ≤ n ≤ 106 ) — number colonies bacteria second line contain formula describe nutrition process formurosa line contain character « 0 » « 1 » « ? » « | » « & » « ^ » « ( » « ) » <unknown> follow grammar : formula consist 106 character always possible determine species colony output ` ` yes '' ( without quote ) otherwise output ` ` '' ( without quote ),['dp'],2600.0
582/E,problem consider boolean function four variables a b c d. variables a b c d logical take value 0 1 . define a function use follow grammar : < expression > : : = < variable > | ( < expression > ) < operator > ( < expression > ) < variable > : : = ' a ' | ' b ' | ' c ' | 'd ' | ' a ' | ' b ' | ' c ' | 'd ' < operator > : : = ' & ' | ' <unknown> large letter a b c d represent variables small letter represent negations example a = 1 character ' a ' correspond value 1 value character ' a ' correspond value 0 . character ' & ' correspond operation logical character ' | ' correspond operation logical give expression s define function f operations variables miss also know value function f ( a b c d ) n distinct set variable value count number ways restore elements miss expression result expression correspond give information function f give variable set value result rather large print remainder modulo 109 + 7 . first line contain expression s ( 1 ≤ |s| ≤ 500 ) character operators and/or variables replace character ' ? ' second line contain number n ( 0 ≤ n ≤ 24 ) — number integers set know value function f ( a b c d ) next n line contain descriptions set : i - th contain five integers ai bi ci di ei ( 0 ≤ ai bi ci di ei ≤ 1 ) separate space mean f ( ai bi ci di ) = ei guarantee tuples ( ai bi ci di ) distinct a single line print answer problem first sample two valid expressions ' c ' 'd ' second sample expressions look follow : ' ( a ) & ( a ) ' ' ( a ) & ( b ) ' ' ( a ) & ( c ) ' ' ( a ) & ( d ) ',['dp'],3000.0
1550/E,give a string $$$ s $$$ length $$$ n $$$ character either one first $$$ k $$$ lowercase latin letter a question mark ask replace every question mark one first $$$ k $$$ lowercase latin letter a way follow value maximize let $$$ f_i $$$ maximum length substring string $$$ s $$$ consist entirely $$$ i $$$ -th latin letter a substring a string a contiguous subsequence string $$$ i $$$ -th letter n't appear a string $$$ f_i $$$ equal $$$ 0 $$$ value a string $$$ s $$$ minimum value among $$$ f_i $$$ $$$ i $$$ $$$ 1 $$$ $$$ k $$$ maximum value string ? first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 1 \le k \le 17 $$$ ) — length string number first latin letter use second line contain a string $$$ s $$$ consist $$$ n $$$ character character either one first $$$ k $$$ lowercase latin letter a question mark print a single integer — maximum value string every question mark replace one first $$$ k $$$ lowercase latin letter first example question mark replace follow way : ` ` <unknown> '' $$$ f_1 = 4 $$$ $$$ f_2 = 4 $$$ thus answer $$$ 4 $$$ replace like also possible : ` ` <unknown> '' way $$$ f_1 = 4 $$$ $$$ f_2 = 6 $$$ however minimum still $$$ 4 $$$ second example one possible string ` ` <unknown> '' third example least one letter wo n't appear string thus minimum value $$$ f_i $$$ always $$$ 0 $$$,['dp'],2500.0
1721/E,give a string $$$ s $$$ consist lowercase latin letter ask $$$ q $$$ query : give another string $$$ t $$$ consist lowercase latin letter perform follow step : prefix function a string $$$ a $$$ a sequence $$$ p_1 p_2 \dots p _ { |a| } $$$ $$$ p_i $$$ maximum value $$$ k $$$ $$$ k < i $$$ $$$ a [ 1 .. k ] = a [ i - k+1 .. i ] $$$ ( $$$ a [ l .. r ] $$$ denote a contiguous substring a string $$$ a $$$ a position $$$ l $$$ a position $$$ r $$$ inclusive ) word 's longest proper prefix string $$$ a [ 1 .. i ] $$$ equal suffix length first line contain a non - empty string $$$ s $$$ ( $$$ 1 \le |s| \le 1000000 $$$ ) consist lowercase latin letter second line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 100000 $$$ ) — number query next $$$ q $$$ line contain a query : a non - empty string $$$ t $$$ ( $$$ 1 \le |t| \le 10 $$$ ) consist lowercase latin letter query print value prefix function a string $$$ <unknown> $$$ position $$$ <unknown> <unknown> \dots <unknown> $$$,['dp'],2200.0
115/D,let 's define unambiguous arithmetic expression ( <unknown> ) follow give a string consist digits ( ` ` 0 '' - ` ` 9 '' ) character ` ` - '' ` ` + '' ` ` * '' ` ` / '' task compute number different possible unambiguous arithmetic expressions bracket ( character ` ` ( ` ` ` ` ) '' ) unambiguous arithmetic expression remove become input string since answer may large print modulo 1000003 ( 106 + 3 ) first line a non - empty string consist digits ( ' <unknown> ' 9 ' ) character ' - ' ' + ' ' * ' and/or ' / ' length exceed 2000 . line n't contain space print a single integer represent number different unambiguous arithmetic expressions modulo 1000003 ( 106 + 3 ) bracket remove become equal input string ( character - by - character ) first example two possible unambiguous arithmetic expressions : second example three possible unambiguous arithmetic expressions :,['dp'],2600.0
1670/F,train icpc competitions team ` ` <unknown> see '' <unknown> upon a basic count problem many ` ` wrong answer '' <unknown> finally decide give destroy turn - <unknown> <unknown> want help up - solving problem give 4 integers $$$ n $$$ $$$ l $$$ $$$ r $$$ $$$ z $$$ count number array $$$ a $$$ length $$$ n $$$ contain non - negative integers : since answer large print modulo $$$ 1000000000 + 7 $$$ line contain four integers $$$ n $$$ $$$ l $$$ $$$ r $$$ $$$ z $$$ ( $$$ 1 \le n \le 1000 $$$ $$$ 1\le <unknown> r\le 10^ { 18 } $$$ $$$ 1\le <unknown> 10^ { 18 } $$$ ) print number array $$$ a $$$ satisfy requirements modulo $$$ 1000000000 + 7 $$$ follow array satisfy condition first sample : follow array satisfy condition second sample :,['dp'],2400.0
1679/E,"today a holiday <unknown> hall — oleh arrive <unknown> girls give a string oleh like gift a lot immediately think offer best friend follow problem give a string $$$ s $$$ length $$$ n $$$ consist first $$$ 17 $$$ lowercase latin letter { $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ \ldots $$$ $$$ p $$$ $$$ q $$$ } question mark $$$ q $$$ query query define a set pairwise distinct lowercase first $$$ 17 $$$ letter latin alphabet use replace question mark string $$$ s $$$ answer query sum number distinct substrings palindromes string obtain original string $$$ s $$$ replace question mark available character answer must calculate modulo $$$ 998\,244\,353 $$$ pay attention ! two substrings different start end position string different , number different substrings palindromes string aba $$$ 4 $$$ : a b a aba consider examples replace question mark letter example string aba ? ? <unknown> query { $$$ a $$$ $$$ b $$$ } get string <unknown> <unknown> get string pizza <unknown> abacaba aba ? fee <unknown> <unknown> recall a palindrome a string read leave right right leave first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le <unknown> $$$ ) — length string $$$ s $$$ second line contain string $$$ s $$$ consist $$$ n $$$ lowercase latin letter question mark guarantee letter string belong set { $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ \ldots $$$ $$$ p $$$ $$$ q $$$ } third line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query follow $$$ q $$$ line contain a single line $$$ t $$$ — a set character replace question mark ( $$$ 1 \le |t| \le 17 $$$ ) guarantee letter string belong set { $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ \ldots $$$ $$$ p $$$ $$$ q $$$ } occur query print one number — total number palindromic substrings string obtain string $$$ s $$$ modulo $$$ 998\,244\,353 $$$ consider first example first query get one string a result replace question mark — abaaaba follow palindrome substrings : third request get 4 line : abaaaba <unknown> <unknown> <unknown>",['dp'],2400.0
1707/F,"a transformation array positive integers $$$ a_1 a_2 \dots a_n $$$ define replace $$$ a $$$ array $$$ b_1 b_2 \dots b_n $$$ give $$$ b_i = <unknown> a _ { ( <unknown> n ) +1 } $$$ $$$ \oplus $$$ denote bitwise xor operation give integers $$$ n $$$ $$$ t $$$ $$$ w $$$ consider array $$$ c_1 c_2 \dots c_n $$$ ( $$$ 0 \le c_i \le <unknown> $$$ ) bugaboo exist array $$$ a_1 a_2 \dots a_n $$$ transform $$$ a $$$ $$$ t $$$ time $$$ a $$$ become $$$ c $$$ example $$$ n=6 $$$ $$$ t=2 $$$ $$$ <unknown> $$$ array $$$ [ 3,2,1,0,2,2 ] $$$ bugaboo give transform array $$$ [ 2,3,1,1,0,1 ] $$$ $$$ 2 $$$ time : $$$ $$$ [ 2,3,1,1,0,1 ] \to [ <unknown> 3,3\oplus 1,1\oplus 1,1\oplus 0,0\oplus 1,1\oplus 2 ] = [ 1,2,0,1,1,3 ] ; \\ [ 1,2,0,1,1,3 ] \to [ <unknown> <unknown> 0,0\oplus 1,1\oplus 1,1\oplus 3,3\oplus 1 ] = [ 3,2,1,0,2,2 ] $$$ $$$ array $$$ [ <unknown> ] $$$ bugaboo $$$ 4 > 2 ^ 2 - 1 $$$ array $$$ [ <unknown> ] $$$ also bugaboo ca n't give transform one array $$$ 2 $$$ time give array $$$ c $$$ position lose ( $$$ m $$$ position know first remain position lose ) $$$ q $$$ modifications modification change a position $$$ c $$$ a modification possibly change whether position lose know possibly <unknown> a position already give need calculate many possible array $$$ c $$$ ( arbitrary elements lose position ) bugaboos modification output $$$ i $$$ -th answer modulo $$$ p_i $$$ ( $$$ p_i $$$ a give array consist $$$ q $$$ elements ) first line contain four integers $$$ n $$$ $$$ m $$$ $$$ t $$$ $$$ w $$$ ( $$$ 2\le n\le 10000000 $$$ $$$ 0\le m\le \min ( n 100000 ) $$$ $$$ 1\le t\le 1000000000 $$$ $$$ 1\le <unknown> 30 $$$ ) $$$ i $$$ -th line follow $$$ m $$$ line contain two integers $$$ d_i $$$ $$$ e_i $$$ ( $$$ 1\le <unknown> n $$$ $$$ 0\le e_i < 2^w $$$ ) mean position $$$ d_i $$$ array $$$ c $$$ give $$$ c _ { d_i } = e_i $$$ guarantee $$$ 1\le d_1 < d_2 < \ldots < <unknown> n $$$ next line contain one number $$$ q $$$ ( $$$ 1\le <unknown> 100000 $$$ ) — number modifications $$$ i $$$ -th line follow $$$ q $$$ line contain three integers $$$ f_i $$$ $$$ g_i $$$ $$$ p_i $$$ ( $$$ 1\le <unknown> n $$$ $$$ <unknown> g_i < 2^w $$$ $$$ <unknown> p_i\le 1000000000 + 7 $$$ ) value $$$ <unknown> $$$ mean change position $$$ f_i $$$ array $$$ c $$$ a lose position otherwise mean change position $$$ f_i $$$ array $$$ c $$$ a know position $$$ c _ { f_i } = g_i $$$ value $$$ p_i $$$ mean need output $$$ i $$$ -th answer modulo $$$ p_i $$$ output contain $$$ q $$$ line denote answer first example $$$ n=3 $$$ $$$ t=1 $$$ $$$ w=1 $$$ let $$$ ? $$$ denote a lose position $$$ c $$$ first query $$$ c= [ 1,0,1 ] $$$ possible array $$$ [ 1,0,1 ] $$$ bugaboo give transform $$$ [ 0,1,1 ] $$$ answer $$$ 1\bmod <unknown> = 1 $$$ second query $$$ c= [ 1,1,1 ] $$$ possible array $$$ [ 1,1,1 ] $$$ bugaboo answer $$$ <unknown> <unknown> = 0 $$$ third query $$$ c= [ ? , 1,1 ] $$$ two possible array $$$ [ 1,1,1 ] $$$ $$$ [ 0,1,1 ] $$$ $$$ [ 0,1,1 ] $$$ bugaboo give transform $$$ [ 1,1,0 ] $$$ answer $$$ 1\bmod <unknown> $$$ fourth query $$$ c= [ ? , 1 ? ] $$$ four possible array $$$ [ 0,1,1 ] $$$ $$$ [ 1,1,0 ] $$$ bugaboos $$$ [ 1,1,0 ] $$$ give perform $$$ [ 1,0,1 ] $$$ answer $$$ <unknown> <unknown> $$$",['dp'],3500.0
1720/D1,easy version problem difference version $$$ a_i \le 200 $$$ give array $$$ n $$$ integers $$$ a_0 a_1 a_2 \ldots a _ { n - 1 } $$$ bryap want find longest beautiful subsequence array array $$$ b = [ b_0 b_1 \ldots b _ { m-1 } ] $$$ $$$ 0 \le b_0 < b_1 < \ldots < b _ { m - 1 } < n $$$ a subsequence length $$$ m $$$ array $$$ a $$$ subsequence $$$ b = [ b_0 b_1 \ldots b _ { m-1 } ] $$$ length $$$ m $$$ call beautiful follow condition hold : $$$ a \oplus b $$$ denote bitwise xor $$$ a $$$ $$$ b $$$ example $$$ 2 \oplus 4 = 6 $$$ $$$ 3 \oplus <unknown> $$$ bryap a simple person want know length longest subsequence help bryap find answer question first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 300000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_0 a_1 ... a _ { n-1 } $$$ ( $$$ 0 \leq a_i \leq 200 $$$ ) — elements array guarantee sum $$$ n $$$ test case exceed $$$ 300000 $$$ test case print a single integer — length longest beautiful subsequence first test case pick whole array a beautiful subsequence $$$ 1 \oplus 1 < 2 \oplus 0 $$$ second test case pick elements index $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$ ( $$$ 0 $$$ <unknown> ) elements hold : $$$ 2 \oplus 2 < 4 \oplus 1 $$$ $$$ 4 \oplus 4 < 1 \oplus 2 $$$,['dp'],1800.0
1327/G,give a string $$$ s $$$ array string $$$ [ t_1 t_2 \dots t_k ] $$$ string $$$ t_i $$$ consist lowercase latin letter a n ; $$$ s $$$ consist lowercase latin letter a n $$$ 14 $$$ question mark string $$$ t_i $$$ cost $$$ c_i $$$ — integer number value string $$$ t $$$ calculate $$$ \sum\limits _ { i = 1 } ^ { k } f ( t t_i ) \cdot c_i $$$ $$$ f ( t t_i ) $$$ number occurences string $$$ t_i $$$ $$$ t $$$ a substring example $$$ f ( \text { <unknown> } \text { aa } ) = 4 $$$ replace question mark $$$ s $$$ pairwise distinct lowercase latin letter a n value $$$ s $$$ maximum possible first line contain one integer $$$ k $$$ ( $$$ 1 \le k \le 1000 $$$ ) — number string array $$$ [ t_1 t_2 \dots t_k ] $$$ $$$ k $$$ line follow contain one string $$$ t_i $$$ ( consist lowercase latin letter a n ) one integer $$$ c_i $$$ ( $$$ 1 \le <unknown> \le 1000 $$$ $$$ -1000000 \le c_i \le 1000000 $$$ ) sum lengths string $$$ t_i $$$ exceed $$$ 1000 $$$ last line contain one string $$$ s $$$ ( $$$ 1 \le |s| \le 400000 $$$ ) consist lowercase latin letter a n question mark number question mark $$$ s $$$ greater $$$ 14 $$$ print one integer — maximum value $$$ s $$$ replace question mark pairwise distinct lowercase latin letter a n,['dp'],2800.0
1387/C,"<unknown> research binary viruses discover a method <unknown> a large family viruses whose <unknown> cod sequence zero ones virus originate a single gene ; simplicity genes denote integers $$$ 0 $$$ $$$ g - 1 $$$ moment time a virus a sequence genes mutation occur one genes sequence replace a certain sequence genes accord mutation table virus stop mutate consist genes $$$ 0 $$$ $$$ 1 $$$ instance follow mutation table : $$$ $$$ 2 \to \langle 0\ 1 \rangle \\ 3 \to \langle 2\ 0\ <unknown> 3 \to \langle 1\ <unknown> 4 \to \langle 0\ 3\ 1\ <unknown> 5 \to \langle 2\ <unknown> 5 \to \langle <unknown> $$$ $$$ a virus initially consist a single gene $$$ 4 $$$ could mutate follow : $$$ $$$ \langle 4 \rangle \to \langle \underline { 0\ 3\ 1\ 2 } \rangle \to \langle 0\ \underline { 2\ 0\ 0 } \ 1\ 2 \rangle \to \langle 0\ \underline { 0\ 1 } \ 0\ 0\ 1\ 2 \rangle \to \langle 0\ 0\ 1\ 0\ 0\ 1\ \underline { 0\ 1 } \rangle $$$ $$$ another way : $$$ $$$ \langle 4 \rangle \to \langle \underline { 0\ 3\ 1\ 2 } \rangle \to \langle 0\ \underline { 1\ 3 } \ 1\ 2 \rangle \to \langle 0\ 1\ 3\ 1\ \underline { 0\ 1 } \rangle \to \langle 0\ 1\ \underline { 2\ 0\ 0 } \ 1\ 0\ 1 \rangle \to \langle 0\ 1\ \underline { 0\ 1 } \ 0\ 0\ 1\ 0\ 1 \rangle $$$ $$$ viruses detect antibodies identify presence specific continuous fragment zero ones viruses ' cod example antibody react a fragment $$$ \langle 0\ 0\ 1\ 0\ 0 \rangle $$$ detect a virus $$$ \langle 0\ 0\ 1\ 0\ 0\ 1\ 0\ 1 \rangle $$$ detect a virus $$$ \langle 0\ 1\ 0\ 1\ 0\ 0\ 1\ 0\ 1 \rangle $$$ gene $$$ 2 $$$ $$$ <unknown> $$$ scientists wonder whether a give set antibodies enough detect viruses emerge mutations gene , want know length shortest virus detect may happen sometimes scientists n't antibodies course virus detect scientists interest length shortest possible virus emerge gene mutations first line input contain three integers $$$ g $$$ $$$ n $$$ $$$ m $$$ ( $$$ g > 2 $$$ $$$ n \geq g - 2 $$$ $$$ m \geq 0 $$$ ) specify number genes number row mutation table number antibodies follow $$$ n $$$ line contain descriptions row mutation table ; line begin two integers $$$ a $$$ $$$ k $$$ ( $$$ 2 \leq a < g $$$ $$$ k \geq 1 $$$ ) follow a sequence $$$ k $$$ integers $$$ b_1 b_2 \ldots b_k $$$ ( $$$ 0 \leq b_i < g $$$ ) encode row $$$ $$$ a \to \langle <unknown> <unknown> <unknown> b_k \rangle $$$ $$$ sum value $$$ k $$$ exceed $$$ 100 $$$ every integer $$$ 2 $$$ $$$ g - 1 $$$ appear table $$$ a $$$ least next $$$ m $$$ line contain descriptions antibodies ; line begin integer $$$ \ell $$$ ( $$$ \ell \geq 1 $$$ ) follow a sequence $$$ \ell $$$ integers $$$ c_1 c_2 \ldots <unknown> $$$ ( $$$ 0 \leq c_i \leq 1 $$$ ) describe antibody sum value $$$ \ell $$$ exceed $$$ 50 $$$ program need output exactly $$$ g - 2 $$$ line contain answer subsequent genes $$$ 2 $$$ $$$ g - 1 $$$ viruses mutate single gene detect give set antibodies need print word ` ` yes '' also need print viruses could originate gene ( happen sequence never stop mutate ) otherwise need print word ` ` '' follow integer denote minimal length <unknown> virus assume prepare input data value smaller $$$ 2^ { 63 } $$$ subtasks :",['dp'],2900.0
1400/F,give integer value $$$ x $$$ a string $$$ s $$$ consist digits $$$ 1 $$$ $$$ 9 $$$ inclusive a substring a string a contiguous subsequence string let $$$ f ( l r ) $$$ sum digits a substring $$$ s [ l .. r ] $$$ let 's call substring $$$ s [ l_1 .. r_1 ] $$$ $$$ x $$$ -prime allow erase character string erase a character two result part string concatenate without change order minimum number character erase string $$$ x $$$ -prime substrings ? $$$ x $$$ -prime substrings give string $$$ s $$$ print $$$ 0 $$$ first line contain a string $$$ s $$$ ( $$$ 1 \le |s| \le 1000 $$$ ) $$$ s $$$ contain digits $$$ 1 $$$ $$$ 9 $$$ inclusive second line contain integer $$$ x $$$ ( $$$ 1 \le x \le 20 $$$ ) print a single integer — minimum number character erase string $$$ x $$$ -prime substrings $$$ x $$$ -prime substrings give string $$$ s $$$ print $$$ 0 $$$ first example two $$$ 8 $$$ -prime substrings ` ` 8 '' ` ` 53 '' erase character get rid : ` ` 116285317 '' result string ` ` <unknown> '' contain $$$ 8 $$$ -prime substrings remove character also a valid answer : ` ` 116285317 '' second example erase ones third example $$$ 13 $$$ -prime substrings substrings sum digits equal $$$ 13 $$$ fourth example neither ` ` 34 '' ` ` <unknown> '' a string thus erase either <unknown> <unknown> $$$ 5 $$$ n't matter,['dp'],2800.0
86/C,` ` <unknown> space completely style days unlike <unknown> problems '' — think <unknown> woll change subject study <unknown> analyse result sequence face follow problem concern dna sequence think a dna sequence arbitrary string uppercase letter ` ` a '' ` ` c '' ` ` g '' ` ` t '' ( course a simplify <unknown> ) let w a long dna sequence s1 s2 ... sm — collection short dna sequence let us say collection filter w iff w cover sequence collection certainly substrings correspond different position string may intersect even cover formally : denote |w| length w let symbols w number 1 |w| position i w exist pair indices l r ( 1 ≤ l ≤ i ≤ r ≤ |w| ) substring w [ l ... r ] equal one elements s1 s2 ... sm collection woll want calculate number dna sequence a give length filter a give collection n't know deal help ! task find number different dna sequence length n filter collection { si } answer may appear large output modulo 1000000009 . first line contain two integer number n m ( 1 ≤ n ≤ 1000 1 ≤ m ≤ 10 ) — length string number sequence collection <unknown> next m line contain collection sequence si one per line si a nonempty string length greater 10 . string consist uppercase letter ` ` a '' ` ` c '' ` ` g '' ` ` t '' collection may contain identical string output contain a single integer — number string filter collection modulo 1000000009 ( 109 + 9 ) first sample a string filter ` ` a '' clearly one string : ` ` aa '' second sample exist exactly two different string satisfy condition ( see picture ),['dp'],2500.0
1592/C,"<unknown> face a problem since 's lazy solve ask help give a tree $$$ n $$$ nod $$$ i $$$ -th node value $$$ a_i $$$ assign $$$ i $$$ $$$ 1 $$$ $$$ n $$$ a reminder a tree $$$ n $$$ nod a connect graph $$$ n-1 $$$ edge want delete least $$$ 1 $$$ $$$ k-1 $$$ edge tree follow condition would hold : every connect component calculate bitwise xor value nod , value connect components possible achieve condition ? test contain multiple test case first line contain number test case $$$ t $$$ $$$ ( 1 \leq t \leq 5 \cdot 10000 ) $$$ description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ $$$ ( 2 \leq k \leq n \leq 100000 ) $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 ... a_n $$$ $$$ ( 1 \leq a_i \leq 1000000000 ) $$$ $$$ i $$$ -th next $$$ n-1 $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ $$$ <unknown> v_i $$$ ) mean 's edge nod $$$ u_i $$$ $$$ v_i $$$ guarantee give graph a tree guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case output a single string delete edge accord condition write output ` ` yes '' ( without quote ) otherwise output ` ` '' ( without quote ) print letter ` ` yes '' ` ` '' case ( upper lower ) show <unknown> achievable first third fifth test case second test case remove edge $$$ 5 $$$ connect components contain one node value $$$ 3 $$$ bitwise <unknown> $$$ 3 $$$ fourth test case tree : remove edge $$$ ( 4,5 ) $$$ bitwise xor first component $$$ a_1 \oplus a_2 \oplus a_3 \oplus a_4 = 1 \oplus 6 \oplus 4 \oplus 1 = 2 $$$ ( $$$ \oplus $$$ denote bitwise xor ) bitwise xor second component $$$ <unknown> = 2 $$$",['dp'],1700.0
427/D,police headquarter monitor signal different frequency level get two <unknown> encode string s1 s2 two different frequencies signal suspect two string two different criminals plan evil task try find a common substring minimum length two string substring must occur first string also must occur second string give two string s1 s2 consist lowercase latin letter find smallest ( length ) common substring p s1 s2 p a unique substring s1 also s2 see note formal definition substring <unknown> first line input contain s1 second line contain s2 ( 1 ≤ |s1| |s2| ≤ 5000 ) string consist lowercase latin letter print length smallest common unique substring s1 s2 common unique substrings s1 s2 print -1 . imagine string a = <unknown> ... a|a| |a| length string a ai ith letter string call string alal + <unknown> + 2 ... ar ( 1 ≤ l ≤ r ≤ |a| ) substring [ l r ] string a. substring [ l r ] unique a pair l1 r1 l1 ≠ l substring [ l1 r1 ] equal substring [ l r ] a,['dp'],2200.0
432/D,a string s = s1s2 ... s|s| |s| length string s si i - th character let 's introduce several definitions : task prefix string s match a suffix string s print number time occur string s a substring single line contain a sequence character s1s2 ... s|s| ( 1 ≤ |s| ≤ 105 ) — string s. string consist uppercase english letter first line print integer k ( 0 ≤ k ≤ |s| ) — number prefix match a suffix string s. next print k line line print two integers li ci number li ci mean prefix length li match suffix length li occur string s a substring ci time print pair li ci order increase li,['dp'],2000.0
1523/F,"william do work day enjoy play favorite video game game happen a 2d world start turn $$$ 0 $$$ william pick cell game world <unknown> , turn william may remain current location move current location ( x y ) one follow locations : ( x + 1 y ) ( x - 1 y ) ( x y + 1 ) ( x y - 1 ) <unknown> movement game $$$ n $$$ fast travel tower $$$ i $$$ -th tower locate location ( $$$ xa_i ya_i $$$ ) able instantly travel tower location game world must first activate <unknown> tower $$$ i $$$ happen moment player cell ( $$$ xa_i ya_i $$$ ) tower remain active throughout entire game william also know game $$$ m $$$ quest $$$ i $$$ -th quest complete instantly location ( $$$ xb_i yb_i $$$ ) turn $$$ t_i $$$ william want find maximal number quest able complete optimally traverse game world first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 0 \le n \le 14 1 \le m \le 100 $$$ ) number tower number quest respectively next $$$ n $$$ line contain two integers $$$ xa_i ya_i $$$ ( $$$ 1 \le xa_i ya_i \le 1000000 $$$ ) coordinate fast travel tower next $$$ m $$$ line contain two integers $$$ xb_i $$$ $$$ yb_i $$$ $$$ t_i $$$ ( $$$ 1 \le xb_i yb_i \le 1000000 $$$ $$$ 1 \le t_i \le 1000000000 $$$ ) coordinate quest turn may complete guarantee locations a test different print a single number — maximal number quest william able complete first sample test one possible sequence william 's action follow :",['dp'],3300.0
756/D,julia conduct experiment lab place several <unknown> <unknown> colonies a horizontal testtube different type bacteria distinguish color light <unknown> julia mark type bacteria small latin letter ` ` a '' ... ` ` z '' testtube divide n consecutive regions region occupy a single colony a certain bacteria type give moment hence population testtube moment describe a string n latin character sometimes a colony decide conquer another colony one adjacent regions happen attack colony immediately eliminate replace a colony type attack colony attack colony keep type note a colony attack neighbour within boundaries testtube moment one attack take place example consider a testtube population ` ` babb '' six options attack may happen next : pattern attack rather unpredictable julia wonder many different configurations bacteria testtube obtain a sequence attack take place ( possible attack happen ) since number large find modulo 109 + 7 . first line contain integer n — number regions testtube ( 1 ≤ n ≤ 5 000 ) second line contain n small latin letter describe initial population testtube print one number — answer problem modulo 109 + 7 . first sample population never change since bacteria type second sample three configurations possible : ` ` ab '' ( attack ) ` ` aa '' ( first colony conquer second colony ) ` ` bb '' ( second colony conquer first colony ) get answer third sample note one attack happen,['dp'],2400.0
822/E,first semester end know end first semester holiday begin holiday noora decide return <unknown> a <unknown> souvenir leha bring a sausage length m <unknown> everyone know sausage represent a string lowercase english letter length equal length sausage leha please gift immediately eat sausage realize a quite <unknown> act sausage a souvenir ! hacker immediately go <unknown> shop unfortunately another sausage length n shop however leha upset buy sausage come home decide cut purchase sausage several piece number piece start 1 leave right want select several piece glue together obtain sausage equal sausage noora give hacker glue two piece together number leave piece less number right piece besides know glue x piece noora notice <unknown> souvenir sausage upset course leha ’ t want upset girl hacker ask find whether able cut sausage buy glue piece noora n't notice anything formally give two string s t. length string s n length string t m. require select several pairwise non - intersecting substrings s concatenation order substrings appear s equal string t. denote f ( s t ) minimal number substrings choose concatenation equal string t. impossible choose substrings f ( s t ) = ∞ leha really want know whether ’ s true f ( s t ) ≤ x. first line contain single integer n ( 1 ≤ n ≤ 105 ) — length sausage buy leha i.e length string s. second line contain string s length n consist lowercase english letter third line contain single integer m ( 1 ≤ m ≤ n ) — length sausage buy noora i.e length string t. fourth line contain string t length m consist lowercase english letter fifth line contain single integer x ( 1 ≤ x ≤ 30 ) — maximum number piece sausage leha glue noora ’ t notice anything line print ` ` yes '' ( without quote ) leha able succeed create new sausage noora n't notice anything otherwise print ` ` '' ( without quote ) let 's consider first sample optimal answer leha cut sausage buy follow way : <unknown> = h + <unknown> + a + y + g + <unknown> number receive part 1 6 : <unknown> hacker glue part number 2 4 6 get sausage <unknown> equal one give noora thus glue three piece since x = 3 print ` ` yes '' ( without quote ) second sample sausages coincide sausages first sample however since x = 2 print ` ` '' ( without quote ),['dp'],2400.0
825/F,"ivan want write a letter friend letter a string s consist lowercase latin letter unfortunately ivan start write letter realise long write whole letter may take extremely long time want write compress version string s instead string compress version string s a sequence string c1 s1 c2 s2 ... ck sk ci decimal representation number ai ( without lead zero ) si string consist lowercase latin letter ivan write string s1 exactly a1 time string s2 exactly a2 time , result string s. length a compress version <unknown> + |s1| + <unknown> + |s2| ... <unknown> + <unknown> among compress versions ivan want choose a version length minimum possible help ivan determine minimum possible length line input contain one string s consist lowercase latin letter ( 1 ≤ |s| ≤ 8000 ) output one integer number — minimum possible length a compress version s. first example ivan choose compress version : c1 10 s1 a. second example ivan choose compress version : c1 1 s1 <unknown> third example ivan choose compress version : c1 2 s1 c c2 1 s2 z c3 4 s3 ab",['dp'],2400.0
906/E,hurricane come berland <unknown> <unknown> go check 's right favorite string <unknown> break a bite reverse non - intersecting substrings a photo string hurricane want restore original state use reverse minimum possible number substrings find substrings reverse give a string s — original state string string t — state string hurricane select k non - intersecting substrings t a way reverse substrings string equal s k minimum possible first line input contain string s second line contain string t. string length consist lowercase english letter 1 ≤ |s| = |t| ≤ 5·105 in first line print k — minimum number substrings reverse next output k line line contain two integers li ri mean reverse substring symbol number li symbol ri ( string 1 - indexed ) substrings n't intersect multiple answer print 's impossible restore string output -1,['dp'],3300.0
1523/D,william host a party $$$ n $$$ trader friends start a <unknown> various currencies trade 's issue : trader friends like every currency like currencies others william 's friend $$$ i $$$ know whether like currency $$$ j $$$ $$$ m $$$ currencies total also know a trader may like $$$ p $$$ currencies friends need common topic <unknown> need find largest cardinality ( possibly empty ) subset currencies least $$$ \lceil \frac { n } { 2 } \rceil $$$ friends ( round ) like currency subset first line contain three integers $$$ n m $$$ $$$ p $$$ $$$ ( 1 \le n \le 2 \cdot 100000 1 \le p \le m \le 60 1 \le p \le 15 ) $$$ number trader friends number currencies maximum number currencies friend like next $$$ n $$$ line contain $$$ m $$$ character $$$ j $$$ -th character $$$ i $$$ -th line $$$ 1 $$$ friend $$$ i $$$ like currency $$$ j $$$ $$$ 0 $$$ otherwise guarantee number ones line exceed $$$ p $$$ print a string length $$$ m $$$ define subset currencies maximum size like least half friends currencies belong subset must <unknown> character $$$ 1 $$$ multiple answer print first sample test case first currency like least $$$ \lceil \frac { 3 } { 2 } \rceil = 2 $$$ friends therefore 's easy demonstrate a better answer find second sample test case answer include $$$ 2 $$$ currencies like friends $$$ 1 $$$ $$$ 2 $$$ $$$ 5 $$$ test case currencies like least half friends use achieve a larger subset size,['dp'],2400.0
845/F,polycarp own a shop capital berland recently criminal activity capital increase polycarp think establish better security storehouse shop storehouse represent a matrix n row m columns element matrix either ( empty space ) x ( a wall ) polycarp want hire guard ( possibly zero ) watch storehouse guard cell matrix protect every cell right cell every cell bottom cell nearest wall formally guard stand cell ( x0 y0 ) protect cell ( x1 y1 ) condition meet : guard place empty cells ( protect empty cells ) plan place guard set cells guard place ( course two plan different exist least one cell include first plan include second plan vice versa ) polycarp call a plan suitable one empty cell protect polycarp want know number suitable plan since large output modulo 109 + 7 . first line contain two number n m — length width storehouse ( 1 ≤ n m ≤ 250 1 ≤ nm ≤ 250 ) n line follow ith line contain a string consist m character — ith row matrix represent storehouse character either x. output number suitable plan modulo 109 + 7 . first example put least one guard three possible arrangements : one guard cell ( 1 1 ) one guard cell ( 1 3 ) two guard cells,['dp'],2500.0
850/C,mojtaba arpa play a game a list n number game a player 's turn choose a number pk ( p a prime number k a positive integer ) pk divide least one number list number list divisible pk call x player delete x add list player make a valid choice p k lose mojtaba start game players alternatively make move determine one players winner players play optimally first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number elements list second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — elements list mojtaba win print ` ` mojtaba '' otherwise print ` ` arpa '' ( without quote ) print letter case ( upper lower ) first sample test mojtaba ca n't move second sample test mojtaba choose p = 17 k = 1 list change [ 1 1 1 1 ] third sample test mojtaba choose p = 17 k = 1 arpa choose p = 17 k = 1 win mojtaba choose p = 17 k = 2 arpa choose p = 17 k = 1 win,['dp'],2200.0
855/E,harry come know <unknown> <unknown> <unknown> 's locket a horcrux locket present earlier 12 <unknown> place home <unknown> black 's mother steal present ministry magic office <unknown> umbridge harry 's former defense dark <unknown> teacher harry ron <unknown> <unknown> ministry upon reach umbridge 's office observe a code lock a puzzle ask calculate count magic number two integers l r ( inclusive ) harry remember <unknown> time umbridge define a magic number a number convert a give base b digits 0 b - 1 appear even number time representation without lead zero answer q query <unknown> office query three integers bi li ri base range find count magic number first line input contain q ( 1 ≤ q ≤ 105 ) — number query next q line contain three space separate integers bi li ri ( 2 ≤ bi ≤ 10 1 ≤ li ≤ ri ≤ 1018 ) output q line contain a single integer answer correspond query sample test case 1 first query convert number 4 9 base 2 get : base 2 representation 9 even number 1 0 . thus answer 1,['dp'],2200.0
865/E,copy large hexadecimal ( base 16 ) string hand error <unknown> n't stop people ' ve discover a bug code likely cause someone make a mistake copy a string suspect whoever copy string change digits string length string may permute digits arbitrarily example original string <unknown> may change <unknown> <unknown> abc <unknown> unfortunately n't access original string copy string know length string numerical absolute difference give difference a hexadecimal string s zero - <unknown> equal length original copy string determine smallest possible numerical value original string input contain a hexadecimal string s consist digits 0 9 lowercase english letter a f length 14 . least one character non - zero possible print ` ` '' ( without quote ) otherwise print lowercase hexadecimal string correspond smallest possible numerical value include necessary lead zero length correct numerical value a hexadecimal string compute multiply digit <unknown> power 16 start rightmost digit multiply 160 . hexadecimal digits represent value greater 9 represent letter : a = 10 b = 11 c = 12 d = 13 e = 14 f = 15 . example numerical value <unknown> 0·163 + <unknown> + <unknown> + <unknown> = 3870 numerical value 00f1 0·163 + 0·162 + <unknown> + <unknown> = 241 numerical value 100f <unknown> + 0·162 + <unknown> + <unknown> = 4111 . since 3870 + 241 = 4111 00f1 a permutation 100f 00f1 a valid answer second test case,['dp'],3300.0
868/C,snark philip prepare problemset upcoming <unknown> - qualification round <unknown> - <unknown> - finals a bank n problems want select non - empty subset a <unknown> experience team participate contest team already know problems make contest interest team know half select problems determine snark philip make interest problemset ! first line contain two integers n k ( 1 ≤ n ≤ 105 1 ≤ k ≤ 4 ) — number problems number experience team next n line contain k integers equal 0 1 . j - th number i - th line 1 j - th team know i - th problem 0 otherwise print ` ` yes '' ( quote clarity ) possible make interest problemset ` ` '' otherwise print character either <unknown> lowercase ( ` ` yes '' ` ` yes '' valid answer ` ` yes '' ) first example ca n't make interest problemset first team know problems second example choose first third problems,['dp'],1500.0
932/G,give a string s find number ways split s substrings k substrings ( p1 p2 p3 ... pk ) partition pi = pk - i + 1 i ( 1 ≤ i ≤ k ) k even since number ways large print modulo 109 + 7 . line input contain a string s ( 2 ≤ |s| ≤ 106 ) even length consist lowercase latin letter print one integer number ways partition string modulo 109 + 7 . first case way partition string <unknown> second case string partition <unknown> <unknown> <unknown>,['dp'],2900.0
903/F,give a matrix f 4 row n columns element matrix either asterisk ( * ) a dot ( . ) may perform follow operation arbitrary number time : choose a square submatrix f size k × k ( 1 ≤ k ≤ 4 ) replace element choose submatrix a dot choose a submatrix size k × k cost ak coin minimum number coin pay replace asterisk dot ? first line contain one integer n ( 4 ≤ n ≤ 1000 ) — number columns f. second line contain 4 integers a1 a2 a3 a4 ( 1 ≤ ai ≤ 1000 ) — cost replace square submatrix size 1 × 1 2 × 2 3 × 3 4 × 4 respectively four line follow contain n character denote a row matrix f. character either a dot asterisk print one integer — minimum number coin replace asterisk dot first example spend 8 coin replace submatrix 3 × 3 top - left corner 1 coin replace 1 × 1 submatrix bottom - right corner second example best option replace 4 × 4 submatrix contain columns 2 – 5 2 × 2 submatrix consist row 2 – 3 columns 6 – 7 . third example select submatrix 3 × 3 top - left corner submatrix 3 × 3 consist row 2 – 4 columns 2 – 4,['dp'],2200.0
913/E,"give a boolean function three variables define truth table need find expression minimum length equal function expression may consist : one expression minimum length exist find lexicographically smallest one operations standard priority highest priority go lowest priority expression satisfy follow grammar : e : : = e ' | ' t | tt : : = t ' & ' f | <unknown> : : = ' ! ' f | ' ( ' e ' ) ' | ' x ' | ' y ' | ' <unknown> first line contain one integer n — number function input ( 1 ≤ n ≤ 10 000 ) follow n line contain descriptions function i - th contain a string length 8 consist digits 0 1 — truth table i - th function digit position j ( 0 ≤ j < 8 ) equal value function case , output n line i - th line contain expression minimum length equal i - th function one expression output lexicographically smallest expressions satisfy give grammar n't contain white space truth table second function :",['dp'],2400.0
1006/F,a rectangular grid size $$$ n \times m $$$ cell a number write ; number cell ( $$$ i j $$$ ) $$$ a _ { i j } $$$ task calculate number paths upper - left cell ( $$$ 1 1 $$$ ) bottom - right cell ( $$$ n m $$$ ) meet follow constraints : find number paths give grid first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n m \le 20 $$$ $$$ 0 \le k \le 10^ { 18 } $$$ ) — height width grid number $$$ k $$$ next $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th element $$$ i $$$ -th line $$$ a _ { i j } $$$ ( $$$ 0 \le a _ { i j } \le 10^ { 18 } $$$ ) print one integer — number paths ( $$$ 1 1 $$$ ) ( $$$ n m $$$ ) xor sum equal $$$ k $$$ paths first example : paths second example :,['dp'],2100.0
812/B,people leave light <unknown> leave a waste resources a <unknown> <unknown> sagheer wait till students professors leave university build go turn light build consist n floor stairs leave right side floor m room line a corridor connect leave right stairs pass room word build represent a rectangle n row m + 2 columns first last columns represent stairs m columns middle represent room sagheer stand grind floor leave stairs want turn light a way go <unknown> light floor stand course sagheer must visit a room turn light take one minute sagheer go next floor use stairs move current room / stairs a neighbor room / stairs floor take time switch light room currently stand help sagheer find minimum total time turn light note sagheer go back start position visit room light already switch first line contain two integers n m ( 1 ≤ n ≤ 15 1 ≤ m ≤ 100 ) — number floor number room floor respectively next n line contain build description line contain a binary string length m + 2 represent a floor ( leave stairs m room right stairs ) 0 indicate light 1 indicate light floor list top bottom last line represent grind floor first last character string represent leave right stairs respectively always 0 . print a single integer — minimum total time need turn light first example sagheer go room 1 grind floor go room 2 second floor use leave right stairs second example go fourth room grind floor use right stairs go fourth room second floor use right stairs go second room last floor third example walk whole corridor alternate leave right stairs floor,['dp'],1600.0
1620/G,a sequence string $$$ [ t_1 t_2 \dots t_m ] $$$ let 's define function $$$ f ( [ t_1 t_2 \dots t_m ] ) $$$ number different string ( include empty string ) subsequences least one string $$$ t_i $$$ $$$ f ( [ ] ) = 0 $$$ ( i. e. number string empty sequence $$$ 0 $$$ ) give a sequence string $$$ [ s_1 s_2 \dots s_n ] $$$ every string sequence consist lowercase latin letter sort ( i. e. string begin several ( maybe zero ) character a several ( maybe zero ) character b ... end several ( maybe zero ) character z ) $$$ 2^n $$$ subsequences $$$ [ s_1 s_2 \dots s_n ] $$$ calculate value function $$$ f $$$ modulo $$$ 998244353 $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 23 $$$ ) — number string $$$ n $$$ line follow $$$ i $$$ -th line contain string $$$ s_i $$$ ( $$$ 1 \le |s_i| \le 20000 $$$ ) consist lowercase latin letter string $$$ s_i $$$ sort since print $$$ 2^ { 23 } $$$ integers would really <unknown> follow : $$$ 2^n $$$ subsequences ( denote $$$ [ s _ { i_1 } s _ { i_2 } \dots s _ { i_k } ] $$$ ) calculate $$$ f ( [ s _ { i_1 } s _ { i_2 } \dots s _ { i_k } ] ) $$$ take modulo $$$ 998244353 $$$ multiply $$$ k \cdot ( i_1 + i_2 + \dots + i_k ) $$$ print xor $$$ 2^n $$$ integers get indices $$$ i_1 i_2 \dots i_k $$$ description subsequences $$$ 1 $$$ -indexed ( i. e. $$$ 1 $$$ $$$ n $$$ ),['dp'],2400.0
1030/E,"vasya a sequence $$$ a $$$ consist $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ vasya may <unknown> follow operation : choose number sequence swap pair bits binary representation example vasya transform number $$$ 6 $$$ $$$ ( \dots <unknown> ) $$$ $$$ 3 $$$ $$$ ( \dots <unknown> ) $$$ $$$ 12 $$$ $$$ ( \dots <unknown> ) $$$ $$$ <unknown> $$$ $$$ ( \dots <unknown> ) $$$ many others vasya use operation ( possibly zero ) number time number sequence vasya name a sequence good one , use operation mention obtain sequence bitwise exclusive elements equal $$$ 0 $$$ give sequence $$$ a_1 a_2 \ldots a_n $$$ vasya 'd like calculate number integer pair $$$ ( l r ) $$$ $$$ 1 \le l \le r \le n $$$ sequence $$$ a_l a _ { l + 1 } \dots a_r $$$ good first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) — length sequence second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 10^ { 18 } $$$ ) — sequence $$$ a $$$ print one integer — number pair $$$ ( l r ) $$$ $$$ 1 \le l \le r \le n $$$ sequence $$$ a_l a _ { l + 1 } \dots a_r $$$ good first example pair $$$ ( 2 3 ) $$$ $$$ ( 1 3 ) $$$ valid pair $$$ ( 2 3 ) $$$ valid since $$$ a_2 = 7 \rightarrow 11 $$$ $$$ a_3 = 14 \rightarrow 11 $$$ $$$ 11 \oplus 11 = 0 $$$ $$$ \oplus $$$ — bitwise exclusive pair $$$ ( 1 3 ) $$$ valid since $$$ a_1 = 6 \rightarrow 3 $$$ $$$ a_2 = 7 \rightarrow 13 $$$ $$$ a_3 = 14 \rightarrow 14 $$$ $$$ 3 \oplus 13 \oplus 14 = 0 $$$ second example pair $$$ ( 1 2 ) $$$ $$$ ( 2 3 ) $$$ $$$ ( 3 4 ) $$$ $$$ ( 1 4 ) $$$ valid",['dp'],2000.0
780/F,"a couple friends axel marston travel across country bitland n towns bitland pair towns connect one - <unknown> roads road bitland either a pedestrian road a bike road multiple roads pair towns may even a road a town however pair roads share start destination towns along type simultaneously friends locate town 1 plan travel route axel enjoy walk marston prefer bike order choose a route diverse equally interest friends agree upon follow procedure choose road type travel : first step route look follow : p <unknown> <unknown> <unknown> <unknown> , friends start travel town 1 via <unknown> roads choose next road accord next character route type time impossible choose next road friends terminate travel fly home instead help friends find longest possible route travel along roads bitland accord road type choose procedure describe a route 1018 roads print -1 instead first line contain two integers n m ( 1 ≤ n ≤ 500 0 ≤ m ≤ <unknown> ) — number towns roads bitland respectively next m line describe roads i - th line contain three integers vi ui ti ( 1 ≤ vi ui ≤ n 0 ≤ ti ≤ 1 ) vi ui denote start destination towns indices i - th road ti <unknown> type i - th road ( 0 a pedestrian road 1 a bike road ) guarantee pair distinct indices i j 1 ≤ i j ≤ m either vi ≠ vj ui ≠ uj ti ≠ tj hold possible find a route length strictly greater 1018 print -1 . otherwise print maximum length a suitable path first sample obtain a route length 3 travel along road 1 town 1 town 2 follow road 2 twice town 2 second sample obtain arbitrarily long route travel road 1 first choose road 2 3 depend necessary type",['dp'],2400.0
453/B,princess twilight go <unknown> <unknown> 's old castle research chest elements harmony a sequence positive integers bi harmony every two elements sequence greatest common divisor equal 1 . accord ancient book key chest a harmony sequence bi minimize follow expression : give sequence ai help princess twilight find key first line contain integer n ( 1 ≤ n ≤ 100 ) — number elements sequence a b. next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 30 ) output key — sequence bi minimize sum describe multiple optimal sequence output,['dp'],2000.0
482/C,play game friend description game list friend create n distinct string length m tell string randomly choose one choose string equiprobably i.e probability choose n string equal want guess string choose friend order guess string friend choose allow ask question question follow form : « character stand position pos string choose ? » a string consider guess answer give question uniquely identify string string guess stop ask question a particular strategy question equiprobably ask a position n't yet mention task determine expect number question need guess string choose friend first line contain a single integer n ( 1 ≤ n ≤ 50 ) — number string friend come next n line contain string friend create guarantee string distinct consist large small english letter besides lengths string 1 20 inclusive print single number — expect value answer consider correct absolute relative error n't exceed 10 - 9 . first sample string differ character third position follow situations possible : thus expect value equal second sample need two question pair question uniquely identify string expect number question third sample whatever position ask first question immediately identify string,['dp'],2600.0
534/F,task write a program deal <unknown> field larger 5 × 20 . simplify <unknown> a task build field ( cell either white black ) satisfy give information row columns row column number contiguous black segment specify example size field n = 3 m = 5 <unknown> number contiguous black segment row : [ 2 3 2 ] columns : [ 1 0 1 2 1 ] solution may look like : guarantee test testset exist least one solution first line follow two integers n m ( 1 ≤ n ≤ 5 1 ≤ m ≤ 20 ) — number row number columns respectively second line contain n integers a1 a2 ... ai number contiguous black segment i - th row field similarly third line contain m integers b1 b2 ... bm bi number contiguous black segment i - th column field guarantee exist least one solution output possible solution output consist n line contain m character denote white cell ` ` . '' black cell ` ` * '',['dp'],2400.0
543/C,multiset n string length consist lowercase english letter say string easy remember string position i letter c english alphabet string string multiset letter c position i. example a multiset string { ` ` abc '' ` ` aba '' ` ` <unknown> '' ` ` ada '' } easy remember multiset { ` ` abc '' ` ` ada '' ` ` <unknown> '' } easy remember : want change multiset a little easy remember aij coin change character j - th position i - th string lowercase letter english alphabet find minimum sum pay order make multiset string easy remember first line contain two integers n m ( 1 ≤ n m ≤ 20 ) — number string multiset length string respectively next n line contain string multiset consist lowercase english letter string 's length m. next n line contain m integers i - th contain integers ai1 ai2 ... aim ( 0 ≤ aij ≤ 106 ) print a single number — answer problem,['dp'],2500.0
580/D,"kefa come restaurant sit a table waiter immediately bring menu n dish kefa know need exactly m dish , n't want order dish twice <unknown> many dish possible kefa know i - th dish give ai units satisfaction dish go well together dish go well together kefa set k rule eat food follow type — eat dish x exactly dish y ( dish x y ) satisfaction level raise c. course <unknown> want get maximal possible satisfaction go restaurant help hard task ! first line input contain three space - separated number n m k ( 1 ≤ m ≤ n ≤ 18 0 ≤ k ≤ n * ( n - 1 ) ) — number dish menu number portion kefa need eat get full number eat rule second line contain n space - separated number ai ( 0 ≤ ai ≤ 109 ) — satisfaction get i - th dish next k line contain rule i - th rule describe three number xi yi ci ( 1 ≤ xi yi ≤ n 0 ≤ ci ≤ 109 ) mean eat dish xi right dish yi kefa 's satisfaction increase ci guarantee pair index i j ( 1 ≤ i < j ≤ k ) xi = xj yi = yj single line output print maximum satisfaction kefa get go restaurant first sample best first eat second dish first one get one unit satisfaction dish plus one rule second test fit sequence choice 4 2 1 2 1 4 . case get satisfaction 7 dish also fulfill rule 1 get additional satisfaction 5",['dp'],1800.0
599/E,root tree a connect graph without simple cycle one vertex select a root problem vertex number 1 always serve a root lowest common ancestor two vertices u v farthest root vertex lie path u root path v root denote lca ( u v ) sandy a root tree consist n vertices use store <unknown> unfortunately <unknown> storm break tree n't remember 's edge manage restore m edge initial tree q triple ai bi ci suppose lca ( ai bi ) = ci help sandy count number tree size n vertex 1 a root match information remember make a mess tree print 0 . two root tree consider distinct exist edge occur one n't occur one first line input contain three integers n m q ( 1 ≤ n ≤ 13 0 ≤ m < n 0 ≤ q ≤ 100 ) — number vertices number edge lca triple remember sandy respectively next m line contain two integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) — number vertices connect i - th edge 's guarantee set edge a subset edge tree last q line contain triplets number ai bi ci ( 1 ≤ ai bi ci ≤ n ) triple define lca ( ai bi ) = ci 's guarantee exist a tree satisfy give lca condition print a single integer — number tree size n satisfy condition second sample correct answer look like : third sample two possible tree : fourth sample answer 0 information lca inconsistent,['dp'],2600.0
1322/D,a popular reality show recruit a new cast third <unknown> ! $$$ n $$$ candidates number $$$ 1 $$$ $$$ n $$$ interview candidate $$$ i $$$ aggressiveness level $$$ l_i $$$ recruit candidate cost show $$$ s_i $$$ roubles show host review applications candidates $$$ i=1 $$$ $$$ i = n $$$ increase indices decide whether recruit candidate aggressiveness level candidate $$$ i $$$ strictly higher already accept candidates candidate $$$ i $$$ definitely reject otherwise host may accept reject candidate <unknown> host want choose cast maximize total profit show make revenue follow aggressiveness level $$$ v $$$ a correspond profitability value $$$ <unknown> $$$ specify positive well negative recruit participants enter stage one one increase indices participant $$$ i $$$ enter stage events proceed follow : allow select empty set participants ( choose neither candidates ) host want recruit cast total profit maximize profit calculate total revenue events stage less total <unknown> recruit accept participants ( total $$$ s_i $$$ ) help host make show profitable possible first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 2000 $$$ ) — number candidates upper bind initial aggressiveness level second line contain $$$ n $$$ integers $$$ l_i $$$ ( $$$ 1 \le l_i \le m $$$ ) — initial aggressiveness level candidates third line contain $$$ n $$$ integers $$$ s_i $$$ ( $$$ 0 \le s_i \le 5000 $$$ ) — cost ( roubles ) recruit candidates fourth line contain $$$ n + m $$$ integers $$$ c_i $$$ ( $$$ <unknown> \le 5000 $$$ ) — profitability <unknown> level guarantee aggressiveness level participant never exceed $$$ n + m $$$ give condition print a single integer — largest profit show first sample case optimal recruit candidates $$$ 1 2 3 5 $$$ show pay $$$ 1 + 2 + 1 + 1 = 5 $$$ roubles <unknown> events stage proceed follow : total revenue show $$$ 4 + 3 + 1 + 1 + <unknown> $$$ roubles profit $$$ 11 - 5 = 6 $$$ roubles second sample case impossible recruit candidates since second one higher aggressiveness thus better recruit candidate $$$ 1 $$$,['dp'],2800.0
449/D,"jzzhu n non - negative integers a1 a2 ... , call a sequence index i1 i2 ... ik ( 1 ≤ i1 < i2 < ... < ik ≤ n ) a group size k. jzzhu wonder many group exist ai1 & ai2 & ... & <unknown> = 0 ( 1 ≤ k ≤ n ) ? help print number modulo 1000000007 ( 109 + 7 ) operation x & y denote bitwise operation two number first line contain a single integer n ( 1 ≤ n ≤ 106 ) second line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 106 ) output a single integer represent number require group modulo 1000000007 ( 109 + 7 )",['dp'],2400.0
744/C,"one day hongcow go store see a brand new deck n special card individual card either red blue decide want buy immediately , need play a game owner store game take number turn complete a turn hongcow may one two things : i - th card require ri red resources bi blue resources suppose hongcow currently a red card b blue card , i - th card require hongcow spend max ( ri - a 0 ) red tokens max ( bi - b 0 ) blue tokens note tokens disappear card stay hongcow forever card buy give a description card cost determine minimum number turn hongcow need purchase card first line input contain a single integer n ( 1 ≤ n ≤ 16 ) next n line input contain three tokens ci ri bi ci ' r ' ' b ' denote color card red blue ri integer denote amount red resources require obtain card bi integer denote amount blue resources require obtain card ( 0 ≤ ri bi ≤ 107 ) output a single integer denote minimum number turn need <unknown> card first sample hongcow 's four move follow : second sample one optimal strategy follow :",['dp'],2400.0
757/D,"gym leaders fascinate <unknown> take place <unknown> camp , curious know secret behind evolve pokemon organizers camp give gym leaders a pokeblock a sequence n ingredients ingredient type 0 1 . organizers tell gym leaders evolve a pokemon type k ( k ≥ 2 ) need make a valid set k cut pokeblock get smaller block suppose give pokeblock sequence <unknown> ... bn - 1 . a choice make cut n + 1 place i.e. b0 b0 b1 b1 b2 ... bn - 2 bn - 1 bn - 1 . n + 1 choices make cut follow ( a | denote a possible cut ) : consider a sequence k cut pair consecutive cut contain a binary string form ingredient type ingredients first cut last cut waste say consider exactly k - 1 binary substrings every substring read a binary number let m maximum number obtain number obtain number positive set obtain number contain integers 1 m set cut say a valid set cut example suppose give pokeblock sequence <unknown> make 5 cut follow way : 4 binary substrings obtain : 11 010 01 1 correspond number 3 2 1 1 respectively m = 3 maximum value among obtain number obtain number positive obtain integers 1 m. hence set cut a valid set 5 cut a pokemon type k evolve pokeblock cut use a valid set k cut many valid set size two valid set k cut consider different a cut one set set let f ( k ) denote number valid set k cut find value since value s large output s modulo 109 + 7 . input consist two line first line consist integer n ( 1 ≤ n ≤ 75 ) — length pokeblock next line contain pokeblock a binary string length n. output a single integer contain answer problem i.e. value s modulo 109 + 7 . first sample set valid cut : size 2 : <unknown> <unknown> <unknown> <unknown> size 3 : <unknown> <unknown> <unknown> <unknown> size 4 : <unknown> <unknown> hence f ( 2 ) = 4 f ( 3 ) = 4 f ( 4 ) = 2 . value s = 10 . second sample set valid cut : size 2 : <unknown> hence f ( 2 ) = 1 f ( 3 ) = 0 . value s = 1",['dp'],2200.0
768/E,sam teach jon game stone <unknown> mind help devise a strategy fight white <unknown> rule game quite simple : jon believe ready battle sam think prove argument sam suggest play a modify version game modify version move make a pile example 4 stone remove a pile 4 stone remove pile sam set game make first move jon believe sam try prevent go battle jon want know win play optimally first line consist a single integer n ( 1 ≤ n ≤ 106 ) — number pile next n line contain integer si ( 1 ≤ si ≤ 60 ) — number stone i - th pile print a single line contain ` ` yes '' ( without quote ) jon win otherwise print ` ` '' ( without quote ) first case sam remove stone jon lose second case follow move possible sam : case last move make jon win game follow :,['dp'],2100.0
776/G,"sherlock find a piece encrypt data think useful catch <unknown> encrypt data consist two integer l r. notice integers hexadecimal form take integers l r perform follow operations : one example : integer 1e sum sum = 21 + <unknown> . letter a b c d e f denote hexadecimal digits 10 11 12 13 14 15 <unknown> sherlock want count number range l r ( inclusive ) decrease application four step want answer q query different l r. first line contain integer q ( 1 ≤ q ≤ 10000 ) next q line contain two hexadecimal integers l r ( 0 ≤ l ≤ r < <unknown> ) hexadecimal integers write use digits 0 9 and/or lowercase english letter a b c d e f. hexadecimal integers contain extra lead zero output q line i - th line contain answer i - th query ( decimal notation ) second <unknown> = <unknown> = 21 + 24 = 18 thus reduce , <unknown> number range 1 1e reduce",['dp'],2900.0
1038/E,"give $$$ n $$$ block form [ color $$$ _ 1 $$$ |value|color $$$ _ 2 $$$ ] block also flip get [ color $$$ _ 2 $$$ |value|color $$$ _ 1 $$$ ] a sequence block call valid touch endpoints neighbor block color example sequence three block a b c valid leave color b right color a right color b leave color c. value sequence define sum value block sequence find maximum possible value valid sequence construct subset give block block subset reorder flip necessary block use sequence first line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number give block follow $$$ n $$$ line describe correspond block consist $$$ \mathrm { color } _ { 1 i } $$$ $$$ \mathrm { value } _ i $$$ $$$ \mathrm { color } _ { 2 i } $$$ ( $$$ 1 \le \mathrm { color } _ { 1 i } \mathrm { color } _ { 2 i } \le 4 $$$ $$$ 1 \le \mathrm { value } _ i \le 100\,000 $$$ ) print exactly one integer — maximum total value subset block make a valid sequence first example possible form a valid sequence block one valid sequence follow : [ 4|2|1 ] [ <unknown> ] [ <unknown> ] [ <unknown> ] [ <unknown> ] [ 4|1|2 ] first block input ( [ <unknown> ] $$$ \to $$$ [ 4|1|2 ] ) second ( [ <unknown> ] $$$ \to $$$ [ 4|2|1 ] ) flip second example optimal answer form first three block follow ( second third block input flip ) : [ <unknown> ] [ <unknown> ] [ <unknown> ] third example possible form a valid sequence two block answer a sequence consist first block since block largest value",['dp'],2400.0
1051/D,give a grid consist $$$ 2 $$$ row $$$ n $$$ columns cell grid color either black white two cells consider neighbour a common border share color two cells $$$ a $$$ $$$ b $$$ belong component neighbour a neighbour $$$ a $$$ belong component $$$ b $$$ let 's call <unknown> beautiful exactly $$$ k $$$ components count number beautiful bicolorings number big enough print answer modulo $$$ 998244353 $$$ line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 1000 $$$ $$$ 1 \le k \le 2n $$$ ) — number columns a grid number components require print a single integer — number beautiful bicolorings modulo $$$ 998244353 $$$ one possible bicolorings sample $$$ 1 $$$ :,['dp'],1700.0
1292/F,back time seven - year - old nora use play lot game creation <unknown> fun <unknown> abilities one day nora 's <unknown> <unknown> phoenix <unknown> bring nora $$$ n $$$ box toy unpack nora decide make a fun game robo label $$$ n $$$ box $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ask robo follow action several ( possibly zero ) time : amuse nine different try game nora ask robo calculate number possible different pile largest amount box two pile consider different exist a position two pile different box since robo still <unknown> stag nora still young <unknown> a long time fell asleep find final answer help ? number pile large print answer modulo $$$ 1000000000 + 7 $$$ first line contain integer $$$ n $$$ ( $$$ 3 \le n \le 60 $$$ ) denote number box second line contain $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 60 $$$ ) $$$ a_i $$$ label $$$ i $$$ -th box print number distinct pile maximum number box <unknown> modulo $$$ 1000000000 + 7 $$$ let 's illustrate box pile a sequence $$$ b $$$ pile 's bottommost box leftmost position first example $$$ 2 $$$ distinct pile possible : second example $$$ 4 $$$ distinct pile possible : third sequence robo nothing therefore $$$ 1 $$$ valid pile pile empty,['dp'],3500.0
743/E,vladik bore way home decide play follow game take n card put a row front every card a positive integer number exceed 8 write decide find longest subsequence card satisfy follow condition : please help vladik find length longest subsequence satisfy condition first line contain single integer n ( 1 ≤ n ≤ 1000 ) — number card vladik 's sequence second line contain sequence n positive integers exceed 8 — description vladik 's sequence print single integer — length longest subsequence vladik 's sequence satisfy condition first sample number write card equal ca n't take one card otherwise 'll violate first condition,['dp'],2200.0
1519/F,"alice bob play a game alice get $$$ n $$$ treasure chests ( $$$ i $$$ -th contain $$$ a_i $$$ coin ) $$$ m $$$ key ( $$$ j $$$ -th sell bob $$$ b_j $$$ coin ) firstly alice put lock chests $$$ m $$$ type lock lock $$$ j $$$ -th type open $$$ j $$$ -th key put a lock type $$$ j $$$ $$$ i $$$ -th chest alice pay $$$ c _ { i j } $$$ dollars alice put number different type lock chest ( possibly zero ) , bob buy key alice ( possibly none possibly ) open chest ( open a chest key lock chest ) bob 's profit difference total number coin open chests total number coin spend buy key alice bob 's profit strictly positive ( greater zero ) win game otherwise alice win game alice want put lock chests matter key bob buy always win ( bob get positive profit ) course want spend minimum possible number dollars buy lock help determine whether win game , many dollars spend lock first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 6 $$$ ) — number chests number key respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 4 $$$ ) $$$ a_i $$$ number coin $$$ i $$$ -th chest third line contain $$$ m $$$ integers $$$ b_1 b_2 \dots <unknown> $$$ ( $$$ 1 \le b_j \le 4 $$$ ) $$$ b_j $$$ number coin bob spend buy $$$ j $$$ -th key alice $$$ n $$$ line follow $$$ i $$$ -th contain $$$ m $$$ integers $$$ c _ { i,1 } c _ { i,2 } \dots c _ { i m } $$$ ( $$$ 1 \le c _ { i j } \le 10000000 $$$ ) $$$ c _ { i j } $$$ number dollars alice spend put a lock $$$ j $$$ -th type $$$ i $$$ -th chest alice ensure victory ( matter lock put chests bob always a way gain positive profit ) print $$$ -1 $$$ otherwise print one integer — minimum number dollars alice spend win game regardless bob 's action first example alice put lock type $$$ 1 $$$ $$$ 3 $$$ first chest lock type $$$ 2 $$$ $$$ 3 $$$ second chest second example alice put lock type $$$ 1 $$$ $$$ 2 $$$ first chest a lock type $$$ 3 $$$ second chest",['dp'],3200.0
750/G,new year tree infinite perfect binary tree root node 1 . node v two children : nod index ( 2·v ) ( 2·v + 1 ) polar bear love decorate new year tree limak exception a little bear tell decorate one simple path pair nod though give opportunity pick pair ! want know number unordered pair indices ( u v ) ( u ≤ v ) sum indices nod along simple path u v ( include endpoints ) equal s. help count value ? line input contain a single integer s ( 1 ≤ s ≤ <unknown> ) print one integer denote number unordered pair nod indices define simple paths sum indices vertices equal s. sample test 4 paths sum indices equal 10 :,['dp'],3200.0
1305/G,<unknown> n't good <unknown> decide find a new financial pyramid call antihype follow rule : $$$ n $$$ people hear antihype recently $$$ i $$$ -th person 's age $$$ a_i $$$ friends friendship a weird thing : $$$ i $$$ -th person a friend $$$ j $$$ -th person $$$ a_i \text { } a_j = 0 $$$ $$$ \text { } $$$ denote bitwise operation nobody among $$$ n $$$ people a member antihype moment want cooperate join invite antihype a way maximize combine gain could help ? first line contain a single integer $$$ n $$$ ( $$$ 1\le n \le 2\cdot 100000 $$$ ) — number people second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0\le a_i \le 2\cdot 100000 $$$ ) — age people output exactly one integer — maximum possible combine gain $$$ n $$$ people first second persons friends second join antihype invite first one get $$$ 2 $$$,['dp'],3500.0
1360/F,give $$$ n $$$ string $$$ a_1 a_2 \ldots a_n $$$ : length $$$ m $$$ string consist lowercase english letter find string $$$ s $$$ length $$$ m $$$ give $$$ n $$$ string differ $$$ s $$$ one position formally give string $$$ a_i $$$ one position $$$ j $$$ $$$ a_i [ j ] \ne s [ j ] $$$ note desire string $$$ s $$$ may equal one give string $$$ a_i $$$ may differ give string example string abac <unknown> answer problem might string abab differ first last character second first first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case $$$ t $$$ test case follow test case start a line contain two positive integers $$$ n $$$ ( $$$ 1 \le n \le 10 $$$ ) $$$ m $$$ ( $$$ 1 \le m \le 10 $$$ ) — number string length follow $$$ n $$$ string $$$ a_i $$$ one per line length $$$ m $$$ consist lowercase english letter print $$$ t $$$ answer test case answer ( exist ) a string length $$$ m $$$ consist lowercase english letter several answer print answer exist print ` ` -1 '' ( ` ` minus one '' without quote ) first test case explain statement second test case answer exist,['dp'],1700.0
1383/C,note difference string transformation 1 string transformation 2 move koa version letter $$$ y $$$ koa select letter first $$$ 20 $$$ lowercase letter english alphabet ( read statement better understand ) make hack problems independently koa koala two string $$$ a $$$ $$$ b $$$ length $$$ n $$$ ( $$$ <unknown> $$$ ) consist first $$$ 20 $$$ lowercase english alphabet letter ( ie a t ) one move koa : note modify letter string $$$ a $$$ koa want know smallest number move make string equal ( $$$ a = b $$$ ) determine way make equal help ! test contain multiple test case first line contain $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) — number test case description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length string $$$ a $$$ $$$ b $$$ second line test case contain string $$$ a $$$ ( $$$ <unknown> $$$ ) third line test case contain string $$$ b $$$ ( $$$ <unknown> $$$ ) string consist first $$$ 20 $$$ lowercase english alphabet letter ( ie a t ) guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case : print a single line smallest number move make string equal ( $$$ a = b $$$ ) $$$ -1 $$$ way make equal,['dp'],3100.0
1450/G,please pay attention unusual memory limit problem a parallel universe <unknown> call ` ` trygub '' reason letter <unknown> delete alphabet ancient time government $$$ n $$$ workers stand a row number integers $$$ 1 $$$ $$$ n $$$ leave right job categories represent a string $$$ s $$$ length $$$ n $$$ character $$$ s_i $$$ represent job category $$$ i $$$ -th worker a new law approve increase <unknown> workers government decide make everyone job category perform follow operation number time ( possibly zero ) a fix rational parameter $$$ <unknown> ab $$$ describe easy convince public use determine success operation operation government first select a job category $$$ x $$$ least one worker current moment suppose $$$ i_1 \ldots i_m $$$ ( $$$ i_1 < \ldots < i_m $$$ ) position workers job category $$$ x $$$ $$$ <unknown> ( i_m - i_1 + 1 ) \le m $$$ government able choose job category $$$ y $$$ least one worker current moment change job category workers job category $$$ x $$$ job category $$$ y $$$ possible make workers job category $$$ x $$$ say $$$ x $$$ obtainable tell government set obtainable job categories ? first line contain three integers $$$ n a b $$$ ( $$$ 1 \le n \le 5000 $$$ $$$ 1\le <unknown> b\le 100000 $$$ ) — number workers numerator denominator parameter $$$ k $$$ respectively second line contain a string $$$ s $$$ length $$$ n $$$ consist lowercase english character — job categories worker character ' t ' ' r ' ' y ' ' g ' ' u ' ' b ' appear string $$$ s $$$ print integer $$$ c $$$ equal number obtainable job categories follow $$$ c $$$ space - separated character — obtainable job categories sort lexicographical order first operation must select job category ' i ' job categories satisfy condition therefore ' i ' obtainable show obtain ' c ' ' m ' ' o ' square bracket denote segment contain workers select category red color denote category blue color denote new category change,['dp'],3500.0
1497/D,please note non - standard memory limit $$$ n $$$ problems number integers $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th problem complexity $$$ c_i = 2^i $$$ tag $$$ tag_i $$$ score $$$ s_i $$$ solve problem $$$ i $$$ 's allow solve problem $$$ j $$$ $$$ \text { iq } < |c_i - c_j| $$$ $$$ tag_i \neq <unknown> $$$ solve $$$ \text { iq } $$$ change become $$$ \text { iq } = |c_i - c_j| $$$ gain $$$ |s_i - <unknown> $$$ point problem first solve problems order many time want initially $$$ \text { iq } = 0 $$$ find maximum number point earn first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 100 ) $$$ — number test case first line test case contain integer $$$ n $$$ $$$ ( 1 \le n \le 5000 ) $$$ — number problems second line test case contain $$$ n $$$ integers $$$ <unknown> <unknown> \ldots <unknown> $$$ $$$ ( 1 \le tag_i \le n ) $$$ — tag problems third line test case contain $$$ n $$$ integers $$$ s_1 s_2 \ldots s_n $$$ $$$ ( 1 \le s_i \le 1000000000 ) $$$ — score problems 's guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ test case print a single integer — maximum number point earn first test case optimal sequence solve problems follow : second test case optimal sequence solve problems follow : third test case optimal sequence solve problems follow :,['dp'],2500.0
1326/F1,easy version problem difference constraints number wise men time limit make hack versions task solve $$$ n $$$ wise men live a beautiful city know $$$ n ! $$$ possible permutations $$$ p_1 p_2 \ldots p_n $$$ wise men let 's generate a binary string length $$$ n-1 $$$ : $$$ 1 \leq i < n $$$ set $$$ s_i=1 $$$ $$$ p_i $$$ $$$ p _ { i+1 } $$$ know $$$ <unknown> $$$ otherwise possible $$$ 2^ { n-1 } $$$ binary string find number permutations produce binary string first line input contain one integer $$$ n $$$ ( $$$ 2 \leq n \leq 14 ) $$$ — number wise men city next $$$ n $$$ line contain a binary string length $$$ n $$$ $$$ j $$$ -th character $$$ i $$$ -th string equal ' 1 ' wise man $$$ i $$$ know wise man $$$ j $$$ equal ' 0 ' otherwise guarantee $$$ i $$$ -th man know $$$ j $$$ -th man $$$ j $$$ -th man know $$$ i $$$ -th man man know print $$$ 2^ { n-1 } $$$ space - separated integers $$$ 0 \leq x < 2^ { n-1 } $$$ : first test wise man know every permutation produce string $$$ 11 $$$ second test :,['dp'],2600.0
1245/F,"spring clean daniel find old calculator love much however seem like break try compute $$$ 1 + 3 $$$ use calculator get $$$ 2 $$$ instead $$$ 4 $$$ try compute $$$ 1 + 4 $$$ get correct answer $$$ 5 $$$ puzzle <unknown> open calculator find answer riddle : full adders become half adders ! , try compute sum $$$ a + b $$$ use calculator instead get <unknown> $$$ a \oplus b $$$ ( read definition link : https : //en.wikipedia.org / wiki / exclusive_or ) saw earlier calculator sometimes give correct answer , wonder give integers $$$ l $$$ $$$ r $$$ many pair integers $$$ ( a b ) $$$ satisfy follow condition : $$$ $$$ a + b = a \oplus b $$$ $$$ $$$ $$$ l \leq a \leq r $$$ $$$ $$$ $$$ l \leq b \leq r $$$ $$$ however daniel barman go bar return two hours tell solve problem return else enjoy block first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number testcases , $$$ t $$$ line follow contain two space - separated integers $$$ l $$$ $$$ r $$$ ( $$$ 0 \le l \le r \le 1000000000 $$$ ) print $$$ t $$$ integers $$$ i $$$ -th integer answer $$$ i $$$ -th testcase $$$ a \oplus b $$$ denote bitwise xor $$$ a $$$ $$$ b $$$ first testcase pair : $$$ ( 1 2 ) $$$ $$$ ( 1 4 ) $$$ $$$ ( 2 1 ) $$$ $$$ ( 2 4 ) $$$ $$$ ( 3 4 ) $$$ $$$ ( 4 1 ) $$$ $$$ ( 4 2 ) $$$ $$$ ( 4 3 ) $$$",['dp'],2300.0
1242/C,"ujan a lot number box like order balance decide reorder number $$$ k $$$ box number $$$ 1 $$$ $$$ k $$$ $$$ i $$$ -th box contain $$$ n_i $$$ integer number integers negative integers distinct ujan lazy follow reorder number exactly pick a single integer box $$$ k $$$ integers total insert choose number — one integer box number integers box begin note may also insert integer pick a box back box ujan happy sum integers box achieve make box perfectly balance like things ? first line contain a single integer $$$ k $$$ ( $$$ 1 \leq k \leq 15 $$$ ) number box $$$ i $$$ -th next $$$ k $$$ line first contain a single integer $$$ n_i $$$ ( $$$ 1 \leq n_i \leq <unknown> $$$ ) number integers box $$$ i $$$ line contain $$$ n_i $$$ integers $$$ a _ { i,1 } \ldots a _ { i n_i } $$$ ( $$$ |a _ { i j } | \leq 1000000000 $$$ ) integers $$$ i $$$ -th box guarantee $$$ a _ { i j } $$$ distinct ujan achieve goal output ` ` '' a single line otherwise first line output ` ` yes '' output $$$ k $$$ line $$$ i $$$ -th line contain two integers $$$ c_i $$$ $$$ p_i $$$ mean ujan pick integer $$$ c_i $$$ $$$ i $$$ -th box place $$$ p_i $$$ -th box afterwards multiple solutions output print letter case ( upper lower ) first sample ujan put number $$$ 7 $$$ $$$ 2 $$$ nd box number $$$ 2 $$$ $$$ 3 $$$ rd box number $$$ 5 $$$ $$$ 1 $$$ st box keep number $$$ 10 $$$ $$$ 4 $$$ th box box contain number $$$ \ { <unknown> } $$$ $$$ \ { 3 <unknown> } $$$ $$$ \ { <unknown> } $$$ $$$ \ { 10\ } $$$ sum box equal $$$ 10 $$$ second sample possible pick redistribute number require way third sample one swap number $$$ <unknown> $$$ $$$ -10 $$$ make sum box equal $$$ -10 $$$",['dp'],2400.0
1238/E,a password often type — a string $$$ s $$$ length $$$ n $$$ every character string one first $$$ m $$$ lowercase latin letter since spend a lot time type want buy a new keyboard a keyboard a permutation first $$$ m $$$ latin letter example $$$ m = 3 $$$ six possible keyboards : abc <unknown> bac bca cab cba since type password one finger need spend time move finger one password character next time move character $$$ s_i $$$ character $$$ s _ { i+1 } $$$ equal distance character keyboard total time spend type password a keyboard call slowness keyboard <unknown> slowness keyboard equal $$$ \sum\limits _ { <unknown> } ^ { n } <unknown> _ { s _ { i-1 } } - pos _ { s_i } | $$$ $$$ <unknown> $$$ position letter $$$ x $$$ keyboard example $$$ s $$$ <unknown> keyboard bac total time type password $$$ |pos_a - pos_a| + |pos_a - pos_c| + <unknown> - pos_a| + |pos_a - <unknown> + <unknown> - pos_c| $$$ = $$$ |2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3| $$$ = $$$ 0 + 1 + 1 + 1 + 2 = 5 $$$ buy a new keyboard want know minimum possible slowness keyboard first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100000 1 \le m \le 20 $$$ ) second line contain string $$$ s $$$ consist $$$ n $$$ character character one first $$$ m $$$ latin letter ( lowercase ) print one integer – minimum slowness a keyboard first test case consider statement second test case slowness keyboard $$$ 0 $$$ third test case one suitable keyboards <unknown>,['dp'],2200.0
1097/B,petr buy a new car 's arrive know petersburg 's petrol station <unknown> suddenly discover petrol tank secure a combination lock ! lock a scale $$$ 360 $$$ degrees a pointer initially point zero : petr call car <unknown> <unknown> rotate lock 's wheel exactly $$$ n $$$ time $$$ i $$$ -th rotation $$$ a_i $$$ degrees either clockwise counterclockwise $$$ n $$$ rotations pointer point zero confuse petr a little bite n't sure rotations do clockwise do counterclockwise many possible ways rotate lock help find whether exist least one $$$ n $$$ rotations pointer point zero first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 15 $$$ ) — number rotations follow $$$ n $$$ line contain one integer $$$ a_i $$$ ( $$$ 1 \leq a_i \leq 180 $$$ ) — angle $$$ i $$$ -th rotation degrees possible rotations pointer point zero perform print a single word ` ` yes '' otherwise print ` ` '' petr probably buy a new car case print letter case ( upper lower ) first example achieve goal apply first second rotation clockwise perform third rotation counterclockwise second example 's impossible perform rotations order make pointer point zero end third example petr three rotations clockwise case whole wheel rotate $$$ 360 $$$ degrees clockwise pointer point zero,['dp'],1200.0
1097/H,a thue - morse - <unknown> - mateusz sequence ( thorse - radewoosh sequence short ) infinite sequence construct a finite sequence $$$ \mathrm { gen } $$$ length $$$ d $$$ integer $$$ m $$$ obtain follow sequence step : instance pick $$$ \mathrm { gen } = ( 0 \color { blue } { 1 } \color { green } { 2 } ) $$$ $$$ m = 4 $$$ : see long first element $$$ \mathrm { gen } $$$ $$$ 0 $$$ consecutive step produce a sequence whose prefix sequence generate previous step therefore define infinite thorse - radewoosh sequence $$$ m_\infty $$$ sequence obtain apply step <unknown> parameters $$$ m_\infty = ( 0 1 2 1 2 3 2 3 0 1 2 3 2 3 0 3 0 1 \dots ) $$$ mateusz pick a sequence $$$ \mathrm { gen } $$$ integer $$$ m $$$ use obtain a thorse - radewoosh sequence $$$ m_\infty $$$ pick two integers $$$ l $$$ $$$ r $$$ write a subsequence sequence $$$ a : = ( ( m_\infty ) _ l ( m_\infty ) _ { l+1 } \dots ( m_\infty ) _ r ) $$$ note use $$$ 1 $$$ -based index $$$ m_\infty $$$ $$$ a $$$ mateusz favorite sequence $$$ b $$$ length $$$ n $$$ would like see large compare $$$ a $$$ let 's say $$$ b $$$ majorizes sequence $$$ x $$$ length $$$ n $$$ ( let 's denote $$$ b \geq x $$$ ) $$$ i \in \ { 1 2 \dots n\ } $$$ $$$ b_i \geq x_i $$$ ask many integers $$$ x $$$ range $$$ [ 1 |a| - n + 1 ] $$$ $$$ b \geq ( a_x a _ { x+1 } a _ { <unknown> } \dots a _ { <unknown> } ) $$$ sequence huge answer question use <unknown> paper turn time - <unknown> help automate research ? first line contain two integers $$$ d $$$ $$$ m $$$ ( $$$ 2 \leq d \leq 20 $$$ $$$ 2 \leq m \leq 60 $$$ ) — length sequence $$$ \mathrm { gen } $$$ integer use perform modular operations second line contain $$$ d $$$ integers $$$ \mathrm { gen } _ i $$$ ( $$$ 0 \leq \mathrm { gen } _ i < m $$$ ) 's guarantee first element sequence $$$ \mathrm { gen } $$$ equal zero third line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 30000 $$$ ) — length sequence $$$ b $$$ fourth line contain $$$ n $$$ integers $$$ b_i $$$ ( $$$ 0 \leq b_i < m $$$ ) fifth line contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l \leq r \leq 10^ { 18 } $$$ $$$ r - l+1 \geq n $$$ ) print a single integer — answer problem thorse - radewoosh sequence first example standard thue - morse sequence sequence $$$ a $$$ follow : $$$ <unknown> $$$ place sequence $$$ b $$$ majorizes $$$ a $$$ :,['dp'],3400.0
1102/F,give a matrix $$$ a $$$ consist $$$ n $$$ row $$$ m $$$ columns cell contain integer change order row arbitrarily ( include leave initial order ) ca n't change order cells a row pick order row traverse whole matrix follow way : firstly visit cells first column top row bottom one second column traversal write sequence number cells order visit let sequence $$$ s_1 s_2 \dots s _ { nm } $$$ traversal $$$ k $$$ -acceptable $$$ i $$$ ( $$$ 1 \le i \le nm - 1 $$$ ) $$$ |s_i - s _ { i + 1 } | \ge k $$$ find maximum integer $$$ k $$$ exist order row matrix $$$ a $$$ produce a $$$ k $$$ -acceptable traversal first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 16 $$$ $$$ 1 \le m \le 10000 $$$ $$$ 2 \le nm $$$ ) — number row number columns respectively next $$$ n $$$ line contain $$$ m $$$ integers ( $$$ 1 \le a _ { i j } \le 1000000000 $$$ ) — description matrix print a single integer $$$ k $$$ — maximum number exist order row matrix $$$ a $$$ produce $$$ k $$$ -acceptable traversal first example rearrange row follow get $$$ 5 $$$ -acceptable traversal : sequence $$$ s $$$ $$$ [ 5 10 4 9 3 8 3 9 ] $$$ pair neighbour elements least $$$ k = 5 $$$ difference second example maximum $$$ k = 0 $$$ order $$$ 0 $$$ -acceptable third example give order already $$$ 3 $$$ -acceptable leave,['dp'],2000.0
1103/D,"cardbluff popular sport game <unknown> cardbluff player ever dream entrance professional layer $$$ n $$$ judge layer try pass entrance exam a number $$$ k $$$ — skill cardbluff judge a number $$$ a_i $$$ — indicator uncertainty entrance professional layer a number $$$ e_i $$$ — experience play cardbluff pass exam need convince judge play play one game judge a result a particular game divide uncertainty $$$ i $$$ -th judge natural divisor $$$ a_i $$$ $$$ k $$$ gcd indicators equal $$$ 1 $$$ enter professional layer become a judge also want minimize total amount spend time , play $$$ x $$$ judge total experience $$$ y $$$ spend $$$ x \cdot y $$$ second print minimal time enter professional layer $$$ -1 $$$ 's impossible two number first line $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 1000000 $$$ $$$ 1 \leq k \leq 10^ { 12 } $$$ ) — number judge skill cardbluff second line contain $$$ n $$$ integers $$$ i $$$ -th number $$$ a_i $$$ ( $$$ 1 \leq a_i \leq 10^ { 12 } $$$ ) — uncertainty $$$ i $$$ -th <unknown> third line contain $$$ n $$$ integers format ( $$$ 1 \leq e_i \leq 1000000000 $$$ ) $$$ e_i $$$ — experience $$$ i $$$ -th judge print single integer — minimal number second pass exam $$$ -1 $$$ 's impossible",['dp'],3100.0
1105/E,hiasat register a new account <unknown> friends find one ask use name hiasat 's handle luckily hiasat change handle point time also know exact moments friends visit profile page formally give a sequence events two type : friend $$$ s $$$ happy time visit hiasat 's profile handle would $$$ s $$$ hiasat ask help find maximum possible number happy friends get first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100000 1 \le m \le 40 $$$ ) — number events number friends $$$ n $$$ line follow denote event one two type : 's guarantee friend 's name consist lowercase latin letter 's guarantee first event always first type friend visit hiasat 's profile least print a single integer — maximum number happy friends first example best way change handle ` ` motarack '' first event ` ` light '' fourth event way ` ` motarack '' ` ` light '' happy ` ` mike '' second example choose either ` ` alice '' ` ` bob '' ` ` <unknown> '' friend happy,['dp'],2200.0
1117/F,give a string length $$$ n $$$ character one first $$$ p $$$ lowercase latin letter also give a matrix $$$ a $$$ binary value size $$$ p \times p $$$ matrix symmetric ( $$$ a _ { ij } = a _ { ji } $$$ ) $$$ a _ { ij } = 1 $$$ mean string $$$ i $$$ -th $$$ j $$$ -th letter latin alphabet adjacent let 's call string crisp adjacent character adjacent ( 1 correspond cell matrix $$$ a $$$ ) allow follow move choose letter remove occurrences join remain part string without change order example remove letter ' a ' ` ` abacaba '' yield ` ` <unknown> '' string give crisp string remain crisp every move make allow arbitrary number move ( possible zero ) shortest result string obtain ? first line contain two integers $$$ n $$$ $$$ p $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 1 \le p \le 17 $$$ ) — length initial string length allow prefix latin alphabet second line contain initial string guarantee contain first $$$ p $$$ lowercase latin letter crisp $$$ p $$$ first latin letter might present string next $$$ p $$$ line contain $$$ p $$$ integer number — matrix $$$ a $$$ ( $$$ 0 \le a _ { ij } \le 1 $$$ $$$ a _ { ij } = a _ { ji } $$$ ) $$$ a _ { ij } = 1 $$$ mean string $$$ i $$$ -th $$$ j $$$ -th letter latin alphabet adjacent print a single integer — length shortest string make arbitrary number move ( possible zero ) first example letter remove initial string second example remove letter order : ' b ' ' c ' ' a ' string <unknown> step : ` ` abacaba '' $$$ \rightarrow $$$ ` ` <unknown> '' $$$ \rightarrow $$$ ` ` aaaa '' $$$ \rightarrow $$$ ` ` '' third example remove letter ' b ' 's fourth example remove letter order ' c ' ' b ' order ' b ' ' c ' two letter ' c ' ca n't adjacent,['dp'],2500.0
1288/D,"give $$$ n $$$ array $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ; array consist exactly $$$ m $$$ integers denote $$$ y $$$ -th element $$$ x $$$ -th array $$$ a _ { x y } $$$ choose two array $$$ a_i $$$ $$$ a_j $$$ ( $$$ 1 \le i j \le n $$$ possible $$$ i = j $$$ ) , obtain a new array $$$ b $$$ consist $$$ m $$$ integers every $$$ k \in [ 1 m ] $$$ $$$ b_k = \max ( a _ { i k } a _ { j k } ) $$$ goal choose $$$ i $$$ $$$ j $$$ value $$$ \min \limits _ { k = 1 } ^ { m } b_k $$$ maximum possible first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 300000 $$$ $$$ 1 \le m \le 8 $$$ ) — number array number elements array respectively $$$ n $$$ line follow $$$ x $$$ -th line contain array $$$ a_x $$$ represent $$$ m $$$ integers $$$ a _ { x 1 } $$$ $$$ a _ { x 2 } $$$ ... $$$ a _ { x m } $$$ ( $$$ 0 \le a _ { x y } \le 1000000000 $$$ ) print two integers $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i j \le n $$$ possible $$$ i = j $$$ ) — indices two array choose value $$$ \min \limits _ { k = 1 } ^ { m } b_k $$$ maximum possible multiple answer print",['dp'],2000.0
1151/B,student dima kremland a matrix $$$ a $$$ size $$$ n \times m $$$ fill non - negative integers want select exactly one integer row matrix bitwise exclusive select integers strictly greater zero help ! formally want choose integers sequence $$$ c_1 c_2 \ldots c_n $$$ ( $$$ 1 \leq c_j \leq m $$$ ) inequality $$$ a _ { 1 c_1 } \oplus a _ { 2 c_2 } \oplus \ldots \oplus a _ { n c_n } > 0 $$$ hold $$$ a _ { i j } $$$ matrix element $$$ i $$$ -th row $$$ j $$$ -th column $$$ x \oplus y $$$ denote bitwise xor operation integers $$$ x $$$ $$$ y $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 500 $$$ ) — number row number columns matrix $$$ a $$$ next $$$ n $$$ line contain $$$ m $$$ integers : $$$ j $$$ -th integer $$$ i $$$ -th line $$$ j $$$ -th element $$$ i $$$ -th row matrix $$$ a $$$ i.e $$$ a _ { i j } $$$ ( $$$ 0 \leq a _ { i j } \leq 1023 $$$ ) way choose one integer row bitwise exclusive strictly greater zero print ` ` nie '' otherwise print ` ` tak '' first line next line print $$$ n $$$ integers $$$ c_1 c_2 \ldots c_n $$$ ( $$$ 1 \leq c_j \leq m $$$ ) inequality $$$ a _ { 1 c_1 } \oplus a _ { 2 c_2 } \oplus \ldots \oplus a _ { n c_n } > 0 $$$ hold one possible answer may output first example number matrix $$$ 0 $$$ impossible select one number row table bitwise exclusive strictly greater zero second example select number $$$ 7 $$$ ( first number first line ) $$$ 10 $$$ ( third number second line ) $$$ 7 \oplus 10 = 13 $$$ $$$ 13 $$$ $$$ 0 $$$ answer find,['dp'],1600.0
1152/F1,problem next one smaller constraints aki play a new video game video game control neko giant cat fly planets catniverse $$$ n $$$ planets catniverse number $$$ 1 $$$ $$$ n $$$ begin game aki choose planet neko initially locate aki perform $$$ k - 1 $$$ move move neko move current planet $$$ x $$$ planet $$$ y $$$ : way neko visit exactly $$$ k $$$ different planets two ways visit planets call different index $$$ i $$$ $$$ i $$$ -th planet visit first way different $$$ i $$$ -th planet visit second way total number ways visit $$$ k $$$ planets way ? since answer quite large print modulo $$$ 1000000000 + 7 $$$ line contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 1 \le k \le \min ( n 12 ) $$$ $$$ 1 \le m \le 4 $$$ ) — number planets catniverse number planets neko need visit say constant $$$ m $$$ print exactly one integer — number different ways neko visit exactly $$$ k $$$ planets since answer quite large print modulo $$$ 1000000000 + 7 $$$ first example $$$ 4 $$$ ways neko visit planets : second example $$$ 9 $$$ ways neko visit exactly $$$ 2 $$$ planets : third example $$$ m = 4 $$$ neko visit planets order $$$ 5 ! = 120 $$$ ways neko visit planets fourth example neko visit exactly $$$ 1 $$$ planet ( also planet initially locate ) $$$ 100 $$$ ways choose start planet neko,['dp'],2800.0
1168/C,"<unknown> <unknown> array integers $$$ a_1 a_2 \ldots a_n $$$ say $$$ y $$$ reachable $$$ x $$$ $$$ x < y $$$ exist integer array $$$ p $$$ $$$ x = p_1 < p_2 < \ldots < p_k = y $$$ $$$ a _ { p_i } \ \ & \ a _ { p _ { i+1 } } > 0 $$$ integers $$$ i $$$ $$$ 1 \leq i < k $$$ $$$ \ & $$$ denote bitwise operation give $$$ q $$$ pair indices check reachability first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \leq n \leq 300\,000 $$$ $$$ 1 \leq q \leq 300\,000 $$$ ) — number integers array number query need answer second line contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 300\,000 $$$ ) — give array next $$$ q $$$ line contain two integers $$$ i $$$ -th contain two space - separated integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \leq x_i < y_i \leq n $$$ ) need check $$$ y_i $$$ reachable $$$ x_i $$$ output $$$ q $$$ line $$$ i $$$ -th print ` ` <unknown> '' $$$ y_i $$$ reachable $$$ x_i $$$ otherwise print ` ` <unknown> '' first example $$$ a_3 = 0 $$$ ca n't reach always zero $$$ <unknown> \ & \ a_4 > 0 $$$ $$$ 4 $$$ reachable $$$ 2 $$$ go $$$ 1 $$$ $$$ 4 $$$ use $$$ p = [ 1 2 4 ] $$$",['dp'],2200.0
1215/E,monocarp arrange $$$ n $$$ color marble a row color $$$ i $$$ -th marble $$$ a_i $$$ monocarp like order things want rearrange marble a way marble color form a <unknown> segment ( one segment color ) word monocarp want rearrange marble every color $$$ j $$$ leftmost marble color $$$ j $$$ $$$ l $$$ -th row rightmost marble color position $$$ r $$$ row every marble $$$ l $$$ $$$ r $$$ color $$$ j $$$ achieve goal monocarp follow operation number time : choose two neighbour marble swap calculate minimum number operations monocarp perform rearrange marble note order segment marble equal color matter require every color marble color form exactly one contiguous segment first line contain one integer $$$ n $$$ $$$ ( 2 \le n \le 4 \cdot 100000 ) $$$ — number marble second line contain integer sequence $$$ a_1 a_2 \dots a_n $$$ $$$ ( 1 \le a_i \le 20 ) $$$ $$$ a_i $$$ color $$$ i $$$ -th marble print minimum number operations monocarp perform achieve goal first example three operations enough firstly monocarp swap third fourth marble sequence color $$$ [ 3 4 3 2 4 2 2 ] $$$ monocarp swap second third marble sequence $$$ [ 3 3 4 2 4 2 2 ] $$$ finally monocarp swap fourth fifth marble sequence $$$ [ 3 3 4 4 2 2 2 ] $$$ second example 's need perform operations,['dp'],2200.0
1221/G,"give undirected graph $$$ n $$$ vertices $$$ m $$$ edge write a number vertex graph number either $$$ 0 $$$ $$$ 1 $$$ , write a number edge equal sum number vertices incident edge choose number write vertices least one edge $$$ 0 $$$ write least one edge $$$ 1 $$$ least one edge $$$ 2 $$$ many ways ? two ways choose number different exist least one vertex different number write two ways first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 40 $$$ $$$ 0 \le m \le \frac { n ( n - 1 ) } { 2 } $$$ ) — number vertices number edge respectively $$$ m $$$ line follow line contain two number $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ ) — endpoints $$$ i $$$ -th edge guarantee pair vertices connect one edge print one integer — number ways write number vertices exist least one edge $$$ 0 $$$ write least one edge $$$ 1 $$$ least one edge $$$ 2 $$$",['dp'],2900.0
1234/F,give a string $$$ s $$$ consist first $$$ 20 $$$ lowercase latin letter ( ' a ' ' b ' ... ' t ' ) recall substring $$$ s [ l ; r ] $$$ string $$$ s $$$ string $$$ s_l s _ { l + 1 } \dots s_r $$$ example substrings ` ` codeforces '' ` ` code '' ` ` force '' ` ` f '' ` ` '' ` ` coder '' ` ` top '' perform follow operation : choose substring $$$ s [ l ; r ] $$$ reverse ( i.e string $$$ s_l s _ { l + 1 } \dots s_r $$$ become $$$ s_r s _ { r - 1 } \dots s_l $$$ ) goal maximize length maximum substring $$$ s $$$ consist distinct ( i.e unique ) character string consist distinct character character string appear example string ` ` abcde '' ` ` <unknown> '' ` ` <unknown> '' consist distinct character string ` ` codeforces '' ` ` abacaba '' consist distinct character line input contain one string $$$ s $$$ consist $$$ 1000000 $$$ character ' a ' ' b ' ... ' t ' ( first $$$ 20 $$$ lowercase latin letter ) print one integer — maximum possible length maximum substring $$$ s $$$ consist distinct character reverse one substring,['dp'],2200.0
1152/F2,problem previous one larger constraints aki play a new video game video game control neko giant cat fly planets catniverse $$$ n $$$ planets catniverse number $$$ 1 $$$ $$$ n $$$ begin game aki choose planet neko initially locate aki perform $$$ k - 1 $$$ move move neko move current planet $$$ x $$$ planet $$$ y $$$ : way neko visit exactly $$$ k $$$ different planets two ways visit planets call different index $$$ i $$$ $$$ i $$$ -th planet visit first way different $$$ i $$$ -th planet visit second way total number ways visit $$$ k $$$ planets way ? since answer quite large print modulo $$$ 1000000000 + 7 $$$ line contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \le n \le 1000000000 $$$ $$$ 1 \le k \le \min ( n 12 ) $$$ $$$ 1 \le m \le 4 $$$ ) — number planets catniverse number planets neko need visit say constant $$$ m $$$ print exactly one integer — number different ways neko visit exactly $$$ k $$$ planets since answer quite large print modulo $$$ 1000000000 + 7 $$$ first example $$$ 4 $$$ ways neko visit planets : second example $$$ 9 $$$ ways neko visit exactly $$$ 2 $$$ planets : third example $$$ m = 4 $$$ neko visit planets order $$$ 5 ! = 120 $$$ ways neko visit planets fourth example neko visit exactly $$$ 1 $$$ planet ( also planet initially locate ) $$$ 100 $$$ ways choose start planet neko,['dp'],3000.0
401/D,roman a young mathematician famous <unknown> unfortunately sereja n't think make sereja change mind roman ready solve mathematical problem think sereja ask roma find many number close number n modulo m. number x consider close number n modulo m : roman a good mathematician number number huge ask help first line contain two integers : n ( 1 ≤ n < 1018 ) m ( 1 ≤ m ≤ 100 ) a single line print a single integer — number number close number n modulo m. first sample require number : 104 <unknown> <unknown> . second sample require number <unknown>,['dp'],2000.0
413/D,programmers r2 company love play <unknown> . one day decide invent simplify version game — 2k a stripe imagine infinite one direction stripe consist unit square ( side square equal height stripe ) square either empty contain number initially square empty infinity one unit square number 2 4 appear player press a button appear number begin move towards begin stripe let 's assume number x move begin stripe stop : final stop number move process infinity get a new number 2 4 process repeat read note test sample better understand move strategy i guess ' ve understand game progress fully depend order number 2 4 appear let 's look sequence number 2 4 game assume sequence win result least one square get number greater equal 2k goal game make a win sequence n number everything simple number sequence identify beforehand give a sequence consist number 0 2 4 . count many ways replace 0 sequence 2 4 get a win sequence first line contain two integers n k ( 1 ≤ n ≤ 2000 ; 3 ≤ k ≤ 11 ) next line contain sequence n integers either 0 2 4 . print a single integer — number ways replace zero number 2 4 get a win sequence number rather large print modulo 1000000007 ( 109 + 7 ) consider first example begin strip look follow : 2 → 4 → 8 → 8 2 → 8 4 → 8 4 2 → 16 . better understand game see original game http : <unknown> please note game describe strip slightly different original game ( two number add original game keep move ) careful game <unknown> n't much time contest !,['dp'],2000.0
772/D,"give n integers a1 a2 ... , denote list integers t. let f ( l ) a function take a non - empty list integers l. function output another integer follow : example f ( 10 9 ) = 0 f ( 123 321 ) = 121 f ( <unknown> <unknown> <unknown> ) = 30 . define function word g ( x ) sum square sum elements nonempty subsequences t evaluate x plug f modulo 1 000 000 007 multiply x. last multiplication <unknown> would like compute g ( 0 ) g ( 1 ) ... g ( 999 999 ) reduce output size print value denote bitwise xor operator first line contain integer n ( 1 ≤ n ≤ 1 000 000 ) — size list t. next line contain n space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 999 999 ) — elements list output a single integer answer problem first sample nonzero value g g ( 121 ) = <unknown> <unknown> <unknown> g ( 123 ) = <unknown> <unknown> 999 g ( 321 ) = <unknown> <unknown> <unknown> g ( 555 ) = <unknown> <unknown> <unknown> . bitwise xor number equal <unknown> <unknown> <unknown> . example , since subsequences [ 123 ] [ 123 555 ] evaluate 123 plug f. second sample last sample , <unknown> coefficient",['dp'],2700.0
1185/G1,difference easy hard versions constraints polycarp love listen music never leave player even way home university polycarp <unknown> distance university house exactly $$$ t $$$ minutes player polycarp store $$$ n $$$ songs characterize two parameters : $$$ t_i $$$ $$$ g_i $$$ $$$ t_i $$$ length song minutes ( $$$ 1 \le t_i \le 15 $$$ ) $$$ g_i $$$ genre ( $$$ 1 \le g_i \le 3 $$$ ) polycarp want create a playlist listen music time way university home time arrival home playlist polycarp never <unknown> songs always listen begin end thus start listen $$$ i $$$ -th song would spend exactly $$$ t_i $$$ minutes listen polycarp also like two songs genre play a row ( i.e <unknown> / <unknown> ) songs playlist repeat help polycarpus count number different sequence songs ( order matter ) total duration exactly $$$ t $$$ two consecutive songs genre songs playlist different first line input contain two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 15 1 \le t \le <unknown> $$$ ) — number songs player require total duration respectively next $$$ n $$$ line contain descriptions songs : $$$ i $$$ -th line contain two integers $$$ t_i $$$ $$$ g_i $$$ ( $$$ 1 \le t_i \le 15 1 \le g_i \le 3 $$$ ) — duration $$$ i $$$ -th song genre respectively output one integer — number different sequence songs total length exactly $$$ t $$$ two consecutive songs genre songs playlist different since answer may huge output modulo $$$ 1000000000 + 7 $$$ ( remainder divide quantity $$$ 1000000000 + 7 $$$ ) first example polycarp make $$$ 6 $$$ possible playlist rearrange available songs : $$$ [ 1 2 3 ] $$$ $$$ [ 1 3 2 ] $$$ $$$ [ 2 1 3 ] $$$ $$$ [ 2 3 1 ] $$$ $$$ [ 3 1 2 ] $$$ $$$ [ 3 2 1 ] $$$ ( indices songs give ) second example first second songs go succession ( since genre ) thus polycarp create a playlist one $$$ 2 $$$ possible ways : $$$ [ 1 3 2 ] $$$ $$$ [ 2 3 1 ] $$$ ( indices songs give ) third example polycarp make follow <unknown> : $$$ [ 1 2 3 ] $$$ $$$ [ 1 3 2 ] $$$ $$$ [ 2 1 3 ] $$$ $$$ [ 2 3 1 ] $$$ $$$ [ 3 1 2 ] $$$ $$$ [ 3 2 1 ] $$$ $$$ [ 1 4 ] $$$ $$$ [ 4 1 ] $$$ $$$ [ 2 3 4 ] $$$ $$$ [ 4 3 2 ] $$$ ( indices songs give ),['dp'],2100.0
1342/F,"give array $$$ a $$$ consist $$$ n $$$ elements may apply several operations ( possibly zero ) operation choose two indices $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i j \le n $$$ ; $$$ i \ne j $$$ ) increase $$$ a_j $$$ $$$ a_i $$$ remove $$$ i $$$ -th element array ( indices elements right decrease $$$ 1 $$$ $$$ n $$$ also decrease $$$ 1 $$$ ) goal make array $$$ a $$$ strictly ascend , condition $$$ a_1 < a_2 < \dots < a_n $$$ hold ( $$$ n $$$ result size array ) calculate minimum number action require make array strictly ascend first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist two line first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 15 $$$ ) — number elements initial array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) guarantee : test case print answer follow : first line print $$$ k $$$ — minimum number operations perform print $$$ k $$$ line contain two indices $$$ i $$$ $$$ j $$$ correspond operation note numeration elements array change remove elements multiple optimal sequence operations print one first test case sequence operations change $$$ a $$$ follow : $$$ [ 2 1 3 5 1 2 4 5 ] \rightarrow [ 2 1 3 5 1 4 7 ] \rightarrow [ 1 3 5 1 6 7 ] \rightarrow [ 2 3 5 6 7 ] $$$",['dp'],3000.0
283/B,"farmer john give cow a program play ! program contain two integer variables x y perform follow operations a sequence a1 a2 ... positive integers : cow good arithmetic though want see program work please help ! give sequence a2 a3 ... , suppose i ( 1 ≤ i ≤ n - 1 ) run program sequence i a2 a3 ... , run output final value y program terminate -1 terminate first line contain a single integer n ( 2 ≤ n ≤ 2·105 ) next line contain n - 1 space separate integers a2 a3 ... ( 1 ≤ ai ≤ 109 ) output n - 1 line i - th line print request value program run sequence i a2 a3 ... please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first sample",['dp'],1700.0
379/D,many countries a new year christmas tradition write a letter santa include a wish list present vasya ordinary programmer boy like ordinary boys go write letter santa new year eve ( <unknown> actually expect santa new year christmas ) vasya come algorithm follow write a letter first choose two string s1 <unknown> s2 consist uppercase english letter boy make string sk use a recurrent equation sn = sn - 2 + sn - 1 operation ' + ' mean a concatenation ( sequential record ) string give order vasya write string sk a piece paper put <unknown> send santa vasya absolutely sure santa bring best present result string sk exactly x occurrences substring ac ( short - cut remind <unknown> accept problems ) besides vasya decide string s1 length n string s2 length m. vasya n't decide anything else moment vasya 's get <unknown> new year business ask choose two string s1 s2 require manner help vasya first line contain four integers k x n m ( 3 ≤ k ≤ 50 ; 0 ≤ x ≤ 109 ; 1 ≤ n m ≤ 100 ) first line print string s1 consist n uppercase english letter second line print string s2 consist m uppercase english letter multiple valid string print require pair string n't exist print ` ` happy new year ! '' without quote,['dp'],2000.0
1765/F,"monocarp plan open a chemistry lab first month 's go distribute solutions a certain acid first sign contract a local chemistry factory contract provide monocarp unlimited supply solution acid factory provide $$$ n $$$ contract options number $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th solution a concentration $$$ <unknown> % $$$ contract cost $$$ w_i $$$ burl monocarp able sell $$$ c_i $$$ burl per liter monocarp expect $$$ k $$$ customers first month customer buy a liter a $$$ y\ % $$$ <unknown> $$$ y $$$ a real number choose uniformly random $$$ 0 $$$ $$$ 100 $$$ independently customer formally probability number $$$ y $$$ less equal $$$ t $$$ $$$ p ( y \le t ) = \frac { t } { 100 } $$$ monocarp mix solution sign contract factory ratio formally contract $$$ m $$$ solutions <unknown> $$$ x_1 x_2 \dots <unknown> $$$ , solutions pick volumes $$$ a_1 a_2 \dots a_m $$$ $$$ \sum \limits _ { i=1 } ^ { m } a_i = 1 $$$ ( exactly $$$ 1 $$$ since customer want exactly one liter a certain solution ) concentration result solution $$$ \sum \limits _ { i=1 } ^ { m } x_i \cdot a_i $$$ price result solution $$$ \sum \limits _ { i=1 } ^ { m } c_i \cdot a_i $$$ monocarp obtain a solution concentration $$$ y\ % $$$ maximize price ( cost customer ) otherwise customer leave without buy anything price consider equal $$$ 0 $$$ monocarp want sign contract a factory ( possibly none ) expect profit maximize — expect total price sell solutions $$$ k $$$ customers minus total cost sign contract factory print maximum expect profit monocarp achieve first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 5000 $$$ ; $$$ 1 \le k \le 100000 $$$ ) — number contract factory provide number customers $$$ i $$$ -th next $$$ n $$$ line contain three integers $$$ x_i w_i $$$ $$$ c_i $$$ ( $$$ 0 \le x_i \le 100 $$$ ; $$$ 1 \le w_i \le 1000000000 $$$ ; $$$ 1 \le c_i \le 100000 $$$ ) — concentration solution cost contract cost per liter customer $$$ i $$$ -th contract print a single real number — maximum expect profit monocarp achieve answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -6 } $$$",['dp'],2200.0
1534/H,"interactive problem qualify ioi year little ericyi give a gift friends : a tree $$$ n $$$ nod ! flight ioi little ericyi bore decide play a game little yvonne new tree first little yvonne select two ( necessarily different ) nod $$$ a $$$ $$$ b $$$ tree ( without tell ericyi ) give a hint $$$ f $$$ ( node path $$$ a $$$ $$$ b $$$ ) , little ericyi able ask follow question repeatedly : little ericyi 's goal find nod $$$ a $$$ $$$ b $$$ report little yvonne however little yvonne think game easy give hint $$$ f $$$ little ericyi also want first find maximum number query require determine $$$ a $$$ $$$ b $$$ possibilities $$$ a $$$ $$$ b $$$ $$$ f $$$ assume little ericyi play optimally little ericyi define optimal strategy one make minimum number query course little ericyi reply maximum number query little yvonne let use many query game tree $$$ a $$$ $$$ b $$$ $$$ f $$$ fix start game change query make first read a line contain integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) number nod tree next $$$ n−1 $$$ line describe little ericyi 's tree line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) denote edge $$$ u $$$ $$$ v $$$ ( $$$ u \neq v $$$ ) guarantee edge form a tree output $$$ k $$$ maximum number query need determine $$$ a $$$ $$$ b $$$ possibilities $$$ a $$$ $$$ b $$$ $$$ f $$$ assume little ericyi play optimally output end line flush output print $$$ k $$$ read a line contain integer $$$ f $$$ ( $$$ 1 \le f \le n $$$ ) — hint : a node path $$$ a $$$ $$$ b $$$ inclusive , start make query limit make $$$ k $$$ query $$$ k $$$ number print query make format ` ` ? r '' $$$ r $$$ integer $$$ 1 \le r \le n $$$ denote root node want query receive integer $$$ x $$$ ( $$$ 1 \le x \le n $$$ ) lowest common ancestor $$$ a $$$ $$$ b $$$ tree root $$$ r $$$ program find nod $$$ a $$$ $$$ b $$$ report answer follow format : ` ` ! a b '' $$$ a $$$ $$$ b $$$ two hide nod terminate program normally immediately flush output stream may output $$$ a $$$ $$$ b $$$ order print a query forget output end line flush output otherwise get idleness limit exceed , use : point make invalid output make $$$ k $$$ query interaction terminate receive a wrong answer verdict invalid output define either invalid query a value $$$ k $$$ less $$$ 0 $$$ greater $$$ n $$$ hacksto hack a solution use follow format : first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) next $$$ n−1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) denote edge $$$ u $$$ $$$ v $$$ ( $$$ u \neq v $$$ ) $$$ n-1 $$$ edge must form a tree next line input contain nod $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le n $$$ ) separate a space final line input contain integer $$$ f $$$ ( $$$ 1 \le f \le n $$$ ) node $$$ f $$$ simple path $$$ a $$$ $$$ b $$$ ( inclusive ) tree first sample interaction nod $$$ a $$$ $$$ b $$$ highlight notice $$$ a $$$ $$$ b $$$ output order additionally answer query every single node $$$ 1,2 \ldots n $$$ convenience : _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <unknown> tree second sample interaction , nod $$$ a $$$ $$$ b $$$ highlight <unknown> answer query every single node $$$ 1,2 \ldots n $$$ ( example $$$ 2 $$$ ) convenience :",['dp'],3500.0
1746/E2,"difference problem hard version maximum number question interactive problem a hide integer $$$ 1 \le x \le n $$$ find order find ask $$$ <unknown> { 53 } $$$ question question choose a non - empty integer set $$$ s $$$ ask $$$ x $$$ belong $$$ s $$$ question $$$ x $$$ belong $$$ s $$$ 'll receive ` ` yes '' otherwise ` ` '' problem answer necessarily true ( joke ) 's guarantee two consecutive question least one answer correctly additionally question make $$$ 2 $$$ guess answer $$$ x $$$ time make a guess guess $$$ x $$$ correctly receive ` ` : ) '' program terminate otherwise 'll receive ` ` : ( ` ` a part joke fix value $$$ x $$$ begin instead change throughout interaction long previous responses valid describe note answer guess always answer correctly ask a question a guess least one two question answer correctly normal line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) maximum possible value $$$ x $$$ question want ask a set $$$ s $$$ first print character ' ? ' print size $$$ s $$$ print elements $$$ s $$$ one one element integer $$$ 1 $$$ $$$ n $$$ elements must distinct question read a string ` ` yes '' ` ` '' explain statement make $$$ 53 $$$ question want guess $$$ x $$$ first print character ' ! ' print guess guess read ` ` : ) '' ` ` : ( ` ` guess $$$ x $$$ correctly answer ` ` : ) '' program terminate immediately otherwise 'll receive ` ` : ( ` ` make $$$ 2 $$$ guess print a query forget output end line flush output otherwise get idleness limit exceed , use : hack allow problem answer first question correct $$$ x $$$ would equal $$$ 6 $$$ see first guess $$$ 6 $$$ answer answer first question joke know answer least one two question correct since answer first question joke answer second question correct understand $$$ x $$$ equal $$$ 1 2 3 $$$ $$$ 4 $$$ also know $$$ x $$$ equal $$$ 6 $$$ either hence $$$ x $$$ equal $$$ 5 $$$",['dp'],3200.0
51/F,undirected graph call a caterpillar a connect graph without cycle a path p vertex locate a distance 1 path p. caterpillar contain loop ( edge a vertex ) contain multiple ( parallel ) edge picture contain example a caterpillar : give undirected graph g. allow a merge operations operation merge two vertices one vertex two vertices a b ( a ≠ b ) choose <unknown> delete together edge ( incident least one vertices a b ) a new vertex w add together edge ( x w ) edge ( a w ) and/or ( b w ) edge ( a b ) transform loop ( w w ) result graph ( merge operation ) may contain multiple ( parallel ) edge pair vertices loop let us note operation decrease number vertices graph 1 leave number edge graph unchanged merge operation <unknown> describe a unity two vertices graph one natural transformation graph edge may apply operation consecutively make give graph a caterpillar write a program print minimal number merge operations require make give graph a caterpillar first line contain a pair integers n m ( 1 ≤ n ≤ 2000 ; 0 ≤ m ≤ 105 ) n represent number vertices graph m number edge follow m line contain edge descriptions one edge description per line every line contain a pair integers ai bi ( 1 ≤ ai bi ≤ n ; ai ≠ bi ) ai bi represent indices vertices connect edge vertices number 1 n. give graph one edge pair vertices give graph necessarily connect print minimal require number operations,['dp'],2800.0
1028/G,"problem interactive guess hide number $$$ x $$$ $$$ 1 $$$ $$$ m = <unknown> $$$ inclusive could use $$$ 5 $$$ query query output increase sequence $$$ k \leq x $$$ integers $$$ 1 $$$ $$$ m $$$ inclusive obtain one follow answer : see interaction section clarity aware interactor adaptive i.e hide number depend query solution make however guarantee solution interactor work non - <unknown> situation hide number fix beforehand hack allow fix hide number a hack represent a single integer $$$ 1 $$$ $$$ m $$$ pretests hide number fix well make $$$ 5 $$$ query make a query print a number $$$ k $$$ ( $$$ 1 \le k \le 10000 $$$ ) increase sequence $$$ <unknown> < t_1 < \ldots < t _ { k-1 } $$$ $$$ k $$$ number $$$ 1 $$$ $$$ m $$$ inclusive $$$ k > x $$$ lose get one integer a response print a query forget output end line flush output otherwise get idleness limit exceed , use : first example number $$$ 5 $$$ hide",['dp'],3000.0
1264/D1,easy version problem difference limit $$$ n $$$ - length input string version $$$ 1 \leq n \leq 2000 $$$ hard version challenge offer round second division let 's define a correct bracket sequence depth follow : a ( necessarily correct ) bracket sequence $$$ s $$$ define depth maximum depth correct bracket sequence induce remove character $$$ s $$$ ( possibly zero ) example : bracket sequence $$$ s = $$$ ` ` ( ) ) ( ( ) ) '' depth $$$ 2 $$$ remove third character obtain a correct bracket sequence ` ` ( ) ( ( ) ) '' depth $$$ 2 $$$ give a string $$$ a $$$ consist character ' ( ' ' ) ' ' ? ' consider ( necessarily correct ) bracket sequence obtain replace character ' ? ' $$$ a $$$ either ' ( ' ' ) ' calculate sum <unknown> bracket sequence number large find modulo $$$ 998244353 $$$ hack problem first division do easy hard versions problem solve line contain a non - empty string consist ' ( ' ' ) ' ' ? ' length string $$$ 2000 $$$ print answer modulo $$$ 998244353 $$$ a single line first test case obtain $$$ 4 $$$ bracket sequence replace character ' ? ' either ' ( ' ' ) ' : answer $$$ 1 = 0 + 0 + 0 + 1 $$$ second test case obtain $$$ 4 $$$ bracket sequence replace character ' ? ' either ' ( ' ' ) ' : answer $$$ 9 = 2 + 2 + 3 + 2 $$$,['dp'],2600.0
1295/F,online contest soon hold forcecoders a large competitive program platform author prepare $$$ n $$$ problems ; since platform popular $$$ 998244351 $$$ coder world go solve problem author estimate number people would solve : $$$ i $$$ -th problem number accept solutions $$$ l_i $$$ $$$ r_i $$$ inclusive creator forcecoders use different criteria determine contest good bad one criteria number inversions problem order inversion a pair problems $$$ ( x y ) $$$ $$$ x $$$ locate earlier contest ( $$$ x < y $$$ ) number accept solutions $$$ y $$$ strictly greater obviously creator forcecoders author contest want contest good want calculate probability inversions problem order assume problem $$$ i $$$ integral number accept solutions ( $$$ l_i $$$ $$$ r_i $$$ ) equally probable number independent first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 50 $$$ ) — number problems contest $$$ n $$$ line follow $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 0 \le l_i \le r_i \le 998244351 $$$ ) — minimum maximum number accept solutions $$$ i $$$ -th problem respectively probability inversions contest express irreducible fraction $$$ \frac { x } { y } $$$ $$$ y $$$ coprime $$$ 998244353 $$$ print one integer — value $$$ <unknown> { -1 } $$$ take modulo $$$ 998244353 $$$ $$$ y^ { -1 } $$$ integer $$$ <unknown> { -1 } \equiv 1 $$$ $$$ ( mod $$$ $$$ 998244353 ) $$$ real answer first test $$$ \frac { 1 } { 2 } $$$,['dp'],2700.0
1765/C,"consider a deck card card one $$$ 4 $$$ suit exactly $$$ n $$$ card suit — total number card deck $$$ 4n $$$ deck shuffle randomly $$$ ( 4n ) ! $$$ possible order card deck probability result shuffle let $$$ c_i $$$ $$$ i $$$ -th card deck ( top bottom ) monocarp start draw card deck one one draw a card try guess suit monocarp remember suit $$$ k $$$ last card guess suit appear least often among last $$$ k $$$ card draw , draw $$$ i $$$ -th card monocarp guess suit suit appear minimum number time among card $$$ c _ { i - k } c _ { i - k+1 } \dots c _ { i-1 } $$$ ( $$$ i \le k $$$ monocarp consider previously draw card , card $$$ c_1 c_2 \dots c _ { i-1 } $$$ ) multiple suit appear minimum number time among previous card monocarp remember choose a random suit guess ( suit appear minimum number time probability choose ) make a guess monocarp draw a card compare suit guess match guess correct ; otherwise incorrect task calculate expect number correct guess monocarp make draw $$$ 4n $$$ card deck first ( ) line contain two integers $$$ n $$$ ( $$$ 1 \le n \le 500 $$$ ) $$$ k $$$ ( $$$ 1 \le k \le 4 \cdot n $$$ ) let expect value calculate irreducible fraction $$$ \dfrac { x } { y } $$$ print one integer — value $$$ x \cdot y^ { -1 } \bmod 998244353 $$$ $$$ y^ { -1 } $$$ inverse $$$ y $$$ ( i. e. integer $$$ y \cdot y^ { -1 } \bmod 998244353 = 1 $$$ )",['dp'],2600.0
1784/E,"alice bob play infinite game consist set set consist round round one players win first player win two round a set win set thus a set always end score $$$ <unknown> $$$ $$$ <unknown> $$$ favor one players let 's call a game scenario a finite string $$$ s $$$ consist character ' a ' ' b ' consider infinite string form <unknown> string $$$ s $$$ : $$$ sss \ldots $$$ suppose alice bob play round accord infinite string leave right a character string $$$ sss \ldots $$$ ' a ' alice win round ; 's ' b ' bob win round soon one players win two round set end favor a new set start next round let 's define $$$ a_i $$$ number set alice among first $$$ i $$$ set play accord give scenario let 's also define $$$ r $$$ limit ratio $$$ \frac { a_i } { i } $$$ $$$ i \rightarrow <unknown> $$$ $$$ r > \frac { 1 } { 2 } $$$ 'll say scenario $$$ s $$$ win alice $$$ r = \frac { 1 } { 2 } $$$ 'll say scenario $$$ s $$$ tie $$$ r < \frac { 1 } { 2 } $$$ 'll say scenario $$$ s $$$ win bob give a string $$$ s $$$ consist character ' a ' ' b ' ' ? ' consider possible ways replace every ' ? ' ' a ' ' b ' obtain a string consist character ' a ' ' b ' count many result a scenario win alice many result a tie scenario many result a scenario win bob print three number modulo $$$ 998\,244\,353 $$$ line contain a single string $$$ s $$$ ( $$$ 1 \le |s| \le 200 $$$ ) consist character ' a ' ' b ' ' ? ' print three integers : many ways result a scenario win alice many result a tie scenario many result a scenario win bob modulo $$$ 998\,244\,353 $$$ first example four ways replace question mark :",['dp'],3100.0
1439/D,"today final contest <unknown> ( <unknown> national olympiad informatics ) contest room a row $$$ n $$$ computers computers number integers $$$ 1 $$$ $$$ n $$$ leave right $$$ m $$$ participants number integers $$$ 1 $$$ $$$ m $$$ array $$$ a $$$ length $$$ m $$$ $$$ a _ { i } $$$ ( $$$ 1 \leq a_i \leq n $$$ ) computer behind $$$ i $$$ -th participant want sit also another array $$$ b $$$ length $$$ m $$$ consist character ' l ' ' r ' $$$ b_i $$$ side $$$ i $$$ -th participant enter room ' l ' mean participant enter leave computer $$$ 1 $$$ go leave right ' r ' mean participant enter right computer $$$ n $$$ go right leave participants order $$$ 1 $$$ $$$ m $$$ enter room one one $$$ i $$$ -th enter contest room direction $$$ b_i $$$ go sit behind $$$ a_i $$$ -th computer occupy keep walk direction reach first unoccupied computer , sit behind n't find computer get upset give contest madness $$$ i $$$ -th participant distance assign computer ( $$$ a_i $$$ ) computer end sit behind distance computers $$$ i $$$ $$$ j $$$ equal $$$ |i - j| $$$ value array $$$ a $$$ equal exist $$$ <unknown> \cdot 2^m $$$ possible pair array $$$ ( a b ) $$$ consider pair array $$$ ( a b ) $$$ person become upset let 's calculate sum participants madnesses find sum value give prime modulo $$$ p $$$ find sum modulo $$$ p $$$ line contain three integers $$$ n $$$ $$$ m $$$ $$$ p $$$ ( $$$ 1 \leq m \leq n \leq 500 100000000 \leq p \leq 10 ^ 9 + 9 $$$ ) guarantee number $$$ p $$$ prime print one integer — require sum modulo $$$ p $$$ first test three possible array $$$ a $$$ : $$$ \ { 1\ } $$$ $$$ \ { 2\ } $$$ $$$ \ { 3\ } $$$ two possible array $$$ b $$$ : $$$ \ { \mathtt { l } \ } $$$ $$$ \ { \mathtt { r } \ } $$$ six pair array $$$ ( a b ) $$$ participant sit behind computer $$$ a_1 $$$ madness $$$ 0 $$$ total sum madnesses $$$ 0 $$$ second test possible pair array $$$ ( a b ) $$$ person become upset : answer $$$ 1 + 1 + 1 + 1 + 0 \ldots = 4 $$$",['dp'],3100.0
1792/F2,difference easy hard version constraint $$$ n $$$ give undirected complete graph $$$ n $$$ vertices a complete graph a graph pair vertices connect edge paint edge graph two color red blue ( edge one color ) a set vertices $$$ s $$$ red - connected every pair vertices $$$ ( v_1 v_2 ) $$$ $$$ v_1 \in s $$$ $$$ v_2 \in s $$$ exist a path $$$ v_1 $$$ $$$ v_2 $$$ go red edge vertices $$$ s $$$ similarly a set vertices $$$ s $$$ blue - connected every pair vertices $$$ ( v_1 v_2 ) $$$ $$$ v_1 \in s $$$ $$$ v_2 \in s $$$ exist a path $$$ v_1 $$$ $$$ v_2 $$$ go blue edge vertices $$$ s $$$ paint graph a way : calculate number ways paint graph print modulo $$$ 998244353 $$$ first ( ) line contain one integer $$$ n $$$ ( $$$ 3 \le n \le 50000 $$$ ) print one integer — number ways paint graph take modulo $$$ 998244353 $$$,['dp'],2900.0
161/D,a tree a connect graph n't contain cycle distance two vertices a tree length ( edge ) shortest path vertices give a tree n vertices a positive number k. find number distinct pair vertices a distance exactly k note pair ( v u ) ( u v ) consider pair first line contain two integers n k ( 1 ≤ n ≤ 50000 1 ≤ k ≤ 500 ) — number vertices require distance vertices next n - 1 line describe edge ` ` ai bi '' ( without quote ) ( 1 ≤ ai bi ≤ n ai ≠ bi ) ai bi vertices connect i - th edge give edge different print a single integer — number distinct pair tree 's vertices a distance exactly k please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first sample pair vertexes distance 2 ( 1 3 ) ( 1 5 ) ( 3 5 ) ( 2 4 ),['dp'],1800.0
1408/G,"$$$ n $$$ computers company network number $$$ 1 $$$ $$$ n $$$ pair two computers $$$ 1 \leq i < j \leq n $$$ know value $$$ a _ { i j } $$$ : difficulty send data computers $$$ i $$$ $$$ j $$$ value $$$ a _ { i j } $$$ $$$ i < j $$$ different want separate computers $$$ k $$$ set $$$ a_1 a_2 \ldots a_k $$$ follow condition satisfy : $$$ 1 \leq k \leq n $$$ find number ways divide computers $$$ k $$$ group require condition satisfy value large need find modulo $$$ 998\,244\,353 $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1500 $$$ ) : number computers $$$ i $$$ -th next $$$ n $$$ line contain $$$ n $$$ integers $$$ a _ { i,1 } a _ { i,2 } \ldots a _ { i n } $$$ ( $$$ 0 \leq a _ { i j } \leq \frac { n ( n-1 ) } { 2 } $$$ ) guarantee : print $$$ n $$$ integers : $$$ k $$$ -th equal number possible ways divide computers $$$ k $$$ group require condition satisfy modulo $$$ 998\,244\,353 $$$ possible ways separate computers $$$ 4 $$$ group second example :",['dp'],2700.0
424/E,cold winter even tomsk bore — nobody want streets a time residents tomsk away time sit warm apartments invent a lot different game one game ' colored <unknown> ' game require wooden block three color : red green blue a tower n level make level consist three wooden block block level arbitrary color always locate close parallel example a tower show figure game play exactly one person every minute a player throw a special dice six side two side dice green two blue one red one black dice show side equiprobably dice show red green blue player must take block color tower minute tower n't fall possible player wait end minute without touch tower also wait end minute without touch tower dice show black side allow take block top level tower ( whether complete ) a player get a block must put top tower form a new level finish upper level consist previously place block newly construct level properties initial level upper level complete start new level prohibit tower fall level except top least one block moreover level exactly one block leave block middle block tower fall game end moment block tower take tower n't fall a wonderful game invent residents city tomsk i wonder many minutes game last player act optimally well ? a player act optimally well moment try choose block take minimize expect number game duration task write a program determine expect number desire amount minutes first line input contain integer n ( 2 ≤ n ≤ 6 ) — number level tower n line follow describe level tower bottom top ( first line top tower ) level describe three character first third set border block level second one middle block character describe block one follow value ' r ' ( a red block ) ' g ' ( a green block ) ' b ' ( a blue block ) line output print seek mathematical expectation value answer consider correct relative absolute error n't exceed 10 - 6,['dp'],2500.0
455/C,andrew play a game call ` ` civilization '' dima help game n cities m bidirectional roads cities number 1 n. pair cities either a single ( unique ) path path a path a sequence distinct cities v1 v2 ... vk a road contiguous cities vi vi + 1 ( 1 ≤ i < k ) length describe path equal ( k - 1 ) assume two cities lie region a path connect two cities game events two type take place : dima find hard execute andrew 's query ask help help dima first line contain three integers n m q ( 1 ≤ n ≤ 3·105 ; 0 ≤ m < n ; 1 ≤ q ≤ 3·105 ) — number cities number roads already number query correspondingly follow m line contain two integers ai bi ( ai ≠ bi ; 1 ≤ ai bi ≤ n ) number represent road cities ai bi one road two cities follow q line contain one two events follow format : event first type print answer a separate line,['dp'],2100.0
461/B,appleman a tree n vertices vertices ( least one ) color black vertices color white consider a set consist k ( 0 ≤ k < n ) edge appleman 's tree appleman delete edge tree split ( k + 1 ) part note part a tree color vertices appleman wonder number set split tree a way result part exactly one black vertex ? find number modulo 1000000007 ( 109 + 7 ) first line contain integer n ( 2 ≤ n ≤ 105 ) — number tree vertices second line contain description tree : n - 1 integers p0 p1 ... pn - 2 ( 0 ≤ pi ≤ i ) pi mean edge connect vertex ( i + 1 ) tree vertex pi consider tree vertices number 0 n - 1 . third line contain description color vertices : n integers x0 x1 ... xn - 1 ( xi either 0 1 ) xi equal 1 vertex i color black otherwise vertex i color white output a single integer — number ways split tree modulo 1000000007 ( 109 + 7 ),['dp'],2000.0
467/D,help fedor find friends « call soldier 3 » game stop study completely today english teacher tell prepare essay fedor n't want prepare essay ask alex help alex come help write essay fedor fedor n't like essay fedor go change essay use synonym dictionary english language fedor want change mean essay change would : change a word essay one synonyms base a replacement rule dictionary fedor may perform operation number time a result fedor want get essay contain little letter « r » ( case n't matter ) possible multiple essay minimum number « r » s want get one minimum length ( length essay sum lengths word ) help fedor get require essay please note problem case letter n't matter example synonym dictionary say word cat replace word dog allow replace word cat word dog first line contain a single integer m ( 1 ≤ m ≤ 105 ) — number word initial essay second line contain word essay word separate a single space guarantee total length word wo n't exceed 105 character next line contain a single integer n ( 0 ≤ n ≤ 105 ) — number pair word synonym dictionary i - th next n line contain two space - separated non - empty word xi yi mean word xi replace word yi ( vise versa ) guarantee total length pair synonyms n't exceed 5·105 character word input consist uppercase lowercase letter english alphabet print two integers — minimum number letter « r » optimal essay minimum length optimal essay,['dp'],2400.0
505/C,shuseki islands <unknown> <unknown> small islands <unknown> sea islands evenly space along a line number 0 30000 west east islands know contain many treasure n gems shuseki islands total i - th gem locate island pi mr . kitayuta arrive island 0 . great jump ability repeatedly perform jump islands east accord follow process : mr . kitayuta collect gems islands visit process find maximum number gems collect first line input contain two space - separated integers n d ( 1 ≤ n d ≤ 30000 ) denote number gems shuseki islands length mr . kitayuta 's first jump respectively next n line describe location gems i - th ( 1 ≤ i ≤ n ) contain a integer pi ( d ≤ p1 ≤ p2 ≤ ... ≤ pn ≤ 30000 ) denote number island contain i - th gem print maximum number gems mr . kitayuta collect first sample optimal route 0 → 10 ( +1 gem ) → 19 → 27 ( +2 gems ) → ... <unknown> second sample optimal route 0 → 8 → 15 → 21 → 28 ( +1 gem ) → 36 ( +1 gem ) → 45 ( +1 gem ) → <unknown> ( +1 gem ) → 66 ( +1 gem ) → 78 ( +1 gem ) → ... third sample optimal route 0 → 7 → 13 → 18 ( +1 gem ) → 24 ( +2 gems ) → 30 ( +1 gem ) → .,['dp'],1900.0
507/E,"break good a new video game a lot gamers want a certain level game really difficult even experience gamers walter william main character game want join a gang call <unknown> <unknown> ( <unknown> ) gang control whole country consist n cities m bidirectional roads connect road connect a city two cities one road country connect word possible reach city city use give roads roads n't work roads need work perform completely function gang go rob a bank ! bank locate city 1 . usual hardest part escape headquarter police ca n't get gang 's headquarter city n. gain gang 's trust walter charge operation come a smart plan first path go use way back city 1 headquarter n must short possible since important finish operation fast possible , gang blow roads country n't lay path order prevent police <unknown> case non - <unknown> road n't blow already <unknown> choose path roads n't work 'll repair roads operation walter discover a lot paths satisfy condition shortest possible decide choose among a path minimize total number affect roads ( roads blow roads repair ) help walter complete task gain gang 's trust ? first line input contain two integers n m ( 2 ≤ n ≤ 105 ) number cities number roads respectively follow m line descriptions roads description consist three integers x y z ( 1 ≤ x y ≤ n ) mean a road connect cities number x y. z = 1 road work otherwise first line output one integer k minimum possible number roads affect gang follow k line output three integers describe roads affect line contain three integers x y z ( 1 ≤ x y ≤ n ) cities connect a road new state a road z = 1 indicate road cities x y repair z = 0 mean road blow may output roads order affect road appear exactly may output cities connect a single road order output a road 's original state different <unknown> perform operations <unknown> plan remain work roads lie certain shortest past city 1 n. multiple optimal answer output first test path 1 - 2 in second test shortest path 1 - 3 - 4 in third test multiple shortest paths optimal 1 - 4 - 6 - 8",['dp'],2100.0
513/G1,give a permutation n number p1 p2 ... pn perform k operations follow type : choose uniformly random two indices l r ( l ≤ r ) reverse order elements pl pl + 1 ... pr task find expect value number inversions result permutation first line input contain two integers n k ( 1 ≤ n ≤ 100 1 ≤ k ≤ 109 ) next line contain n integers p1 p2 ... pn — give permutation pi different range 1 n. problem consist three subproblems subproblems different constraints input get score correct submission subproblem description subproblems follow output answer absolute relative error 1e - 9 . consider first sample test randomly pick interval permutation ( 1 2 3 ) ( inversions ) reverse order elements probability interval consist a single element permutation alter probability inverse first two elements ' order obtain permutation ( 2 1 3 ) one inversion probability might pick interval consist last two elements lead permutation ( 1 3 2 ) one inversion finally probability randomly pick interval contain elements lead permutation ( 3 2 1 ) 3 inversions hence expect number inversions equal,['dp'],1800.0
1835/E,"latest mission starship u. s. s. coder captain jan <unknown> accidentally teleport surface unknown planet try find way back jan find <unknown> planet earth 's ancient civilization — a mobile device <unknown> <unknown> call create <unknown> unfortunately another problem even though jan a <unknown> humans know perfectly old notation cell phone number symbols device 's keyboard completely wear invisible human eye old keyboards exactly $$$ m + 1 $$$ button one digit base $$$ m $$$ numerical system one single backspace button allow one erase last write digit ( nothing write screen button nothing 's still count press ) jan would like communicate crew need type a certain number ( also base $$$ m $$$ numerical system , digits $$$ 0 $$$ $$$ m - 1 $$$ ) want know expect number button press necessary contact u. s. s. coder jan always choose optimal button base current <unknown> button indistinguishable press help ! first line input two integer number $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 1000000 $$$ $$$ 2 \le m \le 1000 $$$ ) — length number u. s. s. coder base numerical system next last input line $$$ n $$$ integers $$$ 0 $$$ $$$ m - 1 $$$ : number type base $$$ m $$$ numerical system output expect number button press modulo $$$ 1\,000\,000\,007 $$$ formally let $$$ m = 1\,000\,000\,007 $$$ show answer express irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \not \equiv 0 \pmod { m } $$$ output integer equal $$$ p \cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \le x < m $$$ $$$ x \cdot q \equiv p \pmod { m } $$$ first example two digits ( $$$ 0 $$$ $$$ 1 $$$ ) a backspace button available keyboard jan way know one press a random one probability $$$ \frac { 1 } { 3 } $$$ press $$$ 0 $$$ manage type crew 's number probability $$$ \frac { 1 } { 3 } $$$ press backspace nothing happen probability $$$ \frac { 1 } { 2 } $$$ manage press $$$ 0 $$$ ( finish process ) otherwise probability $$$ \frac { 1 } { 2 } $$$ type $$$ 1 $$$ need remove backspace hit last button $$$ 0 $$$ case need $$$ 4 $$$ button press last might press $$$ 1 $$$ button first also probability $$$ \frac { 1 } { 3 } $$$ , press backspace a chance $$$ <unknown> % $$$ set need press last button ( 3 press total ) worst case would press $$$ 0 $$$ button first need remove backspace finally type number $$$ 0 $$$ ( 5 press total ) get expect value $$$ \frac { 16 } { 6 } $$$ modular inverse $$$ 6 $$$ modulo $$$ 1\ ; 000\ ; 000\ ; 007 $$$ $$$ <unknown> $$$ $$$ <unknown> = <unknown> \mod \ ; 1\ ; 000\ ; 000\ ; 007 $$$",['dp'],3500.0
1096/G,bus ticket berland number a number consist $$$ n $$$ digits ( $$$ n $$$ even ) $$$ k $$$ decimal digits $$$ d_1 d_2 \dots d_k $$$ use form ticket number $$$ 0 $$$ among digits number may lead zero example $$$ n = 4 $$$ digits $$$ 0 $$$ $$$ 4 $$$ use $$$ 0000 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ valid ticket number $$$ 0002 $$$ $$$ 00 $$$ $$$ <unknown> $$$ a ticket lucky sum first $$$ n / 2 $$$ digits equal sum remain $$$ n / 2 $$$ digits calculate number different lucky ticket berland since answer may big print modulo $$$ 998244353 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ $$$ ( 2 \le n \le 2 \cdot 100000 1 \le k \le 10 ) $$$ — number digits ticket number number different decimal digits may use $$$ n $$$ even second line contain a sequence pairwise distinct integers $$$ d_1 d_2 \dots d_k $$$ $$$ ( 0 \le d_i \le 9 ) $$$ — digits may use ticket number digits give arbitrary order print number lucky ticket number take modulo $$$ 998244353 $$$ first example $$$ 6 $$$ lucky ticket number : $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ one ticket number second example consist $$$ 20 $$$ digits $$$ 6 $$$ ticket number lucky answer $$$ 1 $$$,['dp'],2400.0
516/D,"drazil varda earthworm couple want find a good place bring children find a good grind contain nature hole hole contain many room pair room connect small tunnel earthworm move let 's consider room small tunnel vertices edge a graph graph a tree word pair vertices unique path room leaf graph connect a grind a vertical tunnel , leaf a vertex one outgo edge graph room large enough fit one earthworm live earthworm ca n't live a tunnel drazil varda a plan <unknown> children want children morning exercise immediately get ! morning come earthworm children get time choose farthest path grind gather others ( children lazy want exercise late possible ) drazil varda want difference time first earthworm child arrive outside time last earthworm child arrive outside larger l ( otherwise children spread around grind hard keep exercise together ) also room occupy children form a connect set word two room occupy earthworm children room lie path occupy earthworm children many children drazil varda may order satisfy condition ? drazil varda want know answer many different choices l. ( drazil varda n't live hole children ) first line contain one integer n denote many room hole ( 2 ≤ n ≤ 105 ) n - 1 line follow line contain three integers x y v ( 1 ≤ x y ≤ n 1 ≤ v ≤ 106 ) denote a small tunnel room x room y take time v pass suppose time earthworm get grind leaf room next line contain integer q ( 1 ≤ q ≤ 50 ) denote number different value l need process last line contain q number number denote a value l ( 1 ≤ l ≤ <unknown> ) print q line line contain one integer denote answer a correspond value l. first sample hole look like follow room 1 5 leave contain a vertical tunnel connect grind lengths farthest path room 1 – 5 grind 12 9 7 9 12 respectively l = 1 may choose single room l = 2 .. 4 may choose room 2 3 4 answer l = 5 may choose room",['dp'],2800.0
522/A,"one day polycarp publish a funny picture a social network make a <unknown> color handle many friends start <unknown> polycarp 's joke news fee reposted reposts events give a sequence string ` ` name1 reposted name2 '' name1 name person reposted joke name2 name person whose news fee joke reposted guarantee string ` ` name1 reposted name2 '' user ` ` name1 '' n't joke fee yet ` ` name2 '' already fee moment repost polycarp register ` ` polycarp '' initially joke fee polycarp measure popularity joke length largest repost chain print popularity polycarp 's joke first line input contain integer n ( 1 ≤ n ≤ 200 ) — number reposts next follow reposts order make write a single line look ` ` name1 reposted name2 '' name input consist lowercase uppercase english letter and/or digits lengths 2 24 character inclusive know user name case - insensitive , two name differ letter case correspond social network user print a single integer — maximum length a repost chain",['dp'],1200.0
369/D,"one fine morning n fool line a row , number number 1 n inclusive fool get a unique number fool decide change number end fun every fool exactly k bullets a <unknown> addition fool number i probability pi ( percent ) kill fool shoot fool decide several round fun round fun look like : currently live fool shoot another live fool smallest number ( a fool <unknown> enough shoot ) shots round <unknown> one time ( simultaneously ) exactly one live fool shoot let 's define a situation set number live fool time say a situation possible integer number j ( 0 ≤ j ≤ k ) a nonzero probability j round fun situation occur valera know number p1 p2 ... pn k. help valera determine number distinct possible situations first line contain two integers n k ( 1 ≤ n k ≤ 3000 ) — initial number fool number bullets fool second line contain n integers p1 p2 ... pn ( 0 ≤ pi ≤ 100 ) — give probabilities ( percent ) print a single number — answer problem first sample situation possible except situation { 1 2 } second sample exactly one fool make shots third sample possible situations { 1 2 } ( zero round ) ` ` empty '' situation { } ( one round ) fourth sample possible situation { 1 2 3 }",['dp'],2200.0
354/E,know lucky digits digits 4 7 however vasya 's get another favorite digit 0 assume also lucky ! lucky number non - negative integers whose decimal record contain lucky digits example number 0 47 <unknown> lucky 1 <unknown> <unknown> -7 vasya t important positive integers need remember vasya quite superstitious want remember lucky number ask important number represent a sum exactly six lucky number ( vasya ca n't remember number ) vasya remember six number calculate important number moment t important integers represent sum six lucky number state impossible first line contain a single integer t ( 1 ≤ t ≤ 5000 ) next t line contain a single positive integer ni ( 1 ≤ ni ≤ 1018 ) — list important number please use % lld read write 64 - bit integers с++ prefer read cin cout stream % i64d specifier print t line i - th line must contain answer i - th important number : solution exist line must contain exactly six lucky number sum equal ni solution n't exist string must contain a single integer -1 . multiple answer print,['dp'],2200.0
348/E,a long time ago a land call dudeland dudeland consist n towns connect n - 1 <unknown> roads towns index 1 n one reach city city move along roads country m monasteries dudeland locate m different towns monastery live a pilgrim begin year pilgrim write monastery farthest monastery live one farthest monastery list big <unknown> day pilgrim pick one town paper random start walk town walter hat pilgrims want make many unhappy possible prevent finish journey plan destroy exactly one town contain a monastery a pilgrim become unhappy monasteries list become <unknown> monastery live need find maximum number pilgrims walter make unhappy also find number ways make maximal number pilgrims unhappy : number possible towns destroy first line contain two integers n ( 3 ≤ n ≤ 105 ) m ( 2 ≤ m < n ) next line contain m distinct integers represent indices towns contain monasteries next n - 1 line contain three integers ai bi ci indicate edge towns ai bi length ci ( 1 ≤ ai bi ≤ n 1 ≤ ci ≤ 1000 ai ≠ bi ) output two integers : maximum number pilgrims walter make unhappy number ways make plan come true,['dp'],2800.0
212/E,<unknown> n. a huge problem roads food it - infrastructure total city n junctions pair connect bidirectional roads road network consist n - 1 roads get junction one roads yes 're right — road network form undirected tree recently mayor come a way eliminate problems food it - infrastructure time ! decide put city junctions restaurants two well - known cafe network <unknown> : ` ` imac d0naldz '' ` ` burger bing '' since network <unknown> friends strictly prohibit place two restaurants different network neighbor junctions requirements 's full list : mayor go take a large tax restaurant interest make total number restaurants large possible help mayor analyze situation find pair ( a b ) a restaurants belong ` ` imac d0naldz '' b restaurants belong ` ` burger bing '' sum a + b large possible first input line contain integer n ( 3 ≤ n ≤ 5000 ) — number junctions city next n - 1 line list roads one per line road give a pair integers xi yi ( 1 ≤ xi yi ≤ n ) — index connect junctions consider junctions index 1 n. guarantee give road network represent undirected tree n vertexes print first line integer z — number seek pair print seek pair ( a b ) order increase first component a. figure show answer first test case junctions ` ` imac d0naldz '' restaurants mark red ` ` burger bing '' restaurants mark blue,['dp'],1500.0
219/D,country treeland consist n cities pair connect <unknown> roads overall n - 1 roads country know n't take direction roads consideration get city one council elders recently decide choose capital treeland course a city country council suppose meet capital regularly move capital cities ( stage nobody think get back capital cities ) reason city a choose a capital roads must orient move along get city a city roads may inversed help elders choose capital inverse minimum number roads country first input line contain integer n ( 2 ≤ n ≤ 2·105 ) — number cities treeland next n - 1 line contain descriptions roads one road per line a road describe a pair integers si ti ( 1 ≤ si ti ≤ n ; si ≠ ti ) — number cities connect road i - th road orient city si city ti consider cities treeland index 1 n. first line print minimum number roads inversed capital choose optimally second line print possible ways choose capital — a sequence index cities increase order,['dp'],1700.0
1245/E,hyakugoku retire resident <unknown> south black <unknown> temple order <unknown> dream become a <unknown> spend six months temple play ` ` cat 's <unknown> '' want try a different game — ` ` snake ladder '' unfortunately already kill snake ladder leave game play a $$$ 10 \times 10 $$$ board follow : please note : hyakugoku want finish game soon possible thus turn choose whether climb ladder optimally help determine minimum expect number turn game take input consist ten line $$$ i $$$ -th line contain 10 non - negative integers $$$ h _ { i1 } h _ { i2 } \dots h _ { <unknown> } $$$ $$$ h _ { ij } $$$ $$$ 0 $$$ tile $$$ i $$$ -th row $$$ j $$$ -th column ladder otherwise ladder tile a height $$$ h _ { ij } $$$ i.e climb lead tile $$$ h _ { ij } $$$ row directly guarantee $$$ 0 \leq h _ { ij } < i $$$ also first number first line first number last line always contain $$$ 0 $$$ i.e goal start tile never ladder print one line contain a single <unknown> - point number — minimum expect number turn hyakugoku take finish game answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ a <unknown> path board example 2 follow : tile 's ' start tile tile ' e ' goal first example ladder second example board look like one right part image ( ladder color clarity ) possible ladder overlap case red yellow ladder green blue ladder also possible ladder go straight top case black blue ladder however possible ladder go higher ( outside board ) also possible two ladder lead tile case red yellow ladder also notice red yellow ladder lead tile orange ladder player choose climb either red yellow ladder able climb orange ladder finally notice green ladder pass start tile blue ladder player transfer green ladder blue ladder middle climb green ladder,['dp'],2300.0
316/B2,rush modern life people often forget beautiful world time enjoy around little even stand queue several room time clinic run one queue another ( <unknown> note : stand huge <unknown> queue hours a native tradition russia date back soviet period queue resemble crowd rather line get lose a queue a person follow a strict <unknown> technique : approach queue ask last person somebody answer join crowd 're last person queue till somebody else show keep eye one last chance get destination ) i ' m sure many people problem a stranger ask last person queue even <unknown> hint last queue <unknown> away unknown destination representatives modern world ratio lack time great even watch <unknown> top - <unknown> tv series people often create problems queue <unknown> see last person queue take a place ` ` <unknown> '' link chain wonder legendary figure leave smart beaver <unknown> 's make appointment a <unknown> doctor tell beaver sad news a <unknown> : necessary electrocardiogram next day smart beaver get early put famous tv series download ( three hours till download 's complete ) <unknown> teeth <unknown> go join a queue electrocardiogram room notorious biggest queue clinic stand three hours queue smart beaver realize many beaver see suppose stand queue a huge mess come beaver ecg room queue ask front queue beaver know correct position queue might turn go get ecg maybe wait a long long time ... ' ve guess smart beaver a hurry home give necessary information help determine number queue first line contain two integers n ( 1 ≤ n ≤ 103 ) x ( 1 ≤ x ≤ n ) — number beaver stand queue smart beaver 's number correspondingly will get doctor number 1 n. second line contain n integers a1 a2 ... ( 0 ≤ ai ≤ n ) — number beaver follow i - th beaver ai = 0 i - th beaver n't know front guarantee value ai correct cycle <unknown> beaver follow one beaver queue input limit score 30 point ( subproblem b1 ) : input limit score 100 point ( subproblems <unknown> ) : print possible position smart beaver line increase order,['dp'],1600.0
337/D,<unknown> manao catch trail ancient book evil a <unknown> area area contain n settlements number 1 n. move <unknown> difficult people <unknown> exactly n - 1 paths paths connect pair settlements bidirectional moreover possible reach settlement one traverse one several paths distance two settlements minimum number paths cross get one settlement one manao know book evil get a damage range d. mean book evil locate settlement damage ( example <unknown> <unknown> <unknown> ) affect settlements distance d less settlement book <unknown> manao hear m settlements affect book evil number p1 p2 ... pm note book may affect settlements well detect yet manao want determine settlements may contain book help difficult task first line contain three space - separated integers n m d ( 1 ≤ m ≤ n ≤ 100000 ; 0 ≤ d ≤ n - 1 ) second line contain m distinct space - separated integers p1 p2 ... pm ( 1 ≤ pi ≤ n ) n - 1 line follow line describe a path make area a path describe a pair space - separated integers ai bi represent end path print a single number — number settlements may contain book evil possible manao receive <unknown> information settlement may contain book case print 0 . sample 1 . damage range book evil equal 3 effect notice settlements 1 2 . thus settlements 3 4 5,['dp'],2000.0
533/B,one big software company n employees number 1 n. director assign number 1 . every employee company except director exactly one immediate superior director course n't a superior call person a a subordinate another person b either b immediate supervisor a immediate supervisor a a subordinate person b. particular subordinate head employees company solve achieve important goal need form a workgroup every person efficiency express a positive integer ai i person 's number efficiency workgroup define total efficiency people include employees big software company <unknown> modern ways work process <unknown> today pair program <unknown> popularity workgroup form follow condition person enter workgroup able sort subordinate also workgroup pair word members workgroup number subordinate within workgroup even task determine maximum possible efficiency workgroup form observe give condition person include director company enter workgroup first line contain integer n ( 1 ≤ n ≤ 2·105 ) — number workers big software company n line follow describe company employees i - th line contain two integers pi ai ( 1 ≤ ai ≤ 105 ) — number person i - th employee 's immediate superior i - th employee 's efficiency director p1 = - 1 people condition 1 ≤ pi < i fulfil print a single integer — maximum possible efficiency workgroup sample test effective way make a workgroup employees number 1 2 4 5 6,['dp'],2000.0
300/D,vasily bear get a large square white table n row n columns table get a black border around table vasily bear want paint square table exactly k move move sequence action : bear already know number n k. help — find number ways paint square exactly k move two ways paint call distinct result table differ least one cell answer rather large print remainder divide 7340033 . first line contain integer q ( 1 ≤ q ≤ 105 ) — number test data follow q line contain two integers n k ( 1 ≤ n ≤ 109 0 ≤ k ≤ 1000 ) — size initial table number move correspond test test input print answer problem modulo 7340033 . print answer test order test give input possible paint ways test n = 7 k = 2 :,['dp'],2300.0
1326/G,"let 's call a graph $$$ n $$$ vertices 's point $$$ a_i = ( x_i y_i ) $$$ integer coordinate a planar tree : imagine a planar tree $$$ n $$$ vertices consider convex hull point $$$ a_1 a_2 \ldots a_n $$$ let 's call tree a spiderweb tree $$$ 1 \leq i \leq n $$$ follow statements true : example a spiderweb tree : point $$$ a_3 <unknown> <unknown> a_4 $$$ lie convex hull leaf vertices tree $$$ 3 6 7 4 $$$ refer note examples let 's call subset $$$ s <unknown> \ { 1 2 \ldots n\ } $$$ vertices a subtree tree pair vertices $$$ s $$$ exist a path contain vertices $$$ s $$$ note subtree planar tree a planar tree give a planar tree $$$ n $$$ vertexes let 's call a partition set $$$ \ { 1 2 \ldots n\ } $$$ non - empty subsets $$$ a_1 a_2 \ldots a_k $$$ ( i.e $$$ a_i <unknown> a_j = <unknown> $$$ $$$ 1 \leq i < j \leq k $$$ $$$ a_1 \cup a_2 \cup \ldots \cup a_k = \ { 1 2 \ldots n\ } $$$ ) good $$$ 1 \leq i \leq k $$$ subtree $$$ a_i $$$ a spiderweb tree two partition different exist set lie one <unknown> , find number good partition since number large find modulo $$$ 998\,244\,353 $$$ first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) — number vertices tree next $$$ n $$$ line contain two integers $$$ x_i y_i $$$ ( $$$ -1000000000 \leq x_i y_i \leq 1000000000 $$$ ) — coordinate $$$ i $$$ -th vertex $$$ a_i $$$ next $$$ n-1 $$$ line contain two integers $$$ s f $$$ ( $$$ 1 \leq s f \leq n $$$ ) — edge $$$ ( s f ) $$$ tree guarantee give point different three lie line additionally guarantee give edge coordinate point describe a planar tree print one integer — number good partition vertices give planar tree modulo $$$ 998\,244\,353 $$$ first test case good partition : partition $$$ \ { 1 2 3\ } $$$ $$$ \ { 4\ } $$$ n't good subtree $$$ \ { 1 2 3\ } $$$ n't spiderweb tree since non - leaf vertex $$$ 1 $$$ lie convex hull partition $$$ \ { 2 3 4\ } $$$ $$$ \ { 1\ } $$$ n't good subset $$$ \ { 2 3 4\ } $$$ n't a subtree second test case give tree n't a spiderweb tree leaf vertex $$$ 1 $$$ n't lie convex hull however subtree $$$ \ { 2 3 4 5\ } $$$ a spiderweb tree fourth test case partition $$$ \ { 1 2 3 4\ } $$$ $$$ \ { 5 6 7 <unknown> } $$$ good subsets spiderweb subtrees",['dp'],3500.0
809/C,a wonderful even restaurant time go home come leha a true gentlemen suggest noora give a lift certainly girl agree pleasure suddenly one problem appear : leha find car a huge park near restaurant decide turn watchman help formally park represent a matrix 109 × 109 . exactly one car every cell matrix cars machine number represent a positive integer let 's index columns matrix integers 1 109 leave right row integers 1 109 top bottom coincidence turn every cell ( x y ) number car stand cell equal minimum positive integer ca n't find cells ( i y ) ( x j ) 1 ≤ i < x 1 ≤ j < y. leha want ask watchman q request help find car every request represent five integers x1 y1 x2 y2 k. watchman consider cells ( x y ) matrix x1 ≤ x ≤ x2 y1 ≤ y ≤ y2 number car cell ( x y ) exceed k increase answer request number car cell ( x y ) request leha ask watchman tell result sum due fact sum turn quite large hacker ask calculate modulo 109 + 7 . however request seem <unknown> watchman help watchman answer leha 's request first line contain one integer q ( 1 ≤ q ≤ 104 ) — number leha 's request next q line contain five integers x1 y1 x2 y2 k ( 1 ≤ x1 ≤ x2 ≤ 109 1 ≤ y1 ≤ y2 ≤ 109 1 ≤ k ≤ 2·109 ) — parameters leha 's request print exactly q line — first line print answer first request second — answer second request let 's analyze request case request submatrix highlight blue first request ( k = 1 ) leha ask upper leave park cell cell car 's number 1 . consequentally answer 1 . second request ( k = 5 ) suitable number 4 1 2 3 2 1 . consequentally answer 4 + 1 + 2 + 3 + 2 + 1 = 13 . third request ( k = 10000 ) leha ask upper leave <unknown> 5 × 5 park since k big enough answer equal 93 . last request ( k = 2 ) none <unknown> 's number suitable answer 0,['dp'],2600.0
1140/E,let 's denote array $$$ b $$$ bad contain a subarray $$$ b_l b _ { l+1 } \dots b _ { r } $$$ odd length $$$ 1 $$$ ( $$$ l < r $$$ $$$ r - l + 1 $$$ odd ) $$$ <unknown> i \in \ { 0 1 \dots r - <unknown> } $$$ $$$ b _ { l + i } = b _ { r - i } $$$ array bad good give array $$$ a_1 a_2 \dots a_n $$$ elements replace $$$ -1 $$$ calculate number good array obtain replace $$$ -1 $$$ integer $$$ 1 $$$ $$$ k $$$ since answer large print modulo $$$ 998244353 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n k \le 200000 $$$ ) — length array $$$ a $$$ size ` ` alphabet '' i. e. upper bind number may use replace $$$ -1 $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ a_i = -1 $$$ $$$ 1 \le a_i \le k $$$ ) — array $$$ a $$$ print one integer — number good array get modulo $$$ 998244353 $$$,['dp'],2200.0
1585/G,alice bob two <unknown> cut tree a forest a forest a set zero tree a tree a connect graph without cycle a root tree a special vertex call root parent a node $$$ v $$$ next vertex shortest path $$$ v $$$ root children vertex $$$ v $$$ nod $$$ v $$$ parent a vertex a leaf children problem define depth vertex number vertices simple path vertex root rank a tree minimum depth among leave initially a forest root tree alice bob play a game forest play alternate turn alice go first begin turn player choose a tree forest player choose a positive cut depth exceed rank choose tree player remove vertices tree whose depth less equal cut depth vertices tree form a set root tree root vertex smallest depth cut tree include game forest game continue a player lose forest empty begin move determine whether alice win game players play optimally test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 500000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 500000 $$$ ) — total number vertices initial forest second line contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 0 \leq p_i \leq n $$$ ) — description forest $$$ p_i = 0 $$$ $$$ i $$$ -th vertex root a tree otherwise $$$ p_i $$$ parent vertex $$$ i $$$ 's guarantee $$$ p $$$ define a correct forest root tree guarantee sum $$$ n $$$ test case exceed $$$ 500000 $$$ test case print ` ` yes '' ( without quote ) alice win otherwise print ` ` '' ( without quote ) print letter case ( upper lower ) first test case bob a symmetric strategy alice win second test case alice choose second tree cut depth $$$ 1 $$$ get a forest a symmetric strategy third test case rank tree $$$ 2 $$$ possible move alice result a loss bob either make forest a symmetric strategy clear forest fourth test case leaf depth alice clear forest one move,['dp'],2500.0
540/D,bad luck island inhabit three kinds species : r rock s scissor p paper moments time two random individuals meet ( pair individuals meet equiprobably ) belong different species one individual kill one : a rock kill scissor scissor kill paper paper kill a rock task determine species probability species one inhabit island a long enough period time single line contain three integers r s p ( 1 ≤ r s p ≤ 100 ) — original number individuals species rock scissor paper respectively print three space - separated real number : probabilities rock scissor paper survive species respectively answer consider correct relative absolute error number n't exceed 10 - 9,['dp'],1900.0
734/E,anton grow a tree garden case forget tree a connect acyclic undirected graph n vertices tree paint black white anton n't like <unknown> tree want change tree vertices color ( black white ) change color anton use operations one type denote paint ( v ) v vertex tree operation change color vertices u vertices shortest path v u color ( include v u ) example consider <unknown> apply operation paint ( 3 ) get follow : anton interest minimum number operation need perform order make color vertices equal first line input contain a single integer n ( 1 ≤ n ≤ 200 000 ) — number vertices tree second line contain n integers colori ( 0 ≤ colori ≤ 1 ) — color vertices colori = 0 mean i - th vertex initially paint white colori = 1 mean 's initially paint black follow n - 1 line contain a pair integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) — indices vertices connect correspond edge 's guarantee pair ( ui vi ) distinct i.e multiple edge print one integer — minimum number operations anton apply order make vertices tree black vertices tree white first sample tree picture first apply operation paint ( 3 ) apply paint ( 6 ) tree become completely black answer 2 . second sample tree already white need apply operations answer 0,['dp'],2100.0
1172/C2,"difference easy hard versions constraints nauuo a girl love random picture websites one day make a random picture website include $$$ n $$$ picture nauuo visit website see exactly one picture website display picture equal probability $$$ i $$$ -th picture a non - negative weight $$$ w_i $$$ probability $$$ i $$$ -th picture display $$$ \frac { w_i } { \sum _ { j=1 } ^nw_j } $$$ say probability a picture display proportional weight however nauuo discover picture like display often solve problem come a great idea : saw a picture like would add $$$ 1 $$$ weight ; otherwise would subtract $$$ 1 $$$ weight nauuo visit website $$$ m $$$ time want know expect weight picture $$$ m $$$ visit modulo $$$ 998244353 $$$ help ? expect weight $$$ i $$$ -th picture denote $$$ \frac { q_i } { p_i } $$$ $$$ \gcd ( p_i q_i ) = 1 $$$ need print integer $$$ r_i $$$ satisfy $$$ 0\le r_i < 998244353 $$$ $$$ r_i\cdot p_i\equiv q_i\pmod { 998244353 } $$$ prove $$$ r_i $$$ exist unique first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1\le n\le 2\cdot 100000 $$$ $$$ 1\le m\le 3000 $$$ ) — number picture number visit website second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ a_i $$$ either $$$ 0 $$$ $$$ 1 $$$ ) — $$$ a_i=0 $$$ nauuo like $$$ i $$$ -th picture ; otherwise nauuo like $$$ i $$$ -th picture guarantee least one picture nauuo like third line contain $$$ n $$$ positive integers $$$ w_1 w_2 \ldots w_n $$$ ( $$$ w_i \geq 1 $$$ ) — initial weight picture guarantee sum initial weight exceed $$$ <unknown> - m $$$ output contain $$$ n $$$ integers $$$ r_1 r_2 \ldots r_n $$$ — expect weight modulo $$$ 998244353 $$$ first example visit show first picture a probability $$$ \frac 2 3 $$$ final weight $$$ ( 1,1 ) $$$ ; visit show second picture a probability $$$ \frac1 3 $$$ final weight $$$ ( 2,2 ) $$$ , expect weight $$$ \frac2 3\cdot 1+\frac 1 3\cdot 2=\frac4 3 $$$ $$$ 332748119\cdot 3\equiv 4\pmod { 998244353 } $$$ need print $$$ 332748119 $$$ instead $$$ \frac4 3 $$$ $$$ 1.3333333333 $$$ second example one picture nauuo like every time nauuo visit website $$$ w_1 $$$ increase $$$ 1 $$$ , expect weight $$$ 1 + 2=3 $$$ nauuo naughty n't give hint third example",['dp'],2600.0
9/D,"one old text file write great wisdom wisdom great nobody could decipher even <unknown> — <unknown> among inhabitants mainframe still manage get information example manage learn user launch game pleasure — terrible game cub fall city bring death modules win game ... sure guard bob appear mainframe many modules stop fear game cub bob ( alive yet ) never defeat user always <unknown> game cub program however <unknown> situations happen a game cube fall lose angle live a <unknown> virus — hexadecimal ... <unknown> ... strange like play much , willy - <unknown> bob play first user time hexadecimal invent follow <unknown> : bob leap binary search tree n nod remind a binary search tree a binary tree node a distinct key node follow true : leave sub - tree a node contain nod key less node 's key right sub - tree a node contain nod key greater node 's key key different positive integer number 1 n. node a tree two children children ( case a node a leaf ) hexadecimal 's game tree different height lower h. problem « height » stand maximum amount nod way root <unknown> leaf root node leaf include bob leap a tree disappear bob get access a cube tree leave know many tree leap worst case ? input data contain two space - separated positive integer number n h ( n ≤ 35 h ≤ n ) output one number — answer problem guarantee exceed <unknown>",['dp'],1900.0
101/E,"little gerald coach mike play interest game begin game a pile consist n candy a pile consist m stone gerald mike move turn mike go first move mike check many candy stone gerald eat let gerald eat a candy b stone mike award gerald f ( a b ) prize point gerald move either eat a candy pile candy a stone pile stone mike see gerald eat everything apart one candy one stone award point last time game end gerald allow eat candy allow eat stone tell gerald play get largest possible number point : require find one possible optimal play strategies gerald first line contain three integers n m p ( 1 ≤ n m ≤ 20000 1 ≤ p ≤ 109 ) second line contain n integers x0 x1 ... xn - 1 ( 0 ≤ xi ≤ 20000 ) third line contain m integers y0 y1 ... ym - 1 ( 0 ≤ yi ≤ 20000 ) value f ( a b ) calculate a remainder division sum xa + yb number p. print first line number : maximal number point gerald earn print second line a <unknown> consist n + m - 2 character either a ` ` c '' ` ` s '' i - th character ` ` c '' gerald 's i - th move eat a candy ` ` s '' eat a stone first test gerald 's first move eat a stone receive a point eat a candy get zero <unknown> way gerald get 0 point first move 1 second one , maximum number point gerald get equal 2 first eat a stone a candy",['dp'],2500.0
232/C,john doe decide mathematical object must name invent doe graph doe graph a family undirected graph characterize a single non - negative number — order 'll denote a graph order k d ( k ) 'll denote number vertices graph d ( k ) |d ( k ) | let 's define doe graph follow : john think doe graph great exist a polynomial algorithm search hamiltonian path however task answer query find shortest - length path vertices ai bi graph d ( n ) a path a pair vertices u v graph a sequence vertices x1 x2 ... xk ( k > 1 ) x1 = u xk = v i ( i < k ) vertices xi xi + 1 connect a graph edge length path x1 x2 ... xk number ( k - 1 ) first line contain two integers t n ( 1 ≤ t ≤ 105 ; 1 ≤ n ≤ 103 ) — number query order give graph i - th next t line contain two integers ai bi ( 1 ≤ ai bi ≤ <unknown> ai ≠ bi ) — number two vertices i - th query guarantee ai bi ≤ |d ( n ) | please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier query print a single integer a single line — length shortest path vertices ai bi print answer query order query give input,['dp'],2600.0
372/B,n × m rectangular grid cell grid contain a single integer : zero one let 's call cell i - th row j - th column ( i j ) let 's define a ` ` rectangle '' four integers a b c d ( 1 ≤ a ≤ c ≤ n ; 1 ≤ b ≤ d ≤ m ) rectangle denote a set cells grid { ( x y ) : a ≤ x ≤ c b ≤ y ≤ d } let 's define a ` ` good rectangle '' a rectangle include cells zero answer follow q query : calculate number good rectangles cells give rectangle three integers first line : n m q ( 1 ≤ n m ≤ 40 1 ≤ q ≤ 3·105 ) next n line contain m character — grid consider grid row number top bottom grid columns number leave right columns row number start 1 . next q line contain a query — four integers describe current rectangle a b c d ( 1 ≤ a ≤ c ≤ n ; 1 ≤ b ≤ d ≤ m ) query output answer — a single integer a separate line first example a 5 × 5 rectangular grid first second third query represent follow image,['dp'],1900.0
383/E,iahubina tire many complicate languages decide invent a new simple language already make a dictionary consist n 3 - words a 3 - word a sequence exactly 3 lowercase letter first 24 letter english alphabet ( a x ) decide letter vowels others consonants whole language base a simple rule : word contain least one vowel correct iahubina forget letter vowels want find possible correct set vowels ask iahub question question give iahub a set letter consider vowels ( question ) question want know many word dictionary correct consider give set vowels iahubina want know xor square answer possible question <unknown> different question subsets set first 24 letter english alphabet help iahub find number first line contain one integer n ( 1 ≤ n ≤ 104 ) next n line contain a 3 - word consist 3 lowercase letter two identical 3 - words print one number xor square answer query,['dp'],2700.0
1704/F,"alice bob play a game $$$ n $$$ cells a row initially cell either red blue alice go first turn alice choose two neighbour cells contain least one red cell paint two cells white , bob choose two neighbour cells contain least one blue cell paint two cells white player make a move lose find winner alice bob play optimally note a choose cell white long cell satisfy constraints first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow test case first line contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 500000 $$$ ) — number cells second line contain a string $$$ s $$$ length $$$ n $$$ — initial state cells $$$ i $$$ -th cell red $$$ s_i = $$$ r blue $$$ s_i = $$$ b. guarantee sum $$$ n $$$ test case exceed $$$ 500000 $$$ test case output name winner a separate line note cell number increase leave right first testcase alice two choices : paint first second cells paint second third cells matter choice alice make exactly one blue cell alice 's move bob need paint blue cell neighbour every cell white alice ca n't make a move bob winner second testcase matter alice choose bob choose paint fourth fifth cells $$$ 2 $$$ turn third testcase first alice paint third fourth cells n't matter bob paint first second cells fifth sixth cells alice paint two cells fourth testcase first alice paint second third cells bob paint fifth sixth cells fourth fifth cells alice paint seventh eighth cells bob paint seventh eighth cells alice paint fifth sixth cells fifth alice choose middle two cells first bob obviously two options whichever variant choose alice choose one win eighth matter alice choose bob choose two <unknown> cells",['dp'],2600.0
500/F,dohyun run a grocery store sell n items number integers 1 n. i - th ( 1 ≤ i ≤ n ) cost ci dollars i buy happiness increase hi item display p units time <unknown> dohyun display i - th item time ti customers buy i - th item time ti time ti + ( p - 1 ) inclusively also customer buy item i 'd like visit dohyun 's grocery store buy items new year party maximize happiness i a really busy person i visit store short period time word i visit store time t i buy items available time t. i buy many items possible budget hold i ca n't buy item several time due store rule necessary use whole budget i make a list q pair integers ( aj bj ) mean i may visit store time aj spend bj dollars store pair i 'd like know maximum happiness i obtain many pair i ca n't handle help ? first line contain two space - separated integers n p ( 1 ≤ n ≤ 4000 1 ≤ p ≤ 10 000 ) — number items display time item next n line describe items i - th ( 1 ≤ i ≤ n ) contain three space - separated integers ci hi ti ( 1 ≤ ci hi ≤ 4000 1 ≤ ti ≤ 10 000 ) — cost i - th item happiness i - th item time i - th item start display next line contain integer q ( 1 ≤ q ≤ 20 000 ) — number candidates next q line describe candidates j - th ( 1 ≤ j ≤ q ) contain two space - separated integers aj bj ( 1 ≤ aj ≤ 20 000 1 ≤ bj ≤ 4000 ) — visit time budget j - th visit store candidate print a single line contain maximum happiness i obtain buy items consider first sample,['dp'],2700.0
277/D,many must <unknown> google code jam round rule let us remind key moments <unknown> solve problem round participants suggest solve several problems divide two subproblems : easy one small limit ( small input ) a hard one large limit ( large input ) submit a solution large input ' ve solve small input problem restrictions order solve input particular participant first solve small input switch another problem return large input solve input give participant number point ( usually different problem ) take account complete solutions work correctly test input participant get test result a small input right submit test result a large input round 's final result table participants sort non - increasing receive point point equal participants sort ascend time penalty google code jam rule time penalty time last correct solution submit vasya decide check a new tactics another round soon round begin boy quickly read problems accurately evaluate time take solve specifically one n problems vasya know five value : a round last t minutes time read problems submit solutions consider equal zero vasya allow submit a solution exactly moment round end vasya want choose a set input order solution make expectation total receive point maximum possible multiple ways need minimize expectation time penalty help vasya cope problem first line contain two integers n t ( 1 ≤ n ≤ 1000 1 ≤ t ≤ 1560 ) follow n line contain 5 number : scoresmalli scorelargei timesmalli timelargei probfaili ( 1 ≤ scoresmalli scorelargei ≤ 109 1 ≤ timesmalli timelargei ≤ 1560 0 ≤ probfaili ≤ 1 ) <unknown> real number give 6 digits decimal point number input integers print two real number — maximum expectation total point correspond minimum possible time penalty expectation answer consider correct absolute relative error n't exceed 10 - 9 . first sample one optimal order solve problems : note solve small input second problem instead two input third one total score expectation time penalty expectation worse ( 38 ),['dp'],2800.0
351/B,jeff become friends furik two go play one quite amuse game begin game jeff take a piece paper write a permutation consist n number : p1 p2 ... pn guy take turn make move jeff move first move jeff choose two adjacent permutation elements boy swap move <unknown> toss a coin coin show ` ` head '' choose a random pair adjacent elements index i i + 1 inequality pi > pi + 1 hold swap coin show ` ` tail '' furik choose a random pair adjacent elements index i i + 1 inequality pi < pi + 1 hold swap coin show ` ` head '' ` ` tail '' furik multiple ways adjacent pair take uniformly take one pair furik n't pair take toss a coin one time game end permutation sort increase order jeff want game finish quickly possible ( want players make move possible ) help jeff find minimum mathematical expectation number move game move optimally well consider coin show head ( tail ) probability 50 percent first line contain integer n ( 1 ≤ n ≤ 3000 ) next line contain n distinct integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) — permutation p. number separate space a single line print a single real value — answer problem answer consider correct absolute relative error n't exceed 10 - 6 . first test sequence already sort answer 0,['dp'],1900.0
464/D,roma find a new character game ` ` world <unknown> - 2 '' game character fight monsters find advance stuff let fight stronger monsters character equip k distinct type items power item depend level ( positive integer number ) initially character one 1 - level item k type victory monster character find exactly one new randomly generate item <unknown> process look follow firstly type item define ; k type probability level new item define let 's assume level player 's item choose type equal t moment level new item choose uniformly among integers segment [ 1 ; t + 1 ] new item current player 's item type roma choose best one ( i.e one greater level ) equip ( level roma <unknown> ) remain item sell coin roma sell item level x type x coin help roma determine expect number earn coin victory n monsters first line contain two integers n k ( 1 ≤ n ≤ 105 ; 1 ≤ k ≤ 100 ) print a real number — expect number earn coin victory n monsters answer consider correct relative absolute error n't exceed 10 - 9,['dp'],2700.0
494/C,malek a rich man also generous 's decide split money poor people a charity institute know n poor people number 1 n. institute give malek q recommendations a recommendation a segment people like [ l r ] mean institute recommend malek give one <unknown> every person whose number segment however charity odd rule recommendations rule recommendations give a way every two recommendation [ a b ] [ c d ] one follow condition hold : goodness a charity value maximum money a person malek finish give money institute know recommendation probability malek accept want know expect value goodness charity ask help give list recommendations recommendation probability accept malek also give much money person initially must find expect value goodness first line two space - separated integers n q ( 1 ≤ n ≤ 105 1 ≤ q ≤ 5000 ) give second line n space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 109 ) give mean person number i initially ai dollars next q line contain three space - separated number li ri pi ( 1 ≤ li ≤ ri ≤ n 0 ≤ p ≤ 1 ) li ri two integers describe segment recommendation pi a real number give exactly three digits decimal point equal probability malek accept recommendation note a segment may appear several time recommendations output seek value answer consider correct absolute relative error less 10 - 6,['dp'],2600.0
498/B,"turn a great fan rock band ac / pe peter learn start follow game : play first song list n songs group find name song tell song name peter immediately play follow song order , i - th song ac / pe recognizability pi mean song yet recognize listen exactly one second probability pi percent recognize tell 's name otherwise continue listen note try guess integer number second moment song start play ac / pe songs first word chorus title ' ve hear first ti second i - th song chorus start immediately guess name sure example song <unknown> red chorus sound pretty late song high recognizability song back blue hand word title sound close begin song 's hard name hear word name songs a first second determine expect number songs recognize game last exactly t second ( i. e. make last guess second t game stop ) songs recognize faster t second game stop last song recognize first line input contain number n t ( 1 ≤ n ≤ 5000 1 ≤ t ≤ 5000 ) separate a space next n line contain pair number pi ti ( 0 ≤ pi ≤ 100 1 ≤ ti ≤ t ) songs give order petya 's list output a single number — expect number number songs recognize t second answer consider correct absolute relative error exceed 10 - 6",['dp'],2400.0
626/D,"andrew jerry play a game harry <unknown> game consist three round round andrew jerry draw randomly without replacement a jar contain n ball label a distinct positive integer without look hand ball harry award point player larger number return ball jar winner game one win least two three round andrew win round 1 2 jerry win round 3 andrew win game however jerry unhappy system claim often lose match despite higher overall total probability sum three ball jerry draw strictly higher sum three ball andrew draw ? first line input contain a single integer n ( 2 ≤ n ≤ 2000 ) — number ball jar second line contain n integers ai ( 1 ≤ ai ≤ 5000 ) — number write ith ball guarantee two ball number print a single real value — probability jerry a higher total give andrew win first two round jerry win third answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer a answer jury b. checker program consider answer correct , first case two ball first two round andrew must draw 2 jerry must draw 1 vice versa final round thus andrew 's sum 5 jerry 's sum 4 jerry never a higher total second case game could ' ve three outcomes — 10 - 2 10 - 1 2 - 1 . jerry a higher total andrew 2 - 1 first two round jerry draw 10 last round probability",['dp'],1800.0
1808/E1,"easy version problem difference three versions constraints $$$ n $$$ $$$ k $$$ make hack versions problem solve maxim a minibus driver venus ride maxim 's minibus need a ticket ticket a number consist $$$ n $$$ digits however know residents venus use a numeral system base $$$ k $$$ rather decimal system therefore ticket number consider a sequence $$$ n $$$ integers $$$ 0 $$$ $$$ k-1 $$$ inclusive residents venus consider a ticket lucky a digit equal sum remain digits modulo $$$ k $$$ example $$$ k=10 $$$ ticket $$$ 7135 $$$ lucky $$$ 7 + 1 + 5 \equiv 3 \pmod { 10 } $$$ hand ticket $$$ 7136 $$$ lucky digit equal sum others modulo $$$ 10 $$$ , a trip maxim wonder : many lucky ticket exist ? time maxim understand number large interest answer modulo prime number $$$ m $$$ line input contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \le n \le 100 $$$ $$$ 1 \le k \le 30 $$$ $$$ 100000000 \le m \le 1000000000 + 7 $$$ $$$ m $$$ a prime number ) — number digits ticket base numeral system venus module answer calculation print one integer — number lucky ticket modulo $$$ m $$$ i. e. remainder divide answer $$$ m $$$ first example four lucky ticket : $$$ 000 $$$ $$$ 011 $$$ $$$ 101 $$$ $$$ 110 $$$",['dp'],2200.0
989/E,` ` flow pass like water n't go ultimately ; <unknown> <unknown> like moon n't shrink grow eventually ` ` ` ` everything <unknown> a way <unknown> another ` ` kanno n't seem make much sense <unknown> 's isolate word maybe 's time enjoy <unknown> <unknown> night sky — <unknown> gift nature <unknown> sky star kanno <unknown> a night 's <unknown> dream a set $$$ s $$$ $$$ n $$$ point a coordinate plane kanno start a point $$$ p $$$ choose plane $$$ p $$$ add $$$ s $$$ n't belong $$$ s $$$ follow sequence operations ( altogether call a move ) repeat several time give order : $$$ q $$$ query consist two integers $$$ ( t_i m_i ) $$$ query 're help kanno maximize probability stop position $$$ t_i $$$ -th element $$$ s $$$ $$$ m_i $$$ move a proper selection $$$ p $$$ output maximum probability note accord rule 1 $$$ p $$$ belong least one line pass least two point $$$ s $$$ first line contain a positive integer $$$ n $$$ ( $$$ 2 \leq n \leq 200 $$$ ) — number point $$$ s $$$ $$$ i $$$ -th follow $$$ n $$$ line contain two space - separated integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ <unknown> \leq x_i y_i \leq 10000 $$$ ) — coordinate $$$ i $$$ -th point $$$ s $$$ input guarantee $$$ 1 \leq i \lt j \leq n $$$ $$$ ( x_i y_i ) \neq ( x_j y_j ) $$$ hold next line contain a positive integer $$$ q $$$ ( $$$ 1 \leq q \leq 200 $$$ ) — number query follow $$$ q $$$ line contain two space - separated integers $$$ t $$$ $$$ m $$$ ( $$$ 1 \leq t_i \leq n $$$ $$$ 1 \leq m_i \leq 10000 $$$ ) — index target point number move respectively output $$$ q $$$ line contain a decimal number — $$$ i $$$ -th among denote maximum probability stay $$$ t_i $$$ -th point $$$ m_i $$$ step a proper choice start position $$$ p $$$ answer consider correct number output differ correspond one jury 's answer $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer consider correct $$$ |a - b| \le 10^ { -6 } $$$ point $$$ s $$$ possible candidates line $$$ l $$$ depict follow figure first query $$$ p = ( -1 -3 ) $$$ $$$ l $$$ uniquely determine $$$ <unknown> = y $$$ thus kanno move $$$ ( 0 0 ) $$$ a probability $$$ \frac 1 2 $$$ third query $$$ p = ( 2 2 ) $$$ $$$ l $$$ choose equiprobably $$$ x + y = 4 $$$ $$$ x = y $$$ kanno move four point a probability $$$ \frac 1 2 \cdot \frac 1 3 = \frac 1 6 $$$ stay $$$ ( 2 2 ) $$$ a probability $$$ \frac 1 3 $$$,['dp'],2700.0
1151/F,a girl name sonya study <unknown> <unknown> kingdom kremland teacher computer science ( sonya 's favorite subject ! ) invent a task give array $$$ a $$$ length $$$ n $$$ consist number $$$ 0 $$$ $$$ 1 $$$ number $$$ k $$$ exactly $$$ k $$$ time follow happen : sonya 's task find probability operations complete $$$ a $$$ array sort non - decreasing order turn help help sonya solve problem show desire probability either $$$ 0 $$$ represent $$$ \dfrac { p } { q } $$$ $$$ p $$$ $$$ q $$$ coprime integers $$$ q <unknown> <unknown> { 1000000000 + 7 } $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \leq n \leq 100 1 \leq k \leq 1000000000 $$$ ) — length array $$$ a $$$ number operations second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1 $$$ ) — description array $$$ a $$$ desire probability $$$ 0 $$$ print $$$ 0 $$$ otherwise print value $$$ p \cdot q^ { -1 } $$$ $$$ \pmod { 1000000000 + 7 } $$$ $$$ p $$$ $$$ q $$$ define first example possible variants final array $$$ a $$$ apply exactly two operations : $$$ ( 0 1 0 ) $$$ $$$ ( 0 0 1 ) $$$ $$$ ( 1 0 0 ) $$$ $$$ ( 1 0 0 ) $$$ $$$ ( 0 1 0 ) $$$ $$$ ( 0 0 1 ) $$$ $$$ ( 0 0 1 ) $$$ $$$ ( 1 0 0 ) $$$ $$$ ( 0 1 0 ) $$$ therefore answer $$$ \dfrac { 3 } { 9 } = \dfrac { 1 } { 3 } $$$ second example array sort non - decreasing order one operation therefore answer $$$ 0 $$$,['dp'],2300.0
1172/C1,"difference easy hard versions constraints nauuo a girl love random picture websites one day make a random picture website include $$$ n $$$ picture nauuo visit website see exactly one picture website display picture equal probability $$$ i $$$ -th picture a non - negative weight $$$ w_i $$$ probability $$$ i $$$ -th picture display $$$ \frac { w_i } { \sum _ { j=1 } ^nw_j } $$$ say probability a picture display proportional weight however nauuo discover picture like display often solve problem come a great idea : saw a picture like would add $$$ 1 $$$ weight ; otherwise would subtract $$$ 1 $$$ weight nauuo visit website $$$ m $$$ time want know expect weight picture $$$ m $$$ visit modulo $$$ 998244353 $$$ help ? expect weight $$$ i $$$ -th picture denote $$$ \frac { q_i } { p_i } $$$ $$$ \gcd ( p_i q_i ) = 1 $$$ need print integer $$$ r_i $$$ satisfy $$$ 0\le r_i < 998244353 $$$ $$$ r_i\cdot p_i\equiv q_i\pmod { 998244353 } $$$ prove $$$ r_i $$$ exist unique first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1\le n\le 50 $$$ $$$ 1\le m\le 50 $$$ ) — number picture number visit website second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ a_i $$$ either $$$ 0 $$$ $$$ 1 $$$ ) — $$$ a_i=0 $$$ nauuo like $$$ i $$$ -th picture ; otherwise nauuo like $$$ i $$$ -th picture guarantee least one picture nauuo like third line contain $$$ n $$$ integers $$$ w_1 w_2 \ldots w_n $$$ ( $$$ 1\le <unknown> $$$ ) — initial weight picture output contain $$$ n $$$ integers $$$ r_1 r_2 \ldots r_n $$$ — expect weight modulo $$$ 998244353 $$$ first example visit show first picture a probability $$$ \frac 2 3 $$$ final weight $$$ ( 1,1 ) $$$ ; visit show second picture a probability $$$ \frac1 3 $$$ final weight $$$ ( 2,2 ) $$$ , expect weight $$$ \frac2 3\cdot 1+\frac 1 3\cdot 2=\frac4 3 $$$ $$$ 332748119\cdot 3\equiv 4\pmod { 998244353 } $$$ need print $$$ 332748119 $$$ instead $$$ \frac4 3 $$$ $$$ 1.3333333333 $$$ second example one picture nauuo like every time nauuo visit website $$$ w_1 $$$ increase $$$ 1 $$$ , expect weight $$$ 1 + 2=3 $$$ nauuo naughty n't give hint third example",['dp'],2300.0
50/D,command officer decide drop a nuclear bomb enemy 's force order determine power warhead need use enemy n strategically important object position know due intelligence service aim strike deactivate least k important object enemy bomb impact point already determine coordinate [ x0 ; y0 ] nuclear warhead mark estimate impact radius r ≥ 0 . build locate closer r bomb epicentre destroy build locate r epicentre also deactivate degree probability let 's assume d distance a build epicentre build 's <unknown> probability p ( d r ) calculate accord follow formula : estimate impact radius warhead equal zero build locate impact point completely demolish rest important object damage command officer want probability fail task ε . nuclear <unknown> expensive a luxury 's minimise estimate impact radius warhead first line contain integer n represent number enemy 's object ( 1 ≤ n ≤ 100 ) second line contain two integers : k require number deactivate object ε maximally permit probability complete task give per mils ( 1 ≤ k ≤ n 1 ≤ ε ≤ 999 ) third line contain x0 y0 coordinate strike impact point next n line contain two number xi yi coordinate every strategically important object coordinate integer absolute value exceed 1000 . let us remind a thousand per mils unity ( number one ) several object one point print seek estimate impact radius warhead absolute relative measure <unknown> answer exceed 10 - 6,['dp'],2100.0
28/C,n students live campus every morning students wake time go wash . m room wash basins i - th room contain ai wash basins every student independently select one room equal probability go students select room students room divide queue number wash basins size largest queue least possible calculate expect value size largest queue among room first line contain two positive integers n m ( 1 ≤ n m ≤ 50 ) — amount students amount room second line contain m integers a1 a2 ... ( 1 ≤ ai ≤ 50 ) ai mean amount wash basins i - th room output single number : expect value size largest queue answer must absolute relative error less 10 - 9,['dp'],2200.0
859/D,"annual college <unknown> - ball tournament approach <unknown> reason 'll refer third month <unknown> a total 2n team participate tournament number 1 2n tournament last n round round eliminate half team first round consist 2n - 1 game number start 1 . game i team 2·i - 1 play team 2·i loser eliminate winner advance next round ( tie ) subsequent round half many game previous round game i winner previous round 's game 2·i - 1 play winner previous round 's game 2·i every year office a pool see create best bracket a bracket a set winner predictions every game game first round may predict either team win game later round winner predict must also predict a winner previous round note bracket fully construct game actually play correct predictions first round worth 1 point correct predictions subsequent round worth twice many point previous correct predictions final game worth 2n - 1 point every pair team <unknown> estimate probability team win play want construct a bracket maximum possible expect score input begin a line contain n ( 2 ≤ n ≤ 6 ) <unknown> line follow 2n integers j - th column i - th row indicate percentage chance team i defeat team j unless i = j case value 0 . guarantee i - th column j - th row plus j - th column i - th row add exactly 100 . print maximum possible expect score possible bracket answer must correct within absolute relative error 10 - 9 . formally let answer a jury 's answer b. answer consider correct , first example predict team 1 4 win round 1 team 1 win round 2 . recall winner predict round 2 must also predict a winner round 1",['dp'],2100.0
1425/B,"'s faculty 's <unknown> anniversary ! celebrate great event faculty computer science university <unknown> ( fasilkom ) hold cpc - color <unknown> competition <unknown> cpc two players color predetermine rout fasilkom blue red $$$ n $$$ checkpoints $$$ m $$$ undirected predetermine rout rout $$$ i $$$ connect checkpoint $$$ u_i $$$ $$$ v_i $$$ $$$ ( 1 \le i \le m ) $$$ guarantee pair checkpoints connect use one rout rule cpc follow : chaneka interest participate however want waste much energy , interest number final configurations rout round turn count also exhaust chaneka ask figure ! two final configurations consider different a route $$$ u $$$ a different color two configurations first line contain two integers $$$ n $$$ $$$ m $$$ $$$ n $$$ $$$ ( 2 \le n \le 2 \cdot 1000 ) $$$ denote number checkpoints $$$ m $$$ $$$ ( 1 \le m \le 2 \cdot n ) $$$ denote number rout guarantee every checkpoint except checkpoint $$$ 1 $$$ exactly two rout connect next $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ $$$ ( 1 \le u_i v_i \le n u_i \ne v_i ) $$$ denote checkpoint route $$$ i $$$ connect guarantee every pair checkpoints exist a path connect directly indirectly use rout output a single integer denote number final configurations round cpc modulo $$$ 1000000000 + 7 $$$ every possible final configuration example list : blue - colored number give series move $$$ blue $$$ take red - colored number give series move $$$ red $$$ take",['dp'],2600.0
1194/F,"today adilbek take probability theory test unfortunately adilbek arrive university already a long queue students want take test adilbek estimate able start test $$$ t $$$ second come fortunately adilbek spend time without <unknown> bore theorems formulas app <unknown> contain $$$ n $$$ japanese crosswords solve adilbek decide solve one one order list app without skip crossword crossword a number $$$ t_i $$$ give represent time take average crossword expert solve crossword ( time give second ) adilbek a true crossword expert , unfortunately sometimes unlucky choose way solve crossword , take either $$$ t_i $$$ second $$$ t_i + 1 $$$ second solve $$$ i $$$ -th crossword equiprobably ( probability $$$ \frac { 1 } { 2 } $$$ solve crossword exactly $$$ t_i $$$ second probability $$$ \frac { 1 } { 2 } $$$ spend additional second finish crossword ) events independent $$$ t $$$ second pass ( solve last crossword manage less $$$ t $$$ second ) adilbek close app ( finish crossword moment crossword consider solve ; otherwise adilbek finish solve current crossword ) think would interest probability theory problem calculate $$$ e $$$ — expect number crosswords able solve completely calculate ? recall expect value a <unknown> random variable probability - weighted average possible value — problem mean expect value number solve crosswords calculate $$$ e = \sum \limits _ { i = 0 } ^ { n } i p_i $$$ $$$ p_i $$$ probability adilbek solve exactly $$$ i $$$ crosswords represent $$$ e $$$ rational fraction $$$ \frac { p } { q } $$$ $$$ q > 0 $$$ give answer print $$$ p \cdot q^ { -1 } \bmod ( 1000000000 + 7 ) $$$ first line contain two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le t \le 2 \cdot 10^ { 14 } $$$ ) — number crosswords time adilbek spend respectively second line contain $$$ n $$$ integers $$$ t_1 t_2 \dots t_n $$$ ( $$$ 1 \le t_i \le 1000000000 $$$ ) $$$ t_i $$$ time take a crossword expert solve $$$ i $$$ -th crossword note adilbek solve crosswords order give input without skip print one integer — expect value number crosswords adilbek solve $$$ t $$$ second express form $$$ p \cdot q^ { -1 } \bmod ( 1000000000 + 7 ) $$$ answer first sample equal $$$ \frac { 14 } { 8 } $$$ answer second sample equal $$$ \frac { 17 } { 8 } $$$",['dp'],2400.0
1603/D,"two positive integers $$$ l $$$ $$$ r $$$ ( $$$ l \le r $$$ ) let $$$ c ( l r ) $$$ denote number integer pair $$$ ( i j ) $$$ $$$ l \le i \le j \le r $$$ $$$ \operatorname { gcd } ( i j ) \ge l $$$ , $$$ \operatorname { gcd } ( i j ) $$$ greatest common divisor ( gcd ) integers $$$ i $$$ $$$ j $$$ youkn0wwho two integers $$$ n $$$ $$$ k $$$ $$$ 1 \le k \le n $$$ let $$$ f ( n k ) $$$ denote minimum $$$ \sum\limits _ { i=1 } ^ { k } { c ( <unknown> x _ { i+1 } ) } $$$ integer sequence $$$ 0 = x_1 \lt x_2 \lt \ldots \lt x _ { k } \lt x _ { k+1 } = n $$$ help youkn0wwho find $$$ f ( n k ) $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 300000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 100000 $$$ ) test case print a single integer — $$$ f ( n k ) $$$ first test case youkn0wwho select sequence $$$ [ 0 2 6 ] $$$ $$$ f ( 6 2 ) = c ( 1 2 ) + c ( 3 6 ) = 3 + 5 = 8 $$$ minimum possible",['dp'],3000.0
1671/E,"give a root tree $$$ 2^n - 1 $$$ vertices every vertex tree either $$$ 0 $$$ children $$$ 2 $$$ children leave tree distance root every non - leaf vertex one children leave one child right one formally give a perfect binary tree vertices tree number follow order : every vertex tree a letter write either a b. let 's define character vertex $$$ x $$$ $$$ <unknown> $$$ let preorder string vertex $$$ x $$$ define follow way : preorder string tree preorder string root , problem ... calculate number different string obtain preorder string give tree allow perform follow operation number time construct preorder string tree : first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 18 $$$ ) second line contain a sequence $$$ 2^n-1 $$$ character $$$ s_1 s_2 \dots s _ { 2^n-1 } $$$ character either a b. character separate space anything else print one integer — number different string obtain preorder string give tree apply number operations describe statement since large print modulo $$$ 998244353 $$$",['dp'],2100.0
1808/E2,"medium version problem difference three versions constraints $$$ n $$$ $$$ k $$$ make hack versions problem solve maxim a minibus driver venus ride maxim 's minibus need a ticket ticket a number consist $$$ n $$$ digits however know residents venus use a numeral system base $$$ k $$$ rather decimal system therefore ticket number consider a sequence $$$ n $$$ integers $$$ 0 $$$ $$$ k-1 $$$ inclusive residents venus consider a ticket lucky a digit equal sum remain digits modulo $$$ k $$$ example $$$ k=10 $$$ ticket $$$ 7135 $$$ lucky $$$ 7 + 1 + 5 \equiv 3 \pmod { 10 } $$$ hand ticket $$$ 7136 $$$ lucky digit equal sum others modulo $$$ 10 $$$ , a trip maxim wonder : many lucky ticket exist ? time maxim understand number large interest answer modulo prime number $$$ m $$$ line input contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \le n \le 10^ { 18 } $$$ $$$ 1 \le k \le 100 $$$ $$$ 100000000 \le m \le 1000000000 + 7 $$$ $$$ m $$$ a prime number ) — number digits ticket base numeral system venus module answer calculation print one integer — number lucky ticket modulo $$$ m $$$ i. e. remainder divide answer $$$ m $$$ first example four lucky ticket : $$$ 000 $$$ $$$ 011 $$$ $$$ 101 $$$ $$$ 110 $$$",['dp'],2500.0
385/D,"one day a bear live oxy axis afraid dark could n't move night along plane point n't light one day bear want a night walk house point ( l 0 ) friend 's house point ( r 0 ) along segment length ( r - l ) course want make walk need point segment light 's bear call friend ( yes middle night ) ask a <unknown> favor oxy axis contain n floodlight floodlight i point ( xi yi ) light angle plane large ai degree vertex point ( xi yi ) bear ask friend turn floodlight ( bear ) could go far away house possible walk along segment kind friend agree fulfill request , bear wonder : <unknown> go away house ? <unknown> find distance consider plane obstacles light source besides floodlight bear 's friend turn floodlight bear 's walk assume floodlight turn correct direction bear go a walk friend go bed first line contain three space - separated integers n l r ( 1 ≤ n ≤ 20 ; - 105 ≤ l ≤ r ≤ 105 ) i - th next n line contain three space - separated integers xi yi ai ( - 1000 ≤ xi ≤ 1000 ; 1 ≤ yi ≤ 1000 ; 1 ≤ ai ≤ 90 ) — floodlight ' description note two floodlight point plane print a single real number — answer problem answer consider correct relative absolute error n't exceed 10 - 6 . first sample one possible solutions : second sample a single solution : third sample a single solution :",['dp'],2200.0
592/D,ari monster ordinary monster hide identity super m byteforces ’ <unknown> byteforces a country consist n cities connect n - 1 bidirectional roads every road connect exactly two distinct cities whole road system design a way one able go city city use give roads m cities attack humans ari ... mean super m immediately go cities attack scare bad humans super m pass one city another use give roads moreover pass one road take exactly one <unknown> - time unit use byteforces however super m byteforces - attend a train camp locate a nearby country codeforces fortunately a special device codeforces allow instantly teleport codeforces city byteforces way back long purpose problem <unknown> use exactly help super m calculate city teleport begin order end job minimum time ( measure krons ) also provide time plan way back codeforces first line input contain two integers n m ( 1 ≤ m ≤ n ≤ 123456 ) - number cities byteforces number cities attack respectively follow n - 1 line describe road system line contain two city number ui vi ( 1 ≤ ui vi ≤ n ) - end road i. last line contain m distinct integers - number cities attack number give particular order first print number city super m teleport many possible optimal answer print one lowest city number print minimum possible time need scare humans cities attack measure krons note correct answer always unique first sample two possibilities finish super m 's job 3 krons : however choose first one start city lower number,['dp'],2200.0
1569/F,give a simple undirected graph $$$ n $$$ vertices $$$ n $$$ even go write a letter vertex letter one first $$$ k $$$ letter latin alphabet a path graph call hamiltonian visit vertex exactly a string call palindromic read leave right right leave a path graph call palindromic letter vertices spell a palindromic string without change order a string length $$$ n $$$ good : note path n't <unknown> go vertices order $$$ 1 2 \dots n $$$ count number good string first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \le n \le 12 $$$ ; $$$ n $$$ even ; $$$ 0 \le m \le \frac { n \cdot ( n-1 ) } { 2 } $$$ ; $$$ 1 \le k \le 12 $$$ ) — number vertices graph number edge graph number first letter latin alphabet use next $$$ m $$$ line contain two integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le n $$$ ; $$$ v \neq u $$$ ) — edge graph graph n't contain multiple edge self - loops print a single integer — number good string,['dp'],3000.0
1574/F,a subarray array $$$ a $$$ index $$$ l $$$ index $$$ r $$$ array $$$ [ a_l a _ { l+1 } \dots a _ { r } ] $$$ number occurrences array $$$ b $$$ array $$$ a $$$ number subarrays $$$ a $$$ equal $$$ b $$$ give $$$ n $$$ array $$$ a_1 a_2 \dots a_n $$$ ; elements array integers $$$ 1 $$$ $$$ k $$$ build array $$$ a $$$ consist $$$ m $$$ integers $$$ 1 $$$ $$$ k $$$ a way every give subarray $$$ a_i $$$ number occurrences $$$ a_i $$$ array $$$ a $$$ less number occurrences non - empty subarray $$$ a_i $$$ $$$ a $$$ note $$$ a_i $$$ n't occur $$$ a $$$ subarray $$$ a_i $$$ occur $$$ a $$$ condition still meet $$$ a_i $$$ task calculate number different array $$$ a $$$ build print modulo $$$ 998244353 $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n m k \le 300000 $$$ ) — number give array desire length array $$$ a $$$ upper bind value array $$$ n $$$ line follow $$$ i $$$ -th line represent array $$$ a_i $$$ first integer $$$ i $$$ -th line $$$ c_i $$$ ( $$$ 1 \le c_i \le m $$$ ) — number elements $$$ a_i $$$ ; $$$ c_i $$$ integers $$$ 1 $$$ $$$ k $$$ follow — elements array $$$ a_i $$$ additional constraint input : $$$ \sum\limits _ { i=1 } ^n c_i \le 300000 $$$ ; i. e. number elements give array total exceed $$$ 300000 $$$ print one integer — number different array $$$ a $$$ build take modulo $$$ 998244353 $$$,['dp'],2700.0
1575/D,mr . chanek integer represent a string $$$ s $$$ zero digits erase denote character _ . also zero digits mark character x mean 're digit mr . chanek want count number possible integer $$$ s $$$ $$$ s $$$ divisible $$$ 25 $$$ course $$$ s $$$ must contain lead zero replace character _ digit also replace character x digit must every character x. a note a lead zero 0 digit come first nonzero digit a number string <unknown> notation example <unknown> two lead zero exception integer zero ( 0 lead zero 0000 three lead zero ) one line contain string $$$ s $$$ ( $$$ 1 \leq |s| \leq 8 $$$ ) string $$$ s $$$ consist character 0 1 2 3 4 5 6 7 8 9 _ x. output integer denote number possible integer $$$ s $$$ first example possible $$$ s $$$ $$$ 25 $$$ second third example $$$ s \in \ { 100 <unknown> } $$$ fifth example possible $$$ s $$$ least one lead zero,['dp'],1800.0
1594/D,theofanis start play new online game call ` ` among '' however always play cypriot players name : ` ` andreas '' ( common name <unknown> ) game theofanis play $$$ n $$$ players since name number $$$ 1 $$$ $$$ n $$$ players write $$$ m $$$ comment chat a comment structure ` ` $$$ i $$$ $$$ j $$$ $$$ c $$$ ` ` $$$ i $$$ $$$ j $$$ two distinct integers $$$ c $$$ a string ( $$$ 1 \le i j \le n $$$ ; $$$ i \neq j $$$ ; $$$ c $$$ either imposter crewmate ) comment mean player $$$ i $$$ say player $$$ j $$$ role $$$ c $$$ imposter always lie a crewmate always tell truth help theofanis find maximum possible number imposters among cypriot players determine comment contradict ( see note explanation ) note player exactly one role : either imposter crewmate first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 0 \le m \le 500000 $$$ ) — number players except theofanis number comment next $$$ m $$$ line contain a comment make players structure ` ` $$$ i $$$ $$$ j $$$ $$$ c $$$ ` ` $$$ i $$$ $$$ j $$$ two distinct integers $$$ c $$$ a string ( $$$ 1 \le i j \le n $$$ ; $$$ i \neq j $$$ ; $$$ c $$$ either imposter crewmate ) multiple comment pair $$$ ( i j ) $$$ guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ sum $$$ m $$$ exceed $$$ 500000 $$$ test case print one integer — maximum possible number imposters comment contradict print $$$ -1 $$$ first test case imposters andreas $$$ 2 $$$ $$$ 3 $$$ second test case imposters andreas $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 5 $$$ third test case comment contradict player $$$ 1 $$$ say player $$$ 2 $$$ imposter player $$$ 2 $$$ say player $$$ 1 $$$ a crewmate player $$$ 1 $$$ a crewmate must tell truth player $$$ 2 $$$ must imposter player $$$ 2 $$$ imposter must lie player $$$ 1 $$$ ca n't a crewmate <unknown>,['dp'],1700.0
1616/G,"give a direct acyclic graph $$$ n $$$ vertices $$$ m $$$ edge edge $$$ a \to b $$$ graph $$$ a < b $$$ hold need find number pair vertices $$$ x $$$ $$$ y $$$ $$$ x > y $$$ add edge $$$ x \to y $$$ graph a hamiltonian path first line input contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 5 $$$ ) : number test case next line contain descriptions test case first line give two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 150\,000 $$$ $$$ 0 \leq m \leq \min ( 150\,000 \frac { n ( n-1 ) } { 2 } ) $$$ ) : number vertices edge graph next $$$ m $$$ line contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \leq a < b \leq n $$$ ) specify edge $$$ a \to b $$$ graph edge $$$ a \to b $$$ appear test case print one integer : number pair vertices $$$ x $$$ $$$ y $$$ $$$ x > y $$$ add edge $$$ x \to y $$$ graph a hamiltonian path first example edge $$$ x \to y $$$ $$$ x > y $$$ valid already a path $$$ 1 \to 2 \to 3 $$$ second example edge $$$ 4 \to 1 $$$ valid a path $$$ 3 \to 4 \to 1 \to 2 $$$ edge add third example add edge $$$ 2 \to 1 $$$ $$$ 3 \to 1 $$$ $$$ 4 \to 1 $$$ $$$ 4 \to 2 $$$",['dp'],3500.0
1728/D,alice bob play a game initially give a non - empty string $$$ s $$$ consist lowercase latin letter length string even player also a string initially empty alice start alternate move one move a player take either first last letter string $$$ s $$$ remove $$$ s $$$ <unknown> ( add begin ) string game end string $$$ s $$$ become empty winner player a lexicographically smaller string players ' string equal 's a draw a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ exist position $$$ i $$$ $$$ a_j = b_j $$$ $$$ j < i $$$ $$$ a_i < b_i $$$ result game players play optimally ( e. g. players try win ; ca n't try draw ) ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases testcase consist a single line — a non - empty string $$$ s $$$ consist lowercase latin letter length string $$$ s $$$ even total length string testcases n't exceed $$$ 2000 $$$ testcase print result game players play optimally alice win print ` ` alice '' bob win print ` ` bob '' 's a draw print ` ` draw '' one possible game alice bob play first testcase : alice win ` ` <unknown> '' < ` ` <unknown> '' neither players follow strategy particular example game n't show alice win play optimally,['dp'],1800.0
1389/G,give undirected connect graph consist $$$ n $$$ vertices $$$ m $$$ edge $$$ k $$$ vertices graph special direct edge graph leave undirected leave $$$ i $$$ -th edge undirected pay $$$ w_i $$$ coin direct n't pay let 's call a vertex saturate reachable special vertex along edge graph ( edge undirected traverse directions ) direct edge graph ( possibly leave undirected ) receive $$$ c_i $$$ coin saturate vertex $$$ i $$$ thus total profit calculate $$$ \sum \limits _ { i \in s } c_i - \sum \limits _ { j \in u } w_j $$$ $$$ s $$$ set saturate vertices $$$ u $$$ set edge leave undirected vertex $$$ i $$$ calculate maximum possible profit get make vertex $$$ i $$$ saturate first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \le n \le 300000 $$$ $$$ n - 1 \le m \le \min ( 3 \cdot 100000 \frac { n ( n-1 ) } { 2 } ) $$$ $$$ 1 \le k \le n $$$ ) second line contain $$$ k $$$ pairwise distinct integers $$$ v_1 $$$ $$$ v_2 $$$ ... $$$ v_k $$$ ( $$$ 1 \le v_i \le n $$$ ) — indices special vertices third line contain $$$ n $$$ integers $$$ c_1 $$$ $$$ c_2 $$$ ... $$$ c_n $$$ ( $$$ 0 \le c_i \le 1000000000 $$$ ) fourth line contain $$$ m $$$ integers $$$ w_1 $$$ $$$ w_2 $$$ ... $$$ <unknown> $$$ ( $$$ 0 \le w_i \le 1000000000 $$$ ) $$$ m $$$ line follow $$$ i $$$ -th line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ ) — endpoints $$$ i $$$ -th edge one edge pair vertices print $$$ n $$$ integers $$$ i $$$ -th integer maximum profit get make vertex $$$ i $$$ saturate consider first example : best course action second example direct edge along cycle : $$$ 1 \to 2 $$$ $$$ 2 \to 3 $$$ $$$ 3 \to 4 $$$ $$$ 4 \to 1 $$$ way vertices saturate,['dp'],2800.0
1402/C,unite federation planets <unknown> $$$ n $$$ planets index $$$ 1 $$$ $$$ n $$$ planets connect space tunnel a space tunnel a starship fly ways really fast exactly $$$ n-1 $$$ space tunnel travel planet planet federation use tunnel 's well know $$$ d $$$ additional parallel universes exact copy universe planets space tunnel index $$$ 1 $$$ $$$ d $$$ ( universe index $$$ 0 $$$ ) denote planet $$$ x $$$ universe $$$ i $$$ $$$ p_x^i $$$ travel one universe another use dimension portals every $$$ i $$$ ( $$$ 0\leq i \leq d-1 $$$ ) place exactly one portal allow us fly $$$ p _ { a_i } <unknown> $$$ $$$ p _ { b_i } ^ { i+1 } $$$ planet indices $$$ a_i $$$ $$$ b_i $$$ ( i.e $$$ 1 \leq a_i b_i \leq n $$$ ) portals place starship <unknown> embark <unknown> <unknown> currently orbit around $$$ p_1 ^ 0 $$$ captain ágnes lieutenant gábor decide play follow game : choose alternately a destination ( a planet ) fly planet universe a space tunnel go another universe a portal go aim visit place one go 's visit a planet $$$ p_x^i $$$ never go back ( visit planet $$$ x $$$ another universe ) captain ágnes choose first destination ( gábor ágnes etc . ) somebody ca n't choose a planet his / her turn he / she lose captain ágnes lieutenant gábor clever : know locations tunnel portals play optimally many different placements portals captain ágnes win game ? two placements different index $$$ i $$$ ( $$$ 0\leq i \leq d-1 $$$ ) $$$ i $$$ th portal connect different pair planets two placements ( i.e $$$ a_i $$$ $$$ b_i $$$ differ ) number big interest modulo $$$ 1000000000 + 7 $$$ first line contain two space - separated integers $$$ n $$$ ( $$$ 1\leq n \leq 10^ { 5 } $$$ ) – number planets $$$ d $$$ ( $$$ 1 \leq d \leq 10^ { 18 } $$$ ) – number additional parallel universes next $$$ n-1 $$$ line contain two space - separated integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \leq u v \leq n $$$ ) denote $$$ <unknown> $$$ $$$ <unknown> $$$ connect a space tunnel $$$ i $$$ ( $$$ 0 \leq i \leq d $$$ ) print a single integer number possible placements portals captain ágnes win modulo $$$ 1000000000 + 7 $$$ 1 portal $$$ 9 = 9 $$$ different placements follow 4 placements captain win,['dp'],2600.0
1404/B,alice bob play a fun game tree tag game play a tree $$$ n $$$ vertices number $$$ 1 $$$ $$$ n $$$ recall a tree $$$ n $$$ vertices undirected connect graph $$$ n-1 $$$ edge initially alice locate vertex $$$ a $$$ bob vertex $$$ b $$$ take turn alternately alice make first move a move alice jump a vertex distance $$$ da $$$ current vertex a move bob jump a vertex distance $$$ db $$$ current vertex distance two vertices define number edge unique simple path particular either player allow stay vertex a move note perform a move a player occupy start end vertices move vertices $$$ 10^ { 100 } $$$ move alice bob occupy vertex alice declare winner otherwise bob win determine winner players play optimally test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain five integers $$$ n a b da db $$$ ( $$$ 2\le n\le 100000 $$$ $$$ 1\le a b\le n $$$ $$$ <unknown> b $$$ $$$ 1\le da <unknown> n-1 $$$ ) — number vertices alice 's vertex bob 's vertex alice 's maximum jump distance bob 's maximum jump distance respectively follow $$$ n-1 $$$ line describe edge tree $$$ i $$$ -th line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1\le u <unknown> n <unknown> v $$$ ) denote edge vertices $$$ u $$$ $$$ v $$$ guarantee edge form a tree structure guarantee sum $$$ n $$$ across test case exceed $$$ 100000 $$$ test case output a single line contain winner game : ` ` alice '' ` ` bob '' first test case alice win move vertex $$$ 1 $$$ wherever bob move next alice able move vertex next move second test case bob follow strategy win wherever alice move bob always move whichever two vertices $$$ 1 $$$ $$$ 6 $$$ farthest alice,['dp'],1900.0
16/E,n fish number 1 n live a lake every day right one pair fish meet probability pair meet two fish index i j meet first eat second probability aij second eat first probability aji = 1 - aij describe process go least two fish lake fish find probability survive last lake first line contain integer n ( 1 ≤ n ≤ 18 ) — amount fish lake follow n line n real number — matrix a. aij ( 0 ≤ aij ≤ 1 ) — probability fish index i eat fish index j. 's guarantee main diagonal contain zero elements follow true : aij = 1 - aji real number give 6 character decimal point output n space - separated real number accurate less 6 decimal place number index i equal probability fish index i survive last lake,['dp'],1900.0
1369/F,lee use finish stories a <unknown> way time barely fail ice bear come help lee <unknown> decide show ice bear new game call ` ` critic '' ... game a one <unknown> one game $$$ t $$$ round round two integers $$$ s_i $$$ $$$ e_i $$$ ( determine know game begin $$$ s_i $$$ $$$ e_i $$$ may differ round round ) integer $$$ s_i $$$ write board begin correspond round players take turn player erase number board ( let 's say $$$ a $$$ ) choose write either $$$ 2 \cdot a $$$ $$$ a + 1 $$$ instead whoever write a number strictly greater $$$ e_i $$$ lose round one win round lee want play ` ` critic '' ice bear round choose round 's $$$ s_i $$$ $$$ e_i $$$ advance lee start first round loser round start next round winner last round winner game loser last round loser game determine lee winner independent ice bear 's move also determine lee loser independent ice bear 's move first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number round game $$$ t $$$ line follow contain two integers $$$ s_i $$$ $$$ e_i $$$ ( $$$ 1 \le s_i \le e_i \le 10^ { 18 } $$$ ) — $$$ i $$$ -th round 's information round play order give input $$$ s_i $$$ $$$ e_i $$$ round know everyone game start print two integers first one 1 lee winner independent ice bear 's move 0 otherwise second one 1 lee loser independent ice bear 's move 0 otherwise remember whoever write integer greater $$$ e_i $$$ lose,['dp'],2700.0
1499/F,"give integer $$$ k $$$ undirected tree consist $$$ n $$$ vertices length a simple path ( a path vertex appear ) pair vertices number edge path a diameter a tree maximum length a simple path pair vertices tree remove a set edge tree tree split multiple smaller tree edge remove set edge valid result tree diameter less equal $$$ k $$$ two set edge different edge appear one set count number valid set edge modulo $$$ 998\,244\,353 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 5000 $$$ $$$ 0 \le k \le n - 1 $$$ ) — number vertices tree maximum allow diameter respectively next $$$ n-1 $$$ line contain a description edge : two integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le n $$$ $$$ v \neq u $$$ ) give edge form a tree print a single integer — number valid set edge modulo $$$ 998\,244\,353 $$$ first example diameter give tree already less equal $$$ k $$$ thus choose set edge remove result tree diameter less equal $$$ k $$$ $$$ 2 ^ 3 $$$ set include empty one second example remove edge otherwise diameter $$$ 1 $$$ greater $$$ 0 $$$ tree third fourth examples :",['dp'],2400.0
1551/F,a tree undirected connect graph without cycle give a tree $$$ n $$$ vertices find number ways choose exactly $$$ k $$$ vertices tree ( i. e. a $$$ k $$$ -element subset vertices ) pairwise distance select vertices equal ( word exist integer $$$ c $$$ $$$ u v $$$ ( $$$ u \ne v $$$ $$$ u v $$$ select vertices ) $$$ d _ { u v } = c $$$ $$$ d _ { u v } $$$ distance $$$ u $$$ $$$ v $$$ ) since answer may large need output modulo $$$ 1000000000 + 7 $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) — number test case $$$ t $$$ test case follow test case precede empty line test case consist several line first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le k \le n \le 100 $$$ ) — number vertices tree number vertices select respectively $$$ n - 1 $$$ line follow contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ ) describe a pair vertices connect edge guarantee give graph a tree loop multiple edge test case output a separate line a single integer — number ways select exactly $$$ k $$$ vertices pair select vertices distance vertices pair equal modulo $$$ 1000000000 + 7 $$$ ( word print remainder divide $$$ 1000000007 $$$ ),['dp'],2200.0
1674/G,give a direct acyclic graph consist $$$ n $$$ vertices $$$ m $$$ edge vertices number $$$ 1 $$$ $$$ n $$$ multiple edge self - loops let $$$ \mathit { } _ v $$$ number incoming edge ( <unknown> ) $$$ \mathit { } _ v $$$ number outgo edge ( <unknown> ) vertex $$$ v $$$ ask remove edge graph let new degrees $$$ \mathit { ' } _ v $$$ $$$ \mathit { ' } _ v $$$ allow remove edge follow condition hold every vertex $$$ v $$$ : let 's call a set vertices $$$ s $$$ cute pair vertices $$$ v $$$ $$$ u $$$ ( $$$ v \neq u $$$ ) $$$ v \in s $$$ $$$ u \in s $$$ exist a path either $$$ v $$$ $$$ u $$$ $$$ u $$$ $$$ v $$$ non - <unknown> edge maximum possible size a cute set $$$ s $$$ remove edge graph indegrees outdegrees vertices either decrease remain equal $$$ 0 $$$ ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 0 \le m \le 200000 $$$ ) — number vertices number edge graph next $$$ m $$$ line contain two integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le n $$$ ; $$$ v \neq u $$$ ) — description edge give edge form a valid direct acyclic graph multiple edge print a single integer — maximum possible size a cute set $$$ s $$$ remove edge graph indegrees outdegrees vertices either decrease remain equal $$$ 0 $$$ first example remove edge $$$ ( 1 2 ) $$$ $$$ ( 2 3 ) $$$ $$$ \mathit { } = [ 0 1 2 ] $$$ $$$ \mathit { } = [ 2 1 0 ] $$$ $$$ \mathit { ' } = [ 0 0 1 ] $$$ $$$ \mathit { ' } = [ 1 0 0 ] $$$ see $$$ v $$$ condition hold maximum cute set $$$ s $$$ form vertices $$$ 1 $$$ $$$ 3 $$$ still connect directly edge a path second example edge since $$$ \mathit { } _ v $$$ $$$ \mathit { } _ v $$$ equal $$$ 0 $$$ leave a graph zero edge allow $$$ 5 $$$ cute set contain a single vertex thus maximum size $$$ 1 $$$ third example remove edge $$$ ( 7 1 ) $$$ $$$ ( 2 4 ) $$$ $$$ ( 1 3 ) $$$ $$$ ( 6 2 ) $$$ maximum cute set $$$ s = \ { 7 3 2\ } $$$ remove edge $$$ ( 7 3 ) $$$ well answer wo n't change picture graph third example :,['dp'],2000.0
1676/G,give a root tree consist $$$ n $$$ vertices number $$$ 1 $$$ $$$ n $$$ root vertex $$$ 1 $$$ also a string $$$ s $$$ denote color vertex : $$$ s_i = \texttt { b } $$$ vertex $$$ i $$$ black $$$ s_i = \texttt { w } $$$ vertex $$$ i $$$ white a subtree tree call balance number white vertices equal number black vertices count number balance subtrees a tree a connect undirected graph without cycle a root tree a tree a select vertex call root problem tree root $$$ 1 $$$ tree specify array parent $$$ a_2 \dots a_n $$$ contain $$$ n-1 $$$ number : $$$ a_i $$$ parent vertex number $$$ i $$$ $$$ i = 2 \dots n $$$ parent a vertex $$$ u $$$ a vertex next vertex a simple path $$$ u $$$ root subtree a vertex $$$ u $$$ set vertices pass $$$ u $$$ a simple path root example picture $$$ 7 $$$ subtree $$$ 3 $$$ simple path $$$ 7 \to 5 \to 3 \to 1 $$$ pass $$$ 3 $$$ note a vertex include subtree subtree root entire tree first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 2 \le n \le 4000 $$$ ) — number vertices tree second line test case contain $$$ n-1 $$$ integers $$$ a_2 \dots a_n $$$ ( $$$ 1 \le a_i < i $$$ ) — parent vertices $$$ 2 \dots n $$$ third line test case contain a string $$$ s $$$ length $$$ n $$$ consist character $$$ \texttt { b } $$$ $$$ \texttt { w } $$$ — color tree guarantee sum value $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a single integer — number balance subtrees first test case picture statement subtrees vertices $$$ 2 $$$ $$$ 3 $$$ balance second test case subtree vertex $$$ 1 $$$ balance third test case subtrees vertices $$$ 1 $$$ $$$ 3 $$$ $$$ 5 $$$ $$$ 7 $$$ balance,['dp'],1300.0
1444/E,interactive problem give a tree — connect undirected graph without cycle one vertex tree special find one ask question follow form : give edge tree endpoint closer special vertex mean endpoint 's shortest path special vertex contain fewer edge find special vertex ask minimum number question worst case a give tree please note special vertex might fix interactor advance : might change vertex one requirement consistent previously give answer give integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — number vertices a tree <unknown> $$$ n-1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) denote edge tree connect $$$ u $$$ $$$ v $$$ guarantee give edge form a tree read input data one start make query two possible query : forget output end line flush output otherwise get idleness limit exceed verdict flush output use : case ask query need worst case a give tree get verdict wrong answer hack forbid task,['dp'],3500.0
1472/G,$$$ n $$$ cities berland city number $$$ 1 $$$ capital pair cities connect a one - way road length 1 . trip polycarp city find value $$$ d_i $$$ — shortest distance capital ( $$$ 1 $$$ -st city ) $$$ i $$$ -th city polycarp begin journey city number $$$ s $$$ $$$ i $$$ -th city choose one follow action : since government berland want people come capital polycarp take second action list word perform second action $$$ 0 $$$ $$$ 1 $$$ time journey polycarp hand want close capital possible example $$$ n = 6 $$$ cities connect picture polycarp could make follow travel ( possible options ) : polycarp want start city $$$ i $$$ find close get capital formally : want find minimal value $$$ d_j $$$ polycarp get city $$$ i $$$ city $$$ j $$$ accord rule describe first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case $$$ t $$$ test case follow test case precede empty line first line test case contain two integers $$$ n $$$ ( $$$ 2 \leq n \leq 200000 $$$ ) $$$ m $$$ ( $$$ 1 \leq m \leq 200000 $$$ ) — number cities roads respectively follow $$$ m $$$ line describe roads road characterize two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \leq u v \leq n u \ne v $$$ ) — number cities connect a one - way road guarantee sum $$$ n $$$ $$$ m $$$ test case exceed $$$ 200000 $$$ guarantee pair different cities $$$ ( u v ) $$$ one road $$$ u $$$ $$$ v $$$ ( a pair roads $$$ u $$$ $$$ v $$$ $$$ v $$$ $$$ u $$$ — valid ) guarantee a path capital cities test case a separate line output $$$ n $$$ number $$$ i $$$ -th equal minimum possible distance capital city polycarp end journey,['dp'],2100.0
1547/G,give a direct graph $$$ g $$$ contain loop ( edge a vertex ) multi - edges absent $$$ g $$$ mean order pair $$$ ( u v ) $$$ exist one edge $$$ u $$$ $$$ v $$$ vertices number $$$ 1 $$$ $$$ n $$$ a path $$$ u $$$ $$$ v $$$ a sequence edge : assume empty sequence edge a path $$$ u $$$ $$$ u $$$ vertex $$$ v $$$ output one four value : let 's look example show figure : first contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case input $$$ t $$$ test case follow test case empty line first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 4 \cdot 100000 0 \le m \le 400000 $$$ ) — number vertices edge graph respectively next $$$ m $$$ line contain edge descriptions line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ ) — start end $$$ i $$$ -th edge vertices graph number $$$ 1 $$$ $$$ n $$$ give graph contain loop ( possible $$$ a_i = b_i $$$ ) contain multi - edges ( possible $$$ a_i = a_j $$$ $$$ b_i = b_j $$$ $$$ i \ne j $$$ ) sum $$$ n $$$ test case exceed $$$ 400000 $$$ similarly sum $$$ m $$$ test case exceed $$$ 400000 $$$ output $$$ t $$$ line $$$ i $$$ -th line contain answer $$$ i $$$ -th test case : a sequence $$$ n $$$ integers $$$ -1 $$$ $$$ 2 $$$,['dp'],2100.0
11/D,give a simple graph output number simple cycle a simple cycle a cycle repeat vertices edge first line input contain two integers n m ( 1 ≤ n ≤ 19 0 ≤ m ) – respectively number vertices edge graph subsequent m line contain two integers a b ( 1 ≤ a b ≤ n a ≠ b ) indicate vertices a b connect undirected edge one edge connect pair vertices output number cycle give graph example graph a <unknown> contain four cycle length 3 three cycle length 4,['dp'],2200.0
107/C,year 2500 annual <unknown> ceremony german university cairo ( guc ) run smoothly almost 500 years far important part ceremony relate arrangement professors ceremonial hall traditionally guc n professors professor seniority level <unknown> different let 's enumerate professors 1 n 1 senior professor n junior professor ceremonial hall n seat one seat professor place hall mean senior professors others specifically m pair seat ` ` senior - junior '' relation tradition require m pair seat ( ai bi ) professor seat ` ` senior '' position ai senior professor seat ` ` junior '' position bi guc strict <unknown> carefully observe start year 2001 . tradition require : arrangement professors list n integers first integer seniority professor seat position number one second integer seniority professor seat position number two etc give n number professors y current year m pair restrictions output arrangement professors year first line contain three integers n y m ( 1 ≤ n ≤ 16 2001 ≤ y ≤ 1018 0 ≤ m ≤ 100 ) — number professors year arrangement compute number pair seat seniority relation keep respectively next m line contain one pair integers ` ` ai bi '' indicate professor ai - th seat senior professor bi - th seat ( 1 ≤ ai bi ≤ n ai ≠ bi ) pair may list please use % lld specificator read write 64 - bit integers с++ prefer use cin stream ( may also use % i64d specificator ) print order professors seat request year year guc would run arrangements give ` ` senior - junior '' relation contradictory print ` ` time change '' ( without quote ) first example lexicographically first order seat 1 2 3 . third example guc run arrangements year <unknown> . fourth example valid arrangements seat lexicographical comparison arrangements perform < operator modern program languages arrangement a lexicographically less arrangement b exist i ( 1 ≤ i ≤ n ) ai < bi j ( 1 ≤ j < i ) aj = bj,['dp'],2400.0
111/C,little petya love train spiders petya a board n × m size cell board initially a spider sit one second petya choose a certain action spider <unknown> perform command 5 possible command : stay idle move current cell four side - <unknown> cells ( one command four possible directions ) petya give command spider leave field allow spiders pass crawl towards opposite directions spiders crawl simultaneously several spiders may end one cell petya want know maximum possible number spider - free cells one second first line contain two space - separated integers n m ( 1 ≤ n m ≤ 40 n·m ≤ 40 ) — board size first line print maximum number cells without spiders first sample possible answer : <unknown> second sample one possible solutions : s denote command ` ` stay idle '' l r d u denote command ` ` crawl leave '' ` ` crawl right '' ` ` crawl '' ` ` crawl '' correspondingly,['dp'],2100.0
165/E,"two integers x y compatible result bitwise ` ` '' equal zero , a & b = 0 . example number 90 ( 10110102 ) 36 ( 1001002 ) compatible 10110102 & 1001002 = <unknown> number 3 ( 112 ) 6 ( 1102 ) compatible 112 & 1102 = 102 . give array integers a1 a2 ... , task find follow array element : element compatible element give array ? answer question positive also find suitable element first line contain integer n ( 1 ≤ n ≤ 106 ) — number elements give array second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ <unknown> ) — elements give array number array coincide print n integers ansi ai n't compatible element give array a1 a2 ... , ansi equal -1 . otherwise ansi number ai & ansi = 0 also ansi occur array a1 a2 ... ,",['dp'],2200.0
201/D,"a widely know among people belarusian sport programmer lesha decide make money buy a one square meter larger flat , want make carry a super rat match ( srm ) site torcoder.com 's a problem — a <unknown> <unknown> coordinator ivan accept lesha 's problem call offensive word ` ` <unknown> '' ( duplicate ) one day <unknown> quarrel yet another problem ivan would n't accept invite act a fair judge determine whether problem indeed brand new ivan right problem bear <unknown> use previous <unknown> give descriptions lesha 's problem torcoder.com archive problems description problem a sequence word besides guarantee lesha 's problem repeat word description archive problem may contain number repeat word ` ` similarity '' lesha 's problem archive problem find follow among permutations word lesha 's problem choose one occur archive problem a subsequence multiple permutations choose one smallest number inversions ` ` similarity '' a problem write n number word lesha 's problem x number inversions choose permutation note ` ` similarity '' p always a positive integer problem call brand new a single problem ivan 's archive contain a permutation word lesha 's problem a subsequence help boys determine whether propose problem new specify problem archive resemble lesha 's problem otherwise first line contain a single integer n ( 1 ≤ n ≤ 15 ) — number word lesha 's problem second line contain n space - separated word — short description problem third line contain a single integer m ( 1 ≤ m ≤ 10 ) — number problems torcoder.com archive next m line contain descriptions problems ` ` k s1 s2 ... sk '' k ( 1 ≤ k ≤ 500000 ) number word problem si a word problem description word problem descriptions contain 10 lowercase english letter guarantee total length word problem descriptions exceed <unknown> . lesha 's problem brand new print string ` ` brand new problem ! '' ( without quote ) otherwise first line print index archive problem resemble lesha 's problem multiple problems print one smallest index second line print a string consist character [ : character | repeat p time character : ] p ` ` similarity '' problem lesha 's one archive problems number start one order give input let us remind number inversions number pair word follow permutation original order thus example original problem ` ` add two number '' permutation ` ` number add two '' contain two inversions — pair word ` ` number '' ` ` add '' ` ` number '' ` ` two '' sequence b1 b2 ... bk a subsequence sequence a1 a2 ... exist a set indices 1 ≤ i1 < i2 < ... < ik ≤ n aij = bj ( word sequence b obtain a delete elements ) first test case first problem contain ` ` find palindrome next '' permutation a subsequence number inversions equal 1 ( word ` ` palindrome '' ` ` next '' ) second test case problem contain a permutation word lesha 's problem a subsequence",['dp'],2600.0
232/E,john doe a field a rectangular table size n × m. assume field row number 1 n top bottom field columns number 1 m leave right cell field intersection x - th row y - th column coordinate ( x ; y ) know cells john 's field paint white paint black also john a tortoise move along white cells field tortoise get a white cell coordinate ( x ; y ) cell ( x + 1 ; y ) ( x ; y + 1 ) correspond cell paint white word turtle move along white cells field right turtle go bound field addition john q query characterize four number x1 y1 x2 y2 ( x1 ≤ x2 y1 ≤ y2 ) query john want know whether tortoise start point coordinate ( x1 ; y1 ) reach point coordinate ( x2 ; y2 ) move along white square field first line contain two space - separated integers n m ( 1 ≤ n m ≤ 500 ) — field size next n line contain m character ` ` # '' ` ` ` ` : j - th character i - th line equal ` ` # '' cell ( i ; j ) paint black ` ` ` ` paint white next line contain integer q ( 1 ≤ q ≤ 6·105 ) — number query next q line contain four space - separated integers x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ m ) — coordinate start finish cells guarantee cells ( x1 ; y1 ) ( x2 ; y2 ) white q query print a single line ` ` yes '' a way cell ( x1 ; y1 ) cell ( x2 ; y2 ) meet requirements ` ` '' otherwise print answer query order query give input,['dp'],3000.0
279/D,"' ve get a positive integer sequence a1 a2 ... , number sequence distinct let 's fix set variables b1 b2 ... bm initially variable bi ( 1 ≤ i ≤ m ) contain value zero consider follow sequence consist n operations first operation assign value a1 variable bx ( 1 ≤ x ≤ m ) follow n - 1 operations assign variable value equal sum value store variables bi bj ( 1 ≤ i j y ≤ m ) , value assign t - th operation must equal operation number y i j choose <unknown> task find minimum number variables m variables help perform describe sequence operations first line contain integer n ( 1 ≤ n ≤ 23 ) second line contain n space - separated integers a1 a2 ... ( 1 ≤ ak ≤ 109 ) guarantee number sequence distinct a single line print a single number — minimum number variables m variables help perform describe sequence operations perform sequence operations m print -1 . first sample use two variables b1 b2 perform follow sequence operations",['dp'],2200.0
53/E,life bertown become hard city many roads government spend much maintain n junctions m two way roads one get junction one mayor want close roads number roads leave total n - 1 roads still possible get junction one besides mayor concern number dead end junctions one road go n't many junctions <unknown> problem mayor <unknown> decide roads close road map contain exactly k dead end task count number different ways close roads follow condition meet : two ways consider different a road close first way open second one first line contain three integers n m k ( 3 ≤ n ≤ 10 n - 1 ≤ m ≤ n · ( n - 1 ) / 2 2 ≤ k ≤ n - 1 ) represent number junctions roads dead end correspondingly follow m line contain two different integers v1 v2 ( 1 ≤ v1 v2 ≤ n v1 ≠ v2 ) represent number junctions connect another road one road every pair junctions junctions number integers 1 n. guarantee possible get junction one along original roads print a single number — require number ways,['dp'],2500.0
327/E,"iahub want meet girlfriend iahubina live ox axis ( horizontal axis ) iahub live point 0 iahubina point d. iahub n positive integers a1 a2 ... , sum number d. suppose p1 p2 ... pn a permutation { 1 2 ... n } , let b1 = ap1 b2 = ap2 array b call a ` ` route '' n ! different rout one permutation p. iahub 's travel schedule : walk b1 step ox axis make a break point b1 , walk b2 step ox axis make a break point b1 + b2 similarly j - th ( 1 ≤ j ≤ n ) time walk bj step ox axis make a break point b1 + b2 + ... + bj iahub superstitious k integers give bad luck call a route ` ` good '' never make a break a point correspond one k number curiosity answer many good rout make modulo 1000000007 ( 109 + 7 ) first line contain integer n ( 1 ≤ n ≤ 24 ) follow line contain n integers : a1 a2 ... ( 1 ≤ ai ≤ 109 ) third line contain integer k ( 0 ≤ k ≤ 2 ) fourth line contain k positive integers represent number give iahub bad luck number exceed 109 . output a single integer — answer iahub 's <unknown> modulo 1000000007 ( 109 + 7 ) first case consider six possible order : second case note possible two different ways identical set stop fact six possible ways stop : [ 2 4 6 ] 's bad luck iahub",['dp'],2300.0
377/C,kostya a <unknown> specialize <unknown> dota 2 . <unknown> corporation developer game recently release a new patch turn balance game upside kostya captain team realize greatest responsibility lie want <unknown> <unknown> <unknown> patch mathematical point view choose best heroes team every game a dota 2 match involve two team must choose heroes players team go play forbid choose hero several time even different team large electronic sport competitions kostya 's team go participate match hold captain mode mode captain select heroes make one two possible action a certain predetermine order : pick ban team captain may miss a pick a ban miss a pick a random hero add team available moment miss a ban hero ban ban kostya already identify strength heroes base new patch fix course kostya know order pick ban strength a team sum strengths team 's heroes team participate match seek maximize difference strengths favor help kostya determine team first one second one advantage match large advantage first line contain a single integer n ( 2 ≤ n ≤ 100 ) — number heroes dota 2 . second line contain n integers s1 s2 ... sn ( 1 ≤ si ≤ 106 ) — strengths heroes third line contain a single integer m ( 2 ≤ m ≤ min ( n 20 ) ) — number action captain team must perform next m line look like ` ` action team '' action need action : a pick ( represent a ` ` p '' ) a ban ( represent a ` ` b '' ) team number team need perform action ( number 1 2 ) guarantee team make least one pick besides team number pick number ban print a single integer — difference strength first team strength second team captain team act optimally well,['dp'],2200.0
8/C,girl lena like everything order look order everywhere get ready university notice room a mess — object handbag throw room course want put back handbag problem girl carry two object a time move handbag also take object put anywhere except handbag — <unknown> sense order let give coordinate handbag coordinate object <unknown> coordinate system know girl cover distance two object time equal square length segment point object also know initially coordinate girl handbag ask find order action girl put object back handbag a minimum time period first line input file contain handbag 's coordinate <unknown> <unknown> second line contain number n ( 1 ≤ n ≤ 24 ) — amount object girl follow n line contain object ' coordinate coordinate exceed 100 absolute value give position different number integer first line output number — minimum time girl need put object handbag second line output possible <unknown> way lena object input describe index number ( 1 n ) handbag 's point describe number 0 . path start end handbag 's point several optimal paths print,['dp'],2000.0
1840/F,tema play a interest computer game next mission tema 's character find <unknown> planet unlike earth planet flat represent $$$ n \times m $$$ rectangle tema 's character locate point coordinate $$$ ( 0 0 ) $$$ order successfully complete mission need reach point coordinate $$$ ( n m ) $$$ alive let character computer game locate coordinate $$$ ( i j ) $$$ every second start first tema : alien inhabit planet dangerous <unknown> therefore shoot <unknown> $$$ r $$$ time shoot completely penetrate one coordinate vertically horizontally character line impact time shoot ( end second ) die since tema look game 's source code know complete information shoot — time penetrate coordinate direction shoot minimum time character reach desire point ? doom die reach point coordinate $$$ ( n m ) $$$ output $$$ -1 $$$ first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow descriptions test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \cdot m \le 10000 $$$ ) — size planet height width second line test case contain a single integer $$$ r $$$ ( $$$ 1 \le r \le 100 $$$ ) — number shots follow $$$ r $$$ line describe one shoot a shoot describe three integers $$$ t $$$ $$$ d $$$ $$$ coord $$$ $$$ t $$$ second shoot fire ( $$$ 1 \le t \le 1000000000 $$$ ) $$$ d $$$ direction shoot ( $$$ d = 1 $$$ denote a horizontal shoot $$$ d = 2 $$$ denote a vertical shoot ) $$$ coord $$$ size penetrate coordinate ( $$$ 0 \le coord \le n $$$ $$$ d = 1 $$$ $$$ 0 \le coord \le m $$$ $$$ d = 2 $$$ ) sum products $$$ n \cdot m $$$ test case exceed $$$ 10000 $$$ test case output a single number — minimum time character reach coordinate $$$ ( n m ) $$$ $$$ -1 $$$ doom die first test case character move follow : $$$ ( 0 0 ) \rightarrow ( 0 1 ) \rightarrow ( 0 2 ) \rightarrow ( 0 3 ) \rightarrow ( 0 3 ) \rightarrow ( 1 3 ) $$$ second test case character able leave rectangle completely penetrate shots second $$$ 2 $$$,['dp'],2200.0
1830/A,copil copac give a list $$$ n-1 $$$ edge describe a tree $$$ n $$$ vertices decide draw use follow algorithm : number read define number time copil copac perform step $$$ 1 $$$ find number read need copil copac draw tree test contain multiple test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number vertices tree follow $$$ n - 1 $$$ line test case contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \neq v_i $$$ ) — indicate $$$ ( u_i v_i ) $$$ $$$ i $$$ -th edge list guarantee give edge form a tree guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output number read copil copac need draw tree first test case : first read tree look like : second read : therefore copil copac need $$$ 2 $$$ read draw tree,['dp'],1400.0
1679/D,"one day masha walk park find a graph a tree ... surprise ? think problem would logical reason story ? way ! , problem ... masha orient graph $$$ i $$$ -th vertex contain positive integer $$$ a_i $$$ initially masha put a coin vertex one operation move a coin place vertex $$$ u $$$ vertex $$$ v $$$ orient edge $$$ u \to v $$$ graph time coin place vertex $$$ i $$$ masha write integer $$$ a_i $$$ notebook ( particular masha initially put a coin vertex write integer write vertex notebook ) masha want make exactly $$$ k - 1 $$$ operations way maximum number write notebook small possible first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 0 \le m \le 200000 $$$ $$$ 1 \le k \le 10^ { 18 } $$$ ) — number vertices edge graph number operation masha make second line contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — number write graph vertices follow $$$ m $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u \ne v \le n $$$ ) — mean edge $$$ u \to v $$$ graph 's guarantee graph n't contain loop multi - edges print one integer — minimum value maximum number masha write notebook optimal coin movements masha wo n't able perform $$$ k - 1 $$$ operations print $$$ -1 $$$ graph describe first second examples illustrate first example masha initially put a coin vertex $$$ 1 $$$ perform three operations : $$$ 1 \to 3 $$$ $$$ 3 \to 4 $$$ $$$ 4 \to 5 $$$ integers $$$ 1 2 3 $$$ $$$ 4 $$$ write notepad second example masha initially put a coin vertex $$$ 2 $$$ perform $$$ 99 $$$ operations : $$$ 2 \to 5 $$$ $$$ 5 \to 6 $$$ $$$ 6 \to 2 $$$ $$$ 2 \to 5 $$$ , integers $$$ 10 4 5 10 4 5 \ldots 10 4 5 10 $$$ write notepad third example masha wo n't able perform $$$ 4 $$$ operations",['dp'],1900.0
1681/D,give two integer number $$$ n $$$ $$$ x $$$ may perform several operations integer $$$ x $$$ operation perform follow one : choose digit $$$ y $$$ occur decimal representation $$$ x $$$ least replace $$$ x $$$ $$$ x \cdot y $$$ want make length decimal representation $$$ x $$$ ( without lead zero ) equal $$$ n $$$ minimum number operations require ? line input contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 2 \le n \le 19 $$$ ; $$$ 1 \le x < 10^ { n-1 } $$$ ) print one integer — minimum number operations require make length decimal representation $$$ x $$$ ( without lead zero ) equal $$$ n $$$ $$$ -1 $$$ impossible second example follow sequence operations achieve goal :,['dp'],1700.0
1689/C,byteland a beautiful land know beautiful tree misha find a binary tree $$$ n $$$ vertices number $$$ 1 $$$ $$$ n $$$ a binary tree acyclic connect bidirectional graph contain $$$ n $$$ vertices $$$ n - 1 $$$ edge vertex a degree $$$ 3 $$$ whereas root vertex number $$$ 1 $$$ a degree $$$ 2 $$$ unfortunately root get <unknown> follow process happen $$$ n $$$ time : misha much time think please tell maximum number vertices save <unknown> ( note delete vertices count save ) several test case input data first line contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 5000 $$$ ) — number test case follow test case description first line test case contain one integer $$$ n $$$ ( $$$ <unknown> n\leq 3\cdot 100000 $$$ ) — number vertices tree $$$ i $$$ -th follow $$$ n-1 $$$ line test case contain two positive integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ ) mean exist edge graph guarantee graph a binary tree root $$$ 1 $$$ also guarantee sum $$$ n $$$ test case wo n't exceed $$$ 3\cdot 100000 $$$ test case output maximum number vertices misha save first test case possible action delete vertex $$$ 2 $$$ save $$$ 0 $$$ vertices total second test case delete vertex $$$ 2 $$$ save vertices $$$ 3 $$$ $$$ 4 $$$,['dp'],1600.0
342/D,xenia like puzzle much especially fond puzzle consist domino piece look picture show one puzzle a puzzle a 3 × n table forbid cells ( black square ) contain dominoes ( color rectangles picture ) a puzzle call correct meet follow condition : solve puzzle need multiple step transport empty cell start position specify position a move transport a domino empty cell provide puzzle stay correct horizontal dominoes move horizontally vertical dominoes move vertically ca n't rotate dominoes picture show a probable move xenia a 3 × n table forbid cells a cell mark a circle also xenia many identical dominoes xenia wonder many distinct correct puzzle make put dominoes exist table also xenia want circle - <unknown> cell empty result puzzle puzzle must contain least one move help xenia count describe number puzzle describe number rather large print remainder divide 1000000007 ( 109 + 7 ) first line contain integer n ( 3 ≤ n ≤ 104 ) — puzzle 's size follow three line contain n character — description table j - th character i - th line equal ` ` x '' correspond cell forbid ; equal ` ` ` ` correspond cell non - forbidden ` ` o '' correspond cell mark a circle guarantee exactly one cell table mark a circle guarantee cells a give table least one common point mark cell non - forbidden print a single number — answer problem modulo 1000000007 ( 109 + 7 ) two puzzle consider distinct a pair cells contain one domino one puzzle contain one,['dp'],2100.0
1354/E,give undirected graph without self - loops multiple edge consist $$$ n $$$ vertices $$$ m $$$ edge also give three integers $$$ n_1 $$$ $$$ n_2 $$$ $$$ n_3 $$$ label vertex one three number 1 2 3 way : multiple valid label print first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 5000 $$$ ; $$$ 0 \le m \le 100000 $$$ ) — number vertices edge graph second line contain three integers $$$ n_1 $$$ $$$ n_2 $$$ $$$ n_3 $$$ ( $$$ 0 \le n_1 n_2 n_3 \le n $$$ ) — number label 1 2 3 respectively 's guarantee $$$ n_1 + n_2 + n_3 = n $$$ next $$$ m $$$ line <unknown> description edge : $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ; $$$ u_i \neq v_i $$$ ) — vertices $$$ i $$$ -th edge connect 's guarantee graph n't contain self - loops multiple edge valid label exist print ` ` yes '' ( without quote ) first line second line print string length $$$ n $$$ consist 1 2 3 . $$$ i $$$ -th letter equal label $$$ i $$$ -th vertex valid label print ` ` '' ( without quote ),['dp'],2100.0
855/G,"destroy voldemort 's <unknown> harry voldemort final battle cast spell <unknown> spell collide battle scene hogwarts represent form a tree , total n place hogwarts join use n - 1 undirected roads ron view battle harry voldemort wonder many triplets place ( u v w ) harry stand place u voldemort stand place v spell collide a place w. possible a <unknown> u v w distinct exist paths u w v w pass roads , due battle <unknown> new paths add time tell ron answer addition formally give a tree n vertices n - 1 edge q new edge add nod tree addition need tell number triplets ( u v w ) u v w distinct exist two paths one u w another v w paths edge common first line contain integer n ( 1 ≤ n ≤ 105 ) number place hogwarts next n - 1 line contain two space separate integers u v ( 1 ≤ u v ≤ n ) indicate a road place u v. guarantee give roads form a connect tree next line contain a single integer q ( 1 ≤ q ≤ 105 ) number new edge add next q line contain two space separate integers u v ( 1 ≤ u v ≤ n ) represent new road add note possible a newly add road connect place connect a road also a newly add road may connect a place first line print value number triplets change occur print q line a single integer ansi line contain value number triplets i - th edge addition first sample case initial tree ( 1 3 2 ) ( 3 1 2 ) possible triplets ( u v w ) addition edge 2 3 ( 1 3 2 ) ( 3 1 2 ) ( 1 2 3 ) ( 2 1 3 ) possible triplets",['dp'],3300.0
1822/F,two friends alisa yuki plant a tree $$$ n $$$ vertices garden a tree undirected graph without cycle loop multiple edge edge tree a length $$$ k $$$ initially vertex $$$ 1 $$$ root tree alisa yuki grow tree fun want sell cost tree define maximum distance root a vertex among vertices tree distance two vertices $$$ u $$$ $$$ v $$$ sum lengths edge path $$$ u $$$ $$$ v $$$ girls take a course garden know modify tree alisa yuki spend $$$ c $$$ coin shift root tree one neighbor current root operation perform number time ( possibly zero ) note structure tree leave unchanged ; change vertex root friends want sell tree maximum profit profit define difference cost tree total cost operations profit cost tree minus total cost operations help girls find maximum profit get apply operations tree number time ( possibly zero ) first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain integers $$$ n $$$ $$$ k $$$ $$$ c $$$ ( $$$ 2 \le n \le 200000 $$$ ; $$$ 1 \le k c \le 1000000000 $$$ ) — number vertices tree length edge cost operation next $$$ n - 1 $$$ line test case contain pair integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ) — edge graph edge form a tree sum value $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a single integer — maximum profit yuki alisa get,['dp'],1700.0
596/E,wilbur pig want play string find n m table consist digits 0 9 row number 1 n columns number 1 m. wilbur start square make certain move square ( x y ) digit d ( 0 ≤ d ≤ 9 ) write position ( x y ) must move square ( x + ad y + <unknown> ) square lie within table stay square ( x y ) otherwise wilbur make a move choose whether write digit write square white board digits write <unknown> form string every time a new digit write go end current string wilbur q string worry string si wilbur want know whether exist a start position ( x y ) make <unknown> many move wilbur end string si write white board first line input consist three integers n m q ( 1 ≤ n m q ≤ 200 ) — dimension table number string process respectively next n line contain m digits 0 9 give table follow 10 line i - th contain value ai - 1 bi - 1 ( - 200 ≤ ai bi ≤ 200 ) i.e vector wilbur use make a move square a digit i - 1 q line follow i - th contain a string si consist digits 0 9 . guarantee total length q string wo n't exceed 1 000 000 . q string print ` ` yes '' wilbur choose x y order finish string finite number move 's impossible print ` ` '' correspond string first sample a 1 1 table consist digit 0 . move make stay square first string write white board write 0 repeatedly second string write 2 table,['dp'],2500.0
1340/C,girl n't go denis denis go girl use rule young man leave home buy flower go nastya way denis 's house girl 's house a road $$$ n $$$ line road ca n't always cross one green light <unknown> good mayor decide place safety islands part road safety island locate a line well begin end road pedestrians <unknown> gain strength wait a green light denis come edge road exactly moment green light turn boy know traffic light first light $$$ g $$$ second green $$$ r $$$ second red $$$ g $$$ second green formally road represent a segment $$$ [ 0 n ] $$$ initially denis point $$$ 0 $$$ task get point $$$ n $$$ shortest possible time know many different integers $$$ d_1 d_2 \ldots d_m $$$ $$$ 0 \leq d_i \leq n $$$ — coordinate point safety islands locate one point boy a time red light unfortunately denis n't always able control excitement restrictions <unknown> : denis cross road soon coordinate become equal $$$ n $$$ task simple 's possible impossible cross road since denis thoughts love could n't solve problem ask us help find minimal possible time cross road accord rule find impossible first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 1 \leq n \leq 1000000 2 \leq m \leq min ( n + 1 10000 ) ) $$$ — road width number safety islands second line contain $$$ m $$$ distinct integers $$$ d_1 d_2 \ldots d_m $$$ $$$ ( 0 \leq d_i \leq n ) $$$ — point safety islands locate guarantee $$$ 0 $$$ $$$ n $$$ among third line contain two integers $$$ g r $$$ $$$ ( 1 \leq g r \leq 1000 ) $$$ — time green light stay time red light stay output a single integer — minimum time denis cross road obey rule impossible cross road output $$$ -1 $$$ first test optimal route : total $$$ 45 $$$ second obtain second test impossible cross road accord rule,['dp'],2400.0
786/A,"rick morty play version berzerk ( nothing common famous berzerk game ) game need a huge space play a computer game n object number 1 n arrange a circle ( clockwise order ) object number 1 a black hole others planets 's a monster one planet rick morty n't know one yet 's initially black hole unity inform game start , want prepare every possible scenario one a set number 1 n - 1 ( inclusive ) rick 's set s1 k1 elements morty 's s2 k2 elements one go first player change alternatively player 's turn choose arbitrary number like x set monster move x - th next object current position ( clockwise ) move monster get black hole win task monster 's initial position play first determine <unknown> win lose game stick infinite loop case player lose make game infinity profitable choose infinity game first line input contain a single integer n ( 2 ≤ n ≤ <unknown> ) — number object game second line contain integer k1 follow k1 distinct integers s1 1 s1 2 ... s1 k1 — rick 's set third line contain integer k2 follow k2 distinct integers s2 1 s2 2 ... s2 k2 — morty 's <unknown> ≤ ki ≤ n - 1 1 ≤ si 1 si 2 ... si ki ≤ n - 1 1 ≤ i ≤ 2 . first line print n - 1 word separate space i - th word ` ` win '' ( without quotations ) scenario rick play first monster initially object number i + 1 win ` ` lose '' lose ` ` loop '' game never end similarly second line print n - 1 word separate space i - th word ` ` win '' ( without quotations ) scenario morty play first monster initially object number i + 1 win ` ` lose '' lose ` ` loop '' game never end",['dp'],2000.0
793/E,"earlier internet bank a lot offices around bankopolis cause a lot problems namely day bank collect cash offices oleg bank client hear a dialogue two cash collectors day travel departments offices bank follow route every day collectors start central department move departments department office use special roads finally return central department total number departments offices n total number roads n - 1 . word special roads system a root tree root central department leave offices internal vertices departments collectors always follow route number roads minimum possible 2n - 2 . one collectors say number offices visit visit offices a b ( give order ) equal number offices visit visit offices b a ( order ) collector say number offices visit visit offices c d ( order ) equal number offices visit visit offices d c ( order ) interest part talk shortest path ( use special roads ) pair offices among a b c d pass central department give special roads map index offices a b c d determine situation describe collectors possible , first line contain single integer n ( 5 ≤ n ≤ 5000 ) — total number offices departments departments offices number 1 n central office index 1 . second line contain four integers a b c d ( 2 ≤ a b c d ≤ n ) — index departments mention collector 's dialogue guarantee index offices ( i.e leave tree ) departments guarantee shortest path pair offices pass central department third line n - 1 integers follow : p2 p3 ... pn ( 1 ≤ pi < i ) pi denote a special road i - th office department pi - th department please note <unknown> <unknown> departments offices guarantee give graph a tree offices leave departments internal vertices situation describe cash collectors possible print ` ` yes '' otherwise print ` ` '' first example follow collector 's route possible : note visit offices a b collectors visit number offices visit offices b a ; hold c d ( collectors ' route infinite follow day ) second example route visit offices c d collectors visit number offices visit offices d c. thus situation impossible third example one follow rout :",['dp'],2900.0
796/D,inzane finally find zane a lot money spare together decide establish a country rule a country easy job thieve <unknown> always ready <unknown> country 's peace fight back zane inzane <unknown> a effective law : city must possible reach a police station travel d kilometers along roads n cities country number 1 n connect exactly n - 1 roads roads 1 <unknown> long initially possible travel a city city use roads country also k police station locate cities particular city 's structure satisfy requirement <unknown> previously mention law also note multiple police station one city however zane feel like many n - 1 roads unnecessary country financial issue want minimize road <unknown> cost shut many roads possible help zane find maximum number roads shut without break law also help determine roads first line contain three integers n k d ( 2 ≤ n ≤ 3·105 1 ≤ k ≤ 3·105 0 ≤ d ≤ n - 1 ) — number cities number police station distance limitation kilometers respectively second line contain k integers p1 p2 ... pk ( 1 ≤ pi ≤ n ) — denote city police station locate i - th follow n - 1 line contain two integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) — cities directly connect road index i. guarantee possible travel one city city use roads also possible city reach a police station within d kilometers first line print one integer s denote maximum number roads shut second line print s distinct integers indices roads order multiple answer print first sample shut road 5 cities still reach a police station within k = 4 kilometers second sample although largest valid set roads shut print either 4 5 5 4 second line,['dp'],2100.0
804/D,"pasha a good student one <unknown> 's best friends always a problem think today a talk follow problem a forest ( acyclic undirected graph ) n vertices m edge q query answer query two vertices v u give let v set vertices connect component graph contain v u set vertices connect component graph contain u. let 's add edge vertex vertex compute value d result component result component a tree value d diameter component equal -1 otherwise expect value d choose vertices a b set uniformly random ? help pasha solve problem ? diameter component maximum distance among pair vertices component distance two vertices minimum number edge path two vertices note query n't add edge initial forest first line contain three integers n m q ( 1 ≤ n m q ≤ 105 ) — number vertices number edge graph number query next m line contain two integers ui vi ( 1 ≤ ui vi ≤ n ) mean edge vertices ui vi guarantee give graph a forest next q line contain two integers ui vi ( 1 ≤ ui vi ≤ n ) — vertices give i - th query query print expect value d describe problem statement answer consider correct absolute relative error exceed 10 - 6 . let 's assume answer a jury 's answer b. checker program consider answer correct , first example vertices 1 3 component answer first query -1 . second query two options add edge : one option add edge 1 - 2 one 2 - 3 . ways result diameter 2 answer 2 . second example answer first query obviously -1 . answer second query average three case : add edge 1 - 2 1 - 3 diameter 3 add edge 1 - 4 diameter 2 . thus answer",['dp'],2500.0
1667/D,give a tree ( connect undirected acyclic graph ) $$$ n $$$ vertices two edge adjacent share exactly one endpoint one move remove arbitrary edge edge adjacent even number remain edge remove edge determine impossible multiple solutions print input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number vertices tree $$$ n-1 $$$ line follow $$$ i $$$ -th contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ) endpoints $$$ i $$$ -th edge guarantee give graph a tree guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print ` ` '' impossible remove edge otherwise print ` ` yes '' next $$$ n-1 $$$ line print a possible order remove edge edge print endpoints order test case $$$ 1 $$$ : possible remove edge adjacent edge test case $$$ 2 $$$ : edge adjacent exactly one edge impossible remove answer ` ` '' test case $$$ 3 $$$ : edge $$$ 2 - 3 $$$ adjacent two edge possible remove removal possible remove remain edge,['dp'],2900.0
771/C,"a tree undirected connect graph without cycle distance two vertices number edge a simple path limak a little polar bear live a tree consist n vertices number 1 n. limak recently learn jump jump a vertex vertex within distance k. a pair vertices ( s t ) define f ( s t ) minimum number jump limak need get s t. task find sum f ( s t ) pair vertices ( s t ) s < t. first line input contain two integers n k ( 2 ≤ n ≤ 200 000 1 ≤ k ≤ 5 ) — number vertices tree maximum allow jump distance respectively next n - 1 line describe edge tree i - th line contain two integers ai bi ( 1 ≤ ai bi ≤ n ) — indices vertices connect i - th edge 's guarantee give edge form a tree print one integer denote sum f ( s t ) pair vertices ( s t ) s < t. first sample give tree 6 vertices 's display draw limak jump vertex within distance 2 . example vertex 5 jump vertices : 1 2 4 ( well also jump vertex 5 ) pair vertices ( s t ) s < t. 5 pair limak would need two jump : ( 1 6 ) ( 3 4 ) ( 3 5 ) ( 3 6 ) ( 5 6 ) 10 pair one jump enough , answer <unknown> + 10·1 = 20 . third sample limak jump every two vertices directly 3 pair vertices ( s < t ) answer <unknown> = 3",['dp'],2100.0
1792/E,"give $$$ n \times n $$$ multiplication table a positive integer $$$ m = m_1 \cdot m_2 $$$ a $$$ n \times n $$$ multiplication table a table $$$ n $$$ row $$$ n $$$ columns number $$$ 1 $$$ $$$ n $$$ $$$ a _ { i j } = i \cdot j $$$ divisor $$$ d $$$ $$$ m $$$ check : $$$ d $$$ occur table least , minimum row contain $$$ d $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) — number test case first line test case contain three integers $$$ n $$$ $$$ m_1 $$$ $$$ m_2 $$$ ( $$$ 1 \le n \le 1000000000 $$$ ; $$$ 1 \le m_1 m_2 \le 1000000000 $$$ ) — size multiplication table integer $$$ m $$$ represent $$$ m_1 \cdot m_2 $$$ test case let $$$ d_1 d_2 \dots d_k $$$ divisors $$$ m $$$ sort increase order let $$$ a_1 a_2 \dots a_k $$$ array answer $$$ a_i $$$ equal minimum row index divisor $$$ d_i $$$ occur $$$ 0 $$$ row since array $$$ a $$$ may large first print integer $$$ s $$$ — number divisors $$$ m $$$ present $$$ n \times n $$$ table next print a single value $$$ x = a_1 \oplus a_2 \oplus \dots \oplus a_k $$$ $$$ \oplus $$$ denote bitwise xor operation first test case $$$ m = 72 = 72 $$$ $$$ 12 $$$ divisors $$$ [ 1 2 3 4 6 8 9 12 18 24 36 72 ] $$$ $$$ 3 \times 3 $$$ multiplication table look like : divisor $$$ m $$$ present table position minimum row index mark array answer $$$ a $$$ equal $$$ [ 1 1 1 2 2 0 3 0 0 0 0 0 ] $$$ $$$ 6 $$$ non - zero value xor $$$ a $$$ equal $$$ 2 $$$ second test case $$$ m = 150 = 150 $$$ $$$ 12 $$$ divisors $$$ [ 1 2 3 5 6 10 15 25 30 50 75 150 ] $$$ divisors except $$$ 75 $$$ $$$ 150 $$$ present $$$ 10 \times 10 $$$ table array $$$ a $$$ $$$ = $$$ $$$ [ 1 1 1 1 1 1 3 5 3 5 0 0 ] $$$ $$$ 10 $$$ non - zero value xor $$$ a $$$ equal $$$ 0 $$$ third test case $$$ m = 210 = 210 $$$ $$$ 16 $$$ divisors $$$ [ 1 2 3 5 6 7 10 14 15 21 30 35 42 <unknown> 105 210 ] $$$ $$$ 6 \times 6 $$$ table mark divisors show : array $$$ a $$$ $$$ = $$$ $$$ [ 1 1 1 1 1 0 2 0 3 0 5 0 0 0 0 0 ] $$$ $$$ 8 $$$ non - zero value xor $$$ a $$$ equal $$$ 5 $$$",['dp'],2400.0
804/F,isart people n't die n gang criminals i - th gang contain si evil people numerate 0 si - 1 . people take part a big mine robbery pick one gold bullion ( people give input ) happen <unknown> years ago gang escape a remote area far towns years copy gold bullions accord organize plan order get arrest construct a tournament direct graph ( a graph exactly one direct edge every pair vertices ) gang ( graph give input ) graph edge u v mean i - th hour person gang u send a fake gold bullion person gang v. send bullion ( real fake ) <unknown> n't thus moment gangsters zero one gold bullion real bullions fake ones begin year police finally find gang could n't catch usual police decide open a <unknown> store gangsters would sell bullions thus every <unknown> a bullion ( fake real ) try sell a real gold bullion sell without problems a fake one a choice two events happen : power a gang number people successfully sell bullion sell do police arrest b gang top gang sort gang power call first a gang top gang ( sort equal power order ) consider possible result sell fake gold bullions possible choice b gang among top gang count number different set b gang modulo 109 + 7 . two set x y consider different gang x n't y. first line contain four integers n a b ( 1 ≤ b ≤ a ≤ n ≤ 5·103 ) — number gang constants a b statement n line follow line contain a string size n consist zero ones j - th character i - th line equal 1 vertex i a direct edge vertex j. guarantee <unknown> = 0 aij + aji = 1 i ≠ j. n line follow line start integer si ( 1 ≤ si ≤ 2·106 ) — number gangsters i - th gang contain a string zero ones length si j - th character 0 j - th person i - th gang a real gold bullion initially otherwise 1 . guarantee sum si exceed 2·106 print single integer : number different set b gang police arrest modulo 109 + 7,['dp'],3400.0
743/D,generous sponsor olympiad chloe vladik take part allow participants choose a prize christmas come sponsor decide decorate christmas tree prize take n prize contestants write a unique i d ( integer 1 n ) a gift i characterize integer ai — pleasantness gift pleasantness gift positive negative zero sponsor place gift 1 top tree gift hang a rope tie gift gift hang first gift possibly a sequence rope another gift formally gift form a root tree n vertices prize - <unknown> procedure go follow way : participants come tree one another choose remain gift cut rope prize hang note rope use hang prize choose one cut contestant get choose gift well gift hang possibly a sequence rope another gift friends chloe vladik share first place olympiad choose prize time ! keep fight decide choose two different gift set gift hang a sequence rope another gift n't intersect word n't gift hang gift choose chloe gift choose vladik possible variants choose pair prize sum pleasantness gift take cut rope large possible print maximum sum pleasantness vladik chloe get impossible choose gift without fight print impossible first line contain a single integer n ( 1 ≤ n ≤ 2·105 ) — number gift next line contain n integers a1 a2 ... ( - 109 ≤ ai ≤ 109 ) — pleasantness gift next ( n - 1 ) line contain two number i - th line contain integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) — description tree 's edge mean gift number ui vi connect a rope gift ' ids description rope give <unknown> order : vi hang ui ui hang vi guarantee gift hang first gift possibly a sequence rope another gift possible chloe vladik choose prize without fight print single integer — maximum possible sum pleasantness get together otherwise print impossible,['dp'],1800.0
741/B,"remind girls arpa 's land really nice mehrdad want invite hose palace a dance party hos weight wi beauty bi also hos may friends hose divide friendship group two hose x y friendship group a sequence hose a1 a2 ... ak ai ai + 1 friends 1 ≤ i < k a1 = x ak = y. arpa allow use amphitheater palace mehrdad party arpa 's amphitheater hold w weight mehrdad greedy want invite hose sum weight greater w sum beauties large possible along friendship group either invite hose one otherwise hose hurt find mehrdad maximum possible total beauty hose invite one get hurt total weight n't exceed w. first line contain integers n m w ( 1 ≤ n ≤ 1000 , 1 ≤ w ≤ 1000 ) — number hose number pair friends maximum total weight invite second line contain n integers w1 w2 ... wn ( 1 ≤ wi ≤ 1000 ) — weight hose third line contain n integers b1 b2 ... bn ( 1 ≤ bi ≤ 106 ) — beauties hose next m line contain pair friends i - th contain two integers xi yi ( 1 ≤ xi yi ≤ n xi ≠ yi ) mean hose xi yi friends note friendship bidirectional pair ( xi yi ) distinct print maximum possible total beauty hose mehrdad invite one get hurt total weight n't exceed w. first sample two friendship group : hose { 1 2 } hos { 3 } best way choose hose first group sum weight equal 5 sum beauty 6 . second sample two friendship group : hose { 1 2 3 } hos { 4 } mehrdad ca n't invite hose first group total weight 12 > 11 thus best way choose first hos first group one second group total weight 8 total beauty 7",['dp'],1600.0
613/D,"<unknown> kingdom k get ready marriage king 's daughter however order lose face front <unknown> king first finish reform kingdom king wait daughter 's marriage reform must finish soon possible kingdom currently consist n cities cities connect n - 1 bidirectional road one get city city king save a lot one path two cities point reform ? key <unknown> state relocate distinct cities ( call cities important ) however due fact a high <unknown> attack barbarians must do carefully king make several plan describe a set important cities wonder best plan barbarians capture cities important ( important ones enough <unknown> sure ) capture city become <unknown> particular interest feature plan minimum number cities barbarians need capture order make important cities isolate , important cities would impossible reach important city help king calculate characteristic plan first line input contain integer n ( 1 ≤ n ≤ 100 000 ) — number cities kingdom next n - 1 line contain two distinct integers ui vi ( 1 ≤ ui vi ≤ n ) — indices cities connect i - th road guarantee get city one move along exist roads next line contain a single integer q ( 1 ≤ q ≤ 100 000 ) — number king 's plan next q line look follow : first go number ki — number important cities king 's plan ( 1 ≤ ki ≤ n ) follow exactly ki space - separated pairwise distinct number 1 n — number important cities plan sum ki 's <unknown> exceed 100 000 . plan print a single integer — minimum number cities barbarians need capture print - 1 barbarians ' attempt isolate important cities effective first sample first third king 's plan barbarians capture city 3 enough second fourth plan attempt effective second sample cities capture 3 5",['dp'],2800.0
653/B,limak a little polar bear polar bear hate long string thus like compress also know limak young know first six letter english alphabet : ' a ' ' b ' ' c ' 'd ' ' e ' ' f ' give a set q possible operations limak perform order operation may apply number time i - th operation describe a string ai length two a string bi length one two q possible operations string ai limak a string s perform i - th operation s first two letter s match a two - letter string ai perform i - th operation remove first two letter s insert a string bi see note section clarification may note perform operation decrease length a string s exactly 1 . also set operations may a string compress first two letter n't match ai limak want start a string length n perform n - 1 operations finally get a one - letter string ` ` a '' many ways choose start string able get ` ` a '' ? remember limak use letter know first line contain two integers n q ( 2 ≤ n ≤ 6 1 ≤ q ≤ 36 ) — length initial string number available operations next q line describe possible operations i - th contain two string ai bi ( |ai| = 2 <unknown> = 1 ) 's guarantee ai ≠ aj i ≠ j ai bi consist first six lowercase english letter print number string length n limak able transform string ` ` a '' apply operations give input first sample count initial string length 3 limak get a require string ` ` a '' 4 string : ` ` abb '' ` ` cab '' ` ` <unknown> '' ` ` <unknown> '' first one limak compress use operation 1 two time ( change ` ` ab '' a single ` ` a '' ) first operation would change ` ` abb '' ` ` ab '' second operation would change ` ` ab '' ` ` a '' three string may compress follow : second sample correct initial string ` ` eb '' immediately compress ` ` a '',['dp'],1300.0
682/C,alyona decide go a <unknown> go forest get apples <unknown> find a magic root tree root vertex 1 every vertex every edge a number write girl notice tree 's vertices sad decide play let 's call vertex v sad a vertex u subtree vertex v dist ( v u ) > au au number write vertex u dist ( v u ) sum number write edge path v u. leave a tree vertices connect a single vertex a single edge root a tree a leaf tree consist a single vertex — root thus alyona decide remove tree leave sad vertex leave tree minimum number leave alyona need remove ? first line input integer n ( 1 ≤ n ≤ 105 ) give — number vertices tree second line sequence n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) give ai number write vertex i. next n - 1 line describe tree edge : ith consist two integers pi ci ( 1 ≤ pi ≤ n - 109 ≤ ci ≤ 109 ) mean edge connect vertices i + 1 pi number ci write print integer — minimum number leave alyona need remove sad vertex leave tree follow image represent possible process remove leave tree :,['dp'],1600.0
700/B,treeland a country n towns connect n - 1 two - way road 's possible get town town treeland 2k universities locate different towns recently president sign decree connect universities high - speed network ministry <unknown> understand decree way decide enough connect university another one use a cable formally decree do ! maximum sum budget ministry decide divide universities pair total length require cable maximum word total distance universities k pair large possible help ministry find maximum total distance course university present one pair consider roads length equal 1 . first line input contain two integers n k ( 2 ≤ n ≤ 200 000 1 ≤ k ≤ n / 2 ) — number towns treeland number university pair consider towns number 1 n. second line contain 2k distinct integers <unknown> <unknown> ... <unknown> ( 1 ≤ ui ≤ n ) — indices towns universities locate next n - 1 line contain description roads line contain pair integers xj yj ( 1 ≤ xj yj ≤ n ) mean j - th road connect towns xj yj two - way roads move town use roads print maximum possible sum distance division universities k pair figure show one possible division pair first test connect universities number 1 6 ( mark red ) universities number 2 5 ( mark blue ) use cable total distance equal 6 maximum sum example,['dp'],1800.0
710/E,<unknown> want generate input file program competition problem input a string consist n letter ' a ' lazy write a <unknown> manually generate input a text editor initially text editor empty take x second insert delete a letter ' a ' text file y second copy content entire text file duplicate <unknown> want find minimum amount time need create input file exactly n letter ' a ' help determine amount time need generate input line contain three integers n x y ( 1 ≤ n ≤ 107 1 ≤ x y ≤ 109 ) — number letter ' a ' input file parameters problem statement print integer t — minimum amount time need generate input file,['dp'],2000.0
633/F,"alice bob a tree ( undirected acyclic connect graph ) ai chocolates wait pick i - th vertex tree first choose two different vertices start position ( alice choose first ) take chocolates contain , alternate move select one vertex a time collect chocolates node make things interest decide one select a vertex he / she select a vertex adjacent one his / her previous turn vertex already choose move moment one able select node satisfy rule he / she skip turn let person pick chocolates long he / she go pick chocolates due greed chocolates want collect many chocolates possible however friends care total number chocolates obtain together maximum total number chocolates may pick ? first line input contain single integer n ( 2 ≤ n ≤ 100 000 ) — number vertices tree second line contain n integers ai ( 1 ≤ ai ≤ 109 ) i - th number stand number chocolates store node i. follow n - 1 line describe tree contain two integers ui vi ( 1 ≤ ui vi ≤ n ) — indices vertices connect i - th edge print number chocolates alice bob collect together behave optimally first sample alice may start vertex 9 bob vertex 8 . alice select vertex 1 bob options alice select vertex 7 stop second sample pick either nod alternately",['dp'],2600.0
39/A,"c * + + language quite similar c++ similarity <unknown> fact program write c * + + sometimes behave <unknown> lead absolutely unexpected effect example let 's imagine arithmetic expression c * + + look like ( expression main term ) : example ` ` 5 * <unknown> * + + <unknown> '' a valid expression c * + + thus a sum consist several summands divide sign ` ` + '' ` ` - '' every summand expression ` ` a++ '' ` ` + + a '' multiply integer coefficient coefficient omit suggest equal 1 . calculation sum c * + + go follow way first summands calculate one another sum usual arithmetic rule summand contain ` ` a++ '' calculation first value ` ` a '' variable multiply coefficient value ` ` a '' increase 1 . summand contain ` ` + + a '' action perform reverse order : first ` ` a '' increase 1 — multiply coefficient summands may calculate order 's sometimes result calculation completely unpredictable ! task find largest possible value first input line contain integer a ( - 1000 ≤ a ≤ 1000 ) — initial value variable ` ` a '' next line contain expression c * + + language describe type number summands expression exceed 1000 . guarantee line describe expression contain space <unknown> output a single number — maximal possible value expression consider second example initially a = 3 . suppose first first summand calculate second one first summand get equal 3 value a increase 1 . calculation second summand a increase ( get equal 5 ) value second summand 5 together give 8 . calculate second summand first first summand later summands equal 4 result 8 ,",['greedy'],2000.0
70/B,"fangy little walrus modern <unknown> love communicate via text message one day face follow problem : send large texts split part contain n character ( size one text message ) thus whole sentence word get split ! fangy like face task break text minimal message sentence break piece send number text message send would minimal two consecutive sentence different message space ignore ( fangy write space ) little walrus 's text look follow manner : space stand symbol a space , many message fangy send ? first line contain integer n size one message ( 2 ≤ n ≤ <unknown> ) second line contain text length text exceed 104 character guarantee text satisfy describe format specifically imply text empty first line print number text message fangy need impossible split text print ` ` impossible '' without quote let 's take a look third sample text split three message : ` ` hello ! ` ` ` ` like fish ? '' ` ` ? ` `",['greedy'],1600.0
1722/G,give integer $$$ n $$$ find array $$$ a $$$ $$$ n $$$ distinct nonnegative integers less $$$ 2^ { 31 } $$$ bitwise xor elements odd indices equal bitwise xor elements even indices first line input contain integer $$$ t $$$ ( $$$ 1 \leq t \leq <unknown> $$$ ) — number test case $$$ t $$$ line follow contain a single integer $$$ n $$$ $$$ ( 3 \leq n \leq 2\cdot100000 ) $$$ — length array guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case output one line contain $$$ n $$$ distinct integers satisfy condition multiple answer output first test case xor odd indices $$$ 4 \oplus 1 \oplus 0 \oplus 7 = 2 $$$ xor even indices $$$ 2 \oplus 5 \oplus 6 \oplus <unknown> 2 $$$,['greedy'],1500.0
19/C,bob saw a string contain many different letter letter mark number time letter could meet string 10 time bob n't like string contain repeat : a repeat length x a substring length 2x first half coincide character character second half bob start delete repeat string follow : 's possible bob take shortest repeat unique take leftmost one delete leave half everything leave repeat 're give string see bob find look like bob delete repeat way describe first input line contain integer n ( 1 ≤ n ≤ 105 ) — length string follow line contain n space - separated integer number 0 109 inclusive — number stand letter string 's guarantee letter meet string 10 time first line output length string 's part leave bob 's <unknown> second line output letter ( separate a space ) string leave bob delete repeat describe way,['greedy'],2200.0
1721/D,give two array $$$ a $$$ $$$ b $$$ consist $$$ n $$$ integers let 's define a function $$$ f ( a b ) $$$ follow : find maximum value function $$$ f ( a b ) $$$ reorder array $$$ b $$$ arbitrary way ( leave initial order also option ) first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — size array $$$ a $$$ $$$ b $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i < 2^ { 30 } $$$ ) third line contain $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ 0 \le b_i < 2^ { 30 } $$$ ) sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print one integer — maximum value function $$$ f ( a b ) $$$ reorder array $$$ b $$$ arbitrary way,['greedy'],1800.0
1715/D,<unknown> integer array $$$ a $$$ length $$$ n $$$ tell size $$$ n $$$ $$$ q $$$ statements three integers $$$ i j x $$$ mean $$$ a_i \mid a_j = x $$$ $$$ | $$$ denote bitwise operation find lexicographically smallest array $$$ a $$$ satisfy statements array $$$ a $$$ lexicographically smaller array $$$ b $$$ length follow hold : first line give two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 0 \le q \le 200000 $$$ ) next $$$ q $$$ line give three integers $$$ i $$$ $$$ j $$$ $$$ x $$$ ( $$$ 1 \le i j \le n $$$ $$$ 0 \le x < 2^ { 30 } $$$ ) — statements guarantee $$$ q $$$ statements hold least one array a single line print $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i < 2^ { 30 } $$$ ) — array $$$ a $$$ first sample array satisfy statements :,['greedy'],1900.0
1547/D,a sequence non - negative integers $$$ a_1 a_2 \dots a_n $$$ call grow $$$ i $$$ $$$ 1 $$$ $$$ n - 1 $$$ ones ( binary representation ) $$$ a_i $$$ place ones ( binary representation ) $$$ a _ { i + 1 } $$$ ( word $$$ a_i \ : \ & \ : a _ { i + 1 } = a_i $$$ $$$ \ & $$$ denote bitwise ) $$$ n = 1 $$$ sequence consider grow well example follow four sequence grow : follow three sequence non - growing : consider two sequence non - negative integers $$$ x_1 x_2 \dots x_n $$$ $$$ y_1 y_2 \dots y_n $$$ let 's call pair sequence co - growing sequence $$$ x_1 \oplus y_1 x_2 \oplus y_2 \dots x_n \oplus y_n $$$ grow $$$ \oplus $$$ denote bitwise xor give a sequence integers $$$ x_1 x_2 \dots x_n $$$ find lexicographically minimal sequence $$$ y_1 y_2 \dots y_n $$$ sequence $$$ x_i $$$ $$$ y_i $$$ co - growing sequence $$$ a_1 a_2 \dots a_n $$$ lexicographically smaller sequence $$$ b_1 b_2 \dots b_n $$$ exist $$$ 1 \le k \le n $$$ $$$ a_i = b_i $$$ $$$ 1 \le i < k $$$ $$$ a_k < b_k $$$ first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) $$$ t $$$ test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length sequence $$$ x_i $$$ second line contain $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ 0 \le x_i < 2^ { 30 } $$$ ) — elements sequence $$$ x_i $$$ guarantee sum $$$ n $$$ overall test case n't exceed $$$ 200000 $$$ test case print $$$ n $$$ integers $$$ y_1 y_2 \dots y_n $$$ ( $$$ 0 \le y_i < 2^ { 30 } $$$ ) — lexicographically minimal sequence 's co - growing give sequence $$$ x_i $$$,['greedy'],1300.0
1732/C1,"easy version problem difference version $$$ q = 1 $$$ give array integers $$$ a_1 a_2 \ldots a_n $$$ cost a subsegment array $$$ [ l r ] $$$ $$$ 1 \leq l \leq r \leq n $$$ value $$$ f ( l r ) = \operatorname { sum } ( l r ) - \operatorname { xor } ( l r ) $$$ $$$ \operatorname { sum } ( l r ) = a_l + a _ { l+1 } + \ldots + a_r $$$ $$$ \operatorname { xor } ( l r ) = a_l \oplus a _ { l+1 } \oplus \ldots \oplus a_r $$$ ( $$$ \oplus $$$ stand bitwise xor ) $$$ q = 1 $$$ query query give a pair number $$$ l_i $$$ $$$ r_i $$$ $$$ 1 \leq l_i \leq r_i \leq n $$$ need find subsegment $$$ [ l r ] $$$ $$$ l_i \leq l \leq r \leq r_i $$$ maximum value $$$ f ( l r ) $$$ several answer among need find a subsegment minimum length , minimum value $$$ r - l + 1 $$$ test consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ q = 1 $$$ ) — length array number query second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) — array elements $$$ i $$$ -th next $$$ q $$$ line test case contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \leq l_i \leq r_i \leq n $$$ ) — boundaries need find segment guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ guarantee $$$ l_1 = 1 $$$ $$$ r_1 = n $$$ test case print $$$ q $$$ pair number $$$ l_i \leq l \leq r \leq r_i $$$ value $$$ f ( l r ) $$$ maximum among length $$$ r - l + 1 $$$ minimum several correct answer print first test case $$$ f ( 1 1 ) = 0 - 0 = 0 $$$ second test case $$$ f ( 1 1 ) = 5 - 5 = 0 $$$ $$$ f ( 2 2 ) = 10 - 10 = 0 $$$ note $$$ f ( 1 2 ) = ( 10 + 5 ) - ( 10 \oplus 5 ) = 0 $$$ need find a subsegment minimum length among maximum value $$$ f ( l r ) $$$ , segment $$$ [ 1 1 ] $$$ $$$ [ 2 2 ] $$$ correct answer fourth test case $$$ f ( 2 3 ) = ( 12 + 8 ) - ( 12 \oplus 8 ) = 16 $$$ two correct answer fifth test case since $$$ f ( 2 3 ) = f ( 3 4 ) $$$ lengths equal",['greedy'],1800.0
1567/B,alice give bob two integers $$$ a $$$ $$$ b $$$ ( $$$ a > 0 $$$ $$$ b \ge 0 $$$ ) a curious boy bob write array non - negative integers $$$ \operatorname { mex } $$$ value elements equal $$$ a $$$ $$$ \operatorname { xor } $$$ value elements equal $$$ b $$$ shortest possible length array bob write ? recall $$$ \operatorname { mex } $$$ ( minimum exclude ) array minimum non - negative integer belong array $$$ \operatorname { xor } $$$ array bitwise xor elements array input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 50000 $$$ ) — number test case description test case follow line test case contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \leq a \leq 300000 $$$ ; $$$ 0 \leq b \leq 300000 $$$ ) — $$$ \operatorname { mex } $$$ $$$ \operatorname { xor } $$$ array respectively test case output one ( positive ) integer — length shortest array $$$ \operatorname { mex } $$$ $$$ a $$$ $$$ \operatorname { xor } $$$ $$$ b $$$ show array always exist first test case one shortest array $$$ \operatorname { mex } $$$ $$$ 1 $$$ $$$ \operatorname { xor } $$$ $$$ 1 $$$ $$$ [ 0 <unknown> <unknown> ] $$$ second test case one shortest array $$$ \operatorname { mex } $$$ $$$ 2 $$$ $$$ \operatorname { xor } $$$ $$$ 1 $$$ $$$ [ 0 1 ] $$$ show array shortest array possible,['greedy'],1000.0
1624/G,recently vlad carry away span tree friends without <unknown> give a connect weight undirected graph $$$ n $$$ vertices $$$ m $$$ edge birthday vlad define ority a span tree bitwise weight interest minimum possible ority achieve choose a certain span tree a span tree a connect subgraph a give graph contain cycle word want keep $$$ n-1 $$$ edge graph remain connect bitwise weight edge small possible find minimum bitwise first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case input empty line write front test case follow two number $$$ n $$$ $$$ m $$$ ( $$$ 3 \le n \le 2 \cdot 100000 n - 1 \le m \le 200000 $$$ ) — number vertices edge graph respectively next $$$ m $$$ line contain description edge line $$$ i $$$ contain three number $$$ v_i $$$ $$$ u_i $$$ $$$ w_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ $$$ 1 \le w_i \le 1000000000 $$$ $$$ v_i \neq u_i $$$ ) — vertices edge connect weight guarantee sum $$$ m $$$ sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case contain a connect graph print $$$ t $$$ line contain answer correspond set input data — minimum possible span tree ority,['greedy'],1900.0
1635/A,give array $$$ a $$$ size $$$ n $$$ perform follow operation array : please output minimum sum array get use operation number time test contain multiple test case first line contain number test case $$$ t $$$ $$$ ( 1 \leq t \leq 1000 ) $$$ description test case follow first line test case contain integer $$$ n $$$ $$$ ( 2 \leq n \leq 100 ) $$$ — size array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 0 \leq a_i < 2^ { 30 } ) $$$ test case print one number a line — minimum possible sum array first example perform follow operations obtain array $$$ [ 1 0 2 ] $$$ <unknown> . choose $$$ i = 1 j = 2 $$$ change $$$ a_1 = 1 $$$ $$$ a_2 = 2 $$$ 's valid since $$$ 1 | 3 = 1 | 2 $$$ array become $$$ [ 1 2 2 ] $$$ <unknown> . choose $$$ i = 2 j = 3 $$$ change $$$ a_2 = 0 $$$ $$$ a_3 = 2 $$$ 's valid since $$$ 2 | 2 = 0 | 2 $$$ array become $$$ [ 1 0 2 ] $$$ prove minimum sum $$$ 1 + 0 + 2 = 3 $$$ second example n't need operations,['greedy'],800.0
1659/B,give a binary string length $$$ n $$$ exactly $$$ k $$$ move one move must select a single bite state bits except bite get flip ( $$$ 0 $$$ become $$$ 1 $$$ $$$ 1 $$$ become $$$ 0 $$$ ) need output lexicographically largest string get use $$$ k $$$ move also output number time select bite multiple ways may output a binary string $$$ a $$$ lexicographically larger a binary string $$$ b $$$ length follow hold : first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case two line first line two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 200000 $$$ ; $$$ 0 \leq k \leq 1000000000 $$$ ) second line a binary string length $$$ n $$$ character either $$$ 0 $$$ $$$ 1 $$$ sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output two line first line contain lexicographically largest string obtain second line contain $$$ n $$$ integers $$$ f_1 f_2 \ldots f_n $$$ $$$ f_i $$$ number time $$$ i $$$ -th bite select sum integers must equal $$$ k $$$ explanation first testcase step show binary string change a move,['greedy'],1300.0
1688/B,"patchouli make a magical talisman initially $$$ n $$$ magical tokens magical power represent positive integers $$$ a_1 a_2 \ldots a_n $$$ patchouli may perform follow two operations tokens tokens effective magical power odd value please help patchouli find minimum number operations need make magical power tokens odd value test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case description test case follow test case first line contain one integer $$$ n $$$ ( $$$ 1 \leq n\leq 2\cdot 100000 $$$ ) — initial number tokens second line contain $$$ n $$$ <unknown> $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — initial magical power $$$ n $$$ tokens guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print a single integer — minimum number operations patchouli need make tokens odd value magical power show restrictions require sequence operations exist test case 1 : $$$ a $$$ consist <unknown> odd number initially test case 2 : choose tokens magical power $$$ 1 $$$ $$$ 2 $$$ perform fusion $$$ a= [ 1,3 ] $$$ odd number test case 3 : choose tokens magical power $$$ 2 $$$ $$$ 8 $$$ perform fusion $$$ a= [ <unknown> ] $$$ choose token magical power $$$ 10 $$$ perform reduction $$$ a= [ 4,5 ] $$$ choose tokens magical power $$$ 4 $$$ $$$ 5 $$$ perform fusion $$$ a= [ 9 ] $$$ $$$ 9 $$$ odd number show make magical power odd number less $$$ 3 $$$ move answer $$$ 3 $$$",['greedy'],800.0
1696/A,"nit cleaver new town ! thousands people line <unknown> keep <unknown> entertain nit decide let solve follow problem relate $$$ \operatorname { } z $$$ solve problem ? give a 1 - indexed array $$$ n $$$ integers $$$ a $$$ integer $$$ z $$$ follow operation number ( possibly zero ) time : $$$ \operatorname { } $$$ $$$ \operatorname { } $$$ denote bitwise operations respectively find maximum possible value maximum value $$$ a $$$ number ( possibly zero ) operations test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ z $$$ ( $$$ 1\le n\le 2000 $$$ $$$ 0\le z < 2^ { 30 } $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a_n $$$ ( $$$ 0\le a_i < 2^ { 30 } $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 10000 $$$ test case print one integer — answer problem first test case sample one optimal sequence operations : operations sequence $$$ a $$$ become $$$ [ 3,7 ] $$$ maximum value $$$ 7 $$$ prove maximum value $$$ a $$$ never exceed $$$ 7 $$$ answer $$$ 7 $$$ fourth test case sample one optimal sequence operations :",['greedy'],800.0
1599/J,bob really like play array number 's birthday friends buy a really interest machine – array beautifier array beautifier take array $$$ a $$$ consist $$$ n $$$ integers output a new array $$$ b $$$ length n construct base array give array beautifier construct new array follow way : take two number different indices original array write sum end new array step $$$ n $$$ time - result output array length $$$ n $$$ process machine take index multiple time different step bob <unknown> gift friends give put favorite array machine however machine finish bob happy result array miss favorite array much hop get back give array machine output help bob find array could original array put machine sometimes machine make mistake possible appropriate input array exist array output case let bob know array forever lose first line contain one positive integer $$$ n $$$ ( $$$ 2 \leq n \leq 1000 $$$ ) – length bob 's array second line contain $$$ n $$$ integers $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_n $$$ ( $$$ 1 \leq b_i \leq 1000000 $$$ ) – elements array machine output appropriate input array exist print ` ` yes '' follow input array $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ -1000000000 \leq a_i \leq 1000000000 $$$ ) next line otherwise print ` ` '',['greedy'],2600.0
1560/F1,a simplify version problem f2 difference constraints ( f1 : $$$ k \le 2 $$$ f2 : $$$ k \le 10 $$$ ) give integer $$$ n $$$ find minimum integer $$$ x $$$ $$$ x \ge n $$$ number $$$ x $$$ $$$ k $$$ -beautiful a number call $$$ k $$$ -beautiful decimal representation lead zero contain $$$ k $$$ different digits e.g $$$ k = 2 $$$ number $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ 21 $$$ $$$ k $$$ -beautiful whereas number $$$ 120 $$$ $$$ <unknown> $$$ $$$ 998244353 $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow test case consist one line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 1000000000 $$$ $$$ 1 \le k \le 2 $$$ ) test case output a separate line $$$ x $$$ — minimum $$$ k $$$ -beautiful integer $$$ x \ge n $$$,['greedy'],1900.0
1326/D2,hard version problem difference constraint sum lengths string number test case make hack solve versions task give a string $$$ s $$$ consist lowercase english letter find longest string $$$ t $$$ satisfy follow condition : input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) number test case next $$$ t $$$ line describe a test case test case a non - empty string $$$ s $$$ consist lowercase english letter guarantee sum lengths string test case exceed $$$ 1000000 $$$ test case print longest string satisfy condition describe exist multiple possible solutions print first test string $$$ s = $$$ ` ` a '' satisfy condition second test string ` ` <unknown> '' satisfy condition : prove exist a longer string satisfy condition fourth test string ` ` c '' correct ` ` c '' $$$ = $$$ ` ` c '' $$$ + $$$ ` ` '' $$$ a $$$ $$$ b $$$ empty possible solution test ` ` s '',['greedy'],1800.0
1706/A,a sequence $$$ a_1 a_2 \ldots a_n $$$ length $$$ n $$$ consist integers $$$ 1 $$$ $$$ m $$$ also a string $$$ s $$$ consist $$$ m $$$ character b. go perform follow $$$ n $$$ operations find lexicographically smallest string get operations a string $$$ x $$$ lexicographically smaller a string $$$ y $$$ length first position $$$ x $$$ $$$ y $$$ differ string $$$ x $$$ a letter appear earlier alphabet correspond letter $$$ y $$$ first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 2000 $$$ ) first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 50 $$$ ) — length sequence $$$ a $$$ length string $$$ s $$$ respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le m $$$ ) — sequence $$$ a $$$ test case print a string length $$$ m $$$ — lexicographically smallest string get character string either capital english letter a capital english letter b. first test case sequence $$$ a = [ 1 1 3 1 ] $$$ one possible solutions follow second test case go perform one operation replace either $$$ 2 $$$ -nd character $$$ 4 $$$ -th character $$$ s $$$ a. get string babbb <unknown> operation string babbb lexicographically smallest among string third test case string get a. fourth test case replace $$$ 1 $$$ -st $$$ 2 $$$ -nd character $$$ s $$$ a get <unknown> fifth test case replace $$$ 1 $$$ -st $$$ 3 $$$ -rd character $$$ s $$$ a get <unknown>,['greedy'],800.0
319/D,"a substring a string a contiguous subsequence string , string bca substring string abcabc string cc a repeat block a string form concatenate string , string abcabc a repeat block string <unknown> <unknown> ' ve get a sequence latin character ( string ) step find shortest substring a repeat block exist one must choose leftmost substring form xx ( x — string ) replace substring x word delete one x substrings substring repeat process remain repeat block string would final string look like ? look sample explanation understand statement <unknown> first line input 're give a string small latin character length 1 50000 inclusive print final string apply change first sample string transform follow : <unknown> → abcabc → abc second sample string transform follow : <unknown> → <unknown> → <unknown> → <unknown> → abaab → abab → ab",['greedy'],2800.0
535/D,"tavas a strange creature usually ` ` <unknown> '' come people 's mouth sleep string s length n come tavas ' mouth instead today tavas fell asleep malekas ' place sleep malekas a little process s. malekas a favorite string p. determine position x1 < x2 < ... < xk p match s. formally xi ( 1 ≤ i ≤ k ) condition <unknown> + 1 ... <unknown> + |p| - 1 = p <unknown> malekas write one subsequences x1 x2 ... xk ( possibly n't write anything ) a piece paper a sequence b a subsequence sequence a turn a b remove elements ( maybe one ) tavas wake malekas tell everything could n't remember string s know p s contain lowercase english letter also subsequence write piece paper tavas wonder number possible value s ? ask saddas n't smart enough solve , tavas ask calculate number answer large tavas want print answer modulo 109 + 7 . first line contain two integers n m length s length subsequence malekas write ( 1 ≤ n ≤ 106 0 ≤ m ≤ n - |p| + 1 ) second line contain string p ( 1 ≤ |p| ≤ n ) next line contain m space separate integers y1 y2 ... ym malekas ' subsequence ( 1 ≤ y1 < y2 < ... < ym ≤ n - |p| + 1 ) a single line print answer modulo 1000 000 007 . first sample test string form ` ` <unknown> ? '' question mark replace arbitrary english letter satisfy |x| denote length string x. please note 's possible string ( answer 0 )",['greedy'],1900.0
1009/G,polycarp launch new startup idea <unknown> pretty free key vector development sound really promise easily find investors ready sponsor company however yet name startup ! actually polycarp already come name <unknown> never hurt want swap letter position obtain better name n't necessary letter adjacent addition investors choose index name select a set letter go indices choose different investors pairwise distinct indices n't choose <unknown> letter go finally polycarp sure smallest lexicographically name best ( like think google decide become alphabet ? ) formally give a string consist lowercase latin letter ` ` a '' ` ` f '' swap letter position arbitrary number time ( zero swap also possible ) smallest lexicographically name obtain letter every position among allow letter ? polycarp ca n't produce valid name print ` ` impossible '' first line string $$$ s $$$ ( $$$ 1 \le |s| \le 100000 $$$ ) — name polycarp come string consist lowercase latin letter ` ` a '' ` ` f '' second line contain a single integer $$$ m $$$ ( $$$ 0 \le m \le |s| $$$ ) — number investors $$$ i $$$ -th next $$$ m $$$ line contain integer number $$$ pos_i $$$ a non - empty string allow character $$$ pos_i $$$ ( $$$ 1 \le pos_i \le |s| $$$ ) string contain pairwise distinct letter ` ` a '' ` ` f '' $$$ <unknown> <unknown> \dots <unknown> $$$ pairwise distinct position string n't appear investors demand letter go position polycarp ca n't produce valid name print ` ` impossible '' otherwise print smallest lexicographically name polycarp obtain swap letter string $$$ s $$$ letter every position among allow ones,['greedy'],2400.0
1622/E,petya a math teacher $$$ n $$$ students write a test consist $$$ m $$$ question student know question answer correctly student answer $$$ j $$$ -th question correctly get $$$ p_j $$$ point ( otherwise get $$$ 0 $$$ point ) moreover point question distribute a way array $$$ p $$$ a permutation number $$$ 1 $$$ $$$ m $$$ $$$ i $$$ -th student petya know expect get $$$ x_i $$$ point test petya wonder unexpected result could petya believe surprise value result students equal $$$ \sum\limits _ { i=1 } ^ { n } <unknown> - <unknown> $$$ $$$ r_i $$$ number point $$$ i $$$ -th student get test task help petya find a permutation $$$ p $$$ surprise value result maximum possible multiple answer print first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 10 $$$ ; $$$ 1 \le m \le 10000 $$$ ) — number students number question respectively second line contain $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ 0 \le x_i \le \frac { m ( m+1 ) } { 2 } $$$ ) $$$ x_i $$$ number point $$$ i $$$ -th student expect get follow $$$ n $$$ line $$$ i $$$ -th line contain string $$$ s_i $$$ ( $$$ |s_i| = m ; s _ { i j } \in \ { 0 1\ } $$$ ) $$$ s _ { i j } $$$ $$$ 1 $$$ $$$ i $$$ -th student answer $$$ j $$$ -th question correctly $$$ 0 $$$ otherwise sum $$$ m $$$ test case exceed $$$ 10000 $$$ test case print $$$ m $$$ integers — a permutation $$$ p $$$ surprise value result maximum possible multiple answer print,['greedy'],2200.0
1303/D,a bag size $$$ n $$$ also $$$ m $$$ box size $$$ i $$$ -th box $$$ a_i $$$ $$$ a_i $$$ integer non - negative power two divide box two part equal size goal fill bag completely example $$$ n = 10 $$$ $$$ a = [ 1 1 32 ] $$$ divide box size $$$ 32 $$$ two part size $$$ 16 $$$ divide box size $$$ 16 $$$ fill bag box size $$$ 1 $$$ $$$ 1 $$$ $$$ 8 $$$ calculate minimum number divisions require fill bag size $$$ n $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 10^ { 18 } 1 \le m \le 100000 $$$ ) — size bag number box respectively second line test case contain $$$ m $$$ integers $$$ a_1 a_2 \dots a_m $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — size box guarantee $$$ a_i $$$ a power two also guarantee sum $$$ m $$$ test case exceed $$$ 100000 $$$ test case print one integer — minimum number divisions require fill bag size $$$ n $$$ ( $$$ -1 $$$ impossible ),['greedy'],1900.0
425/B,"sereja n × m rectangular table a cell table contain a zero a number one sereja want table meet follow requirement : connect component value form a rectangle side parallel side table rectangles fill cells , a component form a rectangle size h × w component must contain exactly <unknown> cells a connect component value a set cells table meet follow condition : sereja change value k cells table table meet describe requirement ? minimum number table cells change case ? first line contain integers n m k ( 1 ≤ n m ≤ 100 ; 1 ≤ k ≤ 10 ) next n line describe table a : i - th contain m integers ai1 ai2 ... aim ( 0 ≤ ai j ≤ 1 ) — value cells i - th row print -1 impossible meet requirement otherwise print minimum number cells change",['greedy'],2200.0
1325/D,give 2 integers $$$ u $$$ $$$ v $$$ find shortest array bitwise - xor elements $$$ u $$$ sum elements $$$ v $$$ line contain 2 integers $$$ u $$$ $$$ v $$$ $$$ ( 0 \le u v \le 10^ { 18 } ) $$$ 's array satisfy condition print ` ` -1 '' otherwise : first line contain one integer $$$ n $$$ represent length desire array next line contain $$$ n $$$ positive integers array multiple possible answer print first sample $$$ <unknown> 1 = 2 $$$ $$$ 3 + 1 = 4 $$$ valid array smaller length notice fourth sample array empty,['greedy'],1700.0
1500/C,give two table $$$ a $$$ $$$ b $$$ size $$$ n \times m $$$ define a sort column follow : choose a column reorder row table value column row smallest value row largest case two row equal value column relative order change ( sort algorithms call stable ) find behavior sort column many office software manage <unknown> petya work one a table $$$ a $$$ open right want perform zero sort column transform table table $$$ b $$$ determine possible yes find a sequence columns sort note need minimize number sort first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 1500 $$$ ) — size table next $$$ n $$$ line contain $$$ m $$$ integers $$$ a _ { i j } $$$ ( $$$ 1 \le a _ { i j } \le n $$$ ) denote elements table $$$ a $$$ next $$$ n $$$ line contain $$$ m $$$ integers $$$ b _ { i j } $$$ ( $$$ 1 \le b _ { i j } \le n $$$ ) denote elements table $$$ b $$$ possible transform $$$ a $$$ $$$ b $$$ print $$$ -1 $$$ otherwise first print integer $$$ k $$$ ( $$$ 0 \le k \le 5000 $$$ ) — number sort solution print $$$ k $$$ integers $$$ c_1 \ldots c_k $$$ ( $$$ 1 \le c_i \le m $$$ ) — columns petya need perform a sort show a solution exist one $$$ 5000 $$$ sort consider second example sort first column table become $$$ $$$ \begin { matrix } 1 & 3 & 3\\ 1 & 1 & 2\\ 2 & 3 & 2 \end { matrix } $$$ $$$ sort second column table become $$$ $$$ \begin { matrix } 1 & 1 & 2\\ 1 & 3 & 3\\ 2 & 3 & 2 \end { matrix } $$$ $$$ need third test sort change anything columns already sort,['greedy'],2600.0
1095/C,"a positive integer $$$ x $$$ call a power two represent $$$ x = <unknown> $$$ $$$ y $$$ a non - negative integer , power two $$$ 1 2 4 8 16 \dots $$$ give two positive integers $$$ n $$$ $$$ k $$$ task represent $$$ n $$$ sum exactly $$$ k $$$ power two line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 1000000000 $$$ $$$ 1 \le k \le 200000 $$$ ) impossible represent $$$ n $$$ sum $$$ k $$$ power two print otherwise print yes print $$$ k $$$ positive integers $$$ b_1 b_2 \dots b_k $$$ $$$ b_i $$$ a power two $$$ \sum \limits _ { i = 1 } ^ { k } b_i = n $$$ multiple answer may print",['greedy'],1400.0
1202/A,"give two binary string $$$ x $$$ $$$ y $$$ binary representations two integers ( let 's denote integers $$$ f ( x ) $$$ $$$ f ( y ) $$$ ) choose integer $$$ k \ge 0 $$$ calculate expression $$$ s_k = f ( x ) + f ( y ) \cdot <unknown> $$$ write binary representation $$$ s_k $$$ reverse order ( let 's denote $$$ rev_k $$$ ) example let $$$ x = 1010 $$$ $$$ y = 11 $$$ ; ' ve choose $$$ k = 1 $$$ since $$$ 2 ^ 1 = 10_2 $$$ $$$ s_k = 1010_2 + <unknown> \cdot 10_2 = <unknown> $$$ $$$ rev_k = <unknown> $$$ give $$$ x $$$ $$$ y $$$ need choose $$$ k $$$ $$$ rev_k $$$ lexicographically minimal ( read note n't know ` ` lexicographically '' mean ) 's guarantee give constraints $$$ k $$$ exist finite first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number query next $$$ 2 t $$$ line contain a description query : two line per query first line contain one binary string $$$ x $$$ consist $$$ 100000 $$$ character character either 0 1 . second line contain one binary string $$$ y $$$ consist $$$ 100000 $$$ character character either 0 1 . 's guarantee $$$ 1 \le f ( y ) \le f ( x ) $$$ ( $$$ f ( x ) $$$ integer represent $$$ x $$$ $$$ f ( y ) $$$ integer represent $$$ y $$$ ) representations n't lead zero total length $$$ x $$$ query n't exceed $$$ 100000 $$$ total length $$$ y $$$ query n't exceed $$$ 100000 $$$ print $$$ t $$$ integers ( one per query ) query print $$$ k $$$ $$$ rev_k $$$ lexicographically minimal first query describe legend second query 's optimal choose $$$ k = 3 $$$ $$$ 2 ^ 3 = 1000_2 $$$ $$$ s_3 = <unknown> + <unknown> \cdot 1000_2 = <unknown> + <unknown> = 1000001 $$$ $$$ rev_3 = 1000001 $$$ example $$$ k = 0 $$$ $$$ s_0 = <unknown> $$$ $$$ rev_0 = 11101 $$$ $$$ rev_3 = 1000001 $$$ lexicographically smaller $$$ rev_0 = 11101 $$$ third query $$$ s_0 = 10 $$$ $$$ rev_0 = 01 $$$ example $$$ s_2 = 101 $$$ $$$ <unknown> = 101 $$$ $$$ 01 $$$ lexicographically smaller $$$ 101 $$$ quote wikipedia : ` ` determine two string character come arrange lexicographical order first letter compare differ string whose first letter come earlier alphabet come string first letter second letter compare , a position reach one string letter compare first ( shorter ) string <unknown> come first <unknown> order . ''",['greedy'],1100.0
1687/B,"interactive problem direct <unknown> kanako <unknown> <unknown> railway system gensokyo finally finish <unknown> ( gensokyo railways ) consist $$$ n $$$ station $$$ m $$$ bidirectional track connect $$$ i $$$ -th track length $$$ l_i $$$ ( $$$ 1\le <unknown> 1000000 $$$ ) due budget limit railway system may connect though may one track two station value a railway system define total length track maximum ( minimum ) capacity a railway system define maximum ( minimum ) value among currently functional system 's full span forest brief full span forest a graph a span forest <unknown> give graph kanako a simulator able process $$$ 2 m $$$ query input simulator a string $$$ s $$$ length $$$ m $$$ consist character 0 and/or 1 . simulator assume $$$ i $$$ -th track functional $$$ <unknown> $$$ 1 . device tell kanako maximum capacity system simulate state kanako want know minimum capacity system track functional help simulator structure railway system fix advance word interactor adaptive first line input contain two integers $$$ n m $$$ ( $$$ 2 \leq n \leq 200 $$$ $$$ 1\le m \le 500 $$$ ) — number station track begin interaction read $$$ n m $$$ make a query print ` ` ? $$$ s $$$ ` ` ( without quote $$$ s $$$ a string length $$$ m $$$ consist character 0 and/or 1 ) read response standard input — maximum capacity system simulate state program make invalid query run try interactor terminate immediately program get a verdict wrong answer give final answer print ` ` ! $$$ l $$$ ` ` ( without quote $$$ l $$$ minimum capacity system track functional ) note give answer count towards limit $$$ 2 m $$$ query print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksthe first line input must contain two integers $$$ n m $$$ ( $$$ 2 \leq n \leq 200 $$$ $$$ 1\le m \le 500 $$$ ) — number station track next $$$ m $$$ line input must contain exactly $$$ 3 $$$ space - separated integers $$$ u_i $$$ $$$ v_i $$$ $$$ l_i $$$ ( $$$ 1\le u_i v_i \le n $$$ $$$ u_i\ne v_i $$$ $$$ 1 \leq l_i \leq 1000000 $$$ ) — endpoints length $$$ i $$$ -th track graph example satisfy $$$ l_i = i $$$",['greedy'],1700.0
1583/D,"turn mean life a permutation $$$ p_1 p_2 \ldots p_n $$$ integers $$$ 1 2 \ldots n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) omkar create life know permutation allow figure use query a query consist array $$$ a_1 a_2 \ldots a_n $$$ integers $$$ 1 $$$ $$$ n $$$ $$$ a $$$ require a permutation omkar first compute pairwise sum $$$ a $$$ $$$ p $$$ mean compute array $$$ s $$$ $$$ s_j = p_j + a_j $$$ $$$ j = 1 2 \ldots n $$$ , find smallest index $$$ k $$$ $$$ s_k $$$ occur $$$ s $$$ answer $$$ k $$$ index $$$ k $$$ answer $$$ 0 $$$ perform $$$ 2n $$$ query figure mean life $$$ p $$$ start interaction read single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) — length permutation $$$ p $$$ make query a query consist a single line ` ` $$$ ? \enspace a_1 \enspace a_2 \enspace \ldots \enspace a_n $$$ ` ` ( $$$ 1 \leq a_j \leq n $$$ ) answer query a single integer $$$ k $$$ describe ( $$$ 0 \leq k \leq n $$$ ) make a query forget output end line flush output otherwise get idleness limit exceed , use : output answer print a single line ` ` $$$ ! \enspace p_1 \enspace p_2 \enspace \ldots \enspace p_n $$$ ` ` terminate make $$$ 2n $$$ query output answer count a query hack <unknown> hack first output a line contain $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) output another line contain hide permutation $$$ p_1 p_2 \ldots p_n $$$ number $$$ 1 $$$ $$$ n $$$ sample hide permutation $$$ p $$$ $$$ [ 3 2 1 5 4 ] $$$ three query make first query $$$ a = [ 4 4 2 3 2 ] $$$ yield $$$ s = [ 3 + 4 2 + 4 1 + 2 5 + 3 4 + 2 ] = [ 7 6 3 8 6 ] $$$ $$$ 6 $$$ number appear appear first index $$$ 2 $$$ make answer query $$$ 2 $$$ second query $$$ a = [ 3 5 1 5 5 ] $$$ yield $$$ s = [ 3 + 3 2 + 5 1 + 1 5 + 5 4 + 5 ] = [ 6 7 2 10 9 ] $$$ number appear answer query $$$ 0 $$$ third query $$$ a = [ 5 2 4 3 1 ] $$$ yield $$$ s = [ 3 + 5 2 + 2 1 + 4 5 + 3 4 + 1 ] = [ 8 4 5 8 5 ] $$$ $$$ 5 $$$ $$$ 8 $$$ occur $$$ 5 $$$ first appear index $$$ 3 $$$ $$$ 8 $$$ first appear index $$$ 1 $$$ $$$ 1 < 3 $$$ make answer query $$$ 1 $$$ note sample mean provide example interaction work ; guarantee query represent a correct strategy determine answer",['greedy'],1800.0
1713/D,"interactive problem a tournament consist $$$ 2^n $$$ contestants $$$ 1 $$$ -st contestant compete $$$ 2 $$$ -nd $$$ 3 $$$ -rd compete $$$ 4 $$$ -th , , winner first match compete winner second match etc tournament end one contestant leave declare winner tournament a tournament scheme know single - elimination tournament n't know result want find winner tournament one query select two integers $$$ a $$$ $$$ b $$$ indices two contestants jury return $$$ 1 $$$ $$$ a $$$ match $$$ b $$$ $$$ 2 $$$ $$$ b $$$ match $$$ a $$$ $$$ 0 $$$ number win equal find winner $$$ \left \lceil \frac { 1 } { 3 } \cdot 2^ { n + 1 } \right \rceil $$$ query $$$ \lceil x \rceil $$$ denote value $$$ x $$$ round nearest integer note tournament long mean result fix depend query first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 2^ { 14 } $$$ ) — number test case line input contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 17 $$$ ) guarantee sum $$$ 2^n $$$ test case exceed $$$ 2^ { 17 } $$$ interaction test case begin read integer $$$ n $$$ make a query output ` ` ? a b '' ( $$$ 1 \leq a b \leq 2^n $$$ ) without quote afterwards read one single integer — answer query make $$$ \left \lceil \frac { 1 } { 3 } \cdot 2^ { n + 1 } \right \rceil $$$ query test case receive integer $$$ -1 $$$ instead answer a valid value $$$ n $$$ mean program make invalid query exceed limit query give incorrect answer previous test case program must terminate immediately receive a wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream ready give final answer output ` ` ! x '' ( $$$ 1 \leq x \leq 2^n $$$ ) without quote — winner tournament give answer count towards limit query solve a test case program move next one immediately solve test case program terminate immediately print a query answer forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack use follow format first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 2^ { 14 } $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 17 $$$ ) second line test case contain $$$ 2^n $$$ number a line — number win participant a sequence match consistent number win sum $$$ 2^n $$$ exceed $$$ 2^ { 17 } $$$ tournament first test case show number win $$$ [ <unknown> ] $$$",['greedy'],1800.0
1738/F,"interactive problem give a simple undirected graph $$$ n $$$ vertices number $$$ 1 $$$ $$$ n $$$ task color vertices every color $$$ c $$$ follow condition hold : initially give number $$$ n $$$ vertices degree vertex query choose a vertex $$$ u $$$ a response give $$$ k $$$ -th edge incident $$$ u $$$ $$$ k $$$ -th query vertex $$$ u $$$ allow make $$$ n $$$ query undirected graph simple contain multiple edge self - loops degree a vertex number edge incident a set $$$ s $$$ vertices connect every two different vertices $$$ u v \in s $$$ a path pass vertices $$$ s $$$ connect $$$ u $$$ $$$ v $$$ , a sequence edge $$$ ( <unknown> v_1 ) ( <unknown> v_2 ) \dots ( <unknown> v_k ) $$$ $$$ k \geq 1 $$$ test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case follow line contain description interactive section test case test case begin interaction read integer $$$ n $$$ ( $$$ 1\le n \le 1000 $$$ ) first line indicate number vertices graph second line contain $$$ n $$$ integers $$$ d_1 d_2 \dots d_n $$$ ( $$$ 0 \leq d_i \leq n - 1 $$$ ) $$$ d_i $$$ degree vertex $$$ i $$$ make a query vertex $$$ u $$$ ( $$$ 1 \leq u \leq n $$$ ) output give answer output guarantee graph a simple undirected graph guarantee sum $$$ n $$$ test case exceed $$$ 1000 $$$ case query format invalid make $$$ n $$$ ` ` ? '' query receive wrong answer verdict print a query forget output end line flush output otherwise get idleness limit exceed , use : hack <unknown> first line hack contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) indicate number test case follow line contain description test case first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000 $$$ ) indicate number vertices graph $$$ n $$$ line follow $$$ i $$$ -th line contain integer $$$ d_i $$$ ( $$$ 0 \leq d_i \leq n - 1 $$$ ) indicate degree vertex $$$ i $$$ $$$ d_i $$$ distinct integers $$$ e _ { i,1 } e _ { i,2 } \dots e _ { i d_i } $$$ ( $$$ 1 \leq e _ { i j } \leq n $$$ $$$ e _ { i j } \neq i $$$ ) $$$ \left ( i e _ { i j } \right ) $$$ $$$ j $$$ -th edge incident vertex $$$ i $$$ guarantee graph a simple undirected graph guarantee sum $$$ n $$$ test case exceed $$$ 1000 $$$ example one test case test case $$$ n = 5 $$$ vertices vertices $$$ 1 2 3 4 $$$ degree $$$ 2 $$$ vertex $$$ 5 $$$ degree $$$ 0 $$$ obvious vertex $$$ 5 $$$ isolate i.e. connect vertices a possible interaction show sample input output $$$ 4 $$$ ` ` ? '' query make vertex $$$ 1 $$$ twice vertex $$$ 3 $$$ twice accord responses query know vertex $$$ 1 $$$ vertex $$$ 3 $$$ connect two vertices $$$ 2 $$$ $$$ 4 $$$ a possible solution show sample output vertex $$$ 1 $$$ vertex $$$ 2 $$$ color $$$ 1 $$$ vertex $$$ 3 $$$ vertex $$$ 4 $$$ color $$$ 2 $$$ vertex $$$ 5 $$$ color $$$ 3 $$$ see solution satisfy require condition follow",['greedy'],2400.0
1776/C,"alessia bernardo discover world competitive program book university library library consist $$$ m $$$ section number $$$ 1 $$$ $$$ m $$$ section contain book dedicate a particular subject different section correspond different subject order prevent students <unknown> library university establish a system pass pass a length $$$ y $$$ associate allow access interval $$$ y $$$ consecutive section library a visit student must choose exactly one book one section leave library pass use moment alessia bernardo $$$ n $$$ pass lengths $$$ x_1 \ x_2 \ \dots \ x_n $$$ different <unknown> best way improve : alessia think important study many different topics bernardo believe important study deeply least one topic , alessia want use $$$ n $$$ pass get $$$ n $$$ book distinct topics bernardo would like get least two book topic reach follow <unknown> : follow $$$ n $$$ days alessia choose a pass length $$$ y $$$ among still available interval $$$ y $$$ section library bernardo go library take exactly one book one section bernardo manage get least two book subject alessia able avoid ? decide whether want alessia bernardo fulfill goal choose character judge impersonate character note even moment bernardo already take two book subject interaction go end $$$ n $$$ days first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100 $$$ $$$ n \le m \le 5000 $$$ ) — number pass number section second line contain $$$ n $$$ integers $$$ x_1 \ x_2 \ \dots \ x_n $$$ ( $$$ 1 \le x_i \le m $$$ ) — lengths pass available first print a line contain either string $$$ \texttt { alessia } $$$ string $$$ \texttt { bernardo } $$$ — character want impersonate , $$$ n $$$ turn : one interactions malformed interactor terminate immediately program receive verdict $$$ \texttt { wrong - answer } $$$ otherwise receive verdict accord game 's criteria describe print a line forget end line flush output otherwise get verdict $$$ \texttt { timelimit } $$$ flush output use : first sample show alessia <unknown> goal example interaction ( read input ) follow : $$$ $$$ \begin { array } { |c|c|c| } \hline \textbf { contestant } & \textbf { judge } & \textbf { explanation } \\ \hline \texttt { alessia } & & \text { program act alessia } \\ \hline 3 \quad 11 & & \text { choose $ y = 3 $ $ a = 11 $ } \\ \hline & 13 & \text { judge select $ b = 13 $ } \\ \hline 10 \quad 2 & & \text { choose $ y = 10 $ $ a = 2 $ } \\ \hline & 9 & \text { judge select $ b = 9 $ } \\ \hline 7 \quad 1 & & \text { choose $ y = 7 $ $ a = 1 $ } \\ \hline & 4 & \text { judge select $ b = 4 $ } \\ \hline 2 \quad 10 & & \text { choose $ y = 2 $ $ a = 10 $ } \\ \hline & 10 & \text { judge select $ b = 10 $ } \\ \hline 3 \quad 6 & & \text { choose $ y = 3 $ $ a = 6 $ } \\ \hline & 7 & \text { judge select $ b = 7 $ } \\ \hline \end { array } $$$ $$$ program contestant win book choose bernardo <unknown> different topics action perform contestant judge example interaction may non - optimal second sample show bernardo manage fulfil goal example interaction ( read input ) follow : $$$ $$$ \begin { array } { |c|c|c| } \hline \textbf { contestant } & \textbf { judge } & \textbf { explanation } \\ \hline \texttt { bernardo } & & \text { program act bernardo } \\ \hline & 4 \quad 1 & \text { judge choose $ y = 4 $ $ a = 1 $ } \\ \hline 4 & & \text { select $ b = 4 $ } \\ \hline & 1 \quad 10 & \text { judge choose $ y = 1 $ $ a = 10 $ } \\ \hline 10 & & \text { select $ b = 10 $ } \\ \hline & 6 \quad 3 & \text { judge choose $ y = 6 $ $ a = 3 $ } \\ \hline 4 & & \text { select $ b = 4 $ } \\ \hline & 4 \quad 5 & \text { judge choose $ y = 4 $ $ a = 5 $ } \\ \hline 8 & & \text { select $ b = 8 $ } \\ \hline \end { array } $$$ $$$ program contestant win bernardo select two book topic number $$$ 4 $$$ action perform contestant judge example interaction may non - optimal",['greedy'],2500.0
1776/I,"two siblings alberto beatrice eat a spinach pizza together however none like spinach want eat little possible pizza shape a strictly convex polygon $$$ n $$$ vertices locate integer coordinate $$$ ( x_1 y_1 ) \ ( x_2 y_2 ) \ \dots \ ( x_n y_n ) $$$ plane siblings decide eat pizza follow way : take turn start alberto sibling choose a vertex remain part pizza eat triangle determine two neighbor edge way first $$$ n - 3 $$$ turn pizza one less vertex game end $$$ ( n - 2 ) $$$ -th turn pizza eat assume alberto beatrice choose slice eat optimally siblings manage eat half pizza ? identify a sibling a strategy help choose slice <unknown> note possible alberto beatrice end eat exactly half area choose slice optimally first line contain a single integer $$$ n $$$ ( $$$ 4 \le n \le 100 $$$ ) — number vertices next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ -1000000 \le x_i y_i \le 1000000 $$$ ) — coordinate $$$ i $$$ -th vertex polygon represent initial shape pizza guarantee polygon strictly convex vertices give counterclockwise order first print a line contain either string $$$ \texttt { alberto } $$$ string $$$ \texttt { beatrice } $$$ — sibling help win , next $$$ n - 2 $$$ turn alternate judge choose a slice pizza remove start choose help alberto start judge choose help beatrice one interactions malformed interactor terminate immediately program receive verdict $$$ \texttt { wrong - answer } $$$ otherwise receive $$$ \texttt { correct } $$$ end player eat half pizza $$$ \texttt { wrong - answer } $$$ otherwise print a line forget end line flush output otherwise get verdict $$$ \texttt { timelimit } $$$ flush output use : first sample pizza area $$$ 15 $$$ alberto eat less half pizza eat slice around vertex $$$ 2 $$$ ( area $$$ <unknown> $$$ ) around vertex $$$ 3 $$$ ( area $$$ <unknown> $$$ ) second sample prove players eat exactly half pizza eat optimally therefore possible choose help either alberto beatrice third sample possible show beatrice a strategy eat half pizza follow example a valid interaction ( read input ) : $$$ $$$ \begin { array } { |c|c|c| } \hline \textbf { contestant } & \textbf { judge } & \textbf { explanation } \\ \hline \texttt { beatrice } & & \text { contestant help beatrice } \\ \hline & \texttt { 7 } & \text { alberto eat triangle vertices $ 6 $ $ 7 $ $ 1 $ area $ 1 $ } \\ \hline \texttt { 2 } & & \text { beatrice eat triangle vertices $ 1 $ $ 2 $ $ 3 $ area $ 2 $ } \\ \hline & \texttt { 5 } & \text { alberto eat triangle vertices $ 4 $ $ 5 $ $ 6 $ area $ <unknown> $ } \\ \hline \texttt { 4 } & & \text { beatrice eat triangle vertices $ 3 $ $ 4 $ $ 6 $ area $ 8 $ } \\ \hline & \texttt { 6 } & \text { alberto eat triangle vertices $ 3 $ $ 6 $ $ 1 $ area $ 11 $ } \\ \hline \end { array } $$$ $$$ total area eat alberto $$$ <unknown> $$$ total area eat beatrice $$$ 10 $$$ less half area whole pizza action perform contestant judge example interaction may non - optimal process illustrate :",['greedy'],2500.0
1779/E,"interactive problem anya gather $$$ n $$$ chess experts number $$$ 1 $$$ $$$ n $$$ follow properties hold : organize a tournament anya host $$$ n-1 $$$ game game choose two players one win stay one disqualify game host one player remain a player say a candidate master win a tournament ( notice winner a tournament may depend players select anya $$$ n-1 $$$ game ) since anya a curious girl interest find candidate master unfortunately much time speed process organize $$$ 2n $$$ simuls ( short ` ` simultaneous exhibition '' one player play many ) one simul anya choose exactly one player play ( least one ) players choose player win game would win a regular game hold losses simul finish anya tell total number game choose player ( ones ) nobody disqualify a simul help anya host simuls determine candidate master ? win players pair could change simuls a way preserve result previous simuls change may depend query firstly jury send one integer $$$ n $$$ ( $$$ 3 \leq n \leq 250 $$$ ) read — number players , program may ask query report answer ask a query print ` ` ? $$$ i \ ; s_1 s_2 \ldots s_n $$$ ` ` ( without quote ) $$$ i $$$ index player play players simul $$$ s $$$ a binary string denote players play $$$ i $$$ play every player $$$ j $$$ $$$ s_j = 1 $$$ hold ( $$$ s_j = 1 $$$ hold least one $$$ 1 \leq j \leq n $$$ ) please note $$$ s_i = 0 $$$ must hold since a player play otherwise query consider incorrect , read integer — number game player $$$ i $$$ identify answer must print ` ` ! $$$ c_1 c_2 \ldots c_n $$$ ` ` ( without quote ) terminate program $$$ c $$$ a binary string represent candidate master player $$$ i $$$ a candidate master $$$ <unknown> $$$ hold otherwise , ask $$$ 2n $$$ query one query malformed interaction terminate immediately program receive verdict wrong answer print a query forget output end line flush output otherwise get idleness limit exceed , use : hack <unknown> problem first example first query describe a simul player $$$ 1 $$$ play player $$$ 2 $$$ ( one else ) answer query $$$ 1 $$$ mean player $$$ 1 $$$ game play conclude $$$ 1 $$$ beat $$$ 2 $$$ similarly second query tell us $$$ 2 $$$ beat $$$ 3 $$$ third query tell us $$$ 3 $$$ beat $$$ 1 $$$ players candidate master case <unknown> second example third query describe a simul player $$$ 1 $$$ play every player answer query $$$ 4 $$$ mean every game play conclude player $$$ 1 $$$ also beat every player never lose hence player remain end every possible tournament possible candidate master",['greedy'],2400.0
1797/C,"interactive problem li ming li hua play a game li hua a chessboard size $$$ <unknown> m $$$ denote $$$ ( r c ) $$$ ( $$$ 1\le r\le n 1\le c\le m $$$ ) cell $$$ r $$$ -th row top $$$ c $$$ -th column leave li ming put a king chessboard li hua need guess position li hua ask li ming $$$ 3 $$$ question question choose a cell ask minimum step need move king choose cell question independent mean king n't actually move a king move $$$ ( x y ) $$$ $$$ ( x ' y ' ) $$$ $$$ <unknown> { |x - <unknown> <unknown> - <unknown> } = 1 $$$ ( show follow picture ) position king choose interaction suppose li hua please solve problem first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) first line test case contain two integers $$$ n m $$$ ( $$$ 1\le n m\le 1000000000 $$$ ) — size chessboard interaction begin ask a question print ` ` ? $$$ r $$$ $$$ c $$$ ` ` ( without quote $$$ 1 \leq r \leq n 1 \leq c \leq m $$$ ) input response standard input — minimum step king need move choose cell program ask invalid question run question interactor terminate immediately program get a verdict wrong answer give final answer print ` ` ! $$$ r $$$ $$$ c $$$ ` ` ( without quote $$$ ( r c ) $$$ king 's initial coordinate ) note give answer count towards limit $$$ 3 $$$ question ask a question forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack use follow format first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) first line test case contain four integers $$$ n m r c $$$ ( $$$ 1\le r\le n\le <unknown> c\le m\le 1000000000 $$$ ) test case 1 king $$$ ( 2,2 ) $$$ take $$$ 1 $$$ step move $$$ ( 2,3 ) $$$ $$$ 2 $$$ step move $$$ ( 2,4 ) $$$ note question may seem <unknown> a sample question may ask",['greedy'],1600.0
17/B,nick 's company employ n people nick need build a tree hierarchy « supervisor - <unknown> » relations company ( say employee except one exactly one supervisor ) m applications write follow form : « employee ai ready become a supervisor employee bi extra cost ci » qualification qj employee know application follow true : qai > qbi would help nick calculate minimum cost a hierarchy find impossible build first input line contain integer n ( 1 ≤ n ≤ 1000 ) — amount employees company follow line contain n space - separated number qj ( 0 ≤ qj ≤ 106 ) — employees ' <unknown> follow line contain number m ( 0 ≤ m ≤ 10000 ) — amount receive applications follow m line contain applications form three space - separated number : ai bi ci ( 1 ≤ ai bi ≤ n 0 ≤ ci ≤ 106 ) different applications similar i.e come one employee offer become a supervisor person a different cost application qai > qbi output line — minimum cost build a hierarchy -1 impossible build first sample one possible ways build a hierarchy take applications index 1 2 4 give 11 minimum total cost second sample impossible build require hierarchy answer -1,['greedy'],1500.0
1672/E,"interactive problem $$$ n $$$ word a text editor $$$ i $$$ -th word length $$$ l_i $$$ ( $$$ 1 \leq l_i \leq 2000 $$$ ) array $$$ l $$$ hide know grader text editor display word line split two word a line least one space note a line end a space let height text editor refer number line use give width text editor display word a way height minimize formally suppose text editor width $$$ w $$$ let $$$ a $$$ array length $$$ k+1 $$$ $$$ 1 = a_1 < a_2 < \ldots < a _ { k+1 } = n+1 $$$ $$$ a $$$ a valid array $$$ 1 \leq i \leq k $$$ $$$ l _ { a_i } <unknown> _ { <unknown> } <unknown> _ { a _ { i+1 } -1 } \leq w $$$ height text editor minimum $$$ k $$$ valid array note $$$ w < \max ( l_i ) $$$ text editor display word properly crash height text editor $$$ 0 $$$ instead ask $$$ n+30 $$$ query one query provide a width $$$ w $$$ , grader return height $$$ h_w $$$ text editor width $$$ w $$$ find minimum area text editor minimum value $$$ w \cdot h_w $$$ $$$ w $$$ $$$ h_w \neq 0 $$$ lengths fix advance word interactor adaptive first line input contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 2000 $$$ ) — number word text editor guarantee hide lengths $$$ l_i $$$ satisfy $$$ 1 \leq l_i \leq 2000 $$$ begin interaction read $$$ n $$$ make a query print ` ` ? $$$ w $$$ ` ` ( without quote $$$ 1 \leq w \leq 1000000000 $$$ ) read response standard input , $$$ h_w $$$ program make invalid query run try interactor terminate immediately program get a verdict wrong answer give final answer print ` ` ! $$$ area $$$ ` ` ( without quote ) note give answer count towards limit $$$ n+30 $$$ query print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksthe first line input must contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 2000 $$$ ) — number word text editor second line input must contain exactly $$$ n $$$ space - separated integers $$$ l_1 l_2 \ldots <unknown> $$$ ( $$$ 1 \leq l_i \leq 2000 $$$ ) first test case word $$$ \ { \texttt { <unknown> } \texttt { } \texttt { <unknown> } \texttt { } \texttt { anton } \texttt { trygub } \ } $$$ $$$ <unknown> { <unknown> } $$$ $$$ w=1 $$$ text editor able display word properly crash height text editor $$$ <unknown> $$$ grader return $$$ 0 $$$ $$$ <unknown> $$$ a possible way word display text editor : height text editor $$$ h _ { 9 } = 4 $$$ grader return $$$ 4 $$$ $$$ <unknown> $$$ a possible way word display text editor : height text editor $$$ h _ { 16 } = 2 $$$ grader return $$$ 2 $$$ somehow figure minimum area text editor $$$ 32 $$$ answer",['greedy'],2200.0
61/D,valerian capture shapur victory a great one shapur decide <unknown> a scene valerian 's defeat a mountain find best place make victory eternal ! decide visit n cities persia find best available mountain recent war tire n't want traverse a lot want visit n cities least smallest possible traverse <unknown> cities connect bidirectional roads go city one use roads a unique path two cities cities number 1 n. shapur currently city 1 want visit cities minimum possible traverse finish travel city help shapur find much travel first line contain a single natural number n ( 1 ≤ n ≤ 105 ) — amount cities next n - 1 line contain 3 integer number xi yi wi ( 1 ≤ xi yi ≤ n 0 ≤ wi ≤ 2 × 104 ) xi yi two end a road wi length road a single integer number minimal length shapur 's travel please use % lld specificator read write 64 - bit integers c++ preffered use cout ( also may use % i64d ),['greedy'],1800.0
1498/E,"interactive problem remember flush output communicate test program may use fflush ( stdout ) c++ system.out.flush ( ) java <unknown> ( ) python flush ( output ) pascal flush output use program language <unknown> documentation may also refer guide interactive problems : https : <unknown> / <unknown> / <unknown> a city dixit live city $$$ n $$$ house exactly one direct road every pair house example consider two house a b a direct road either a b b a number roads lead $$$ i $$$ -th house $$$ k_i $$$ two house a b bi - reachable a reachable b b reachable a. say house b reachable house a a path house a house b. dixit want buy two house city , one live one study course would like travel one house another , want find a pair bi - reachable house a b. among pair want choose one maximum value $$$ |k_a - k_b| $$$ $$$ k_i $$$ number roads lead house $$$ i $$$ one optimal pair exist suitable since dixit busy prepare <unknown> help find desire pair house tell house exist ? problem input give direction road give — house — number incoming roads house ( $$$ k_i $$$ ) allow ask one type query judge : give two house a b judge answer whether b reachable a. upper limit number query , ask query judge answer ` ` yes '' query also ask query twice exhaust query ( judge respond ` ` yes '' query ) program must output guess two house quit see interaction section detail first line contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 500 $$$ ) denote number house city next line contain $$$ n $$$ space - separated integers $$$ k_1 k_2 \dots <unknown> $$$ ( $$$ 0 \le k_i \le n - 1 $$$ ) $$$ i $$$ -th represent number incoming roads $$$ i $$$ -th house ask a query print ` ` ? a b '' $$$ ( 1 \leq a b \leq n <unknown> b ) $$$ judge respond ` ` yes '' house b reachable house a ` ` '' otherwise output final answer print ` ` ! a b '' a b bi - reachable maximum possible value $$$ |k_a - k_b| $$$ exist pair house a b output ` ` ! 0 0 '' output final answer program must terminate immediately otherwise receive wrong answer verdict ask query twice upper limit number query ask , ask query judge answer ` ` yes '' query program must output final answer ( ` ` ! a b '' ` ` ! 0 0 '' ) terminate ask a query incorrect format repeat a previous query get wrong answer verdict print a query forget output end line flush output otherwise get idleness limit exceed error , use : first sample input give a city three house one incoming road user program ask one query : ` ` ? 1 2 '' : ask whether reach house $$$ 1 $$$ house $$$ 2 $$$ judge respond ` ` yes '' user program conclude sufficient information determine correct answer , output ` ` ! 1 2 '' quit second sample input user program query six different pair house finally answer ` ` ! 0 0 '' convince two house desire question exist city",['greedy'],2200.0
73/D,vasya play freediv game manage a huge state n cities m two - way roads unfortunately every city reach one move along roads therefore vasya decide divide state provinces every province one could reach every city cities province roads provinces unlike turn - based strategies freediv a player opportunity build tunnel cities tunnel two - way roads along one move armies <unknown> enemy however one tunnel connect city vasya want build a network tunnel pair cities state reachable path consist roads a tunnel k tunnel connect province ( otherwise province difficult keep case provinces capture enemy armies ) vasya discover maybe able build a network current condition state maybe 'll first build several roads cities different provinces merge provinces task determine minimum number roads vasya need build possible build require network tunnel result state first line contain three integers n m k ( 1 ≤ n k ≤ 106 0 ≤ m ≤ 106 ) next m line contain two integers number cities connect a correspond road road connect city one road pair cities print a single number minimum number additional roads first example one province exist necessary build tunnel roads second example two provinces exist possible merge provinces build a tunnel cities 1 3 . third example least one additional road necessary example possible build additional road cities 1 2 build two tunnel cities 1 3 2 4,['greedy'],2200.0
571/C,"' in boolean logic a formula <unknown> normal form ( cnf ) <unknown> normal form a conjunction clauses a clause a disjunction literals ' ( <unknown> https : //en.wikipedia.org / wiki / <unknown> ) word cnf a formula type & represent a logical ` ` '' ( conjunction ) represent a logical ` ` '' ( disjunction ) vij boolean variables negations statement bracket call a clause vij call literals give a cnf contain variables x1 ... xm negations know variable occur two clauses ( negation without negation total ) task determine whether cnf satisfiable , whether value variables cnf value true cnf satisfiable also need determine value variables cnf true guarantee variable occur clause first line contain integers n m ( 1 ≤ n m ≤ 2·105 ) — number clauses number variables correspondingly next n line contain descriptions clause i - th line first contain first number ki ( ki ≥ 1 ) — number literals i - th clauses follow space - separated literals vij ( 1 ≤ <unknown> ≤ m ) a <unknown> correspond vij <unknown> either negation vij negative without negation otherwise cnf satisfiable print a single line ` ` '' ( without quote ) otherwise print two string : string ` ` yes '' ( without quote ) a string m number zero one — value variables satisfy assignment order x1 xm first sample test formula one possible answer x1 = true x2 = true",['greedy'],2500.0
896/B,"interactive problem refer interaction section better understand ithea chtholly want play a game order determine use <unknown> tonight initially ithea put n clear sheet paper a line number 1 n leave right game go m round round ithea give chtholly integer 1 c chtholly need choose one sheet write number ( already a number erase original one replace new one ) chtholly win time sheet fill a number n number non - decreasing order look leave right sheet 1 sheet n m round still n't win lose game chtholly really want win game want cook something willem n't know win game chtholly find task write a program receive number ithea give chtholly help make decision sheet paper write number first line contain 3 integers n m c ( mean round ) — number sheet number round largest possible number ithea give chtholly respectively remain part input give throughout interaction process round program need read one line contain a single integer pi ( 1 ≤ pi ≤ c ) indicate number give chtholly program output a line contain integer 1 n indicate number sheet write number output line n't forget flush output example : chtholly win end a round input become available program terminate normally show constraints 's always possible chtholly win game example chtholly initially know 2 sheet 4 round number 1 4 . receive a 2 decide write 1st sheet receive a 1 write 2nd sheet last receive a 3 replace 1 3 2nd sheet time sheet fill a number non - decreasing game note require program terminate immediately chtholly win read number input remain round , undefined <unknown> may arise wo n't sure whether program accept reject also please careful hack others ' cod sample chtholly game 3rd round require program n't read number remain <unknown> round input format hack :",['greedy'],2000.0
445/B,dzy love chemistry enjoy mix chemicals dzy n chemicals m pair react want pour chemicals a test tube need pour one one order let 's consider danger a test tube danger empty test tube 1 . every time dzy pour a chemical already one chemicals test tube react danger test tube multiply 2 . otherwise danger remain find maximum possible danger pour chemicals one one optimal order first line contain two space - separated integers n m next m line contain two space - separated integers xi yi ( 1 ≤ xi < yi ≤ n ) integers mean chemical xi react chemical yi pair chemicals appear input consider chemicals number 1 n order print a single integer — maximum possible danger first sample 's one way pour danger wo n't increase second sample matter pour 1st chemical first pour 2nd chemical first answer always 2 . third sample four ways achieve maximum possible danger : 2 - 1 - 3 2 - 3 - 1 1 - 2 - 3 3 - 2 - 1 ( number chemicals order pour ),['greedy'],1400.0
237/D,' ve get a undirected tree s consist n nod task build optimal t - decomposition let 's define a t - decomposition follow let 's denote set nod s v. let 's consider undirected tree t whose nod non - empty subsets v 'll call xi tree t a t - decomposition s follow condition hold : obviously many distinct tree t t - decompositions tree s. example a t - decomposition a tree consist a single node equal set v. let 's define cardinality node xi number nod tree s contain node let 's choose node maximum cardinality t. let 's assume cardinality equal w. weight t - decomposition t value w. optimal t - decomposition one minimum weight task find optimal t - decomposition give tree s minimum number nod first line contain a single integer n ( 2 ≤ n ≤ 105 ) denote number nod tree s. follow n - 1 line contain two space - separated integers ai bi ( 1 ≤ ai bi ≤ n ; ai ≠ bi ) denote nod tree s indices ai bi connect edge consider nod tree s index 1 n. guarantee s a tree first line print a single integer m denote number nod require t - decomposition print m line contain descriptions t - decomposition nod i - th ( 1 ≤ i ≤ m ) print description node xi t - decomposition description node xi start integer ki represent number nod initial tree s contain node xi print ki distinct space - separated integers — number nod s contain xi arbitrary order print m - 1 line consist two integers pi qi ( 1 ≤ pi qi ≤ m ; pi ≠ qi ) pair integers pi qi mean edge nod <unknown> <unknown> t - decomposition print t - decomposition optimal t - decomposition give tree s minimum possible number nod among optimal t - decompositions multiple optimal t - decompositions minimum number nod print,['greedy'],2000.0
549/B,"looksery company consist n staff members plan another big party every employee phone number phone number friends phone book everyone come party send message contact cool time everyone try spend much time fun possible send message everyone without special think moreover person even send a message igor max looksery developers start a dispute many message person get igor indicate n number i - th indicate many message view i - th employee go take igor guess correctly least one number win otherwise max win support max <unknown> need give contact list employees determine whether a situation igor lose specifically need determine employees come party , visitors send message contact employee receive a number message different igor state first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number employees company looksery next n line contain description contact list employees i - th line contain a string length n consist digits zero one specify contact list i - th employee j - th character i - th string equal 1 j - th employee i - th employee 's contact list otherwise n't guarantee i - th character i - th line always equal 1 . last line contain n space - separated integers : a1 a2 ... ( 0 ≤ ai ≤ n ) ai represent number message i - th employee get accord igor first line print a single integer m — number employees come party igor lose dispute second line print m space - separated integers — number employees arbitrary order igor win dispute case print -1 . multiple possible solutions print first sample igor suppose first employee receive 0 message since n't contain contact list must come party order receive one message come party receive 1 message second employee receive 0 message third also receive 1 message <unknown> igor wo n't guess number second sample single employee come party receive 1 message igor win n't third sample first employee receive 2 message second — 3 third — 2 fourth — 3",['greedy'],2300.0
240/E,a country name berland n cities number integers 1 n. city index 1 capital country pair cities <unknown> roads build however good condition road know whether need repair a road need repair forbid use however berland government repair road use right berland threaten war neighbour state capital <unknown> decide send a military squad city squads move along exist roads 's time money build new roads however roads probably repair order get cities course country need much resources defeat enemy want careful 're go throw force 's berland government want repair minimum number roads enough military <unknown> get city capital drive along good repair roads task help berland government find roads need repair first line contain two space - separated integers n m ( 1 ≤ n m ≤ 105 ) — number cities number roads berland next m line contain three space - separated integers ai bi ci ( 1 ≤ ai bi ≤ n ai ≠ bi 0 ≤ ci ≤ 1 ) describe road city ai city bi ci equal 0 give road a good condition ci equal 1 need repair guarantee one road cities direction even roads repair still impossible get city capital print - 1 . otherwise first line print minimum number roads need repair second line print number roads separate single space roads number start 1 order give input multiple set consist minimum number roads repair make travel city capital possible print possible reach city drive along roads already a good condition print 0 output line,['greedy'],2800.0
274/D,"lenny n × m matrix positive integers love matrix much row matrix sort non - decreasing order reason call <unknown> integers lovely one day lenny school little brother play lenny 's matrix room erase entries matrix change order columns lenny get back home upset lenny want recover matrix help find order columns matrix 's possible fill erase entries matrix achieve a lovely matrix note fill erase entries matrix integers first line input contain two positive integers n m ( 1 ≤ n·m ≤ 105 ) next n line contain m space - separated integers represent matrix integer -1 show erase entry matrix integers ( 0 109 inclusive ) represent fill entries exist possible reorder columns print -1 . otherwise output contain m integers p1 p2 ... pm show seek permutation columns , first column lovely matrix p1 - th column initial matrix second column lovely matrix p2 - th column initial matrix",['greedy'],2200.0
290/F,petya <unknown> program contestant recently come across follow problem : give a non - directed graph consist n nod m edge task determine whether graph contain a hamiltonian path petya write a <unknown> bug - free code believe solve problem petya decide give problem april fool day contest unfortunately petya might make a mistake 's quite possible algorithm wrong n't a good <unknown> leave contest without submit problem ? first line contain two integers n m ( 1 ≤ n ≤ 20 ; 0 ≤ m ≤ 400 ) next m line contain pair integers vi ui ( 1 ≤ vi ui ≤ n ) follow format petya 's code output,['greedy'],2800.0
321/C,fox ciel become a commander tree land tree land like name say n cities connect n - 1 undirected roads two cities always exist a path fox ciel need assign officer city officer a rank — a letter ' a ' ' z ' 26 different rank ' a ' <unknown> ' z ' bottommost enough officer rank a special rule must obey : x y two distinct cities officer rank simple path x y must a city z officer higher rank rule guarantee a <unknown> rank officer monitor higher rank officer help ciel make a valid plan 's impossible output ` ` impossible ! ` ` first line contain integer n ( 2 ≤ n ≤ 105 ) — number cities tree land follow n - 1 line contain two integers a b ( 1 ≤ a b ≤ n a ≠ b ) — mean undirected road a b. consider cities number 1 n. guarantee give graph a tree a valid plane output n space - separated character a line — i - th character rank officer city number i. otherwise output ` ` impossible ! ` ` first example two officer rank ' b ' officer rank ' a ' path a valid solution,['greedy'],2100.0
325/E,piegirl find red button one last chance change <unknown> end circuit button consist n nod number 0 n - 1 . order deactivate button n nod must disarm a particular order node 0 must disarm first disarm node i next node disarm must either node ( 2·i ) modulo n node ( 2·i ) + 1 modulo n. last node disarm must node 0 . node 0 must disarm twice nod must disarm exactly task find order print order print -1 . input consist a single integer n ( 2 ≤ n ≤ 105 ) print order disarm nod impossible print -1 instead multiple order print one,['greedy'],2800.0
339/E,xenia horse <unknown> n ( n > 1 ) horse stand a row horse unique number initially i - th leave horse number i. sequence number horse a row look follow ( leave right ) : 1 2 3 ... n. xenia train horse performance practice sessions consistently give command command a pair number l r ( 1 ≤ l < r ≤ n ) command l r mean horse l - th ( l + 1 ) -th ( l + 2 ) -th ... r - th place leave must rearrange horse initially stand l - th r - th place swap horse ( l + 1 ) -th ( r - 1 ) -th place swap horse ( l + 2 ) -th ( r - 2 ) -th place swap word horse segment [ l r ] change order reverse one example xenia command l = 2 r = 5 sequence number horse command look ( 2 1 3 4 5 6 ) command sequence ( 2 5 4 3 1 6 ) know practice xenia give three command describe form get final sequence number horse end practice find command xenia give practice note need minimize number command solution find valid sequence three command first line contain integer n ( 2 ≤ n ≤ 1000 ) — number horse row second line contain n distinct integers a1 a2 ... ( 1 ≤ ai ≤ n ) ai number i - th leave horse row practice first line contain integer k ( 0 ≤ k ≤ 3 ) — number <unknown> xenia give practice next k line print two integers i - th line print number li ri ( 1 ≤ li < ri ≤ n ) — xenia 's i - th command practice guarantee a solution exist several solutions allow print,['greedy'],2700.0
242/D,"valera n counter number 1 n. connect wire counter a special button initially counter contain number 0 . press a button a certain counter value increase one also value record counter directly connect a wire increase one valera ignat start a dispute dispute follow ignat think a sequence n integers a1 a2 ... , valera choose set distinct counter press button exactly ( counter button wo n't press ) a counter number i value ai valera lose dispute otherwise win dispute help valera determine counter need press a button win dispute first line contain two space - separated integers n m ( 1 ≤ n m ≤ 105 ) denote number counter valera number pair counter connect wire follow m line contain two space - separated integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) mean counter number ui vi connect a wire guarantee pair connect counter occur exactly input last line contain n space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 105 ) ai value ignat choose i - th counter valera ca n't win dispute print first line -1 . otherwise print first line integer k ( 0 ≤ k ≤ n ) second line print k distinct space - separated integers — number counter valera push button win dispute arbitrary order exist multiple answer allow print",['greedy'],2100.0
343/E,mad scientist mike apply a job task manage a system water pump station system consist n pump station number integers 1 n. pair station connect bidirectional pip water flow either direction ( one a time ) pipe know bandwidth — maximum number liters water flow one hour pump station pump incoming water station station pip provide one hour total <unknown> water station equal total <unknown> water station mike 's responsibility pump water station station a station b pip ( possibly station ) within one hour one transmit a certain number liters water accord rule describe time water station flow station a flow station b. however amount water flow station a station b. a total x <unknown> water flow station a hour mike get x bollars salary get pay mike need work n - 1 days accord contract first day select two station v1 v2 within one hour pump a certain amount water v1 v2 next i - th day mike choose a station vi + 1 never select pump a certain amount water station vi station vi + 1 one hour quantity water pump i - th day depend amount water pump ( i - 1 ) -th day mike need earn much bollars project help mike find a permutation station number v1 v2 ... vn mike able earn highest possible salary first line input contain two space - separated integers n m ( 2 ≤ n ≤ 200 1 ≤ m ≤ 1000 ) — number station pip system accordingly i - th next m line contain three space - separated integers ai bi ci ( 1 ≤ ai bi ≤ n ai ≠ bi 1 ≤ ci ≤ 100 ) — number station connect i - th pipe pipe 's bandwidth accordingly guarantee two station connect one pipe a pipe path two station first line print a single integer — maximum salary mike earn second line print a space - separated permutation n number 1 n — number station sequence v1 v2 ... vn multiple answer print,['greedy'],2900.0
1627/B,rahul tina look forward start new year college enter new classroom observe seat students arrange a $$$ n \times m $$$ grid seat row $$$ r $$$ column $$$ c $$$ denote $$$ ( r c ) $$$ distance two seat $$$ ( a b ) $$$ $$$ ( c d ) $$$ $$$ |a - <unknown> + <unknown> - <unknown> $$$ class president tina access exactly $$$ k $$$ bucket pink paint follow process occur rahul want choose a seat sit close tina possible however tina want sit far away rahul possible due complicate relationship history could n't fit statement ! rahul wonder $$$ k = 0 1 \dots n \cdot m - 1 $$$ tina $$$ k $$$ bucket paint close rahul sit tina rahul tina aware 's <unknown> act strategically possible ? please help satisfy rahul 's curiosity ! input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 50000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \cdot m \leq 100000 $$$ ) — number row columns seat classroom sum $$$ n \cdot m $$$ across test case exceed $$$ 100000 $$$ test case output $$$ n \cdot m $$$ order integers — distance rahul tina act optimally every $$$ k \in [ 0 n \cdot m - 1 ] $$$ one possible sequence choices first testcase tina $$$ k=3 $$$ bucket paint follow tina paint seat position $$$ ( 1 2 ) $$$ $$$ ( 2 2 ) $$$ $$$ ( 3 2 ) $$$ pink paint rahul choose seat $$$ ( 3 1 ) $$$ tina choose sit $$$ ( 1 3 ) $$$ therefore distance tina rahul $$$ |3 - 1| + |1 - 3| = 4 $$$ prove indeed minimum possible distance give constraints may choices seat lead answer well $$$ k=0 $$$ first test case rahul decide sit $$$ ( 2 2 ) $$$ tina decide sit $$$ ( 4 3 ) $$$ distance would $$$ |2 - <unknown> + |2 - 3| = 3 $$$ <unknown> representations $$$ k=3 $$$ $$$ k=0 $$$ case first test case,['greedy'],1300.0
1600/E,alice bob play a game give array $$$ a $$$ length $$$ n $$$ array consist integers build a sequence together begin sequence empty one turn a player remove a number leave right side array append sequence rule sequence build must strictly increase winner player make last move alice play first give start array <unknown> play optimally win game ? first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 2 * 100000 $$$ ) - length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) first line output consist one string name winner alice print ` ` alice '' otherwise print ` ` bob '',['greedy'],1900.0
1673/A,alice bob play a game string $$$ t $$$ round game round a string $$$ s $$$ consist lowercase english letter alice move first players take alternate turn alice allow remove substring even length ( possibly empty ) bob allow remove substring odd length $$$ s $$$ formally a string $$$ s = <unknown> \ldots s_k $$$ player choose a substring $$$ s_ls _ { l+1 } \ldots s _ { r-1 } s_r $$$ length correspond <unknown> remove string become $$$ s = s_1 \ldots s _ { <unknown> } s _ { <unknown> } \ldots s_k $$$ string become empty round end player calculate his / her score round score a player sum value character remove him / her value $$$ \texttt { a } $$$ $$$ 1 $$$ value $$$ \texttt { b } $$$ $$$ 2 $$$ value $$$ \texttt { c } $$$ $$$ 3 $$$ $$$ \ldots $$$ value $$$ \texttt { z } $$$ $$$ 26 $$$ player higher score win round round determine winner difference winner 's loser 's score assume players play optimally maximize score prove a draw impossible first line input contain a single integer $$$ t $$$ ( $$$ 1\leq t\leq 5\cdot 10000 $$$ ) denote number round next $$$ t $$$ line contain a single string $$$ s $$$ ( $$$ 1\leq |s|\leq 2\cdot 100000 $$$ ) consist lowercase english letter denote string use round $$$ |s| $$$ denote length string $$$ s $$$ guarantee sum $$$ |s| $$$ round exceed $$$ 2\cdot 100000 $$$ round print a single line contain a string integer alice win round string must ` ` alice '' bob win round string must ` ` bob '' integer must difference score assume players play optimally first round $$$ \texttt { ` ` aba '' } \xrightarrow { \texttt { alice } } \texttt { ` ` } { \color { red } { \texttt { ab } } } \texttt { a '' } \xrightarrow { } \texttt { ` ` a '' } \xrightarrow { \texttt { bob } } \texttt { ` ` } { \color { red } { \texttt { a } } } \texttt { ` ` } \xrightarrow { } \texttt { ` ` '' } $$$ alice 's total score $$$ 1 + 2=3 $$$ bob 's total score $$$ 1 $$$ second round $$$ \texttt { ` ` abc '' } \xrightarrow { \texttt { alice } } \texttt { ` ` a } { \color { red } { \texttt { <unknown> } } } \texttt { ` ` } \xrightarrow { } \texttt { ` ` a '' } \xrightarrow { \texttt { bob } } \texttt { ` ` } { \color { red } { \texttt { a } } } \texttt { ` ` } \xrightarrow { } \texttt { ` ` '' } $$$ alice 's total score $$$ 2 + <unknown> $$$ bob 's total score $$$ 1 $$$ third round $$$ \texttt { ` ` cba '' } \xrightarrow { \texttt { alice } } \texttt { ` ` } { \color { red } { \texttt { cb } } } \texttt { a '' } \xrightarrow { } \texttt { ` ` a '' } \xrightarrow { \texttt { bob } } \texttt { ` ` } { \color { red } { \texttt { a } } } \texttt { ` ` } \xrightarrow { } \texttt { ` ` '' } $$$ alice 's total score $$$ 3 + 2=5 $$$ bob 's total score $$$ 1 $$$ fourth round $$$ \texttt { ` ` n '' } \xrightarrow { \texttt { alice } } \texttt { ` ` n '' } \xrightarrow { } \texttt { ` ` n '' } \xrightarrow { \texttt { bob } } \texttt { ` ` } { \color { red } { \texttt { n } } } \texttt { ` ` } \xrightarrow { } \texttt { ` ` '' } $$$ alice 's total score $$$ 0 $$$ bob 's total score $$$ 14 $$$ fifth round $$$ \texttt { ` ` codeforces '' } \xrightarrow { \texttt { alice } } \texttt { ` ` } { \color { red } { \texttt { codeforces } } } \texttt { ` ` } \xrightarrow { } \texttt { ` ` '' } $$$ alice 's total score $$$ 3 + 15 + 4 + 5 + 6 + 15 + 18 + 3 + 5 + <unknown> $$$ bob 's total score $$$ 0 $$$,['greedy'],800.0
1817/E,'re give a multiset non - negative integers $$$ \ { a_1 a_2 \dots <unknown> } $$$ one step take two elements $$$ x $$$ $$$ y $$$ multiset remove insert mean value $$$ \frac { x + y } { 2 } $$$ back multiset repeat step describe leave two number $$$ a $$$ $$$ b $$$ maximum possible value absolute difference $$$ |a - b| $$$ ? since answer integer number output modulo $$$ 1000000000 + 7 $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 1000000 $$$ ) — size multiset second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — elements multiset guarantee sum $$$ n $$$ test case exceed $$$ 1000000 $$$ test case output a single integer answer problem modulo $$$ 1000000000 + 7 $$$ formally let $$$ m = 1000000000 + 7 $$$ show answer express irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \not \equiv 0 \pmod { m } $$$ output integer equal $$$ p \cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \le x < m $$$ $$$ x \cdot q \equiv p \pmod { m } $$$ first case ca n't operations answer $$$ <unknown> - <unknown> $$$ second case one optimal sequence operations : third case exact answer $$$ \frac { 3 } { 2 } $$$ $$$ <unknown> \cdot 2 \equiv 3 \pmod { 1000000000 + 7 } $$$,['greedy'],3400.0
1583/E,"utmost <unknown> carry a person 's last <unknown> preserve world 's balance <unknown> yang hu <unknown> little <unknown> try scare graph problem ! give a connect undirected graph $$$ n $$$ nod $$$ m $$$ edge also $$$ q $$$ query query consist two nod $$$ a $$$ $$$ b $$$ initially edge graph a weight $$$ 0 $$$ query must choose a simple path start $$$ a $$$ end $$$ b $$$ add $$$ 1 $$$ every edge along path determine 's possible process $$$ q $$$ query edge graph even weight , output choice paths query possible determine smallest number extra query could add make possible show number exceed $$$ 10^ { 18 } $$$ give constraints a simple path define path visit a node edge say even weight value divisible $$$ 2 $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 300000 $$$ $$$ n-1 \leq m \leq \min { \left ( \frac { n ( n-1 ) } { 2 } 3 \cdot <unknown> ) } $$$ ) next $$$ m $$$ line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq x y \leq n $$$ $$$ <unknown> y $$$ ) indicate undirected edge node $$$ x $$$ $$$ y $$$ input contain self - loops duplicate edge provide graph connect next line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 300000 $$$ ) next $$$ q $$$ line contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \leq a b \leq n a \neq b $$$ ) description query guarantee $$$ <unknown> \leq 300000 $$$ possible force edge weight even print ` ` yes '' first line follow $$$ <unknown> $$$ line indicate choice path query order query give query first line contain a single integer $$$ x $$$ : number nod choose path next line contain $$$ x $$$ space separate integers $$$ p_i $$$ indicate path take ( $$$ p_1 = a p_x = b $$$ number fall $$$ 1 $$$ $$$ n $$$ ) path contain duplicate nod must a valid simple path graph impossible force edge weight even print ` ` '' first line minimum number add query second line query look like first test case ( red correspond 1st query blue 2nd query green 3rd query ) : graph second test case look like :",['greedy'],2200.0
1611/E1,difference e2 question problem .. vlad build a maze $$$ n $$$ room $$$ n-1 $$$ bidirectional corridors room $$$ u $$$ room $$$ v $$$ reach a sequence corridors thus room system form undirected tree vlad invite $$$ k $$$ friends play a game vlad start game room $$$ 1 $$$ win reach a room $$$ 1 $$$ exactly one corridor lead friends place maze : friend number $$$ i $$$ room $$$ x_i $$$ two friends room ( $$$ x_i \neq x_j $$$ $$$ i \neq j $$$ ) friends win one meet vlad room corridor win one unit time participant game go one corridor participants move time participants may move room fit participants time friends know plan a maze intend win vlad a bite afraid <unknown> determine guarantee victory ( i.e win way friends play ) word determine a sequence vlad 's move let vlad win way friends play first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case input input contain empty string test case first line test case contain two number $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k < n \le 2\cdot 100000 $$$ ) — number room friends respectively next line test case contain $$$ k $$$ integers $$$ x_1 x_2 \dots <unknown> $$$ ( $$$ 2 \le x_i \le n $$$ ) — number room friends $$$ x_i $$$ different next $$$ n-1 $$$ line contain descriptions corridors two number per line $$$ v_j $$$ $$$ u_j $$$ ( $$$ 1 \le u_j v_j \le n $$$ ) — number room connect $$$ j $$$ corridor corridors bidirectional room go move along corridors guarantee sum value $$$ n $$$ test case test greater $$$ 2\cdot100000 $$$ print $$$ t $$$ line line contain answer correspond test case answer a test case ` ` yes '' vlad guarantee a victory ` ` '' otherwise may print every letter case want ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive answer ) first test case regardless strategy friends vlad win go room $$$ 4 $$$ game may look like : note vlad try reach exit room $$$ 8 $$$ a friend $$$ 3 $$$ room able catch,['greedy'],1700.0
1619/G,"polycarp fond play game <unknown> recently find a similar game rule mine field coordinate location know ( $$$ x_i y_i $$$ ) mine a <unknown> second explode explosion mine also detonate mine vertically horizontally a distance $$$ k $$$ ( two perpendicular line ) a result get explosion field form a ` ` plus '' symbol ( ' + ' ) thus one explosion cause new explosions , also polycarp detonate anyone mine every second start zero second , a chain reaction explosions also take place mine explode instantly also instantly detonate mine accord rule describe polycarp want set a new record ask help calculate minimum number second mine detonate first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test empty line write front test <unknown> next come a line contain integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 0 \le k \le 1000000000 $$$ ) — number mine distance hit mine explosion respectively $$$ n $$$ line follow $$$ i $$$ -th describe $$$ x $$$ $$$ y $$$ coordinate $$$ i $$$ -th mine time explosion ( $$$ -1000000000 \le x y \le 1000000000 $$$ $$$ 0 \le <unknown> \le 1000000000 $$$ ) guarantee mine different coordinate guarantee sum value $$$ n $$$ test case test exceed $$$ 200000 $$$ print $$$ t $$$ line line must contain answer correspond set input data — minimum number second take explode mine first example : second example :",['greedy'],2000.0
1626/E,give a tree consist $$$ n $$$ vertices vertices ( least two ) black vertices white place a chip one vertices tree perform follow operations : allow choose black vertex $$$ y $$$ two operations a row ( i. e. every two consecutive operations choose black vertex different ) end operations chip move black vertex ( initially place a black vertex n't perform operations ) number perform operations exceed $$$ <unknown> { 500 } $$$ every vertex $$$ i $$$ determine exist a ( possibly empty ) sequence operations move chip black vertex chip initially place vertex $$$ i $$$ first line contain one integer $$$ n $$$ ( $$$ 3 \le n \le 300000 $$$ ) — number vertices tree second line contain $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 0 \le c_i \le 1 $$$ ) $$$ c_i = 0 $$$ mean $$$ i $$$ -th vertex white $$$ c_i = 1 $$$ mean $$$ i $$$ -th vertex black least two value $$$ c_i $$$ equal $$$ 1 $$$ $$$ n-1 $$$ line follow contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ; $$$ u_i \ne v_i $$$ ) — endpoints edge edge form a tree print $$$ n $$$ integers $$$ i $$$ -th integer equal $$$ 1 $$$ exist a ( possibly empty ) sequence operations move chip black vertex place vertex $$$ i $$$ $$$ 0 $$$ sequence operations exist,['greedy'],2400.0
1635/E,$$$ n $$$ cars a coordinate axis $$$ ox $$$ car locate integer point initially two cars locate point also car orient either leave right move constant positive speed direction moment formally describe $$$ i $$$ -th car a letter integer : orientation $$$ ori_i $$$ location $$$ x_i $$$ $$$ ori_i = l $$$ $$$ x_i $$$ decrease a constant rate respect time similarly $$$ ori_i = r $$$ $$$ x_i $$$ increase a constant rate respect time call two cars irrelevant never end point regardless speed word wo n't share coordinate moment call two cars destine always end point regardless speed word must share coordinate moment unfortunately lose information cars remember $$$ m $$$ relationships two type relationships : $$$ 1 $$$ $$$ i $$$ $$$ j $$$ — $$$ i $$$ -th car $$$ j $$$ -th car irrelevant $$$ 2 $$$ $$$ i $$$ $$$ j $$$ — $$$ i $$$ -th car $$$ j $$$ -th car destine restore orientations locations cars satisfy relationships report impossible multiple solutions output note two cars share coordinate intersect moment continue movement directions first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 2 \leq n \leq 2 \cdot 100000 ; 1 \leq m \leq min ( 2 \cdot 100000 \frac { n ( n-1 ) } { 2 } ) $$$ — number cars number restrictions respectively next $$$ m $$$ line contain three integers $$$ type $$$ $$$ i $$$ $$$ j $$$ $$$ ( 1 \leq type \leq 2 ; 1 \leq i j \leq n ; <unknown> ) $$$ $$$ type $$$ = $$$ 1 $$$ $$$ i $$$ -th car $$$ j $$$ -th car irrelevant otherwise $$$ i $$$ -th car $$$ j $$$ -th car destine guarantee pair cars $$$ 1 $$$ relationship first line print either ` ` yes '' ` ` '' ( case ) whether possible restore orientations locations cars satisfy relationships answer ` ` yes '' print $$$ n $$$ line contain a symbol integer : $$$ ori_i $$$ $$$ x_i $$$ $$$ ( ori_i \in \ { l <unknown> } ; -1000000000 \leq x_i \leq 1000000000 ) $$$ — represent information $$$ i $$$ -th car orientation leave $$$ ori_i $$$ = $$$ l $$$ otherwise $$$ ori_i $$$ = $$$ r $$$ $$$ x_i $$$ $$$ i $$$ -th car locate note $$$ x_i $$$ distinct prove exist a solution must a solution satisfy constraints $$$ x_i $$$,['greedy'],2200.0
1740/C,"$$$ n $$$ bricks number $$$ 1 $$$ $$$ n $$$ brick $$$ i $$$ a weight $$$ a_i $$$ pak chanek $$$ 3 $$$ bag number $$$ 1 $$$ $$$ 3 $$$ initially empty brick pak chanek must put one bag , bag must contain least one brick pak chanek distribute bricks bu dengklek take exactly one brick bag let $$$ w_j $$$ weight brick bu dengklek take bag $$$ j $$$ score calculate $$$ <unknown> - <unknown> + <unknown> - <unknown> $$$ $$$ |x| $$$ denote absolute value $$$ x $$$ know bu dengklek take bricks a way minimise score maximum possible final score pak chanek distribute bricks optimally ? test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 20000 $$$ ) — number test case follow line contain description test case first line test case contain integer $$$ n $$$ ( $$$ 3 \leq n \leq 200000 $$$ ) — number bricks second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — weight bricks guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a line contain integer represent maximum possible final score pak chanek distribute bricks optimally first test case one way achieve a final score $$$ 6 $$$ follow : pak chanek distribute bricks way a way bu dengklek take bricks : score $$$ <unknown> - <unknown> + <unknown> - <unknown> = |3 - 5| + <unknown> - 1| = 6 $$$ show bu dengklek get a smaller score distribution show distribution result a final score bigger $$$ 6 $$$",['greedy'],1400.0
1559/D2,hard version problem difference two versions constraint $$$ n $$$ make hack versions problem solve a forest undirected graph without cycle ( necessarily connect ) mocha diana friends <unknown> a forest nod number $$$ 1 $$$ $$$ n $$$ would like add edge forest : mocha diana want know maximum number edge add edge add first line contain three integers $$$ n $$$ $$$ m_1 $$$ $$$ m_2 $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 0 \le m_1 m_2 < n $$$ ) — number nod number initial edge mocha 's forest diana 's forest next $$$ m_1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ ) — edge mocha 's forest next $$$ m_2 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ ) — edge diana 's forest first line contain one integer $$$ h $$$ maximum number edge mocha diana add next $$$ h $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ ) — edge add time multiple correct answer print one first example add edge second example initial forest follow add edge $$$ ( 2 4 ) $$$,['greedy'],2500.0
1391/E,"a simple connect undirected graph consist $$$ n $$$ nod $$$ m $$$ edge consider way pair subset $$$ n $$$ nod node present one pair pair valid every pair pair induce subgraph contain $$$ 4 $$$ nod two pair $$$ 2 $$$ edge ( $$$ 6 $$$ possible edge ) formally two pair $$$ ( a b ) $$$ $$$ ( c d ) $$$ induce subgraph nod $$$ \ { a b c <unknown> } $$$ $$$ 2 $$$ edge please note subgraph induce a set nod contain nod set edge end point set , one follow : show possible find least one two every graph satisfy constraints statement test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow first line test case contain $$$ 2 $$$ integers $$$ n m $$$ ( $$$ 2 \le n \le 5\cdot 100000 $$$ $$$ 1 \le m \le 1000000 $$$ ) denote number nod edge respectively next $$$ m $$$ line contain $$$ 2 $$$ integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ ) denote undirected edge nod $$$ u $$$ $$$ v $$$ give graph guarantee give graph connect simple — contain multiple edge pair nod self - loops guarantee sum $$$ n $$$ test case exceed $$$ 5\cdot 100000 $$$ guarantee sum $$$ m $$$ test case exceed $$$ 1000000 $$$ test case output format follow find a pair first line output ` ` pair '' ( without quote ) otherwise first line output ` ` path '' ( without quote ) path output first case follow pair output second case follow invalid pair graph — subgraph $$$ \ { <unknown> } $$$ $$$ 3 $$$ edge pair output third case 's valid — pair output fourth case",['greedy'],2600.0
1399/E2,easy hard versions actually different problems advise read statements carefully give a weight root tree vertex $$$ 1 $$$ root tree also edge cost a tree a connect graph without cycle a root tree a special vertex call root a parent a vertex $$$ v $$$ last different $$$ v $$$ vertex path root vertex $$$ v $$$ children vertex $$$ v $$$ vertices $$$ v $$$ parent a vertex a leaf children weight tree a tree edge tree weight weight path sum edge weight path weight path vertex $$$ 0 $$$ make a sequence zero move move select edge divide weight $$$ 2 $$$ round formally one move choose edge $$$ i $$$ divide weight $$$ 2 $$$ round ( $$$ w_i : = <unknown> { w_i } { 2 } \right\rfloor $$$ ) edge $$$ i $$$ associate cost $$$ c_i $$$ either $$$ 1 $$$ $$$ 2 $$$ coin move edge $$$ i $$$ cost $$$ c_i $$$ coin task find minimum total cost make sum weight paths root leaf $$$ s $$$ word $$$ w ( i j ) $$$ weight path vertex $$$ i $$$ vertex $$$ j $$$ make $$$ \sum\limits _ { v \in leave } w ( root v ) \le s $$$ $$$ leave $$$ list leave answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ s $$$ ( $$$ 2 \le n \le 100000 ; 1 \le s \le 10^ { 16 } $$$ ) — number vertices tree maximum possible sum weight obtain next $$$ n-1 $$$ line describe edge tree edge $$$ i $$$ describe four integers $$$ v_i $$$ $$$ u_i $$$ $$$ w_i $$$ $$$ c_i $$$ ( $$$ 1 \le v_i u_i \le n ; 1 \le w_i \le 1000000 ; 1 \le c_i \le 2 $$$ ) $$$ v_i $$$ $$$ u_i $$$ vertices edge $$$ i $$$ connect $$$ w_i $$$ weight edge $$$ c_i $$$ cost edge guarantee sum $$$ n $$$ exceed $$$ 100000 $$$ ( $$$ \sum n \le 100000 $$$ ) test case print answer : minimum total cost require make sum weight paths root leaf $$$ s $$$,['greedy'],2200.0
1436/D,<unknown> appear city ! one try catch many citizens city consist $$$ n $$$ square connect $$$ n-1 $$$ roads a way possible reach square square square number $$$ 1 $$$ main square sunday walk roads change one - way roads a way possible reach square main square moment bandit appear main square $$$ a_i $$$ citizens $$$ i $$$ -th square follow process begin first citizen currently a square outgo one - way roads choose one roads move along another square bandit choose one one - way roads outgo square locate move along process repeat bandit locate a square outgo roads bandit catch citizens square bandit want catch many citizens possible ; citizens want minimize number catch people bandit citizens know position citizens time citizens cooperate side act optimally many citizens catch ? first line contain a single integer $$$ n $$$ — number square city ( $$$ 2 \le n \le 2\cdot100000 $$$ ) second line contain $$$ n-1 $$$ integers $$$ p_2 p_3 \dots p_n $$$ mean a one - way road square $$$ p_i $$$ square $$$ i $$$ ( $$$ 1 \le p_i < i $$$ ) third line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ — number citizens square initially ( $$$ 0 \le a_i \le 1000000000 $$$ ) print a single integer — number citizens bandit catch side act optimally first example citizens square $$$ 1 $$$ split two group $$$ 2 + 1 $$$ second third square $$$ 3 $$$ citizens second example matter citizens act bandit catch least $$$ 4 $$$ citizens,['greedy'],1900.0
1442/C,"give a direct graph $$$ n $$$ vertices $$$ m $$$ edge vertices number $$$ 1 $$$ $$$ n $$$ a token vertex $$$ 1 $$$ follow action allow : goal move token vertex $$$ 1 $$$ vertex $$$ n $$$ shortest possible time print time modulo $$$ 998\,244\,353 $$$ first line input contain two integers $$$ n m $$$ ( $$$ 1 \le n m \le 200\,000 $$$ ) next $$$ m $$$ line contain two integers : $$$ u v $$$ ( $$$ 1 \le u v \le n ; u \ne v $$$ ) represent edge graph guarantee order pair $$$ ( u v ) $$$ distinct guarantee possible move token vertex $$$ 1 $$$ vertex $$$ n $$$ use action print one integer : minimum require time modulo $$$ 998\,244\,353 $$$ first example solve transpose graph move token vertex $$$ 4 $$$ take $$$ 2 $$$ second best way solve second example follow : transpose graph move token vertex $$$ 2 $$$ transpose graph move token vertex $$$ 3 $$$ transpose graph move token vertex $$$ 4 $$$",['greedy'],2400.0
1470/D,students winter informatics school go live a set house connect underground passages teachers also go live house accommodate randomly safety reason follow must hold : please help organizers choose house teachers live satisfy safety requirements determine impossible first input line contain a single integer $$$ t $$$ — number test case ( $$$ 1 \le t \le 100000 $$$ ) test case start two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 300000 $$$ $$$ 0 \le m \le 300000 $$$ ) — number house number passages $$$ m $$$ line follow contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ ) describe a passage house $$$ u $$$ $$$ v $$$ guarantee two passages connect pair house sum value $$$ n $$$ test case exceed $$$ 300000 $$$ sum value $$$ m $$$ test case exceed $$$ 300000 $$$ test case way choose desire set house output ` ` '' otherwise output ` ` yes '' total number house choose indices choose house arbitrary order picture show second example test,['greedy'],2200.0
1515/F,"phoenix 's <unknown> fire nation $$$ n $$$ cities connect $$$ m $$$ roads roads destroy earthquake fire nation wish repair $$$ n-1 $$$ roads cities connect $$$ i $$$ -th city $$$ a_i $$$ tons asphalt $$$ x $$$ tons asphalt use repair a road repair a road $$$ i $$$ $$$ j $$$ cities $$$ i $$$ $$$ j $$$ must least $$$ x $$$ tons asphalt word city $$$ i $$$ $$$ a_i $$$ tons asphalt city $$$ j $$$ $$$ a_j $$$ tons would remain $$$ <unknown> - x $$$ tons repair road asphalt move cities road already repair please determine possible connect cities , output sequence roads repair first line contain integers $$$ n $$$ $$$ m $$$ $$$ x $$$ ( $$$ 2 \le n \le 300000 $$$ ; $$$ n-1 \le m \le 300000 $$$ ; $$$ 1 \le x \le 1000000000 $$$ ) — number cities number roads amount asphalt need repair one road next line contain $$$ n $$$ space - separated integer $$$ a_i $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — amount asphalt initially city $$$ i $$$ next $$$ m $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ <unknown> y_i $$$ ; $$$ 1 \le x_i y_i \le n $$$ ) — cities connect $$$ i $$$ -th road guarantee one road pair cities city originally connect earthquake possible connect cities print otherwise print yes follow $$$ n-1 $$$ integers $$$ e_1 e_2 \dots e _ { n-1 } $$$ order roads repair $$$ e_i $$$ index $$$ i $$$ -th road repair multiple solutions print first example roads repair follow order : second example cities $$$ 1 $$$ $$$ 2 $$$ use asphalt together build road $$$ 1 $$$ <unknown> together $$$ 2 $$$ tons enough third example n't enough asphalt connect cities $$$ 1 $$$ $$$ 2 $$$",['greedy'],2600.0
1534/F1,"easy version problem difference versions constraints $$$ a_i $$$ make hack versions problem solve little dormi recently receive a puzzle friend need help solve puzzle consist <unknown> board $$$ n $$$ row $$$ m $$$ columns cells empty fill block sand $$$ m $$$ non - negative integers $$$ a_1 a_2 \ldots a_m $$$ ( $$$ 0 \leq a_i \leq n $$$ ) version problem $$$ a_i $$$ equal number block sand column $$$ i $$$ a cell fill a block sand disturb block sand fall cell sand counter bottom column ( column a sand counter ) a block sand fall block sand adjacent point fall block sand also disturb start fall specifically a block sand disturb a cell $$$ ( i j ) $$$ pass cells include cell $$$ ( i j ) $$$ within column disturb adjacent cells along way , cells adjacent a cell $$$ ( i j ) $$$ define $$$ ( i-1 j ) $$$ $$$ ( i <unknown> ) $$$ $$$ ( i+1 j ) $$$ $$$ ( i <unknown> ) $$$ ( within grid ) note newly fall block disturb block one operation able disturb piece sand puzzle solve least $$$ a_i $$$ block sand count $$$ i $$$ -th sand counter column $$$ 1 $$$ $$$ m $$$ task find minimum amount operations order solve puzzle note little dormi never give a puzzle impossible solve first line consist two space - separated positive integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \cdot m \leq <unknown> $$$ ) next $$$ n $$$ line contain $$$ m $$$ character describe row board a character a line ' ' correspond cell empty ' # ' cell contain a block sand final line contain $$$ m $$$ non - negative integers $$$ a_1 a_2 \ldots a_m $$$ ( $$$ 0 \leq a_i \leq n $$$ ) — minimum amount block sand need fall board column version problem $$$ a_i $$$ equal number block sand column $$$ i $$$ print one non - negative integer minimum amount operations need solve puzzle example $$$ 1 $$$ disturb block sand first row top first sixth columns leave block sand second row top fourth column leave possible require amount sand fall column prove possible fewer $$$ 3 $$$ operations answer $$$ 3 $$$ puzzle first example example $$$ 2 $$$ disturb cell top row rightmost column one cause block sand board fall counter bottom thus answer $$$ 1 $$$ puzzle second example",['greedy'],2500.0
1677/C,tokitsukaze two colorful tap $$$ n $$$ distinct color number $$$ 1 $$$ $$$ n $$$ color appear exactly two tap denote color $$$ i $$$ -th position first tape $$$ ca_i $$$ color $$$ i $$$ -th position second tape $$$ cb_i $$$ tokitsukaze want select color integer value $$$ 1 $$$ $$$ n $$$ distinct color put color value color position tap denote number $$$ i $$$ -th position first tape $$$ <unknown> $$$ number $$$ i $$$ -th position second tape $$$ <unknown> $$$ example picture assume color red value $$$ x $$$ ( $$$ 1 \leq x \leq n $$$ ) appear $$$ 1 $$$ -st position first tape $$$ 3 $$$ -rd position second tape $$$ <unknown> = <unknown> = x $$$ note color $$$ i $$$ $$$ 1 $$$ $$$ n $$$ a distinct value color appear tap value label color beauty two tap calculate $$$ $$$ \sum _ { i=1 } ^ { n } <unknown> - <unknown> $$$ $$$ please help tokitsukaze find highest possible beauty first contain a single positive integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case test case first line contain a single integer $$$ n $$$ ( $$$ 1\leq n \leq 100000 $$$ ) — number color second line contain $$$ n $$$ integers $$$ <unknown> <unknown> \ldots <unknown> $$$ ( $$$ 1 \leq ca_i \leq n $$$ ) — color position first tape guarantee $$$ ca $$$ a permutation third line contain $$$ n $$$ integers $$$ <unknown> <unknown> \ldots <unknown> $$$ ( $$$ 1 \leq cb_i \leq n $$$ ) — color position second tape guarantee $$$ cb $$$ a permutation guarantee sum $$$ n $$$ test case exceed $$$ 2 \cdot 10^ { 5 } $$$ test case print a single integer — highest possible beauty optimal solution first test case show follow figure : beauty $$$ <unknown> - 3 \right|+\left|3 - 5 <unknown> - 4 \right|+\left|5 - 2 \right|+\left|1 - 6 \right|+\left|6 - 1 <unknown> $$$ optimal solution second test case show follow figure : beauty $$$ <unknown> - 2 \right|+\left|1 - 6 \right|+\left|3 - 3 \right|+\left|6 - 1 <unknown> - 4 \right|+\left|5 - 5 <unknown> $$$,['greedy'],1900.0
27/B,tournament « <unknown> » <unknown> fall asleep finish berland n best participants country participate tournament consist game a match two participants n · ( n - 1 ) / 2 game play tournament participant a match participant rule game quite simple — participant fall asleep first win secretary make a record game form « xi yi » xi yi number participants first number pair a winner ( i.e xi a winner yi a loser ) draw recently research form « institute sleep » find every person characterize a value pj — speed fall asleep person lower speed win every person value pj constant life know participants tournament distinct speed fall asleep also find secretary make record game except one find result miss game first line contain one integer n ( 3 ≤ n ≤ 50 ) — number participants follow n · ( n - 1 ) / 2 - 1 line contain result game game describe a single line two integers xi yi ( 1 ≤ xi yi ≤ n xi ≠ yi ) xi и yi number opponents game know tournament n participants play n - 1 game one game participant output two integers x y — miss record several solutions output,['greedy'],1300.0
309/C,get work turn computer start cod give little think ram role whole process problem task solve one problems encounter computer <unknown> 'll consider ram a sequence cells contain data cells already contain data empty empty cells form so - called memory cluster thus a memory cluster a sequence consecutive empty memory cells exactly n memory cluster i - th cluster consist ai cells need find memory m array program j - th array take <unknown> consecutive memory cells possibly n't enough memory m array task determine maximum number array locate available memory cluster course array divide memory cluster also cell belong two array first line input contain two integers n m ( 1 ≤ n m ≤ 106 ) next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) next line contain m integers b1 b2 ... bm ( 1 ≤ <unknown> ≤ 109 ) print a single integer — answer problem first example give memory cluster size 8 4 3 2 2 array size 8 4 4 . ways obtain answer equal 2 : locate array size 8 cluster size 8 one array size 4 cluster size 4 . another way locate two array size 4 one cluster size 8 . second example give 10 memory cluster size 1 6 array size 1 . choose 6 cluster locate give array,['greedy'],1900.0
1842/F,"tenzing undirected tree $$$ n $$$ vertices define value a tree black white vertices follow way value edge absolute difference number black nod two components tree delete edge value tree sum value edge $$$ k $$$ $$$ 0 \leq k \leq n $$$ tenzing want know maximum value tree $$$ k $$$ vertices paint black $$$ n - k $$$ vertices paint white first line input contain a single integer $$$ n $$$ ( $$$ 1\leq n\leq 5000 $$$ ) — number vertices follow $$$ n-1 $$$ line input contain $$$ 2 $$$ integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n u_i \neq v_i $$$ ) — indicate edge vertices $$$ u_i $$$ $$$ v_i $$$ guarantee give edge form a tree output $$$ n+1 $$$ number $$$ i $$$ -th number answer $$$ k = i-1 $$$ consider first example $$$ k=2 $$$ tenzing paint vertices $$$ 1 $$$ $$$ 2 $$$ black value edge $$$ ( 1,2 ) $$$ 0 value edge equal $$$ 2 $$$ value tree $$$ 4 $$$",['greedy'],2500.0
1707/C,"give a connect undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge weight $$$ i $$$ -th edge $$$ i $$$ a wrong algorithm find a minimum span tree ( mst ) a graph : call findmst ( 1 ) findmst ( 2 ) ... findmst ( n ) give a span tree graph determine tree minimum span tree first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2\le n\le 100000 $$$ $$$ <unknown> m\le 2\cdot 100000 $$$ ) — number vertices number edge graph follow $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1\le u_i v_i\le n $$$ $$$ u_i\ne v_i $$$ ) describe undirected edge $$$ ( u_i v_i ) $$$ graph $$$ i $$$ -th edge input weight $$$ i $$$ guarantee graph connect one edge pair vertices need output a binary string $$$ s $$$ $$$ s_i=1 $$$ findmst ( i ) create mst $$$ s_i = 0 $$$ otherwise graph give first example one minimum span tree graph a minimum span tree $$$ ( 1,2 ) ( 3,5 ) ( 1,3 ) ( 2,4 ) $$$ weight $$$ 1 + 2 + 3 + <unknown> $$$ a part process call findmst ( 1 ) : end select edge $$$ ( 1,2 ) ( 2,3 ) ( 3,5 ) ( 2,4 ) $$$ total weight $$$ 1 + 4 + 2 + <unknown> > 11 $$$ findmst ( 1 ) find a minimum span tree show tree <unknown> answer <unknown>",['greedy'],2400.0
1800/E2,a complex version problem version additional restrictions number $$$ k $$$ chief wizard <unknown> catch evil wizard drahyrt evil wizard return want revenge chief wizard steal spell $$$ s $$$ student harry spell — a $$$ n $$$ <unknown> string lowercase latin letter drahyrt want replace spell <unknown> curse — string $$$ t $$$ <unknown> use ancient magic swap letter a distance $$$ k $$$ $$$ k+1 $$$ spell many time want word drahyrt change letter position $$$ i $$$ $$$ j $$$ spell $$$ s $$$ $$$ |i - <unknown> $$$ $$$ |i - <unknown> $$$ example $$$ k = 3 s = $$$ ` ` <unknown> '' $$$ t = $$$ ` ` <unknown> '' drahyrt act follow : give spell $$$ s $$$ $$$ t $$$ drahyrt change spell $$$ s $$$ $$$ t $$$ ? first line input give a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test descriptions test case follow first line contain two integers $$$ n k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le k \le 200000 $$$ ) — length spell number $$$ k $$$ drahyrt change letter a spell a distance $$$ k $$$ $$$ k+1 $$$ second line give spell $$$ s $$$ — a string length $$$ n $$$ consist lowercase latin letter third line give spell $$$ t $$$ — a string length $$$ n $$$ consist lowercase latin letter guarantee sum $$$ n $$$ value test case exceed $$$ 200000 $$$ note limit sum $$$ k $$$ value test case test case output a separate line ` ` yes '' drahyrt change spell $$$ s $$$ $$$ t $$$ ` ` '' otherwise output answer case ( example line ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive answer ) first case explain condition second case swap adjacent letter sort string use bubble sort example third case show string $$$ s $$$ get string $$$ t $$$ swap letter a distance $$$ 6 $$$ $$$ 7 $$$ fourth case example follow sequence transformations appropriate : fifth case show impossible get string $$$ s $$$ string $$$ t $$$ sixth example enough swap two <unknown> letter,['greedy'],1500.0
1815/C,give integer $$$ n $$$ well $$$ m $$$ pair integers $$$ ( a_i b_i ) $$$ $$$ 1\leq a_i b_i \leq n $$$ $$$ a_i \ne b_i $$$ want construct a sequence satisfy follow requirements : sometimes possible a sequence arbitrarily long case output ` ` infinite '' otherwise output ` ` finite '' sequence multiple possible <unknown> yield maximum length output test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 300 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 1500 $$$ $$$ 0 \le m \le 5000 $$$ ) — maximum possible value element sequence number pair $$$ i $$$ -th next $$$ m $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ $$$ a_i \ne b_i $$$ ) $$$ ( a_i b_i ) \ne ( a_j b_j ) $$$ $$$ 1 \le i < j \le m $$$ guarantee sum $$$ n $$$ test case n't exceed $$$ 1500 $$$ sum $$$ m $$$ test case n't exceed $$$ 5000 $$$ test case first line output ` ` infinite '' sequence arbitrarily long ` ` finite '' otherwise output ` ` finite '' output follow $$$ 2 $$$ line first line contain integer $$$ s $$$ maximum length sequence second line contain $$$ s $$$ integers $$$ 1 $$$ $$$ n $$$ inclusive represent elements sequence multiple sequence maximum length output show test case answer ` ` finite '' constraints maximum possible sum sequence lengths test case exceed $$$ <unknown> $$$ first test case element $$$ 1 $$$ two elements value $$$ 3 $$$ element $$$ 1 $$$ two elements value $$$ 2 $$$ show suitable sequence length $$$ 5 $$$ second case $$$ [ 1 ] $$$ possible sequence exactly one element value $$$ 1 $$$ sequence third case get arbitrary long sequence like $$$ 1 2 2 2 \ldots $$$,['greedy'],2200.0
1827/E,a country consist $$$ n $$$ cities $$$ n - 1 $$$ bidirectional roads connect travel two cities use roads word cities roads form a tree $$$ m $$$ bus rout connect cities together a bus route city $$$ x $$$ city $$$ y $$$ allow travel two cities simple path $$$ x $$$ $$$ y $$$ route determine every pair cities $$$ u $$$ $$$ v $$$ travel $$$ u $$$ $$$ v $$$ use two bus rout test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 5 \cdot 100000 0 \le m \le 500000 $$$ ) — number cities number bus rout $$$ n - 1 $$$ line follow line contain two integers $$$ u $$$ $$$ v $$$ denote a road connect city $$$ u $$$ city $$$ v $$$ ( $$$ 1 \le u v \le n u \neq v $$$ ) guarantee cities roads form a tree $$$ m $$$ line follow line contain two integers $$$ x $$$ $$$ y $$$ denote a bus route city $$$ x $$$ city $$$ y $$$ ( $$$ 1 \le x y \le n $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 500000 $$$ sum $$$ m $$$ test case exceed $$$ 500000 $$$ test case output ` ` yes '' travel pair cities use two bus rout otherwise output ` ` '' next line output two cities $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ ) impossible reach city $$$ y $$$ city $$$ x $$$ use two bus rout output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses graph test case $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$ :,['greedy'],3400.0
1761/C,"give a binary matrix $$$ b $$$ ( elements matrix $$$ 0 $$$ $$$ 1 $$$ ) $$$ n $$$ row $$$ n $$$ columns need construct a $$$ n $$$ set $$$ a_1 a_2 \ldots a_n $$$ follow condition satisfy : set $$$ x $$$ a proper subset set $$$ y $$$ $$$ x $$$ a nonempty subset $$$ y $$$ $$$ x \neq y $$$ 's guarantee test case problem $$$ n $$$ set exist note n't mean $$$ n $$$ set exist possible input multiple solutions output test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 1000 $$$ ) — number test case description test case follow first line contain a single integer $$$ n $$$ ( $$$ 1\le n\le 100 $$$ ) follow $$$ n $$$ line contain a binary matrix $$$ b $$$ $$$ j $$$ -th character $$$ i $$$ -th line denote $$$ b _ { i j } $$$ guarantee sum $$$ n $$$ test case exceed $$$ 1000 $$$ 's guarantee test case problem $$$ n $$$ set exist test case output $$$ n $$$ line $$$ i $$$ -th line first output $$$ s_i $$$ $$$ ( 1 \le s_i \le n ) $$$ — size set $$$ a_i $$$ , output $$$ s_i $$$ distinct integers $$$ 1 $$$ $$$ n $$$ — elements set $$$ a_i $$$ multiple solutions output 's guarantee test case problem $$$ n $$$ set exist first test case $$$ a_1 = \ { 1 2 3\ } a_2 = \ { 1 3\ } a_3 = \ { 2 4\ } a_4 = \ { 1 2 3 4\ } $$$ set $$$ a_1 a_2 a_3 $$$ proper subsets $$$ a_4 $$$ also set $$$ a_2 $$$ a proper subset $$$ a_1 $$$ set a proper subset set second test case $$$ a_1 = \ { 1\ } a_2 = \ { 1 2\ } a_3 = \ { 1 2 3\ } $$$ $$$ a_1 $$$ a proper subset $$$ a_2 $$$ $$$ a_3 $$$ $$$ a_2 $$$ a proper subset $$$ a_3 $$$",['greedy'],1400.0
1325/F,"'s year <unknown> . a graph want find a long cycle a huge independent set , , let 's stick find either give a connect graph $$$ n $$$ vertices choose either : independent set a set vertices two connect edge a simple cycle a cycle n't contain vertex twice i a proof always solve one problems 's long fit <unknown> first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 5 \le n \le 100000 $$$ $$$ n-1 \le m \le 200000 $$$ ) — number vertices edge graph next $$$ m $$$ line contain two space - separated integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) mean 's edge vertices $$$ u $$$ $$$ v $$$ 's guarantee graph connect n't contain self - loops multiple edge choose solve first problem first line print ` ` 1 '' follow a line contain $$$ <unknown> { n } \rceil $$$ distinct integers exceed $$$ n $$$ vertices desire independent set , however choose solve second problem first line print ` ` 2 '' follow a line contain one integer $$$ c $$$ represent length find cycle follow a line contain $$$ c $$$ distinct integers integers exceed $$$ n $$$ vertices desire cycle order appear cycle first sample : notice solve either problem print cycle $$$ 2 - 4 - 3 - 1 - 5 - 6 $$$ also acceptable second sample : notice multiple answer print print cycle $$$ 2 - 5 - 6 $$$ example acceptable third sample :",['greedy'],2500.0
1795/F,"give a tree consist $$$ n $$$ vertices $$$ k $$$ chip place vertices $$$ a_1 a_2 \dots a_k $$$ $$$ a_i $$$ distinct vertices $$$ a_1 a_2 \dots a_k $$$ color black initially remain vertices white go play a game perform move ( possibly zero ) $$$ i $$$ -th move ( $$$ 1 $$$ -indexed ) go move $$$ ( ( i - 1 ) \bmod k + 1 ) $$$ -st chip current vertex adjacent white vertex color vertex black , $$$ k=3 $$$ move chip $$$ 1 $$$ move $$$ 1 $$$ chip $$$ 2 $$$ move $$$ 2 $$$ chip $$$ 3 $$$ move $$$ 3 $$$ chip $$$ 1 $$$ move $$$ 4 $$$ chip $$$ 2 $$$ move $$$ 5 $$$ adjacent white vertex game end 's maximum number move perform ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases first line testcase contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number vertices tree next $$$ n - 1 $$$ line contain two integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le n $$$ ) — descriptions edge give edge form a tree next line contain a single integer $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) — number chip next line contain $$$ k $$$ integers $$$ a_1 a_2 \dots a_k $$$ ( $$$ 1 \le a_i \le n $$$ ) — vertices chip $$$ a_i $$$ distinct sum $$$ n $$$ testcases n't exceed $$$ 200000 $$$ testcase print a single integer — maximum number move perform",['greedy'],2400.0
769/C,"robot a rectangular maze size n × m. cell maze either empty occupy obstacle robot move neighbor cells side leave ( symbol ` ` l '' ) right ( symbol ` ` r '' ) ( symbol ` ` u '' ) ( symbol ` ` d '' ) robot move cell empty initially robot empty cell task find lexicographically minimal robot 's cycle length exactly k begin end cell robot initially allow robot visit cell many time ( include start ) consider robot 's way give a line consist symbols ` ` l '' ` ` r '' ` ` u '' ` ` d '' example firstly robot go leave right mean way write ` ` <unknown> '' task n't need minimize length way find minimum lexicographical ( alphabet order dictionary ) line satisfy requirements first line contain three integers n m k ( 1 ≤ n m ≤ 1000 1 ≤ k ≤ 106 ) — size maze length cycle follow n line contain m symbols — description maze symbol equal ` ` . '' current cell empty symbol equal ` ` * '' current cell occupy obstacle symbol equal ` ` x '' initially robot cell empty guarantee symbol ` ` x '' find maze exactly print lexicographically minimum robot 's way length exactly k start end cell initially robot way print ` ` impossible '' ( without quote ) first sample two cyclic ways robot length 2 exist — ` ` <unknown> '' ` ` rl '' second cycle lexicographically less second sample robot move follow way : leave , leave leave leave right right right , right , third sample robot ca n't move neighbor cells occupy obstacles",['greedy'],1700.0
780/C,andryusha go a park day square paths look bore andryusha decide decorate park consist n square connect ( n - 1 ) bidirectional paths a way square reachable use paths andryusha decide hang a color balloon square baloons ' color describe positive integers start 1 . order make park <unknown> andryusha want choose color a special way precisely want use color a b c distinct square a b a direct path b c a direct path balloon color three square distinct andryusha want use little different color possible help choose color ! first line contain single integer n ( 3 ≤ n ≤ 2·105 ) — number square park next ( n - 1 ) line contain two integers x y ( 1 ≤ x y ≤ n ) — indices two square directly connect a path guarantee square reachable use paths first line print single integer k — minimum number color andryusha use second line print n integers i - th equal balloon color i - th square number within range 1 k. first sample park consist three square : 1 → 3 → 2 . thus balloon color distinct second example follow triple consequently connect square : third example follow triple :,['greedy'],1600.0
804/C,isart modsart try solve interest problem suddenly <unknown> arrive <unknown> ask : ` ` solve a problem i ' m stick day ? ` ` a tree t n vertices m type ice cream numerate 1 m. vertex i a set si type ice cream vertices i - th ( 1 ≤ i ≤ m ) type ice cream form a connect subgraph build a new graph g m vertices put edge v - th u - th ( 1 ≤ u v ≤ m u ≠ v ) vertices g exist a vertex t v - th u - th type ice cream set problem paint vertices g minimum possible number color a way adjacent vertices color please note consider empty set vertices form a connect subgraph problem usual modsart n't like <unknown> previous problem isart want solve new problem first line contain two integer n m ( 1 ≤ n m ≤ 3·105 ) — number vertices t number ice cream <unknown> line follow i - th line contain single integer si ( 0 ≤ si ≤ 3·105 ) si distinct integers 1 m — type ice cream i - th vertex sum si n't exceed <unknown> - 1 line follow line describe edge tree two integers u v ( 1 ≤ u v ≤ n ) — index connect edge vertices print single integer c first line — minimum number color paint vertices graph g. second line print m integers i - th color i - th vertex color 1 c. answer print first example first type ice cream present first vertex color color second third ice cream present second vertex paint different color second example color second fourth fifth ice cream obviously distinct,['greedy'],2200.0
1558/E,a certain video game player control a hero characterize a single integer value : power current level hero get a system $$$ n $$$ cave number $$$ 1 $$$ $$$ n $$$ $$$ m $$$ tunnel tunnel connect two distinct cave two cave connect one tunnel cave reach cave move via tunnel hero start level cave $$$ 1 $$$ every cave contain a monster hero move cave via tunnel hero leave a cave enter a tunnel must finish movement arrive opposite end tunnel hero use tunnel move directions however hero use tunnel twice a row formally hero move cave $$$ i $$$ cave $$$ j $$$ via a tunnel head back cave $$$ i $$$ immediately head cave connect cave $$$ j $$$ a tunnel know least two tunnel come every cave thus hero never find a dead end even consider requirement pass level hero must beat monsters cave hero enter a cave first time fight monster hero beat monster cave $$$ i $$$ hero 's power strictly greater $$$ a_i $$$ case beat monster hero 's power increase $$$ b_i $$$ hero ca n't beat monster 's fight game end player lose hero beat monster cave $$$ i $$$ subsequent visit cave $$$ i $$$ wo n't <unknown> : cave wo n't monsters hero 's power wo n't change either find smallest possible power hero must start level able beat monsters pass level test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 3 \le n \le 1000 $$$ ; $$$ n \le m \le min ( \frac { n ( n-1 ) } { 2 } 2000 ) $$$ ) — number cave tunnel second line contain $$$ n-1 $$$ integers $$$ a_2 a_3 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — value hero 's power compare fight monsters cave $$$ 2 3 \ldots n $$$ third line contain $$$ n-1 $$$ integers $$$ b_2 b_3 \ldots b_n $$$ ( $$$ 1 \le b_i \le 1000000000 $$$ ) — increase apply hero 's power beat monsters cave $$$ 2 3 \ldots n $$$ next $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ; $$$ u_i \ne v_i $$$ ) — number cave connect a tunnel two cave connect one tunnel cave reach cave move via tunnel least two tunnel come every cave guarantee sum $$$ n $$$ test case exceed $$$ 1000 $$$ sum $$$ m $$$ test case exceed $$$ 2000 $$$ test case print a single integer — smallest possible power hero must start level able beat monsters pass level first test case hero pass level initial power $$$ 15 $$$ follow : second test case situation similar except power increase beat monsters cave $$$ 2 $$$ $$$ 4 $$$ exchange hero follow a different route $$$ 1 \rightarrow 4 \rightarrow 3 \rightarrow 2 $$$ pass level initial power $$$ 15 $$$ third test case hero pass level initial power $$$ 19 $$$ follow :,['greedy'],3000.0
761/E,dasha decide a rest solve problem ready start favourite activity — <unknown> remember puzzle could solve tree a non - oriented connect graph without cycle particular always n - 1 edge a tree n vertices puzzle position vertices point cartesian plane integral coordinate segment vertices connect edge parallel coordinate ax also intersection segment allow end distinct vertices place different point help dasha find suitable way position tree vertices plane guarantee possible position tree vertices plane without violate condition give use point integral coordinate n't exceed 1018 absolute value first line contain single integer n ( 1 ≤ n ≤ 30 ) — number vertices tree next n - 1 line contain two integers ui vi ( 1 ≤ ui vi ≤ n ) mean i - th edge tree connect vertices ui vi guarantee describe graph a tree puzzle n't a solution line print ` ` '' otherwise first line contain ` ` yes '' next n line contain pair integers xi yi ( |xi| |yi| ≤ 1018 ) — coordinate point correspond i - th vertex tree several solutions print first sample one possible position tree :,['greedy'],2000.0
622/E,tree a connect graph without cycle a leaf a tree vertex connect exactly one vertex give a tree n vertices a root vertex 1 . <unknown> leaf tree one second ants simultaneously go parent vertex vertex two ants vertex simultaneously except root tree find minimal time require ants root tree note start ants leave tree first line contain integer n ( 2 ≤ n ≤ 5·105 ) — number vertices tree next n - 1 line contain two integers xi yi ( 1 ≤ xi yi ≤ n ) — end i - th edge guarantee give correct undirected tree print integer t — minimal time require ants root tree,['greedy'],2200.0
638/C,berland n cities n - 1 bidirectional roads road connect pair cities city get one use give roads city exactly one repair brigade repair road need two team base cities connect road work simultaneously one day brigade repair one road whole day take part repair roads day repair brigade nothing day determine minimum number days need repair roads brigade change cities initially first line input contain a positive integer n ( 2 ≤ n ≤ 200 000 ) — number cities berland next n - 1 line contain two number ui vi mean i - th road connect city ui city vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) first print number k — minimum number days need repair roads berland next k line print description roads repair k days i - th line print first number di — number roads repair i - th day di space - separated integers — number roads repair i - th day roads number accord order input start one multiple variants print first sample repair roads two days example repair roads 1 2 first day road 3 — second day,['greedy'],1800.0
659/F,"farmer polycarp a warehouse hay represent n × m rectangular table n number row m number columns table cell table contain a haystack height meter hay locate i - th row j - th column equal integer ai j coincide number cubic meter hay haystack cells size base 1 × 1 . polycarp decide <unknown> warehouse remove arbitrary integer amount cubic meter hay top stack take different amount hay different <unknown> besides allow touch a stack , <unknown> remove completely a stack completely remove correspond cell become empty longer contain stack polycarp want follow requirements hold reorganization : two stack consider adjacent share a side table area call connect stack area get stack area move adjacent stack case two adjacent stack necessarily belong area help polycarp complete challenge task inform impossible first line input contain three integers n m ( 1 ≤ n m ≤ 1000 ) k ( 1 ≤ k ≤ 1018 ) — number row columns rectangular table heap hay lie require total number cubic meter hay reorganization n line follow contain m positive integers ai j ( 1 ≤ ai j ≤ 109 ) ai j equal number cubic meter hay make hay stack i - th row j - th column table first line print ` ` yes '' ( without quote ) polycarpus perform <unknown> ` ` '' ( without quote ) otherwise answer ` ` yes '' ( without quote ) next n line print m number — heights remain hay stack remain non - zero value equal represent a connect area least one value n't alter multiple answer print first sample non - zero value make a connect area value exceed initial heights hay stack non - zero value equal 7 number 5 total volume remain hay equal require value k = <unknown> = 35 . stack second line third row remain <unknown>",['greedy'],2000.0
689/B,"recently mike busy study exams contest go <unknown> a bite <unknown> see city city consist n intersections number 1 n. mike start walk house locate intersection number 1 go along sequence intersections walk intersection number i intersection j require |i - j| units energy total energy spend mike visit a sequence intersections p1 = 1 p2 ... pk equal units energy course walk would bore shortcuts a shortcut a special path allow mike walk one intersection another require 1 unit energy exactly n shortcuts mike 's city ith allow walk intersection i intersection ai ( i ≤ ai ≤ ai + 1 ) ( opposite direction ) thus exactly one shortcut start intersection formally mike choose a sequence p1 = 1 p2 ... pk 1 ≤ i < k satisfy pi + 1 = api api ≠ pi mike spend 1 unit energy instead <unknown> - pi + 1| walk intersection pi intersection pi + 1 . example mike choose a sequence p1 = 1 p2 = ap1 p3 = ap2 ... pk = <unknown> - 1 spend exactly k - 1 units total energy walk around go adventure mike ask find minimum amount energy require reach intersections home formally 1 ≤ i ≤ n mike interest find minimum possible total energy sequence p1 = 1 p2 ... pk = i. first line contain integer n ( 1 ≤ n ≤ 200 000 ) — number mike 's city intersection second line contain n integers a1 a2 ... ( i ≤ ai ≤ n , describe shortcuts mike 's city allow walk intersection i intersection ai use 1 unit energy please note shortcuts n't allow walk opposite directions ( ai i ) line print n integers m1 m2 ... <unknown> mi denote least amount total energy require walk intersection 1 intersection i. first sample case desire sequence <unknown> : 1 ; m1 = 0 ; 2 : 1 2 ; m2 = 1 ; 3 : 1 3 ; m3 = |3 - 1| = 2 . second sample case sequence intersection 1 < i always 1 i mi = |1 - <unknown> third sample case — consider follow intersection <unknown> : 1 ; m1 = 0 ; 2 : 1 2 ; m2 = |2 - 1| = 1 ; 3 : 1 4 3 ; m3 = 1 + |4 - 3| = 2 ; 4 : 1 4 ; m4 = 1 ; 5 : 1 4 5 ; m5 = 1 + |4 - 5| = 2 ; 6 : 1 4 6 ; <unknown> = 1 + |4 - 6| = 3 ; 7 : 1 4 5 7 ; <unknown> = 1 + |4 - 5| + 1 = 3",['greedy'],1600.0
723/E,n cities m two - way roads berland road connect two cities know one road connect pair cities road connect city possible way get one city city use roads road minister decide make a reform berland orient roads country i.e make road one - way minister want maximize number cities number roads begin city equal number roads end first line contain a positive integer t ( 1 ≤ t ≤ 200 ) — number testsets input testsets give follow way first line contain two integers n m ( 1 ≤ n ≤ 200 0 ≤ m ≤ n · ( n - 1 ) / 2 ) — number cities number roads berland next m line contain description roads berland line contain two integers u v ( 1 ≤ u v ≤ n ) — cities correspond road connect 's guarantee self - loops multiple roads possible way along roads a pair cities guarantee total number cities testset input data n't exceed 200 . pay attention hack use test consist one testset t equal one testset print maximum number cities number roads begin city equal number roads end next m line print orient roads first print number city road begin number city road end several answer print allow print roads test arbitrary order road print exactly,['greedy'],2200.0
731/C,"arseniy already grown - up independent mother decide leave alone m days leave a vacation prepare a lot food leave money wash arseniy 's clothe ten minutes leave realize would also useful prepare instruction particular clothe wear days absent arseniy 's family a bite weird clothe enumerate example arseniy 's n sock assign a unique integer 1 n. thus thing mother write two integers li ri days — indices sock wear day i ( obviously li stand leave foot ri right ) sock paint one k color mother already leave arseniy notice accord instruction would wear sock different color days course a terrible mistake cause a rush arseniy a smart boy , magical coincidence <unknown> k jar paint — one k color arseniy want repaint sock a way m days follow mother 's instructions wear sock color go busy days time change color sock finalize color new computer game <unknown> realise arseniy ca n't wait play minimum number sock need color change order make possible follow mother 's instructions wear sock color m days first line input contain three integers n m k ( 2 ≤ n ≤ 200 000 0 ≤ m ≤ 200 000 1 ≤ k ≤ 200 000 ) — number sock number days number available color respectively second line contain n integers c1 c2 ... cn ( 1 ≤ ci ≤ k ) — current color arseniy 's sock follow m line contain two integers li ri ( 1 ≤ li ri ≤ n li ≠ ri ) — indices sock arseniy wear i - th day print one integer — minimum number sock color change order able obey instructions make people laugh watch sock different color first sample arseniy repaint first third sock second color second sample need change color",['greedy'],1600.0
846/E,igor a post - <unknown> student chemistry faculty berland state university ( bersu ) need conduct a complicate experiment write <unknown> laboratory bersu n't contain materials require experiment fortunately chemical laws allow material transformations ( yes chemistry berland differ ) rule transformation a bite strange berland chemists aware n materials number order discover material transform material ( vice versa ) formally i ( 2 ≤ i ≤ n ) exist two number xi ki denote a possible transformation : ki kilograms material xi transform 1 kilogram material i 1 kilogram material i transform 1 kilogram material xi chemical process <unknown> bersu allow transformation amount result material always integer number kilograms i ( 1 ≤ i ≤ n ) igor know experiment require ai kilograms material i laboratory contain bi kilograms material possible conduct experiment transform materials ( none ) ? first line contain one integer number n ( 1 ≤ n ≤ 105 ) — number materials discover berland chemists second line contain n integer number b1 b2 ... bn ( 1 ≤ bi ≤ 1012 ) — supply bersu laboratory third line contain n integer number a1 a2 ... ( 1 ≤ ai ≤ 1012 ) — amount require experiment n - 1 line follow j - th contain two number xj + 1 kj + 1 denote transformation ( j + 1 ) -th material ( 1 ≤ xj + 1 ≤ j 1 ≤ kj + 1 ≤ 109 ) print yes possible conduct experiment otherwise print,['greedy'],2300.0
1176/D,"author guess array $$$ a $$$ consist $$$ n $$$ integers ; integer less $$$ 2 $$$ greater $$$ 200000 $$$ n't know array $$$ a $$$ know array $$$ b $$$ form follow sequence operations : $$$ p _ { a_i } $$$ mean $$$ a_i $$$ -th prime number first prime $$$ p_1 = 2 $$$ second one $$$ p_2 = 3 $$$ , task recover suitable array $$$ a $$$ form give array $$$ b $$$ guarantee answer exist ( array $$$ b $$$ obtain suitable array $$$ a $$$ ) multiple answer print first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements $$$ a $$$ second line input contain $$$ 2n $$$ integers $$$ b_1 b_2 \dots b _ { 2n } $$$ ( $$$ 2 \le b_i \le 2750131 $$$ ) $$$ b_i $$$ $$$ i $$$ -th element $$$ b $$$ $$$ 2750131 $$$ $$$ <unknown> $$$ -th prime number line output print $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 2 \le a_i \le 200000 $$$ ) order — array $$$ a $$$ array $$$ b $$$ obtain use sequence move give problem statement multiple answer print",['greedy'],1800.0
1218/I,birthday alice receive interest gift friends – light square light square game play $$$ n \times n $$$ <unknown> square board a magical lightbulb bar size $$$ n \times 1 $$$ magical properties start game light square board magical bar turn goal game transform start light square board pattern pattern use magical bar without rotate square board magical bar work follow : place row column orientation magical lightbulb must leave right top bottom keep magical properties entire bar need fully place a board light magical bar never change light magical bar light square place switch light square board otherwise switch light magical bar use infinite number time alice a hard time transform square board pattern bob give help transform board let know impossible ? multiple solutions print first line contain one positive integer number $$$ n\ ( 1 \leq n \leq 2000 ) $$$ represent size square board next $$$ n $$$ line string length $$$ n $$$ consist 1 's 0 's represent initial state square board start top row character a string 1 mean light turn otherwise next $$$ n $$$ line string length $$$ n $$$ consist 1 's 0 's represent desire state square board start top row give alice bob last line one string length $$$ n $$$ consist 1 's 0 's represent pattern magical bar a leave right order transform instructions alice order transform square board pattern bob give first line output contain integer number $$$ <unknown> ( 0 \leq m \leq 100000 $$$ ) represent number time alice need apply magical bar next $$$ m $$$ line form ` ` <unknown> $$$ x $$$ ` ` ` ` row $$$ x $$$ ` ` $$$ x $$$ $$$ 0 $$$ -based index matrix mean magical bar apply either row $$$ x $$$ column $$$ x $$$ solution print -1 . case multiple solutions print correct one example 1 : impossible transform square board one format <unknown> 2 : magic bar apply first row column,['greedy'],2100.0
1250/N,"polycarpus a complex electronic device <unknown> device a circuit board board $$$ 1000000000 $$$ contact point number $$$ 1 $$$ $$$ 1000000000 $$$ also $$$ n $$$ wire number $$$ 1 $$$ $$$ n $$$ connect two distinct contact point board <unknown> signal pass wire $$$ a $$$ $$$ b $$$ : currently circuit board break polycarpus think board could fix wire re - <unknown> a signal could pass pair wire take $$$ 1 $$$ minute polycarpus re - solder end a wire i.e take one minute change one two contact point a wire contact point range $$$ [ 1 1000000000 ] $$$ use a new contact point a wire 's end must always solder distinct contact point wire 's end re - <unknown> require two action take $$$ 2 $$$ minutes total find minimum amount time polycarpus need re - solder wire a signal pass pair wire also output optimal sequence wire re - soldering input contain one several test case first input line contain a single integer $$$ t $$$ — number test case , $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number wire follow $$$ n $$$ line describe wire line contain two space - separated integers $$$ x_i y_i $$$ ( $$$ 1 \le x_i y_i \le 1000000000 $$$ $$$ x_i \neq y_i $$$ ) — contact point connect $$$ i $$$ -th wire a couple contact point connect one wire sum value $$$ n $$$ across test case exceed $$$ 100000 $$$ test case first print one line a single integer $$$ k $$$ — minimum number minutes need re - solder wire a signal pass pair wire follow $$$ k $$$ line print description re - solderings re - soldering describe three integers $$$ w_j a_j b_j $$$ ( $$$ 1 \le w_j \le n $$$ $$$ 1 \le a_j b_j \le 1000000000 $$$ ) triple mean $$$ j $$$ -th re - soldering end $$$ w_j $$$ -th wire solder contact point $$$ a_j $$$ become solder contact point $$$ b_j $$$ instead re - soldering a wire must connect two distinct contact point multiple optimal re - solderings print",['greedy'],2000.0
1280/C,<unknown> ! everything fine arrive medium place place good place bad place assign a task either make people <unknown> <unknown> eternity a list $$$ k $$$ pair people arrive a new inhabit neighborhood need assign $$$ 2k $$$ people one $$$ 2k $$$ house person resident exactly one house house exactly one resident course neighborhood possible visit friends $$$ 2k - 1 $$$ roads connect two house take time traverse a road specify amount time take input neighborhood design a way anyone 's house exactly one sequence distinct roads take house word graph house vertices roads edge a tree truth $$$ k $$$ pair people actually soulmates index $$$ 1 $$$ $$$ k $$$ denote $$$ f ( i ) $$$ amount time take $$$ i $$$ -th pair soulmates go 's house say need assign $$$ 2k $$$ people one $$$ 2k $$$ house two <unknown> one entities good place one entities bad place : value $$$ g $$$ $$$ b $$$ ? first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) denote number test case next line contain descriptions test case first line test case contain a single integer $$$ k $$$ denote number pair people ( $$$ 1 \le k \le 100000 $$$ ) next $$$ 2k - 1 $$$ line describe roads ; $$$ i $$$ -th contain three space - separated integers $$$ a_i b_i t_i $$$ mean $$$ i $$$ -th road connect $$$ a_i $$$ -th $$$ b_i $$$ -th house a road take $$$ t_i $$$ units time traverse ( $$$ 1 \le a_i b_i \le 2k $$$ $$$ a_i \neq b_i $$$ $$$ 1 \le t_i \le 1000000 $$$ ) guarantee give roads define a tree structure guarantee sum $$$ k $$$ a single file $$$ 300000 $$$ test case output a single line contain two space - separated integers $$$ g $$$ $$$ b $$$ sample test case a minimum sum equal $$$ g = 15 $$$ one way achieve follow assignment : note sum $$$ f ( i ) $$$ $$$ 5 + 6 + 4 = 15 $$$ also a maximum sum equal $$$ b = 33 $$$ one way achieve follow assignment : note sum $$$ f ( i ) $$$ $$$ 6 + 14 + 13 = 33 $$$,['greedy'],2000.0
1296/F,$$$ n $$$ railway station berland connect $$$ n-1 $$$ railway section railway network connect i.e represent undirected tree a map network railway section know station connect $$$ n-1 $$$ section integer value scenery beauty however value mark map n't know value $$$ 1 $$$ $$$ 1000000 $$$ inclusive ask $$$ m $$$ passengers question : $$$ j $$$ -th one tell three value : plan update map set value $$$ f_i $$$ railway section — scenery beauty passengers ' answer consistent value print valid set value $$$ f_1 f_2 \dots f _ { n-1 } $$$ passengers ' answer consistent report n't exist first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 5000 $$$ ) — number railway station berland next $$$ n-1 $$$ line contain descriptions railway section : $$$ i $$$ -th section description two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n x_i \ne y_i $$$ ) $$$ x_i $$$ $$$ y_i $$$ indices station connect $$$ i $$$ -th railway section railway section <unknown> station reach station railway next line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 5000 $$$ ) — number passengers ask question $$$ m $$$ line follow $$$ j $$$ -th line contain three integers $$$ a_j $$$ $$$ b_j $$$ $$$ g_j $$$ ( $$$ 1 \le a_j b_j \le n $$$ ; $$$ a_j \ne b_j $$$ ; $$$ 1 \le g_j \le 1000000 $$$ ) — departure station arrival station minimum scenery beauty along path answer print a single integer -1 . otherwise print $$$ n-1 $$$ integers $$$ f_1 f_2 \dots f _ { n-1 } $$$ ( $$$ 1 \le f_i \le 1000000 $$$ ) $$$ f_i $$$ valid scenery beauty along $$$ i $$$ -th railway section multiple answer print,['greedy'],2100.0
1325/C,give a tree consist $$$ n $$$ nod want write label tree 's edge follow condition hold : $$$ mex ( u v ) $$$ denote smallest non - negative integer n't write edge unique simple path node $$$ u $$$ node $$$ v $$$ first line contain integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — number nod tree next $$$ n-1 $$$ line contain two space - separated integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) mean 's edge nod $$$ u $$$ $$$ v $$$ 's guarantee give graph a tree output $$$ n-1 $$$ integers $$$ i^ { th } $$$ number write $$$ i^ { th } $$$ edge ( input order ) tree second sample :,['greedy'],1500.0
1141/G,treeland consist $$$ n $$$ cities $$$ n-1 $$$ roads road bidirectional connect two distinct cities city get city roads yes right — country 's <unknown> undirected tree <unknown> road company treeland government decide sell roads company road belong one company a company multiple roads government afraid look unfair think people a city consider unfair one company own two roads enter city government want make privatization number cities n't exceed $$$ k $$$ number company take part privatization minimal choose number company $$$ r $$$ possible assign road one company a way number cities two roads one company $$$ k $$$ word a city roads belong different company city good task find minimal $$$ r $$$ assignment company $$$ 1 $$$ $$$ r $$$ number cities good n't exceed $$$ k $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 200000 0 \le k \le n - 1 $$$ ) — number cities maximal number cities two roads belong one company follow $$$ n-1 $$$ line contain roads one road per line line contain a pair integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ ) $$$ x_i $$$ $$$ y_i $$$ cities connect $$$ i $$$ -th road first line print require $$$ r $$$ ( $$$ 1 \le r \le n - 1 $$$ ) second line print $$$ n-1 $$$ number $$$ c_1 c_2 \dots c _ { n-1 } $$$ ( $$$ 1 \le c_i \le r $$$ ) $$$ c_i $$$ company $$$ i $$$ -th road multiple answer print,['greedy'],1900.0
1133/F2,give undirected unweighted connect graph consist $$$ n $$$ vertices $$$ m $$$ edge guarantee self - loops multiple edge give graph task find span tree graph degree first vertex ( vertex label $$$ 1 $$$ ) equal $$$ d $$$ ( say span tree ) recall degree a vertex number edge incident first line contain three integers $$$ n $$$ $$$ m $$$ $$$ d $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ n - 1 \le m \le min ( 2 \cdot 100000 \frac { n ( n-1 ) } { 2 } ) 1 \le d < n $$$ ) — number vertices number edge require degree first vertex respectively follow $$$ m $$$ line denote edge : edge $$$ i $$$ represent a pair integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ $$$ u_i \ne v_i $$$ ) indices vertices connect edge loop multiple edge give graph i. e. pair ( $$$ v_i u_i $$$ ) pair ( $$$ v_i u_i $$$ ) ( $$$ u_i v_i $$$ ) list edge pair $$$ ( v_i u_i ) $$$ condition $$$ v_i \ne u_i $$$ satisfy span tree satisfy condition problem statement print ` ` '' first line otherwise print ` ` yes '' first line print $$$ n-1 $$$ line describe edge a span tree degree first vertex ( vertex label $$$ 1 $$$ ) equal $$$ d $$$ make sure edge print span tree form subset input edge ( order n't matter edge $$$ ( v u ) $$$ consider edge $$$ ( u v ) $$$ ) multiple possible answer print picture correspond first second examples : picture correspond third example :,['greedy'],1900.0
1098/C,misha walk <unknown> forest fascinate tree decide draw tree ! misha would like construct a root tree $$$ n $$$ vertices index 1 $$$ n $$$ root index 1 . every vertex a parent $$$ p_i $$$ $$$ i $$$ call a child vertex $$$ p_i $$$ vertex $$$ u $$$ belong subtree vertex $$$ v $$$ iff $$$ v $$$ reachable $$$ u $$$ iterate parent ( $$$ u $$$ $$$ p _ { u } $$$ $$$ p _ { p _ { u } } $$$ ... ) clearly $$$ v $$$ belong subtree number vertices subtree call size subtree misha interest tree every vertex belong subtree vertex $$$ 1 $$$ a tree $$$ 6 $$$ vertices subtree vertex $$$ 2 $$$ contain vertices $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ hence size subtree $$$ 4 $$$ branch coefficient tree define maximum number children vertex example tree branch coefficient equal $$$ 2 $$$ task construct a tree $$$ n $$$ vertices sum subtree size vertices equal $$$ s $$$ branch coefficient minimum possible input line contain two integers $$$ n $$$ $$$ s $$$ — number vertices tree desire sum subtree size ( $$$ 2 \le n \le 100000 $$$ ; $$$ 1 \le s \le 10^ { 10 } $$$ ) require tree exist output « » otherwise output « yes » first line next one output integers $$$ p_2 $$$ $$$ p_3 $$$ ... $$$ p_n $$$ $$$ p_i $$$ denote parent vertex $$$ i $$$ one find one possible solutions first sample case sum subtree size equal $$$ 3 + 1 + 1 = 5 $$$ branch coefficient equal $$$ 2 $$$ one find one possible solutions third sample case sum subtree size equal $$$ 6 + 3 + 2 + 1 + 2 + 1 = 15 $$$ branch coefficient equal $$$ 2 $$$,['greedy'],2400.0
1253/D,'re give undirected graph $$$ n $$$ nod $$$ m $$$ edge nod number $$$ 1 $$$ $$$ n $$$ graph consider harmonious follow property hold : word a harmonious graph a node $$$ l $$$ reach a node $$$ r $$$ edge ( $$$ l < r $$$ ) able reach nod $$$ ( l+1 ) ( <unknown> ) \ldots ( r-1 ) $$$ minimum number edge need add make graph harmonious ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 3 \le n \le 200\ 000 $$$ $$$ 1 \le m \le 200\ 000 $$$ ) $$$ i $$$ -th next $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \neq v_i $$$ ) mean 's edge nod $$$ u $$$ $$$ v $$$ guarantee give graph simple ( self - loop one edge every pair nod ) print minimum number edge add graph make harmonious first example give graph harmonious ( instance $$$ 1 < 6 < 7 $$$ node $$$ 1 $$$ reach node $$$ 7 $$$ path $$$ 1 \rightarrow 2 \rightarrow 7 $$$ node $$$ 1 $$$ ca n't reach node $$$ 6 $$$ ) however add edge $$$ ( 2 4 ) $$$ sufficient make harmonious second example give graph already harmonious,['greedy'],1700.0
893/C,"vova promise would never play computer game ... recently <unknown> — a well - known game develop company — publish newest game world <unknown> become really popular course vova start play try solve a quest task come a settlement name overcity spread a rumor vova know n character overcity character friends share information get also vova know bribe character start spread rumor ; i - th character want ci gold exchange spread rumor a character hear rumor tell friends start spread rumor friends ( free ) , quest finish n character know rumor minimum amount gold vova need spend order finish quest ? take a look note think n't understand problem completely first line contain two integer number n m ( 1 ≤ n ≤ 105 0 ≤ m ≤ 105 ) — number character overcity number pair friends second line contain n integer number ci ( 0 ≤ ci ≤ 109 ) — amount gold i - th character ask start spread rumor m line follow contain a pair number ( xi yi ) represent character xi yi friends ( 1 ≤ xi yi ≤ n xi ≠ yi ) guarantee pair list print one number — minimum amount gold vova spend order finish quest first example best decision bribe first character ( spread rumor fourth character fourth one spread fifth ) also vova bribe second third character know rumor second example vova bribe everyone third example optimal decision bribe first third fifth seventh ninth character",['greedy'],1300.0
902/B,give a root tree n vertices vertices number 1 n root vertex number 1 . vertex a color let 's denote color vertex v cv initially cv = 0 . color tree give color use smallest possible number step step choose a vertex v a color x color <unknown> subtree v ( include v ) color x. word every vertex u path root u pass v set <unknown> = x. guarantee color vertex a color different 0 . learn a root tree use link : https : //en.wikipedia.org / wiki / tree _ ( graph_theory ) first line contain a single integer n ( 2 ≤ n ≤ 104 ) — number vertices tree second line contain n - 1 integers p2 p3 ... pn ( 1 ≤ pi < i ) pi mean edge vertices i pi third line contain n integers c1 c2 ... cn ( 1 ≤ ci ≤ n ) ci color color i - th vertex guarantee give graph a tree print a single integer — minimum number step perform color tree give color tree first sample show picture ( number vetices ' indices ) : first step color vertices subtree vertex 1 color 2 ( number color ) : <unknown> step color vertices subtree vertex 5 color 1 : third step color vertices subtree vertex 2 color 1 : tree second sample show picture ( number vetices ' indices ) : first step color vertices subtree vertex 1 color 3 ( number color ) : second step color vertices subtree vertex 3 color 1 : third step color vertices subtree vertex 6 color 2 : fourth step color vertices subtree vertex 4 color 1 : <unknown> step color vertices subtree vertex 7 color 3 :,['greedy'],1200.0
911/F,give unweighted tree n vertices n - 1 follow operations apply tree a single operation consist follow step : initial answer ( apply operations ) 0 . obviously n - 1 operations tree consist a single vertex calculate maximal possible answer achieve construct a sequence operations allow achieve answer ! first line contain one integer number n ( 2 ≤ n ≤ 2·105 ) — number vertices tree next n - 1 line describe edge tree form ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) guarantee give graph a tree first line print one integer number — maximal possible answer next n - 1 line print operations order apply format ai bi ci ai bi — pair leave choose current operation ( 1 ≤ ai bi ≤ n ) ci ( 1 ≤ ci ≤ n ci = ai ci = bi ) — <unknown> leaf remove tree current operation see examples better understand,['greedy'],2400.0
939/D,valya tolya <unknown> pair quarrel sometimes recently valya take <unknown> <unknown> come t - shirt letter differ letter pullover n't want see tolya seat room cry photos day long story could sad <unknown> <unknown> ( tolya 's grandmother ) decide help restore relationship <unknown> take tolya 's t - shirt valya 's pullover want make letter order one unit mana buy a spell change letter clothe task calculate minimum amount mana tolya 's grandmother spend rescue love tolya valya formally letter tolya 's t - shirt valya 's pullover two string length n consist lowercase english letter use one unit mana grandmother buy a spell form ( c1 c2 ) ( c1 c2 lowercase english letter ) arbitrary number time transform a single letter c1 c2 vise - versa tolya 's t - shirt valya 's pullover find minimum amount mana grandmother spend buy a set spell make letter equal addition output require set spell first line contain a single integer n ( 1 ≤ n ≤ 105 ) — length letter second line contain a string length n consist lowercase english letter — letter valya 's pullover third line contain letter tolya 's t - shirt format first line output a single integer — minimum amount mana t require rescue love valya tolya next t line output pair space - separated lowercase english letter — spell tolya 's grandmother buy spell letter spell print order many optimal answer output first example 's enough buy two spell : ( ' a ' 'd ' ) ( ' b ' ' a ' ) first letter coincide replace letter ' a ' 'd ' second letter coincide replace ' b ' ' a ' third letter coincide first replace ' b ' ' a ' ' a ' 'd ',['greedy'],1600.0
999/E,$$$ n $$$ cities $$$ m $$$ roads berland road connect a pair cities roads berland one - way minimum number new roads need build make cities reachable capital ? new roads also one - way first line input consist three integers $$$ n $$$ $$$ m $$$ $$$ s $$$ ( $$$ 1 \le n \le 5000 0 \le m \le 5000 1 \le s \le n $$$ ) — number cities number roads index capital cities index $$$ 1 $$$ $$$ n $$$ follow $$$ m $$$ line contain roads : road $$$ i $$$ give a pair cities $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) pair cities $$$ ( u v ) $$$ one road $$$ u $$$ $$$ v $$$ roads opposite directions a pair cities allow ( i.e $$$ u $$$ $$$ v $$$ $$$ v $$$ $$$ u $$$ ) print one integer — minimum number extra roads need make cities reachable city $$$ s $$$ cities already reachable $$$ s $$$ print 0 . first example illustrate follow : example add roads ( $$$ 6 4 $$$ ) ( $$$ 7 9 $$$ ) ( $$$ 1 7 $$$ ) make cities reachable $$$ s = 1 $$$ second example illustrate follow : example add one roads ( $$$ 5 1 $$$ ) ( $$$ 5 2 $$$ ) ( $$$ 5 3 $$$ ) ( $$$ 5 4 $$$ ) make cities reachable $$$ s = 5 $$$,['greedy'],2000.0
1098/A,mitya a root tree $$$ n $$$ vertices index $$$ 1 $$$ $$$ n $$$ root index $$$ 1 $$$ vertex $$$ v $$$ initially integer number $$$ a_v \ge 0 $$$ write every vertex $$$ v $$$ mitya compute $$$ s_v $$$ : sum value write vertices path vertex $$$ v $$$ root well $$$ h_v $$$ — depth vertex $$$ v $$$ denote number vertices path vertex $$$ v $$$ root clearly $$$ s_1 = a_1 $$$ $$$ <unknown> $$$ mitya erase number $$$ a_v $$$ accident also erase value $$$ s_v $$$ vertices even depth ( vertices even $$$ h_v $$$ ) task restore value $$$ a_v $$$ every vertex determine mitya make a mistake case multiple ways restore value 're require find one minimize total sum value $$$ a_v $$$ vertices tree first line contain one integer $$$ n $$$ — number vertices tree ( $$$ 2 \le n \le 100000 $$$ ) follow line contain integers $$$ p_2 $$$ $$$ p_3 $$$ ... $$$ p_n $$$ $$$ p_i $$$ stand parent vertex index $$$ i $$$ tree ( $$$ 1 \le p_i < i $$$ ) last line contain integer value $$$ s_1 $$$ $$$ s_2 $$$ ... $$$ s_n $$$ ( $$$ -1 \le s_v \le 1000000000 $$$ ) erase value replace $$$ -1 $$$ output one integer — minimum total sum value $$$ a_v $$$ original tree $$$ -1 $$$ tree exist,['greedy'],1600.0
1495/B,"a <unknown> qingshan suggest friend daniel go hike unfortunately busy high school students go hike <unknown> paper a permutation $$$ p $$$ write leave right paper first qingshan choose integer index $$$ x $$$ ( $$$ 1\le <unknown> n $$$ ) tell daniel , daniel choose another integer index $$$ y $$$ ( $$$ 1\le <unknown> n $$$ $$$ y \ne x $$$ ) game progress turn turn usual qingshan move first rule follow : person ca n't make move lose win , qingshan 's fan ask calculate number possible $$$ x $$$ make qingshan win case players play optimally first line contain a single integer $$$ n $$$ ( $$$ 2\le n\le 100000 $$$ ) — length permutation second line contain $$$ n $$$ distinct integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1\le p_i\le n $$$ ) — permutation print number possible value $$$ x $$$ qingshan choose make win first test case qingshan choose $$$ <unknown> $$$ win answer $$$ 1 $$$ second test case qingshan choose $$$ <unknown> $$$ daniel choose $$$ <unknown> $$$ first turn ( qingshan 's ) qingshan choose $$$ <unknown> $$$ change $$$ x $$$ $$$ 3 $$$ second turn ( daniel 's ) daniel choose $$$ <unknown> $$$ change $$$ y $$$ $$$ 2 $$$ qingshan ca n't choose $$$ <unknown> $$$ $$$ <unknown> $$$ time qingshan lose",['greedy'],1900.0
1092/E,give a forest — undirected graph $$$ n $$$ vertices connect component a tree diameter ( aka ` ` longest shortest path '' ) a connect undirected graph maximum number edge shortest path pair vertices task add edge ( possibly zero ) graph become a tree diameter tree minimal possible multiple correct answer print first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 1000 $$$ $$$ 0 \le m \le n - 1 $$$ ) — number vertices graph number edge respectively next $$$ m $$$ line contain two integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le n $$$ $$$ v \ne u $$$ ) — descriptions edge guarantee give graph a forest first line print diameter result tree next $$$ ( n - 1 ) - m $$$ line contain two integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le n $$$ $$$ v \ne u $$$ ) — descriptions add edge result graph a tree diameter minimal possible $$$ m = n - 1 $$$ edge add thus output consist a single integer — diameter give tree multiple correct answer print first example add edge ( 1 4 ) ( 3 4 ) lead a total diameter 3 . add edge ( 2 4 ) however make 2 . edge ( 1 2 ) option second example diameter 1 . ca n't add edge third example diameter already 2,['greedy'],2000.0
576/B,a tree size n undirected connect graph consist n vertices without cycle consider tree n vertices call a tree invariant relative permutation p = <unknown> ... pn two vertices tree u v condition hold : ` ` vertices u v connect edge vertices pu pv connect edge '' give permutation p size n. find tree size n invariant relative give permutation first line contain number n ( 1 ≤ n ≤ 105 ) — size permutation ( also equal size seek tree ) second line contain permutation pi ( 1 ≤ pi ≤ n ) seek tree exist print ` ` '' ( without quote ) otherwise print ` ` yes '' print n - 1 line contain two integers — number vertices connect edge tree find vertices number 1 order edge order vertices within edge matter multiple solutions output first sample test a permutation transform edge ( 4 1 ) edge ( 1 4 ) edge ( 4 2 ) edge ( 1 3 ) edge ( 1 3 ) edge ( 4 2 ) edge appear result tree show second sample test tree satisfy give condition,['greedy'],2100.0
1198/F,give array $$$ n $$$ integers need split integers two group gcd integers first group equal one gcd integers second group equal one gcd a group integers largest non - negative integer divide integers group group non - empty first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — elements array first line print ` ` yes '' ( without quote ) possible split integers two group require ` ` '' ( without quote ) otherwise possible split integers second line print $$$ n $$$ integers $$$ i $$$ -th integer equal $$$ 1 $$$ integer $$$ a_i $$$ first group $$$ 2 $$$ otherwise multiple solutions print,['greedy'],2900.0
1764/A,<unknown> $$$ n $$$ bucket paint represent array $$$ a $$$ length $$$ n $$$ bucket $$$ i $$$ contain paint color $$$ a_i $$$ let $$$ c ( l r ) $$$ number distinct elements subarray $$$ [ a_l a _ { l+1 } \ldots a_r ] $$$ choose $$$ 2 $$$ integers $$$ l $$$ $$$ r $$$ $$$ l \leq r $$$ $$$ r - l - c ( l r ) $$$ maximize input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 10000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) guarantee sum $$$ n $$$ exceed $$$ 100000 $$$ test case output $$$ l $$$ $$$ r $$$ $$$ l \leq r $$$ $$$ r - l - c ( l r ) $$$ maximize multiple solutions may output first test case $$$ a= [ <unknown> ] $$$ show choose $$$ l=2 $$$ $$$ r=4 $$$ maximize value $$$ r - l - c ( l r ) $$$ $$$ 0 $$$ second test case $$$ a= [ <unknown> ] $$$ show choose $$$ l=1 $$$ $$$ r=5 $$$ maximize value $$$ r - l - c ( l r ) $$$ $$$ -1 $$$ choose $$$ <unknown> $$$ $$$ <unknown> $$$ also acceptable,['greedy'],800.0
250/C,a film festival come city n. festival last exactly n days day a premiere exactly one film film a genre — integer 1 k. i - th day festival show a movie genre ai know a movie k genres occur festival <unknown> least word integer 1 k occur sequence a1 a2 ... least valentine a movie critic want watch movies festival describe impressions site creative person valentine <unknown> watch movie a certain genre valentine form mood preserve watch next movie genre next movie change valentine 's mood genres different valentine 's mood change accord new genre valentine a stress valentine ca n't watch n movies decide exclude to - watch list movies one genres word valentine go choose exactly one k genres skip movies genre sure visit movies valentine want choose genre x ( 1 ≤ x ≤ k ) total number <unknown> - movie stress ( movies genre x exclude ) minimum first line input contain two integers n k ( 2 ≤ k ≤ n ≤ 105 ) n number movies k number genres second line input contain a sequence n positive integers a1 a2 ... ( 1 ≤ ai ≤ k ) ai genre i - th movie guarantee number 1 k occur least sequence print a single number — number genre ( 1 k ) exclude film multiple answer print genre minimum number first sample exclude movies 1st genre genres 2 3 2 3 3 3 remain 3 stress ; exclude movies 2nd genre genres 1 1 3 3 3 1 1 3 remain 3 stress ; exclude movies 3rd genre genres 1 1 2 2 1 1 remain 2 stress second sample whatever genre valentine exclude exactly 3 stress,['greedy'],1600.0
1480/A,homer two friends alice bob string fan one day alice bob decide play a game a string $$$ s = s_1 s_2 \dots s_n $$$ length $$$ n $$$ consist lowercase english letter move turn alternatively alice make first move a move a player must choose index $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) choose change $$$ s_i $$$ lowercase english letter $$$ c $$$ $$$ c \neq s_i $$$ indices choose game end goal alice make final string lexicographically small possible goal bob make final string lexicographically large possible game experts always play game optimally homer a game expert wonder final string a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ one follow hold : test contain multiple test case first line contain $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case description test case follow line test case contain a single string $$$ s $$$ ( $$$ 1 \leq |s| \leq 50 $$$ ) consist lowercase english letter test case print final string a single line first test case : alice make first move must change letter a different one change ' b ' second test case : alice change first letter ' a ' bob change second letter ' z ' alice change third letter ' a ' bob change fourth letter ' z ' third test case : alice change first letter ' b ' bob change second letter ' y ',['greedy'],800.0
1425/A,<unknown> mr . chanek frequently play game arena greed name imply game 's goal find <unknown> <unknown> king <unknown> game play two people take turn mr . chanek take first turn initially a treasure chest contain $$$ n $$$ gold coin game end gold coin chest turn players make one follow move : players try maximize number coin mr . chanek ask help find maximum number coin get end game opponent play optimally first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 100000 ) $$$ denote number test case next $$$ t $$$ line contain a single integer $$$ n $$$ $$$ ( 1 \le n \le 10^ { 18 } ) $$$ $$$ t $$$ line line answer request mr . chanek first case game follow : second case game follow :,['greedy'],1400.0
1374/C,give a bracket sequence $$$ s $$$ length $$$ n $$$ $$$ n $$$ even ( divisible two ) string $$$ s $$$ consist $$$ \frac { n } { 2 } $$$ open bracket ' ( ' $$$ \frac { n } { 2 } $$$ close bracket ' ) ' one move choose exactly one bracket move begin string end string ( i.e choose index $$$ i $$$ remove $$$ i $$$ -th character $$$ s $$$ insert remain character $$$ s $$$ ) task find minimum number move require obtain regular bracket sequence $$$ s $$$ prove answer always exist give constraints recall regular bracket sequence : example ` ` ( ) ( ) '' ` ` ( ( ) ) ( ) '' ` ` ( ( ) ) '' ` ` ( ) '' regular bracket sequence ` ` ) ( ` ` ` ` ( ) ( ` ` ` ` ) ) ) '' answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 2000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 2 \le n \le 50 $$$ ) — length $$$ s $$$ guarantee $$$ n $$$ even second line test case <unknown> string $$$ s $$$ consist $$$ \frac { n } { 2 } $$$ open $$$ \frac { n } { 2 } $$$ close bracket test case print answer — minimum number move require obtain regular bracket sequence $$$ s $$$ prove answer always exist give constraints first test case example sufficient move first bracket end string third test case example sufficient move last bracket begin string fourth test case example choose last three <unknown> bracket move begin string obtain ` ` ( ( ( ) ) ) ( ( ) ) '',['greedy'],1000.0
1385/B,a permutation length $$$ n $$$ a sequence integers $$$ 1 $$$ $$$ n $$$ length $$$ n $$$ contain number exactly example $$$ [ 1 ] $$$ $$$ [ 4 3 5 1 2 ] $$$ $$$ [ 3 2 1 ] $$$ permutations $$$ [ 1 1 ] $$$ $$$ [ 0 1 ] $$$ $$$ [ 2 2 1 4 ] $$$ a permutation $$$ p [ 1 \dots n ] $$$ merge word let 's take two instance $$$ p $$$ insert elements second $$$ p $$$ first maintain relative order elements result a sequence length $$$ 2n $$$ example $$$ p= [ 3 1 2 ] $$$ possible result : $$$ [ 3 1 2 3 1 2 ] $$$ $$$ [ 3 3 1 1 2 2 ] $$$ $$$ [ 3 1 3 1 2 2 ] $$$ follow sequence possible result a merge : $$$ [ 1 3 2 1 2 3 $$$ ] [ $$$ 3 1 2 3 2 1 ] $$$ $$$ [ 3 3 1 2 2 1 ] $$$ example $$$ p= [ 2 1 ] $$$ possible result : $$$ [ 2 2 1 1 ] $$$ $$$ [ 2 1 2 1 ] $$$ follow sequence possible result a merge : $$$ [ 1 1 2 2 $$$ ] [ $$$ 2 1 1 2 ] $$$ $$$ [ 1 2 2 1 ] $$$ task restore permutation $$$ p $$$ give result sequence $$$ a $$$ guarantee answer exist unique answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 400 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — length permutation second line test case contain $$$ 2n $$$ integers $$$ a_1 a_2 \dots a _ { 2n } $$$ ( $$$ 1 \le a_i \le n $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ guarantee array $$$ a $$$ represent result merge permutation $$$ p $$$ permutation $$$ p $$$ test case print answer : $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) represent initial permutation guarantee answer exist unique,['greedy'],800.0
1385/C,give array $$$ a $$$ consist $$$ n $$$ integers find length smallest ( shortest ) prefix elements need erase $$$ a $$$ make a good array recall prefix array $$$ a= [ a_1 a_2 \dots a_n ] $$$ a subarray consist several first elements : prefix array $$$ a $$$ length $$$ k $$$ array $$$ [ a_1 a_2 \dots a_k ] $$$ ( $$$ 0 \le k \le n $$$ ) array $$$ b $$$ length $$$ m $$$ call good obtain a non - decreasing array $$$ c $$$ ( $$$ c_1 \le c_2 \le \dots \le c _ { m } $$$ ) repeat follow operation $$$ m $$$ time ( initially $$$ c $$$ empty ) : example $$$ 4 $$$ operations : take $$$ b_1 $$$ $$$ b _ { m } $$$ $$$ b _ { m-1 } $$$ last $$$ b_2 $$$ $$$ b $$$ become $$$ [ b_3 <unknown> \dots b _ { <unknown> } ] $$$ $$$ c = [ b_1 b _ { m } b _ { m-1 } b_2 ] $$$ consider follow example : $$$ b = [ 1 2 3 4 4 2 1 ] $$$ array good obtain non - decreasing array $$$ c $$$ follow sequence operations : note array consist one element good print length shortest prefix $$$ a $$$ delete ( erase ) make $$$ a $$$ a good array note require length $$$ 0 $$$ answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 200000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print answer : length shortest prefix elements need erase $$$ a $$$ make a good array first test case example array $$$ a $$$ already good n't need erase prefix second test case example initial array $$$ a $$$ good let 's erase first $$$ 4 $$$ elements $$$ a $$$ result $$$ [ 4 5 2 ] $$$ result array good prove erase fewer number first elements result good,['greedy'],1200.0
1397/A,give $$$ n $$$ string $$$ s_1 s_2 \ldots s_n $$$ consist lowercase latin letter one operation remove a character a string $$$ s_i $$$ insert arbitrary position a string $$$ s_j $$$ ( $$$ j $$$ may equal $$$ i $$$ ) may perform operation number time possible make $$$ n $$$ string equal ? first line contain $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) : number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) : number string $$$ n $$$ line follow $$$ i $$$ -th line contain $$$ s_i $$$ ( $$$ 1 \le <unknown> s_i <unknown> \le 1000 $$$ ) sum lengths string test case exceed $$$ 1000 $$$ possible make string equal print ` ` yes '' ( without quote ) otherwise print ` ` '' ( without quote ) output character either lowercase uppercase first test case follow : second test case impossible make $$$ n $$$ string equal,['greedy'],800.0
1399/B,$$$ n $$$ gift want give children course n't want <unknown> anyone gift equal $$$ i $$$ -th gift consist $$$ a_i $$$ candy $$$ b_i $$$ oranges one move choose gift $$$ 1 \le i \le n $$$ one follow operations : course eat a candy orange 's present gift ( neither $$$ a_i $$$ $$$ b_i $$$ become less zero ) say gift equal mean sequence move follow two condition satisfy : $$$ a_1 = a_2 = \dots = a_n $$$ $$$ b_1 = b_2 = \dots = b_n $$$ ( $$$ a_i $$$ equal $$$ b_i $$$ necessary ) task find minimum number move require equalize give gift answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — number gift second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ number candy $$$ i $$$ -th gift third line test case contain $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ 1 \le b_i \le 1000000000 $$$ ) $$$ b_i $$$ number oranges $$$ i $$$ -th gift test case print one integer : minimum number move require equalize give gift first test case example perform follow sequence move :,['greedy'],800.0
1431/D,"university a large <unknown> today duty $$$ n $$$ lecture today — different lecturers current task choose order $$$ ord $$$ happen lecturer use one marker write something a board lecture unfortunately markers become worse use lecturers may <unknown> use markers become bad opinion formally $$$ i $$$ -th lecturer acceptance value $$$ a_i $$$ mean use marker use least $$$ a_i $$$ lecture already ask a replacement specifically : know : better marker — easier audience understand a lecturer write want maximize number use markers unfortunately higher - ups watch closely many markers spend ca n't replace markers lecture , replace markers ask a lecturer marker consider use least one lecturer use lecture choose order $$$ ord $$$ lecturers give lecture find order lead maximum possible number use markers first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number independent test first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500 $$$ ) — number lecture lecturers second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — acceptance value lecturer test case print $$$ n $$$ integers — order $$$ ord $$$ lecturers maximize number use markers lecturers number $$$ 1 $$$ $$$ n $$$ order input multiple answer print first test case one optimal order follow : second test case $$$ 2 $$$ markers use third test case $$$ 3 $$$ markers use fourth test case $$$ 3 $$$ markers use",['greedy'],1500.0
1452/C,give a string $$$ s $$$ consist bracket two type : ' ( ' ' ) ' ' [ ' ' ] ' a string call a regular bracket sequence ( rbs ) 's one follow type : plus a concatenation two string one move choose a non - empty subsequence string $$$ s $$$ ( necessarily consecutive ) rbs remove string concatenate remain part without change order maximum number move perform ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases next $$$ t $$$ line contain a non - empty string consist character ' ( ' ' ) ' ' [ ' ' ] ' total length string testcases n't exceed $$$ 200000 $$$ testcase print a single integer — maximum number move perform a give string $$$ s $$$ first example erase whole string second example first erase bracket position $$$ 1 $$$ $$$ 2 $$$ : ` ` [ ] ( ) '' ` ` ( ) '' leave erase whole could erase whole string begin would get one move instead two third example first erase bracket position $$$ 1 $$$ $$$ 3 $$$ : ` ` ( [ ) ] '' form rbs ` ` ( ) '' ` ` [ ] '' leave erase whole fourth example subsequence rbs ca n't perform a move fifth example erase bracket position $$$ 2 $$$ $$$ 4 $$$ : ` ` ) [ ( ] '' get ` ` ) ( ` ` a result erase nothing,['greedy'],800.0
1474/A,"$$$ <unknown> $$$ year mike find two binary integers $$$ a $$$ $$$ b $$$ length $$$ n $$$ ( write digits $$$ 0 $$$ $$$ 1 $$$ ) lead zero order forget want construct integer $$$ d $$$ follow way : unfortunately mike lose integer $$$ a $$$ could calculate $$$ d $$$ , <unknown> want find binary integer $$$ a $$$ length $$$ n $$$ $$$ d $$$ maximum possible integer maximum possible integer mean $$$ 102 > 21 $$$ $$$ <unknown> < 101 $$$ $$$ <unknown> = 21 $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — length $$$ a $$$ $$$ b $$$ second line test case contain binary integer $$$ b $$$ length $$$ n $$$ integer $$$ b $$$ consist digits $$$ 0 $$$ $$$ 1 $$$ guarantee total sum $$$ n $$$ $$$ t $$$ test case n't exceed $$$ 100000 $$$ test case output one binary integer $$$ a $$$ length $$$ n $$$ note $$$ a $$$ $$$ b $$$ may lead zero must length $$$ n $$$ first test case $$$ b = 0 $$$ choose $$$ a = 1 $$$ give $$$ d = 1 $$$ a result second test case $$$ b = 011 $$$ : third test case $$$ b = 110 $$$ choose $$$ a = 100 $$$ 'll get $$$ d = 210 $$$ 's maximum possible $$$ d $$$ fourth test case $$$ b = <unknown> $$$ choose $$$ a = <unknown> $$$ 'll get $$$ d = <unknown> $$$ 's maximum possible $$$ d $$$ fifth test case $$$ b = <unknown> $$$ choose $$$ a = <unknown> $$$ 'll get $$$ d = <unknown> $$$ 's maximum possible $$$ d $$$",['greedy'],800.0
1481/A,dream travel a planet name planetforces personal spaceship unfortunately pilot system corrupt need fix order reach planetforces space represent $$$ xy $$$ plane start point $$$ ( 0 0 ) $$$ planetforces locate point $$$ ( p_x p_y ) $$$ pilot system spaceship follow list order represent a string $$$ s $$$ system read $$$ s $$$ leave right suppose point $$$ ( x y ) $$$ current order $$$ s_i $$$ : since string $$$ s $$$ could corrupt a possibility wo n't reach planetforces end fortunately delete order $$$ s $$$ ca n't change position delete several order ( possibly zero ) $$$ s $$$ a way 'll reach planetforces system process order ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case consist two line first line test case contain two integers $$$ p_x $$$ $$$ p_y $$$ ( $$$ -100000 \le p_x p_y \le 100000 $$$ ; $$$ ( p_x p_y ) \neq ( 0 0 ) $$$ ) — coordinate planetforces $$$ ( p_x p_y ) $$$ second line contain string $$$ s $$$ ( $$$ 1 \le |s| \le 100000 $$$ : $$$ |s| $$$ length string $$$ s $$$ ) — list order guarantee sum $$$ |s| $$$ test case exceed $$$ 100000 $$$ test case print ` ` yes '' delete several order ( possibly zero ) $$$ s $$$ a way 'll reach planetforces otherwise print ` ` '' print letter case ( upper lower ) first case n't need modify $$$ s $$$ since give $$$ s $$$ bring planetforces second case delete order $$$ s_2 $$$ $$$ s_3 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ s_8 $$$ $$$ s $$$ become equal ` ` ur '' third test case delete order $$$ <unknown> $$$ otherwise wo n't finish position planetforces,['greedy'],800.0
1488/B,a bracket sequence a string contain character ` ` ( ` ` ` ` ) '' a regular bracket sequence ( shortly rbs ) a bracket sequence transform a correct arithmetic expression insert character ` ` 1 '' ` ` + '' original character sequence example : give a string $$$ s $$$ rbs apply number operations string operation one follow type : operation $$$ 2 $$$ apply $$$ k $$$ time calculate maximum number operations apply $$$ s $$$ become empty first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case test case describe two line first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 200000 $$$ ; $$$ 1 \le k \le n $$$ ; $$$ n $$$ even ) — length $$$ s $$$ maximum number operations type $$$ 2 $$$ apply second line contain a string $$$ s $$$ $$$ n $$$ character ' ( ' ' ) ' string rbs sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print one integer — maximum number operations apply,['greedy'],1800.0
1509/B,"student council a share document file every day members student council write sequence tmt ( short <unknown> <unknown> <unknown> ) however one day members somehow enter sequence document time create a <unknown> mess therefore <unknown> <unknown> 's task figure whether document malfunction specifically give a string length $$$ n $$$ whose character either t m want figure possible partition number <unknown> subsequences equal tmt , character string belong exactly one subsequences a string $$$ a $$$ a subsequence a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 5000 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 3 \le n < 100000 $$$ ) number character string enter document guarantee $$$ n $$$ divisible $$$ 3 $$$ second line test case contain a string length $$$ n $$$ consist character t m. guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print a single line contain yes describe partition exist a single line contain otherwise first test case string already a sequence equal tmt third test case may partition string subsequences <unknown> bolded non - bolded subsequences equal tmt",['greedy'],1100.0
1380/B,"recently find a bot play ` ` rock paper scissor '' unfortunately bot use quite a simple algorithm play : a string $$$ s = s_1 s_2 \dots s _ { n } $$$ length $$$ n $$$ letter either r s p. <unknown> bot choose a start index $$$ pos $$$ ( $$$ 1 \le pos \le n $$$ ) play number round first round choose ` ` rock '' ` ` scissor '' ` ` paper '' base value $$$ s _ { pos } $$$ : second round bot 's choice base value $$$ s _ { pos + 1 } $$$ third round — $$$ s _ { pos + 2 } $$$ $$$ s_n $$$ bot return $$$ s_1 $$$ continue game plan play $$$ n $$$ round ' ve already figure string $$$ s $$$ still n't know start index $$$ pos $$$ since bot 's tactic bore ' ve decide find $$$ n $$$ choices round maximize average number win word let 's suggest choices $$$ c_1 c_2 \dots c_n $$$ bot start index $$$ pos $$$ 'll win $$$ win ( pos ) $$$ round find $$$ c_1 c_2 \dots c_n $$$ $$$ \frac { win ( 1 ) + win ( 2 ) + \dots + win ( n ) } { n } $$$ maximum possible first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next $$$ t $$$ line contain test case — one per line first line test case contain string $$$ s = s_1 s_2 \dots s _ { n } $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ s_i \in \ { \text { r } \text { s } \text { p } \ } $$$ ) — string bot 's guarantee total length string one test n't exceed $$$ 200000 $$$ test case print $$$ n $$$ choices $$$ c_1 c_2 \dots c_n $$$ maximize average number win print manner string $$$ s $$$ multiple optimal answer print first test case bot ( wherever start ) always choose ` ` rock '' always choose ` ` paper '' , case win $$$ n = 4 $$$ round average also equal $$$ 4 $$$ second test case : a picture wikipedia explain ` ` rock paper scissor '' game :",['greedy'],1400.0
1511/A,upcoming movie director release first movie also launch a simple review site two button press — upvote downvote however site simple inside two servers separate count upvotes downvotes $$$ n $$$ reviewers enter site one one reviewer one follow type : reviewer vote movie exactly since two servers actually manipulate vote movie get many upvotes possible a reviewer enter a site know type send either first server second one maximum total number upvotes gather servers decide server send reviewer ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases descriptions $$$ t $$$ testcases follow first line testcase contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — number reviewers second line testcase contain $$$ n $$$ integers $$$ r_1 r_2 \dots r_n $$$ ( $$$ 1 \le r_i \le 3 $$$ ) — type reviewers order enter site testcase print a single integer — maximum total number upvotes gather servers decide server send reviewer first testcase example send reviewer either servers — 'll downvote anyway movie wo n't receive upvotes second testcase example send reviewers first server : two upvotes total <unknown> send first second reviewers first server last reviewer — second server :,['greedy'],800.0
1516/A,"give array $$$ a $$$ length $$$ n $$$ $$$ k $$$ operations follow type : lexicographically smallest array obtain ? array $$$ x $$$ lexicographically smaller array $$$ y $$$ exist index $$$ i $$$ $$$ x_i < y_i $$$ $$$ x_j = y_j $$$ $$$ 1 \le j < i $$$ less formally first index $$$ i $$$ differ $$$ x_i < y_i $$$ first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 20 $$$ ) – number test case need solve first line test case contain $$$ 2 $$$ integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 100 $$$ $$$ 1 \le k \le 10000 $$$ ) — number elements array maximum number operations make second line contain $$$ n $$$ space - separated integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a _ { n } $$$ ( $$$ 0 \le a_i \le 100 $$$ ) — elements array $$$ a $$$ test case print lexicographically smallest array obtain $$$ k $$$ operations second test case start subtract $$$ 1 $$$ first element add $$$ 1 $$$ second , ca n't get lexicographically smaller array ca n't make elements negative",['greedy'],800.0
1585/B,give array $$$ a $$$ length $$$ n $$$ let 's define eversion operation let $$$ x = a_n $$$ array $$$ a $$$ partition two part : leave right leave part contain elements $$$ a $$$ greater $$$ x $$$ ( $$$ \le x $$$ ) right part contain elements $$$ a $$$ strictly greater $$$ x $$$ ( $$$ > x $$$ ) order elements part keep operation i. e. partition stable array replace concatenation leave right part example array $$$ a $$$ $$$ [ 2 4 1 5 3 ] $$$ eversion go like : $$$ [ 2 4 1 5 3 ] \to [ 2 1 3 ] [ 4 5 ] \to [ 2 1 3 4 5 ] $$$ start array $$$ a $$$ perform eversions array prove several eversions array $$$ a $$$ stop change output minimum number $$$ k $$$ array stop change $$$ k $$$ eversions test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print a single integer $$$ k $$$ — number eversions array stop change consider <unknown> example consider second example,['greedy'],900.0
1328/F,give array $$$ a $$$ consist $$$ n $$$ elements integer $$$ k \le n $$$ want obtain least $$$ k $$$ equal elements array $$$ a $$$ one move make one follow two operations : task calculate minimum number move require obtain least $$$ k $$$ equal elements array first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 200000 $$$ ) — number elements $$$ a $$$ require number equal elements second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ print one integer — minimum number move require obtain least $$$ k $$$ equal elements array,['greedy'],2200.0
1321/A,"polycarp prepare first program contest robots $$$ n $$$ problems a lot robots go participate robot solve problem $$$ i $$$ get $$$ p_i $$$ point score robot competition calculate sum $$$ p_i $$$ problems $$$ i $$$ solve problem $$$ p_i $$$ integer less $$$ 1 $$$ two <unknown> specialize problem - solving robot <unknown> ` ` robo - coder inc . '' ` ` bionicsolver industries '' go register two robots ( one corporation ) <unknown> well polycarp know advantage <unknown> robots produce company , problem know precisely whether robot solve competition know try predict result — manipulate reason ( absolutely involve bribe ) polycarp want ` ` robo - coder inc . '' robot outperform ` ` bionicsolver industries '' robot competition polycarp want set value $$$ p_i $$$ a way ` ` robo - coder inc . '' robot get strictly point ` ` bionicsolver industries '' robot however value $$$ p_i $$$ large may look suspicious — polycarp want minimize maximum value $$$ p_i $$$ problems help polycarp determine minimum possible upper bind number point give solve problems ? first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number problems second line contain $$$ n $$$ integers $$$ r_1 $$$ $$$ r_2 $$$ ... $$$ r_n $$$ ( $$$ 0 \le r_i \le 1 $$$ ) $$$ r_i = 1 $$$ mean ` ` robo - coder inc . '' robot solve $$$ i $$$ -th problem $$$ r_i = 0 $$$ mean wo n't solve $$$ i $$$ -th problem third line contain $$$ n $$$ integers $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_n $$$ ( $$$ 0 \le b_i \le 1 $$$ ) $$$ b_i = 1 $$$ mean ` ` bionicsolver industries '' robot solve $$$ i $$$ -th problem $$$ b_i = 0 $$$ mean wo n't solve $$$ i $$$ -th problem ` ` robo - coder inc . '' robot outperform ` ` bionicsolver industries '' robot mean print one integer $$$ -1 $$$ otherwise print minimum possible value $$$ \max \limits _ { i = 1 } ^ { n } p_i $$$ value $$$ p_i $$$ set a way ` ` robo - coder inc . '' robot get strictly point ` ` bionicsolver industries '' robot first example one valid score assignments $$$ p = [ 3 1 3 1 1 ] $$$ ` ` robo - coder '' get $$$ 7 $$$ point ` ` bionicsolver '' — $$$ 6 $$$ point second example robots get $$$ 0 $$$ point score distribution matter third example robots solve problems point equal",['greedy'],900.0
1157/B,give a long decimal number $$$ a $$$ consist $$$ n $$$ digits $$$ 1 $$$ $$$ 9 $$$ also a function $$$ f $$$ map every digit $$$ 1 $$$ $$$ 9 $$$ ( possibly ) digit $$$ 1 $$$ $$$ 9 $$$ perform follow operation : choose a non - empty contiguous subsegment digits $$$ a $$$ replace digit $$$ x $$$ segment $$$ f ( x ) $$$ example $$$ a = <unknown> $$$ $$$ f ( 1 ) = 1 $$$ $$$ f ( 3 ) = 5 $$$ $$$ f ( 7 ) = 3 $$$ choose segment consist three rightmost digits get $$$ <unknown> $$$ result maximum possible number obtain apply operation ? first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number digits $$$ a $$$ second line contain a string $$$ n $$$ character denote number $$$ a $$$ character a decimal digit $$$ 1 $$$ $$$ 9 $$$ third line contain exactly $$$ 9 $$$ integers $$$ f ( 1 ) $$$ $$$ f ( 2 ) $$$ ... $$$ f ( 9 ) $$$ ( $$$ 1 \le f ( i ) \le 9 $$$ ) print maximum number get apply operation describe statement,['greedy'],1300.0
1157/C1,difference problems c1 c2 value input problem c1 distinct ( condition may false problem c2 ) give a sequence $$$ a $$$ consist $$$ n $$$ integers integers distinct value $$$ 1 $$$ $$$ n $$$ appear sequence exactly make a sequence move move must take either leftmost element sequence rightmost element sequence write remove sequence task write a strictly increase sequence among sequence take longest ( length sequence number elements ) example sequence $$$ [ 2 1 5 4 3 ] $$$ answer $$$ 4 $$$ ( take $$$ 2 $$$ sequence become $$$ [ 1 5 4 3 ] $$$ take rightmost element $$$ 3 $$$ sequence become $$$ [ 1 5 4 ] $$$ take $$$ 4 $$$ sequence become $$$ [ 1 5 ] $$$ take $$$ 5 $$$ sequence become $$$ [ 1 ] $$$ obtain increase sequence $$$ [ 2 3 4 5 ] $$$ ) first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements $$$ a $$$ second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ integers pairwise distinct first line output print $$$ k $$$ — maximum number elements a strictly increase sequence obtain second line print a string $$$ s $$$ length $$$ k $$$ $$$ j $$$ -th character string $$$ s_j $$$ ' l ' take leftmost element $$$ j $$$ -th move ' r ' otherwise multiple answer print first example describe problem statement,['greedy'],1300.0
1157/C2,difference problems c1 c2 value input problem c1 distinct ( condition may false problem c2 ) give a sequence $$$ a $$$ consist $$$ n $$$ integers make a sequence move move must take either leftmost element sequence rightmost element sequence write remove sequence task write a strictly increase sequence among sequence take longest ( length sequence number elements ) example sequence $$$ [ 1 2 4 3 2 ] $$$ answer $$$ 4 $$$ ( take $$$ 1 $$$ sequence become $$$ [ 2 4 3 2 ] $$$ take rightmost element $$$ 2 $$$ sequence become $$$ [ 2 4 3 ] $$$ take $$$ 3 $$$ sequence become $$$ [ 2 4 ] $$$ take $$$ 4 $$$ sequence become $$$ [ 2 ] $$$ obtain increase sequence $$$ [ 1 2 3 4 ] $$$ ) first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements $$$ a $$$ second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 200000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ first line output print $$$ k $$$ — maximum number elements a strictly increase sequence obtain second line print a string $$$ s $$$ length $$$ k $$$ $$$ j $$$ -th character string $$$ s_j $$$ ' l ' take leftmost element $$$ j $$$ -th move ' r ' otherwise multiple answer print first example describe problem statement,['greedy'],1700.0
1166/A,$$$ n $$$ students first grade <unknown> high school <unknown> wish split students two classrooms ( student must exactly one classrooms ) two distinct students whose name start letter chatty put classroom ( must a lot common ) let $$$ x $$$ number pair students a split pair $$$ ( a b ) $$$ $$$ ( b a ) $$$ count example $$$ 6 $$$ students : ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` jack '' ` ` <unknown> '' ` ` <unknown> '' : give list $$$ n $$$ name minimum $$$ x $$$ obtain split students classrooms ? note valid place students one classrooms leave one empty first line contain a single integer $$$ n $$$ ( $$$ 1\leq n \leq 100 $$$ ) — number students $$$ n $$$ line follow $$$ i $$$ -th line contain name $$$ i $$$ -th student guarantee name a string lowercase english letter length $$$ 20 $$$ note multiple students may share name output must consist a single integer $$$ x $$$ — minimum possible number chatty pair first sample minimum number pair $$$ 1 $$$ achieve example put everyone except jose one classroom jose <unknown> jerry form chatty pair second sample minimum number pair $$$ 2 $$$ achieve example put kambei <unknown> <unknown> kyuzo one room put <unknown> katsushiro kikuchiyo room case two pair kambei kyuzo katsushiro kikuchiyo third sample minimum number pair $$$ 4 $$$ achieve place three students name mike one classroom two students another classroom thus three chatty pair one classroom one chatty pair classroom,['greedy'],900.0
1173/A,nauuo a girl love write comment one day post a comment codeforces wonder whether would get upvotes downvotes 's know $$$ x $$$ persons would upvote $$$ y $$$ persons would downvote also another $$$ z $$$ persons would vote n't know whether would upvote downvote note $$$ <unknown> $$$ people would vote exactly one time three different result : people upvote downvote result ` ` + '' ; people downvote upvote result ` ` - '' ; otherwise result ` ` 0 '' $$$ z $$$ unknown persons result may uncertain ( i.e one possible result ) formally result uncertain exist two different situations $$$ z $$$ persons vote result different two situations tell nauuo result report result uncertain line contain three integers $$$ x $$$ $$$ y $$$ $$$ z $$$ ( $$$ 0\le x y <unknown> $$$ ) correspond number persons would upvote downvote unknown one possible result print result : ` ` + '' ` ` - '' ` ` 0 '' otherwise print ` ` ? '' report result uncertain first example nauuo would definitely get three upvotes seven downvotes possible result ` ` - '' second example matter person unknown downvotes upvotes nauuo would get upvotes downvotes possible result ` ` + '' third example nauuo would definitely get one upvote one downvote possible result ` ` 0 '' fourth example one person <unknown> result would ` ` + '' otherwise result would ` ` - '' two possible result result uncertain,['greedy'],800.0
1585/C,a total $$$ n $$$ depots locate a number line depot $$$ i $$$ lie point $$$ x_i $$$ $$$ 1 \le i \le n $$$ a <unknown> $$$ n $$$ bag goods attempt deliver one bag $$$ n $$$ depots $$$ n $$$ bag initially origin $$$ 0 $$$ carry $$$ k $$$ bag a time must collect require number goods origin deliver respective depots return origin collect next <unknown> goods calculate minimum distance need cover deliver bag goods depots return origin deliver bag test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le <unknown> $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 200000 $$$ ) second line test case contain $$$ n $$$ integers $$$ x_1 x_2 \ldots x_n $$$ ( $$$ -1000000000 \le x_i \le 1000000000 $$$ ) possible depots share position guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a single integer denote minimum distance need cover deliver bag goods depots first test case carry one bag a time thus follow a solution sequence give a minimum travel distance : $$$ 0 \to 2 \to 0 \to 4 \to 0 \to 3 \to 0 \to 1 \to 0 \to 5 $$$ $$$ 0 $$$ mean go origin grab one bag positive integer mean deliver bag a depot coordinate give a total distance $$$ 25 $$$ units must note sequence give distance second test case follow follow sequence among multiple sequence travel minimum distance : $$$ 0 \to 6 \to 8 \to 7 \to 0 \to 5 \to 4 \to 3 \to 0 \to ( <unknown> ) \to ( -10 ) \to ( <unknown> ) $$$ distance $$$ 41 $$$ show $$$ 41 $$$ optimal distance test case,['greedy'],1300.0
1178/A,alice leader state <unknown> party become prime minister elections take place $$$ n $$$ party number $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th party receive $$$ a_i $$$ seat <unknown> alice 's party number $$$ 1 $$$ order become prime minister need build a coalition consist party possibly party two condition need fulfil : example $$$ n=4 $$$ $$$ a= [ 51 25 99 25 ] $$$ ( note alice ' a party $$$ 51 $$$ seat ) follow set $$$ [ <unknown> <unknown> <unknown> ] $$$ create a coalition since condition satisfy however follow set create a coalition : alice minimise number party a coalition want invite many party want ( long condition satisfy ) alice 's party enough people create a coalition invite party note alice either invite a party a whole possible invite deputies ( seat ) another party word alice invite a party invite deputies find print suitable coalition first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) — number party second line contain $$$ n $$$ space separate integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq 100 $$$ ) — number seat $$$ i $$$ -th party coalition satisfy condition possible output a single line integer $$$ 0 $$$ otherwise suppose $$$ k $$$ ( $$$ 1 \leq k \leq n $$$ ) party coalition ( alice minimise number party a coalition ) indices $$$ c_1 c_2 \dots c_k $$$ ( $$$ 1 \leq c_i \leq n $$$ ) output two line first contain integer $$$ k $$$ second space - separated indices $$$ c_1 c_2 \dots c_k $$$ may print party order alice 's party ( number $$$ 1 $$$ ) must list multiple solutions may print first example alice pick second party note also pick third party however become prime minister without $$$ 100 $$$ a strict majority $$$ 200 $$$ second example way build a majority party large become a coalition partner third example alice already majority fourth example describe problem statement,['greedy'],800.0
1346/B,"berland state university ( bsu ) conduct a program boot camp boot camp last $$$ n $$$ days bsu lecturers plan give number lecture days days boot camp already plan excursion days lecture hold days make sure participants n't get tire learn program number lecture day exceed $$$ k_1 $$$ number lecture pair consecutive days exceed $$$ k_2 $$$ calculate maximum number lecture conduct boot camp ? formally find maximum integer $$$ m $$$ possible choose $$$ n $$$ non - negative integers $$$ c_1 $$$ $$$ c_2 $$$ ... $$$ c_n $$$ ( $$$ c_i $$$ number lecture hold day $$$ i $$$ ) : note might non - excursion days without lecture ( i. e. possible $$$ c_i = 0 $$$ even $$$ i $$$ excursion day ) first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 50 $$$ ) — number testcases testcases follow consist two line first line contain three integers $$$ n $$$ $$$ k_1 $$$ $$$ k_2 $$$ ( $$$ 1 \le n \le 5000 $$$ ; $$$ 1 \le k_1 \le k_2 \le 200\,000 $$$ ) second line contain one string $$$ s $$$ consist exactly $$$ n $$$ character character either 0 1 . $$$ s_i = 0 $$$ day $$$ i $$$ excursion day ( lecture day ) ; $$$ s_i = 1 $$$ day $$$ i $$$ excursion day test case print one integer — maximum possible value $$$ m $$$ ( number lecture conduct )",['greedy'],1400.0
1231/C,"problem a $$$ n \times m $$$ rectangular matrix $$$ a $$$ call increase row $$$ i $$$ go leave right value strictly increase ( $$$ a _ { i,1 } < a _ { i,2 } < \dots < a _ { i m } $$$ ) column $$$ j $$$ go top bottom value strictly increase ( $$$ a _ { 1 j } < a _ { 2 j } < \dots < a _ { n j } $$$ ) a give matrix non - negative integers necessary replace value $$$ 0 $$$ positive integer result matrix increase sum elements maximum find impossible guarantee a give value matrix value $$$ 0 $$$ contain internal cells ( first last row first last column ) first line contain integers $$$ n $$$ $$$ m $$$ ( $$$ 3 \le n m \le 500 $$$ ) — number row columns give matrix $$$ a $$$ follow line contain $$$ m $$$ non - negative integers — value correspond row give matrix : $$$ a _ { i,1 } a _ { i,2 } \dots a _ { i m } $$$ ( $$$ 0 \le a _ { i j } \le 8000 $$$ ) guarantee $$$ a _ { i j } = 0 $$$ $$$ 1 < i < n $$$ $$$ 1 < j < m $$$ true possible replace zero positive number matrix increase print maximum possible sum matrix elements otherwise print -1 . first example result matrix follow : second example value $$$ 3 $$$ must put middle cell third example desire <unknown> matrix exist",['greedy'],1100.0
1251/B,a palindrome a string $$$ t $$$ read backward forward ( formally $$$ t [ i ] = t [ |t| + 1 - i ] $$$ $$$ i \in [ 1 |t| ] $$$ ) $$$ |t| $$$ denote length a string $$$ t $$$ example string 010 1001 0 palindromes $$$ n $$$ binary string $$$ s_1 s_2 \dots s_n $$$ ( $$$ s_i $$$ consist zero and/or ones ) swap pair character number time ( possibly zero ) character either string different string — restrictions formally one move : maximum number string make palindromic simultaneously ? first line contain single integer $$$ q $$$ ( $$$ 1 \le q \le 50 $$$ ) — number test case first line test case contain single integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — number binary string next $$$ n $$$ line contain binary string $$$ s_1 s_2 \dots s_n $$$ — one per line 's guarantee $$$ 1 \le |s_i| \le 50 $$$ string <unknown> zero and/or ones print $$$ q $$$ integers — one per test case $$$ i $$$ -th integer maximum number palindromic string achieve simultaneously perform zero swap string $$$ i $$$ -th test case first test case $$$ s_1 $$$ palindrome answer $$$ 1 $$$ second test case ca n't make three string palindromic time make pair string palindromic example let 's make $$$ s_1 = \text { 0110 } $$$ $$$ s_2 = \text { <unknown> } $$$ $$$ s_3 = \text { <unknown> } $$$ third test case make string palindromic example $$$ s_1 = \text { <unknown> } $$$ $$$ s_2 = \text { <unknown> } $$$ last test case $$$ s_2 $$$ palindrome make $$$ s_1 $$$ palindrome example swap $$$ s_1 [ 2 ] $$$ $$$ s_1 [ 3 ] $$$,['greedy'],1400.0
1256/B,give a permutation length $$$ n $$$ recall permutation array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2 3 1 5 4 ] $$$ a permutation $$$ [ 1 2 2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1 3 4 ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 4 $$$ array ) perform $$$ n-1 $$$ operations give permutation ( possible n't perform operations ) $$$ i $$$ -th operation allow swap elements give permutation position $$$ i $$$ $$$ i+1 $$$ operation perform operations perform arbitrary order task find lexicographically minimum possible permutation obtain perform give operations order see definition lexicographical order note section answer $$$ q $$$ independent test case example let 's consider permutation $$$ [ 5 4 1 3 2 ] $$$ minimum possible permutation obtain $$$ [ 1 5 2 4 3 ] $$$ follow way : another example $$$ [ 1 2 4 3 ] $$$ minimum possible permutation obtain $$$ [ 1 2 3 4 ] $$$ perform third operation ( swap third fourth elements ) first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100 $$$ ) — number test case $$$ q $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number elements permutation second line test case contain $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ — give permutation test case print answer — <unknown> minimum possible permutation obtain perform give operations order recall permutation $$$ p $$$ length $$$ n $$$ lexicographically less permutation $$$ q $$$ length $$$ n $$$ index $$$ i \le n $$$ $$$ j $$$ $$$ 1 $$$ $$$ i - 1 $$$ condition $$$ p_j = <unknown> $$$ satisfy $$$ p_i < q_i $$$ example :,['greedy'],1400.0
1256/C,a river width $$$ n $$$ leave bank river cell $$$ 0 $$$ right bank cell $$$ n + 1 $$$ ( formally river represent a sequence $$$ n + 2 $$$ cells number $$$ 0 $$$ $$$ n + 1 $$$ ) also $$$ m $$$ wooden platforms a river $$$ i $$$ -th platform length $$$ c_i $$$ ( $$$ i $$$ -th platform take $$$ c_i $$$ consecutive cells river ) guarantee sum lengths platforms exceed $$$ n $$$ stand $$$ 0 $$$ want reach $$$ n+1 $$$ somehow stand position $$$ x $$$ jump position range $$$ [ x + 1 ; x + d ] $$$ however n't really like water jump cells belong wooden platform example $$$ <unknown> $$$ jump next position ( belong wooden platform ) assume cells $$$ 0 $$$ $$$ n+1 $$$ belong wooden platforms want know possible reach $$$ n+1 $$$ $$$ 0 $$$ move platform leave right arbitrary number time ( possibly zero ) long intersect ( two platforms touch ) also mean change relative order platforms note move platforms start jump ( word first move platforms start jump ) example $$$ n=7 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ c = [ 1 2 1 ] $$$ one ways reach $$$ 8 $$$ $$$ 0 $$$ follow : first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ d $$$ ( $$$ 1 \le n m d \le 1000 m \le n $$$ ) — width river number platforms maximum distance jump correspondingly second line input contain $$$ m $$$ integers $$$ c_1 c_2 \dots c_m $$$ ( $$$ 1 \le c_i \le n \sum\limits _ { i=1 } ^ { m } c_i \le n $$$ ) $$$ c_i $$$ length $$$ i $$$ -th platform impossible reach $$$ n+1 $$$ $$$ 0 $$$ print first line otherwise print yes first line array $$$ a $$$ length $$$ n $$$ second line — sequence river cells ( exclude cell $$$ 0 $$$ cell $$$ n + 1 $$$ ) cell $$$ i $$$ belong platform $$$ a_i $$$ $$$ 0 $$$ otherwise equal index platform ( $$$ 1 $$$ -indexed platforms number $$$ 1 $$$ $$$ m $$$ order input ) cell $$$ i $$$ belong note $$$ a_i $$$ equal $$$ 1 $$$ form a contiguous subsegment array $$$ a $$$ length $$$ c_1 $$$ $$$ a_i $$$ equal $$$ 2 $$$ form a contiguous subsegment array $$$ a $$$ length $$$ c_2 $$$ ... $$$ a_i $$$ equal $$$ m $$$ form a contiguous subsegment array $$$ a $$$ length $$$ c_m $$$ leftmost position $$$ 2 $$$ $$$ a $$$ greater rightmost position $$$ 1 $$$ leftmost position $$$ 3 $$$ $$$ a $$$ greater rightmost position $$$ 2 $$$ ... leftmost position $$$ m $$$ $$$ a $$$ greater rightmost position $$$ m-1 $$$ see example output better understand consider first example : answer $$$ [ 0 1 0 2 2 0 3 ] $$$ sequence jump perform $$$ 0 \rightarrow 2 \rightarrow 4 \rightarrow 5 \rightarrow 7 \rightarrow 8 $$$ consider second example : matter place platform always jump $$$ 0 $$$ $$$ 11 $$$ consider third example : answer $$$ [ 0 0 0 0 1 1 0 0 0 0 ] $$$ sequence jump perform $$$ 0 \rightarrow 5 \rightarrow 6 \rightarrow 11 $$$,['greedy'],1700.0
1256/D,give a binary string length $$$ n $$$ ( i. e. a string consist $$$ n $$$ character ' 0 ' ' 1 ' ) one move swap two adjacent character string lexicographically minimum possible string obtain give one perform $$$ k $$$ move ? possible perform move note swap pair adjacent character indices $$$ i $$$ $$$ i+1 $$$ arbitrary ( possibly zero ) number time swap consider a separate move answer $$$ q $$$ independent test case first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 10000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 1000000 1 \le k \le <unknown> $$$ ) — length string number move perform second line test case contain one string consist $$$ n $$$ character ' 0 ' ' 1 ' guarantee sum $$$ n $$$ test case exceed $$$ 1000000 $$$ ( $$$ \sum n \le 1000000 $$$ ) test case print answer : lexicographically minimum possible string length $$$ n $$$ obtain give one perform $$$ k $$$ move first example change string follow : $$$ <unknown> { 10 } <unknown> \rightarrow \underline { 10 } <unknown> \rightarrow <unknown> { 10 } 10 \rightarrow <unknown> { 10 } 110 \rightarrow <unknown> { 10 } 1110 \rightarrow <unknown> $$$ third example enough operations make string sort,['greedy'],1500.0
1281/B,friend jeff <unknown> try run new online company 's go well 's get a lot <unknown> website decide call <unknown> big problem think 's rank high enough search engines could rename products better name competitors 'll top search result a <unknown> research find search engines sort result lexicographically friend could rename products lexicographically smaller string competitor 's 'll top rank ! make strategy less obvious competitors decide swap two letter product name please help jeff find improve name products lexicographically smaller competitor 's ! give string $$$ s $$$ represent jeff 's product name string $$$ c $$$ represent competitor 's product name find a way swap one pair character $$$ s $$$ ( find two distinct indices $$$ i $$$ $$$ j $$$ swap $$$ s_i $$$ $$$ s_j $$$ ) result new name become strictly lexicographically smaller $$$ c $$$ determine impossible note : string $$$ a $$$ strictly lexicographically smaller string $$$ b $$$ one follow hold : first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1500 $$$ ) denote number test case next line contain descriptions test case test case consist a single line contain two space - separated string $$$ s $$$ $$$ c $$$ ( $$$ 2 \le |s| \le 5000 1 \le |c| \le 5000 $$$ ) string $$$ s $$$ $$$ c $$$ consist uppercase english letter guarantee sum $$$ |s| $$$ input $$$ 5000 $$$ sum $$$ |c| $$$ input $$$ 5000 $$$ test case output a single line contain a single string <unknown> first test case possible swap second fourth letter string result string ` ` <unknown> '' lexicographically smaller ` ` apple '' impossible improve product 's name second test case satisfy condition third test case possible swap a pair character name ` ` apple '' lexicographically smaller ` ` <unknown> '' note valid answer <unknown> ` ` <unknown> '',['greedy'],1600.0
1295/A,a large electronic screen display $$$ 998244353 $$$ decimal digits digits display way different electronic alarm clock : place a digit consist $$$ 7 $$$ segment turn compose different digits follow picture describe display $$$ 10 $$$ decimal digits : see different digits may require different number segment turn example want display $$$ 1 $$$ turn $$$ 2 $$$ segment screen want display $$$ 8 $$$ $$$ 7 $$$ segment place display a digit turn want display a really large integer screen unfortunately screen bug : $$$ n $$$ segment turn simultaneously wonder greatest integer display turn $$$ n $$$ segment program able process $$$ t $$$ different test case first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case input test case follow represent a separate line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — maximum number segment turn correspond testcase guarantee sum $$$ n $$$ test case input exceed $$$ 100000 $$$ test case print greatest integer display turn $$$ n $$$ segment screen note answer may fit standard $$$ 32 $$$ -bit $$$ 64 $$$ -bit integral data type,['greedy'],900.0
1315/C,give a sequence $$$ b_1 b_2 \ldots b_n $$$ find lexicographically minimal permutation $$$ a_1 a_2 \ldots a _ { 2n } $$$ $$$ b_i = \min ( a _ { <unknown> } a _ { 2i } ) $$$ determine impossible test contain one test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) first line test case consist one integer $$$ n $$$ — number elements sequence $$$ b $$$ ( $$$ 1 \le n \le 100 $$$ ) second line test case consist $$$ n $$$ different integers $$$ b_1 \ldots b_n $$$ — elements sequence $$$ b $$$ ( $$$ 1 \le b_i \le 2n $$$ ) guarantee sum $$$ n $$$ test case n't exceed $$$ 100 $$$ test case appropriate permutation print one number $$$ -1 $$$ otherwise print $$$ 2n $$$ integers $$$ a_1 \ldots a _ { 2n } $$$ — require lexicographically minimal permutation number $$$ 1 $$$ $$$ 2n $$$,['greedy'],1200.0
1203/F1,difference easy hard versions complete project easy version necessary hard version polycarp a famous freelancer current rat $$$ r $$$ units rich customers ask complete project company complete $$$ i $$$ -th project polycarp need least $$$ a_i $$$ units rat ; complete project rat change $$$ b_i $$$ ( rat increase decrease $$$ b_i $$$ ) ( $$$ b_i $$$ positive negative ) polycarp 's rat fall zero people wo n't trust a low rat freelancer possible complete project ? formally write a program check order project exist polycarp enough rat start project non - negative rat complete project word check exist order project polycarp complete enough rat start project non - negative rat complete project first line input contain two integers $$$ n $$$ $$$ r $$$ ( $$$ 1 \le n \le 100 1 \le r \le 30000 $$$ ) — number project initial rat polycarp respectively next $$$ n $$$ line contain project one per line $$$ i $$$ -th project represent a pair integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i \le 30000 $$$ $$$ <unknown> \le b_i \le 300 $$$ ) — rat require complete $$$ i $$$ -th project rat change project completion print ` ` yes '' ` ` '' first example possible order : $$$ 1 2 3 $$$ second example possible order : $$$ 2 3 1 $$$ third example possible order : $$$ 3 1 4 2 $$$,['greedy'],2100.0
1628/B,mihai plan watch a movie like palindromic movies want skip ( possibly zero ) scenes make remain part movie palindromic give a list $$$ s $$$ $$$ n $$$ non - empty string length $$$ 3 $$$ represent scenes mihai 's movie a subsequence $$$ s $$$ call awesome non - empty concatenation string subsequence order a palindrome help mihai check least one awesome subsequence $$$ s $$$ ? a palindrome a string read backward forward example string ` ` z '' ` ` aaa '' ` ` aba '' ` ` abccba '' palindromes string ` ` codeforces '' ` ` reality '' ` ` ab '' a sequence $$$ a $$$ a non - empty subsequence a non - empty sequence $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) elements first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number scenes movie follow $$$ n $$$ line $$$ i $$$ -th contain a single non - empty string $$$ s_i $$$ length $$$ 3 $$$ consist lowercase latin letter guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print ` ` yes '' awesome subsequence $$$ s $$$ ` ` '' otherwise ( case insensitive ) first test case awesome subsequence $$$ s $$$ $$$ [ ab cc ba ] $$$,['greedy'],1700.0
1249/D1,difference easy hard versions constraints give $$$ n $$$ segment coordinate axis $$$ ox $$$ segment intersect lie inside even coincide $$$ i $$$ -th segment $$$ [ l_i ; r_i ] $$$ ( $$$ l_i \le r_i $$$ ) cover integer point $$$ j $$$ $$$ l_i \le j \le r_i $$$ integer point call bad cover strictly $$$ k $$$ segment task remove minimum number segment bad point first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 200 $$$ ) — number segment maximum number segment integer point cover next $$$ n $$$ line contain segment $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le 200 $$$ ) — endpoints $$$ i $$$ -th segment first line print one integer $$$ m $$$ ( $$$ 0 \le m \le n $$$ ) — minimum number segment need remove bad point second line print $$$ m $$$ distinct integers $$$ p_1 p_2 \dots p_m $$$ ( $$$ 1 \le p_i \le n $$$ ) — indices segment remove order multiple answer print,['greedy'],1800.0
1573/A,give a digital clock $$$ n $$$ digits digit show integer $$$ 0 $$$ $$$ 9 $$$ whole clock show integer $$$ 0 $$$ $$$ <unknown> $$$ clock show lead zero number smaller $$$ 10^ { n-1 } $$$ want clock show $$$ 0 $$$ operations possible operation one follow : task determine minimum number operations need make clock show $$$ 0 $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number digits clock second line test case contain a string $$$ n $$$ digits $$$ s_1 s_2 \ldots s_n $$$ ( $$$ 0 \le s_1 s_2 \ldots s_n \le 9 $$$ ) — number clock note : number smaller $$$ 10^ { n-1 } $$$ clock show lead zero test case print one integer : minimum number operations need make clock show $$$ 0 $$$ first example 's optimal decrease number $$$ 7 $$$ time second example first swap first last position decrease number $$$ 1 $$$ third example clock already show $$$ 0 $$$ n't perform operations,['greedy'],800.0
1322/A,a bracket sequence call correct ( regular ) insert ` ` + '' ` ` 1 '' get a well - <unknown> mathematical expression example sequence ` ` ( ( ) ) ( ) '' ` ` ( ) '' ` ` ( ( ) ( ( ) ) ) '' correct ` ` ) ( ` ` ` ` ( ( ) '' ` ` ( ( ) ) ) ( ` ` teacher give <unknown> 's class a strange task — ask every student come a sequence arbitrary length consist open close bracket students take turn name sequence invent dima 's turn come suddenly realize <unknown> get correct bracket sequence whether get correct bracket sequence know dima suspect simply miss word ` ` correct '' task statement want save situation modify sequence slightly precisely arbitrary number time ( possibly zero ) perform reorder operation reorder operation consist choose arbitrary consecutive subsegment ( substring ) sequence reorder character arbitrary way operation take $$$ l $$$ nanoseconds $$$ l $$$ length subsegment reorder 's easy see reorder operation n't change number open close bracket example ` ` ) ) ( ( ` ` choose substring ` ` ) ( ` ` reorder ` ` ) ( ) ( ` ` ( operation take $$$ 2 $$$ nanoseconds ) since dima soon answer want make sequence correct fast possible help determine 's impossible first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — length dima 's sequence second line contain string length $$$ n $$$ consist character ` ` ( ` ` ` ` ) '' print a single integer — minimum number nanoseconds make sequence correct ` ` -1 '' impossible first example firstly reorder segment first fourth character replace ` ` ( ) ( ) '' whole sequence ` ` ( ) ( ) ( ) ) ( ` ` reorder segment seventh eighth character replace ` ` ( ) '' end sequence ` ` ( ) ( ) ( ) ( ) '' total time spend $$$ 4 + 2 = 6 $$$ nanoseconds,['greedy'],1300.0
1604/A,"shohag integer sequence $$$ a_1 a_2 \ldots a_n $$$ perform follow operation number time ( possibly zero ) : example $$$ a= [ 3,3,4 ] $$$ select $$$ k = 2 $$$ operation obtain one sequence $$$ [ \underline { 2 } , 3,3,4 ] $$$ $$$ [ 3 \underline { 2 } , 3,4 ] $$$ $$$ [ <unknown> \underline { 2 } , 4 ] $$$ $$$ [ 3,3,4 \underline { 2 } ] $$$ shohag want sequence satisfy follow condition : $$$ 1 \le i \le |a| $$$ $$$ a_i \le i $$$ , $$$ |a| $$$ denote size $$$ a $$$ help find minimum number operations perform achieve goal show constraints problem 's always possible achieve goal a finite number operations first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — initial length sequence second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements sequence test case print a single integer — minimum number operations need perform achieve goal mention statement first test case perform least one operation $$$ <unknown> > 2 $$$ perform operation $$$ [ 1 3 4 ] \rightarrow [ 1 \underline { 2 } 3 4 ] $$$ ( newly insert element underline ) condition satisfy second test case shohag perform follow operations : $$$ [ 1 2 5 7 4 ] \rightarrow [ 1 2 \underline { 3 } 5 7 4 ] \rightarrow [ 1 2 3 \underline { 4 } 5 7 4 ] \rightarrow [ 1 2 3 4 5 \underline { 3 } 7 4 ] $$$ third test case sequence already satisfy condition",['greedy'],800.0
1765/N,give a positive integer $$$ x $$$ apply follow operation number : remove one occurrence digit a way result number contain lead zero still a positive integer example $$$ <unknown> $$$ convert $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ 1012 $$$ $$$ 1014 $$$ ( note $$$ <unknown> $$$ a valid outcome ) ; $$$ 10 $$$ convert $$$ 1 $$$ ( $$$ 0 $$$ since positive ) task find minimum positive integer obtain $$$ x $$$ apply aforementioned operation exactly $$$ k $$$ time first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case first line test case contain a single integer $$$ x $$$ ( $$$ 1 \le x < 10^ { 500000 } $$$ ) second line contain a single integer $$$ k $$$ ( $$$ 0 \le k < |x| $$$ ) $$$ |x| $$$ length number $$$ x $$$ sum $$$ |x| $$$ test case exceed $$$ 500000 $$$ test case print one integer — minimum positive number obtain $$$ x $$$ apply operation exactly $$$ k $$$ time,['greedy'],1500.0
1776/A,one swerc judge a dog name boy besides a good competitive programmer boy love <unknown> air want walk least twice a day walk boy require $$$ 120 $$$ consecutive minutes two walk overlap one start soon previous one finish boy get accept problem today judge send $$$ n $$$ message swerc <unknown> server $$$ i $$$ -th message send $$$ a_i $$$ minutes midnight know walk boy judge send message send a message right right a walk possible judge walk boy least twice today ? note a day $$$ 1440 $$$ minutes a walk consider happen today start a minute $$$ s \ge 0 $$$ end right a minute $$$ e \le 1440 $$$ case must hold $$$ e - s = 120 $$$ every $$$ i = 1 \ 2 \ \dots \ n $$$ either $$$ a_i \le s $$$ $$$ a_i \ge e $$$ test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case descriptions $$$ t $$$ test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number message send judge second line test case contain $$$ n $$$ integers $$$ a_1 \ a_2 \ \dots \ a_n $$$ ( $$$ 0 \le a_1 < a_2 < <unknown> < a_n < 1440 $$$ ) — time message send ( minutes <unknown> midnight ) test case output one line contain $$$ \texttt { yes } $$$ possible boy walk least twice $$$ \texttt { } $$$ otherwise first test case judge send a message time multiple $$$ 100 $$$ ( exclude $$$ 0 $$$ ) impossible walk boy even second test case time $$$ 500 $$$ $$$ 1000 $$$ miss judge could walk boy instance time intervals $$$ [ <unknown> <unknown> ] $$$ $$$ [ <unknown> 1100 ] $$$ situation illustrate picture walk represent green intervals $$$ $$$ $$$ $$$ third test case time first test case $$$ 1000 $$$ miss judge could walk boy fourth test case boy could walk time intervals $$$ [ <unknown> 859 ] $$$ $$$ [ 859 <unknown> ] $$$,['greedy'],800.0
1799/C,give a string $$$ s $$$ reorder character form a string $$$ t $$$ define $$$ t _ { \mathrm { max } } $$$ lexicographical maximum $$$ t $$$ $$$ t $$$ reverse order give $$$ s $$$ determine lexicographically minimum value $$$ t _ { \mathrm { max } } $$$ reorder $$$ t $$$ $$$ s $$$ a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ one follow hold : first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case descriptions test case follow first line test case contain a string $$$ s $$$ ( $$$ 1 \leq |s| \leq 100000 $$$ ) $$$ s $$$ consist lowercase english letter guarantee sum $$$ |s| $$$ test case exceed $$$ 100000 $$$ test case print lexicographically minimum value $$$ t _ { \mathrm { max } } $$$ reorder $$$ t $$$ $$$ s $$$ first test case one reorder $$$ s $$$ namely ` ` a '' second test case three reorder $$$ s $$$ lexicographical minimum $$$ t _ { \mathrm { max } } $$$ case ` ` aba '',['greedy'],1700.0
1800/B,kristina a string $$$ s $$$ length $$$ n $$$ consist lowercase uppercase latin letter pair lowercase letter match uppercase letter kristina get $$$ 1 $$$ burl however pair character overlap character one pair example string $$$ s $$$ = ` ` aaaabacacbe '' get a burl follow character pair : kristina want get burl string go perform $$$ k $$$ operations one operation : example $$$ k $$$ = 2 $$$ s $$$ = ` ` aaaabacacbe '' perform one operation : choose $$$ s_3 $$$ = ` ` a '' make uppercase get another pair $$$ s_3 $$$ = ` ` a '' $$$ s_8 $$$ = ` ` a '' find maximum number burl kristina get string first line input data contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) $$$ k $$$ ( $$$ 0 \le k \le n $$$ ) — number character string maximum number operations perform second line test case contain a string $$$ s $$$ length $$$ n $$$ consist lowercase uppercase latin letter guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print exactly one integer a separate line : maximum number burl kristina get string $$$ s $$$ first test case explain problem statement second test case possible get pair perform number operations,['greedy'],1000.0
1805/B,give a string $$$ s $$$ apply operation string exactly : choose index $$$ i $$$ move character $$$ s_i $$$ begin string ( remove old position ) example apply operation index $$$ <unknown> $$$ string ` ` <unknown> '' number $$$ 1 $$$ get string ` ` <unknown> '' lexicographically minimal $$$ ^ { \dagger } $$$ string obtain operation ? $$$ ^ { \dagger } $$$ a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ length follow hold : test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 10 ^ 5 $$$ ) — length string second line test case contain string $$$ s $$$ length $$$ n $$$ consist lowercase english letter guarantee sum $$$ n $$$ test case exceed $$$ 10 ^ 5 $$$ test case a separate line print lexicographically smallest string obtain apply operation original string exactly first test case need move last character begin second case need move second letter ` ` a '' third set need apply operation $$$ i=1 $$$ string change,['greedy'],800.0
1807/B,mihai bianca play bag candy a row $$$ a $$$ $$$ n $$$ bag candy $$$ i $$$ -th bag $$$ a_i $$$ candy bag give players order first bag $$$ n $$$ -th bag a bag even number candy mihai grab bag otherwise bianca grab bag a bag grab number candy get add total number candy player take mihai want show want reorder array moment ( except start candy ) mihai strictly candy bianca help mihai find a reorder exist first line input contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100 $$$ ) — number bag array second line test case contain $$$ n $$$ space - separated integers $$$ a_i $$$ ( $$$ 1 \leq a_i \leq 100 $$$ ) — number candy bag test case output ` ` yes '' ( without quote ) a reorder exist ` ` '' ( without quote ) otherwise output answer case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive answer ) first test case mihai reorder array follow : $$$ [ 4 1 2 3 ] $$$ process proceed follow :,['greedy'],800.0
1825/A,luotianyi give a palindrome $$$ ^ { \dagger } $$$ string $$$ s $$$ want find length longest non - empty subsequence $$$ ^ { \ddagger } $$$ $$$ s $$$ a palindrome string subsequence output $$$ -1 $$$ instead $$$ ^ { \dagger } $$$ a palindrome a string read backward forward example string ` ` z '' ` ` aaa '' ` ` aba '' ` ` abccba '' palindromes string ` ` codeforces '' ` ` reality '' ` ` ab '' $$$ ^ { \ddagger } $$$ a string $$$ a $$$ a subsequence a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character $$$ b $$$ example string ` ` a '' ` ` aaa '' ` ` bab '' subsequences string ` ` abaab '' string ` ` codeforces '' ` ` bbb '' ` ` h '' test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case description test case follow first line test case contain a single string $$$ s $$$ ( $$$ 1 \le |s| \le 50 $$$ ) consist lowercase english letter — string luotianyi give 's guarantee $$$ s $$$ a palindrome string test case output a single integer — length longest non - empty subsequence a palindrome string subsequence output $$$ -1 $$$ first test case ` ` abcaba '' a subsequence ` ` abacaba '' delete third letter ` ` abacaba '' get ` ` abcaba '' ` ` abcaba '' a palindrome string prove ` ` abcaba '' example longest subsequences ` ` abacaba '' n't palindrome answer $$$ 6 $$$ second test case get ` ` a '' ` ` aa '' palindrome string answer $$$ -1 $$$,['greedy'],800.0
1837/B,give a string $$$ s $$$ length $$$ n $$$ character either < > array $$$ a $$$ consist $$$ n+1 $$$ elements compatible string $$$ s $$$ every $$$ i $$$ $$$ 1 $$$ $$$ n $$$ character $$$ s_i $$$ represent result compare $$$ a_i $$$ $$$ a _ { i+1 } $$$ i. e. : example array $$$ [ 1 2 5 4 2 ] $$$ compatible string < < > > array compatible string example $$$ [ 13 37 42 37 13 ] $$$ cost array number different elements example cost $$$ [ 1 2 5 4 2 ] $$$ $$$ 4 $$$ ; cost $$$ [ 13 37 42 37 13 ] $$$ $$$ 3 $$$ calculate minimum cost among array compatible give string $$$ s $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case test case consist two line : test case print one integer — minimum cost among array compatible give string $$$ s $$$ first test case example array $$$ [ 13 37 42 37 13 ] $$$ second test case example array $$$ [ 42 37 13 37 42 ] $$$,['greedy'],900.0
1607/G,a know <unknown> prepare $$$ n $$$ dish : $$$ i $$$ -th dish consist $$$ a_i $$$ grams fish $$$ b_i $$$ grams meat <unknown> organizers estimate balance $$$ n $$$ dish follow balance equal absolute value difference total mass fish total mass meat <unknown> balance equal $$$ <unknown> _ { i=1 } ^n a_i - \sum\limits _ { i=1 } ^n <unknown> $$$ smaller balance better order improve balance a taster invite eat exactly $$$ m $$$ grams food dish dish taster determine separately much fish much meat eat condition eat exactly $$$ m $$$ grams dish total determine much type food taster eat dish value balance minimal possible several correct answer may choose first line input data contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case test case 's description precede a <unknown> line next come a line contain integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 200000 $$$ ; $$$ 0 \leq m \leq 1000000 $$$ ) next $$$ n $$$ line describe dish $$$ i $$$ -th contain a pair integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 0 \leq a_i b_i \le 1000000 $$$ ) — mass fish meat $$$ i $$$ -th dish guarantee possible eat $$$ m $$$ grams food dish word $$$ m \leq <unknown> $$$ $$$ i $$$ $$$ 1 $$$ $$$ n $$$ inclusive sum $$$ n $$$ value test case test exceed $$$ 200000 $$$ test case print first line minimal balance value achieve eat exactly $$$ m $$$ grams food dish print $$$ n $$$ line describe a way : $$$ i $$$ -th line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \leq x_i \leq a_i $$$ ; $$$ 0 \leq y_i \leq b_i $$$ ; $$$ <unknown> = m $$$ ) $$$ x_i $$$ many grams fish taster eat $$$ i $$$ -th meal $$$ y_i $$$ many grams meat several ways achieve a minimal balance find,['greedy'],2200.0
1754/A,work quality control department technical support a large company job make sure client issue <unknown> today need check a copy a dialog a client a technical support manager accord rule work message client must follow one several message answer a support manager however sometimes clients ask question quickly manager 's answer old question appear client ask new question due <unknown> <unknown> full text message available order message visible well type message : a customer question a response technical support manager guarantee dialog begin question client determine dialog may correspond rule work describe rule certainly <unknown> test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — total number message dialog second line test case consist $$$ n $$$ character ` ` q '' ` ` a '' describe type message dialog chronological order character ` ` q '' denote message client question character ` ` a '' — message technical support manager answer guarantee first character line equal ` ` q '' test case print ` ` yes '' ( without quote ) dialog may correspond rule work ` ` '' ( without quote ) otherwise first test case two question client follow two <unknown> 's answer dialog may correspond rule work second test case one first two question answer third test case technical support manager send two message answer message client,['greedy'],800.0
1749/B,play a computer game pass current level kill a big horde monsters horde $$$ n $$$ monsters stand row number $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th monster $$$ a_i $$$ health a special ` ` death 's <unknown> '' spell strength $$$ b_i $$$ attach go kill one one take exactly $$$ h $$$ second kill a monster health $$$ h $$$ $$$ i $$$ -th monster die cast spell increase health neighbor $$$ b_i $$$ ( neighbor $$$ j $$$ -th monster row monsters place $$$ j - 1 $$$ $$$ j + 1 $$$ first last monsters one neighbor ) monster kill row shrink former neighbor become adjacent ( one die one affect spell ) example imagine a situation $$$ 4 $$$ monsters health $$$ a = [ 2 6 7 3 ] $$$ spell $$$ b = [ 3 6 0 5 ] $$$ one ways get rid monsters show : a result kill monsters $$$ 6 + 13 + 8 + 6 $$$ $$$ = $$$ $$$ 33 $$$ second note 's example may fastest way get rid monsters minimum time require kill monsters row ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number monsters row second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — initial health correspond monsters third line contain $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ 0 \le b_i \le 1000000000 $$$ ) $$$ b_i $$$ strength spell $$$ i $$$ -th monster 's guarantee sum $$$ n $$$ n't exceed $$$ 200000 $$$ test case print one integer — minimum possible total time kill monsters first test case one monster kill $$$ 10 $$$ second second test case 's optimal kill first monster last monster middle one take $$$ 100 + 100 + ( 1 + 1 + 1 ) $$$ $$$ = $$$ $$$ <unknown> $$$ second third test case 's optimal kill first monster third one fourth one finally second one take $$$ 2 + 7 + ( 3 + 0 ) + ( 3 + 6 + 5 ) $$$ $$$ = $$$ $$$ 26 $$$ second,['greedy'],900.0
1729/B,polycarp a string $$$ s $$$ consist lowercase latin letter encode use follow algorithm go letter string $$$ s $$$ leave right letter polycarp consider number alphabet : example string $$$ s $$$ code polycarp encode string follow : thus code string code <unknown> . give a string $$$ t $$$ result encode string $$$ s $$$ task decode ( get original string $$$ s $$$ $$$ t $$$ ) first line input contain integer $$$ q $$$ ( $$$ 1 \le q \le 10000 $$$ ) — number test case input descriptions test case follow first line description test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — length give code second line description test case contain a string $$$ t $$$ length $$$ n $$$ — give code guarantee exist a string lowercase latin letter a result encode string $$$ t $$$ obtain test case output require string $$$ s $$$ — string give string $$$ t $$$ result encode guarantee a string always exist show a string always unique first test case explain second test case answer aj indeed number letter a equal $$$ 1 $$$ 1 append code number letter j $$$ 10 $$$ 100 append code result code 1100 . zero third test case mean number letter less $$$ 10 $$$ encode one digit original string abacaba fourth test case string $$$ s $$$ equal letter l number $$$ 12 $$$ encode 120 . indeed <unknown>,['greedy'],800.0
1717/C,"give array integer $$$ a_1 a_2 \ldots a_n $$$ one operation make $$$ a_i : = a_i + 1 $$$ $$$ i < n $$$ $$$ a_i \leq a _ { i + 1 } $$$ $$$ i = n $$$ $$$ a_i \leq a_1 $$$ need check whether array $$$ a_1 a_2 \ldots a_n $$$ become equal array $$$ b_1 b_2 \ldots b_n $$$ number operations ( possibly zero ) two array $$$ a $$$ $$$ b $$$ length $$$ n $$$ call equal $$$ a_i = b_i $$$ integers $$$ i $$$ $$$ 1 $$$ $$$ n $$$ input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 40000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) – length array second line test case contain $$$ n $$$ integers $$$ a_1 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) – elements array $$$ a $$$ third line test case contain $$$ n $$$ integers $$$ b_1 \ldots b_n $$$ ( $$$ 1 \le b_i \le 1000000000 $$$ ) – elements array $$$ b $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output ` ` yes '' get array $$$ b $$$ otherwise output ` ` '' may print letter case ( example ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive answer ) first test case array $$$ a $$$ already equal array $$$ b $$$ second test case ca n't get array $$$ b $$$ need decrease $$$ a_1 $$$ fifth test case apply operations order elements indices $$$ 4 3 <unknown> $$$ get array $$$ [ <unknown> ] $$$ , apply operations order elements indices $$$ <unknown> $$$ already get array $$$ [ <unknown> ] $$$",['greedy'],1300.0
1616/B,"a string $$$ s_1 s_2 \ldots s_n $$$ stand leave string look right want choose index $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) place a mirror $$$ k $$$ -th letter see $$$ s_1 s_2 \ldots s_k s_k s _ { k - 1 } \ldots s_1 $$$ lexicographically smallest string see ? a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ one follow hold : first line input contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 10\,000 $$$ ) : number test case next $$$ t $$$ line contain description test case two line per a test case first line give one integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) : length string second line contain string $$$ s $$$ consist $$$ n $$$ lowercase english character guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print lexicographically smallest string see first test case choose $$$ k = 1 $$$ obtain ` ` cc '' second test case choose $$$ k = 3 $$$ obtain ` ` <unknown> '' third test case choose $$$ k = 1 $$$ obtain ` ` aa '' fourth test case choose $$$ k = 1 $$$ obtain ` ` bb ''",['greedy'],1100.0
1626/B,give a decimal representation integer $$$ x $$$ without lead zero perform follow reduction exactly : take two neighbor digits $$$ x $$$ replace sum without lead zero ( sum $$$ 0 $$$ 's represent a single $$$ 0 $$$ ) example $$$ x = <unknown> $$$ possible <unknown> : 's largest number obtain ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases testcase consist a single integer $$$ x $$$ ( $$$ 10 \le x < 10^ { 200000 } $$$ ) $$$ x $$$ n't contain lead zero total length decimal representations $$$ x $$$ testcases n't exceed $$$ 200000 $$$ testcase print a single integer — largest number obtain reduction apply exactly number contain lead zero first testcase example already explain statement second testcase one possible reduction : first second digits,['greedy'],1100.0
1631/A,"give two array $$$ a $$$ $$$ b $$$ $$$ n $$$ positive integers apply follow operation number time : find minimum possible value $$$ \max ( a_1 a_2 \ldots a_n ) \cdot \max ( b_1 b_2 \ldots b_n ) $$$ get apply operation number time ( possibly zero ) input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1\le n\le 100 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 10\,000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element array $$$ a $$$ third line test case contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 1 \le b_i \le 10\,000 $$$ ) $$$ b_i $$$ $$$ i $$$ -th element array $$$ b $$$ test case print a single integer minimum possible value $$$ \max ( a_1 a_2 \ldots a_n ) \cdot \max ( b_1 b_2 \ldots b_n ) $$$ get apply operation number time first test apply operations indices $$$ 2 $$$ $$$ 6 $$$ $$$ a = [ 1 4 6 5 1 5 ] $$$ $$$ b = [ 3 2 3 2 2 2 ] $$$ $$$ \max ( 1 4 6 5 1 5 ) \cdot \max ( 3 2 3 2 2 2 ) = 18 = 18 $$$ second test matter apply operations $$$ a = [ 3 3 3 ] $$$ $$$ b = [ 3 3 3 ] $$$ always hold answer $$$ \max ( 3 3 3 ) \cdot \max ( 3 3 3 ) = 9 = 9 $$$ third test apply operation index $$$ 1 $$$ $$$ a = [ 2 2 ] $$$ $$$ b = [ 1 1 ] $$$ answer $$$ \max ( 2 2 ) \cdot \max ( 1 1 ) = 2 = 2 $$$",['greedy'],800.0
253/A,n boys m girls study class stand a line boys girls alternate much possible let 's assume position line index leave right number 1 n + m. number integers i ( 1 ≤ i < n + m ) position index i i + 1 contain children different <unknown> ( position i a girl position i + 1 a boy vice versa ) must large possible help children tell form line single line input contain two integers n m ( 1 ≤ n m ≤ 100 ) separate a space print a line n + m character print i - th position line character ` ` b '' i - th position arrangement a boy ` ` g '' a girl course number character ` ` b '' equal n number character ` ` g '' equal m. multiple optimal solutions print first sample another possible answer <unknown> second sample answer <unknown> also optimal,['greedy'],1100.0
1633/B,"give a string $$$ s $$$ consist character ' 0 ' ' 1 ' choose a contiguous substring $$$ s $$$ remove occurrences character a strict minority substring , amount ' 0 's substring strictly smaller amount ' 1 's remove occurrences ' 0 ' substring amount ' 1 's strictly smaller amount ' 0 's remove occurrences ' 1 ' amount nothing apply operation exactly maximum amount character remove ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number testcases line testcase contain a non - empty string $$$ s $$$ consist character ' 0 ' ' 1 ' length $$$ s $$$ n't exceed $$$ 200000 $$$ total length string $$$ s $$$ testcases n't exceed $$$ 200000 $$$ testcase print a single integer — maximum amount character remove apply operation exactly first testcase choose substrings ` ` 0 '' ` ` 1 '' ` ` 01 '' ` ` 0 '' amount ' 0 ' $$$ 1 $$$ amount ' 1 ' $$$ 0 $$$ ' 1 ' a strict minority thus occurrences remove substring however since $$$ 0 $$$ nothing change ` ` 1 '' ` ` 01 '' neither ' 0 ' ' 1 ' a strict minority thus nothing change way remove character second testcase choose substring ` ` <unknown> '' contain $$$ 5 $$$ character ' 0 ' $$$ 6 $$$ character ' 1 ' ' 0 ' a strict minority thus remove occurrences exist substrings produce answer third testcase choose substring ` ` <unknown> '' contain $$$ 6 $$$ character ' 0 ' $$$ 3 $$$ character ' 1 ' ' 1 ' a strict minority thus remove occurrences",['greedy'],800.0
522/C,"polycarp fly airplane finally favorite time — <unknown> <unknown> company stewardess give food consecutively passengers 1 - th one last one polycarp sit seat m mean m - th person get food flight menu k dish total polycarp board flight time count number portion dish board thus know value a1 a2 ... ak ai number portion i - th dish stewardess already give food m - 1 passengers give polycarp a polite smile ask would prefer 's polycarp realize might run dish moment m - 1 passengers ahead notice dish give besides 's hear strange <unknown> m - 1 passengers ahead similar phrase ' i ' m disappoint ' happen a passenger ask dish stewardess give a polite smile say run dish case passenger need choose dish available polycarp hear sound a passenger mean passenger choose dish first try help polycarp find dish : whether could run dish moment <unknown> serve dish definitely available test problem consist one input set first go a string contain a single integer t ( 1 ≤ t ≤ 100 000 ) — number input data set test set follow set precede empty line first line set input contain integers m k ( 2 ≤ m ≤ 100 000 1 ≤ k ≤ 100 000 ) — number polycarp 's seat number dish respectively second line contain a sequence k integers a1 a2 ... ak ( 1 ≤ ai ≤ 100 000 ) ai initial number portion i - th dish m - 1 line follow line contain description polycarp 's observations give food a passenger sit front : j - th line contain a pair integers tj rj ( 0 ≤ tj ≤ k 0 ≤ rj ≤ 1 ) tj number dish give j - th passenger ( 0 polycarp n't notice dish give passenger ) rj — a 1 a 0 depend whether j - th passenger n't disappoint respectively know sum ai equal least m , polycarp definitely get dish even last thing want guarantee data consistent sum m input set n't exceed 100 000 . sum k input set n't exceed 100 000 . input set print answer a single line print a string k letter ` ` y '' ` ` n '' letter ` ` y '' position i print could run i - th dish time stewardess start serve polycarp first input set depend choice second passenger situation could develop different ways : thus answer ` ` <unknown> '' second input set example follow possible scenario first first passenger take third dish second passenger take second dish , third passenger ask third dish available make disappoint <unknown> end second dish fourth passenger take fourth dish polycarp end choice first fourth fifth dish <unknown> another possible scenario time stewardess come polycarp run either first fifth dish ( happen one dish take second passenger ) easy see enough fourth dish polycarp always count thus answer ` ` <unknown> ''",['greedy'],2100.0
1154/D,a robot stay $$$ <unknown> $$$ $$$ ox $$$ axis walk $$$ x = n $$$ control robot control go robot a battery accumulator a <unknown> <unknown> $$$ i $$$ -th segment path ( $$$ x = i-1 $$$ $$$ x = i $$$ ) expose sunlight array $$$ s $$$ denote segment expose sunlight : segment $$$ i $$$ expose $$$ s_i = 1 $$$ otherwise $$$ s_i = 0 $$$ robot one battery capacity $$$ b $$$ one accumulator capacity $$$ a $$$ segment choose type energy <unknown> robot use go next point ( either battery accumulator ) robot go use battery current charge battery decrease one ( robot ca n't use battery charge zero ) robot go use accumulator current charge accumulator decrease one ( robot also ca n't use accumulator charge zero ) current segment expose sunlight robot go use battery charge accumulator increase one ( course charge ca n't become higher 's maximum capacity ) accumulator use pass segment charge decrease 1 matter segment expose understand always possible walk $$$ x = n $$$ want robot go far possible find maximum number segment distance robot pass control optimally first line input contain three integers $$$ n b a $$$ ( $$$ 1 \le n b a \le 200000 $$$ ) — robot 's destination point battery capacity accumulator capacity respectively second line input contain $$$ n $$$ integers $$$ s_1 s_2 \dots s_n $$$ ( $$$ 0 \le s_i \le 1 $$$ ) $$$ s_i $$$ $$$ 1 $$$ $$$ i $$$ -th segment distance expose sunlight $$$ 0 $$$ otherwise print one integer — maximum number segment robot pass control optimally first example robot go first segment use accumulator charge level become $$$ <unknown> $$$ $$$ a=0 $$$ second segment pass use battery charge level become $$$ b=1 $$$ $$$ a=1 $$$ third segment pass use accumulator charge level become $$$ b=1 $$$ $$$ a=0 $$$ fourth segment pass use battery charge level become $$$ <unknown> $$$ $$$ a=1 $$$ fifth segment pass use accumulator second example robot go maximum number segment use battery two time accumulator one time order,['greedy'],1500.0
1657/B,give four integers $$$ n $$$ $$$ b $$$ $$$ x $$$ $$$ y $$$ build a sequence $$$ a_0 a_1 a_2 \dots a_n $$$ $$$ a_0 = 0 $$$ $$$ i \ge 1 $$$ choose : goal build a sequence $$$ a $$$ $$$ a_i \le b $$$ $$$ i $$$ $$$ \sum\limits _ { i=0 } ^ { n } { a_i } $$$ maximum possible first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case next $$$ t $$$ case follow first line test case contain four integers $$$ n $$$ $$$ b $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 1 \le b x y \le 1000000000 $$$ ) 's guarantee total sum $$$ n $$$ n't exceed $$$ 200000 $$$ test case print one integer — maximum possible $$$ \sum\limits _ { i=0 } ^ { n } { a_i } $$$ first test case optimal sequence $$$ a $$$ $$$ [ 0 1 2 3 4 5 ] $$$ second test case optimal sequence $$$ a $$$ $$$ [ 0 1000000000 0 1000000000 0 1000000000 0 1000000000 ] $$$ third test case optimal sequence $$$ a $$$ $$$ [ 0 -3 -6 1 -2 ] $$$,['greedy'],800.0
1675/E,give a string $$$ s $$$ lowercase latin letter follow operation use : give integer $$$ k $$$ — maximum number operations perform find minimum lexicographically possible string obtain perform $$$ k $$$ operations string $$$ a = a_1a_2 \dots a_n $$$ lexicographically smaller string $$$ b = <unknown> \dots b_n $$$ exist index $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) $$$ a_1 = b_1 $$$ $$$ a_2 = b_2 $$$ ... $$$ a _ { k-1 } = b _ { k-1 } $$$ $$$ a_k < b_k $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — the number test case test follow descriptions test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le k \le 1000000000 $$$ ) — size string $$$ s $$$ maximum number operations perform string $$$ s $$$ second line test case contain a string $$$ s $$$ length $$$ n $$$ consist lowercase latin letter guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output lexicographically minimal string obtain string $$$ s $$$ perform $$$ k $$$ operations,['greedy'],1500.0
1682/A,give a palindromic string $$$ s $$$ length $$$ n $$$ count number indices $$$ i $$$ $$$ ( 1 \le i \le n ) $$$ string remove $$$ s_i $$$ $$$ s $$$ still remain a palindrome example consider $$$ s $$$ = ` ` aba '' a palindrome a string read backward forward example ` ` <unknown> '' ` ` a '' ` ` <unknown> '' palindromes whereas ` ` codeforces '' ` ` <unknown> '' ` ` xy '' input consist multiple test case first line input contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000 ) $$$ — number test case description test case follow first line testcase contain a single integer $$$ n $$$ $$$ ( 2 \leq n \leq 100000 ) $$$ — length string $$$ s $$$ second line test case contain a string $$$ s $$$ consist lowercase english letter guarantee $$$ s $$$ a palindrome guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output a single integer — number indices $$$ i $$$ $$$ ( 1 \le i \le n ) $$$ string remove $$$ s_i $$$ $$$ s $$$ still remain a palindrome first test case describe statement second test case indices $$$ i $$$ result palindrome remove $$$ s_i $$$ $$$ 3 4 5 6 $$$ hence answer $$$ 4 $$$ third test case removal indices result ` ` d '' a palindrome hence answer $$$ 2 $$$,['greedy'],800.0
1686/A,give array $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ watch <unknown> film ` ` everything everywhere '' come follow operation one operation choose $$$ n-1 $$$ elements array replace arithmetic mean ( n't integer ) example array $$$ [ 1 2 3 1 ] $$$ get array $$$ [ 2 2 2 1 ] $$$ choose first three elements get array $$$ [ \frac { 4 } { 3 } \frac { 4 } { 3 } 3 \frac { 4 } { 3 } ] $$$ choose elements except third possible make elements array equal perform a finite number operations ? first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 50 $$$ ) — number integers second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 100 $$$ ) test case possible make elements equal number operations output $$$ \texttt { yes } $$$ otherwise output $$$ \texttt { } $$$ output $$$ \texttt { yes } $$$ $$$ \texttt { } $$$ case ( example string $$$ \texttt { yes } $$$ $$$ \texttt { yes } $$$ $$$ \texttt { yes } $$$ recognize a positive response ) first test case elements already equal second test case choose elements except third average $$$ \frac { 1 + 2 + 4 + 5 } { 4 } = 3 $$$ array become $$$ [ 3 3 3 3 3 ] $$$ 's possible show 's impossible make elements equal third fourth test case,['greedy'],800.0
1693/A,array length $$$ n $$$ initially element equal $$$ 0 $$$ a pointer locate first element follow two kinds operations number time ( possibly zero ) order : one additional rule do pointer first element give array $$$ a $$$ determine whether 's possible obtain $$$ a $$$ operations first line contain a single integer $$$ t $$$ $$$ ( 1\le t\le 1000 ) $$$ — number test case description test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 1\le n\le 2 \cdot 100000 ) $$$ — size array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ -1000000000 \le a_i \le 1000000000 $$$ ) — elements array guarantee sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print ` ` yes '' ( without quote ) 's possible obtain $$$ a $$$ operations ` ` '' ( without quote ) otherwise output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first test case obtain array operations pointer wo n't first element one way obtain array second test case show $$$ \langle \underline { 0 } 0 0 0\rangle \to \langle 1 \underline { 0 } 0 0 \rangle \to \langle \underline { 1 } -1 0 0\rangle \to \langle 2 \underline { -1 } 0 0\rangle \to \langle 2 0 \underline { 0 } 0\rangle \to \langle 2 \underline { 0 } -1 0\rangle \to \langle \underline { 2 } -1 -1 0\rangle $$$,['greedy'],1300.0
1696/B,"a collection integers $$$ s $$$ define $$$ \operatorname { mex } ( s ) $$$ smallest non - negative integer appear $$$ s $$$ nit cleaver decide destroy universe powerful <unknown> destroy universe snap finger several time universe represent a 1 - indexed array $$$ a $$$ length $$$ n $$$ nit snap finger follow operation array : say universe destroy $$$ 1\le i\le n $$$ $$$ a_i=0 $$$ hold find minimum number time nit need snap finger destroy universe , find minimum number operations nit need perform make elements array equal $$$ 0 $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1\le n\le 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a_n $$$ ( $$$ 0\le a_i\le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case print one integer — answer problem first test case $$$ 0 $$$ operations elements array already equal $$$ 0 $$$ second test case one optimal way operation $$$ l=2 $$$ $$$ r=5 $$$ third test case one optimal way operation twice respectively $$$ <unknown> $$$ $$$ r=4 $$$ $$$ l=2 $$$ $$$ <unknown> $$$ fourth test case one optimal way operation $$$ l=1 $$$ $$$ <unknown> $$$",['greedy'],900.0
1702/B,polycarp a poor memory day remember $$$ 3 $$$ different letter polycarp want write a non - empty string $$$ s $$$ consist lowercase latin letter take minimum number days many days able ? polycarp initially empty string add character end string example polycarp want write string <unknown> $$$ 2 $$$ days : polycarp want write string <unknown> $$$ 4 $$$ days : a give string $$$ s $$$ print minimum number days take polycarp write first line input data contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist a non - empty string $$$ s $$$ consist lowercase latin letter ( length string $$$ s $$$ exceed $$$ 200000 $$$ ) — string polycarp want construct guarantee sum string lengths $$$ s $$$ test case exceed $$$ 200000 $$$ test case print a single number — minimum number days take polycarp write string $$$ s $$$ memory,['greedy'],800.0
1702/D,let $$$ s $$$ a string lowercase latin letter price sum indices letter ( integer 1 26 ) include example price string <unknown> $$$ 1 + 2 + 3 + <unknown> $$$ string $$$ w $$$ integer $$$ p $$$ give remove minimal number letter $$$ w $$$ price become less equal $$$ p $$$ print result string note result string may empty delete arbitrary letter go a row price a give string $$$ w $$$ less equal $$$ p $$$ nothing need delete $$$ w $$$ must output note delete a letter $$$ w $$$ order remain letter preserve example delete letter e string test get <unknown> first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test follow descriptions $$$ t $$$ test case case consist two line first string $$$ w $$$ non - empty consist lowercase latin letter length exceed $$$ 2\cdot100000 $$$ second line contain integer $$$ p $$$ ( $$$ 1 \le p \le <unknown> $$$ ) guarantee sum string lengths $$$ w $$$ test case exceed $$$ 200000 $$$ output exactly $$$ t $$$ row $$$ i $$$ -th contain answer $$$ i $$$ -th set input data print longest string obtain $$$ w $$$ delete letter price less equal $$$ p $$$ several answer output note empty string — one possible answer case output empty string,['greedy'],1000.0
1714/C,find minimum number give sum digits $$$ s $$$ digits distinct ( i.e digits unique ) example $$$ <unknown> $$$ answer $$$ <unknown> $$$ minimum number digits different sum digits $$$ 20 $$$ ( $$$ 3 + 8 + <unknown> $$$ ) give $$$ s $$$ print require number first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 45 $$$ ) — number test case test case specify a line contain integer $$$ s $$$ ( $$$ 1 \le s \le 45 $$$ ) print $$$ t $$$ integers — answer give test case,['greedy'],800.0
1642/B,sam a <unknown> $$$ n $$$ children group decide create a team children play ` ` <unknown> : go 2 '' sam $$$ n $$$ power - ups $$$ i $$$ -th type $$$ a_i $$$ a child 's strength equal number different type among power - ups a team size $$$ k $$$ sam distribute $$$ n $$$ power - ups $$$ k $$$ children a way $$$ k $$$ children receive least one power - up power - up give someone integer $$$ k $$$ $$$ 1 $$$ $$$ n $$$ find minimum sum strengths a team $$$ k $$$ children sam get test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 300000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — type sam 's power - ups guarantee sum $$$ n $$$ test case exceed $$$ 300000 $$$ every test case print $$$ n $$$ integers $$$ k $$$ -th integer equal minimum sum strengths children team size $$$ k $$$ sam get one ways give power - ups minimise sum strengths first test case : one ways give power - ups minimise sum strengths second test case :,['greedy'],900.0
1666/D,"daisy love play game word recently play follow deletive edit word game daniel daisy pick a word example ` ` determine '' game turn daniel call a letter example ' e ' daisy remove first occurrence letter word get ` ` <unknown> '' next turn daniel call a letter example 'd ' daisy remove first occurrence get ` ` <unknown> '' continue ' i ' get ` ` <unknown> '' ' n ' get ` ` term '' 'd ' get ` ` <unknown> '' , daniel call letter ' e ' daisy get ` ` <unknown> '' way get word ` ` term '' start play word ` ` determine '' daisy curious get final word choice start give initial word play game zero turn task help figure first line input contain integer $$$ n $$$ — number test case ( $$$ 1 \le n \le 10\,000 $$$ ) follow $$$ n $$$ line contain test case test case consist two word $$$ s $$$ $$$ t $$$ separate a space word consist least one 30 uppercase english letter ; $$$ s $$$ daisy 's initial word game ; $$$ t $$$ final word daisy would like get end game output $$$ n $$$ line output — a single line test case output ` ` yes '' possible daisy get initial word $$$ s $$$ final word $$$ t $$$ play deletive edit game output ` ` '' otherwise",['greedy'],900.0
1153/C,"<unknown> soon say <unknown> japari kindergarten begin life japari primary school favorite math class teacher teach follow interest definitions a parenthesis sequence a string contain character ` ` ( ` ` ` ` ) '' a correct parenthesis sequence a parenthesis sequence transform a correct arithmetic expression insert character ` ` 1 '' ` ` + '' original character sequence example parenthesis sequence ` ` ( ) ( ) '' ` ` ( ( ) ) '' correct ( result expressions : ` ` ( 1 + 1 ) + ( 1 + 1 ) '' ` ` ( ( 1 + 1 ) +1 ) '' ) ` ` ) ( ` ` ` ` ) '' note empty string a correct parenthesis sequence definition define $$$ |s| $$$ length string $$$ s $$$ a strict prefix $$$ s [ <unknown> l ] $$$ $$$ ( 1\leq l < |s| ) $$$ a string $$$ s = s_1s_2\dots s _ { |s| } $$$ string $$$ s_1s_2\dots s_l $$$ note empty string whole string strict prefix string definition learn definitions come a new problem write a string $$$ s $$$ contain character ` ` ( ` ` ` ` ) '' ` ` ? ` ` go replace ` ` ? '' $$$ s $$$ independently one ` ` ( ` ` ` ` ) '' make strict prefix new sequence a correct parenthesis sequence new sequence a correct parenthesis sequence , a primary school student problem hard solve best friend help replace question mark ? many solutions acceptable first line contain a single integer $$$ |s| $$$ ( $$$ 1\leq |s|\leq 300000 $$$ ) length string second line contain a string $$$ s $$$ contain ` ` ( ` ` ` ` ) '' ` ` ? ` ` a single line contain a string represent answer many solutions acceptable answer print a single line contain ` ` : ( ` ` ( without quote ) prove solution second sample print ` ` : ( ` `",['greedy'],1700.0
1141/F1,problem give two <unknown> differ <unknown> constraints number $$$ n $$$ give array integers $$$ a [ 1 ] a [ 2 ] \dots a [ n ] $$$ a block a sequence contiguous ( consecutive ) elements $$$ a [ l ] a [ l+1 ] \dots a [ r ] $$$ ( $$$ 1 \le l \le r \le n $$$ ) thus a block define a pair indices $$$ ( l r ) $$$ find a set block $$$ ( l_1 r_1 ) ( l_2 r_2 ) \dots ( <unknown> <unknown> ) $$$ : write a program find a set block first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — length give array second line contain sequence elements $$$ a [ 1 ] a [ 2 ] \dots a [ n ] $$$ ( $$$ -100000 \le a_i \le 100000 $$$ ) first line print integer $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) follow $$$ k $$$ line contain block one per line line print a pair indices $$$ l_i r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) — bound $$$ i $$$ -th block print block order multiple answer print,['greedy'],1900.0
374/B,inna love digit 9 much 's ask dima write a small number consist <unknown> dima must <unknown> write a large number a consist digits 1 9 . inna want slightly alter number dima write end number contain many digits nine possible one move inna choose two adjacent digits a number sum equal 9 replace a single digit 9 . instance inna alter number 14545181 like : 14545181 → <unknown> → <unknown> → 19919 . also use method transform number 14545181 number 19991 . inna transform <unknown> get number 19919 19991 contain digits nine dima a programmer want find many distinct number contain many digits nine possible inna get write number help challenge task first line input contain integer a ( 1 ≤ a ≤ <unknown> ) number a n't zero a single line print a single integer — answer problem guarantee answer problem n't exceed <unknown> - 1 . please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier note <unknown> first sample inna get follow number : 369727 → 99727 → <unknown> 369727 → 99727 → <unknown> . second sample inna act like : <unknown> → <unknown> → <unknown>,['greedy'],1500.0
435/B,pasha a positive integer a without lead zero today decide number small make larger unfortunately operation pasha swap two adjacent decimal digits integer help pasha count maximum number get time make k swap single line contain two integers a k ( 1 ≤ a ≤ 1018 ; 0 ≤ k ≤ 100 ) print maximum number pasha get make k swap,['greedy'],1400.0
436/A,hero cut rope game a little monster name om nom love candy a coincidence ! also hero today 's problem one day om nom visit friend evan evan n candy two type ( fruit drop caramel drop ) i - th candy hang height hi centimeters floor house mass mi om nom want eat many candy possible begin om nom make x <unknown> high jump om nom eat a candy mass y get stronger height jump increase y centimeters maximum number candy om nom eat never eat two candy type a row ( om nom find bore ) ? first line contain two integers n x ( 1 ≤ n x ≤ 2000 ) — number sweets evan initial height om nom 's jump follow n line contain three integers ti hi mi ( 0 ≤ ti ≤ 1 ; 1 ≤ hi mi ≤ 2000 ) — type height mass i - th candy number ti equal 0 current candy a caramel drop otherwise a fruit drop print a single integer — maximum number candy om nom eat one possible ways eat 4 candy eat order : 1 5 3 2 . let 's assume follow scenario :,['greedy'],1500.0
457/B,piegirl ask implement two table join operation distribute database system minimize network traffic suppose want join two table a b. certain number row distribute different number partition table a distribute first cluster consist m partition partition index i ai row a. similarly second cluster contain table b n partition i - th one bi row b. one network operation copy one row partition partition end row a row b a partition row determine minimal number network operations achieve first line contain two integer number m n ( 1 ≤ m n ≤ 105 ) second line contain description first cluster m space separate integers ai ( 1 ≤ ai ≤ 109 ) similarly third line describe second cluster n space separate integers bi ( 1 ≤ bi ≤ 109 ) print one integer — minimal number copy operations first example make sense move row second partition second cluster achieve 2 + 6 + 3 = 11 <unknown> second example piegirl copy row b partition first cluster need <unknown> = 6 copy operations,['greedy'],1900.0
462/B,appleman n card card uppercase letter write toastman must choose k card appleman 's card appleman give toastman coin depend choose card formally toastman 's card i calculate much toastman 's card letter equal letter ith sum <unknown> a number coin appleman give toastman give description appleman 's card maximum number coin toastman get ? first line contain two integers n k ( 1 ≤ k ≤ n ≤ 105 ) next line contain n uppercase letter without space — i - th letter describe i - th card appleman print a single integer – answer problem first test example toastman choose nine card letter d one additional card letter card d get 9 coin additional card get 1 coin,['greedy'],1300.0
1554/A,"give $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ find maximum value $$$ max ( a_l a _ { l + 1 } \ldots a_r ) \cdot min ( a_l a _ { l + 1 } \ldots a_r ) $$$ pair $$$ ( l r ) $$$ integers $$$ 1 \le l < r \le n $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10\,000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) guarantee sum $$$ n $$$ test case n't exceed $$$ 300000 $$$ test case print a single integer — maximum possible value product statement let $$$ f ( l r ) = max ( a_l a _ { l + 1 } \ldots a_r ) \cdot min ( a_l a _ { l + 1 } \ldots a_r ) $$$ first test case maximum $$$ f ( 2 3 ) = 12 $$$ second test case maximum $$$ f ( 1 2 ) = f ( 1 3 ) = f ( 2 3 ) = 6 $$$",['greedy'],800.0
1551/B1,a simplify version problem b2 perhaps read problem b2 start solve b1 paul mary a favorite string $$$ s $$$ consist lowercase letter latin alphabet want paint use piece <unknown> two color : red green let 's call a color a string wonderful follow condition meet : e. g. consider a string $$$ s $$$ equal ` ` <unknown> '' one wonderful color string show figure paul mary want learn find a wonderful color string young need a hint help find $$$ k $$$ — number red ( green number equal ) letter a wonderful color first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case $$$ t $$$ test case follow test case consist one non - empty string $$$ s $$$ consist lowercase letter latin alphabet number character string n't exceed $$$ 50 $$$ test case output a separate line contain one non - negative integer $$$ k $$$ — number letter paint red a wonderful color first test case contain string statement one wonderful color show figure 's wonderful color contain $$$ 3 $$$ red letter total number paint symbols exceed string 's length string second test case paint follow let 's paint first occurrence letter ` ` c '' ` ` o '' ` ` e '' red second ones green let 's paint letter ` ` d '' ` ` f '' red ` ` r '' ` ` s '' green every letter paint red green hence answer better $$$ 5 $$$ n't exist third test case contain string distinct letter paint set character red long size set n't exceed half size string maximum possible fourth test case contain a single letter paint red letter able paint green fifth test case contain a string identical letter 's way paint one letter red,['greedy'],800.0
1635/B,give array $$$ a $$$ size $$$ n $$$ element array integer $$$ 1 $$$ $$$ 1000000000 $$$ perform several operations array operation replace element array integer $$$ 1 $$$ $$$ 1000000000 $$$ output minimum number operations need result array n't contain local maximums result array operations element $$$ a_i $$$ a local maximum strictly larger neighbor ( $$$ a_i > a _ { i - 1 } $$$ $$$ a_i > a _ { i + 1 } $$$ ) since $$$ a_1 $$$ $$$ a_n $$$ one neighbor never a local maximum test contain multiple test case first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10000 ) $$$ — number test case $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 2 \leq n \leq 2 \cdot 100000 ) $$$ — size array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 1 \leq a_i \leq 1000000000 ) $$$ elements array guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case first output a line contain a single integer $$$ m $$$ — minimum number operations require <unknown> a line consist $$$ n $$$ integers — result array operations note array differ exactly $$$ m $$$ elements initial array multiple answer print first example array contain local maximum n't need perform operations second example change $$$ a_2 $$$ $$$ 3 $$$ array n't local maximums,['greedy'],800.0
1634/A,give a string $$$ s $$$ length $$$ n $$$ a number $$$ k $$$ let 's denote $$$ rev ( s ) $$$ reverse string $$$ s $$$ ( i.e $$$ rev ( s ) = s_n s _ { n-1 } ... s_1 $$$ ) apply one two kinds operations string : many different string get a result perform exactly $$$ k $$$ operations ( possibly different kinds ) original string $$$ s $$$ ? statement denote concatenation string $$$ s $$$ $$$ t $$$ $$$ s + t $$$ word $$$ s + t = s_1 s_2 ... s_n t_1 t_2 ... t_m $$$ $$$ n $$$ $$$ m $$$ lengths string $$$ s $$$ $$$ t $$$ respectively first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case next $$$ 2 \cdot t $$$ line contain $$$ t $$$ test case : first line a test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100 $$$ $$$ 0 \le k \le 1000 $$$ ) — length string number operations respectively second string a test case contain one string $$$ s $$$ length $$$ n $$$ consist lowercase latin letter test case print answer ( number different string get exactly $$$ k $$$ operations ) a separate line show answer exceed $$$ 1000000000 $$$ give constraints first test case example : first operation string $$$ s $$$ become either aabbaa <unknown> second operation 2 possibilities $$$ s $$$ : <unknown> <unknown>,['greedy'],800.0
464/A,paul hat palindromes assume string s tolerable character one first p letter english alphabet s n't contain palindrome contiguous substring length 2 paul find a tolerable string s length n. help find lexicographically next tolerable string length else state string exist first line contain two space - separated integers : n p ( 1 ≤ n ≤ 1000 ; 1 ≤ p ≤ 26 ) second line contain string s consist n small english letter guarantee string tolerable ( accord definition ) lexicographically next tolerable string length exist print otherwise print ` ` '' ( without quote ) string s lexicographically larger ( simply larger ) string t length number i s1 = t1 ... si = ti si + 1 > ti + 1 . lexicographically next tolerable string lexicographically minimum tolerable string larger give one a palindrome a string read forward reverse,['greedy'],1700.0
523/C,"a martian boy name s — get name quite recently parent come age birthday enjoy look name everywhere see obtain name string remove zero letter ( remain letter remain order ) get happy example s= « aba » string « <unknown> » « aabbaa » « <unknown> » make happy string « <unknown> » « <unknown> » « <unknown> » however rather happy love twice much happy twice ! , get string t a present want cut two part ( leave part right part ) part make happy help s determine number distinct ways cut give string t two part require manner first line contain string s consist lowercase english letter length string s 1 1000 letter second line contain string t also consist lowercase english letter length string t 1 106 letter print seek number ways cut string t two part make s happy",['greedy'],1400.0
527/B,ford <unknown> get a job a <unknown> developer a small company make <unknown> current work task create a search engine website company development process need write a <unknown> compare string s t equal length ` ` similar '' a brief search internet learn ham distance two string s t length define number position s t different character example ham distance word ` ` permanent '' ` ` <unknown> '' two word differ fourth sixth letter moreover search information also notice modern search engines powerful <unknown> correct errors request improve quality search ford n't know much human <unknown> assume common mistake a request swap two arbitrary letter string ( necessarily adjacent ) want write a function determine two letter swap string s ham distance a new string s string t would small possible otherwise determine a replacement reduce distance string help ! first line contain integer n ( 1 ≤ n ≤ 200 000 ) — length string s t. second line contain string s. third line contain string t. line contain lowercase latin letter first line print number x — minimum possible ham distance string s t swap one pair letter s. second line either print index i j ( 1 ≤ i j ≤ n i ≠ j ) reach minimum possible distance possible swap letter position i j print ` ` -1 -1 '' necessary swap character multiple possible answer print second test acceptable print i = 2 j = 3,['greedy'],1500.0
545/B,little susie love string today calculate distance susie a small girl string contain digits zero one use definition ham distance : define distance two string s t length consist digits zero one number position i si n't equal ti besides everything else susie love symmetry want find two string s t length n string p length n distance p s equal distance p t. 's time susie go bed help find string p state impossible first line contain string s length n. second line contain string t length n. length string n within range 1 105 . guarantee string contain digits zero one print a string length n consist digits zero one meet problem statement string exist print a single line ` ` impossible '' ( without quote ) multiple possible answer print first sample different answer possible namely — <unknown> 0011 0110 <unknown> 1000 1001 1100 <unknown>,['greedy'],1100.0
556/A,andrewid android a galaxy - famous detective free time like think string contain zero ones think a string length n consist zero ones consider follow operation : choose two adjacent position string one contain 0 contain 1 allow remove two digits string obtain a string length n - 2 a result andreid think minimum length string remain apply describe operation several time ( possibly zero ) ? help calculate number first line input contain a single integer n ( 1 ≤ n ≤ 2·105 ) length string andreid second line contain string length n consist zero ones output minimum length string may remain apply describe operations several time first sample test possible change string like follow : second sample test possible change string like follow : third sample test possible change string like follow :,['greedy'],900.0
568/C,live byteland good enough begin good king decide please subject introduce a national language gather best wise men send expedition <unknown> countries would find a language design time wise men return trip even <unknown> lock six months <unknown> room say king : ` ` a lot different languages almost letter divide vowels consonants ; a word vowels consonants must combine correctly ` ` many rule exceptions language <unknown> <unknown> ! propose introduce a set formal rule combine vowels consonants include language word satisfy rule compose word : give string s length n necessarily a correct word new language among word language lexicographically smaller string s find minimal one <unknown> order first line contain a single line consist letter ' v ' ( vowel ) ' c ' ( consonant ) determine letter vowels letter consonants length string l size alphabet new language ( 1 ≤ l ≤ 26 ) first l letter english alphabet use letter alphabet new language i - th character string equal ' v ' correspond letter a vowel otherwise a consonant second line contain two integers n m ( 1 ≤ n ≤ 200 0 ≤ m ≤ 4n ( n - 1 ) ) — number letter a single word number rule correspondingly next m line describe m rule language follow format : pos1 t1 pos2 t2 ( 1 ≤ pos1 pos2 ≤ n pos1 ≠ pos2 ' v ' ' c ' } ) last line contain string s length n consist first l small letter english alphabet guarantee two rule print a smallest word a language lexicographically smaller s. word exist ( example language word ) print ` ` -1 '' ( without quote ) first test word ` ` aa '' a word language word ` ` ab '' second test four possibilities word ` ` bb '' a word a language word lexicographically less answer third test due last rule ` ` abac '' n't belong language ( ` ` a '' a vowel ` ` c '' a consonant ) word prefix ` ` ab '' meet give rule ` ` <unknown> '' less ` ` abac '' answer ` ` <unknown> '',['greedy'],2600.0
351/E,jeff 's friends know full well boy like get sequence array birthday thus jeff get sequence p1 p2 ... pn birthday jeff hat inversions sequence inversion sequence a1 a2 ... a pair index i j ( 1 ≤ i < j ≤ n ) inequality ai > aj hold jeff multiply number sequence p -1 . want number inversions sequence minimum help jeff find minimum number inversions manage get first line contain integer n ( 1 ≤ n ≤ 2000 ) next line contain n integers — sequence p1 p2 ... pn ( <unknown> ≤ 105 ) number separate space a single line print answer problem — minimum number inversions jeff get,['greedy'],2200.0
587/A,recently duff practice weight lift a hard practice malek give a task give a sequence weight weight i - th <unknown> pound step duff lift remain weight throw away 's weight leave malek ask minimize number step duff a competitive program fan 's step lift throw away a sequence weight 2a1 ... 2ak exist a non - negative integer x 2a1 + <unknown> + ... + 2ak = 2x i. e. sum number a power two duff a competitive program fan a programmer 's ask help help minimize number step first line input contain integer n ( 1 ≤ n ≤ 106 ) number weight second line contain n integers w1 ... wn separate space ( 0 ≤ wi ≤ 106 1 ≤ i ≤ n ) power two form weight value print minimum number step a single line first sample case : one optimal way would throw away first three first step rest second step also 's possible one step sum a power two second sample case : optimal way throw away one weight step 's possible less 4 step 's subset weight one weight sum equal a power two,['greedy'],1500.0
333/A,"gerald sell state secrets <unknown> secrets cost : n mark state secrets gerald sell paper money coin coin positive integer denominations power three : 1 mark 3 mark 9 mark 27 mark coin denominations course gerald like get money without change <unknown> respect try give desire sum without change possible always happen one day unlucky buyer come desire sum without change take coin try give gerald a larger necessary sum coin possible maximum number coin could get ? formal explanation previous paragraph : consider possible combinations coin buyer give gerald sum n mark without change combination calculate minimum number coin bring buyer least n mark among combinations choose maximum minimum number coin number want single line contain a single integer n ( 1 ≤ n ≤ <unknown> ) please use % lld specifier read write 64 bite integers с++ prefer use cin cout stream % i64d specifier a single line print integer : maximum number coin unlucky buyer could pay first test case a buyer exactly one coin least 3 mark , give gerald one mark give coin sample customer a coin one mark case able give money gerald without change second test case buyer exactly three coin 3 mark , give gerald 4 mark give two coin buyer give three coin want minimize number coin give",['greedy'],1600.0
494/A,malek recently find a treasure map look a treasure find a lock door a string s write door consist character ' ( ' ' ) ' ' # ' a manual open door spend a long time malek manage decode manual find goal replace ' # ' one ' ) ' character final string become beautiful also write a string call beautiful i ( 1 ≤ i ≤ |s| ) ' ) ' character ' ( ' character among first i character s also total number ' ( ' character equal total number ' ) ' character help malek open door tell ' # ' character many ' ) ' character must replace first line input contain a string s ( 1 ≤ |s| ≤ 105 ) character string one character ' ( ' ' ) ' ' # ' guarantee s contain least one ' # ' character way replace ' # ' character lead a beautiful string print - 1 . otherwise character ' # ' print a separate line contain a positive integer number ' ) ' character character must replace several possible answer may output <unknown> denote length string s,['greedy'],1500.0
322/A,fox ciel friends a dance room n boys m girls never dance songs song must exactly one boy one girl dance besides a special rule : help fox ciel make a schedule dance many songs possible first line contain two integers n m ( 1 ≤ n m ≤ 100 ) — number boys girls dance room first line print k — number songs dance follow k line print index boys girls dance songs chronologically assume boys index 1 n girls index 1 m. test case 1 2 boys 1 girl 2 dance : 1st boy 1st girl ( first song ) 2nd boy 1st girl ( second song ) test case 2 2 boys 2 girls answer 3,['greedy'],1000.0
316/A2,special agent smart beaver work a secret research department <unknown> 's work a long time satisfy job allow eat best restaurants order expensive <unknown> wood type content special agent get important task : get latest research <unknown> scientists english language developments encode store a large safe beaver 's teeth strong enough authorities <unknown> upon arrive place beaver wo n't problems open safe finish <unknown> <unknown> leave important task course beaver arrive location without problems alas ca n't open safe strong big teeth point smart beaver get a call headquarter learn open safe teeth necessary a reliable source send follow information : safe code consist digits lead zero also a special hint use open safe hint string s follow structure : example hint ` ` ? <unknown> '' match safe code variants : ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' wrong variants : ` ` <unknown> '' ` ` 00111 '' ` ` <unknown> '' ` ` <unknown> '' receive information authorities change plan ask special <unknown> work <unknown> <unknown> try open safe <unknown> mean try find password use give hint a special agent school smart beaver fastest <unknown> find cod safes shape : years take toll ... help determine number possible variants code safe match give hint receive information know speed enter cod smart beaver able determine whether time tonight 's show ` ` beaver trail '' favorite tv channel work a <unknown> night ... first line contain string s — hint safe code string s consist follow character : ? 0 - 9 a - j guarantee first character string s n't equal character 0 . input limit score 30 point ( subproblem a1 ) : input limit score 100 point ( subproblems <unknown> ) : |s| mean length string s. print number cod match give hint,['math'],1400.0
1/C,nowadays circuses berland a round arena diameter 13 meter past things different ancient berland <unknown> circuses shape a regular ( <unknown> ) polygon size number angle could vary one circus another corner arena a special pillar rope string pillars mark arena edge recently scientists berland discover remain ancient circus arena find three pillars others destroy time give coordinate three pillars find smallest area arena could input file consist three line contain a pair number – – coordinate pillar coordinate n't exceed 1000 absolute value give six digits decimal point output smallest possible area ancient arena number accurate least 6 digits decimal point 's guarantee number angle optimal polygon larger 100,['math'],2100.0
9/A,yakko wakko dot world - famous <unknown> decide rest act cartoon take a leave travel a bite yakko dream go <unknown> motherland motherland ancestors wakko think <unknown> beach sun sea dot choose transylvania mysterious unpredictable place great <unknown> leave turn short enough visit one three name place 's yakko <unknown> come a truly genius idea : let three roll ordinary six - <unknown> die one highest amount point winner take two place his / her dream yakko throw a die get y point wakko — w point dot 's turn n't hurry dot want know sure chance visit transylvania know yakko wakko true gentlemen 's amount point dot let dot win line input file contain two natural number y w — result yakko 's wakko 's die roll output require probability form irreducible fraction format « a / b » a — numerator b — denominator require probability equal zero output « 0/1 » require probability equal 1 output « <unknown> » dot go transylvania lucky roll 4 5 6 point,['math'],800.0
11/B,jack work jump skills recently currently 's locate point zero number line would like get point x. order train decide 'll first jump one unit subsequent jump exactly one longer previous one go either leave right jump wonder many jump need reach x. input data consist one integer x ( - 109 ≤ x ≤ 109 ) output minimal number jump jack require reach x,['math'],1600.0
15/B,petya responsible worker research institute ask make a important experiment : melt chocolate bar a new <unknown> device device consist a rectangular field n × m cells a robotic arm cell field a 1 × 1 square robotic arm two lasers point field <unknown> surface one time lasers point <unknown> two cells since lasers robotic hand movements synchronize — move one lasers a vector another one move vector follow <unknown> experiment know : give n m cells ( x1 y1 ) ( x2 y2 ) lasers initially point ( xi a column number yi a row number ) row number 1 m top bottom columns number 1 n leave right find amount cells field chocolate ca n't melt give condition first line contain one integer number t ( 1 ≤ t ≤ 10000 ) — number test set follow t line describe one test set line contain integer number n m x1 y1 x2 y2 separate a space ( 2 ≤ n m ≤ 109 1 ≤ x1 x2 ≤ n 1 ≤ y1 y2 ≤ m ) cells ( x1 y1 ) ( x2 y2 ) distinct t line output contain answer correspond input test set,['math'],1800.0
7/C,a line plane describe equation ax + + c = 0 . find point line whose coordinate integer number - 5·1018 5·1018 inclusive find point exist first line contain three integers a b c ( - 2·109 ≤ a b c ≤ 2·109 ) — correspond coefficients line equation guarantee a2 + b2 > 0 . require point exist output coordinate otherwise output -1,['math'],1800.0
1/A,theatre square capital city berland a rectangular shape size n × m meter occasion city 's anniversary a decision take pave square square <unknown> flagstones <unknown> size a × a. least number flagstones need pave square ? 's allow cover surface larger theatre square square cover 's allow break flagstones side flagstones parallel side square input contain three positive integer number first line : n m a ( 1 ≤ n m a ≤ 109 ) write need number flagstones,['math'],1000.0
4/A,one hot summer day pete friend billy decide buy a watermelon choose biggest <unknown> one opinion watermelon weigh scale show w kilos rush home die <unknown> decide divide berry however face a hard problem pete billy great fan even number 's want divide watermelon a way two part weigh even number kilos time obligatory part equal boys extremely tire want start meal soon possible 's help find divide watermelon way want sure get a part positive weight first ( ) input line contain integer number w ( 1 ≤ w ≤ 100 ) — weight watermelon buy boys print yes boys divide watermelon two part weigh even number kilos ; opposite case example boys divide watermelon two part 2 6 kilos respectively ( another variant — two part 4 4 kilos ),['math'],800.0
17/A,nick interest prime number read goldbach problem state every even integer greater 2 express sum two prim get nick 's attention decide invent a problem call noldbach problem since nick interest prime number noldbach problem state least k prime number 2 n inclusively express sum three integer number : two neighbor prime number 1 . example 19 = 7 + 11 + 1 13 = 5 + 7 + 1 . two prime number call neighbor prime number help nick find right wrong first line input contain two integers n ( 2 ≤ n ≤ 1000 ) k ( 0 ≤ k ≤ 1000 ) output yes least k prime number 2 n inclusively express describe otherwise output first sample answer yes since least two number express describe ( example 13 19 ) second sample answer since impossible express 7 prime number 2 45 desire form,['math'],1000.0
364/D,"john doe offer sister jane doe find gcd set number a. gcd a positive integer g number set evenly divisible g n't g ' ( g ' > g ) number set evenly divisible g ' unfortunately jane could n't cope task john offer find ghd subset number ghd a positive integer g least half number set evenly divisible g n't g ' ( g ' > g ) least half number set evenly divisible g ' jane <unknown> task two hours please try , first line contain integer n ( 1 ≤ n ≤ 106 ) show many number set a. second line contain space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 1012 ) please note give set contain equal number please write % lld specifier read write 64 - bit integers с++ prefer use % i64d specifier print a single integer g — ghd set a",['math'],2900.0
319/A,a tradition every year ioi members natalia fan club invite malek dance club a fun night together malek dance club 2n members <unknown> natalia fan club also 2n members member mdc assign a unique i d i 0 2n - 1 . hold member nfc one part tradition one one dance member mdc dance a member nfc a dance pair a pair number ( a b ) member a mdc dance member b nfc complexity a pair ' assignment number pair dance pair ( a b ) ( c d ) a < c b > d. give a binary number length n name x. know member i mdc dance member nfc task calculate complexity assignment modulo 1000000007 ( 109 + 7 ) expression denote apply « xor » number x y. operation exist modern program languages example c++ java denote « ^ » pascal — « xor » first line input contain a binary number x <unknown> n ( 1 ≤ n ≤ 100 ) number may contain lead zero print complexity give dance <unknown> modulo 1000000007 ( 109 + 7 ),['math'],1600.0
18/B,one one - dimensional world n platforms platform index k ( platforms number 1 ) a segment coordinate [ ( k - 1 ) m ( k - 1 ) m + l ] l < m. grasshopper bob start jump along platforms point 0 jump move exactly d units right find coordinate point bob fall grasshopper fall find platform find edge platform n't fall first input line contain 4 integer number n d m l ( 1 ≤ n d m l ≤ 106 l < m ) — respectively : amount platforms length grasshopper bob 's jump number m l need find coordinate k - th platform : [ ( k - 1 ) m ( k - 1 ) m + l ] output coordinate point <unknown> fall n't forget bob find platform edge n't fall,['math'],1700.0
23/D,'re give center three equal side a strictly convex tetragon task restore initial tetragon first input line contain one number t — amount test ( 1 ≤ t ≤ 5·104 ) follow t line contain number x1 y1 x2 y2 x3 y3 — coordinate different point center three equal side ( non - negative integer number exceed 10 ) test output two line require tetragon exist output first line yes second line — four pair number — coordinate polygon 's vertices clockwise counter - clockwise order n't forget please tetragon strictly convex i.e 3 point lie one line output number 9 character a decimal point require tetragon doe n't exist output first line leave second line empty,['math'],2600.0
322/B,fox ciel flower : r red flower g green flower b blue flower want use flower make several bouquets 4 type bouquets : help fox ciel find maximal number bouquets make first line contain three integers r g b ( 0 ≤ r g b ≤ 109 ) — number red green blue flower print maximal number bouquets fox ciel make test case 1 make 1 red bouquet 2 green bouquets 3 blue bouquets test case 2 make 1 red 1 green 1 blue 1 mix bouquet,['math'],1600.0
325/B,"daniel organize a football tournament come follow tournament format : example 20 team initially would begin play 10 game , 10 team would eliminate remain 10 would play 5 game remain 5 team would play 10 game a round <unknown> tournament total would 10 + 5 + <unknown> game daniel already book stadium n game help determine many team invite tournament need exactly n game print possible number team yield exactly n game ascend order -1 number first line contain a single integer n ( 1 ≤ n ≤ 1018 ) number game play please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print possible number invite team ascend order one per line exactly n game play output one number : -1",['math'],1800.0
327/B,"iahub iahubina go a date a luxury restaurant everything go fine pay food instead money waiter want iahub write a hungry sequence consist n integers a sequence a1 a2 ... , consist n integers hungry : iahub trouble ask help find a hungry sequence n elements input contain a single integer : n ( 1 ≤ n ≤ 105 ) output a line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 107 ) represent a possible hungry sequence note ai must greater 10000000 ( 107 ) less 1 . multiple solutions output one",['math'],1200.0
329/E,n cities a two dimensional cartesian plane distance two cities equal manhattan distance ( see note definition ) a hamiltonian cycle cities define a permutation n cities length hamiltonian cycle define sum distance adjacent cities permutation plus distance first final city permutation please compute longest possible length a hamiltonian cycle give cities first line contain integer n ( 3 ≤ n ≤ 105 ) n line follow consist two integers xi yi ( 0 ≤ xi yi ≤ 109 ) denote coordinate a city give point distinct a single line denote longest possible length a hamiltonian cycle give cities output cycle length please write % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier example one possible hamiltonian cycle length 6 ( 1 1 ) ( 1 2 ) ( 2 1 ) ( 2 2 ) exist hamiltonian cycle a length greater 6 . manhattan distance two cities ( xi yi ) ( xj yj ) |xi - xj| + |yi - <unknown>,['math'],3100.0
332/D,"insurgents accidentally get hold plan a top secret research polygon create a <unknown> planet need galaxy empire insurgents suppose polygon develop new <unknown> weapon polygon consist n missile silos connect bidirectional underground passages passages link <unknown> research conduct naturally passages guard <unknown> : passage silos i j patrol ci j war droids insurgents study polygon plan notice unusual structure turn k - element set silos s exactly one silo directly connect a passage silo s ( 'll call silo adjacent s ) consider insurgents decide act follow : danger operation total number droids patrol passages scout go danger operation obviously depend way choose set s. insurgents n't yet decide exact silos send scout however already want start prepare weapons scout group , insurgents need know mathematical average <unknown> operations correspond possible ways choose set s. solve problem help insurgents protect <unknown> republic ! first line contain two integers n k ( 2 ≤ n ≤ 2000 1 ≤ k ≤ n - 1 ) — number silos number scout group correspondingly next n - 1 line describe polygon plan : i - th line contain n - i integers ci i + 1 ci i + 2 ... ci n — number droids patrol correspond passages ( -1 ≤ ci j ≤ 109 ; ci j = -1 silos i j n't a passage ) passages bidirectional , assume ci j = cj i. passages connect a silo guarantee polygon plan meet condition problem statement print average danger scout operation round integer note give limit answer problem always fit standard integer 64 - bit data type please use % lld specifier write 64 - bit integers с++ prefer use cout stream % i64d specifier first sample 6 one - element set silos set { 1 } { 5 } operation danger equal 8 set { 3 } { 6 } — 3 set { 2 } { 4 } — 5 . mathematical average equal second sample 3 two - elements set silos : { 1 3 } ( danger equal 21 ) { 1 2 } ( danger equal 11 ) { 2 3 } ( danger equal 10 ) average operation danger equal",['math'],2400.0
336/B,one beautiful day vasily bear paint 2 m circle radius r a coordinate plane circle number 1 m center point ( 2r - r 0 ) ( 4r - r 0 ) ... ( 2rm - r 0 ) respectively circle number m + 1 2 m center point ( 2r - r 2r ) ( 4r - r 2r ) ... ( 2rm - r 2r ) respectively naturally bear paint circle a simple experiment a fly experiment continue m2 days day experiment get unique number 0 m2 - 1 inclusive day number i follow things happen : help vasily count average distance fly go along coordinate plane m2 days first line contain two integers m r ( 1 ≤ m ≤ 105 1 ≤ r ≤ 10 ) a single line print a single real number — answer problem answer consider correct absolute relative error n't exceed 10 - 6 . figure second sample,['math'],1900.0
336/D,vasily bear love beautiful string string s beautiful meet follow criteria : a modification string length least two follow operation : replace two last character string exactly one character character equal one replace two zero otherwise equal zero example one modification transform string ` ` <unknown> '' string ` ` <unknown> '' two modifications transform ` ` 011 '' forbid modify a string length less two help bear count number beautiful string number beautiful string rather large print remainder divide number 1000000007 ( 109 + 7 ) first line input contain three space - separated integers n m g ( 0 ≤ n m ≤ 105 n + m ≥ 1 0 ≤ g ≤ 1 ) print a single integer — answer problem modulo 1000000007 ( 109 + 7 ) first sample beautiful string : ` ` 01 '' ` ` 10 '' second sample beautiful string : ` ` 0011 '' ` ` 1001 '' ` ` 1010 '' ` ` 1100 '' third sample beautiful string,['math'],2100.0
338/D,consider a table g size n × m g ( i j ) = gcd ( i j ) 1 ≤ i ≤ n 1 ≤ j ≤ m. gcd ( a b ) greatest common divisor number a b. a sequence positive integer number a1 a2 ... ak say sequence occur table g coincide consecutive elements row start position formally number 1 ≤ i ≤ n 1 ≤ j ≤ m - k + 1 exist g ( i j + l - 1 ) = al 1 ≤ l ≤ k. determine sequence a occur table g. first line contain three space - separated integers n m k ( 1 ≤ n m ≤ 1012 ; 1 ≤ k ≤ 10000 ) second line contain k space - separated integers a1 a2 ... ak ( 1 ≤ ai ≤ 1012 ) print a single word ` ` yes '' give sequence occur table g otherwise print ` ` '' sample 1 . <unknown> row table g start sequence { 1 2 1 2 5 2 1 2 1 10 } see elements fifth ninth coincide sequence a. sample 2 . time width table g equal 8 . sequence a n't occur,['math'],2900.0
340/A,"iahub friend floyd start paint a wall iahub paint wall red floyd paint pink consider wall make a large number bricks number 1 2 3 iahub follow scheme paint : skip x - 1 consecutive bricks paint x - th one , 'll paint bricks x <unknown> <unknown> red similarly floyd skip y - 1 consecutive bricks paint y - th one hence 'll paint bricks y <unknown> <unknown> pink paint wall day boys observe bricks paint red pink iahub a lucky number a floyd a lucky number b. boys wonder many bricks number less a greater b paint red pink exactly task : compute print answer question input a single line contain four integers order : x y a b ( 1 ≤ x y ≤ 1000 1 ≤ a b ≤ 2·109 a ≤ b ) output a single integer — number bricks number less a greater b paint red pink let 's look bricks a b ( a = 6 b = 18 ) bricks color red number 6 8 10 12 14 16 18 . bricks color pink number 6 9 12 15 18 . bricks color red pink number 6 12 18",['math'],1200.0
340/E,iahub happy invent bubble sort graph 's stay day long office write permutations iahubina angry important iahub iahub go away iahubina come office <unknown> research work girl find important permutation research permutation contain n distinct integers a1 a2 ... ( 1 ≤ ai ≤ n ) replace permutation elements -1 value a revenge iahub find important permutation break try recover thing remember permutation n't fix point a fix point a permutation element ak value equal k ( ak = k ) job proof iahub try recover a good idea output number permutations could originally iahub 's important permutation modulo 1000000007 ( 109 + 7 ) first line contain integer n ( 2 ≤ n ≤ 2000 ) second line n integers represent iahub 's important permutation iahubina replace value -1 . 's guarantee fix point give permutation also give sequence contain least two number -1 positive number occur sequence 's guarantee least one suitable permutation output a single integer number ways iahub could recover permutation modulo 1000000007 ( 109 + 7 ) first test example two permutations fix point [ 2 5 4 3 1 ] [ 5 1 4 3 2 ] permutation would least one fix point,['math'],2000.0
343/A,"mad scientist mike build a time machine spare time finish work need a resistor a certain resistance value however mike lot identical resistors unit resistance r0 = 1 . elements resistance construct resistors problem consider follow elements : consecutive connection resistance new element equal r = + r0 parallel connection resistance new element equal case equal resistance element connect mike need assemble element a resistance equal fraction determine smallest possible number resistors need make element single input line contain two space - separated integers a b ( 1 ≤ a b ≤ 1018 ) guarantee fraction irreducible guarantee a solution always exist print a single number — answer problem please use % lld specifier read write 64 - bit integers с++ recommend use cin cout stream % i64d specifier first sample one resistor enough second sample one connect resistors parallel take result element connect a third resistor consecutively , get element resistance make element use two resistors",['math'],1600.0
327/C,a long plate s contain n digits iahub want delete digits ( possibly none allow delete digits ) form ` ` magic number '' plate a number divisible 5 . note result number may contain lead zero iahub want count number ways obtain magic number modulo 1000000007 ( 109 + 7 ) two ways different set delete position s differ look input part statement s give a special form first line 're give a string a ( 1 ≤ |a| ≤ 105 ) contain digits second line 're give integer k ( 1 ≤ k ≤ 109 ) plate s form concatenate k copy a together n = <unknown> print a single integer — require number ways modulo 1000000007 ( 109 + 7 ) first case four possible ways make a number divisible 5 : 5 15 25 <unknown> . second case remember concatenate copy a. actual plate <unknown> . third case except delete digits choice therefore 26 - 1 = 63 possible ways delete digits,['math'],1700.0
344/B,mad scientist mike busy carry experiment chemistry today attempt join three atoms one molecule a molecule consist atoms pair atoms connect atomic bond atom a valence number — number bond atom must form atoms atom form one multiple bond atom form a bond number bond atom molecule must equal valence number mike know valence number three atoms find a molecule build atoms accord state rule determine impossible single line input contain three space - separated integers a b c ( 1 ≤ a b c ≤ 106 ) — valence number give atoms a molecule build print three space - separated integers — number bond 1 - st 2 - nd 2 - nd 3 - rd 3 - rd 1 - st atoms correspondingly multiple solutions output solution print ` ` impossible '' ( without quote ) first sample correspond first figure bond atoms 1 2 case second sample correspond second figure one bond pair atoms third sample correspond third figure solution atom form bond configuration fourth figure impossible atom must least one atomic bond,['math'],1200.0
361/B,levko love permutations much a permutation length n a sequence distinct positive integers n. let ’ s assume value gcd ( a b ) show greatest common divisor number a b. levko assume element pi permutation p1 p2 ... pn good gcd ( i pi ) > 1 . levko consider a permutation beautiful exactly k good elements unfortunately ’ t know beautiful permutation task help find least one single line contain two integers n k ( 1 ≤ n ≤ 105 0 ≤ k ≤ n ) a single line print either beautiful permutation -1 permutation ’ t exist multiple suitable permutations allow print first sample elements 4 3 good gcd ( 2 4 ) = 2 > 1 gcd ( 3 3 ) = 3 > 1 . elements 2 1 good gcd ( 1 2 ) = 1 gcd ( 4 1 ) = 1 . exactly 2 good elements permutation beautiful second sample beautiful permutations,['math'],1200.0
318/A,a <unknown> volodya displease current state things <unknown> order natural number ( natural number positive integer number ) determine rearrange many natural number volodya decide start first n. write follow sequence number : firstly odd integers 1 n ( ascend order ) even integers 1 n ( also ascend order ) help hero find number stand position number k. line input contain integers n k ( 1 ≤ k ≤ n ≤ 1012 ) please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier print number stand position number k volodya 's <unknown> first sample volodya 's sequence look like : { 1 3 5 7 9 2 4 6 8 10 } third place sequence therefore occupy number 5,['math'],900.0
312/B,smallr archer smallr take a match archer zanoes try shoot target turn smallr shoot first probability shoot target time smallr zanoes one shoot target first winner output probability smallr win match a single line contain four integers print a single real number probability smallr win match answer consider correct absolute relative error n't exceed 10 - 6,['math'],1300.0
267/A,' ve get two number long larger zero go operation : subtract <unknown> number larger one equal <unknown> one number another example one operation transform pair ( <unknown> ) pair ( <unknown> ) transform ( <unknown> ) ( <unknown> ) ' ve get number pair ( ai bi ) many operations perform ? first line contain number pair n ( 1 ≤ n ≤ 1000 ) follow n line line contain a pair positive integers ai bi ( 1 ≤ ai bi ≤ 109 ) print seek number operations pair a single line,['math'],900.0
267/C,"berland traffic different traffic countries capital berland consist n junctions m roads road connect a pair junctions multiple roads a pair junctions road know capacity : value ci maximum number cars drive along a road direction per a unit time road cars drive along one two direction , cars ca n't simultaneously move directions a road 's traffic number cars go along per a unit time road ( ai bi ) value negative traffic move bi ai a road 's traffic a non - integer number capital two special junctions — entrance city ( junction 1 ) exit city ( junction n ) junctions true traffic lose , junctions except 1 n incoming traffic sum equal outgo traffic sum traffic unusual <unknown> capital berland — pair junctions ( x y ) sum traffic along path x y n't change depend choice path sum include traffic along roads path ( possible ` ` minus '' sign traffic along road direct direction road path x y ) task find largest traffic pass trough city per one unit time well correspond traffic road first line contain a positive integer n — number junctions ( 2 ≤ n ≤ 100 ) second line contain integer m ( 1 ≤ m ≤ 5000 ) — number roads next m line contain roads ' descriptions road contain a group three number ai bi ci ai bi number junctions connect give road ci ( 1 ≤ ai bi ≤ n ; ai ≠ bi ; 0 ≤ ci ≤ 10000 ) largest <unknown> traffic along road first line print require largest traffic across city print m line line print speed traffic move along correspond road direction n't match order junctions give input print traffic minus sign print number accuracy least five digits decimal point many optimal solutions print",['math'],2700.0
269/E,emuskald <unknown> <unknown> always try push boundaries music <unknown> come idea a revolutionary <unknown> <unknown> — a rectangular harp a rectangular harp a rectangle n × m consist n row m columns row number 1 n top bottom similarly columns number 1 m leave right string pin space evenly across every side one per unit thus n pin leave right side harp m pin top bottom harp exactly n + m different string string connect two different pin a different side harp emuskald order <unknown> construct first ever rectangular harp however n't mention two string cross otherwise would impossible play harp two string cross segment connect pin intersect fix harp emuskald perform operations two type : follow example fix harp swap two columns : help emuskald complete creation find permutations row columns harp need rearrange tell impossible <unknown> <unknown> string pin <unknown> layout string n't matter first line input contain two space - separated integers number n m ( 1 ≤ n m ≤ 105 ) height width harp units follow n + m line contain 4 space - separated tokens describe a single string : two symbols ai bi two integer number pi qi pair ai pi describe first pin pair bi qi describe second pin string ; a pair s x describe position a single pin a follow way : guarantee two different string connect pin possible rearrange row columns fix harp first line output n space - separated integers — old number row place top bottom fix harp second line output m space - separated integers — old number columns place leave right fix harp impossible rearrange row columns fix harp output ` ` solution '' ( without quote ),['math'],3100.0
271/B,' ve get n × m matrix matrix consist integers one move apply a single transformation matrix : choose arbitrary element matrix increase 1 . element increase arbitrary number time really curious prime number let us remind a prime number a positive integer exactly two distinct positive integer divisors : number one example number 2 3 5 prime number 1 4 6 a matrix prime least one two follow condition fulfill : task count minimum number move need get a prime matrix one ' ve get first line contain two integers n m ( 1 ≤ n m ≤ 500 ) — number row columns matrix correspondingly follow n line contain m integers — initial matrix matrix elements positive integers number initial matrix exceed 105 . number line separate single space print a single integer — minimum number move need get a prime matrix one ' ve get ' ve get a prime matrix print 0 . first sample need increase number 1 cell ( 1 1 ) thus first row consist prime number : 2 2 3 . second sample need increase number 8 cell ( 1 2 ) three time thus second column consist prime number : 11 2 . third sample n't anything second column already consist prime number : 3 2,['math'],1300.0
271/E,three horse live a horse land : one gray one white one gray - and - white horse really amuse animals adore special card card must contain two integers first one top second one bottom card let 's denote a card a top b bottom ( a b ) three horse paint special card show ( a b ) card gray horse horse paint a new ( a + 1 b + 1 ) card show ( a b ) card a b even integers white horse horse paint a new card show two card ( a b ) ( b c ) gray - and - white horse paint a new ( a c ) card polycarpus really want get n special card ( 1 a1 ) ( 1 a2 ) ... ( 1 ) go horse land take exactly one ( x y ) card horse land 1 ≤ x < y ≤ m. many ways choose card perform action horse land get require card ? polycarpus get card horse a result action describe polycarpus allow get additional card besides card require first line contain two integers n m ( 1 ≤ n ≤ 105 2 ≤ m ≤ 109 ) second line contain sequence integers a1 a2 ... ( 2 ≤ ai ≤ 109 ) note number sequence coincide number line separate single space print a single integer — answer problem please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier,['math'],2200.0
348/A,one day n friends gather together play ` ` mafia '' round game player must supervisor n - 1 people take part game person know many round want a player supervisor : i - th person want play ai round minimum number round ` ` mafia '' game need play let person play least many round want ? first line contain integer n ( 3 ≤ n ≤ 105 ) second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — i - th number list number round i - th person want play a single line print a single integer — minimum number game round friends need let i - th person play least ai round please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier n't need know rule ` ` mafia '' solve problem 're curious 's a game russia get soviet time : http : //en.wikipedia.org / wiki / mafia _ ( <unknown> ),['math'],1600.0
272/D,little dima two sequence point integer coordinate : sequence ( a1 1 ) ( a2 2 ) ... ( n ) sequence ( b1 1 ) ( b2 2 ) ... ( bn n ) dima want count number distinct sequence point length 2·n assemble sequence x - coordinates point assemble sequence decrease help note element initial sequence use exactly assemble sequence dima consider two assemble sequence ( p1 q1 ) ( p2 q2 ) ... ( <unknown> <unknown> ) ( x1 y1 ) ( x2 y2 ) ... ( <unknown> <unknown> ) distinct i ( 1 ≤ i ≤ 2·n ) ( pi qi ) ≠ ( xi yi ) answer rather large print remainder divide answer number m. first line contain integer n ( 1 ≤ n ≤ 105 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) third line contain n integers b1 b2 ... bn ( 1 ≤ bi ≤ 109 ) number line separate space last line contain integer m ( 2 ≤ m ≤ 109 + 7 ) single line print remainder divide answer problem number m. first sample get one sequence : ( 1 1 ) ( 2 1 ) second sample get sequence : ( 1 1 ) ( 2 2 ) ( 2 1 ) ( 3 2 ) ; ( 1 1 ) ( 2 1 ) ( 2 2 ) ( 3 2 ) thus answer 2,['math'],1600.0
286/E,a <unknown> ' shop recently open city <unknown> thule get ready open shop buy n bag bag characterise total weight ai items put weird thing use bag put a set items total weight strictly less ai however weight items sell shop n't yet define 's determine right task find set items ' weight p1 p2 ... pk ( 1 ≤ p1 < p2 < ... < pk ) : find print require set first line contain space - separated integers n m ( 1 ≤ n m ≤ 106 ) second line contain n distinct space - separated integers a1 a2 ... ( 1 ≤ a1 < a2 < ... < ≤ m ) — bag ' weight limit first line print ` ` '' ( without quote ) n't set pi would meet condition otherwise first line print ` ` yes '' ( without quote ) second line print integer k ( show many number suitable set minimum number weight ) third line print k space - separated integers p1 p2 ... pk ( 1 ≤ p1 < p2 < ... < pk ) multiple solutions print,['math'],2800.0
287/B,vova ultimate thule new shaman want build a pipeline exactly n house ultimate thule vova want city exactly n pip pipe connect water supply a pipe connect water supply 's water flow initially vova one pipe flow water besides vova several splitters a splitter a construction consist one input ( connect a water pipe ) x output pip a splitter connect a water pipe water flow output pipe assume output pip ordinary pip example connect water supply pipe 's water flow one splitter connect water pipe vova one splitter kind : 2 3 4 ... k output help vova use minimum number splitters build require pipeline otherwise state 's impossible vova need pipeline exactly n pip flow water note pip output pip splitters first line contain two space - separated integers n k ( 1 ≤ n ≤ 1018 2 ≤ k ≤ 109 ) please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print a single integer — minimum number splitters need build pipeline impossible build a pipeline give splitters print -1,['math'],1700.0
293/C,yaroslav andrey roman love play cub sometimes get together play cub hours hours ! today get together play cub yaroslav take unit cub compose a × a × a cube andrey make a b × b × b cube roman make a c × c × c cube game finish guy leave later vitaly enter room saw cub want make a cube well size cube ? course a large cube side length a + b + c. besides vitaly decide <unknown> cub build yaroslav andrey roman compose large cube however turn unit cub get destroy three cub n't enough make a large cube know vitaly short exactly n cub vitaly get upset demolish everything leave leave meet petya tell three cub room need another n unit cub make large cube petya enter room saw <unknown> scatter cub want make <unknown> orderly know three cub make small unit cub vitaly need n unit cub make a large one ! help petya understand many ways size a b c restore yaroslav 's andrey 's roman 's cub single line input contain integer n ( 1 ≤ n ≤ 1014 ) know number a b c positive integers please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier single line print require number ways turn n't a single way suitable size a b c print 0,['math'],2400.0
293/D,ksusha a <unknown> mathematician keen absolutely incredible mathematical riddle today ksusha come across a convex polygon non - zero area wonder : choose a pair distinct point uniformly among integer point ( point integer coordinate ) inside border polygon draw a square two opposite vertices lie choose point expectation square 's area ? a pair distinct point choose uniformly among pair distinct point locate inside border polygon pair point p q ( p ≠ q ) q p consider help ksusha ! count require expectation first line contain integer n ( 3 ≤ n ≤ 105 ) — number vertices ksusha 's convex polygon next n line contain coordinate polygon vertices clockwise counterclockwise order i - th line contain integers xi yi ( |xi| |yi| ≤ 106 ) — coordinate vertex go i - th order print a single real number — require expect area answer consider correct absolute relative error n't exceed 10 - 6,['math'],2700.0
300/E,"a far away galaxy war <unknown> republic make k precision strike power ai empire possessions cope <unknown> threat supreme council decide deal a <unknown> blow enemy force successfully complete conflict confrontation balance blow a positive integer balance confrontation a number look like p = n ! ( n power <unknown> strike ) , many years war empire 's resources low reduce cost n a minimum positive integer approve <unknown> help empire find minimum positive integer n describe fraction a positive integer first line contain integer k ( 1 ≤ k ≤ 106 ) second line contain k integers a1 a2 ... ak ( 1 ≤ ai ≤ 107 ) print minimum positive integer n need empire win please use % lld read write 64 - <unknown> integers с++ prefer use cin cout stream % i64d specificator",['math'],2300.0
303/C,"give n distinct integers a1 a2 ... , remove k find minimum modular m ( m > 0 ) every pair remain integers ( ai aj ) follow <unknown> hold : first line contain two integers n k ( 1 ≤ n ≤ 5000 0 ≤ k ≤ 4 ) mention second line contain n distinct integers a1 a2 ... ( 0 ≤ ai ≤ 106 ) print a single positive integer — minimum m",['math'],2400.0
303/D,bike a smart boy love math much invent a number call ` ` rotatable number '' inspire 142857 . see 142857 a magic number rotate get multiply number 1 2 ... 6 ( number one number 's length ) rotate a number mean put last several digit first example rotate number 12345 obtain number : 12345 <unknown> <unknown> <unknown> <unknown> . 's worth mention leading - zeroes allow <unknown> <unknown> obtain rotate <unknown> . see 142857 satisfy condition 6 equations base 10 . bike a problem extend ` ` rotatable number '' base b. mention 142857 a ` ` rotatable number '' base 10 . another example 0011 base 2 . 4 equations base 2 . want find largest b ( 1 < b < x ) a positive ` ` rotatable number '' ( leading - zeroes allow ) length n base b. note time multiply a rotatable number number 1 length get a rotate number line contain two space - separated integers n x ( 1 ≤ n ≤ <unknown> 2 ≤ x ≤ 109 ) print a single integer — largest b find b exist print -1 instead,['math'],2600.0
304/A,mathematics pythagorean theorem — a relation euclidean geometry among three side a right - angled triangle term areas state : <unknown> right - angled triangle area square whose side hypotenuse ( side opposite right angle ) equal sum areas square whose side two legs ( two side meet a right angle ) theorem write equation relate lengths side a b c often call pythagorean equation : c represent length hypotenuse a b represent lengths two side give n task count many right - angled <unknown> side - lengths a b c satisfy inequality 1 ≤ a ≤ b ≤ c ≤ n. line contain one integer n ( 1 ≤ n ≤ 104 ) mention print a single integer — answer problem,['math'],1200.0
305/D,olya get a direct non - weighted graph consist n vertexes m edge consider graph vertexes index 1 n manner graph edge go vertex v vertex u follow <unknown> hold : v < u. olya wonder many ways add arbitrary ( possibly zero ) number edge graph follow condition meet : consider two ways distinct pair vertexes i j ( i < j ) first result graph edge i j second one n't help olya require number ways rather large print modulo 1000000007 ( 109 + 7 ) first line contain three space - separated integers n m k ( 2 ≤ n ≤ 106 0 ≤ m ≤ 105 1 ≤ k ≤ 106 ) next m line contain description edge initial graph i - th line contain a pair space - separated integers ui vi ( 1 ≤ ui < vi ≤ n ) — number vertexes a direct edge ui vi guarantee pair vertexes ui vi one edge also guarantee graph edge give order non - decreasing ui multiple edge go vertex ui guarantee edge give order increase vi print a single integer — answer problem modulo 1000000007 ( 109 + 7 ) first sample two ways : first way add anything second way add a single edge vertex 2 vertex 5,['math'],2200.0
309/A,people like fit 's many ready wake dawn go stadium run problem task help a company design a new stadium city n a <unknown> old stadium many people like every morning thousands people come stadium run stadium represent a circle length exactly l meter a mark start line however ca n't simultaneous start morning exactly 7 runner go favorite spot stadium start run note everybody run manner everybody else people run clockwise direction run counter - clockwise direction <unknown> depend runner 's mood morning assume run direction equiprobable runner fix morning stadium <unknown> need major repair right one run track ! ca n't get <unknown> a single track 's runners keep run speed — exactly 1 meter per a time unit nevertheless runners choose different directions bump meet company want design a new stadium first need know bad old one need expectation number bump t time units run begin help company count require expectation note runner choose a direction equiprobably independently others runners start run simultaneously 7 <unknown> assume runner run t time units without stop consider runners bump a certain moment moment find point stadium a pair runners bump first line input contain three integers n l t ( 1 ≤ n ≤ 106 1 ≤ l ≤ 109 1 ≤ t ≤ 109 ) next line contain n distinct integers a1 a2 ... ( 0 ≤ a1 < a2 < ... < < l ) ai clockwise distance start line i - th runner 's start position print a single real number — answer problem absolute relative error 10 - 6 . two runners first example first runner run clockwise direction 1 time unit 1 m away start line second runner run counter - clockwise direction 1 time unit also 1 m away start line possible way meet assume run direction equiprobable answer example equal <unknown> = <unknown>,['math'],2000.0
286/A,a permutation p size n sequence p1 p2 ... pn consist n distinct integers 1 n ( 1 ≤ pi ≤ n ) a lucky permutation permutation p integer i ( 1 ≤ i ≤ n ) meet condition <unknown> = n - i + 1 . integer n. find lucky permutation p size n. first line contain integer n ( 1 ≤ n ≤ 105 ) — require permutation size print ` ` -1 '' ( without quote ) lucky permutation p size n n't exist otherwise print n distinct integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) a space — require permutation multiple answer print,['math'],1400.0
346/E,"<unknown> jump aim guide a four - <unknown> creature call ` ` doodler '' a never - <unknown> series platforms without fall — wikipedia a popular game xiaodao like much one day play game wonder whether exist a platform doodler could n't reach due limit jump ability consider follow problem n platforms height x - th ( 1 ≤ x ≤ n ) platform <unknown> mod p a p positive co - prime integers maximum possible height a doodler 's jump h. jump height h1 height h2 ( h1 < h2 ) h2 - h1 ≤ h. initially doodler grind height 0 . question whether reach highest platform example a = 7 n = 4 p = 12 h = 2 heights platforms 7 2 9 4 picture first jump doodler jump platform height 2 second one doodler jump platform height 4 ca n't jump higher platforms , ca n't reach highest platform user xiaodao think problem a long time n't solve ask help also a lot instance problem task solve instance first line contain integer t ( 1 ≤ t ≤ 104 ) — number problem instance next t line contain four integers a n p h ( 1 ≤ a ≤ 109 1 ≤ n < p ≤ 109 0 ≤ h ≤ 109 ) 's guarantee a p co - prime problem instance doodler reach highest platform output ` ` yes '' otherwise output ` ` ''",['math'],3000.0
346/A,bore summer holiday n't ? alice bob invent a new game play rule follow first get a set n distinct integers take turn make follow move move either alice bob ( player whose turn current ) choose two distinct integers x y set set n't contain absolute difference |x - y| player add integer |x - y| set ( size set increase one ) current player valid move ( ) lose game question finally win game players play optimally remember alice always move first first line contain integer n ( 2 ≤ n ≤ 100 ) — initial number elements set second line contain n distinct space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — elements set print a single line winner 's name alice win print ` ` alice '' otherwise print ` ` bob '' ( without quote ) consider first test sample alice move first move choose 2 3 add 1 set next bob move valid move anymore winner alice,['math'],1600.0
359/C,"simon a prime number x array non - negative integers a1 a2 ... , simon love fraction much today write number a piece paper simon lead fraction a common denominator sum get a fraction : number t equal <unknown> + a2 + ... + simon want reduce result fraction help find greatest common divisor number s t. gcd rather large print a remainder divide number 1000000007 ( 109 + 7 ) first line contain two positive integers n x ( 1 ≤ n ≤ 105 2 ≤ x ≤ 109 ) — size array prime number second line contain n space - separated integers a1 a2 ... ( 0 ≤ a1 ≤ a2 ≤ ... ≤ ≤ 109 ) print a single number — answer problem modulo 1000000007 ( 109 + 7 ) first sample thus answer problem 8 . second sample , answer problem 27 <unknown> = <unknown> <unknown> = <unknown> third sample answer problem <unknown> mod 1000000007 = <unknown> . fourth sample thus answer problem 1",['math'],1900.0
370/A,"little petya learn play chess already learn move a king a rook a bishop let us remind rule move chess piece a chessboard 64 square field organize 8 × 8 table a field represent a pair integers ( r c ) — number row number column ( a classical game columns traditionally index letter ) chess piece take exactly one field make a move move a chess piece piece move follow rule : petya think follow problem : minimum number move need piece move field ( r1 c1 ) field ( r2 c2 ) ? , assume piece besides one board help solve problem input contain four integers r1 c1 r2 c2 ( 1 ≤ r1 c1 r2 c2 ≤ 8 ) — coordinate start final field start field n't coincide final one assume chessboard row number top bottom 1 8 columns number leave right 1 8 . print three space - separated integers : minimum number move rook bishop king ( order ) need move field ( r1 c1 ) field ( r2 c2 ) a piece make a move print a 0 instead correspond number",['math'],1100.0
371/B,two little greedy bear find two piece cheese forest weight a b grams correspondingly bear greedy ready fight larger piece 's fox come start dialog : ` ` little bear wait a little i want make piece equal '' ` ` come fox go ? ` ` curious bear ask ` ` 's easy '' say fox ` ` mass a certain piece divisible two i eat exactly a half piece mass a certain piece divisible three i eat exactly two - <unknown> mass divisible five i eat four - <unknown> i 'll eat a little make piece equal '' little bear realize fox 's proposal contain a catch time realize make two piece equal agree proposal one condition : fox make piece equal quickly possible find minimum number operations fox need make piece equal first line contain two space - separated integers a b ( 1 ≤ a b ≤ 109 ) fox lie little bear impossible make piece equal print -1 . otherwise print require minimum number operations piece cheese initially equal require number 0,['math'],1300.0
459/C,recently pashmak employ a transportation company company k bus a contract a school n students school plan take students d different place d days ( day one place ) day company provide bus trip pashmak arrange students bus want arrange students a way two students become close friends <unknown> idea two students become close friends bus d days please help pashmak weird idea assume bus unlimited capacity first line input contain three space - separated integers n k d ( 1 ≤ n d ≤ 1000 ; 1 ≤ k ≤ 109 ) valid arrangement print -1 . otherwise print d line print n integers j - th integer i - th line show bus j - th student take i - th day assume bus number 1 k. note two students become close friends share a bus day bus share differ day day,['math'],1900.0
460/D,little victor adore set theory let us remind a set a group number number pairwise distinct today victor want find a set integers s follow properties : help victor find describe set first line contain three space - separated integers l r k ( 1 ≤ l ≤ r ≤ 1012 ; 1 ≤ k ≤ min ( 106 r - l + 1 ) ) print minimum possible value f ( s ) print cardinality set |s| print elements set order multiple optimal set print operation represent operation bitwise exclusive word xor operation,['math'],2300.0
460/E,roland love grow flower recently grow a beautiful rise point ( 0 0 ) cartesian coordinate system rise beautiful roland afraid evil force try steal protect rise roland want build n watch tower let 's assume a tower a point plane distance r rise besides roland assume tower build point integer coordinate sum square distance pair tower must large possible note roland may build several tower point also may build point ( 0 0 ) help roland build tower integer point sum square distance tower maximum possible note distance problem define <unknown> distance point first line contain two integers n r ( 2 ≤ n ≤ 8 ; 1 ≤ r ≤ 30 ) first line print integer — maximum possible sum square distance i - th follow n line print two integers xi yi — coordinate i - th tower tower must inside border circle radius r. note may several tower locate point plane also tower locate point ( 0 0 ) multiple valid optimal arrangements choose,['math'],2700.0
461/D,toastman come a complicate task give appleman appleman n't know solve help ? give a n × n <unknown> cell board either character ' x ' character ' o ' nothing many ways fill empty cells ' x ' ' o ' ( cell must contain one character end ) cell number adjacent cells ' o ' even ? find number ways modulo 1000000007 ( 109 + 7 ) two cells board adjacent share a side first line contain two integers n k ( 1 ≤ n k ≤ 105 ) — size board number cells character initially k line follow i - th line contain two integers a character : ai bi ci ( 1 ≤ ai bi ≤ n ; ci either ' o ' ' x ' ) line mean : a character ci cell locate intersection ai - th row bi - th column give cells distinct consider row number 1 n top bottom <unknown> columns number 1 n leave right print a single integer — answer problem first example two ways :,['math'],2800.0
463/E,caisa home son a simple task give a root tree n vertices number 1 n ( vertex 1 root ) vertex tree a value answer q query query one follow : give query help caisa solve problem first line contain two space - separated integers n q ( 1 ≤ n q ≤ 105 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 2·106 ) ai represent value node i. next n - 1 line contain two integers xi yi ( 1 ≤ xi yi ≤ n ; xi ≠ yi ) denote edge tree vertices xi yi next q line contain a query format give query follow <unknown> hold : 1 ≤ v ≤ n 1 ≤ w ≤ 2·106 note : 50 query change value a vertex query first type output result <unknown> ( x y ) greatest common divisor two integers x y,['math'],2100.0
466/B,start new academic year bring problem <unknown> students dormitories one dormitories a a × b square meter wonder room caretaker want accommodate exactly n students law say must least 6 square meter per student a room ( room n students must area least <unknown> square meter ) caretaker <unknown> ( possibly ) side room arbitrary positive integer meter help change room n students could live total area room small possible first line contain three space - separated integers n a b ( 1 ≤ n a b ≤ 109 ) — number students size room print three integers s a1 b1 ( a ≤ a1 ; b ≤ b1 ) — final area room size multiple optimal solutions print,['math'],2000.0
468/C,little x meet follow problem recently let 's define f ( x ) sum digits decimal representation number x ( example f ( 1234 ) = 1 + 2 + 3 + 4 ) calculate course little x solve problem quickly lock try hack others see follow c++ code : first line contain a single integer a ( 1 ≤ a ≤ 1018 ) print two integers : l r ( 1 ≤ l ≤ r < <unknown> ) — require test data lead zero n't allow 's guarantee solution exist,['math'],2500.0
472/A,one way create a task learn math generate random math statement modify theorems get something new build a new task example a statement call ` ` goldbach 's conjecture '' say : ` ` even number less four express sum two prim '' let 's modify a statement like : ` ` integer less 12 express sum two composite number . '' like goldbach 's conjecture i prove theorem give integer n less 12 express a sum two composite number line contain integer n ( 12 ≤ n ≤ 106 ) output two composite integers x y ( 1 < x y < n ) x + y = n. multiple solutions output first example 12 = 4 + 8 4 8 composite number output ` ` 6 6 '' ` ` 8 4 '' well second example 15 = 6 + 9 . note ca n't output ` ` 1 14 '' 1 a composite number,['math'],800.0
472/F,task follow structure : give a model operations use operations <unknown> goal one way create a new task use model operations change goal let 's a try i create follow task <unknown> srm <unknown> <unknown> - hard : give n integers x1 x2 ... xn allow perform assignments ( many want ) follow form xi ^= xj ( original task i j must different task allow i equal j ) goal maximize sum xi change goal also give n integers y1 y2 ... yn make x1 x2 ... xn exactly equal y1 y2 ... yn word i number xi equal yi first line contain integer n ( 1 ≤ n ≤ 10000 ) second line contain n integers : x1 xn ( 0 ≤ xi ≤ 109 ) third line contain n integers : y1 yn ( 0 ≤ yi ≤ 109 ) solution output -1 . a solution first line output integer m ( 0 ≤ m ≤ 1000000 ) – number assignments need perform print m line line contain two integers i j ( 1 ≤ i j ≤ n ) denote assignment xi ^= xj multiple solutions print prove constraints exist a solution always exist a solution 106 operations assignment a ^= b denote assignment a = a ^ b operation ` ` ^ '' bitwise xor two integers,['math'],2700.0
476/C,dreamoon love sum something reason one day obtain two integers a b <unknown> want calculate sum nice integers positive integer x call nice k integer number range [ 1 a ] denote <unknown> integer division x y. denote remainder integer division x y. read operations : http : <unknown> / <unknown> answer may large please print remainder modulo 1 000 000 007 ( 109 + 7 ) compute faster dreamoon ? single line input contain two integers a b ( 1 ≤ a b ≤ 107 ) print a single integer represent answer modulo 1 000 000 007 ( 109 + 7 ) first sample nice integers always zero second sample set nice integers { 3 5 },['math'],1600.0
457/E,"a computer network consist n nod number 1 n. link network connect pair nod a pair nod may multiple link node a link link support unlimited bandwidth ( either direction ) however a link may transmit a single direction give time cost send data across a link proportional square bandwidth specifically link a positive weight cost send data across link weight time square bandwidth network connect ( a series link node node ) furthermore design remain connect event single node <unknown> need send data node 1 node n a bandwidth positive number k. wish assign a bandwidth link bandwidth a node minus bandwidth a node - k node 1 k node n 0 nod individual bandwidths need integers wish minimize total cost draw a diagram network give task intern solve intern claim solve task write optimal bandwidths diagram <unknown> coffee <unknown> much unreadable ( include part original diagram value k ) information available determine intern 's solution may optimal , determine exist a valid network total bandwidth optimal solution a <unknown> give information furthermore determine efficiency intern 's solution ( possible ) efficiency define total cost divide total bandwidth input begin two integers n m ( 2 ≤ n ≤ 200000 ; 0 ≤ m ≤ 200000 ) number nod number know link network respectively follow m line four integers : f t w b ( 1 ≤ f ≤ n ; 1 ≤ t ≤ n ; f ≠ t ; 1 ≤ w ≤ 100 ; 0 ≤ b ≤ 100 ) indicate a link nod f t weight w carry b bandwidth direction bandwidth f t. intern 's solution definitely optimal print ` ` bad x '' x first link input violate <unknown> solution intern 's solution may optimal print efficiency solution determine round nearest integer otherwise print ` ` unknown '' although know weight bandwidths happen always integers weight bandwidths remain link <unknown> integers",['math'],3000.0
479/A,"petya study a school adore maths class study arithmetic expressions last class teacher write three positive integers a b c blackboard task insert sign operations ' + ' ' * ' probably bracket number value result expression large possible let 's consider example : assume teacher write number 1 2 3 blackboard ways place sign bracket : note insert operation sign a b b c , swap integers instance give sample get expression ( 1 + 3 ) * 2 . 's easy see maximum value obtain 9 . task : give a b c print maximum value get input contain three integers a b c a single line ( 1 ≤ a b c ≤ 10 ) print maximum value expression obtain",['math'],1000.0
484/B,give a sequence a consist n integers find maximum possible value ( integer remainder ai divide aj ) 1 ≤ i j ≤ n ai ≥ aj first line contain integer n — length sequence ( 1 ≤ n ≤ 2·105 ) second line contain n space - separated integers ai ( 1 ≤ ai ≤ 106 ) print answer problem,['math'],2100.0
487/C,consider a sequence [ a1 a2 ... ] define prefix product sequence give n find a permutation [ 1 2 ... n ] prefix product sequence a permutation [ 0 1 ... n - 1 ] input line contain integer n ( 1 ≤ n ≤ 105 ) first output line print ` ` yes '' sequence exist print ` ` '' sequence exist solution exist output n line i - th line contain integer ai elements sequence different positive integers larger n. multiple solutions allow print second sample valid sequence,['math'],2300.0
488/B,old tradition keep 4 box candy house cyberland number candy special arithmetic mean median range equal definition a set { x1 x2 x3 x4 } ( x1 ≤ x2 ≤ x3 ≤ x4 ) arithmetic mean median range x4 - x1 arithmetic mean median necessary integer well - known three number box create a ` ` <unknown> field '' cod field bug example 1 1 3 3 example 4 number meet condition mean median range equal 2 . jeff 4 special box candy however something bad happen ! box could lose n ( 0 ≤ n ≤ 4 ) box remain i - th remain box contain ai candy jeff want know : a possible way find number candy 4 - n miss box meet condition ( mean median range equal ) ? first line input contain integer n ( 0 ≤ n ≤ 4 ) next n line contain integers ai denote number candy i - th box ( 1 ≤ ai ≤ 500 ) first output line print ` ` yes '' a solution exist print ` ` '' solution a solution exist output 4 - n line line contain integer b denote number candy a miss box number b must satisfy inequality 1 ≤ b ≤ 106 . guarantee exist a positive integer solution always find b 's meet condition multiple answer allow print give number ai may follow order input necessary <unknown> may stand position original set necessary lowest n first position first sample number candy 4 box 1 1 3 3 . arithmetic mean median range 2 . second sample 's impossible find miss number candy third example box lose number satisfy condition may output b order,['math'],1900.0
457/A,piegirl get bore binary decimal integer base count systems recently discover interest properties number particular q2 = q + 1 think would make a good base new unique system call ` ` golden system '' golden system number a non - empty string contain 0 's 1 's digits decimal value expression <unknown> ... equal soon piegirl find system n't properties integer base systems operations perform n't able come a fast way compare two number ask help give two number write golden system notation determine larger decimal value input consist two line — one number line contain non - empty string consist ' 0 ' ' 1 ' character length string exceed 100000 . print ` ` > '' first number larger ` ` < ` ` smaller ` ` = '' equal first example first number equal second number approximately <unknown> + <unknown> + 1 ≈ <unknown> clearly a bigger number second example number equal ≈ <unknown>,['math'],1700.0
456/B,fedya study a <unknown> fedya 's maths <unknown> calculate follow expression : give value n. fedya manage complete task ? note give number n extremely large ( e.g exceed integer type program language ) single line contain a single integer n ( 0 ≤ n ≤ <unknown> ) number n't contain lead zero print value expression without lead zero operation x mod y mean take remainder division x y. note first sample :,['math'],1200.0
452/C,alex enjoy perform magic trick a trick require a deck n card m identical deck n different card mix together alex wish perform trick grab n card random perform trick result deck look like a normal deck may duplicate card trick perform follow : first alex allow choose a random card deck memorize card put back deck alex shuffle deck pull a card card match one memorize trick successful n't think alex a good magician pull a card randomly deck determine probability trick successful case first line input consist two integers n m ( 1 ≤ n m ≤ 1000 ) separate space — number card deck number deck line output print one float point number – probability alex successfully perform trick relative absolute error answer higher 10 - 6 . first sample probability alex perform trick two card value two different deck case trick guarantee succeed remain probability take two different card probability pull trick result probability,['math'],2100.0
451/D,call a string good merge consecutive equal character result string palindrome example ` ` <unknown> '' good merge step become ` ` aba '' give a string find two value : first line input contain a single string length n ( 1 ≤ n ≤ 105 ) character string either ' a ' ' b ' print two space - separated integers : number good substrings even length number good substrings odd length example 1 three good substrings ( ` ` b '' ` ` b '' ` ` bb '' ) one even length two odd length example 2 six good substrings ( i.e ` ` b '' ` ` a '' ` ` a '' ` ` b '' ` ` aa '' ` ` <unknown> '' ) two even length four odd length example 3 seven good substrings ( i.e ` ` b '' ` ` a '' ` ` b '' ` ` b '' ` ` bb '' ` ` bab '' ` ` babb '' ) two even length five odd length <unknown> substring s [ l r ] ( 1 ≤ l ≤ r ≤ n ) string s = s1s2 ... sn string <unknown> + 1 ... <unknown> . a string s = s1s2 ... sn a palindrome equal string <unknown> - 1 ... s1,['math'],2000.0
375/A,number a whose decimal representation quite luckily contain digits 1 6 8 9 . rearrange digits decimal representation result number divisible 7 . number a n't contain lead zero contain digits 1 6 8 9 ( also contain another digits ) result number also must n't contain lead zero first line contain positive integer a decimal record guarantee record number a contain digits : 1 6 8 9 . number a n't contain lead zero decimal representation number a contain least 4 106 character print a number decimal notation without lead zero — result permutation impossible rearrange digits number a require manner print 0,['math'],1600.0
380/D,cinema theater hall sereja 's city n seat line front one large screen slot personal possessions leave right seat two adjacent seat exactly one share slot figure show arrangement seat slot n = 4 . today 's premiere a movie call ` ` <unknown> hard '' ticket seat sell a strict controller entrance theater n people come hall one one soon a person enter a cinema hall immediately ( <unknown> ) take seat occupy empty slot leave right empty slot man get really upset leave people constant 's hard predict order viewers enter hall seat sereja know number <unknown> ( number enter queue viewers ) come take seat others order a programmer a mathematician sereja wonder : many ways people enter hall nobody get upset ? number quite large print modulo 1000000007 ( 109 + 7 ) first line contain integer n ( 1 ≤ n ≤ 105 ) second line contain n integers i - th integer show either index person ( index enter queue ) ticket i - th seat a 0 index know guarantee positive number second line distinct assume index person enter cinema hall a unique integer 1 n. person index 1 come first hall person index 2 come second a single line print remainder divide answer number 1000000007 ( 109 + 7 ),['math'],2500.0
97/C,"one university find a sport program contest call acm icpc v2.0 contest n't differ much well - known acm icpc example participants allow take part finals two time however one <unknown> difference : team contest consist exactly n participants take part several acm icpc v2.0 finals medals students university governors realize 's high time change something <unknown> process specifically first <unknown> decide change team ' <unknown> process spend <unknown> amount time study statistics universities ' performance manage receive interest information : dependence probability win a medal number team members participate finals past formally know n + 1 real number p0 ≤ p1 ≤ ... ≤ pn pi probability get a medal finals team i participants previous finals n - i participants arrive finals first time despite useful data university governors unable determine team form tactics would provide maximum probability win a medal acm icpc v2.0 finals average ( suppose want provide result far future also suppose <unknown> supply students ) , offer optimal tactic ? first stage university governors want know value maximum average probability formally suppose university send a team k - th world finals team ak participants previous finals ( 0 ≤ ak ≤ n ) since person participate finals twice follow condition must true : task choose sequence limit ψ exist 's value maximal : infinite sequence print maximum value ψ limit first line contain integer n ( 3 ≤ n ≤ 100 ) n number team participants second line contain n + 1 real number 6 digits decimal point pi ( 0 ≤ i ≤ n 0 ≤ pi ≤ 1 ) — probability team win a medal contain i participants already finals also condition pi ≤ pi + 1 fulfil 0 ≤ i ≤ n - 1 . print real number — expect average number medals per year optimal strategy use result may absolute relative error 10 - 6 . second test matter participants team contain doom successful",['math'],2400.0
483/B,two friends want present several positive integers want present cnt1 number first friend cnt2 number second friend moreover want present number distinct also mean number present friends addition first friend like number divisible without remainder prime number x. second one like number divisible without remainder prime number y. course 're go present friends number n't like task find minimum number v form present use number a set 1 2 ... v. course may choose present number a positive integer number greater 1 call prime positive divisors 1 line contain four positive integers cnt1 cnt2 x y ( 1 ≤ cnt1 cnt2 < 109 ; cnt1 + cnt2 ≤ 109 ; 2 ≤ x < y ≤ <unknown> ) — number describe statement guarantee number x y prime print a single integer — answer problem first sample give set number { 1 3 5 } first friend set number { 2 } second friend note give set { 1 3 5 } first friend give number 1 3 5 second friend second sample give set number { 3 } first friend set number { 1 2 4 } second friend thus answer problem 4,['math'],1800.0
457/D,game bingo play a 5 × 5 square grid fill distinct number 1 75 . problem consider a <unknown> version play n × n grid distinct number 1 m ( m ≥ n2 ) a player begin select a randomly generate bingo grid ( generate uniformly among available <unknown> ) k distinct number 1 m call random ( call uniformly among available set k number ) call number appear grid player mark cell score end 2 raise power ( number completely mark row plus number completely mark columns ) determine expect value score expect score may large expect score larger 1099 print 1099 instead ( example ` ` <unknown> '' without quote ) input consist three integers n m k ( 1 ≤ n ≤ 300 ; n2 ≤ m ≤ 100000 ; n ≤ k ≤ m ) print smaller 1099 expect score answer must correct within absolute relative error 10 - 9,['math'],2700.0
382/B,arthur alexander number <unknown> today ' ve get a competition arthur take a group four integers a b w x ( 0 ≤ b < w 0 < x < w ) alexander take integer с . arthur alexander use distinct approach number <unknown> alexander a regular guy second subtract one number word perform assignment : c = c - 1 . arthur a <unknown> guy second arthur perform a complex operation describe follow : b ≥ x perform assignment b = b - x b < x perform two consecutive assignments a = a - 1 ; b = w - ( x - b ) ' ve get number a b w x c. determine alexander get ahead arthur guy start perform operations time assume alexander get ahead arthur c ≤ a. first line contain integers a b w x c ( 1 ≤ a ≤ 2·109 1 ≤ w ≤ 1000 0 ≤ b < w 0 < x < w 1 ≤ c ≤ 2·109 ) print a single integer — minimum time second alexander need get ahead arthur prove describe situation always occur within problem 's limit,['math'],2000.0
385/E,"bear 's forest a checker field checker field n × n table row number 1 n top bottom columns number 1 n leave right let 's denote a cell field intersection row x column y record ( x y ) cell field contain grow raspberry , cell ( x y ) field contain x + y raspberry bush bear come walk across field begin walk speed ( dx dy ) bear spend exactly t second field second follow take place : task predict bear 's action find cell end start cell ( sx sy ) assume bush infinitely much raspberry bear never eat first line input contain six space - separated integers : n sx sy dx dy t ( 1 ≤ n ≤ 109 ; 1 ≤ sx sy ≤ n ; - 100 ≤ dx dy ≤ 100 ; 0 ≤ t ≤ 1018 ) print two integers — coordinate cell bear end t second operation a mod b mean take remainder divide a b. note result operation always non - negative example ( - 1 ) mod 3 = 2 . first sample first move speed vector equal ( 3,4 ) bear get cell ( <unknown> ) second move speed vector equal ( <unknown> ) bear get cell ( <unknown> ) n't forget second move number berry bush increase 1 . second sample first move speed vector equal ( 1,1 ) bear get cell ( 1,1 ) second move speed vector equal ( <unknown> ) bear get cell ( 1,1 ) n't forget second move number berry bush increase 1",['math'],2300.0
266/D,<unknown> a well - known fast food restaurant go open a cafe bertown important thing choose new restaurant 's location would easy get bertown road system represent n junctions connect m bidirectional roads road know length also know get junction one move along roads task find location restaurant shortest distance along roads cafe farthest junction would minimum note restaurant locate junction point road first line contain two integers n m ( ) — number junctions number roads correspondingly m line follow describe bertown roads road describe three integers ai bi wi ( 1 ≤ ai bi ≤ n ai ≠ bi ; 1 ≤ wi ≤ 105 ) ai bi number junctions connect i - th road wi length i - th road guarantee road connect two distinct junctions one road two junctions get junction one print a single real number — shortest distance optimal restaurant location farthest junction answer consider correct absolute relative error n't exceed 10 - 9,['math'],2400.0
401/E,problem delete contest use previously another competition,['math'],2500.0
402/E,matrix a size n × n. let 's number row matrix 1 n top bottom let 's number columns 1 n leave right let 's use aij represent element intersection i - th row j - th column matrix a meet follow two condition : matrix b strictly positive number i j ( 1 ≤ i j ≤ n ) inequality <unknown> > 0 hold task determine integer k ≥ 1 matrix ak strictly positive first line contain integer n ( 2 ≤ n ≤ 2000 ) — number row columns matrix a. next n line contain description row matrix a. i - th line contain n non - negative integers ai1 ai2 ... ( 0 ≤ aij ≤ 50 ) guarantee a positive integer k ≥ 1 matrix ak strictly positive print ` ` yes '' ( without quote ) otherwise print ` ` '' ( without quote ),['math'],2200.0
417/E,rest ship ` ` russian code cup '' a boy name misha invent interest game promise give <unknown> whoever first one make a rectangular table size n × m consist positive integers sum square number row column also a square since check <unknown> table manually difficult misha ask make number table exceed 108 . first line contain two integers n m ( 1 ≤ n m ≤ 100 ) — size table print table meet condition : n line contain m integers separate space multiple possible answer allow print anyone guarantee exist least one correct answer,['math'],2400.0
424/C,people tomskaya region like magic formulas much see imagine give a sequence positive integer number p1 p2 ... pn let write magic formulas : ` ` mod '' mean operation take residue divide expression mean apply bitwise xor ( exclude ` ` '' ) operation integers x y. give operation exist modern program languages example languages c++ java represent ` ` ^ '' pascal — ` ` xor '' people tomskaya region like magic formulas much n't like calculate ! therefore give sequence p calculate value q. first line input contain integer n ( 1 ≤ n ≤ 106 ) next line contain n integers : p1 p2 ... pn ( 0 ≤ pi ≤ 2·109 ) line output contain a single integer — value q,['math'],1600.0
446/D,"today dzy begin play old game game a big maze n room connect m corridors ( corridor allow move directions ) assume room connect corridors directly indirectly dzy get lose maze currently first room k live act like follow : room trap first room definitely trap n - th room definitely a trap time dzy enter one room lose one life , dzy know enter n - th room exactly 2 live firstly lose one live open a bonus round want know probability open bonus round please help first line contain three integers n m k ( 2 ≤ n ≤ 500 ; 1 ≤ m ≤ 105 ; 2 ≤ k ≤ 109 ) second line contain n integers either 0 1 . i - th number 1 i - th room a trap otherwise a trap please note number room a trap 101 . guarantee first room trap n - th room a trap m line follow contain two integers ui vi ( 1 ≤ ui vi ≤ n ; ui ≠ vi ) mean current corridor connect two room ui vi guarantee corridor system connect print real number — probability dzy open bonus round answer consider correct relative absolute error n't exceed 10 - 4",['math'],2800.0
23/B,"n people come a party , friends among people party leave , exactly 1 friend among stay leave well , exactly 2 3 ... n - 1 friends among stay moment leave , maximum amount people could stay party end ? first input line contain one number t — amount test ( 1 ≤ t ≤ 105 ) follow t line contain one integer number n ( 1 ≤ n ≤ 105 ) test output a separate line one number — maximum amount people could stay end",['math'],1600.0
257/C,flatland recently introduce a new type eye check driver 's <unknown> check go like : a plane mannequins stand tell value minimum angle vertex origin coordinate mannequins stand inside <unknown> angle spend lot time ` ` glue screen '' <unknown> <unknown> write a program pass check first line contain a single integer n ( 1 ≤ n ≤ 105 ) — number mannequins next n line contain two space - separated integers : xi yi ( |xi| |yi| ≤ 1000 ) — coordinate i - th mannequin guarantee origin coordinate mannequin guarantee two mannequins locate point plane print a single real number — value seek angle degrees answer consider valid relative absolute error n't exceed 10 - 6 . solution first sample test show : solution second sample test show : solution third sample test show : solution fourth sample test show :,['math'],1800.0
249/E,"a russian space <unknown> alisa <unknown> like <unknown> late 21 <unknown> interest science recently visit <unknown> ( moscow institute time ) <unknown> co - <unknown> time machine <unknown> <unknown> tell construction a time machine demonstration time machine performance alisa notice machine high speed girl get interest reason <unknown> turn closer examination one problems solve time machine n't solve optimal algorithm find a way solve problem optimally time machine run faster use less energy a task none staff solve optimally follow exist a matrix a fill follow rule : cells consecutive positive integers start one besides ai j < k ( i j t k ≥ 1 ) : first 36 number insert matrix a look follow : solve problem learn find rather quickly give value x1 y1 x2 y2 ( x1 ≤ x2 y1 ≤ y2 ) mean expression : mean expression large enough sufficient know last 10 digits seek value , one <unknown> solve give task alice brave enough use time machine travel past help task write a program use give value x1 y1 x2 y2 find last 10 digits give expression first input line contain a single integer t ( 1 ≤ t ≤ 105 ) — number test set solve problem next t line contain description a test — four positive integers x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ 109 1 ≤ y1 ≤ y2 ≤ 109 ) separate space query print mean expression contain 10 character otherwise print three character ` ` . '' ( without quote ) ten last digits time expression print answer query a single line follow format give sample closely possible",['math'],2600.0
79/E,fox ciel <unknown> return castle something wrong security system castle : sensors attach castle cover ciel point ( 1 1 ) castle want move point ( n n ) position room one step ciel move point ( x y ) either ( x + 1 y ) ( rightward ) ( x y + 1 ) ( upward ) castle c2 sensors set point ( a + i b + j ) ( every integer i j : 0 ≤ i < c 0 ≤ j < c ) sensor a count value decrease count value every time ciel move initially count value sensor t. every time ciel move point ( x y ) count value a sensor point ( u v ) decrease ( |u - <unknown> + <unknown> - y| ) count value sensor become strictly less 0 sensor catch ciel a suspicious individual ! determine whether ciel move ( 1 1 ) ( n n ) without catch a sensor possible output step assume ciel move every point even a <unknown> point first line five integers n t a b c ( 2 ≤ n ≤ 2·105 0 ≤ t ≤ 1014 1 ≤ a ≤ n - c + 1 1 ≤ b ≤ n - c + 1 1 ≤ c ≤ n ) please use % lld specificator read write 64 - bit integers c++ prefer use cin stream ( also may use % i64d specificator ) ciel 's objective possible output first line 2n - 2 character represent <unknown> step i - th character r i - th step move rightward u move upward several solution output lexicographically first one character r lexicographically earlier character u. objective impossible output impossible answer first sample second sample show picture :,['math'],2900.0
80/B,"remember a kind cartoon ` ` beauty beast '' ? , fire machine <unknown> <unknown> <unknown> time - <unknown> ! a beauty name belle violate beast 's order visit west <unknown> <unknown> castle ... everybody upset beautiful belle upset beast <unknown> <unknown> worst thing cogsworth upset cogsworth a human mantel clock often use alarm clock due cogsworth 's <unknown> inhabitants castle trouble : could determine time drink morning <unknown> time even <unknown> fortunately deep <unknown> lie digital clock show time format hh : mm residents castle face a difficult task turn cogsworth 's hour minute mustache hand a way cogsworth begin show correct time moreover need find turn angle degrees mustache hand initial time show cogsworth 12:00 . rotate hand forward , show picture : since many ways select angle full rotations choose smallest angle right ( non - negative ) direction note cogsworth 's hour minute mustache hand move evenly continuously hand move independently turn one hand hand remain stand still line input contain current time accord digital clock format hh : mm ( 00 ≤ hh ≤ 23 00 ≤ mm ≤ 59 ) mantel clock initially show 12:00 . pretests contain time begin morning tv program channel one russia print two number x y — angle turn hour minute hand respectively ( 0 ≤ x y < 360 ) absolute relative error answer exceed 10 - 9 . a note second example : hour hand position exactly middle 4 5",['math'],1200.0
83/B,n animals queue dr . <unknown> animal come office doctor examine give <unknown> appoint test may appoint extra examination <unknown> know forest animals perfectly well therefore know exactly animal number i queue visit office exactly ai time assume examination take much time make test extra procedures therefore assume animal leave room immediately get end queue doctor course animal visit doctor many time necessary n't stand end queue immediately go home doctor plan go home receive k animals therefore queue look like moment important since doctor work long hours ca n't get <unknown> like ask figure first line input data contain two space - separated integers n k ( 1 ≤ n ≤ 105 0 ≤ k ≤ 1014 ) second line give space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) please use % lld specificator read write 64 - bit number c++ recommend use cin cout stream ( also use % i64d specificator ) doctor overall carry less k <unknown> print a single number ` ` -1 '' ( without quote ) otherwise print sequence number — number animals order stand queue note sequence may empty case present pretests print nothing print one ` ` end line '' <unknown> accept first sample test : second sample test :,['math'],1800.0
84/A,hero story valera best friend arcady still school therefore spend free time play turn - based strategy ` ` gaga : go go '' gameplay follow two armies play field consist n men ( n always even ) current player specify soldier enemy 's soldier shoot ( a target ) player 's soldier shoot simultaneously a game world soldier shoot perfectly absolutely always hit specify target enemy soldier hit surely die may happen several soldier indicate target kill soldier participate game anymore game ` ` gaga '' consist three step : first valera make a move arcady valera game end ask calculate maximum total number soldier may kill game input data consist a single integer n ( 2 ≤ n ≤ 108 n even ) please note game start 2n soldier field print a single number — a maximum total number soldier could kill course game three turn first sample <unknown> ) valera 's soldier 1 2 shoot arcady 's soldier 1.2 ) arcady 's soldier 2 shoot valera 's soldier <unknown> ) valera 's soldier 1 shoot arcady 's soldier 2 . 3 soldier kill total : valera 's soldier 1 arcady 's soldier 1 2,['math'],900.0
86/A,positive integer n consider integer ψ ( n ) obtain n replace every digit a decimal notation n digit ( 9 - a ) say ψ ( n ) reflection n. example reflection <unknown> equal <unknown> . note lead zero ( ) omit reflection 9 equal 0 reflection 91 equal 8 . let us call weight number product number reflection thus weight number 10 equal <unknown> = 890 . task find maximum weight number give range [ l r ] ( boundaries include ) input contain two space - separated integers l r ( 1 ≤ l ≤ r ≤ 109 ) — bound range output contain single integer number : maximum value product <unknown> ( n ) l ≤ n ≤ r. please use % lld specificator read write 64 - bit integers c++ prefer use cout ( also may use % i64d ) third sample weight 8 equal <unknown> = 8 weight 9 equal <unknown> = 0 weight 10 equal 890 . thus maximum value product equal 890,['math'],1600.0
86/E,"a sequence a0 a1 ... call a recurrent binary sequence term ai ( i = 0 1 ... ) equal 0 1 exist coefficients note a sequence uniquely recover k - tuple { + 1 ... + k - 1 } <unknown> moreover a k - tuple contain zero sequence contain zero case interest otherwise minimal period sequence greater 2k - 1 k - tuple determine next element 2k - 1 non - zero k - tuples let us call a sequence long minimal period exactly 2k - 1 . task find a long sequence a give k , input contain a single integer k ( 2 ≤ k ≤ 50 ) long sequence a give k output ` ` -1 '' ( without quote ) otherwise first line output contain k integer number : c1 c2 ... ck ( coefficients ) second line contain first k elements sequence : a0 a1 ... ak - 1 . ( elements coefficients ) equal 0 1 least one ci equal 1 . several solutions output <unknown> first sample : c1 = 1 c2 = 1 = - 1 + - 2 ( mod 2 ) thus sequence : period equal 3 = 22 - 1.2 . second sample : c1 = 0 c2 = 1 c3 = 1 = - 2 + - 3 ( mod 2 ) thus sequence : period equal 7 = 23 - 1 . periods color",['math'],2700.0
446/E,"dzy own 2 m islands near home number 1 2 m love build bridge connect islands every bridge build take one day 's time walk across dzy a strange rule build bridge every pair islands u v ( u ≠ v ) build 2k different bridge connect ( a|b mean b divisible a ) bridge bidirectional also dzy build bridge connect home islands specifically ai different bridge home i - th island one - way bridge leave home never come back dzy decide go islands sightsee first home choose walk across one bridge connect home arrive island , spend t day ( s ) islands day choose stay rest walk another island across bridge allow stay island one day 's also allow cross one bridge suppose right t - th day dzy stand i - th island let ans [ i ] number ways dzy reach i - th island t - th day task calculate ans [ i ] i modulo 1051131 . avoid huge input use follow way generate array a. give first s elements array : a1 a2 ... , elements calculate formula : ai = ( <unknown> - s + <unknown> ) mod 1051131 ( s < i ≤ 2 m ) first line contain three integers m t s ( 1 ≤ m ≤ 25 ; 1 ≤ t ≤ 1018 ; 1 ≤ s ≤ min ( 2 m 105 ) ) second line contain s integers a1 a2 ... ( 1 ≤ ai ≤ 106 ) avoid huge output need output xor - sum answer i modulo 1051131 ( 1 ≤ i ≤ 2 m ) i.e ( ans [ 1 ] mod 1051131 ) xor ( ans [ 2 ] mod 1051131 ) xor ... xor ( ans [ n ] mod 1051131 ) first sample ans = [ 6 7 6 6 ] want island 1 one day 6 different ways : second sample ( a1 a2 a3 a4 <unknown> <unknown> <unknown> <unknown> ) = ( <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> ) ans = [ <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> ]",['math'],3100.0
388/D,"fox ciel study number theory think a non - empty set s contain non - negative integers perfect ( a equal b ) , operation xor mean exclusive operation ( http : //en.wikipedia.org / wiki / exclusive_or ) please calculate number perfect set consist integers greater k. answer large print modulo 1000000007 ( 109 + 7 ) first line contain integer k ( 0 ≤ k ≤ 109 ) print a single integer — number require set modulo 1000000007 ( 109 + 7 ) example 1 2 set : { 0 } { 0 1 } note { 1 } a perfect set since 1 xor 1 = 0 { 1 } n't contain zero example 4 6 set : { 0 } { 0 1 } { 0 2 } { 0 3 } { 0 4 } { 0 1 2 3 }",['math'],2700.0
194/B,"a square paint a piece paper square 's side equal n meter john doe draw cross square 's perimeter john paint first cross lower leave corner square john move along square 's perimeter clockwise direction ( first upwards right downwards leave ) every time walk ( n + 1 ) meter draw a cross ( see picture clarifications ) john doe stop lower leave corner square two cross many cross john draw ? first line contain integer t ( 1 ≤ t ≤ 104 ) — number test case second line contain t space - separated integers ni ( 1 ≤ ni ≤ 109 ) — side square test sample test sample print a single line answer , number cross john draw move along square correspond size print answer sample order sample give input please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier",['math'],1200.0
100/E,n lamps a line lamps number 1 n leave right also n key key number i press lamps number x <unknown> change state two integer number a b say a|b exist integer c a × c = b. <unknown> like play key randomly press k key want know final state lamps help write a <unknown> piece code solve task first line input contain a single integer n number lamps ( 1 ≤ n ≤ 105 ) follow line contain n word i - th word describe initial state lamp number i ( see sample detail ) follow line contain a single integer k ( 1 ≤ k ≤ 104 ) number time a key press next line come k integers range [ 1 n ] number press key write n word output describe final state lamps see sample detail,['math'],1600.0
66/D,"little petya a birthday soon due wonderful event petya 's friends decide give sweets total number petya 's friends equal n. let us remind definition greatest common divisor : gcd ( a1 ... ak ) = d d represent a maximal positive number ai ( 1 ≤ i ≤ k ) evenly divisible d. assume ai 's greater zero know petya keen program friends agree beforehand 1 - st friend give a1 sweets 2 - nd one give a2 sweets ... n - th one give sweets time i j ( 1 ≤ i j ≤ n ) want gcd ( ai aj ) equal 1 . however also want follow condition satisfy : gcd ( a1 a2 ... ) = 1 . one : ai distinct help friends choose suitable number a1 ... , first line contain integer n ( 2 ≤ n ≤ 50 ) answer print ` ` -1 '' without quote otherwise print a set n distinct positive number a1 a2 ... , line must contain one number number must consist 100 digits must contain lead zero several solutions problem print forget please follow condition must true : please use % lld specificator read write 64 - bit integers c++ preffered use cout ( also may use % i64d )",['math'],1700.0
113/D,"one day petya friend vasya one <unknown> trip decide visit a museum castle museum a specific shape : consist n room connect m corridors one access room one two friends a little walk around museum decide split watch piece art find interest agree meet one room six p.m. however forget one quite <unknown> thing : n't specify place meet time come start rush museum look ( could n't call <unknown> make a call 's cost <unknown> ) yet even despite whole rush could n't get enough piece art 's follow strategy : minute make a decision go — probability pi n't move place minute ( i.e stay room ) probability 1 - pi equiprobably choose one adjacent room go along corridor i <unknown> number current room build expensive ancient time 's corridor connect two different room two room one corridor boys act simultaneously corridors dark impossible meet ; however one walk along corridors directions ( besides two boys go corridor simultaneously without meet ) boys act like meet formally two friends meet moment time decide appear room room find probability boys meet consider 6 p.m. position room a b correspondingly first line contain four integers : n ( 1 ≤ n ≤ 22 ) represent number room ; m represent number corridors ; a b ( 1 ≤ a b ≤ n ) represent number petya 's vasya 's start room correspondingly next m line contain pair number — number room connect a corridor next n line contain probabilities pi ( <unknown> ≤ pi ≤ <unknown> ) accuracy four digits decimal point — probability stay room i. guarantee every room reach every room corridors line print n space - separated number i - th number represent probability friends meet i - th room absolute relative error 10 - 6 . first sample museum symmetric mean probabilities meet room 1 2 equal sum equal one , probability equal 0.5",['math'],2700.0
114/A,petya go school get interest large number call ancient time instance learn russian word ` ` tma '' ( mean ` ` much count '' ) use stand a thousand ` ` tma <unknown> '' ( <unknown> mean ` ` tma <unknown> '' ) use stand a million petya want <unknown> word use number invent a word petricium represent number k. moreover petricium la petricium stand number k2 petricium la petricium la petricium stand <unknown> number form call petriciumus cifera number 's importance number article la title petya 's invention bring a challenge need solve quickly : number l belong set petriciumus cifera ? petya a busy schoolboy need automate process ask solve first input line contain integer number k second line contain integer number l ( 2 ≤ k l ≤ 231 - 1 ) print first line output ` ` yes '' number belong set petriciumus cifera otherwise print ` ` '' number belong set print second line number — importance number l,['math'],1000.0
115/C,little john <unknown> become a <unknown> ! today draw a grid consist n row m columns consist n × m square cells cell draw a pipe segment draw four type segment number 1 4 illustrate follow : pipe segment two end illustrate <unknown> picture example segment 1 end top leave side little john consider pip system leak least one pipe segment inside grid whose end connect another pipe 's end border grid image show example leak non - leaking systems size 1 × 2 . give grid partially fill little john cell either contain one four segment empty find number possible different non - leaking final systems little john finish fill empty cells pipe segment print number modulo 1000003 ( 106 + 3 ) note rotations flip grid allow two configurations identical one rotate flip either horizontally vertically consider two different configurations first line contain two single - space separate integers n m ( 1 ≤ n m n·m ≤ 5·105 ) — number row columns respectively n line follow contain exactly m character — description grid character describe a cell either one : print a single integer denote number possible final non - leaking pipe systems modulo 1000003 ( 106 + 3 ) configurations print 0 . first example initial configuration grid follow two possible final non - leaking pipe configurations follow : second example initial grid already leak final grid non - leaking final example 's one possible non - leaking final grid follow,['math'],2200.0
117/D,let a array consist n number array 's elements number 1 n even array consist numerals whose number even a ( <unknown> = a2i 1 ≤ 2i ≤ n ) odd array consist <unknown> whose number odd а ( <unknown> = a2i - 1 1 ≤ 2i - 1 ≤ n ) let 's define transformation array f ( a ) follow manner : let a array consist n number 1 2 3 ... n. b result apply transformation array a ( b = f ( a ) ) give m query ( l r u v ) task find query sum number bi l ≤ i ≤ r u ≤ bi ≤ v. print query result modulo mod first line contain three integers n m mod ( 1 ≤ n ≤ 1018 1 ≤ m ≤ 105 1 ≤ mod ≤ 109 ) next m line describe query query define four integers l r u v ( 1 ≤ l ≤ r ≤ n 1 ≤ u ≤ v ≤ 1018 ) please use % lld specificator read write 64 - bit integers c++ use % i64d specificator print m line contain integer — remainder modulo mod query result let 's consider first example first let 's construct array b = f ( a ) = f ( [ 1 2 3 4 ] ),['math'],2500.0
120/E,petya <unknown> play a interest game ` ` put a knight ! '' a chessboard n × n size game take turn put chess piece call ` ` knight '' board two knight could threat a knight locate square ( r c ) threat square ( r - 1 c + 2 ) ( r - 1 c - 2 ) ( r + 1 c + 2 ) ( r + 1 c - 2 ) ( r - 2 c + 1 ) ( r - 2 c - 1 ) ( r + 2 c + 1 ) ( r + 2 c - 1 ) ( square may locate outside chessboard ) player ca n't put a new knight move lose determine player win consider players play optimally well petya start first line contain integer t ( 1 ≤ t ≤ 100 ) — number board determine win player next t line contain t integers ni ( 1 ≤ ni ≤ 10000 ) — size <unknown> ni × ni board print a single line ` ` 0 '' petya win consider players play optimally well otherwise print ` ` 1 '',['math'],1400.0
78/D,a <unknown> among computer game ` ` civilization <unknown> '' strike scale <unknown> detail let 's take a closer look one play area game split <unknown> cells regular <unknown> side cell equal 1 . unit occupy exactly one cell play field field consider infinite let 's take a look battle unit call ` ` archer '' archer a parameter ` ` shoot range '' 's a positive integer determine radius circle archer hit a target center circle coincide center cell archer stay a cell consider archer ’ s fire point cell include border point locate inside circle border picture show border shoot range equal 3 4 5 . archer depict a. find number cells fire archer first line input contain a single positive integer k — archer 's shoot range ( 1 ≤ k ≤ 106 ) print single number number cells fire please use % lld specificator read write 64 - bit integers c++ prefer use cout stream ( also may use % i64d specificator ),['math'],2300.0
124/A,petr stand line n people n't know exactly position occupy say less a people stand front b people stand behind find number different position petr occupy line contain three integers n a b ( 0 ≤ a b < n ≤ 100 ) print single number — number seek position possible position first sample : 2 3 ( number position start 1 ) second sample 3 4 5,['math'],1000.0
77/B,reason many <unknown> cartoon anvils fall time time onto heroes ' head course safes <unknown> <unknown> plan fall sometimes ... anvils anvils come different size shape quite often get hero stick deep grind ever think throw anvils sky ? height ? sure question never trouble ! turn throw anvil properly easy task let 's describe one popular anvil throw model let height p potential victim vary range [ 0 ; a ] direction wind q vary range [ - b ; b ] p q could real ( float ) number assume anvil fit <unknown> 's head perfectly follow equation least one real root : determine probability aim successfully hit anvil assume p q coefficients choose equiprobably independently range first line contain integer t ( 1 ≤ t ≤ 10000 ) — amount testcases follow t line contain two space - separated integers a b ( 0 ≤ a b ≤ 106 ) pretests contain test 0 < a < 10 0 ≤ b < 10 . print t line — probability a successful anvil hit testcase absolute relative error answer exceed 10 - 6,['math'],1800.0
72/C,positive integer a a divisor positive integer b exist a positive integer c a × c = b. king <unknown> think a positive integer x extraordinarily nice number even divisors equal number odd divisors example 3 two positive divisors 3 1 odd 3 extraordinarily nice hand 2 divisible 2 1 one odd one even divisor therefore 2 extraordinarily nice give a positive integer x determine whether 's extraordinarily nice input contain a single integer x ( 1 ≤ x ≤ 103 ) write a single yes write yes number extraordinarily nice otherwise n't need care capital small letter output case - insensitive,['math'],1200.0
26/D,a big fan formula one charlie really happy fact organize ticket sell next <unknown> <unknown> race city unfortunately <unknown> <unknown> strike everywhere banknotes leave country value either 10 euros 20 euros price ticket race 10 euros whenever someone come ticket store 20 euro banknote charlie must a 10 euro banknote give change charlie realize huge <unknown> banknotes could a problem charlie <unknown> information could n't make use need help exactly n + m people come buy a ticket n a single 10 euro banknote m a single 20 euro banknote currently charlie k 10 euro banknotes use change need n + m people come ticket store random order order equiprobable return probability ticket sell process run smoothly i.e charlie change every person 20 euro banknote input consist a single line three space separate integers n m k ( 0 ≤ n m ≤ 105 0 ≤ k ≤ 10 ) output a single line desire probability least 4 digits decimal point,['math'],2400.0
113/C,math lesson a teacher ask <unknown> come lucky number a fan number theory peter choose prime number bob original say number t lucky number represent : boys decide find many days interval [ l r ] ( l ≤ r ) suitable pair program decide day i ( l ≤ i ≤ r ) suitable pair program number i lucky peter lucky bob time help boys find number days first line input contain integer number l r ( 1 ≤ l r ≤ <unknown> ) line print number days segment [ l r ] lucky peter bob time,['math'],2200.0
28/E,<unknown> ! empire <unknown> chickens try conquer a beautiful city ` ` z '' build a huge incubator produce millions chicken soldier a day fence around huge incubator look like a polygon plane oxy n vertices naturally dravde ca n't keep still want destroy chicken empire sure start incubator dravde strictly outside incubator 's territory point a ( xa ya ) want get inside kill chickens work take a lot ! problem recently dravde go <unknown> skate break legs get incubator 's territory <unknown> airplane levap-41 levap-41 fly speed v ( xv yv zv ) dravde get plane point a fly time air drop dravde <unknown> 's fall vertically speed fdown point free fall dravde open parachute moment start fall wind speed u ( xu yu zu ) land unfortunately dravde n't good mathematics would help poor world 's <unknown> find air drop plan allow land incubator 's territory ? answer unique dravde want find plan minimum time flight plane answer still multiple want find one minimum time free fall open <unknown> first line contain number n ( 3 ≤ n ≤ 104 ) — amount vertices fence follow n line contain coordinate vertices ( two integer number xi yi ) clockwise counter - clockwise order 's guarantee fence contain self - intersections follow four line contain coordinate point a ( xa ya ) speed v ( xv yv zv ) fdown speed u ( xu yu zu ) input number integer coordinate n't exceed 104 absolute value 's guarantee zv > 0 fdown zu < 0 point a strictly outside incubator 's territory first line output two number t1 t2 dravde air drop time t1 ( count begin flight ) land incubator 's territory ( land border <unknown> land territory ) dravde n't open parachute second number equal duration dravde 's fall 's impossible dravde get incubator 's territory output -1 -1 . answer unique output answer minimum t1 answer still multiple output answer minimum t2 answer must absolute relative error less 10 - 6,['math'],2800.0
32/C,know <unknown> berland jump vertically horizontally length jump always equal s centimeters a flea find center cell check board size n × m centimeters ( cell 1 × 1 centimeters ) jump wish arbitrary number time even visit a cell restriction jump board flea count amount cells reach start position ( x y ) let 's denote amount dx y. task find number start position ( x y ) maximum possible value dx y. first line contain three integers n m s ( 1 ≤ n m s ≤ 106 ) — length board width board length flea 's jump output integer — number require start position flea,['math'],1700.0
39/D,find anything whatsoever galaxy ! a cubical planet go round <unknown> star let us introduce a system ax edge cubical planet parallel coordinate ax two opposite vertices lay point ( 0 0 0 ) ( 1 1 1 ) two fly live planet moment sit two different vertices cubical planet task determine whether see fly see vertices occupy lie face cube first line contain three space - separated integers ( 0 1 ) — coordinate first fly second line <unknown> contain coordinate second fly output ` ` yes '' ( without quote ) fly see otherwise output ` ` '',['math'],1100.0
40/B,a chessboard n × m size give zero minute repaint black square 0 color i - th minute repaint i color initially black square exactly four corner - adjacent square paint i - 1 ( square repaint simultaneously ) process continue ad <unknown> figure many square repaint exactly x time upper leave square board assume always black two square call corner - adjacent exactly one common point first line contain integers n m ( 1 ≤ n m ≤ 5000 ) second line contain integer x ( 1 ≤ x ≤ 109 ) print many square paint exactly x time,['math'],1600.0
42/D,"volodya recently visit a odd town n <unknown> attractions town every two connect a bidirectional road road travel price ( natural number ) assign price distinct strike thing town city sightsee tour total price ! , choose city sightsee tour — a cycle visit every attraction exactly — sum cost tour roads independent tour volodya curious find price system road price greater 1000 . input contain one natural number ( 3 ≤ n ≤ 20 ) — number town attractions output contain n row contain n positive integer number — <unknown> matrix price graph ( thus j - th number i - th row equal price road j - th i - th attraction ) diagonal number equal zero number greater 1000 . price positive pairwise distinct several solutions output",['math'],2300.0
44/D,a far away galaxy n inhabit planets number number 1 n. locate large distance 's communication difficult planet number 1 a hyperdrive invent soon significant event take place n - 1 <unknown> build planet number 1 ship send planets inform revolutionary invention <unknown> think may hyperspace represent simple three - dimensional euclidean space inhabit planets may consider fix point two point coincide three point lie straight line movement a ship a hyperdrive two planets perform along a straight line constant speed ship 's distance hyperspace measure hyperyears ( a ship a hyperdrive cover a distance s hyperyears s years ) ship reach inhabit planet inhabitants planet dissemble make n - 2 identical ship a hyperdrive send n - 2 planets ( except one ship arrive ) time make a new ship compare time move one planet another small <unknown> new ship absolutely identical ones send initially : move constant speed along a straight line <unknown> reach a planet perform mission i.e dissemble build new n - 2 ship send planets except one ship arrive thus process spread important news around galaxy continue however hyperdrive <unknown> hurry spread news invention much n't study completely go two ship collide hyperspace two move ship find one point <unknown> explosion <unknown> power lead destruction galaxy ! task find time galaxy continue exist moment ship ' launch first planet first line contain a number n ( 3 ≤ n ≤ 5000 ) — number inhabit planets galaxy next n line contain integer coordinate planets format ` ` xi yi zi '' ( - 104 ≤ xi yi zi ≤ 104 ) print single number — solution task absolute relative error exceed 10 - 6,['math'],1800.0
47/A,a triangular number number dot equilateral triangle uniformly fill dot example three dot arrange a triangle ; thus three a triangular number n - th triangular number number dot a triangle n dot a side   learn number wikipedia ( http : //en.wikipedia.org / wiki / <unknown> ) task find a give integer a triangular number first line contain single number n ( 1 ≤ n ≤ 500 ) — give integer give integer a triangular number output yes otherwise output,['math'],800.0
48/C,"every year a race take place motorway cities a b. year vanya decide take part race drive car around bear <unknown> name — huff - puffer , vasya leave city a huff - puffer besides begin fill petrol tank α liters petrol ( α ≥ 10 vanya 's favorite number necessarily integer ) petrol station locate motorway interval 100 kilometers i.e first station locate 100 kilometers away city a second one 200 kilometers away city a third one 300 kilometers away city a huff - puffer spend 10 liters petrol every 100 kilometers vanya check petrol tank every time pass a petrol station petrol leave tank enough get next station vanya fill tank α liters petrol otherwise n't stop station drive example α = 43.21 car fuel first time station number 4 'll <unknown> petrol liters leave fuel car <unknown> liters vanya stop station number 8 end <unknown> + 43.21 = <unknown> liters next stop station number 12 <unknown> + 43.21 = <unknown> . next stop station number 17 wo n't believe huff - puffer lead race ! perhaps due unexpected snow perhaps due video <unknown> instal along motorway register speed limit break perhaps due fact vanya threaten <unknown> huff - puffer unless car win whatever reason huff - puffer lead <unknown> people together contestants <unknown> <unknown> try think a way stop <unknown> one way mine next petrol station vanya stop task calculate station happen <unknown> vanya n't know α number however give succession number station vanya stop find number station next stop first line contain integer n ( 1 ≤ n ≤ 1000 ) represent number petrol station vanya stop next line n space - separated integers represent number station number positive exceed 106 give increase order two number succession match guarantee exist least one number α ≥ 10 a succession stop correspond print first line ` ` unique '' ( without quote ) answer determine uniquely second line print number station next stop take place answer unique print first line ` ` unique '' second example answer unique example α = 10 'll a sequence 1 2 3 α = 14 sequence 1 2 4",['math'],1800.0
49/C,vasya buy collect work a well - known berland <unknown> petya n volumes volumes number 1 n. think arrange book simply accord order vasya want minimize number disposition ’ s divisors — positive integers i least one j ( 1 ≤ j ≤ n ) true : j mod i = 0 time p ( j ) mod i = 0 p ( j ) number tome stand j - th place mod operation take division remainder naturally one volume occupy exactly one place one place stand exactly one volume help vasya — find volume disposition minimum number divisors first line contain number n ( 1 ≤ n ≤ 100000 ) represent number volumes free place print n number — seek disposition minimum divisor number j - th number ( 1 ≤ j ≤ n ) equal p ( j ) — number tome stand j - th place several solutions print,['math'],1700.0
50/E,a schoolboy petya study square equations equations include school <unknown> usually look simple : petya notice equations two real root one root equations n't real root moreover turn several different square equations a common root petya interest many different real root equations type describe possible pair number b c 1 ≤ b ≤ n 1 ≤ c ≤ m. help petya find number single line contain two integers n m. ( 1 ≤ n m ≤ 5000000 ) print a single number number real root describe set equations second test statement follow equations analyse : b = 1 c = 1 : x2 + 2x + 1 = 0 ; root x = - 1 b = 1 c = 2 : x2 + 2x + 2 = 0 ; root overall 's one <unknown> second test follow equations analyse : b = 1 c = 1 : x2 + 2x + 1 = 0 ; root x = - 1 b = 1 c = 2 : x2 + 2x + 2 = 0 ; root b = 1 c = 3 : x2 + 2x + 3 = 0 ; root b = 2 c = 1 : x2 + 4x + 1 = 0 ; root b = 2 c = 2 : x2 + 4x + 2 = 0 ; root b = 2 c = 3 : x2 + 4x + 3 = 0 ; root x1 = - 3 x2 = - 1 b = 3 c = 1 : x2 + 6x + 1 = 0 ; root b = 3 c = 2 : x2 + 6x + 2 = 0 ; root b = 3 c = 3 : x2 + 6x + 3 = 0 ; root overall 13 root root - 1 repeat twice mean 12 different root,['math'],2300.0
100/I,ehsan love geometry ! especially like rotate point ! give a point plane ehsan like rotate k degrees ( counter - clockwise ) around origin result rotation ? a single integer k ( 0 ≤ k < 360 ) give first line two integer number x y give second line ( - 1390 ≤ x y ≤ 1390 ) write two number result rotation answer must a relative error less 10 - 1,['math'],1500.0
30/A,"a long time ago far country live king <unknown> recent king 's reform get large power start keep book total income a kingdom 0 - th year know well total income b n - th year ( number negative — mean a loss <unknown> year ) king want show financial <unknown> , need find common coefficient x — coefficient income growth one year coefficient satisfy equation : surely king go job demand find number x. necessary point fractional number use kingdom 's <unknown> 's input number well coefficient x must integers number x may zero negative input contain three integers a b n ( |a| |b| ≤ 1000 1 ≤ n ≤ 10 ) output require integer coefficient x « solution » a coefficient exist fractional several possible solutions output",['math'],1400.0
109/E,"petya love lucky number know lucky number positive integers whose decimal representations contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 one day petya come across interval number [ a a + l - 1 ] let f ( x ) number lucky digits number x. find minimum b ( a < b ) f ( a ) = f ( b ) f ( a + 1 ) = f ( b + 1 ) ... f ( a + l - 1 ) = f ( b + l - 1 ) single line contain two integers a l ( 1 ≤ a l ≤ 109 ) — interval 's first number interval 's length correspondingly single line print number b — answer problem consider [ a b ] denote interval integers ; interval include boundaries ,",['math'],2700.0
60/D,misha decide help pasha <unknown> friends a <unknown> plan — destroy laughy mushroom know laughy mushroom easily burst laugh mushroom grow lawns a [ t ] mushroom t - th lawn misha know lawns mushroom grow a unique ability a lawn ( say i ) transfer laugh lawn ( say j ) exist integer ( say b ) permutation number a [ i ] a [ j ] b a beautiful triple ( i ≠ j ) a beautiful triple three pairwise coprime number x y z satisfy follow condition : x2 + y2 = z2 misha want know minimal number lawns laugh laughy mushroom burst first line contain one integer n ( 1 ≤ n ≤ 106 ) number lawns next line contain n integers ai number mushroom i - lawn ( 1 ≤ ai ≤ 107 ) number different print a single number — minimal number lawns misha laugh mushroom burst,['math'],2500.0
60/E,"upon a time <unknown> mushroom forest live mushroom gnomes famous among neighbor magic mushroom magic nature make possible every two neighbor mushroom every minute grow another mushroom weight equal sum weight two neighbor ones mushroom gnomes love everything order 's always plant mushroom one line order weight ' increase well ... gnomes plant mushroom go eat x minutes return saw new mushroom grow increase order violate gnomes replant mushroom correct order , sort mushroom order weight ' increase go eat ( gnomes quite big <unknown> ) total weight modulo p mushroom another y minutes ? first line contain four integers n x y p ( 1 ≤ n ≤ 106 0 ≤ x y ≤ 1018 x + y > 0 2 ≤ p ≤ 109 ) represent number mushroom number minutes first replant number minutes second replant module next line contain n integers ai represent mushroom ' weight non - decreasing order ( 0 ≤ ai ≤ 109 ) please use % lld specificator read write 64 - bit integers c++ preffered use cin ( also may use % i64d ) answer contain a single number total weight mushroom modulo p end x + y minutes",['math'],2600.0
73/E,vasya play elder <unknown> iii : <unknown> a huge list items inventory however limit size things vasya know total amount items sure x less 2 items inventory a new patch game appear view inventory n different modes display mode i a partition inventory items page ( except maybe last one ) show exactly ai items addition mode show many page bi a complete list great ! perhaps information enough vasya find require number moreover interest fewest number modes vasya see inventory determine number items ? vasya use information receive look inventory mode selection next action i. e. vasya choose set modes first see result determine size know number ai x assume vasya smart check whether uniquely determine number items inventory many modes need know number ai x able know number bi view items mode i. first line contain two integers n x ( 0 ≤ n ≤ 105 2 ≤ x ≤ 109 ) second line contain integers ai ( 1 ≤ ai ≤ 109 ) number among ai may equal output fewest amount modes require uniquely determine amount items inventory solution output - 1 . second example vasya able determine items count uniquely 3 items well 4 items display two page,['math'],2400.0
125/A,lengths measure baden inch feet a length centimeters enough know inch equal three centimeters baden one foot contain 12 inch give a length equal n centimeters task convert feet inch number feet maximum result integer round closest value contain integral number inch note round 1 cm round 0 inch 2 cm round 1 inch line contain integer n ( 1 ≤ n ≤ 10000 ) print two non - negative space - separated integers a b a number feet b number inch,['math'],1400.0
126/A,bob take a hot bath two tap fill bath : a hot water tap a cold water tap cold water 's temperature t1 hot water 's temperature t2 cold water tap transmit integer number water units per second 0 x1 inclusive similarly hot water tap transmit 0 x2 water units per second y1 water units per second flow first tap y2 water units per second flow second tap result bath water temperature : bob want open tap bath water temperature less t0 however temperature close possible value several optimal variants bob choose one let fill bath quickest way possible determine much tap open bob please result end give five integers t1 t2 x1 x2 t0 ( 1 ≤ t1 ≤ t0 ≤ t2 ≤ 106 1 ≤ x1 x2 ≤ 106 ) print two space - separated integers y1 y2 ( 0 ≤ y1 ≤ x1 0 ≤ y2 ≤ x2 ) second sample hot water tap n't open cold water tap open full capacity order fill bath quickest way possible,['math'],1900.0
131/C,n boys m girls attend a theatre club set a play ` ` big <unknown> theory '' need choose a group contain exactly t <unknown> contain less 4 boys less one girl many ways choose a group ? course variants differ <unknown> <unknown> consider different perform calculations 64 - bit type : long long с / с++ <unknown> <unknown> long java line input data contain three integers n m t ( 4 ≤ n ≤ 30 1 ≤ m ≤ 30 5 ≤ t ≤ n + m ) find require number ways please use % lld specificator read write 64 - bit integers с++ prefer use cin cout stream % i64d specificator,['math'],1400.0
195/D,valeric valerko watch one last euro championship game a sport bar break a mug course guy pay barman say let watch football bar help son complete a program task task go like let 's consider a set function follow form : valeric valerko really want watch next euro championship game ask help first line contain integer n ( 1 ≤ n ≤ 105 ) — number function follow n line contain two space - separated integer number ki bi ( - 109 ≤ ki bi ≤ 109 ) determine i - th function print a single number — number angle equal 180 degrees graph polyline equal sum give function,['math'],1900.0
197/A,' ve get a rectangular table length a width b infinite number plat radius r. two players play follow game : take turn put plat table plat n't lie ( touch ) point plate locate within table 's border game one move plat already lie table player make another move lose determine player win one move first one move second provide players play optimally well a single line contain three space - separated integers a b r ( 1 ≤ a b r ≤ 100 ) — table side plat ' radius correspondingly win player move first print ` ` first '' ( without quote ) otherwise print ` ` second '' ( without quote ) first sample table place one plate first player put a plate table second player ca n't lose second sample table small n't enough place even one plate first player lose without make a single move,['math'],1600.0
197/B,give two polynomials : calculate limit first line contain two space - separated integers n m ( 0 ≤ n m ≤ 100 ) — degrees polynomials p ( x ) q ( x ) correspondingly second line contain n + 1 space - separated integers — factor polynomial p ( x ) : a0 a1 ... - 1 ( - 100 ≤ ai ≤ 100 a0 ≠ 0 ) third line contain m + 1 space - separated integers — factor polynomial q ( x ) : b0 b1 ... bm - 1 bm ( - 100 ≤ bi ≤ 100 b0 ≠ 0 ) limit equal + ∞ print ` ` infinity '' ( without quote ) limit equal - ∞ print ` ` <unknown> '' ( without quote ) value limit equal zero print ` ` 0/1 '' ( without quote ) otherwise print irreducible fraction — value limit format ` ` p / q '' ( without quote ) p — numerator q ( q > 0 ) denominator fraction let 's consider sample : learn definition properties limit follow link : http : //en.wikipedia.org / wiki / <unknown>,['math'],1400.0
201/B,a widely know among people belarusian sport programmer yura possess lot information cars invite participate a game show call ` ` guess car ! ` ` game show take place a giant park lot 4n meter long north south 4 m meter wide west east lot n + 1 divide line draw west east m + 1 divide line draw north south divide park lot n·m 4 4 meter square a car park strictly inside square divide line number 0 n north south 0 m west east square coordinate ( i j ) square north - west corner coordinate ( 1 1 ) square south - east corner coordinate ( n m ) see picture note clarifications game show organizers offer yura occupy ( n + 1 ) · ( m + 1 ) intersection point divide line start guess cars yura choose a point prohibit move along park lot end game show yura a car expert always guess cars offer 's a matter time yura know guess car need spend time equal square euclidean distance point center square car multiply coefficient characterize machine 's ` ` rarity '' ( <unknown> car harder guess ) formally guess a car ` ` rarity '' c place a square whose center distance d yura take <unknown> second time yura spend turn head <unknown> happen yura know ` ` rarity '' car park lot advance help choose point total time guess cars smallest possible first line contain two integers n m ( 1 ≤ n m ≤ 1000 ) — size park lot next n line contain m integers : j - th number i - th line describe ` ` rarity '' cij ( 0 ≤ cij ≤ 100000 ) car locate square coordinate ( i j ) first line print minimum total time yura need guess offer cars second line print two number li lj ( 0 ≤ li ≤ n 0 ≤ lj ≤ m ) — number divide line form a junction yura choose stand begin game show multiple optimal start point print point smaller li still multiple point print point smaller lj please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first test case total time guess cars equal 3·8 + 3·8 + <unknown> + <unknown> + <unknown> + <unknown> = <unknown> . coordinate system field :,['math'],1800.0
204/C,little elephant love furik rubik meet a small city <unknown> little elephant two string equal length a b consist uppercase english letter little elephant select a pair substrings equal length — first one string a second one string b. choice equiprobable among possible pair let 's denote substring a x substring b — y. little elephant give string x furik string y — rubik let 's assume f ( x y ) number position i ( 1 ≤ i ≤ |x| ) xi = yi ( |x| length line x y xi yi i - th character string x y correspondingly ) help furik rubik find expect value f ( x y ) first line contain a single integer n ( 1 ≤ n ≤ 2·105 ) — length string a b. second line contain string a third line contain string b. string consist uppercase english letter length string equal n. a single line print a real number — answer problem answer consider correct relative absolute error exceed 10 - 6 . let 's assume give string a = a1a2 ... a|a| let 's denote string 's length |a| i - th character — ai a substring a [ l ... r ] ( 1 ≤ l ≤ r ≤ |a| ) string a string alal + 1 ... ar string a a substring string b exist pair integers l r ( 1 ≤ l ≤ r ≤ |b| ) b [ l ... r ] = a. let 's consider first test sample first sample 5 possible substring pair : ( ` ` a '' ` ` b '' ) ( ` ` a '' ` ` a '' ) ( ` ` b '' ` ` b '' ) ( ` ` b '' ` ` a '' ) ( ` ` ab '' ` ` ba '' ) second third pair value f ( x y ) equal 1 rest equal 0 . probability choose pair equal 's answer · 0 + · 1 + · 1 + · 0 + · 0 = = <unknown>,['math'],2000.0
64/E,positive integer number x call prime exactly two positive integer divisors example 2 3 17 <unknown> prim 1 10 120 give integer number n find shortest segment [ a b ] contain n ( i.e a ≤ n ≤ b ) a b prim give line contain integer number n ( 2 ≤ n ≤ 10000 ) print space separate pair require number a b,['math'],1800.0
209/B,flatland inhabit pixels three color : red green blue know two pixels different color meet a violent fight one survive fight ( total number pixels decrease one ) besides pixels color x y ( x ≠ y ) meet a violent fight pixel survive fight immediately change color z ( z ≠ x ; z ≠ y ) pixels color friends n't fight king flatland know land peaceful prosperous pixels color three color know number pixels color inhabit flatland help king determine whether fight bring peace prosperity country possible find minimum number fight need make land peaceful prosperous first line contain three space - separated integers a b c ( 0 ≤ a b c ≤ 231 ; a + b + c > 0 ) — number red green blue pixels correspondingly print a single number — minimum number pixel fight country become peaceful prosperous make country peaceful prosperous impossible print -1 . first test sample country need one fight achieve peace prosperity besides fight whatsoever example let 's assume green blue pixels fight survive pixel red a result fight two red pixels wo n't pixels second sample follow sequence fight possible : red blue green red red blue a result fight one green pixel leave,['math'],2100.0
217/B,"fibonacci number sequence integers : <unknown> = 0 f1 = 1 f2 = 1 <unknown> = 2 <unknown> = 3 <unknown> = 5 ... fn = fn - 2 + fn - 1 . every next number sum previous two bajtek develop a nice way compute fibonacci number a blackboard first write a 0 . , write a 1 . perform follow two operations : perform n operations start ` ` t '' choose operations alternately ( sequence operations look like ` ` <unknown> ... '' ) last number write equal fn + 1 . unfortunately bajtek sometimes make mistake repeat operation two time a row example bajtek want compute <unknown> would want n = 6 operations : ` ` <unknown> '' instead perform sequence operations ` ` <unknown> '' make 3 mistake <unknown> compute seventh fibonacci number 10 . number mistake sequence operations number neighbour equal operations ( « tt » « bb » ) give number n operations bajtek make attempt compute fn + 1 number r result <unknown> ( last write number ) find minimum possible number mistake bajtek must make possible sequence n operations result r number mistake assume bajtek always correctly start operation ` ` t '' first line contain integers n r ( 1 ≤ n r ≤ 106 ) first line output contain one number — minimum possible number mistake make bajtek second line contain n character start ` ` t '' describe one possible sequence operations number mistake character must either ` ` t '' ` ` b '' require sequence n't exist output ` ` impossible '' ( without quote )",['math'],2100.0
217/D,byteland try send a space mission onto bit - x planet task complicate fact orbit planet regularly patrol captain bitonix leader space force bit - x n station around bit - x number clockwise 1 n. station evenly place a circular orbit station number i i + 1 ( 1 ≤ i < n ) station number 1 n neighbor distance every pair adjacent station equal m space miles go a patrol captain bitonix jump rocket one station fly a circle cover a distance least one space <unknown> finish ( perhaps start ) station bitonix ' rocket move burn fuel tank bitonix attach x - liter fuel tank choose direction ( clockwise counter - clockwise ) rocket fly exactly x space miles along a circular orbit choose direction note rocket <unknown> ; possible rocket stop <unknown> a fuel tank example assume n = 3 m = 60 bitonix fuel tank volumes 10 60 90 100 liters bitonix start station 1 use 100 - liter fuel tank go clockwise use 90 - liter fuel tank go clockwise use 10 - liter fuel tank go counterclockwise finish back station 1 . <unknown> a valid patrol note bitonix use available fuel tank another valid option bitonix example would simply use 60 - liter fuel tank fly either station 2 3 . however n equal 3 m equal 60 fuel tank available bitonix one 10 - liter tank one 100 - liter tank would way complete a valid patrol ( would n't able finish patrol exactly station ) byteland space agency want destroy captain bitonix ' fuel tank complete valid patrol find many different subsets tank agency destroy prevent captain bitonix complete a patrol output answer modulo 1000000007 ( 109 + 7 ) first line input contain three integers n ( 2 ≤ n ≤ 1000 ) — number station m ( 1 ≤ m ≤ 120 ) — distance adjacent station t ( 1 ≤ t ≤ 10000 ) — number fuel tank own captain bitonix second line input contain t space - separated integers 1 109 inclusive — volumes bitonix ' fuel tank output a single number — number distinct subsets tank bytelandian space agency destroy order prevent captain bitonix complete a patrol modulo 109 + 7 . fuel tank distinct even capacity,['math'],2900.0
220/D,"little elephant play cartesian coordinate ' system like play integer point little elephant define integer point a pair integers ( x ; y ) 0 ≤ x ≤ w 0 ≤ y ≤ h. thus little elephant know ( w + 1 ) · ( h + 1 ) distinct integer point little elephant want paint a triangle vertexes integer point triangle 's area must a positive integer , need find number group three point form triangle , order point a group matter , group three point ( 0 ; 0 ) ( 0 ; 2 ) ( 2 ; 2 ) n't equal group ( 0 ; 2 ) ( 0 ; 0 ) ( 2 ; 2 ) help little elephant find number group three integer point form a <unknown> triangle integer area a single line contain two integers w h ( 1 ≤ w h ≤ 4000 ) a single output line print integer — remainder divide answer problem 1000000007 ( 109 + 7 )",['math'],2500.0
223/C,' ve get array a consist n integers array elements index 1 n. let 's determine a two step operation like : task find array a exactly k describe operations apply first line contain two space - separated integers n k ( 1 ≤ n ≤ 2000 0 ≤ k ≤ 109 ) next line contain n space - separated integers a1 a2 ... — elements array a ( 0 ≤ ai ≤ 109 ) print n integers — elements array a operations apply print elements order increase index array a. separate print number space,['math'],1900.0
224/A,' ve get a rectangular parallelepiped integer edge lengths know areas three face a common vertex task find sum lengths 12 edge parallelepiped first single line contain three space - separated integers — areas parallelepiped 's face area 's value positive ( > 0 ) exceed 104 . guarantee exist least one parallelepiped satisfy problem statement print a single number — sum edge parallelepiped first sample parallelepiped size 1 × 1 × 1 second one — 2 × 2 × 3,['math'],1100.0
225/E,consider follow equation : let 's find integer z ( z > 0 ) equation unsolvable positive integers phrase ` ` unsolvable positive integers '' mean positive integers x y ( x y > 0 ) give equation hold let 's write z increase order : z1 z2 <unknown> ( zi < zi + 1 ) task : give number n find number zn first line contain a single integer n ( 1 ≤ n ≤ 40 ) print a single integer — number zn modulo 1000000007 ( 109 + 7 ) guarantee answer exist,['math'],2100.0
226/A,"expedition group fly planet <unknown> earth order study <unknown> species ( representatives n't even <unknown> head ! ) fly saucer brave <unknown> set consist three section section connect a chain : 1 - st section adjacent 2 - nd one 2 - nd one — 1 - st 3 - rd ones 3 - rd one — 2 - nd one <unknown> possible adjacent section <unknown> team consist n alien give a rank — integer 1 n. rank astronauts distinct rule establish saucer state alien may move section a section b senior rank alien segment a b ( besides segment a b course require adjacent ) alien require exactly 1 minute make a move besides safety <unknown> require one alien move minute along ship alien a senior rank alien b number indicate rank a correspond number b. moment whole saucer team 3 - rd segment need move 1 - st segment one member crew alien <unknown> number cfr-140 decide calculate minimum time ( minutes ) need perform task help cfr-140 figure minimum time ( minutes ) astronauts need move 3 - rd segment 1 - st one since number rather large count modulo m. first line contain two space - separated integers : n m ( 1 ≤ n m ≤ 109 ) — number alien saucer number modulo print answer correspondingly print a single number — answer problem modulo m. first sample crew member move segment 3 segment 2 segment 2 segment 1 without problems thus whole move take two minutes <unknown> describe movements second sample use value would correspond alien rank i move segment moment segment number j. use value describe movements segment second sample : , , , , , , , , , , , , ; total : alien need 26 move remainder divide 26 8 equal 2 answer test 2",['math'],1400.0
233/B,let 's consider equation : x n positive integers s ( x ) function equal sum digits number x decimal number system give integer n find smallest positive integer root equation x else determine root a single line contain integer n ( 1 ≤ n ≤ 1018 ) — equation parameter please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print -1 equation n't integer positive root otherwise print smallest integer x ( x > 0 ) equation give statement hold first test case x = 1 minimum root s ( 1 ) = 1 12 + 1·1 - 2 = 0 . second test case x = 10 minimum root s ( 10 ) = 1 + 0 = 1 102 + <unknown> - 110 = 0 . third test case equation root,['math'],1400.0
238/A,a sequence non - negative integers a1 a2 ... length n call a wool sequence exist two integers l r ( 1 ≤ l ≤ r ≤ n ) word wool sequence contain a subsequence consecutive elements xor equal 0 . expression mean apply operation a bitwise xor number x y. give operation exist modern program languages example languages c++ java mark ` ` ^ '' pascal — ` ` xor '' problem ask compute number sequence make n integers 0 2 m - 1 a wool sequence print number modulo 1000000009 ( 109 + 9 ) line input contain two space - separated integers n m ( 1 ≤ n m ≤ 105 ) print require number sequence modulo 1000000009 ( 109 + 9 ) line output sequence length 3 make integers 0 1 2 3 a wool sequence ( 1 3 1 ) ( 1 2 1 ) ( 2 1 2 ) ( 2 3 2 ) ( 3 1 3 ) ( 3 2 3 ),['math'],1300.0
248/B,chilly willy love play number know prime number digits yet number 2 3 5 7 . willy grow rather bore number come a game connect chilly willy want find minimum number length n simultaneously divisible number willy already know ( 2 3 5 7 ) help a number 's length number digits decimal representation without lead zero a single input line contain a single integer n ( 1 ≤ n ≤ 105 ) print a single integer — answer problem without lead zero ` ` -1 '' ( without quote ) number meet problem condition exist,['math'],1400.0
216/E,"know martians use a number system base k. digit b ( 0 ≤ b < k ) consider lucky first contact martians <unknown> occur year b ( martian <unknown> ) a digital root d ( x ) number x a number consist a single digit result cascade sum digits number x. word ` ` cascade '' mean first sum give us a number consist several digits sum digits , get a one digit number example d ( <unknown> ) = d ( ( 3 + 5 + 0 + 4 ) 7 ) = d ( <unknown> ) = d ( ( 1 + 5 ) 7 ) = d ( 67 ) = 67 . sample calculations perform 7 - base notation a number 's digital root equal b martians also call number lucky string s consist n digits k - base notation system task find many distinct substrings give string lucky number lead zero permit number note substring s [ i ... j ] string s = a1a2 ... ( 1 ≤ i ≤ j ≤ n ) string <unknown> + 1 ... aj two substrings s [ i1 ... j1 ] s [ i2 ... j2 ] string s different either i1 ≠ i2 j1 ≠ j2 first line contain three integers k b n ( 2 ≤ k ≤ 109 0 ≤ b < k 1 ≤ n ≤ 105 ) second line contain string s a sequence n integers represent digits k - base notation : i - th integer equal ai ( 0 ≤ ai < k ) — i - th digit string s. number line space - separated print a single integer — number substrings lucky number please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first sample follow substrings seek digital root : s [ 1 ... 2 ] = ` ` 3 2 '' s [ 1 ... 3 ] = ` ` 3 2 0 '' s [ 3 ... 4 ] = ` ` 0 5 '' s [ 4 ... 4 ] = ` ` 5 '' s [ 2 ... 6 ] = ` ` 2 0 5 6 1 ''",['math'],2000.0
61/C,'s <unknown> ad shapur extremely smart become king persia call shapur <unknown> king kings <unknown> <unknown> recently romans declare war persia dream occupy armenia recent war romans <unknown> defeat senior army general philip capture shapur shapur go capture valerian roman <unknown> defeat <unknown> valerian hide a room top one castle capture shapur open many doors fortunately valerian scar make <unknown> lock doors door 4 part first part integer number a. second part either integer number b really odd sign look like r. third one integer c fourth part empty ! lay write something extremely gift open first doors shapur find secret behind <unknown> integer write base a open door write base b. bad news r sort special number system use roman empire open doors a piece cake ! 's explanation really weird number system even n't zero : roman numerals base seven symbols : a stroke ( identify letter i ) a unit a <unknown> ( identify letter v ) a five a cross - stroke ( identify letter x ) a ten a c ( identify <unknown> <unknown> ) a hundred etc : symbols iterate produce <unknown> decimal ( 1 10 100 1 000 ) value v l d <unknown> a multiple five iteration continue : i 1 <unknown> 2 iii 3 v 5 vi 6 <unknown> 7 etc . base : x 10 xx 20 <unknown> 30 l 50 <unknown> 80 ; cc 200 <unknown> <unknown> etc fourth ninth iteration a <unknown> <unknown> must employ base place higher base : <unknown> 4 <unknown> 9 <unknown> 40 <unknown> 90 cd 400 cm 900 . also base greater 10 use a 10 b 11 etc help shapur capture valerian bring peace back persia especially armenia first line contain two integers a b ( 2 ≤ a b ≤ 25 ) b may replace r indicate roman number system next line contain a single non - negative integer c base a may contain lead zero length n't exceed 103 . guarantee roman numerals include number would less equal <unknown> wo n't 0 . case number wo n't greater <unknown> . write a single line contain integer c base b. must omit lead zero find information roman numerals : http : //en.wikipedia.org / wiki / <unknown>,['math'],2000.0
108/B,<unknown> 's <unknown> brother tuftuf new program since older brother a good programmer biggest dream <unknown> tuftuf a student german university cairo ( guc ) learn write program gava today tuftuf introduce gava 's unsigned integer datatypes gava n unsigned integer datatypes size ( bits ) a1 a2 ... i - th <unknown> size ai bits represent every integer 0 <unknown> - 1 inclusive tuftuf think learn a better program language exist integer x x fit type i ( ai bits ) <unknown> fit type j ( aj bits ) ai < aj tuftuf stop use gava task determine tuftuf 's <unknown> first line contain integer n ( 2 ≤ n ≤ 105 ) — number gava 's unsigned integer datatypes ' size second line contain a single - space - separated list n integers ( 1 ≤ ai ≤ 109 ) — size datatypes bits datatypes may equal size print ` ` yes '' tuftuf stop use gava ` ` '' otherwise second example x = 7 ( 1112 ) fit 3 bits x2 = <unknown> ( <unknown> ) fit 4 bits,['math'],1400.0
195/A,valeric valerko miss last euro football game decide watch game 's key moments net want start watch soon possible connection speed low turn video right ` ` hang '' size data watch per second size download data per second guy want watch whole video without pause wait integer number second a part video download number second pass start watch wait whole video download n't necessary video download guy start watch let 's suppose video 's length c second valeric valerko wait t second watch moment time t0 t ≤ t0 ≤ c + t follow condition must fulfill : size data receive t0 second less size data need watch t0 - t second video course guy want wait little possible task find minimum integer number second wait turn video guy must watch video without pause first line contain three space - separated integers a b c ( 1 ≤ a b c ≤ 1000 a > b ) first number ( a ) denote size data need watch one second video second number ( b ) denote size data valeric valerko download net per second third number ( c ) denote video 's length second print a single number — minimum integer number second valeric valerko must wait watch football without pause first sample video 's length 1 second necessary 4 units data watch 1 second video guy download 4 · 1 = 4 units data watch whole video optimal way wait 3 second till 3 units data download start watch guy watch video 1 second one unit data download <unknown> valerko 4 units data end watch also every moment till end video guy data necessary watch second sample guy need 2 · 10 = 20 units data wait 5 second 20 units second second end however guy wait 4 second able watch first second video without pause download 18 units data end second second less necessary,['math'],1000.0
140/A,gerald set new year table table form a circle ; radius equal r. gerald invite many guests concern whether table enough space plat guests consider plat round <unknown> equal r. plate must completely inside table must touch edge table course plat must intersect touch help gerald determine whether table large enough n plat first line contain three integers n r r ( 1 ≤ n ≤ 100 1 ≤ r r ≤ 1000 ) — number plat radius table plat ' radius print ` ` yes '' ( without quote ) possible place n plat table rule give impossible print ` ` '' remember plate must touch edge table possible arrangement plat first sample :,['math'],1700.0
141/B,<unknown> half winter maria dream summer 's feed skate <unknown> dream hopscotch night long 's a popular children 's game game field court look show figure ( block square number bottom top block row number leave right ) let us describe hopscotch number denote number square row star lowest one : 1 - 1 - 2 - 1 - 2 - 1 - <unknown> ( 1 - 2 ) ... period repeat ( 1 - 2 ) coordinate system define show figure side square equal length a. maria a smart clever girl concern quite serious issue : throw a stone a point coordinate ( x y ) hit square ? answer positive also require determine number square believe stone fall square locate strictly inside word a stone fall square border consider a hit a square input line contain three integers : a x y a ( 1 ≤ a ≤ 100 ) side square x y ( - 106 ≤ x ≤ 106 0 ≤ y ≤ 106 ) coordinate stone print number square inside stone fell stone a border stone outside court print ` ` -1 '' without quote,['math'],1400.0
142/A,upon a time kingdom far far away live sam farmer sam a cow name dawn deeply attach sam would spend whole summer <unknown> hay fee dawn winter sam <unknown> hay put haystack sam a <unknown> farmer try make process store hay <unknown> <unknown> use collect hay cubical hay block size store block barn a summer spend hard <unknown> sam store <unknown> hay block store a barn a rectangular parallelepiped a layer high layer b row row c block end autumn sam come barn <unknown> one time hay 'd stack hard summer unfortunately sam <unknown> see hay block <unknown> scatter around barn place a complete mess turn thieve <unknown> barn completely dissemble take away a layer block parallelepiped 's front back top side a result barn a parallelepiped contain ( a - 1 ) × ( b - 2 ) × ( c - 2 ) hay block hide <unknown> <unknown> thieve dissemble parallelepiped single 1 × 1 × 1 block scatter around barn theft sam count n hay block barn forget number a b и c. give number n find <unknown> possible maximally possible number steal hay block line contain integer n problem 's statement ( 1 ≤ n ≤ 109 ) print space - separated minimum maximum number hay block could steal thieve note answer problem large enough must use 64 - bit integer type calculations please use % lld specificator read write 64 - bit integers с++ prefer use cin cout stream % i64d specificator let 's consider first sample test initially sam a parallelepiped consist 32 = 2 × 4 × 4 hay block barn theft barn 4 = ( 2 - 1 ) × ( 4 - 2 ) × ( 4 - 2 ) hay block leave thus thieve could steal 32 - 4 = 28 hay block sam initially a parallelepiped consist 45 = 5 × 3 × 3 hay block barn theft barn 4 = ( 5 - 1 ) × ( 3 - 2 ) × ( 3 - 2 ) hay block leave thus thieve could steal 45 - 4 = 41 hay block variants block ' initial arrangement ( leave sam exactly 4 block theft ) permit thieve steal less 28 41 block,['math'],1600.0
143/A,vasilisa wise kingdom far far away get a magic box a secret a present friend <unknown> wise kingdom a little closer however vasilisa wise know box 's secret since open hop help one time box 's lock look follow : contain 4 identical deepen gems a 2 × 2 square integer number write lock 's edge near deepen example a lock give picture box <unknown> 9 gems shape match deepen ' shape gem contain one number 1 9 ( number write exactly one gem ) box open decorate gems correctly : deepen lock fill exactly one gem also sum number square 's row columns two diagonals square match number write lock 's edge example lock open fill deepen gems number show picture vasilisa wise want define give number box 's lock gems put deepen open box help vasilisa solve challenge task input contain number write edge lock box first line contain space - separated integers r1 r2 define require sum number row square second line contain space - separated integers c1 c2 define require sum number columns square third line contain space - separated integers d1 d2 define require sum number main side diagonals square ( 1 ≤ r1 r2 c1 c2 d1 d2 ≤ 20 ) correspondence 6 variables place write show picture clarifications please look second sample test demonstrate example give problem statement print scheme decorate box stone : two line contain two space - separated integers 1 9 . number pairwise different solution give lock print single number ` ` -1 '' ( without quote ) several solutions output pay attention last test statement : impossible open box vasilisa wise would need 4 identical gems contain number ` ` 5 '' however vasilisa one gem number 1 9,['math'],1000.0
150/A,ca n't possibly imagine cold friends winter nvodsk ! two play follow game warm : initially a piece paper integer q. a move a player write integer number a non - trivial divisor last write number run number circle around hotel let us remind a number 's divisor call non - trivial different one divide number first person ca n't make a move win continue lie warm bed three <unknown> one keep run determine player win consider players play optimally first player win print win first move first line contain integer q ( 1 ≤ q ≤ 1013 ) please use % lld specificator read write 64 - bit integers с++ prefer use cin cout stream % i64d specificator first line print number win player ( 1 2 ) first player win second line contain another integer — first move ( first player ca n't even make first move print 0 ) multiple solutions print number 6 two non - trivial divisors : 2 3 . impossible make a move number 2 3 write win thus number 6 lose number a player make a move write number 6 number 30 ; 6 know a lose number thus move bring us victory,['math'],1400.0
150/B,case somebody miss : winter totally cold nvodsk ! cold one get funny thoughts example let 's say string length exactly n base alphabet size m. substring length equal k a palindrome many string exist ? task find quantity modulo 1000000007 ( 109 + 7 ) careful n't miss a string two ! let us remind a string a palindrome read way either direction leave right right leave first line contain three integers : n m k ( 1 ≤ n m k ≤ 2000 ) print a single integer — number string describe type modulo 1000000007 ( 109 + 7 ) first sample one string valid : ` ` a '' ( let 's denote letter alphabet ` ` a '' ) second sample ( denote alphabet letter ` ` a '' ` ` b '' ) follow string valid : ` ` <unknown> '' ` ` <unknown> '',['math'],1600.0
251/D,little petya like number a lot recently mother present a collection n non - negative integers 's one thing petya like number : play little masha immediately decide give a part new collection make game even interest petya decide give masha collection number follow condition fulfill : xor operation a bitwise exclude ` ` '' denote ` ` xor '' pascal language ` ` ^ '' c / c++/java help petya divide collection describe multiple suitable ways divide find please note petya give a part number masha may number leave reverse situation also possible petya give nothing masha case must assume xor empty set number equal 0 . first line contain integer n ( 1 ≤ n ≤ 105 ) show many number petya 's mother give second line contain actual space - separated number integer non - negative exceed 1018 . print n space - separated integers i - th equal either 1 petya keep number follow i - th collection equal 2 petya give correspond number masha number index order give input,['math'],2700.0
154/B,2312 n large hadron colliders inhabit part universe correspond a single natural number 1 n. however scientists know activate several colliders simultaneously could cause colliders deactivate 2312 a <unknown> <unknown> : a collider 's activity safe number activate colliders pairwise relatively prime ( two number relatively prime greatest common divisor equal 1 ) ! two colliders relatively <unknown> number activate cause a <unknown> <unknown> upon learn <unknown> rush turn colliders carry sort experiment make sure scientists ' <unknown> n't end big trouble large hadron colliders ' large remote control create commission write software remote ( well expect <unknown> operate manually ? ) initially colliders deactivate program receive multiple request form ` ` activate / deactivate i - th collider '' program handle request order receive program print process result format describe request ` ` + i '' ( activate i - th collider ) program print exactly one follow responses : request ` ` - i '' ( deactivate i - th collider ) receive one follow responses program : n't need print quote output responses request first line contain two space - separated integers n m ( 1 ≤ n m ≤ 105 ) — number colliders number request correspondingly next m line contain number request one per line form either ` ` + i '' ( without quote ) — activate i - th collider ` ` - i '' ( without quote ) — deactivate i - th collider ( 1 ≤ i ≤ n ) print m line — result execute request give format request process order give input n't forget responses request print without quote note sample colliders n't turn second ninth request ninth request could also receive response ` ` conflict 3 '',['math'],1600.0
167/C,"country live wizards love play number blackboard two number write — a b. order number important let 's consider a ≤ b sake <unknown> players cast one two spell turn : a > b similar move possible least one number equal zero a player ca n't make a move take a remainder modulo zero consider <unknown> <unknown> far bore subtract a zero player make a move lose perform well magic <unknown> need learn quickly determine player win wizards play optimally : one move first one move second first line contain a single integer t — number input data set ( 1 ≤ t ≤ 104 ) next t line contain two integers a b ( 0 ≤ a b ≤ 1018 ) number separate a space please use % lld specificator read write 64 - bit integers с++ prefer use cin cout stream % i64d specificator t input set print ` ` first '' ( without quote ) player move first win print ` ` second '' ( without quote ) player move second win print answer different data set different line order give input first sample first player go ( <unknown> ) , a single move second player ( 1,10 ) take 10 modulo 1 win second sample first player two move ( 1,10 ) ( <unknown> ) move second player win third sample first player move fourth sample first player win one move take 30 modulo 10",['math'],2300.0
167/E,"country live wizards like make weird bet two wizards draw acyclic direct graph n vertices m edge ( graph 's vertices number 1 n ) a source a vertex incoming edge a sink vertex outgo edge note a vertex could sink source simultaneously wizards ' graph number sink source wizards number source order increase number vertices 1 k. sink number 1 k similar way make a bet , real wizards cast a spell select a set k paths source sink a way two paths intersect vertices case sink exactly one path go exactly one source let 's suppose i - th sink a path go ai 's source let 's call pair ( i j ) inversion i < j ai > aj number inversions among possible pair ( i j ) ( 1 ≤ i < j ≤ k ) even first wizard win ( second one give one magic coin ) otherwise second wizard win ( get one magic coin first one ) wizards capture <unknown> excitement keep choose new paths long eventually choose every possible set paths exactly two set non - intersecting <unknown> consider different edge lie path one set n't lie path another set check note ask count total winnings first player possible set paths modulo a prime number p. first line contain three space - separated integers n m p ( 1 ≤ n ≤ <unknown> 0 ≤ m ≤ 105 2 ≤ p ≤ 109 + 7 ) guarantee p prime number next m line contain edge graph line contain a pair space - separated integers ai bi — edge vertex ai vertex bi guarantee graph acyclic graph contain number source sink please note graph multiple edge print answer problem — total winnings first player modulo a prime number p. please note winnings may negative modulo residue must non - negative ( see sample ) first sample exactly one set paths — number inversions 0 even number therefore first wizard get 1 coin second sample exactly one set paths — exactly one inversion therefore first wizard get -1 coin   third sample two set paths count opposite sign fourth sample set paths fifth sample three source — vertices number ( 2 3 5 ) three sink — vertices number ( 1 2 4 ) a single set paths 2 inversions , number even",['math'],2900.0
135/B,little petya much like rectangles especially square recently receive 8 point plane a gift mother point pairwise distinct petya decide split two set contain 4 point point first set lay vertexes square point second set lay vertexes a rectangle point initial 8 belong exactly one set acceptable a rectangle second set also a square several partition petya satisfy help find partition note rectangle square partition non - zero areas side figure parallel coordinate ax though might case give 8 pair integers a pair per line — coordinate point petya absolute value coordinate exceed 104 . guarantee two point coincide print first output line ` ` yes '' ( without quote ) desire partition exist second line output 4 space - separated number — point index input lie vertexes square point number start 1 . number print order third line print index point lie vertexes a rectangle similar format print number pairwise distinct require partition exist first line contain word ` ` '' ( without quote ) output need pay attention third example : figure necessarily parallel coordinate ax,['math'],1600.0
174/A,a group n <unknown> programmers celebrate <unknown> floyd 's birthday <unknown> get <unknown> task pour ber - cola everybody pour amount ber - cola everybody really important word drink 's volume n mug must polycarpus already begin process partially empty ber - cola bottle first mug a1 milliliters drink second one a2 milliliters bottle b milliliters leave polycarpus plan pour mug main equation fulfil write a program would determine volume drink polycarpus need add mug ensure follow two condition fulfil simultaneously : first line contain a pair integers n b ( 2 ≤ n ≤ 100 1 ≤ b ≤ 100 ) n total number friends group b current volume drink bottle second line contain a sequence integers a1 a2 ... ( 0 ≤ ai ≤ 100 ) ai current volume drink i - th mug print a single number ` ` -1 '' ( without quote ) solution otherwise print n float number c1 c2 ... cn ci volume drink add i - th mug print number less 6 digits decimal point print ci a single line polycarpus prove a solution exist unique russian <unknown> instal <unknown> test computer make sure solution use point separate integer part a real number decimal a comma,['math'],1100.0
183/A,sensation sensation two - dimensional kingdom ! police catch a highly dangerous outlaw member notorious ` ` <unknown> '' gang law department state outlaw drive gang 's headquarter car crash ice cream stall stall car headquarter occupy exactly one point two - dimensional kingdom outlaw 's car equip a gps transmitter transmitter show car make exactly n movements way headquarter stall a movement move car point ( x y ) one four point : point ( x - 1 y ) mark letter ` ` l '' point ( x + 1 y ) — ` ` r '' point ( x y - 1 ) — ` ` d '' point ( x y + 1 ) — ` ` u '' gps transmitter <unknown> n't preserve exact sequence car 's movements instead keep record car 's possible movements record a string one type : ` ` ul '' ` ` ur '' ` ` dl '' ` ` dr '' ` ` uldr '' string mean car make a single movement correspond one character string example string ` ` ul '' mean car move either ` ` u '' ` ` l '' ' ve receive journal outlaw 's possible movements headquarter stall journal record give a chronological order give ice - cream stall locate point ( 0 0 ) task print number different point contain gang headquarter ( number different possible locations car 's origin ) first line contain a single integer n ( 1 ≤ n ≤ 2·105 ) — number car 's movements headquarter stall follow n line describe car 's possible movements guarantee possible movement one follow string : ` ` ul '' ` ` ur '' ` ` dl '' ` ` dr '' ` ` uldr '' movements give chronological order please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier print a single integer — number different possible locations gang 's headquarter figure show nine possible position gang headquarter first sample : example follow movements get car point ( 1 0 ) point ( 0 0 ) :,['math'],1700.0
185/A,dwarf plant a interest plant a triangle direct ` ` upwards '' plant amuse feature one year a triangle plant direct ` ` upwards '' divide four triangle plant : three point ` ` upwards '' one point ` ` downwards '' another year triangle plant divide four triangle plant : three direct direction parent plant one direct opposite direction year process repeat figure illustrate process help dwarf find many triangle plant point ` ` upwards '' n years first line contain a single integer n ( 0 ≤ n ≤ 1018 ) — number full years plant grow please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print a single integer — remainder divide number plant point ` ` upwards '' n years 1000000007 ( 109 + 7 ) first test sample correspond second triangle figure statement second test sample correspond third one,['math'],1300.0
185/B,well know whole universe traditionally use three - dimensional cartesian system coordinate system point correspond three real coordinate ( x y z ) coordinate system distance center universe point calculate follow formula : mushroom scientists work great mushroom king think universe n't exactly right distance center universe a point equal <unknown> test metric mushroom scientists usual scientists offer a task : find x y z ( 0 ≤ x y z ; x + y + z ≤ s ) distance center universe point ( x y z ) maximum possible metric mushroom scientists mushroom scientists n't good maths commission task note problem consider 00 = 1 . first line contain a single integer s ( 1 ≤ s ≤ 103 ) — maximum sum coordinate seek point second line contain three space - separated integers a b c ( 0 ≤ a b c ≤ 103 ) — number describe metric mushroom scientists print three real number — coordinate point reach maximum value <unknown> mushroom scientists multiple answer print meet limitations a natural logarithm distance center universe give point metric mushroom scientists n't differ natural logarithm maximum distance 10 - 6 . think <unknown> ( 0 ) = - ∞,['math'],1800.0
185/D,"great mushroom king descend dwarves everyone manage see choose ones could see king know lcm ( k2l + 1 k2l + 1 + 1 ... <unknown> + 1 ) dwarves see great mushroom king number k l r choose great mushroom king complicate manner <unknown> common dwarves dwarven historians decide document visit great mushroom king visit dwarven historians know three integers ki li ri choose great mushroom king visit also know a prime number pi help count remainder divide number dwarves see king number pi visit first line contain single integer t ( 1 ≤ t ≤ 105 ) — number king 's visit follow t input line contain four space - separated integers ki li ri pi ( 1 ≤ ki ≤ 106 ; 0 ≤ li ≤ ri ≤ 1018 ; 2 ≤ pi ≤ 109 ) — number choose great mushroom king prime module correspondingly guarantee visit number pi prime please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier visit print answer a single line — remainder divide number dwarves see king time number pi print answer visit order visit describe input consider lcm ( a1 a2 ... ) represent least common multiple number a1 a2 ... , consider x0 = 1 x",['math'],2600.0
154/D,"king flatland organize a knight ' tournament ! winner get half kingdom favor princess legendary beauty wisdom final test <unknown> ' <unknown> strength a fence tournament tournament hold follow rule : participants fight one one winner ( rather <unknown> ) transfer next round battle participants stand specify point ox axis integer coordinate make move turn first participant move first naturally a move first participant transfer point x integer point interval [ x + a ; x + b ] second participant transfer a move integer point interval [ x - b ; x - a ] , options players ' move symmetric ( note number a b require positive a ≤ 0 ≤ b stay one place a correct move ) time participants locate arbitrarily relative , allow ` ` jump '' enemy direction a participant win use move transfer point opponent course princess already choose a <unknown> want make sweetheart win tournament already reach tournament finals face last battle princess ask tournament manager arrange tournament <unknown> a way sweetheart win tournament consider players play optimally however initial location participants already announce pull string determine participant first one second know participant secure victory ? alas princess learn military affairs ... therefore ask determine battle end consider opponents play optimally also first player win task determine win move first line contain four space - separated integers — x1 x2 a b ( x1 ≠ x2 a ≤ b - 109 ≤ x1 x2 a b ≤ 109 ) — coordinate point first second participant start number determine players ' move correspondingly first line print outcome battle ` ` first '' ( without quote ) players play optimally first player win print ` ` second '' ( without quote ) second player win print ` ` draw '' ( without quote ) nobody able secure victory first player win print next line single integer x — coordinate point first player transfer win indicate move valid , meet follow condition : x1 + a ≤ x ≤ x1 + b. several win move print first participant ca n't secure victory print anything first sample first player win one move second sample first participant must go point 1 second participant immediately go win third sample change position n't profitable either participant nobody win",['math'],2400.0
490/C,polycarpus participate a competition hack a new secure messenger 's almost carefully study interaction protocol polycarpus come conclusion secret key obtain properly cut public key application two part public key a long integer may consist even a million digits ! polycarpus need find a way cut public key two nonempty part first ( leave ) part divisible a a separate number second ( right ) part divisible b a separate number part positive integers lead zero polycarpus know value a b. help polycarpus find suitable method cut public key first line input contain public key messenger — integer without lead zero length range 1 106 digits second line contain a pair space - separated positive integers a b ( 1 ≤ a b ≤ 108 ) first line print ` ` yes '' ( without quote ) method satisfy condition exist case next print two line — leave right part cut two part concatenate must exactly identical public key leave part must divisible a right part must divisible b. two part must positive integers lead zero several answer print answer print a single line ` ` '' ( without quote ),['math'],1700.0
180/B,vasya study divisibility rule school : vasya get interest fact divisibility rule resemble fact check a number 's divisibility 2 4 5 8 10 enough check fulfil condition one several last digits vasya call rule 2 - type rule check divisibility mean find a sum digits check whether sum divisible give number vasya call rule 3 - type rule ( work number 3 9 ) need find difference sum digits odd even position check whether difference divisible give divisor rule call 11 - type rule ( work number 11 ) case divide divisor several factor check whether rule different type ( 2 - type 3 - type 11 - type ) work example number 6 check 2 - type 3 - type rule number 66 check three type mix divisibility rule call 6 - type rule finally number rule work : neither 2 - type 3 - type 11 - type 6 - type least number number 7 'll say case mysterious 7 - type rule work one vasya n't discover yet vasya 's dream find divisibility rule possible number n't go stop decimal number quite many number <unknown> ca n't vasya ask write a program determine divisibility rule type b - based notation give divisor d. first input line contain two integers b d ( 2 ≤ b d ≤ 100 ) — notation system base divisor number give decimal notation first output line print type rule b - based notation system divisor d : ` ` 2 - type '' ` ` 3 - type '' ` ` 11 - type '' ` ` 6 - type '' ` ` 7 - type '' several type print one go earlier give sequence a number belong 2 - type print second line least number last b - based digits need use check divisibility divisibility rule number 3 binary notation look follow : ` ` a number divisible 3 sum digits occupy even place differ sum digits occupy odd place a number divisible 3 '' 's 11 - type rule example <unknown> = <unknown> . sum digits odd position equal 1 + 1 + 1 = 3 even position — 0 + 0 = 0 . rule work number divisible 3 . <unknown> a number fit 3 - type rule 11 - type rule case correct answer ` ` 3 - type '',['math'],2300.0
134/B,"let 's assume a pair number ( a b ) get a new pair ( a + b b ) ( a a + b ) give pair a single step let initial pair number ( 1,1 ) task find number k , least number step need transform ( 1,1 ) pair least one number equal n. input contain integer n ( 1 ≤ n ≤ 106 ) print integer k. pair ( 1,1 ) transform a pair contain 5 three move : ( 1,1 ) → ( 1,2 ) → ( <unknown> ) → ( <unknown> )",['math'],1900.0
189/B,two positive integers w h. task count number rhombi follow properties : count number rhombi let us remind a rhombus a <unknown> whose four side length first line contain two integers w h ( 1 ≤ w h ≤ 4000 ) — rectangle 's size print a single number — number seek rhombi please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first example exist one rhombus vertices locate point ( 1 0 ) ( 2 1 ) ( 1 2 ) ( 0 1 ),['math'],1300.0
193/E,"john doe a list fibonacci number modulo 1013 . list infinite start number 0 1 . number list apart first two a sum previous two modulo 1013 . john 's list make fibonacci number ' list replace number remainder divide 1013 . john get interest number f ( 0 ≤ f < 1013 ) want find first occurrence list give help john find number first <unknown> number f list otherwise state number f occur list numeration john 's list start zero , 0 - th position number 0 1 - st position number 1 2 - nd position number 1 3 - rd position number 2 4 - th position number 3 thus begin list look like : 0 1 1 2 3 5 8 13 21 ... first line contain single integer f ( 0 ≤ f < 1013 ) — number position list find please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print a single number — number first occurrence give number john 's list number n't occur john 's list print -1",['math'],2900.0
1285/A,today mezo play a game zoma a character game initially position $$$ x = 0 $$$ mezo start send $$$ n $$$ command zoma two possible command : unfortunately mezo 's controller malfunction sometimes command send successfully ignore command ignore position $$$ x $$$ n't change mezo simply proceed next command example mezo send command ` ` <unknown> '' possible outcomes ( underline command send successfully ) : mezo n't know command send successfully beforehand thus want know many different position may zoma end first line contain $$$ n $$$ $$$ ( 1 \le n \le 100000 ) $$$ — number command mezo send second line contain a string $$$ s $$$ $$$ n $$$ command either ' l ' ( leave ) ' r ' ( right ) print one integer — number different position zoma may end example zoma may end anywhere $$$ -2 $$$ $$$ 2 $$$,['math'],800.0
1249/A,a coach a group consist $$$ n $$$ students $$$ i $$$ -th student program skill $$$ a_i $$$ students distinct program skills want divide team a way : answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100 $$$ ) — number query $$$ q $$$ query follow first line query contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number students query second line query contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100 $$$ $$$ a_i $$$ distinct ) $$$ a_i $$$ program skill $$$ i $$$ -th student query print answer — minimum number team form two students $$$ i $$$ $$$ j $$$ $$$ <unknown> - <unknown> = 1 $$$ may belong team ( i.e skills pair students team difference strictly greater $$$ 1 $$$ ) first query example $$$ n=4 $$$ students skills $$$ a= [ 2 10 1 20 ] $$$ one restriction : $$$ 1 $$$ -st $$$ 3 $$$ -th students ca n't team ( $$$ <unknown> - <unknown> - <unknown> $$$ ) possible divide $$$ 2 $$$ team : example students $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$ first team student $$$ 3 $$$ second team second query example $$$ <unknown> $$$ students skills $$$ a= [ 3 6 ] $$$ possible compose a single team contain students,['math'],800.0
1359/E,define $$$ x \bmod y $$$ remainder division $$$ x $$$ $$$ y $$$ ( $$$ \ % $$$ operator c++ java mod operator pascal ) let 's call array positive integers $$$ [ a_1 a_2 \dots a_k ] $$$ stable every permutation $$$ p $$$ integers $$$ 1 $$$ $$$ k $$$ every non - negative integer $$$ x $$$ follow condition meet : non - negative integer $$$ x $$$ value $$$ ( ( ( x \bmod a_1 ) \bmod a_2 ) \dots \bmod a _ { k - 1 } ) \bmod a_k $$$ change reorder elements array $$$ a $$$ two give integers $$$ n $$$ $$$ k $$$ calculate number stable array $$$ [ a_1 a_2 \dots a_k ] $$$ $$$ 1 \le a_1 < a_2 < \dots < a_k \le n $$$ line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 500000 $$$ ) print one integer — number stable array $$$ [ a_1 a_2 \dots a_k ] $$$ $$$ 1 \le a_1 < a_2 < \dots < a_k \le n $$$ since answer may large print modulo $$$ 998244353 $$$,['math'],2000.0
492/E,vanya decide walk field size n × n cells field contain m apple tree i - th apple tree cell coordinate ( xi yi ) vanya move towards vector ( dx dy ) mean vanya cell ( x y ) a second cell follow condition satisfy vector : largest integer divide a b. vanya end path reach square already visit vanya wonder square field start path see many apple tree possible first line contain integers n m dx dy ( 1 ≤ n ≤ 106 1 ≤ m ≤ 105 1 ≤ dx dy ≤ n ) — size field number apple tree vector vanya 's movement next m line contain integers xi yi ( 0 ≤ xi yi ≤ n - 1 ) — coordinate apples one cell may contain multiple apple tree print two space - separated number — coordinate cell start path several answer allow print first sample vanya 's path look like : ( 1 3 ) - ( 3 1 ) - ( 0 4 ) - ( 2 2 ) - ( 4 0 ) - ( 1 3 ) second sample : ( 0 0 ) - ( 1 1 ) - ( 0 0 ),['math'],2000.0
493/E,"vasya study last class school soon take exams decide study polynomials polynomial a function p ( x ) = a0 + <unknown> + ... + <unknown> number ai call coefficients a polynomial non - negative integer n call a degree a polynomial vasya make a bet friends solve problem polynomials suggest problem : ` ` determine many polynomials p ( x ) exist integer non - negative coefficients , b give positive integers '' ? vasya like lose bet idea solve task please help solve problem input contain three integer positive number greater 1018 . infinite number polynomials print ` ` inf '' without quote otherwise print reminder answer modulo 109 + 7",['math'],2800.0
1354/C2,statement problem statement problem c1 difference problem c1 $$$ n $$$ always even c2 $$$ n $$$ always odd give a regular polygon $$$ 2 \cdot n $$$ vertices ( 's convex equal side equal angle ) side length $$$ 1 $$$ let 's name $$$ 2n $$$ -gon task find square minimum size embed $$$ 2n $$$ -gon square embed $$$ 2n $$$ -gon square mean need place $$$ 2n $$$ -gon square way point lie inside a border $$$ 2n $$$ -gon also lie inside a border square rotate $$$ 2n $$$ -gon and/or square first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200 $$$ ) — number test case next $$$ t $$$ line contain descriptions test case — one per line line contain single odd integer $$$ n $$$ ( $$$ 3 \le n \le <unknown> $$$ ) n't forget need embed $$$ 2n $$$ -gon $$$ n $$$ -gon print $$$ t $$$ real number — one per test case test case print minimum length a side square $$$ 2n $$$ -gon embed answer consider correct absolute relative error n't exceed $$$ 10^ { -6 } $$$,['math'],2000.0
1355/D,petya vasya compete a new interest game always begin game petya come array $$$ n $$$ positive integers sum elements array equal $$$ s $$$ petya select integer $$$ k $$$ $$$ 0 \leq k \leq s $$$ order win vasya find a non - empty subarray petya 's array sum select elements equal either $$$ k $$$ $$$ s - k $$$ otherwise vasya lose give integers $$$ n $$$ $$$ s $$$ determine petya win consider vasya play optimally petya win help first line contain two integers $$$ n $$$ $$$ s $$$ ( $$$ 1 \leq n \leq s \leq 10^ { 6 } $$$ ) — require length array require sum elements petya win print ` ` yes '' ( without quote ) first line print petya 's array second line array contain $$$ n $$$ positive integers sum equal $$$ s $$$ third line print $$$ k $$$ many correct answer print petya ca n't win print ` ` '' ( without quote ) print letter register ( lowercase uppercase ),['math'],1400.0
1358/C,<unknown> <unknown> free time create new function ` ` celex-2021 '' developers make a new function gaz - giz infinitely fill infinite table right upper leave corner follow : developers sum function n't sleep either <unknown> team developers <unknown> function add ability calculate sum arbitrary path one cell another move right formally cell $$$ ( x y ) $$$ one step move cell $$$ ( x+1 y ) $$$ $$$ ( x <unknown> ) $$$ another <unknown> update <unknown> start study ` ` celex-2021 '' ( want <unknown> ! ) fill table gaz - giz function ask calculate quantity possible different amount path a give cell $$$ ( x_1 y_1 ) $$$ another give cell $$$ ( x_2 y_2 $$$ ) move one cell right formally consider paths cell $$$ ( x_1 y_1 ) $$$ cell $$$ ( x_2 y_2 ) $$$ next cell path locate either right previous one calculate number different sum elements paths first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le <unknown> $$$ ) — number test case follow $$$ t $$$ line contain four natural number $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \le x_1 \le x_2 \le 1000000000 $$$ $$$ 1 \le y_1 \le y_2 \le 1000000000 $$$ ) — coordinate start end cells test case a separate line print number possible different sum way start cell end cell first test case two possible sum : $$$ 1 + 2 + <unknown> $$$ $$$ 1 + 3 + <unknown> $$$,['math'],1600.0
1359/C,two infinite source water : perform follow procedure alternate move : note always start cup hot water barrel initially empty pour least one cup barrel water temperature barrel average temperatures pour cup want achieve a temperature close possible $$$ t $$$ temperature barrel $$$ t_b $$$ absolute difference $$$ t_b $$$ $$$ t $$$ ( $$$ <unknown> - <unknown> $$$ ) small possible many cup pour barrel temperature close possible $$$ t $$$ ? multiple answer minimum absolute difference print smallest first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 30000 $$$ ) — number testcases next $$$ t $$$ line contain three integers $$$ h $$$ $$$ c $$$ $$$ t $$$ ( $$$ 1 \le c < h \le 1000000 $$$ ; $$$ c \le t \le h $$$ ) — temperature hot water temperature cold water desire temperature barrel testcase print a single positive integer — minimum number cup require pour barrel achieve closest temperature $$$ t $$$ first testcase temperature $$$ 2 $$$ pour cup : $$$ 1 $$$ hot $$$ 1 $$$ cold exactly $$$ 20 $$$ closest achieve second testcase temperature $$$ 7 $$$ pour cup : $$$ 4 $$$ hot $$$ 3 $$$ cold $$$ <unknown> $$$ pour water wo n't get us closer $$$ t $$$ third testcase temperature $$$ 1 $$$ pour cup : $$$ 1 $$$ hot $$$ 18 $$$ 's exactly equal $$$ t $$$,['math'],1700.0
1444/A,oleg 's favorite subject history math favorite branch mathematics division improve division skills oleg come $$$ t $$$ pair integers $$$ p_i $$$ $$$ q_i $$$ pair decide find greatest integer $$$ x_i $$$ : first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 50 $$$ ) — number pair follow $$$ t $$$ line contain two integers $$$ p_i $$$ $$$ q_i $$$ ( $$$ 1 \le p_i \le 10^ { 18 } $$$ ; $$$ 2 \le q_i \le 10^ { 9 } $$$ ) — $$$ i $$$ -th pair integers print $$$ t $$$ integers : $$$ i $$$ -th integer largest $$$ x_i $$$ $$$ p_i $$$ divisible $$$ x_i $$$ $$$ x_i $$$ divisible $$$ q_i $$$ one show always least one value $$$ x_i $$$ satisfy divisibility condition give constraints first pair $$$ p_1 = 10 $$$ $$$ q_1 = 4 $$$ answer $$$ x_1 = 10 $$$ since greatest divisor $$$ 10 $$$ $$$ 10 $$$ divisible $$$ 4 $$$ second pair $$$ p_2 = 12 $$$ $$$ q_2 = 6 $$$ note,['math'],1500.0
1360/D,"polycarp want buy exactly $$$ n $$$ shovel shop sell package shovel store $$$ k $$$ type package : package $$$ i $$$ -th type consist exactly $$$ i $$$ shovel ( $$$ 1 \le i \le k $$$ ) store infinite number package type polycarp want choose one type package buy several ( one ) package type smallest number package polycarp buy get exactly $$$ n $$$ shovel ? example $$$ n=8 $$$ $$$ <unknown> $$$ polycarp buy $$$ 2 $$$ package $$$ 4 $$$ shovel help polycarp find minimum number package need buy give : first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case input , $$$ t $$$ test case follow one per line test case consist two positive integers $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) $$$ k $$$ ( $$$ 1 \le k \le 1000000000 $$$ ) — number shovel number type package print $$$ t $$$ answer test case answer a positive integer — minimum number package answer first test case explain statement second test case one way buy $$$ 8 $$$ shovel — $$$ 8 $$$ package one shovel third test case need buy a $$$ 1 $$$ package $$$ 6 $$$ shovel",['math'],1300.0
1350/A,"orac study number theory interest properties divisors two positive integers $$$ a $$$ $$$ b $$$ $$$ a $$$ a divisor $$$ b $$$ exist integer $$$ c $$$ $$$ <unknown> c = b $$$ $$$ n \ge 2 $$$ denote $$$ f ( n ) $$$ smallest positive divisor $$$ n $$$ except $$$ 1 $$$ example $$$ f ( 7 ) = 7 f ( 10 ) = 2 f ( 35 ) = 5 $$$ fix integer $$$ n $$$ orac decide add $$$ f ( n ) $$$ $$$ n $$$ example integer $$$ n=5 $$$ new value $$$ n $$$ equal $$$ 10 $$$ integer $$$ n=6 $$$ $$$ n $$$ change $$$ 8 $$$ orac love much decide repeat operation several time , two positive integers $$$ n $$$ $$$ k $$$ orac ask add $$$ f ( n ) $$$ $$$ n $$$ exactly $$$ k $$$ time ( note $$$ n $$$ change operation $$$ f ( n ) $$$ may change ) tell final value $$$ n $$$ example orac give $$$ n=5 $$$ $$$ k=2 $$$ first add $$$ f ( 5 ) = 5 $$$ $$$ n=5 $$$ new value $$$ n $$$ equal $$$ <unknown> $$$ , add $$$ f ( 10 ) = 2 $$$ $$$ 10 $$$ new ( final ! ) value $$$ n $$$ equal $$$ 12 $$$ orac may ask query many time first line input a single integer $$$ <unknown> ( 1\le t\le 100 ) $$$ : number time orac ask next $$$ t $$$ line contain two positive integers $$$ n <unknown> ( 2\le n\le 1000000 1\le <unknown> 1000000000 ) $$$ correspond a query orac guarantee total sum $$$ n $$$ $$$ 1000000 $$$ print $$$ t $$$ line $$$ i $$$ -th contain final value $$$ n $$$ $$$ i $$$ -th query orac first query $$$ n=5 $$$ $$$ <unknown> $$$ divisors $$$ 5 $$$ $$$ 1 $$$ $$$ 5 $$$ smallest one except $$$ 1 $$$ $$$ 5 $$$ therefore operation add $$$ f ( 5 ) = 5 $$$ $$$ 5 $$$ result $$$ 10 $$$ second query $$$ n=8 $$$ $$$ k=2 $$$ divisors $$$ 8 $$$ $$$ <unknown> $$$ smallest one except $$$ 1 $$$ $$$ 2 $$$ one operation $$$ 8 $$$ turn $$$ 8 + ( f ( 8 ) = 2 ) = 10 $$$ divisors $$$ 10 $$$ $$$ <unknown> $$$ smallest one except $$$ 1 $$$ $$$ 2 $$$ therefore answer $$$ 10 + ( f ( 10 ) = 2 ) = 12 $$$ third query $$$ n $$$ change follow : $$$ 3 \to 6 \to 8 \to 10 \to 12 $$$",['math'],900.0
1371/A,"a <unknown> <unknown> $$$ n $$$ stick exactly one stick length $$$ i $$$ $$$ 1 \le i \le n $$$ connect stick connect two stick lengths $$$ a $$$ $$$ b $$$ get one stick length $$$ a + b $$$ two stick use operation disappear set new connect stick appear set use next connections want create maximum number stick length necessary make stick length stick length many stick equal length create ? input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next $$$ t $$$ line contain descriptions test case test case line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 10^ { 9 } $$$ ) test case print a single integer — answer problem third case connect two stick lengths $$$ 1 $$$ $$$ 2 $$$ get one stick length $$$ 3 $$$ , two stick lengths $$$ 3 $$$ fourth case connect two stick lengths $$$ 1 $$$ $$$ 3 $$$ get one stick length $$$ 4 $$$ , three stick lengths $$$ \ { 2 4 4\ } $$$ two stick length one stick length",['math'],800.0
1371/B,"a competitive <unknown> alice schedule practice eat contest a magical calendar calendar unusual a week contain necessarily $$$ 7 $$$ days ! detail choose integer $$$ k $$$ satisfy $$$ 1 \leq k \leq r $$$ set $$$ k $$$ days number days a week alice go paint $$$ n $$$ consecutive days calendar calendar date write leave cell right cell a week a date reach last day a week next day 's cell leftmost cell next ( ) row want make paint cells connect side mean two paint cells exist least one sequence paint cells start one cells end another two consecutive cells sequence connect side alice consider shape paint cells two shape exist a way make exactly overlap use parallel move parallel calendar 's side example picture a week $$$ 4 $$$ days alice paint $$$ 5 $$$ consecutive days [ 1 ] [ 2 ] different shape [ 1 ] [ 3 ] equal shape alice want know many possible shape exist set many days a week choose consecutive $$$ n $$$ days paint calendar start one days week say consider shape cells connect side input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next $$$ t $$$ line contain descriptions test case test case line contain two integers $$$ n $$$ $$$ r $$$ ( $$$ 1 \le n \le 1000000000 1 \le r \le 1000000000 $$$ ) test case print a single integer — answer problem please note answer test case wo n't fit $$$ 32 $$$ -bit integer type use least $$$ 64 $$$ -bit integer type program language first test case alice set $$$ 1,2,3 $$$ $$$ 4 $$$ days number days a week $$$ 6 $$$ possible paint show picture $$$ 4 $$$ different shape , answer $$$ 4 $$$ notice last example picture invalid paint cells connect side last test case careful <unknown> issue describe output format",['math'],1200.0
1371/E1,"easy version problem difference versions constraints $$$ n $$$ $$$ a_i $$$ make hack versions problem solve first aoi come follow idea competitive program problem : yuzu a girl collect candy originally $$$ x $$$ candy also $$$ n $$$ enemies number integers $$$ 1 $$$ $$$ n $$$ enemy $$$ i $$$ $$$ a_i $$$ candy yuzu go determine a permutation $$$ p $$$ a permutation array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ \ { <unknown> } $$$ a permutation $$$ \ { <unknown> } $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ \ { <unknown> } $$$ also a permutation ( $$$ n=3 $$$ number $$$ 4 $$$ array ) , $$$ n $$$ duel enemies follow rule : yuzu want win duel many valid permutations $$$ p $$$ exist ? problem easy n't interest akari a friend aoi akari make follow problem idea : let 's define $$$ f ( x ) $$$ number valid permutations integer $$$ x $$$ give $$$ n $$$ $$$ a $$$ a prime number $$$ p \le n $$$ let 's call a positive integer $$$ x $$$ good value $$$ f ( x ) $$$ divisible $$$ p $$$ find good integers $$$ x $$$ task solve problem make akari first line contain two integers $$$ n $$$ $$$ p $$$ $$$ ( 2 \le p \le n \le 2000 ) $$$ guarantee number $$$ p $$$ prime ( exactly two divisors $$$ 1 $$$ $$$ p $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 1 \le a_i \le 2000 ) $$$ first line print number good integers $$$ x $$$ second line output good integers $$$ x $$$ ascend order guarantee number good integers $$$ x $$$ exceed $$$ 100000 $$$ first test $$$ <unknown> $$$ , good number $$$ 3 $$$ third test positive integers $$$ x $$$ value $$$ f ( x ) $$$ divisible $$$ p = 3 $$$",['math'],1900.0
1372/C,"patrick like play <unknown> sometimes spend many hours hit home run mind start get <unknown> ! patrick sure score across $$$ n $$$ sessions follow identity permutation ( ie first game score $$$ 1 $$$ point second game score $$$ 2 $$$ point ) however check back record see number mix ! define a special exchange follow : choose subarray score permute elements element subarray get position exchange example perform a special exchange $$$ [ 1,2,3 ] $$$ yield $$$ [ <unknown> ] $$$ yield $$$ [ <unknown> ] $$$ since $$$ 2 $$$ position give a permutation $$$ n $$$ integers please help patrick find minimum number special exchange need make permutation sort ! prove give constraints number n't exceed $$$ 10^ { 18 } $$$ array $$$ a $$$ a subarray array $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) elements begin several ( possibly zero ) elements end test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — length give permutation second line test case contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } ... a _ { n } $$$ ( $$$ 1 \leq a _ { i } \leq n $$$ ) — initial permutation guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case output one integer : minimum number special exchange need sort permutation first permutation already sort exchange need show need least $$$ 2 $$$ exchange sort second permutation $$$ [ 3 2 4 5 1 6 7 ] $$$ perform special exchange range ( $$$ 1 5 $$$ ) $$$ [ 4 1 2 3 5 6 7 ] $$$ perform special exchange range ( $$$ 1 4 $$$ ) $$$ [ 1 2 3 4 5 6 7 ] $$$",['math'],1500.0
1373/C,give a string $$$ s $$$ consist character + - perform process string process describe follow pseudocode : note $$$ inf $$$ denote infinity character string number $$$ 1 $$$ $$$ |s| $$$ calculate value $$$ res $$$ process end first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case line test case contain string $$$ s $$$ ( $$$ 1 \le |s| \le 1000000 $$$ ) consist character + - 's guarantee sum $$$ |s| $$$ test case n't exceed $$$ 1000000 $$$ test case print one integer — value $$$ res $$$ process end,['math'],1300.0
1374/A,give three integers $$$ x y $$$ $$$ n $$$ task find maximum integer $$$ k $$$ $$$ 0 \le k \le n $$$ $$$ k \bmod x = y $$$ $$$ \bmod $$$ modulo operation many program languages use percent operator % implement word give $$$ x y $$$ $$$ n $$$ need find maximum possible integer $$$ 0 $$$ $$$ n $$$ remainder $$$ y $$$ modulo $$$ x $$$ answer $$$ t $$$ independent test case guarantee $$$ k $$$ exist test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 50000 $$$ ) — number test case next $$$ t $$$ line contain test case line test case contain three integers $$$ x y $$$ $$$ n $$$ ( $$$ 2 \le x \le 1000000000 ; ~ 0 \le y < x ; ~ y \le n \le 1000000000 $$$ ) show $$$ k $$$ always exist give constraints test case print answer — maximum non - negative integer $$$ k $$$ $$$ 0 \le k \le n $$$ $$$ k \bmod x = y $$$ guarantee answer always exist first test case example answer $$$ 12339 = <unknown> + 5 $$$ ( thus $$$ 12339 \bmod 7 = 5 $$$ ) obvious greater integer exceed $$$ 12345 $$$ remainder $$$ 5 $$$ modulo $$$ 7 $$$,['math'],800.0
1374/B,give integer $$$ n $$$ one move either multiply $$$ n $$$ two divide $$$ n $$$ $$$ 6 $$$ ( divisible $$$ 6 $$$ without remainder ) task find minimum number move need obtain $$$ 1 $$$ $$$ n $$$ determine 's impossible answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) test case print answer — minimum number move need obtain $$$ 1 $$$ $$$ n $$$ 's possible -1 's impossible obtain $$$ 1 $$$ $$$ n $$$ consider sixth test case example answer obtain follow sequence move give integer $$$ <unknown> $$$ :,['math'],900.0
1354/C1,statement problem statement problem c2 difference problem c1 $$$ n $$$ always even c2 $$$ n $$$ always odd give a regular polygon $$$ 2 \cdot n $$$ vertices ( 's convex equal side equal angle ) side length $$$ 1 $$$ let 's name $$$ 2n $$$ -gon task find square minimum size embed $$$ 2n $$$ -gon square embed $$$ 2n $$$ -gon square mean need place $$$ 2n $$$ -gon square way point lie inside a border $$$ 2n $$$ -gon also lie inside a border square rotate $$$ 2n $$$ -gon and/or square first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200 $$$ ) — number test case next $$$ t $$$ line contain descriptions test case — one per line line contain single even integer $$$ n $$$ ( $$$ 2 \le n \le 200 $$$ ) n't forget need embed $$$ 2n $$$ -gon $$$ n $$$ -gon print $$$ t $$$ real number — one per test case test case print minimum length a side square $$$ 2n $$$ -gon embed answer consider correct absolute relative error n't exceed $$$ 10^ { -6 } $$$,['math'],1400.0
1374/D,give array $$$ a $$$ consist $$$ n $$$ positive integers initially integer $$$ x = 0 $$$ one move one follow two operations : first operation apply $$$ i $$$ $$$ 1 $$$ $$$ n $$$ task find minimum number move require obtain array element divisible $$$ k $$$ ( value $$$ k $$$ give ) answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 2 \cdot 100000 ; 1 \le k \le 1000000000 $$$ ) — length $$$ a $$$ require <unknown> second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print answer — minimum number move require obtain array element divisible $$$ k $$$ consider first test case example : note ca n't add $$$ x $$$ element,['math'],1400.0
1354/A,polycarp spend entire day prepare problems sleep least $$$ a $$$ minutes feel refresh polycarp wake hear sound alarm fall asleep first alarm go $$$ b $$$ minutes every time polycarp wake decide want sleep time 's sleep less $$$ a $$$ minutes total set alarm go $$$ c $$$ minutes reset spend $$$ d $$$ minutes fall asleep otherwise get bed proceed day alarm go polycarp fall asleep reset alarm go another $$$ c $$$ minutes try fall asleep $$$ d $$$ minutes want find polycarp get bed report never happen please check note <unknown> example first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases line testcase contain four integers $$$ a b c d $$$ ( $$$ 1 \le a b c d \le 1000000000 $$$ ) — time polycarp sleep feel refresh time first alarm go time every succeed alarm go time polycarp spend fall asleep test case print one integer polycarp never get bed print -1 . otherwise print time take polycarp get bed first testcase polycarp wake $$$ 3 $$$ minutes rest $$$ 3 $$$ minutes $$$ 10 $$$ minutes need set alarm go $$$ 6 $$$ minutes spend $$$ 4 $$$ minutes fall asleep thus rest $$$ 2 $$$ minutes total $$$ 3 + 2=5 $$$ minutes sleep repeat procedure three time end $$$ 11 $$$ minutes sleep finally get bed spend $$$ 3 $$$ minutes first alarm reset alarm four time answer $$$ 3 + 4 \cdot 6 = 27 $$$ second example almost like first one polycarp need $$$ 11 $$$ minutes sleep instead $$$ 10 $$$ however change nothing get $$$ 11 $$$ minutes alarm parameters anyway third testcase polycarp wake rest enough first alarm thus answer $$$ <unknown> $$$ fourth testcase polycarp wake $$$ 5 $$$ minutes unfortunately keep reset alarm infinitely unable rest even a single minute : (,['math'],900.0
1370/B,"ashish array $$$ a $$$ consist $$$ 2n $$$ positive integers want compress $$$ a $$$ array $$$ b $$$ size $$$ n-1 $$$ , first discard exactly $$$ 2 $$$ ( two ) elements $$$ a $$$ perform follow operation elements leave $$$ a $$$ : compress array $$$ b $$$ a special property greatest common divisor ( $$$ \mathrm { gcd } $$$ ) elements greater $$$ 1 $$$ recall $$$ \mathrm { gcd } $$$ array positive integers biggest integer a divisor integers array prove always possible compress array $$$ a $$$ array $$$ b $$$ size $$$ n-1 $$$ $$$ gcd ( b_1 b_2 ... b _ { n-1 } ) > 1 $$$ help ashish find a way first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 1000 $$$ ) second line test case contain $$$ 2n $$$ integers $$$ a_1 a_2 \ldots a _ { 2n } $$$ ( $$$ 1 \leq a_i \leq 1000 $$$ ) — elements array $$$ a $$$ test case output $$$ n-1 $$$ line — operations perform compress array $$$ a $$$ array $$$ b $$$ initial discard two elements operation n't need output anything $$$ i $$$ -th line contain two integers indices ( $$$ 1 $$$ — based ) two elements array $$$ a $$$ use $$$ i $$$ -th operation $$$ <unknown> $$$ indices distinct integers $$$ 1 $$$ $$$ 2n $$$ n't need output two initially discard elements $$$ a $$$ multiple answer find first test case $$$ b = \ { 3 + 6 4 + 5\ } = \ { 9 <unknown> } $$$ $$$ \mathrm { gcd } ( 9 9 ) = 9 $$$ second test case $$$ b = \ { 9 + 10\ } = \ { <unknown> } $$$ $$$ \mathrm { gcd } ( 19 ) = 19 $$$ third test case $$$ b = \ { 1 + 2 3 + 3 4 + 5 90 + 3\ } = \ { 3 6 9 <unknown> } $$$ $$$ \mathrm { gcd } ( 3 6 9 93 ) = 3 $$$",['math'],1100.0
1352/F,binary string $$$ s $$$ ( i.e character $$$ s_i $$$ either ' 0 ' ' 1 ' ) pair consecutive ( adjacent ) character write word substrings length $$$ 2 $$$ write pair ( substring length $$$ 2 $$$ ) number ' 1 ' ( ones ) calculate give three number : example string $$$ s= $$$ ` ` <unknown> '' follow substrings would write : ` ` 11 '' ` ` 11 '' ` ` 10 '' ` ` 00 '' ` ` 01 '' ` ` 11 '' ` ` 11 '' ` ` 11 '' ` ` 10 '' thus $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ task restore suitable binary string $$$ s $$$ give value $$$ n_0 n_1 n_2 $$$ guarantee least one number $$$ n_0 n_1 n_2 $$$ greater $$$ 0 $$$ also guarantee a solution exist first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case input test case follow test case consist one line contain three integers $$$ n_0 n_1 n_2 $$$ ( $$$ 0 \le n_0 n_1 n_2 \le 100 $$$ ; $$$ n_0 + n_1 + n_2 > 0 $$$ ) guarantee answer give $$$ n_0 n_1 n_2 $$$ exist print $$$ t $$$ line line contain a binary string correspond a test case several possible solutions print,['math'],1500.0
1336/E1,"easy version problem difference easy hard versions constraint $$$ m $$$ make hack versions solve chiori love dolls go decorate bedroom ! a doll collector chiori get $$$ n $$$ dolls $$$ i $$$ -th doll a non - negative integer value $$$ a_i $$$ ( $$$ a_i < 2^m $$$ $$$ m $$$ give ) chiori want pick ( maybe zero ) dolls decoration $$$ 2^n $$$ different pick ways let $$$ x $$$ bitwise - xor - sum value dolls chiori pick ( case chiori pick dolls $$$ x = 0 $$$ ) value pick way equal number $$$ 1 $$$ -bits binary representation $$$ x $$$ formally also equal number indices $$$ 0 \leq i < m $$$ $$$ \left\lfloor \frac { x } { 2^i } \right\rfloor $$$ odd tell number pick ways value $$$ i $$$ integer $$$ i $$$ $$$ 0 $$$ $$$ m $$$ due answer huge print modulo $$$ 998\,244\,353 $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 0 \le m \le 35 $$$ ) — number dolls maximum value pick way second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i < 2^m $$$ ) — value dolls print $$$ m+1 $$$ integers $$$ p_0 p_1 \ldots p_m $$$ — $$$ p_i $$$ equal number pick ways value $$$ i $$$ modulo $$$ 998\,244\,353 $$$",['math'],2700.0
1336/E2,"hard version problem difference easy hard versions constraint $$$ m $$$ make hack versions solve chiori love dolls go decorate bedroom ! a doll collector chiori get $$$ n $$$ dolls $$$ i $$$ -th doll a non - negative integer value $$$ a_i $$$ ( $$$ a_i < 2^m $$$ $$$ m $$$ give ) chiori want pick ( maybe zero ) dolls decoration $$$ 2^n $$$ different pick ways let $$$ x $$$ bitwise - xor - sum value dolls chiori pick ( case chiori pick dolls $$$ x = 0 $$$ ) value pick way equal number $$$ 1 $$$ -bits binary representation $$$ x $$$ formally also equal number indices $$$ 0 \leq i < m $$$ $$$ \left\lfloor \frac { x } { 2^i } \right\rfloor $$$ odd tell number pick ways value $$$ i $$$ integer $$$ i $$$ $$$ 0 $$$ $$$ m $$$ due answer huge print modulo $$$ 998\,244\,353 $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 0 \le m \le 53 $$$ ) — number dolls maximum value pick way second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i < 2^m $$$ ) — value dolls print $$$ m+1 $$$ integers $$$ p_0 p_1 \ldots p_m $$$ — $$$ p_i $$$ equal number pick ways value $$$ i $$$ modulo $$$ 998\,244\,353 $$$",['math'],3500.0
1337/A,ichihime current <unknown> <unknown> <unknown> temple claim human despite cat <unknown> days temple hold a math contest usually ichihime lack interest things time prize winner favorite — cookies ichihime decide attend contest solve follow problem give four positive integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ $$$ a \leq b \leq c \leq d $$$ task find three integers $$$ x $$$ $$$ y $$$ $$$ z $$$ satisfy follow condition : ichihime desire get cookie problem seem hard help ? first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case next $$$ t $$$ line describe test case test case give four space - separated integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ ( $$$ 1 \leq a \leq b \leq c \leq d \leq 1000000000 $$$ ) test case print three integers $$$ x $$$ $$$ y $$$ $$$ z $$$ — integers find satisfy condition give statement guarantee answer always exist multiple answer print one possible solutions first test case : one possible solutions second test case :,['math'],800.0
1338/C,consider infinite sequence $$$ s $$$ positive integers create repeat follow step : integer $$$ n $$$ find $$$ n $$$ -th element $$$ s $$$ answer $$$ t $$$ independent test case a sequence $$$ a $$$ lexicographically smaller a sequence $$$ b $$$ first position $$$ a $$$ $$$ b $$$ differ sequence $$$ a $$$ a smaller element correspond element $$$ b $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case next $$$ t $$$ line contain a single integer $$$ n $$$ ( $$$ 1\le n \le 10^ { 16 } $$$ ) — position element want know $$$ t $$$ line output answer correspond test case first elements $$$ s $$$ $$$ 1 2 3 4 8 12 5 10 15 \dots $$$,['math'],2200.0
1341/A,nastya make a huge mistake drop a whole package rice floor mom come soon see nastya punish total nastya drop $$$ n $$$ grain nastya read grain weigh integer number grams $$$ a - b $$$ $$$ a + b $$$ inclusive ( number $$$ a $$$ $$$ b $$$ know ) whole package $$$ n $$$ grain weigh $$$ c - d $$$ $$$ c + d $$$ grams inclusive ( number $$$ c $$$ $$$ d $$$ know ) weight package sum weight $$$ n $$$ grain help nastya understand information correct word check whether grain a mass $$$ i $$$ -th grain weigh integer number $$$ x_i $$$ $$$ ( a - b \leq x_i \leq a + b ) $$$ total weigh $$$ c - d $$$ $$$ c + d $$$ inclusive ( $$$ c - d \leq \sum\limits _ { i=1 } ^ { n } { x_i } \leq c + d $$$ ) input consist multiple test case first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000 ) $$$ — number test case next $$$ t $$$ line contain descriptions test case line contain $$$ 5 $$$ integers : $$$ n $$$ $$$ ( 1 \leq n \leq 1000 ) $$$ — number grain nastya count $$$ a b c d $$$ $$$ ( 0 \leq b < a \leq 1000 0 \leq d < c \leq 1000 ) $$$ — number determine possible weight one grain rice ( $$$ a - b $$$ $$$ a + b $$$ ) possible total weight package ( $$$ c - d $$$ $$$ c + d $$$ ) test case give input print ` ` yes '' information weight inconsistent print ` ` '' $$$ n $$$ grain mass $$$ a - b $$$ $$$ a + b $$$ make a package a total mass $$$ c - d $$$ $$$ c + d $$$ first test case example assume grain weigh $$$ 17 $$$ grams a pack $$$ 119 $$$ grams really nastya could collect whole pack third test case example assume grain weigh $$$ 16 $$$ grams a pack $$$ <unknown> $$$ grams really nastya could collect whole pack fifth test case example assume $$$ 3 $$$ grain rice weigh $$$ 2 $$$ $$$ 2 $$$ $$$ 3 $$$ grams a pack $$$ 7 $$$ grams really nastya could collect whole pack second fourth test case example prove impossible determine correct weight grain rice weight pack weight pack equal total weight collect grain,['math'],900.0
1342/C,give two integers $$$ a $$$ $$$ b $$$ $$$ q $$$ query $$$ i $$$ -th query consist two number $$$ l_i $$$ $$$ r_i $$$ answer number integers $$$ x $$$ $$$ l_i \le x \le r_i $$$ $$$ ( ( x \bmod a ) \bmod b ) \ne ( ( x \bmod b ) \bmod a ) $$$ calculate answer query recall $$$ y \bmod z $$$ remainder division $$$ y $$$ $$$ z $$$ example $$$ 5 \bmod 3 = 2 $$$ $$$ 7 \bmod 8 = 7 $$$ $$$ 9 \bmod 4 = 1 $$$ $$$ 9 \bmod 9 = 0 $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case test case follow first line test case contain three integers $$$ a $$$ $$$ b $$$ $$$ q $$$ ( $$$ 1 \le a b \le 200 $$$ ; $$$ 1 \le q \le 500 $$$ ) $$$ q $$$ line follow contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le 10^ { 18 } $$$ ) correspond query test case print $$$ q $$$ integers — answer query test case order appear,['math'],1600.0
1342/E,calculate number ways place $$$ n $$$ rook $$$ n \times n $$$ chessboard follow condition meet : empty cell attack least one rook row least one rook column two rook attack share row column rook example two pair rook attack follow picture : two ways place rook consider different exist least one cell empty one ways contain a rook another way answer might large print modulo $$$ 998244353 $$$ line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 0 \le k \le \frac { n ( n - 1 ) } { 2 } $$$ ) print one integer — number ways place rook take modulo $$$ 998244353 $$$,['math'],2300.0
1343/B,give a positive integer $$$ n $$$ guarantee $$$ n $$$ even ( i.e divisible $$$ 2 $$$ ) want construct array $$$ a $$$ length $$$ n $$$ : multiple answer print guarantee answer exist answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow line test case contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — length array guarantee $$$ n $$$ even ( i.e divisible $$$ 2 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print answer — ` ` '' ( without quote ) suitable answer give test case ` ` yes '' first line suitable array $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) satisfy condition problem statement second line,['math'],800.0
1344/A,"hilbert 's hotel a unusual hotel since number room infinite ! fact exactly one room every integer include zero negative integers even stranger hotel currently full capacity mean exactly one guest every room hotel 's manager <unknown> hilbert decide want shuffle guests around think create a <unknown> ( a room without a guest ) integer $$$ k $$$ positive integer $$$ n $$$ let $$$ k\bmod n $$$ denote remainder $$$ k $$$ divide $$$ n $$$ formally $$$ r = k\bmod n $$$ smallest non - negative integer $$$ k - r $$$ divisible $$$ n $$$ always hold $$$ 0\le k\bmod n\le n-1 $$$ example $$$ <unknown> <unknown> $$$ $$$ ( <unknown> ) \bmod <unknown> $$$ shuffle work follow array $$$ n $$$ integers $$$ a_0 a_1 \ldots a _ { n-1 } $$$ integer $$$ k $$$ guest room $$$ k $$$ move room number $$$ <unknown> _ { k\bmod n } $$$ shuffle process determine still exactly one guest assign room , <unknown> room multiple guests test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 10000 $$$ ) — number test case next $$$ 2 t $$$ line contain descriptions test case first line test case contain a single integer $$$ n $$$ ( $$$ 1\le n\le 2\cdot 100000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_0 a_1 \ldots a _ { n-1 } $$$ ( $$$ <unknown> a_i\le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case output a single line contain ` ` yes '' exactly one guest assign room shuffle process ` ` '' otherwise print letter case ( upper lower ) first test case every guest shift $$$ 14 $$$ room assignment still unique second test case even guests move right $$$ 1 $$$ room odd guests move leave $$$ 1 $$$ room show assignment still unique third test case every fourth guest move right $$$ 1 $$$ room guests move right $$$ 5 $$$ room show assignment still unique fourth test case guests $$$ 0 $$$ $$$ 1 $$$ assign room $$$ 3 $$$ fifth test case guests $$$ 1 $$$ $$$ 2 $$$ assign room $$$ 2 $$$",['math'],1600.0
1365/G,"interactive problem ayush devise yet another scheme set password lock lock $$$ n $$$ slot slot hold non - negative integer password $$$ p $$$ a sequence $$$ n $$$ integers $$$ i $$$ -th element go $$$ i $$$ -th slot lock set password ayush come array $$$ a $$$ $$$ n $$$ integers range $$$ [ 0 2^ { 63 } -1 ] $$$ set $$$ i $$$ -th element $$$ p $$$ bitwise integers array except $$$ a_i $$$ need guess password make a query choose a non - empty subset indices array ask bitwise elements array index subset ask 13 query first line input contain one integer $$$ n $$$ $$$ ( 2 \le n \le 1000 ) $$$ — number slot lock ask a query print a single line : query receive integer $$$ x $$$ — bitwise value array among indices query subset indices query invalid exceed number query get $$$ x = -1 $$$ case terminate program immediately guess password print a single line ` ` ! ` ` ( without quote ) follow $$$ n $$$ space - separated integers — password sequence guess password count towards number query ask interactor adaptive array $$$ a $$$ change query print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack solution use follow test format : first line print a single integer $$$ n $$$ $$$ ( 2 \le n \le 1000 ) $$$ — number slot lock next line contain $$$ n $$$ space - separated integers range $$$ [ 0 2^ { 63 } - 1 ] $$$ — array $$$ a $$$ array $$$ a $$$ example $$$ \ { { 1 2 4\ } } $$$ first element password bitwise $$$ a_2 $$$ $$$ a_3 $$$ second element bitwise $$$ a_1 $$$ $$$ a_3 $$$ third element bitwise $$$ a_1 $$$ $$$ a_2 $$$ hence password sequence $$$ \ { { 6 5 3\ } } $$$",['math'],2800.0
1335/A,two sisters alice <unknown> $$$ n $$$ candy want distribute $$$ n $$$ candy two sisters a way : task calculate number ways distribute exactly $$$ n $$$ candy sisters a way describe candy indistinguishable formally find number ways represent $$$ n $$$ sum $$$ n = <unknown> $$$ $$$ a $$$ $$$ b $$$ positive integers $$$ a > b $$$ answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow line a test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 2000000000 $$$ ) — number candy test case print answer — number ways distribute exactly $$$ n $$$ candy two sisters a way describe problem statement way satisfy condition print $$$ 0 $$$ test case example $$$ 3 $$$ possible ways distribute candy :,['math'],800.0
1369/A,lee go <unknown> decorate house a party use regular convex polygons ... lee think a regular $$$ n $$$ -sided ( convex ) polygon beautiful rotate a way least one edge parallel $$$ ox $$$ -axis least one edge parallel $$$ oy $$$ -axis time recall a regular $$$ n $$$ -sided polygon a convex polygon $$$ n $$$ vertices edge angle equal shop : market $$$ t $$$ regular polygons print yes beautiful otherwise first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number polygons market next $$$ t $$$ line contain a single integer $$$ n_i $$$ ( $$$ 3 \le n_i \le 1000000000 $$$ ) : mean $$$ i $$$ -th polygon a regular $$$ n_i $$$ -sided polygon polygon print yes 's beautiful otherwise ( case insensitive ) example $$$ 4 $$$ polygons market 's easy see equilateral triangle ( a regular $$$ 3 $$$ -sided polygon ) beautiful a square ( a regular $$$ 4 $$$ -sided polygon ) beautiful a regular $$$ 12 $$$ -sided polygon ( show ) beautiful well,['math'],800.0
1795/A,"two tower consist block two color : red blue tower represent string character b and/or r denote order block bottom top b correspond a blue block r correspond a red block perform follow operation number time : choose a tower least two block move top block top tower pair tower beautiful pair touch block color ; i. e. red block stand top another red block blue block stand top another blue block check possible perform number operations ( possibly zero ) make pair tower beautiful first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case test case consist three line : test case print yes possible perform several ( possibly zero ) operations a way pair tower become beautiful ; otherwise print may print letter case ( yes yes yes recognize positive answer , recognize negative answer ) first test case move top block first tower second tower ( see third picture ) second test case move top block second tower first tower $$$ 6 $$$ time third test case pair tower already beautiful",['implementation'],800.0
413/A,long ago company r2 buy company r1 consequently developments field <unknown> processors r2 laboratory test one r1 processors test go n step step processor get instructions temperature measure head engineer r2 keep a report record work processor : write minimum maximum measure temperature notebook assistant write temperatures notebook ( unknown reason ) record m. next day engineer 's assistant file a report m temperatures however chief engineer doubt assistant write everything correctly ( naturally chief engineer n't doubt note ) ask help give number n m min max list m temperatures determine whether <unknown> set m temperatures set n temperatures ( add n - m temperatures ) minimum temperature min maximum one max first line contain four integers n m min max ( 1 ≤ m < n ≤ 100 ; 1 ≤ min < max ≤ 100 ) second line contain m space - separated integers ti ( 1 ≤ ti ≤ 100 ) — temperatures report assistant note report temperatures temperatures want add contain equal temperatures data consistent print ' correct ' ( without quote ) otherwise print ' incorrect ' ( without quote ) first test sample one possible initial configurations temperatures [ 1 2 ] second test sample one possible initial configurations temperatures [ 2 1 3 ] third test sample impossible add one temperature obtain minimum equal 1 maximum equal 3,['implementation'],1200.0
592/A,"<unknown> one <unknown> chess players byteforces even invent a new variant chess name « <unknown> » new game play a board consist 8 row 8 columns begin every game black white pawn place board number black pawn place necessarily equal number white pawn place let enumerate row columns integers 1 8 . row number top bottom columns number leave right denote ( r c ) cell locate row r column c. always two players a b play game player a play white pawn player b play black ones goal player a put pawn row 1 player b try put pawn row 8 . soon players complete goal game finish immediately succeed player declare a winner player a move first alternate turn move player a must choose exactly one white pawn move one step upward player b ( turn ) must choose exactly one black pawn move one step move possible target cell empty 's guarantee scenario game always least one move available players move upward mean pawn locate ( r c ) go cell ( r - 1 c ) move mean pawn locate ( r c ) go cell ( r + 1 c ) , correspond cell must empty i.e occupy pawn color give initial disposition board determine win game players play optimally note always a winner due restriction game scenario players move available input consist board description give eight line line contain eight character character ' b ' use denote a black pawn character ' w ' represent a white pawn empty cell mark ' . ' 's guarantee white pawn first row neither black pawn last row print ' a ' player a win game give board ' b ' player b claim victory , 's guarantee always a winner give board first sample player a able complete goal 3 step always move a pawn initially locate ( 4 5 ) player b need least 5 step pawn reach row 8 . hence player a winner",['implementation'],1200.0
609/B,"emily 's birthday next week jack decide buy a present know love book go local bookshop n book sale one m genres bookshop jack decide buy two book different genres base genre book sale shop find number options available jack choose two book different genres emily options consider different differ least one book book give indices genres genres number 1 m. first line contain two positive integers n m ( 2 ≤ n ≤ 2·105 2 ≤ m ≤ 10 ) — number book <unknown> number genres second line contain a sequence a1 a2 ... , ai ( 1 ≤ ai ≤ m ) equal genre i - th book guarantee genre least one book genre print integer — number ways jack choose book guarantee answer n't exceed value 2·109 answer first test sample equal 5 <unknown> choose :",['implementation'],1100.0
617/C,"a <unknown> many flower two fountains <unknown> water <unknown> set value r1 ( r1 ≥ 0 ) r2 ( r2 ≥ 0 ) give distance water spread first second fountain respectively set r1 r2 flower water , flower distance flower first fountain n't exceed r1 distance second fountain n't exceed r2 's ok flower water fountains need decrease amount water need set r1 r2 flower water r12 + r22 minimum possible find minimum value first line input contain integers n x1 y1 x2 y2 ( 1 ≤ n ≤ 2000 - 107 ≤ x1 y1 x2 y2 ≤ 107 ) — number flower coordinate first second fountain next follow n line i - th line contain integers xi yi ( - 107 ≤ xi yi ≤ 107 ) — coordinate i - th flower guarantee n + 2 point input distinct print minimum possible value r12 + r22 note problem optimal answer always integer first sample ( r12 = 5 r22 = 1 ) : second sample ( r12 = 1 r22 = 32 ) :",['implementation'],1600.0
616/A,give two long integers a b ( lead zero allow ) check number a b greater determine equal input size large n't use read symbols one one instead use read a whole line token input / output reach huge size recommend use fast input / output methods : example prefer use scanf / printf instead cin / cout c++ prefer use bufferedreader / printwriter instead scanner / system.out java n't use function input ( ) <unknown> instead use function <unknown> ( ) first line contain a non - negative integer a. second line contain a non - negative integer b. number a b may contain lead zero contain 106 digits print symbol ` ` < ` ` a < b symbol ` ` > '' a > b. number equal print symbol ` ` = '',['implementation'],900.0
615/A,vasya want turn christmas light consist m bulbs initially bulbs turn n button connect set bulbs vasya press button button press turn bulbs 's connect vasya light bulbs ? vasya press button bulbs connect already turn change state i.e remain turn first line input contain integers n m ( 1 ≤ n m ≤ 100 ) — number button number bulbs respectively next n line contain xi ( 0 ≤ xi ≤ m ) — number bulbs turn i - th button xi number yij ( 1 ≤ yij ≤ m ) — number bulbs 's possible turn m bulbs print ` ` yes '' otherwise print ` ` '' first sample press button turn bulbs 2 sample impossible turn 3 - rd lamp,['implementation'],800.0
614/A,programmer rostislav get <unknown> interest link / cut tree data structure base splay tree specifically study expose procedure unfortunately rostislav unable understand definition procedure decide ask programmer serezha help serezha agree help rostislav solve a simple task ( n't would need splay tree anyway ? ) give integers l r k need print power number k within range l r inclusive however rostislav n't want spend time get interest play a network game call <unknown> <unknown> help ! first line input contain three space - separated integers l r k ( 1 ≤ l ≤ r ≤ 1018 2 ≤ k ≤ 109 ) print power number k lie within range l r increase order number print ` ` -1 '' ( without quote ) note first sample : number 20 = 1 21 = 2 22 = 4 23 = 8 lie within specify range number 24 = 16 greater 10 thus n't print,['implementation'],1500.0
612/A,give string s length n number p q. split string s piece length p q. example string ` ` hello '' p = 2 q = 3 split two string ` ` <unknown> '' ` ` <unknown> '' two string ` ` '' ` ` <unknown> '' note allow split string s string length p string length q ( see second sample test ) first line contain three positive integers n p q ( 1 ≤ p q ≤ n ≤ 100 ) second line contain string s consist lowercase uppercase latin letter digits 's impossible split string s string length p q print number ` ` -1 '' otherwise first line print integer k — number string partition s. next k line contain string partition string length p q. string order appear string s — leave right several solutions print,['implementation'],1300.0
611/F,limak a little polar bear parent tell clean a house new year 's eve house a rectangular grid h row w columns cell empty square a little bear thus ca n't clean a house instead go use a clean robot a clean robot a built - in pattern n move define a string length n. a single move ( character ) move a robot one four adjacent cells character one follow four : ' u ' ( ) 'd ' ( ) ' l ' ( leave ) ' r ' ( right ) one move take one minute a clean robot must place start cell repeat pattern move till hit a wall ( one four border a house ) hit a wall place use limak n't sure place a clean robot one cell enough thus go start <unknown> time one time cell maybe cells clean care ? limak ask one question much time take clean a house ? find print number minutes modulo 109 + 7 . 's also possible a clean robot never stop — print ` ` -1 '' ( without quote ) instead place start a robot take time however must count a move robot hit a wall take a look sample clarification first line contain three integers n h w ( 1 ≤ n h w ≤ 500 000 ) — length pattern number row number columns respectively second line contain a string length n — pattern n move character one uppercase letter ' u ' 'd ' ' l ' ' r ' print one line answer a clean robot never stop print ` ` -1 '' ( without quote ) otherwise print number minutes take clean a house modulo 109 + 7 . first sample house a grid 10 row 2 columns start a robot anywhere second column result one move ( thus one minute clean ) robot hit a wall — try go right third column start a robot anywhere first column result two move total number minutes 10·1 + <unknown> = 30 . second sample a start robot try move ` ` <unknown> ... '' example leftmost cell second row robot make 5 move stop hit upper wall,['implementation'],2500.0
611/B,year 2015 almost limak a little polar bear recently learn binary system notice pass year exactly one zero representation binary system — <unknown> = <unknown> . note n't care number zero decimal representation limak choose interval years go count years interval exactly one zero binary representation faster ? assume positive integers always write without lead zero line input contain two integers a b ( 1 ≤ a ≤ b ≤ 1018 ) — first year last year limak 's interval respectively print one integer – number years limak count choose interval first sample limak 's interval contain number <unknown> = 1012 <unknown> = 1102 <unknown> = 1112 <unknown> = <unknown> <unknown> = 10012 1010 = 10102 . two ( 1012 1102 ) describe property,['implementation'],1300.0
611/A,"today wednesday third day week 's interest tomorrow last day year 2015 . limak a little polar bear enjoy year a lot , eager come year 2016 . limak want prove responsible a bear go regularly save candy entire year 2016 ! consider various save plan save one candy either fix day week fix day month limak choose one particular plan n't sure many candy save 2016 plan please calculate tell line input one follow two format : print one integer — number candy limak save year 2016 . polar bear use <unknown> calendar common calendar likely use read wikipedia want – https : //en.wikipedia.org / wiki / <unknown> week start monday first sample limak want save one candy thursday ( 4 - th day week ) 52 <unknown> 2016 . thus save 52 candy total second sample limak want save one candy 30 - th day month 30 - th day exactly 11 months 2016 — months <unknown> mean limak save 11 candy total",['implementation'],900.0
621/A,today wet shark give n integers use integers wet shark want get maximum possible even ( divisible 2 ) sum please calculate value wet shark note wet shark use integers n integers sum even integer 0 . first line input contain one integer n ( 1 ≤ n ≤ 100 000 ) next line contain n space separate integers give wet shark integers range 1 109 inclusive print maximum possible even sum obtain use give integers first sample simply take three integers a total sum 6 . second sample wet shark take four five integers 999 999 999,['implementation'],900.0
618/A,"friend recently give slim birthday n slim initially value 1 . go play a game slim initially put a single slime a row , add n - 1 slim one one add a slime place right already place slim , last two slim row value v combine together create a slime value v + 1 . would like see final state row ' ve add n slim please print value slim row leave right first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) output a single line k integers k number slim row ' ve finish procedure describe problem statement i - th number value i - th slime leave first sample a single slime value 1 . final state board a single slime value 1 . second sample perform follow step : initially place a single slime a row thus row initially 1 . add another slime row 1 1 . since two rightmost slim value replace slim one value 2 . thus final state board 2 . third sample add first two slim row 2 . add one slime row become 2 1 . last sample step look follow :",['implementation'],800.0
610/B,vika n jar paint distinct color jar number 1 n i - th jar contain ai liters paint color i. vika also infinitely long rectangular piece paper width 1 consist square size 1 × 1 . square number 1 2 3 vika decide start paint square one one leave right start square number 1 arbitrary color square paint color x next square paint color x + 1 . case x = n next square paint color 1 . paint color vika want use stop square always paint one color take exactly 1 liter paint task calculate maximum number square might paint vika choose right color paint first square first line input contain a single integer n ( 1 ≤ n ≤ 200 000 ) — number jar color vika second line input contain a sequence integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) ai equal number liters paint i - th jar i.e number liters color i vika line output contain a single integer — maximum number square vika paint follow rule describe first sample best strategy start paint use color 4 . square paint follow color ( leave right ) : 4 5 1 2 3 4 5 1 2 3 4 5 . second sample vika start paint use color third sample vika start paint use color number 5,['implementation'],1300.0
606/A,<unknown> a beginner magician a blue b violet c orange magic spheres one move transform two spheres color one <unknown> color make a spell never see need least x blue y violet z orange spheres get ( possible multiple action ) ? first line input contain three integers a b c ( 0 ≤ a b c ≤ 1 000 000 ) — number blue violet orange spheres magician 's disposal second line input contain three integers x y z ( 0 ≤ x y z ≤ 1 000 000 ) — number blue violet orange spheres need get wizard able obtain require number spheres print ` ` yes '' otherwise print ` ` '' first sample wizard 4 blue 4 violet spheres first action turn two blue spheres one violet one 2 blue 5 violet spheres turn 4 violet spheres 2 orange spheres end 2 blue 1 violet 2 orange spheres exactly need,['implementation'],1200.0
604/A,kevin sun finish compete codeforces round # <unknown> ! round 120 minutes long feature five problems maximum point value 500 1000 1500 2000 2500 respectively despite challenge task kevin <unknown> <unknown> distinguish <unknown> best <unknown> scientist <unknown> kevin know submission time problem number wrong submissions make problem total number successful unsuccessful hack codeforces score complicate kevin want write a program compute final score codeforces score compute follow : maximum point value a problem x kevin submit correctly minute m make w wrong submissions score problem total score equal sum score problem addition kevin 's total score get increase 100 point successful hack get decrease 50 point unsuccessful hack arithmetic operations perform absolute precision round guarantee kevin 's final score integer first line input contain five space - separated integers m1 m2 m3 m4 m5 mi ( 0 ≤ mi ≤ 119 ) time kevin 's last submission problem i. last submission always correct get accept second line contain five space - separated integers w1 w2 <unknown> <unknown> <unknown> wi ( 0 ≤ wi ≤ 10 ) kevin 's number wrong submissions problem i. last line contain two space - separated integers hs hu ( 0 ≤ hs hu ≤ 20 ) denote kevin 's number successful unsuccessful hack respectively print a single integer value kevin 's final score second sample kevin take 119 minutes problems therefore get point problem score solve problems add <unknown> = 1000 point hack total score become <unknown> + 1000 = <unknown>,['implementation'],1000.0
602/A,see ` ` base belong us '' <unknown> first time number x y realise different base complicate relations 're give a number x represent base bx a number y represent base compare two number first line input contain two space - separated integers n bx ( 1 ≤ n ≤ 10 2 ≤ bx ≤ 40 ) n number digits bx - based representation x. second line contain n space - separated integers x1 x2 ... xn ( 0 ≤ xi < bx ) — digits x. give order significant digit least significant one follow two line describe y way : third line contain two space - separated integers m ( 1 ≤ m ≤ 10 2 ≤ ≤ 40 bx ≠ ) m number digits by - based representation y fourth line contain m space - separated integers y1 y2 ... ym ( 0 ≤ yi < ) — digits y. lead zero x y positive digits number give standard decimal numeral system output a single character ( quote clarity ) : first sample x = <unknown> = <unknown> = y. second sample x = 1023 = 215 y = <unknown> = <unknown> thus x < y. third sample y = <unknown> . may notice x start much larger digits bx much larger x clearly larger y,['implementation'],1100.0
600/A,"give string s. let 's call word largest sequence consecutive symbols without symbols ' ' ( comma ) ' ; ' ( <unknown> ) example four word string ` ` aba,123 ; 1a ; 0 '' : ` ` aba '' ` ` 123 '' ` ` 1a '' ` ` 0 '' a word empty : example string s= '' ; ; '' contain three empty word separate ' ; ' find word give string nonnegative integer number without lead zero build new string a. string a contain word number separate ' ' ( order number remain string s ) word build string b way ( order number remain string s ) string ` ` 101 '' ` ` 0 '' integer number ` ` 01 '' ` ` <unknown> '' example string aba,123 ; 1a ; 0 string a would equal ` ` <unknown> '' string b would equal ` ` <unknown> '' line input contain string s ( 1 ≤ |s| ≤ 105 ) string contain symbols ' . ' ( ascii <unknown> ) ' ' ( ascii <unknown> ) ' ; ' ( ascii 59 ) digits lowercase uppercase latin letter print string a first line string b second line string surround quote ( ascii 34 ) word number print dash ( ascii 45 ) first line word number print dash second line second example string s contain five word : ` ` 1 '' ` ` '' ` ` 01 '' ` ` a0 '' ` ` ''",['implementation'],1600.0
599/B,"patrick go shop spongebob decide play a little trick friend naughty <unknown> <unknown> patrick 's personal stuff find a sequence a1 a2 ... length m consist integers 1 n necessarily distinct pick sequence f1 f2 ... fn length n number ai get number bi = fai finish <unknown> erase initial sequence ai 's hard express sad patrick return home shop ! say spongebob immediately get really sorry do try restore original sequence help determine impossible first line input contain two integers n m ( 1 ≤ n m ≤ 100 000 ) — lengths sequence fi bi respectively second line contain n integers determine sequence f1 f2 ... fn ( 1 ≤ fi ≤ n ) last line contain m integers determine sequence b1 b2 ... bm ( 1 ≤ bi ≤ n ) print ` ` possible '' exactly one sequence ai bi = fai i 1 m. print m integers a1 a2 ... , multiple suitable sequence ai print ` ` <unknown> '' spongebob make a mistake calculations suitable sequence ai exist print ` ` impossible '' first sample 3 replace 1 vice versa 2 never change answer exist unique second sample number replace 1 impossible <unknown> restore original sequence third sample fi ≠ 3 i sequence ai transform bi say sure spongebob make a mistake",['implementation'],1500.0
599/A,today patrick wait a visit friend spongebob prepare visit patrick need buy <unknown> two store locate near house a d1 meter long road house first shop a d2 meter long road house second shop also a road length d3 directly connect two shop help patrick calculate minimum distance need walk order go shop return house patrick always start house visit shop move along three exist roads return back house n't mind visit shop pass road multiple time goal minimize total distance travel first line input contain three integers d1 d2 d3 ( 1 ≤ d1 d2 d3 ≤ 108 ) — lengths paths print minimum distance patrick walk order visit shop return house first sample show picture problem statement one optimal rout : house first shop second shop house second sample one optimal rout : house first shop house second shop house,['implementation'],800.0
598/B,give a string s process m query query describe two 1 - based indices li ri integer ki mean cyclically shift substring s [ li ... ri ] ki time query process one another order give one operation a cyclic shift ( rotation ) <unknown> move last character position first character shift character one position right example string s abacaba query l1 = 3 r1 = 6 k1 = 1 answer <unknown> would process query l2 = 1 r2 = 4 k2 = 2 would get string <unknown> first line input contain string s ( 1 ≤ |s| ≤ 10 000 ) initial state |s| stand length s. contain lowercase english letter second line contain a single integer m ( 1 ≤ m ≤ 300 ) — number query i - th next m line contain three integers li ri ki ( 1 ≤ li ≤ ri ≤ |s| 1 ≤ ki ≤ 1 000 000 ) — description i - th query print result string s process m query sample describe problem statement,['implementation'],1300.0
596/A,make bad <unknown> swim pool wilbur want build a swim pool shape a rectangle <unknown> set coordinate ax want side rectangle parallel course area rectangle must positive wilbur four vertices plan pool write a paper friend come along erase vertices wilbur wonder remain n vertices initial rectangle give enough information restore area plan swim pool first line input contain a single integer n ( 1 ≤ n ≤ 4 ) — number vertices erase wilbur 's friend follow n line contain two integers xi yi ( - 1000 ≤ xi yi ≤ 1000 ) — the coordinate i - th vertex remain vertices give arbitrary order 's guarantee point distinct vertices rectangle positive area side parallel coordinate ax print area initial rectangle could uniquely determine point remain otherwise print - 1 . first sample two opposite corner initial rectangle give give enough information say rectangle actually a unit square second sample one vertex leave definitely enough uniquely define area,['implementation'],1100.0
595/A,"one day vitaly go home late night wonder : many people n't sleep moment ? estimate vitaly decide look windows light house pass moment vitaly see a build n floor 2·m windows floor floor m flats number 1 m two consecutive windows correspond flat number windows 1 2·m leave right j - th flat i - th floor windows 2·j - 1 2·j correspond row windows ( usual floor enumerate bottom ) vitaly think people flat n't sleep moment least one windows correspond flat light give information windows give house task calculate number flats accord vitaly people n't sleep first line input contain two integers n m ( 1 ≤ n m ≤ 100 ) — number floor house number flats floor respectively next n line describe floor top bottom contain 2·m character i - th window give floor light i - th character line ' 1 ' otherwise ' 0 ' print a single integer — number flats light least one window , flats accord vitaly people n't sleep first test case house two floor two flats floor , total 4 flats light n't second floor leave flat , room flat light second test case house one floor first floor three flats light leftmost flat ( windows ) middle flat ( one window ) right flat light",['implementation'],800.0
593/A,"andrew often read article favorite magazine 2char main feature article use two distinct letter andrew decide send article magazine n't write article decide take a random one magazine <unknown> however send magazine 2char need <unknown> text format journal , remove word choose article a way remain text write use two distinct letter since <unknown> depend number non - space character article andrew want keep word maximum total length first line input contain number n ( 1 ≤ n ≤ 100 ) — number word article choose andrew follow n line contain one word word consist small english letter total length n't exceed 1000 . word guarantee distinct case allow use a word article many time appear input print a single integer — maximum possible total length word andrew 's article first sample optimal way choose word { ' abb ' ' aaa ' ' bbb ' } second sample word ' <unknown> ' consist three distinct letter thus use article optimal answer { ' a ' ' a ' ' aaaa ' }",['implementation'],1200.0
606/B,"<unknown> <unknown> ( cf ) <unknown> make a prototype a bomb <unknown> robot find possible problems decide carry a series test begin test robot prototype place cell ( x0 y0 ) a rectangular square field size x × y a mine instal one square field suppose conduct exactly <unknown> test time a mine instal a square never use start cell robot always remain place object field robot run a sequence command give string s consist character ' l ' ' r ' ' u ' 'd ' command tell robot move one square leave right , stay idle move give direction impossible soon robot fulfill sequence command blow due a bug code moment time robot square mine also blow due a bug code move leave decrease coordinate y move right increase similarly move decrease x coordinate move increase test go long task predict result k 0 length ( s ) task find many test robot run exactly k command blow first line input contain four integers x y x0 y0 ( 1 ≤ x y ≤ 500 1 ≤ x0 ≤ x 1 ≤ y0 ≤ y ) — size field start coordinate robot coordinate axis x direct downwards axis y direct right second line contain a sequence command s fulfil robot length 1 100 000 character consist character ' l ' ' r ' ' u ' 'd ' print sequence consist ( length ( s ) + 1 ) number k - th position start zero print number test robot run exactly k command blow first sample exclude probable impact mine robot 's route look like :",['implementation'],1600.0
618/C,cat noku obtain a map night sky map find a <unknown> n star number 1 n. i i - th star locate coordinate ( xi yi ) two star locate position even noku go take a look night sky would like find three distinct star form a triangle triangle must positive area addition star must lie strictly outside triangle trouble find answer would like help job find indices three star would form a triangle satisfy condition guarantee line star lie line prove previous condition satisfy exist a solution problem first line input contain a single integer n ( 3 ≤ n ≤ 100 000 ) next n line contain two integers xi yi ( - 109 ≤ xi yi ≤ 109 ) guarantee two star lie point exist a line star lie line print three distinct integers a single line — indices three point form a triangle satisfy condition state problem multiple possible answer may print first sample print three indices order second sample follow picture note triangle form start 1 4 3 n't satisfy condition state problem point 5 strictly outside triangle ( lie 's border ),['implementation'],1600.0
620/B,max find electronic calculator <unknown> <unknown> 's chest notice number write seven - segment indicators ( https : //en.wikipedia.org / wiki / seven - <unknown> ) max start type value a b. type number max reset calculator find total number segment print calculator example a = 1 b = 3 first calculator print 2 segment — 5 segment last print 5 segment total number print segment 12 . line contain two integers a b ( 1 ≤ a ≤ b ≤ 106 ) — first last number type max print integer a — total number print segment,['implementation'],1000.0
617/D,three point mark coordinate plane goal make a simple polyline without self - intersections self - touches pass point also polyline must consist segment parallel coordinate ax find minimum number segment polyline may consist three line input contain two integers i - th line contain integers xi yi ( - 109 ≤ xi yi ≤ 109 ) — coordinate i - th point guarantee point distinct print a single number — minimum possible number segment polyline variant polyline first sample : variant polyline second sample : variant polyline third sample :,['implementation'],1700.0
591/B,name one small proud corporation consist n lowercase english letter corporation decide try rebranding — active market strategy include a set measure change either brand ( company goods produce ) components : name <unknown> <unknown> decide start name purpose corporation consecutively hire m designers a company hire i - th designer immediately <unknown> creation a new corporation name follow : take newest version name replace letter xi yi letter yi xi result new version possible letter occur string may also happen xi coincide yi version name receive work last designer become new name corporation manager arkady recently get a job company already <unknown> <unknown> <unknown> worry success rebranding naturally ca n't wait find new name corporation receive satisfy arkady 's curiosity tell final version name first line input contain two integers n m ( 1 ≤ n m ≤ 200 000 ) — length initial name number designers hire respectively second line consist n lowercase english letter represent original name corporation next m line contain descriptions designers ' action : i - th contain two space - separated lowercase english letter xi yi print new name corporation second sample name corporation consecutively change follow :,['implementation'],1200.0
621/B,today wet shark give n bishops a 1000 1000 grid row columns grid number 1 1000 . row number top bottom columns number leave right wet shark think two bishops attack share diagonal note criteria two bishops may attack ( accord wet shark ) even another bishop locate wet shark want count number pair bishops attack first line input contain n ( 1 ≤ n ≤ 200 000 ) — number bishops next n line contain two space separate integers xi yi ( 1 ≤ xi yi ≤ 1000 ) — number row number column i - th bishop position 's guarantee two bishops share position output one integer — number pair bishops attack first sample follow pair bishops attack : ( 1 3 ) ( 1 5 ) ( 2 3 ) ( 2 4 ) ( 3 4 ) ( 3 5 ) pair ( 1 2 ) ( 1 4 ) ( 2 5 ) ( 4 5 ) attack share diagonal,['implementation'],1300.0
831/B,two popular keyboard layouts berland differ letter position key berland use alphabet 26 letter coincide english alphabet give two string consist 26 distinct letter : key first second layouts order also give text consist small capital english letter digits know type first layout writer intend type second layout print text key press second layout since key letter layouts <unknown> letter remain well character first line contain a string length 26 consist distinct lowercase english letter first layout second line contain a string length 26 consist distinct lowercase english letter second layout third line contain a non - empty string s consist lowercase uppercase english letter digits text type first layout length s exceed 1000 . print text key press second layout,['implementation'],800.0
672/B,a wise man tell kerem ` ` different good '' kerem want things life different kerem recently get a string s consist lowercase english letter since kerem like things different want substrings string s distinct substring a string form number consecutive character string example string ` ` aba '' substrings ` ` '' ( empty substring ) ` ` a '' ` ` b '' ` ` a '' ` ` ab '' ` ` ba '' ` ` aba '' string s least two equal substrings kerem change character position lowercase english letter change character a tire job kerem want perform change possible task find minimum number change need make substrings give string distinct determine impossible first line input contain integer n ( 1 ≤ n ≤ 100 000 ) — length string s. second line contain string s length n consist lowercase english letter 's impossible change string s substring distinct print -1 . otherwise print minimum require number change first sample one possible solutions change first character ' b ' second sample one may change first character ' a ' second character ' b ' string become ` ` <unknown> '',['implementation'],1000.0
672/A,every year <unknown> people come summer camp learn new algorithms solve hard problems first year summer camp ask solve follow problem integers start 1 write one line prefix line ` ` <unknown> ... '' task print n - th digit string ( digits number start 1 . line input contain a single integer n ( 1 ≤ n ≤ 1000 ) — position digit need print print n - th digit line first sample digit position 3 ' 3 ' integers 1 2 consist one digit second sample digit position 11 ' 0 ' belong integer 10,['implementation'],800.0
670/D2,term problem previous one exception — increase restrictions first line contain two positive integers n k ( 1 ≤ n ≤ 100 000 1 ≤ k ≤ 109 ) — number ingredients number grams magic powder second line contain sequence a1 a2 ... ( 1 ≤ ai ≤ 109 ) i - th number equal number grams i - th ingredient need bake one cookie third line contain sequence b1 b2 ... bn ( 1 ≤ bi ≤ 109 ) i - th number equal number grams i - th ingredient apollinaria print maximum number cookies apollinaria able bake use ingredients magic powder,['implementation'],1500.0
670/D1,problem give two versions differ constraints solve problem large constraints write a single solution versions find problem difficult large constraints write solution simplify version wake morning apollinaria decide bake cookies bake one cookie need n ingredients ingredient know value ai — many grams ingredient one need bake a cookie prepare one cookie apollinaria need use n ingredients apollinaria bi gram i - th ingredient also k grams a magic powder gram magic powder turn exactly 1 gram n ingredients use bake cookies task determine maximum number cookies apollinaria able bake use ingredients magic powder first line input contain two positive integers n k ( 1 ≤ n k ≤ 1000 ) — number ingredients number grams magic powder second line contain sequence a1 a2 ... ( 1 ≤ ai ≤ 1000 ) i - th number equal number grams i - th ingredient need bake one cookie third line contain sequence b1 b2 ... bn ( 1 ≤ bi ≤ 1000 ) i - th number equal number grams i - th ingredient apollinaria print maximum number cookies apollinaria able bake use ingredients magic powder first sample <unknown> apollinaria make exist 1 gram magic powder ingredient index 2 apollinaria able bake 4 cookies second sample apollinaria turn 1 gram magic powder ingredient index 1 1 gram magic powder ingredient index 3 . apollinaria able bake 3 cookies remain 1 gram magic powder leave ca n't use increase answer,['implementation'],1400.0
670/C,moscow host a major <unknown> conference attend n scientists different countries scientists know exactly one language convenience enumerate languages world integers 1 109 . even conference n scientists decide go cinema m movies cinema come movies characterize two distinct number — index audio language index subtitle language scientist come movie please know audio language movie almost satisfy know language subtitle satisfy know neither one ( note audio language subtitle language movie always different ) scientists decide go together movie help choose movie number please scientists maximum possible several movies select among one maximize number almost satisfy scientists first line input contain a positive integer n ( 1 ≤ n ≤ 200 000 ) — number scientists second line contain n positive integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) ai index a language i - th scientist know third line contain a positive integer m ( 1 ≤ m ≤ 200 000 ) — number movies cinema fourth line contain m positive integers b1 b2 ... bm ( 1 ≤ bj ≤ 109 ) bj index audio language j - th movie fifth line contain m positive integers c1 c2 ... cm ( 1 ≤ cj ≤ 109 ) cj index subtitle language j - th movie guarantee audio languages subtitle language different movie bj ≠ cj print single integer — index a movie scientists go view movie number please scientists maximum possible cinema several movies need choose among one view maximum possible number almost satisfy scientists several possible answer print first sample scientists must go movie index 2 case 1 - th 3 - rd scientists please 2 - nd scientist almost satisfy second test case scientists go either movie index 1 index 3 . view movies exactly two scientists please others satisfy,['implementation'],1300.0
670/B,late autumn even n robots gather <unknown> company friends robot a unique identifier — integer 1 109 . moment robots decide play game ` ` <unknown> '' rule game first robots stand a row first robot say identifier second robot say identifier first robot say identifier third robot say identifier first robot say identifier second robot say process continue leave right n - th robot say identifier task determine k - th identifier pronounce first line contain two positive integers n k ( 1 ≤ n ≤ 100 000 1 ≤ k ≤ min ( 2·109 n · ( n + 1 ) / 2 ) second line contain sequence id1 id2 ... <unknown> ( 1 ≤ idi ≤ 109 ) — identifiers <unknown> guarantee identifiers different print k - th pronounce identifier ( assume numeration start 1 ) first sample identifiers robots pronounce follow order : 1 1 2 . k = 2 answer equal 1 . second test case identifiers robots pronounce follow order : 10 10 4 10 4 18 10 4 18 3 . k = 5 answer equal 4,['implementation'],1000.0
665/A,bus run cities a b first one 05:00 last one depart later <unknown> pm a bus city a depart every a minutes arrive city b a ta minutes a bus city b depart every b minutes arrive city a a tb minutes driver simion want make job diverse count bus go towards simion n't count bus meet start finish know time simion depart city a city b. calculate number bus simion meet sure count first line contain two integers a ta ( 1 ≤ a ta ≤ 120 ) — frequency bus city a city b travel time value give minutes second line contain two integers b tb ( 1 ≤ b tb ≤ 120 ) — frequency bus city b city a travel time value give minutes last line contain departure time simion city a format hh : mm guarantee a bus city a time note hours minutes give exactly two digits print integer z — number bus simion meet way note count encounter cities a b. first example simion depart form city a <unknown> arrive city b 05:50 meet first 5 bus city b depart period [ 05:00 - <unknown> ] also simion meet a bus city b 05:50 count also note first encounter <unknown> <unknown> ( suggest bus go <unknown> speed ),['implementation'],1600.0
660/B,consider 2n row seat a bus n row seat leave n row seat right row fill two people total capacity bus 4n consider m ( m ≤ 4n ) people occupy seat bus passengers enter bus number 1 m ( order enter bus ) pattern seat occupation <unknown> - st row leave window seat 1 - st row right window seat 2 - nd row leave window seat 2 - nd row right window seat ... n - th row leave window seat n - th row right window seat occupy window seat ( m > 2n ) non - window seat <unknown> - st row leave non - window seat 1 - st row right non - window seat ... n - th row leave non - window seat n - th row right non - window seat passengers go a single final destination final destination passengers get give <unknown> - st row leave non - window seat 1 - st row leave window seat 1 - st row right non - window seat 1 - st row right window seat ... n - th row leave non - window seat n - th row leave window seat n - th row right non - window seat n - th row right window seat give value n m. output m number 1 m order passengers get bus line contain two integers n m ( 1 ≤ n ≤ 100 1 ≤ m ≤ 4n ) — number pair row number passengers print m distinct integers 1 m — order passengers get bus,['implementation'],1000.0
658/A,"limak radewoosh go compete upcoming <unknown> contest equally <unknown> wo n't solve problems order n problems i - th problem initial score pi take exactly ti minutes solve problems sort difficulty — 's guarantee pi < pi + 1 ti < ti + 1 . a constant c give represent speed loose point , submit i - th problem time x ( x minutes start contest ) give max ( 0 pi - <unknown> ) point limak go solve problems order 1 2 ... n ( sort <unknown> pi ) radewoosh go solve order n n - 1 ... 1 ( sort <unknown> pi ) task predict outcome — print name winner ( person get point end ) a word ` ` tie '' case a tie may assume duration competition greater equal sum ti mean limak radewoosh accept n problems first line contain two integers n c ( 1 ≤ n ≤ 50 1 ≤ c ≤ 1000 ) — number problems constant represent speed loose point second line contain n integers p1 p2 ... pn ( 1 ≤ pi ≤ 1000 pi < pi + 1 ) — initial score third line contain n integers t1 t2 ... tn ( 1 ≤ ti ≤ 1000 ti < ti + 1 ) ti denote number minutes one need solve i - th problem print ` ` limak '' ( without quote ) limak get point total print ` ` radewoosh '' ( without quote ) radewoosh get point total print ` ` tie '' ( without quote ) limak radewoosh get total number point first sample 3 problems limak solve follow : limak get 30 + 35 + 150 = 215 point radewoosh solve problem reverse order : radewoosh get 200 + 5 + 0 = <unknown> point total limak 215 point limak win second sample limak get 0 point problem radewoosh first solve hardest problem get 250 - <unknown> = 100 point radewoosh get 0 point two problems winner anyway third sample limak get 2 point 1 - st problem 2 point 2 - nd problem radewoosh get 4 point 8 - th problem wo n't get point problems thus a tie 2 + 2 = 4",['implementation'],800.0
656/B,<unknown> yuo adn yuor <unknown> <unknown> <unknown> <unknown> btu <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> oen dya yuo <unknown> <unknown> <unknown> <unknown> yuor <unknown> <unknown> teh <unknown> <unknown> yuo <unknown> <unknown> <unknown> <unknown> m adn r <unknown> <unknown> dyas ( <unknown> teh <unknown> oen ) <unknown> <unknown> <unknown> ( teh <unknown> dya <unknown> ) adn yuo <unknown> teh <unknown> dya d adn <unknown> <unknown> <unknown> <unknown> i <unknown> taht d mod m [ i ] = r [ i ] <unknown> yuor <unknown> <unknown> yuo <unknown> teh <unknown> btu yuor <unknown> 's <unknown> <unknown> <unknown> yuo <unknown> <unknown> yuo <unknown> <unknown> teh <unknown> teh <unknown> yuo <unknown> <unknown> <unknown> m adn r. <unknown> teh <unknown> dyas <unknown> yuo <unknown> <unknown> teh <unknown> <unknown> taht yuo <unknown> <unknown> <unknown> dyas <unknown> yuo first line input contain a single integer n ( 1 ≤ n ≤ 16 ) second third line input contain n integers 0 16 inclusive represent array m r respectively m [ i ] positive i r [ i ] < m [ i ] output a single real number answer consider correct absolute relative error exceed 10 - 4,['implementation'],1700.0
673/A,"bear limak like watch sport tv go watch a game today game last 90 minutes break minute either interest bore 15 consecutive minutes bore limak immediately turn tv know n interest minutes t1 t2 ... tn task calculate many minutes limak watch game first line input contain one integer n ( 1 ≤ n ≤ 90 ) — number interest minutes second line contain n integers t1 t2 ... tn ( 1 ≤ t1 < t2 < ... tn ≤ 90 ) give increase order print number minutes limak watch game first sample minutes 21 22 ... 35 bore thus limak turn tv immediately 35 - th minute , would watch game 35 minutes second sample first 15 minutes bore third sample consecutive 15 bore minutes , limak watch whole game",['implementation'],800.0
653/C,life go like nice sequence sequence t1 t2 ... tn call nice follow two condition satisfy : example sequence ( 2 8 ) ( 1 5 1 ) ( 2 5 1 100 99 120 ) nice ( 1 1 ) ( 1 2 3 ) ( 2 5 3 2 ) bear limak a sequence positive integers t1 t2 ... tn sequence nice limak want fix a single swap go choose two indices i < j swap elements ti tj order get a nice sequence count number ways two ways consider different indices elements choose a swap different first line input contain one integer n ( 2 ≤ n ≤ 150 000 ) — length sequence second line contain n integers t1 t2 ... tn ( 1 ≤ ti ≤ 150 000 ) — initial sequence 's guarantee give sequence nice print number ways swap two elements exactly order get a nice sequence first sample two ways get a nice sequence one swap : second sample one way — limak swap t1 = 200 t4 = 50,['implementation'],1900.0
653/A,limak a little polar bear n ball i - th ball size ti limak want give one ball three friends give gift n't easy — two rule limak must obey make friends happy : example limak choose ball size 4 5 3 ball size 90 91 92 . ca n't choose ball size 5 5 6 ( two friends would get ball size ) ca n't choose ball size 30 31 33 ( size 30 33 differ 2 ) task check whether limak choose three ball satisfy condition first line input contain one integer n ( 3 ≤ n ≤ 50 ) — number ball limak second line contain n integers t1 t2 ... tn ( 1 ≤ ti ≤ 1000 ) ti denote size i - th ball print ` ` yes '' ( without quote ) limak choose three ball distinct size two differ 2 . otherwise print ` ` '' ( without quote ) first sample 4 ball limak able choose three satisfy rule must must choose ball size 18 16 17 . second sample way give gift three friends without break rule third sample even one way choose ball :,['implementation'],900.0
643/A,bear limak n color ball arrange one long row ball number 1 n leave right n possible color also number 1 n. i - th ball color ti a fix interval ( set consecutive elements ) ball define a dominant color 's a color occur biggest number time interval case a tie color one smallest number ( index ) choose dominant non - empty intervals total color task count number intervals color dominant first line input contain a single integer n ( 1 ≤ n ≤ 5000 ) — number ball second line contain n integers t1 t2 ... tn ( 1 ≤ ti ≤ n ) ti color i - th ball print n integers i - th equal number intervals i a dominant color first sample color 2 dominant three intervals : 7 intervals color 1 dominant,['implementation'],1500.0
641/C,little artem fond dance dance artem like rueda — <unknown> dance dance pair boys girls form a circle dance together detail n pair boys girls stand a circle initially boy number 1 dance a girl number 1 boy number 2 dance a girl number 2 girls number clockwise order dance different move announce pair perform move perform move boys move along circle girls always stay initial position purpose problem consider two different type move : task determine final position boy first line input contain two integers n q ( 2 ≤ n ≤ 1 000 000 1 ≤ q ≤ 2 000 000 ) — number couple rueda number command perform respectively 's guarantee n even next q line contain descriptions command command type integer 1 2 first command first type give x ( - n ≤ x ≤ n ) 0 ≤ x ≤ n mean boys move x girls clockwise direction - x mean boys move x position counter - clockwise direction input command second type output n integers i - th equal index boy i - th girl dance perform q move,['implementation'],1800.0
641/B,little artem like electronics spend lot time make different <unknown> look <unknown> nearest electronics store new control element deliver store recently artem immediately buy element store information matrix integers size n × m. n + m input element i.e row column get signal signal come input correspond row row cyclically shift leave first element row become last element second element become first signal come input correspond column column shift cyclically top first element column become last element second element become first row number integers 1 n top bottom columns number integers 1 m leave right artem want carefully study element use purpose go set experiment consist q turn turn either send signal input check number store position matrix artem complete experiment write result lose chip ! help artem find initial matrix match experiment result guarantee experiment data consistent mean least one valid matrix exist first line input contain three integers n m q ( 1 ≤ n m ≤ 100 1 ≤ q ≤ 10 000 ) — dimension matrix number turn experiment respectively next q line contain turn descriptions one per line description start integer ti ( 1 ≤ ti ≤ 3 ) define type operation operation first second type integer ri ( 1 ≤ ri ≤ n ) ci ( 1 ≤ ci ≤ m ) follow operations third type three integers ri ci xi ( 1 ≤ ri ≤ n 1 ≤ ci ≤ m - 109 ≤ xi ≤ 109 ) give operation first type ( ti = 1 ) mean signal come input correspond row ri shift cyclically operation second type ( ti = 2 ) mean column ci shift cyclically finally operation third type mean moment time cell locate row ri column ci store value xi print description valid initial matrix n line contain m integers output integers exceed 109 absolute value multiple valid solutions output,['implementation'],1400.0
641/A,little artem find a grasshopper bring house construct a jump area area look like a strip cells 1 × n. cell contain direction next jump length jump grasshopper start first cell follow instructions write cells grasshopper stop immediately jump strip artem want find ever happen first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — length strip next line contain a string length n consist character ` ` < ` ` ` ` > '' provide direction jump correspond cell next line contain n integers di ( 1 ≤ di ≤ 109 ) — length jump i - th cell print ` ` infinite '' ( without quote ) grasshopper continue jump forever otherwise print ` ` finite '' ( without quote ) first sample grasshopper start first cell jump right next cell second cell need jump two cells leave jump strip second sample grasshopper path 1 - 3 - 2 - 3 - 2 - 3 path infinite,['implementation'],1000.0
639/A,limak a little polar bear love connect bear via social network n friends relation i - th describe a unique integer ti bigger value better friendship two friends value ti spring start winter sleep bear limak wake log friends still sleep thus none online ( maybe ) appear online next hours one a time system display friends online screen space display k friends k friends online system display k best — biggest ti task handle query two type : able help limak answer query second type ? first line contain three integers n k q ( 1 ≤ n q ≤ 150 000 1 ≤ k ≤ min ( 6 n ) ) — number friends maximum number display online friends number query respectively second line contain n integers t1 t2 ... tn ( 1 ≤ ti ≤ 109 ) ti describe good limak 's relation i - th friend i - th follow q line contain two integers typei idi ( 1 ≤ typei ≤ 2 1 ≤ idi ≤ n ) — i - th query typei = 1 a friend idi become online typei = 2 check whether a friend idi display 's guarantee two query first type idi <unknown> one friend ca n't become online twice also 's guarantee least one query second type ( typei = 2 ) output wo n't empty query second type print one line answer — ` ` yes '' ( without quote ) give friend display ` ` '' ( without quote ) otherwise first sample limak 4 friends sleep initially first system display nobody nobody online follow 8 query :,['implementation'],1200.0
637/C,"a new year special offer ` ` sudislavl bar '' offer n promo cod promo code consist exactly six digits give right one free <unknown> bar ` ` mosquito shelter '' course promocodes differ ` ` mosquito shelter '' open 9 party sudislavl usually begin early 6 many problems may arise type a promotional code without errors necessary calculate maximum k promotional code could uniquely identify type k errors , k = 0 mean promotional cod must enter exactly a mistake problem consider enter wrong number example value ` ` <unknown> '' contain two errors relative promocode ` ` 123456 '' regardless number errors enter value consist exactly six digits first line output contain number n ( 1 ≤ n ≤ 1000 ) — number promocodes next n line contain a single promocode consist exactly 6 digits guarantee promocodes distinct promocodes start digit ` ` 0 '' print maximum k ( naturally exceed length promocode ) promocode uniquely identify type k mistake first sample k < 3 a bar customer type value ` ` <unknown> '' impossible define promocode exactly correspond",['implementation'],1400.0
637/A,celebrate <unknown> students one <unknown> berland state university decide conduct a vote best photo publish photos social network agree rule choose a winner : photo get like win multiple photoes get like winner photo get number first help guy determine winner photo record like first line input contain a single integer n ( 1 ≤ n ≤ 1000 ) — total like publish photoes second line contain n positive integers a1 a2 ... ( 1 ≤ ai ≤ 1 000 000 ) ai identifier photo get i - th like print identifier photo elections first test sample photo i d 1 get two like ( first fifth ) photo i d 2 get two like ( third fourth ) photo i d 3 get one like ( second ) thus winner photo identifier 2 get :,['implementation'],1000.0
635/A,paul orchestra string section arrange r × c rectangular grid fill violinists exception n violists paul really like violas would like take a picture include least k paul take a picture axis - parallel rectangle orchestra count number possible picture paul take two picture consider different coordinate correspond rectangles different first line input contain four space - separated integers r c n k ( 1 ≤ r c n ≤ 10 1 ≤ k ≤ n ) — number row columns string section total number violas minimum number violas paul would like photograph respectively next n line contain two integers xi yi ( 1 ≤ xi ≤ r 1 ≤ yi ≤ c ) : position i - th <unknown> guarantee location appear input print a single integer — number photograph paul take include least k violas use ' * ' denote violinists ' # ' denote violists first sample orchestra look follow second sample orchestra look follow third sample orchestra look second sample,['implementation'],1100.0
474/B,lunch time mole friend marmot prepare a nice game lunch marmot bring mole n order pile worm i - th pile contain ai worm label worm consecutive integers : worm first pile label number 1 a1 worm second pile label number a1 + 1 a1 + a2 see example a better understand mole ca n't eat worm ( marmot bring a lot ) know mole blind marmot tell label best juicy worm marmot give mole a worm mole say correctly pile worm contain poor mole ask help juicy worm say marmot tell mole correct answer first line contain a single integer n ( 1 ≤ n ≤ 105 ) number pile second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 103 a1 + a2 + ... + ≤ 106 ) ai number worm i - th pile third line contain single integer m ( 1 ≤ m ≤ 105 ) number juicy worm say marmot fourth line contain m integers q1 q2 ... <unknown> ( 1 ≤ qi ≤ a1 + a2 + ... + ) label juicy worm print m line standard output i - th line contain integer represent number pile worm label number qi sample input :,['implementation'],1200.0
622/B,give current time 24 - hour format hh : mm find print time a minutes note find time a minutes see examples clarify problem statement read 24 - hour format https : //en.wikipedia.org / <unknown> - <unknown> first line contain current time format hh : mm ( 0 ≤ hh < 24 0 ≤ mm < 60 ) hours minutes give two digits ( hours minutes less 10 give lead zero ) second line contain integer a ( 0 ≤ a ≤ 104 ) — number minutes pass line contain time a minutes format describe input note print exactly two digits hours minutes ( add lead zero number need ) see examples check input / output format,['implementation'],900.0
625/C,people many crazy things stand a crowd dance learn <unknown> rule russian language try become <unknown> competitive programmers others collect funny math object <unknown> among collectors right want get one k - special table case forget table n × n call k - special follow three condition satisfy : goal help alice find least one k - special table size n × n. row columns number 1 n row number top bottom columns number leave right first line input contain two integers n k ( 1 ≤ n ≤ 500 1 ≤ k ≤ n ) — size table alice look column maximum possible sum first print sum integers k - th column require table next n line contain description table : first line contain n elements first row second line contain n elements second row multiple suitable table allow print,['implementation'],1300.0
634/A,"a remote island chain contain n islands label 1 n. bidirectional bridge connect islands form a simple cycle — a bridge connect islands 1 2 islands 2 3 , additionally a bridge connect islands n 1 . center island contain identical pedestal one islands a <unknown> uniquely color statue currently hold pedestal remain island hold empty pedestal islanders want rearrange statues a new order , repeat follow process : first choose island directly adjacent island contain empty pedestal , <unknown> carry statue island across <unknown> bridge place empty pedestal determine possible islanders arrange statues desire order first line contain a single integer n ( 2 ≤ n ≤ 200 000 ) — total number islands second line contain n space - separated integers ai ( 0 ≤ ai ≤ n - 1 ) — statue currently place i - th island ai = 0 island statue guarantee ai distinct third line contain n space - separated integers bi ( 0 ≤ bi ≤ n - 1 ) — desire statues ith island , bi = 0 indicate island desire statue guarantee bi distinct print ` ` yes '' ( without quote ) rearrangement do exist network ` ` '' otherwise first sample islanders first move statue 1 island 1 island 2 move statue 2 island 3 island 1 finally move statue 1 island 2 island 3 . second sample islanders simply move statue 1 island 1 island 2 . third sample sequence movements result desire position",['implementation'],1300.0
631/B,kris work a large company ` ` <unknown> <unknown> '' a best engineer company assign a task develop a printer able print horizontal vertical strip first prototype already build kris want test want implement program check result print printer work a rectangular sheet paper size n × m. consider list a table consist n row m columns row number top bottom integers 1 n columns number leave right integers 1 m. initially cells paint color 0 . program support two operations : operation i a cell already paint color cell also change ai program print result table k operation first line input contain three integers n m k ( 1 ≤ n m ≤ 5000 n·m ≤ 100 000 1 ≤ k ≤ 100 000 ) — dimension sheet number operations respectively next k line contain description exactly one query : print n line contain m integers — result table operations apply figure show three operations first sample step step cells paint correspond step mark gray,['implementation'],1200.0
590/A,a schoolboy name vasya love read book program mathematics recently read <unknown> article describe method median smooth ( median filter ) many applications science engineer vasya like idea method much decide try practice apply <unknown> variant median smooth sequence number a1 a2 ... result a new sequence b1 b2 ... bn obtain follow algorithm : median a set three number number go second place three number write non - decreasing order example median set 5 1 2 number 2 median set 1 0 1 equal 1 . order make task easier vasya decide apply method sequence consist zero ones make procedure vasya look result sequence think : i apply algorithm apply next result ? vasya try a couple examples find number median smooth algorithm applications sequence stop change say sequence stable change median smooth apply vasya wonder whether sequence always eventually become stable ask write a program give a sequence zero ones determine whether ever become stable moreover ever become stable determine look like many time one need apply median smooth algorithm initial sequence order obtain a stable one first input line input contain a single integer n ( 3 ≤ n ≤ 500 000 ) — length initial sequence next line contain n integers a1 a2 ... ( ai = 0 ai = 1 ) give initial sequence sequence never become stable print a single number - 1 . otherwise first print a single integer — minimum number time one need apply median smooth algorithm initial sequence become stable second line print n number separate a space — result sequence second sample <unknown> occur two step : sequence <unknown> obviously stable,['implementation'],1700.0
586/B,a little boy laurenty play favourite game <unknown> quite a hungry boy want make sausage cheese <unknown> first need buy a sausage cheese town laurenty live large house locate two row n house row laurenty live last house second row shop town place first house first row first second row separate main avenue city adjacent house one row separate streets crosswalk a street avenue traffic light order cross street need press a button traffic light wait a green light cross street different traffic light different wait time traffic light crosswalk j - th house i - th row ( j + 1 ) -th house row wait time equal aij ( 1 ≤ i ≤ 2 1 ≤ j ≤ n - 1 ) traffic light cross j - th house one row j - th house another row wait time equal bj ( 1 ≤ j ≤ n ) city n't cross boy want get store buy products go back main avenue city wide enough boy want cross exactly way store exactly way back home boy would get bore walk way want way home different way store least one cross help laurenty determine minimum total time need wait crossroads first line input contain integer n ( 2 ≤ n ≤ 50 ) — number house row next two line contain n - 1 space - separated integer — value aij ( 1 ≤ aij ≤ 100 ) last line contain n space - separated integers bj ( 1 ≤ bj ≤ 100 ) print a single integer — least total time laurenty need wait crossroads give cross avenue way store way back home first sample show figure second sample laurenty 's path look follow : last sample laurenty visit cross answer 4,['implementation'],1300.0
586/A,alena successfully pass entrance exams university look forward start study one two - hour lesson russian university traditionally call a pair last two academic hours ( academic hour equal 45 minutes ) university work a way every day hold exactly n lessons depend schedule a particular group students a give day pair may actually contain class may empty ( pair call break ) official website university already publish schedule tomorrow alena 's group thus n pair know a class time alena 's house far university break n't always go home alena time go home break consist least two free pair a row otherwise wait next pair university course alena want sleepy pair sleep long possible come first pair present schedule similarly pair alena immediately go home alena appreciate time spend home always go home possible return university begin next pair help alena determine many pair stay university note pair alena may university wait upcoming pair first line input contain a positive integer n ( 1 ≤ n ≤ 100 ) — number lessons university second line contain n number ai ( 0 ≤ ai ≤ 1 ) number ai equal 0 alena n't i - th pair otherwise equal 1 . number a1 a2 ... separate space print a single number — number pair alena stay university first sample alena stay university second fifth pair inclusive third pair university wait next pair last sample alena n't a single pair spend time home,['implementation'],900.0
510/A,fox ciel start learn program first task draw a fox ! however turn hard a beginner decide draw a snake instead a snake a pattern a n m table denote c - th cell r - th row ( r c ) tail snake locate ( 1 1 ) 's body extend ( 1 m ) go 2 row ( 3 m ) go leave ( 3 1 ) task draw snake fox ciel : empty cells represent dot character ( ' . ' ) snake cells fill number sign ( ' # ' ) consider sample test order understand snake pattern line contain two integers : n m ( 3 ≤ n m ≤ 50 ) n odd number output n line line contain a string consist m character output space,['implementation'],800.0
509/A,n × n table a define follow : condition define value table give a number n. need determine maximum value n × n table define rule line input contain a positive integer n ( 1 ≤ n ≤ 10 ) — number row columns table print a single line contain a positive integer m — maximum value table second test row table look follow :,['implementation'],800.0
505/A,mr . kitayuta <unknown> give a string s consist lowercase english letter ask insert exactly one lowercase english letter s make a palindrome a palindrome a string read forward backward example ` ` <unknown> '' ` ` testset '' ` ` a '' palindromes ` ` test '' ` ` kitayuta '' choose lowercase english letter insert position s possibly begin end s. insert a letter even give string already a palindrome possible insert one lowercase english letter s result string a palindrome print string <unknown> otherwise print ` ` na '' ( without quote case - sensitive ) case one palindrome obtain allow print line input contain a string s ( 1 ≤ |s| ≤ 10 ) character s a lowercase english letter possible turn s a palindrome insert one lowercase english letter print result string a single line otherwise print ` ` na '' ( without quote case - sensitive ) case one solution accept first sample insert ' r ' end ` ` <unknown> '' obtain a palindrome ` ` <unknown> '' second sample one solution example ` ` eve '' also accept third sample possible turn ` ` kitayuta '' a palindrome insert one letter,['implementation'],1100.0
501/E,misha array n integers index integers 1 n. let 's define palindrome degree array a number index pair ( l r ) ( 1 ≤ l ≤ r ≤ n ) elements l - th r - th one inclusive rearrange a way whole array a palindrome word pair ( l r ) meet condition rearrange number position l r inclusive ( allow rearrange number ) 1 ≤ i ≤ n follow condition hold : a [ i ] = a [ n - i + 1 ] task find palindrome degree misha 's array first line contain integer n ( 1 ≤ n ≤ 105 ) second line contain n positive integers a [ i ] ( 1 ≤ a [ i ] ≤ n ) separate space — elements misha 's array a single line print answer problem first sample test possible pair ( l r ) meet condition third sample test follow pair ( 1 3 ) ( 1 4 ) ( 1 5 ) ( 2 5 ) meet condition,['implementation'],2500.0
501/A,"misha vasya participate a codeforces contest unfortunately solve one problem though successfully submit first attempt misha solve problem cost a point vasya solve problem cost b point besides misha submit problem c minutes contest start vasya submit problem d minutes contest start know codeforces cost a problem reduce a round continue , submit a problem cost p point t minutes contest start get point misha vasya argument try find get point help find truth first line contain four integers a b c d ( 250 ≤ a b ≤ <unknown> 0 ≤ c d ≤ 180 ) guarantee number a b divisible 250 ( like real codeforces round ) output a single line : ` ` misha '' ( without quote ) misha get point vasya ` ` vasya '' ( without quote ) vasya get point misha ` ` tie '' ( without quote ) get number point",['implementation'],900.0
500/A,"new year come line world ! world n cells number integers 1 n a 1 × n board people live cells however hard move distinct cells difficulty escape cell people want meet people live cells , user <unknown> make a transportation system move cells celebrate new year first think n - 1 positive integers a1 a2 ... - 1 . every integer i 1 ≤ i ≤ n - 1 condition 1 ≤ ai ≤ n - i hold next make n - 1 portals number integers 1 n - 1 . i - th ( 1 ≤ i ≤ n - 1 ) portal connect cell i cell ( i + ai ) one travel cell i cell ( i + ai ) use i - th portal unfortunately one use portal backwards mean one move cell ( i + ai ) cell i use i - th portal easy see condition 1 ≤ ai ≤ n - i one ca n't leave line world use portals currently i stand cell 1 i want go cell t. however i n't know whether possible go please determine whether i go cell t use <unknown> transportation system first line contain two space - separated integers n ( 3 ≤ n ≤ 3 × 104 ) t ( 2 ≤ t ≤ n ) — number cells index cell i want go second line contain n - 1 space - separated integers a1 a2 ... - 1 ( 1 ≤ ai ≤ n - i ) guarantee use give transportation system one leave line world i go cell t use transportation system print ` ` yes '' otherwise print ` ` '' first sample visit cells : 1 2 4 ; successfully visit cell 4 . second sample possible cells visit : 1 2 4 6 7 8 ; ca n't visit cell 5 want visit",['implementation'],1000.0
626/A,"calvin robot lie infinite rectangular grid calvin 's source code contain a list n command either ' u ' ' r ' 'd ' ' l ' — instructions move a single square right , leave respectively many ways calvin execute a non - empty contiguous substrings command return square start ? two substrings consider different different start end indices first line input contain a single positive integer n ( 1 ≤ n ≤ 200 ) — number command next line contain n character either ' u ' ' r ' 'd ' ' l ' — calvin 's source code print a single integer — number contiguous substrings calvin execute return start square first case entire source code work well ` ` rl '' substring second third character note third case substring ` ` <unknown> '' appear three time therefore count three time total result",['implementation'],1000.0
499/B,"a new professor graph theory speak quickly come follow plan keep lecture make note know two languages professor give lecture first one word languages consist lowercase english character language consist several word language word distinct i.e spell differently moreover word languages a one - to - one correspondence , word language exist exactly one word language mean write every word professor say either first language second language course lecture write word language word shorter case equal lengths correspond word prefer word first language give text lecture professor go read find lecture record note first line contain two integers n m ( 1 ≤ n ≤ 3000 1 ≤ m ≤ 3000 ) — number word professor 's lecture number word languages follow m line contain word i - th line contain two string ai bi mean word ai belong first language word bi belong second language two word mean guarantee word occur languages word occur language exactly next line contain n space - separated string c1 c2 ... cn — text lecture guarantee string ci belong set string { a1 a2 ... } string input non - empty consist 10 lowercase english letter output exactly n word : record lecture notebook output word lecture order input",['implementation'],1000.0
496/B,get a box a combination lock lock a display show n digits two button box button change digits display quickly discover first button add 1 digits ( digits 9 become digits 0 ) second button shift digits display one position right ( last digit become first one ) example display currently show number <unknown> push first button display show <unknown> push second button display show <unknown> . know lock open display show smallest possible number obtain push button order lead zero ignore compare number task find desire number first line contain a single integer n ( 1 ≤ n ≤ 1000 ) — number digits display second line contain n digits — initial state display print a single line contain n digits — desire state display contain smallest possible number,['implementation'],1500.0
495/A,malek live apartment block 100 floor number 0 99 . apartment elevator a digital counter show floor elevator currently elevator show digit a number 7 light stick turn picture show elevator show digit one day malek want go floor 88 floor 0 use elevator notice counter show number 89 instead 88 . elevator start move number counter change <unknown> . a little think malek come conclusion one explanation : one stick counter break later day malek think break stick suddenly come follow problem suppose digital counter show number n. malek call integer x ( 0 ≤ x ≤ 99 ) good 's possible digital counter suppose show x ( possibly none ) break stick 's show n instead malek want know number good integers a specific n. must write a program calculate number please note counter always show two digits line input contain exactly two digits represent number n ( 0 ≤ n ≤ 99 ) note n may a lead zero line output print number good integers first sample counter may suppose show 88 89 . second sample good integers 00 08 80 88 . third sample good integers <unknown> 08 <unknown> 33 38 39 <unknown> 78 <unknown> <unknown> 88 89 93 <unknown> 99,['implementation'],1100.0
493/B,vasya become interest wrestle wrestle wrestlers use techniques award point judge wrestler get point win number point wrestlers equal wrestler whose sequence point lexicographically greater win sequence award point coincide wrestler perform last technique win task determine wrestler first line contain number n — number techniques wrestlers use ( 1 ≤ n ≤ 2·105 ) follow n line contain integer number ai ( |ai| ≤ 109 ai ≠ 0 ) ai positive mean first wrestler perform technique award ai point ai negative mean second wrestler perform technique award ( - ai ) point techniques give chronological order first wrestler win print string ` ` first '' otherwise print ` ` second '' sequence x = x1x2 ... x|x| lexicographically larger sequence y = y1y2 ... y|y| either |x| > |y| x1 = y1 x2 = y2 ... x|y| = y|y| number r ( r < |x| r < |y| ) x1 = y1 x2 = y2 ... xr = yr xr + 1 > yr + 1 . use notation |a| denote length sequence a,['implementation'],1400.0
493/A,vasya start watch football game learn foul players receive yellow card foul receive red card a player receive second yellow card automatically receive a red card vasya watch a record football match make note foul would give a card help vasya determine moments time players would give red card vasya judge player vasya want know first moment time would receive a red card vasya first line contain name team play home second line contain name team play away line empty lengths line exceed 20 . line contain large english letter name team distinct next follow number n ( 1 ≤ n ≤ 90 ) — number foul follow n line contain information a foul follow form : players different team number players within one team distinct number foul go chronologically two foul happen minute event a player receive first red card a chronological order print a string contain follow information : player receive a card need print anything possible case program print anything output ( red card ),['implementation'],1300.0
519/A,a b prepare program contest train logical think solve problems better a b decide play chess game a wonder whose position stronger chess piece know weight : player 's weight equal sum weight piece board a n't like count ask help determine player larger position weight input contain eight line eight character — board 's description white piece board mark uppercase letter black piece mark lowercase letter white piece denote follow : queen represent ' q ' rook — ' r ' bishop — ' b ' knight — ' n ' pawn — ' p ' king — ' k ' black piece denote ' q ' ' r ' ' b ' ' n ' ' p ' ' k ' respectively empty square board mark ' . ' ( a dot ) guarantee give chess position achieve a real game specifically arbitrary ( possibly zero ) number piece type king may attack print ` ` white '' ( without quote ) weight position white piece weight position black piece print ` ` black '' weight black piece weight white piece print ` ` draw '' weight white black piece equal first test sample weight position white piece equal 9 weight position black piece equal 5 . second test sample weight position black white piece equal 39 . third test sample weight position white piece equal 9 weight position black piece equal 16,['implementation'],900.0
492/A,"vanya get n cub decide build a pyramid vanya want build pyramid follow : top level pyramid must consist 1 cube second level must consist 1 + 2 = 3 cub third level must 1 + 2 + 3 = 6 cub , thus i - th level pyramid must 1 + 2 + ... + ( i - 1 ) + i cub vanya want know maximum height pyramid make use give cub first line contain integer n ( 1 ≤ n ≤ 104 ) — number cub give vanya print maximum possible height pyramid single line illustration second sample :",['implementation'],800.0
487/A,a monster attack cyberland ! master yang a <unknown> go beat monster yang monster 3 attribute : <unknown> ( hp ) offensive power ( atk ) <unknown> power ( def ) battle every second monster 's hp decrease max ( 0 atky - defm ) yang 's hp decrease max ( 0 atkm - defy ) index y denote master yang index m denote monster decrease happen simultaneously monster 's hp ≤ 0 time master yang 's hp > 0 master yang win master yang buy attribute magic shop cyberland : h bitcoins per hp a bitcoins per atk d bitcoins per def master yang want know minimum number bitcoins spend order win first line contain three integers <unknown> atky defy separate a space denote initial hp atk def master yang second line contain three integers <unknown> atkm defm separate a space denote hp atk def monster third line contain three integers h a d separate a space denote price 1 hp 1 atk 1 def number input integer lie 1 100 inclusively output line contain integer denote minimum bitcoins master yang spend order win first sample price atk def extremely high master yang buy 99 hp beat monster 1 hp leave second sample master yang strong enough beat monster n't need buy anything,['implementation'],1800.0
478/A,five people play a game call ` ` <unknown> '' person give non - zero number coin b initial bet players make bet b coin follow operation repeat several time : a coin pass one player player task write a program give number coin player end game determine size b initial bet find outcome game obtain positive number coin b initial bet input consist a single line contain five integers c1 c2 c3 c4 c5 — number coin first second third fourth fifth players respectively end game ( 0 ≤ c1 c2 c3 c4 c5 ≤ 100 ) print line contain a single positive integer b — number coin initial bet player value b print value ` ` -1 '' ( quote clarity ) first sample follow sequence operations possible :,['implementation'],1100.0
475/B,imagine a city n horizontal streets cross m vertical streets form ( n - 1 ) × ( m - 1 ) grid order increase traffic flow mayor city decide make street one way mean horizontal street traffic move west east east west also traffic move north south south north vertical street possible enter a horizontal street a vertical street vice versa intersection mayor receive street direction pattern task check whether possible reach junction junction propose street direction pattern first line input contain two integers n m ( 2 ≤ n m ≤ 20 ) denote number horizontal streets number vertical streets second line contain a string length n make character ' < ' ' > ' denote direction horizontal street i - th character equal ' < ' street direct east west otherwise street direct west east streets list order north south third line contain a string length m make character ' ^ ' ' v ' denote direction vertical street i - th character equal ' ^ ' street direct south north otherwise street direct north south streets list order west east give pattern meet mayor 's criteria print a single line contain ` ` yes '' otherwise print a single line contain ` ` '' figure show street directions second sample test case,['implementation'],1400.0
475/A,final round <unknown> program contest hold <unknown> participants carry around a yellow bus bus 34 passenger seat : 4 seat last row 3 seat remain row event coordinator a list k participants pick <unknown> a participant get bus sit last row empty seat one empty seat row take leftmost one order keep track people bus event coordinator need a figure show seat go take k participants task draw figure represent occupy seat line input contain integer k ( 0 ≤ k ≤ 34 ) denote number participants print figure a bus k passengers describe sample test character ' # ' denote empty seat ' o ' denote a take seat 'd ' bus driver character output purpose <unknown> figure strictly follow sample test case output format print exactly six line output extra space character,['implementation'],1100.0
496/C,"give n × m rectangular table consist lower case english letter one operation completely remove one column table remain part combine form a new table example remove second column table obtain table : a table call good row order top bottom lexicographically i.e row lexicographically larger follow one determine minimum number operations remove a column need make a give table good first line contain two integers — n m ( 1 ≤ n m ≤ 100 ) next n line contain m small english letter — character table print a single number — minimum number columns need remove order make table good first sample table already good second sample may remove first third column third sample remove columns ( note table row empty consider good definition ) let string s t equal length , s lexicographically larger t equal character follow largest common prefix s t ( prefix may empty ) s <unknown> larger correspond character t",['implementation'],1500.0
629/A,"door 's family go celebrate famil doors 's birthday party love famil door plan make birthday cake weird ! cake a n × n square consist equal square side length 1 . square either empty consist a single chocolate buy cake randomly start put chocolates cake value famil door 's happiness equal number pair cells chocolates row column cake famil doors 's family wonder amount happiness famil go ? please note pair count two different cells ca n't share row column first line input give a single integer n ( 1 ≤ n ≤ 100 ) — length side cake follow n line contain n character empty cells denote ' ' cells contain chocolates denote ' c ' print value famil door 's happiness i.e number pair chocolate piece share row column number row top bottom columns leave right , piece share row first sample :",['implementation'],800.0
784/F,develop a new feature website sell <unknown> ticket : able sort ticket price ! already <unknown> ticket ' price 's last step do ... give array integers sort non - descending order input consist a single line space - separated integers first number n ( 1 ≤ n ≤ 10 ) — size array follow n number elements array ( 1 ≤ ai ≤ 100 ) output space - separated elements sort array remember a important feature make sure customers appreciate !,['implementation'],1900.0
645/A,bessie cow best friend elsie receive a slide puzzle pi day puzzle consist a 2 × 2 grid three tile label ' a ' ' b ' ' c ' three tile sit top grid leave one grid cell empty make a move bessie elsie slide a tile adjacent empty cell empty cell show : order determine truly best friends life ( bffls ) bessie elsie would like know exist a sequence move take puzzle configuration ( move perform puzzle ) two puzzle consider configuration tile top grid cell puzzle since tile label letter rotations <unknown> allow first two line input consist a 2 × 2 grid describe initial configuration bessie 's puzzle next two line contain a 2 × 2 grid describe initial configuration elsie 's puzzle position tile label ' a ' ' b ' ' c ' empty cell label ' x ' 's guarantee puzzle contain exactly one tile letter exactly one empty position output ` ` yes '' ( without quote ) puzzle reach configuration ( bessie elsie truly bffls ) otherwise print ` ` '' ( without quote ) solution first sample describe image bessie need slide ' a ' tile second sample two puzzle never configuration perhaps bessie elsie mean friends .,['implementation'],1200.0
474/A,good friend mole try code a big message type unusual keyboard character arrange follow way : unfortunately mole blind sometimes problem put hand accurately accidentally move hand one position leave right mean press a button want one neighbor button ( leave right specify input ) a sequence character type want find original message first line input contain one letter describe direction shift ( ' l ' ' r ' respectively leave right ) second line contain a sequence character write mole size sequence 100 . sequence contain symbols appear mole 's keyboard n't contain space space mole 's keyboard guarantee even though mole hand move still press button keyboard hit outside print a line contain original message,['implementation'],900.0
544/A,give a string q. a sequence k string s1 s2 ... sk call beautiful concatenation string string q ( formally s1 + s2 + ... + sk = q ) first character string distinct find beautiful sequence string determine beautiful sequence n't exist first line contain a positive integer k ( 1 ≤ k ≤ 26 ) — number string a beautiful sequence second line contain string q consist lowercase latin letter length string within range 1 100 inclusive sequence n't exist print a single line ` ` '' ( without quote ) otherwise print first line ` ` yes '' ( without quote ) next k line print beautiful sequence string s1 s2 ... sk multiple possible answer print second sample two possible answer : { ` ` <unknown> '' ` ` s '' } { ` ` aaa '' ` ` <unknown> '' },['implementation'],1100.0
469/B,little x little z good friends always chat online schedule little z fix schedule always online moment time a1 b1 a2 b2 ... ap <unknown> ( border inclusive ) schedule little x quite strange depend time get get time 0 online moment time c1 d1 c2 d2 ... <unknown> <unknown> ( border inclusive ) get time t segment shift t. become [ ci + t di + t ] ( i ) a moment time little x little z online <unknown> chat online <unknown> know little x get integer moment time l r ( border inclusive ) also know little x want get moment time suitable chat little z ( must least one common moment time schedule ) many integer moments time segment [ l r ] suit ? first line contain four space - separated integers p q l r ( 1 ≤ p q ≤ 50 ; 0 ≤ l ≤ r ≤ 1000 ) next p line contain two space - separated integers ai bi ( 0 ≤ ai < bi ≤ 1000 ) next q line contain two space - separated integers cj dj ( 0 ≤ cj < dj ≤ 1000 ) 's guarantee bi < ai + 1 dj < cj + 1 valid i j. output a single integer — number moments time segment [ l r ] suit online <unknown>,['implementation'],1300.0
467/B,help george alex move <unknown> go help friend fedor play a new computer game « call soldier 3 » game ( m + 1 ) players n type soldier total players « call soldier 3 » number form 1 ( m + 1 ) type soldier number 0 n - 1 . player army army i - th player describe non - negative integer xi consider binary representation xi : j - th bite number xi equal one army i - th player soldier j - th type fedor ( m + 1 ) -th player game assume two players become friends armies differ k type soldier ( word binary representations correspond number differ k bits ) help fedor count many players become friends first line contain three integers n m k ( 1 ≤ k ≤ n ≤ 20 ; 1 ≤ m ≤ 1000 ) i - th next ( m + 1 ) line contain a single integer xi ( 1 ≤ xi ≤ 2n - 1 ) describe i - th player 's army remind fedor ( m + 1 ) -th player print a single integer — number fedor 's potential friends,['implementation'],1100.0
491/A,hike club ` ` hill '' return a walk try remember hill ' ve walk know n stop different integer heights 1 n kilometers ( inclusive ) sea level first day ' ve travel first stop second stop second day ' ve travel second third last day ' ve travel stop n - 1 stop n successfully finish expedition try find heights stop locate entry a travel journal specify many days travel hill many days walk hill help suggest possible stop heights satisfy number travel journal first line integer non - negative number a denote number days climb hill second line contain integer non - negative number b — number days walk hill ( a + b + 1 = n 1 ≤ n ≤ 100 000 ) output n space - separated distinct integers 1 n inclusive denote possible heights stop order visit,['implementation'],1000.0
520/A,a word a sentence language call a pangram character alphabet language appear least <unknown> often use demonstrate <unknown> print test output <unknown> give a string consist lowercase uppercase latin letter check whether string a pangram say string contain a letter latin alphabet letter occur string uppercase lowercase first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number character string second line contain string string consist uppercase lowercase latin letter output ` ` yes '' string a pangram ` ` '' otherwise,['implementation'],800.0
523/A,"polycarp write prototype a <unknown> editor already make mind basic image transformations editor : rotate image 90 degrees clockwise flip image horizontally ( symmetry relative vertical line , right part image move leave vice versa ) zoom image sure a large number transformations express three recently stop implement three transformations monochrome image test feature ask write a code consecutively perform three action a monochrome image : first rotate image 90 degrees clockwise flip image horizontally finally zoom twice image ( double linear size ) implement feature help polycarp test editor first line contain two integers w h ( 1 ≤ w h ≤ 100 ) — width height image pixels picture give h line line contain w character — character encode color correspond pixel image line consist character ` ` . '' ` ` * '' image monochrome print <unknown> line contain 2h character — result consecutive implement three transformations describe",['implementation'],1200.0
523/B,"problem deal a real algorithm use vk social network company create high - <unknown> websites vk developers deal request statistics regularly important indicator reflect load site mean number request a certain period time t second ( example t = 60 second = 1 min t = <unknown> second = 1 day ) example value drop <unknown> show site access problem value grow may a reason analyze cause growth add servers website really need however even a natural problem count mean number query period time a challenge process amount data a huge social network 's developers use original techniques solve problems approximately effectively time let 's consider follow formal model a service work n second know number query resource moment time t ( 1 ≤ t ≤ n ) let 's formulate follow algorithm calculate mean exponential <unknown> let c real number strictly larger one thus mean variable recalculate second use number query come second make mathematical calculations prove choose value constant c correctly make value mean different real mean value ax t - t + 1 ≤ x ≤ t. advantage approach use number request current moment time n't require store history request a large time range also consider recent value weight larger weight old ones help react <unknown> change value <unknown> however use new <unknown> approach industrial program obligatory step make , test <unknown> <unknown> give test data set task compare data obtain a result work approximate algorithm real data give n value integer t real number c. also give m moments pj ( 1 ≤ j ≤ m ) interest mean value number query last t second implement two algorithms first one calculate require value definition i.e formula second algorithm calculate mean value describe print value calculate relative error second algorithm formula approx approximate value obtain second algorithm real exact value obtain first algorithm first line contain integer n ( 1 ≤ n ≤ 2·105 ) integer t ( 1 ≤ t ≤ n ) real number c ( 1 < c ≤ 100 ) — time range resource work length time range need mean number request coefficient c work approximate algorithm number c give exactly six digits decimal point next line contain n integers ( 1 ≤ ≤ 106 ) — number query service moment time next line contain integer m ( 1 ≤ m ≤ n ) — number moments time interest mean number query last t second next line contain m integers pj ( t ≤ pj ≤ n ) represent another moment time need statistics moments pj strictly increase print m line j - th line must contain three number real approx error : number print compare correct number relative absolute error 10 - 4 . recommend print number least five digits decimal point",['implementation'],1500.0
585/A,"gennady one best child <unknown> berland today n children get appointment line front office children love cry loudly <unknown> dentist enumerate children integers 1 n order go line every child associate value <unknown> pi children take turn one another come office ; time child first line go doctor gennady treat teeth i - th child child cry volume vi confidence first child line reduce amount vi second one — value vi - 1 , children queue vi - th child almost hear cry confidence remain unchanged point time confidence j - th child less zero begin cry volume dj leave line run towards exit without go doctor 's office confidence children j - th one line reduce amount dj events occur immediately one order cry may lead cry cause a chain reaction hallway quiet child first line go doctor 's office help gennady dentist determine number kid whose teeth cure print number chronological order first line input contain a positive integer n ( 1 ≤ n ≤ 4000 ) — number kid line next n line contain three integers vi di pi ( 1 ≤ vi di pi ≤ 106 ) — volume cry doctor 's office volume cry hall confidence i - th child first line print number k — number children whose teeth gennady cure second line print k integers — number children make end line increase order first example gennady first treat teeth first child cry volume 4 . confidences remain children get equal - 2 1 3 1 respectively thus second child also cry volume 1 run exit confidence remain children equal 0 2 0 . third child go office cry volume 5 . children wo n't bear a <unknown> cry run exit second sample first first child go office cry volume 4 . confidence remain children equal 5 - 1 6 8 . thus third child cry volume 1 run exit confidence remain children equal 5 5 7 . second child go office cry volume 5 . confidences remain children equal 0 3 . fourth child go office cry volume 2 . confidence fifth child 1 go office last",['implementation'],1800.0
583/A,"city x consist n vertical n horizontal infinite roads form n × n intersections roads ( vertical horizontal ) number 1 n intersections indicate number roads form sand roads long recognize date decision make asphalt , a team workers hire a schedule work make accord intersections asphalt road repair plan n2 days i - th day team arrive i - th intersection list none two roads form intersection already asphalt asphalt roads otherwise team leave intersection without anything roads accord schedule road work tell days least one road asphalt first line contain integer n ( 1 ≤ n ≤ 50 ) — number vertical horizontal roads city next n2 line contain order intersections schedule i - th contain two number hi vi ( 1 ≤ hi vi ≤ n ) separate a space mean intersection go i - th timetable intersection hi - th horizontal vi - th vertical roads guarantee intersections timetable distinct single line print number days road work progress ascend order days number start 1 . sample brigade act like :",['implementation'],1000.0
579/B,"a program contest name <unknown> 2n people want compete order attend contest people need form team exactly two people give strength possible combination two people value strengths distinct every contestant hop find a teammate team ’ s strength high possible , a contestant form a team highest strength possible choose a teammate ones will a teammate him / her formally two people a b may form a team best possible teammate ( among contestants remain <unknown> ) one determine person ’ s teammate ? 2n line input first line contain integer n ( 1 ≤ n ≤ 400 ) — number team form i - th line ( i > 1 ) contain i - 1 number ai1 ai2 ... ai ( i - 1 ) aij ( 1 ≤ aij ≤ 106 aij distinct ) denote strength a team consist person i person j ( people number start 1 ) output a line contain 2n number i - th number represent number teammate i - th person first sample contestant 1 2 <unknown> contestant 3 4 teammate contestant 1 2 3 4 2 1 4 3 respectively",['implementation'],1300.0
577/A,let 's consider a table consist n row n columns cell locate intersection i - th row j - th column contain number i × j. row columns number start 1 . give a positive integer x. task count number cells a table contain number x. single line contain number n x ( 1 ≤ n ≤ 105 1 ≤ x ≤ 109 ) — size table number look table print a single number : number time x occur table a table second sample test give occurrences number 12 mark bold,['implementation'],1000.0
470/A,crystal ball sequence <unknown> lattice define follow : n - th element number lattice point inside a <unknown> ( n + 1 ) point side formula hn = <unknown> · ( n + 1 ) + 1 . give n ; calculate n - th element sequence line input contain integer n ( 0 ≤ n ≤ 9 ) output n - th element crystal ball sequence,['implementation'],1400.0
575/D,"a big bank robbery tablecity order catch thief president call none albert – tablecity ’ s chief police albert know thief locate know move tablecity represent 1000 × 2 grid every cell represent one district district unique name <unknown> ( x y ) <unknown> x y coordinate district grid thief ’ s movement every hour thief leave district ( x y ) currently hide move one district : ( x - 1 y ) ( x + 1 y ) ( x - 1 y - 1 ) ( x - 1 y + 1 ) ( x + 1 y - 1 ) ( x + 1 y + 1 ) long exist tablecity example thief ’ s possible movements locate district ( <unknown> ) : albert enough people every hour pick two district tablecity fully investigate make sure thief locate one get catch albert promise president thief catch 2015 hours need help order achieve input problem first line output contain integer n – duration police search hours follow n line contain exactly 4 integers xi1 yi1 xi2 yi2 separate space represent 2 district ( xi1 yi1 ) ( xi2 yi2 ) get investigate i - th hour output give chronological order ( i - th line contain district investigate i - th hour ) guarantee thief catch 2015 hours regardless thief ’ s initial position movement let 's consider follow <unknown> 1 50 28 1 80 <unknown> output guarantee catch thief correct give show expect output format exist a combination initial position a movement strategy police catch thief consider follow initial position thief ’ s movement : first hour thief locate district ( 1,1 ) police officer search district ( <unknown> ) ( <unknown> ) find start second hour thief move district ( 2,2 ) police officer search district ( <unknown> ) ( <unknown> ) find since investigation police thief escape !",['implementation'],1700.0
560/B,"gerald buy two rare paint <unknown> 's auction want hang wall buy a special board attach wall place paint board board shape a1 × b1 rectangle paint shape a a2 × b2 a3 × b3 rectangles since paint paint style abstract art matter exactly rotate still one side board paint must parallel floor paint touch edge board overlap go <unknown> edge board gerald ask whether possible place paint board board buy large enough ? first line contain two space - separated number a1 b1 — side board next two line contain number a2 b2 a3 b3 — side paint number ai bi input integers fit range 1 1000 . paint place wall print ` ` yes '' ( without quote ) , print ` ` '' ( without quote ) 's place picture first test : 's third one",['implementation'],1200.0
560/A,a magic island geraldion gerald live currency system use banknotes several value problem system perfect sometimes happen <unknown> express a certain sum money set banknotes course use number banknotes value sum call unfortunate gerald wonder : minimum unfortunate sum ? first line contain number n ( 1 ≤ n ≤ 1000 ) — number value banknotes use geraldion second line contain n distinct space - separated number a1 a2 ... ( 1 ≤ ai ≤ 106 ) — value banknotes print a single line — minimum unfortunate sum unfortunate sum print - 1,['implementation'],1000.0
558/B,amr get a large array size n. amr n't like large array intend make smaller amr n't care anything array except beauty beauty array define maximum number time number occur array want choose smallest subsegment array beauty original array help amr choose smallest subsegment possible first line contain one number n ( 1 ≤ n ≤ 105 ) size array second line contain n integers ai ( 1 ≤ ai ≤ 106 ) represent elements array output two integers l r ( 1 ≤ l ≤ r ≤ n ) begin end subsegment choose respectively several possible answer may output a subsegment b array a l r array size r - l + 1 bi = al + i - 1 1 ≤ i ≤ r - l + 1,['implementation'],1300.0
558/A,amr live lala land lala land a beautiful country locate a coordinate line lala land famous apple tree grow everywhere lala land exactly n apple tree tree number i locate a position xi ai apples grow amr want collect apples apple tree amr currently stand x = 0 position begin choose whether go right leave 'll continue direction meet apple tree n't visit 'll take apples reverse direction continue walk direction meet another apple tree n't visit word amr reverse direction visit new apple tree amr stop collect apples tree n't visit direction face maximum number apples collect ? first line contain one number n ( 1 ≤ n ≤ 100 ) number apple tree lala land follow n line contain two integers xi ai ( - 105 ≤ xi ≤ 105 xi ≠ 0 1 ≤ ai ≤ 105 ) represent position i - th tree number apples 's guarantee one apple tree coordinate 's guarantee tree grow point 0 . output maximum number apples amr collect first sample test n't matter amr choose first go leave right case 'll get apples second sample test optimal solution go leave x = - 1 collect apples direction reverse amr go x = 1 collect apples direction reverse amr go final tree x = - 2 . third sample test optimal solution go right x = 1 collect apples direction reverse amr able collect anymore apples apple tree leave,['implementation'],1100.0
556/B,andrewid android a galaxy - famous detective investigate a case <unknown> make fake copy famous stolp 's gear puzzle famous rubik 's cube important components a button a line n similar gear gear n teeth contain number 0 n - 1 counter - clockwise order push a button first gear rotate clockwise second gear rotate counter - clockwise third gear rotate clockwise besides gear exactly one active tooth a gear turn a new active tooth one follow current active tooth accord direction rotation example n = 5 active tooth one contain number 0 clockwise rotation make tooth number 1 active counter - clockwise rotate make tooth number 4 active andrewid remember real puzzle follow property : push button multiple time a way end number active teeth gear first last form sequence 0 1 2 ... n - 1 . write a program determine whether give puzzle real fake first line contain integer n ( 1 ≤ n ≤ 1000 ) — number gear second line contain n digits a1 a2 ... ( 0 ≤ ai ≤ n - 1 ) — sequence active teeth : active tooth i - th gear contain number ai a single line print ` ` yes '' ( without quote ) give stolp 's gear puzzle real ` ` '' ( without quote ) otherwise first sample test push button first time sequence active teeth 2 2 1 push second time get 0 1 2,['implementation'],1100.0
555/A,andrewid android a galaxy - famous detective investigate case <unknown> exhibition <unknown> art main exhibit a construction n matryoshka dolls nest one another matryoshka dolls number 1 n. a matryoshka a smaller number nest a matryoshka a higher number two matryoshkas directly nest doll may chain nest example 1 → 2 → 4 → 5 . one second perform one two follow operations : accord modern <unknown> <unknown> matryoshka dolls display assemble a specific configuration i.e several separate chain nest matryoshkas criminal follow mysterious plan take dolls assemble a single large chain ( 1 → 2 → ... → n ) order continue investigation andrewid need know minimum time possible perform action first line contain integers n ( 1 ≤ n ≤ 105 ) k ( 1 ≤ k ≤ 105 ) — number matryoshkas matryoshka chain initial configuration next k line contain descriptions chain : i - th line first contain number mi ( 1 ≤ mi ≤ n ) mi number ai1 ai2 ... aimi — number matryoshkas chain ( matryoshka ai1 nest matryoshka ai2 nest matryoshka <unknown> till matryoshka aimi n't nest matryoshka ) guarantee m1 + m2 + ... + <unknown> = n number matryoshkas chain distinct chain number matryoshkas follow ascend order single line print minimum number second need assemble one large chain initial configuration first sample test two chain : 1 → 2 3 . one second nest first chain second one get 1 → 2 → 3 . second sample test need <unknown> three chain individual matryoshkas 2 + 1 + 1 = 4 second assemble one big chain 6 second,['implementation'],1500.0
551/B,professor gukiz n't accept string like swap letter string obtain a new one gukiz string a b c. want obtain string k swap letter a k contain many non - <unknown> substrings equal either b c possible substring string x a string form consecutive segment character x. two substrings string x overlap position i string x occupy gukiz disappoint none students manage solve problem help find one possible string k ? first line contain string a second line contain string b third line contain string c ( 1 ≤ |a| |b| |c| ≤ 105 |s| denote length string s ) three string consist lowercase english letter possible b c coincide find one possible string k describe problem statement multiple possible answer print third sample optimal solutions three non - <unknown> substrings equal either b c position 1 – 2 ( ab ) 3 – 4 ( ab ) 5 – 7 ( <unknown> ) sample exist many optimal solutions one would <unknown>,['implementation'],1800.0
551/A,"professor gukiz like program contest especially like rate students contest prepare , decide prepare a new contest total n students attend start every one positive integer rat students index 1 n. let 's denote rat i - th student ai contest end every student end positive integer position gukiz expect students take place accord rat think student take place equal particular student a rat strictly lower student b a get strictly better position b two students equal rat share position gukiz would like <unknown> result follow <unknown> help determine position end contest students everything go expect first line contain integer n ( 1 ≤ n ≤ 2000 ) number gukiz 's students second line contain n number a1 a2 ... ( 1 ≤ ai ≤ 2000 ) ai rat i - th student ( 1 ≤ i ≤ n ) a single line print position end contest n students order appear input first sample students 2 3 position first ( student higher rat ) student 1 position third since two students higher rat second sample first student one contest third sample students 2 5 share first position highest rat student 4 next third position students 1 3 last share fourth position",['implementation'],800.0
550/D,undirected graph call k - regular degrees vertices equal k. edge a connect graph call a bridge remove graph split two connect components build a connect undirected k - regular graph contain least one bridge else state graph n't exist single line input contain integer k ( 1 ≤ k ≤ 100 ) — require degree vertices regular graph print ` ` '' ( without quote ) graph n't exist otherwise print ` ` yes '' first line description suitable graph next line description make graph must start number n m — number vertices edge respectively next m line must contain two integers a b ( 1 ≤ a b ≤ n a ≠ b ) mean edge connect vertices a b. a graph n't contain multiple edge edge lead a vertex a graph must connect degrees vertices graph must equal k. least one edge graph must a bridge print edge graph order print end edge order construct graph must contain 106 vertices 106 edge ( guarantee least one graph meet requirements exist also exist graph 106 vertices 106 edge ) sample statement a suitable graph consist two vertices connect a single edge,['implementation'],1900.0
472/E,"one way create task learn game pick a game focus part <unknown> game might a good task let 's a try puzzle <unknown> a popular game <unknown> focus puzzle part game a tile - <unknown> puzzle n × m board consist orb game follow move begin move touch a cell board move finger one adjacent cells ( a cell <unknown> 8 adjacent cells ) move finger current cell one adjacent cells one time , time move finger a cell another cell orb cells swap word whatever move make orb cell touch never change goal achieve kind pattern orb cancel monster attack enemy n't care detail instead give initial board input target board output goal determine whether a way reach target a single move first line contain two integers : n m ( 1 ≤ n m ≤ 30 ) next n line contain m integers — description initial board j - th integer i - th line si j ( 1 ≤ si j ≤ 900 ) si j denote type orb locate i - th row j - th column board next n line contain target board format note initial board target board different solution output : -1 . a solution first line output integer k ( 1 ≤ k ≤ 106 ) — number finger move next line print two integers x0 y0 ( 1 ≤ x0 ≤ n ; 1 ≤ y0 ≤ m ) — position cell touch begin next k line print two integers xi yi ( 1 ≤ xi ≤ n ; 1 ≤ yi ≤ m ) — position move note position must adjacent previous position max ( |xi - xi - 1| |yi - yi - 1| ) = 1 . multiple solutions print prove constraints exist a solution a solution 106 operations",['implementation'],2800.0
567/B,"berland national library recently build capital berland addition library take collect work berland leaders library a read room today pilot launch automate read room visitors ' account system ! scanner system instal entrance read room record events form ` ` reader enter room '' ` ` reader leave room '' every reader assign a registration number registration procedure library — 's a unique integer 1 106 . thus system log events two form : first launch system a success function period time , time launch time <unknown> read room may already visitors significant fund budget berland spend design <unknown> system therefore citizens capital demand explain need system <unknown> <unknown> bring , developers system need <unknown> come reason existence help system developers find minimum possible capacity read room ( visitors ) use log system available first line contain a positive integer n ( 1 ≤ n ≤ 100 ) — number record system log next follow n events system journal order make event write a single line look ` ` + ri '' ` ` - ri '' ri integer 1 106 registration number visitor ( distinct visitors always distinct registration number ) guarantee log contradictory , every visitor type two consecutive events distinct start system stop room may possibly contain visitors print a single integer — minimum possible capacity read room first sample test system log ensure point read room visitors registration number 1 <unknown> <unknown> . people room time base log therefore answer test 3",['implementation'],1300.0
471/A,two polar bear menshykov uslada st . petersburg zoo elephant horace kiev zoo get six stick play assess animals ' <unknown> menshykov uslada horace decide make either elephant a bear stick make animal stick follow way : task find animal make give stick set zoo <unknown> want stick back game must never break even bear understand single line contain six space - separated integers li ( 1 ≤ li ≤ 9 ) — lengths six stick guarantee input make animals stick make a bear give set print string ` ` bear '' ( without quote ) make elephant print string ` ` elephant '' ( <unknown> quote ) make neither a bear elephant print string ` ` alien '' ( without quote ) 're creative <unknown> see instructions show make a bear elephant first two sample stick length 2 red stick length 4 green stick length 5 blue,['implementation'],1100.0
549/A,"developers looksery write efficient algorithm detect face a picture unfortunately currently busy prepare a contest , problem image a rectangular table consist lowercase latin letter a face image a 2 × 2 square four letter square make word ` ` face '' need write a program determine number face image square correspond face overlap first line contain two space - separated integers n m ( 1 ≤ n m ≤ 50 ) — height width image respectively next n line define image line contain m lowercase latin letter single line print number face image first sample image contain a single face locate a square upper leave corner second line second column : second sample image also contain exactly one face upper leave corner second row first column third sample two face show : fourth sample image face",['implementation'],900.0
548/A,mike walk subway stuff back - bag drop grind several fax message among concatenate string order string s. sure back - bag someone else 's remember exactly k message bag a palindrome string string length ask help tell wear back - bag check give string s a concatenation k palindromes length first line input contain string s contain lowercase english letter ( 1 ≤ |s| ≤ 1000 ) second line contain integer k ( 1 ≤ k ≤ 1000 ) print ` ` yes '' ( without quote ) wear back - bag ` ` '' ( without quote ) otherwise palindrome a string read forward backward second sample fax back - bag ` ` saddas '' ` ` <unknown> '',['implementation'],1100.0
540/A,scrooge mcduck keep treasure save a home safe a combination lock time want put treasure 's earn fair square open lock combination lock represent n rotate disk digits 0 9 write scrooge mcduck turn disk combination digits disk form a secret combination one move rotate one disk one digit forward backwards particular one move go digit 0 digit 9 vice versa minimum number action need ? first line contain a single integer n ( 1 ≤ n ≤ 1000 ) — number disk combination lock second line contain a string n digits — original state disk third line contain a string n digits — scrooge mcduck 's combination open lock print a single integer — minimum number move scrooge mcduck need open lock sample need 13 move :,['implementation'],800.0
538/D,igor chess a long time <unknown> game ordinary rule go think new rule game become world famous igor 's chessboard a square size n × n cells igor decide simple rule guarantee success 's game one type piece besides piece game color possible move a piece describe a set shift vectors next passage contain a formal description available move let row board number top bottom columns number leave right 1 n. let 's assign square a pair integers ( x y ) — number correspond column row possible move piece define a pair integers ( dx dy ) ; use move piece move field ( x y ) field ( x + dx y + dy ) perform move cell ( x + dx y + dy ) within boundaries board n't contain another piece piece stand cells ( x y ) ( x + dx y + dy ) important consider possibility make give move ( example like a knight move usual chess ) igor offer find move chess piece make place several piece board unoccupied square tell whether attack present piece ( i.e whether piece field move cell ) restore a possible set shift vectors piece else determine igor make a mistake situation impossible set shift vectors first line contain a single integer n ( 1 ≤ n ≤ 50 ) next n line contain n character describe position offer igor j - th character i - th string follow value : guarantee least one piece board a valid set move first line print a single word ' yes ' ( without quote ) next print description set move a piece form a ( 2n - 1 ) × ( 2n - 1 ) board center board a piece symbols ' x ' mark cells attack a format similar input see examples output a full understand format several possible answer print a valid set move exist print a single word ' no ' first sample test piece a usual chess rook second sample test piece a usual chess knight,['implementation'],1800.0
538/A,a large banner word codeforces order 1000 - th <unknown> round <unknown> take place <unknown> beach unfortunately company make banner mix two order deliver somebody else 's banner contain someone else 's word word banner consist upper - case english letter little time correct mistake manage cut substring banner i.e several consecutive letter result part banner glue a single piece ( begin end original banner cut one part remain ) ; allow change relative order part banner ( i.e a substring cut several first last letter leave allow glue last letter right first letter ) thus example example cut a substring string ' <unknown> ' get string ' temple ' ( cut string ) ' plate ' ( cut <unknown> ) ' t ' ( cut <unknown> ) etc help organizers round determine whether possible cut banner substring a way remain part form word codeforces single line input contain word write banner word consist upper - case english letter word non - empty length n't exceed 100 character guarantee word n't word codeforces print ' yes ' exist a way cut substring ' no ' otherwise ( without quote ),['implementation'],1400.0
535/B,tavas start eat coffee mix without water ! keione tell <unknown> <unknown> n't stop 's keione tell smart friend saddas punish ! saddas take tavas ' headphones tell : ` ` solve follow problem i 'll return ` ` problem : give a lucky number n. lucky number positive integers whose decimal representations contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 sort lucky number increase order 's 1 - based index n ? tavas smart saddas ask a favor solve problem headphones back first line input contain a lucky number n ( 1 ≤ n ≤ 109 ) print index n among lucky number,['implementation'],1100.0
535/A,today tavas get test result integer score want share girlfriend nafas phone operate system <unknown> keyboard n't digits ! want share score nafas via text choice send number use word eat coffee mix without water right 's really mess ca n't think task help tell type first line input contain integer s ( 0 ≤ s ≤ 99 ) tavas 's score first line output print a single string consist english lowercase letter <unknown> ( ' - ' ) use space find need know english numerals http : //en.wikipedia.org / wiki / <unknown>,['implementation'],1000.0
526/A,problem meet simplify model game king thieve a new <unknown> game call ` ` king thieve '' aim reach a chest gold control character avoid trap obstacles way interest feature game design level available players let 's consider follow simple design a level a <unknown> consist n segment locate a vertical level segment either a platform character stand a pit a trap make player lose fall segment length platforms scheme level represent ' * ' pit represent ' . ' one things affect <unknown> characteristics level a possibility perform a series consecutive jump length formally character platform number i1 make a sequence jump platforms i1 < i2 < ... < ik i2 - i1 = i3 - i2 = ... = ik - ik - 1 . course segment i1 i2 ... ik exactly platforms pit let 's call a level good perform a sequence four jump length word must a sequence i1 i2 ... <unknown> consist five platforms intervals consecutive platforms length give scheme level check good first line contain integer n ( 1 ≤ n ≤ 100 ) — number segment level next line contain scheme level represent a string n character ' * ' ' . ' level good print word ` ` yes '' ( without quote ) otherwise print word ` ` '' ( without quote ) first sample test may perform a sequence jump platforms 2 5 8 11 14,['implementation'],1300.0
524/A,<unknown> <unknown> социальной сети является <unknown> <unknown> <unknown> <unknown> <unknown> в <unknown> <unknown> <unknown> <unknown> в <unknown> <unknown> социальной сети <unknown> <unknown> то есть <unknown> a является другом b то b <unknown> является другом a. в <unknown> <unknown> сети есть функция <unknown> <unknown> множество людей <unknown> <unknown> <unknown> <unknown> <unknown> для пользователя <unknown> функция <unknown> <unknown> <unknown> <unknown> пользователя x. <unknown> <unknown> <unknown> <unknown> y не <unknown> другом x <unknown> <unknown> <unknown> является другом не <unknown> <unknown> для k % друзей x. <unknown> <unknown> является предполагаемым другом для x. <unknown> каждого человека в социальной сети есть <unknown> <unknown> <unknown> — это <unknown> <unknown> <unknown> 1 <unknown> 109 . <unknown> <unknown> <unknown> пар пользователей являющихся друзьями <unknown> для каждого <unknown> пользователя множество его предполагаемых друзей в <unknown> <unknown> <unknown> два <unknown> числа m и k ( 1 ≤ m ≤ 100 0 ≤ k ≤ 100 ) — количество пар друзей и <unknown> <unknown> <unknown> друзей для <unknown> <unknown> <unknown> предполагаемым другом в <unknown> m <unknown> <unknown> <unknown> два числа ai bi ( 1 ≤ ai bi ≤ 109 ai ≠ bi ) <unknown> идентификаторы пользователей являющихся друзьями <unknown> <unknown> <unknown> <unknown> людей <unknown> в <unknown> не <unknown> <unknown> <unknown> для <unknown> <unknown> людей в порядке <unknown> i d <unknown> <unknown> <unknown> предполагаемых <unknown> <unknown> <unknown> <unknown> <unknown> ` ` i d : k id1 id2 ... idk '' <unknown> i d — это i d <unknown> человека k — количество его предполагаемых друзей а id1 id2 ... idk — идентификаторы его предполагаемых друзей в <unknown> порядке,['implementation'],1600.0
676/A,nicholas array a contain n distinct integers 1 n. word nicholas a permutation size n. nicholas want minimum element ( integer 1 ) maximum element ( integer n ) far possible want perform exactly one swap order maximize distance minimum maximum elements distance two elements consider equal absolute difference position first line input contain a single integer n ( 2 ≤ n ≤ 100 ) — size permutation second line input contain n distinct integers a1 a2 ... ( 1 ≤ ai ≤ n ) ai equal element i - th position print a single integer — maximum possible distance minimum maximum elements nicholas achieve perform exactly one swap first sample one may obtain optimal answer swap elements 1 2 . second sample minimum maximum elements locate opposite end array swap 7 2 . third sample distance minimum maximum elements already maximum possible perform unnecessary swap example one swap 5 2,['implementation'],800.0
676/D,theseus arrive <unknown> fight minotaur find a labyrinth a form a rectangular field size n × m consist block size 1 × 1 . block labyrinth a button rotate block 90 degrees clockwise block rotate around center n't change position labyrinth also block number doors ( possibly none ) one minute theseus either push button order rotate block 90 degrees clockwise pass neighbour block theseus go block a neighbour block b block a a door lead block b block b a door lead block a. theseus find entrance labyrinth locate block ( xt yt ) — block row xt column yt theseus know minotaur hide block ( xm ym ) want know minimum number minutes require get theseus a hero a programmer ask help first line input contain two integers n m ( 1 ≤ n m ≤ 1000 ) — number row number columns labyrinth respectively follow n line contain m character describe block labyrinth possible character : leave right top bottom define represent labyrinth a table row number 1 n top bottom columns number 1 m leave right next line contain two integers — coordinate block ( xt yt ) ( 1 ≤ xt ≤ n 1 ≤ yt ≤ m ) theseus initially locate last line contain two integers — coordinate block ( xm ym ) ( 1 ≤ xm ≤ n 1 ≤ ym ≤ m ) minotaur hide 's guarantee block theseus start block minotaur hide least one door theseus minotaur may initially locate block theseus able get minotaur print -1 line output otherwise print minimum number minutes require get block minotaur hide assume theseus start block ( xt yt ) moment 0,['implementation'],2000.0
544/B,a map object a rectangular field consist n row n columns cell initially occupy sea cover cells map sand exactly k islands appear map call a set sand cells island possible get move sand cells move a cell a side - adjacent cell cells call side - adjacent share a vertical horizontal side easy see islands share cells ( otherwise together form a bigger island ) find a way cover cells sand exactly k islands appear n × n map determine way exist single line contain two positive integers n k ( 1 ≤ n ≤ 100 0 ≤ k ≤ n2 ) — size map number islands form answer n't exist print ` ` '' ( without quote ) a single line otherwise print ` ` yes '' first line next n line print description map line description must consist character 's ' ' l ' 's ' a cell occupy sea ' l ' cell cover sand length line description must equal n. multiple answer may print maximize size islands,['implementation'],1400.0
677/A,vanya friends walk along fence height h want guard notice order achieve height friends exceed h. height person greater h bend surely wo n't notice guard height i - th person equal ai consider width person walk usual equal 1 width bend person equal 2 . friends want talk walk would like walk a single row minimum width road friends walk a row remain <unknown> guard ? first line input contain two integers n h ( 1 ≤ n ≤ 1000 1 ≤ h ≤ 1000 ) — number friends height fence respectively second line contain n integers ai ( 1 ≤ ai ≤ 2h ) i - th equal height i - th person print a single integer — minimum possible valid width road first sample person number 3 must bend require width equal 1 + 1 + 2 = 4 . second sample friends short enough one bend width 1 + 1 + 1 + 1 + 1 + 1 = 6 enough third sample persons bend except last one require minimum width road equal 2 + 2 + 2 + 2 + 2 + 1 = 11,['implementation'],800.0
807/A,rat ? ultimate question competitive program codeforces everything answer another codeforces round conduct two participants number point participant top bottom stand rat round know 's know least one participant 's rat change round rat sure 's also know round rat a participant lower rat take a better place stand a participant higher rat least one round participant 's rat change problem make <unknown> rat system determine current round rat unrated 's impossible determine whether rat first line contain a single integer n ( 2 ≤ n ≤ 1000 ) — number round participants next n line contain two integers ai bi ( 1 ≤ ai bi ≤ <unknown> ) — rat i - th participant round respectively participants list order top bottom stand round rat sure print ` ` rat '' round unrated sure print ` ` unrated '' 's impossible determine whether round rat print ` ` maybe '' first example rat participants third fifth place change therefore round rat second example one 's rat change participant second place lower rat participant fourth place therefore round rat someone 's rat would ' ve change sure third example one 's rat change participants take place non - increasing order rat therefore 's impossible determine whether round rat,['implementation'],900.0
802/G,'s first april heidi suspect news read today fake want look <unknown> front contestants know a <unknown> fake contain heidi a subsequence help heidi assess whether give piece true please <unknown> ... first line input contain a single nonempty string s length 1000 compose lowercase letter ( a - z ) output yes string s contain heidi a subsequence otherwise a string s contain another string p a subsequence possible delete character s obtain p,['implementation'],800.0
799/A,game <unknown> take t minutes oven bake k <unknown> cake cake ready moment t minutes start bake arkady need least n cake complete a task currently n't however infinitely many ingredients one oven moreover arkady build one similar oven make process faster would take d minutes build oven new oven build old one bake cake new oven build ovens bake simultaneously arkady ca n't build one oven determine reasonable build second oven i.e decrease minimum time need get n cake time need second oven one oven unreasonable line contain four integers n t k d ( 1 ≤ n t k d ≤ 1 000 ) — number cake need time need one oven bake k cake number cake bake time time need build second oven reasonable build second oven print ` ` yes '' otherwise print ` ` '' first example possible get 8 cake 12 minutes use one oven second oven build 5 minutes 6 minutes first oven bake 4 cake second oven bake 4 ovens 11 minutes thus reasonable build second oven second example n't matter whether build second oven thus take 12 minutes bake 8 cake case thus unreasonable build second oven third example first oven bake 11 cake 3 minutes need 10 . unreasonable build second oven build take time bake need number cake use oven,['implementation'],1100.0
796/B,zane wizard go perform a magic show shuffle cup n cup number 1 n place along x - axis a table m hole precisely cup i table position x = i. <unknown> bone initially position x = 1 . zane confuse audience swap cup k time i - th time involve cup position x = ui x = vi bone happen position a hole time fall hole onto grind affect future swap operations forget zane a wizard swap cup move <unknown> instead teleport cup ( along bone inside ) intend position therefore example swap cup x = 4 one x = 6 position x = 5 moment operation zane ’ s <unknown> inzane trouble zane away vacation inzane find beloved bone would exhaust try open cup inzane know codeforces <unknown> successfully help zane want see could help solve problem help inzane determine final position bone first line contain three integers n m k ( 2 ≤ n ≤ 106 1 ≤ m ≤ n 1 ≤ k ≤ 3·105 ) — number cup number hole table number swap operations respectively second line contain m distinct integers h1 h2 ... <unknown> ( 1 ≤ hi ≤ n ) — position along x - axis a hole table next k line contain two integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) — position cup swap print one integer — final position along x - axis bone first sample operations bone become x = 2 x = 5 x = 7 x = 1 respectively second sample first operation bone become x = 2 fall hole onto grind,['implementation'],1300.0
796/A,"zane wizard never love anyone fell love a girl whose name remain unknown us girl live house m a village n house village line a straight line leave right : house 1 house 2 ... house n. village also well - <unknown> : house i house i + 1 ( 1 ≤ i < n ) exactly 10 meter away village house occupy , indeed unoccupied house purchase give n integers a1 a2 ... denote availability price house house i occupy therefore buy ai equal 0 . otherwise house i buy ai represent money require buy dollars zane k dollars spare become a challenge choose house purchase could live near possible crush help zane determine minimum distance crush 's house house afford help succeed love first line contain three integers n m k ( 2 ≤ n ≤ 100 1 ≤ m ≤ n 1 ≤ k ≤ 100 ) — number house village house girl live amount money zane ( dollars ) respectively second line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 100 ) — denote availability price house guarantee = 0 possible purchase house k dollars print one integer — minimum distance meter house girl zane like live house zane buy first sample k = 20 dollars zane buy house 5 . distance house m = 1 house 5 10 + 10 + 10 + 10 = 40 meter second sample zane buy house 6 7 . better buy house 6 house 7 since house m = 3 house 6 30 meter away house m = 3 house 7 40 meter away",['implementation'],800.0
794/A,a robber attempt rob a bank fail complete task however manage open safes oleg bank client love money ( n't ) decide take advantage fail robbery steal money safes many safes arrange a line i - th safe leave call safe i. n banknotes leave safes total i - th banknote safe xi oleg safe a. two security guard one guard safe b b < a i.e first guard leave oleg guard guard safe c c > a i.e right oleg two guard lazy move every second oleg either take banknotes current safe move neighbor safes however visit safe guard security guard time <unknown> might charge steal determine maximum amount banknotes oleg gather first line input contain three space - separated integers a b c ( 1 ≤ b < a < c ≤ 109 ) denote position oleg first security guard second security guard respectively next line input contain a single integer n ( 1 ≤ n ≤ 105 ) denote number banknotes next line input contain n space - separated integers x1 x2 ... xn ( 1 ≤ xi ≤ 109 ) denote i - th banknote locate xi - th safe note xi guarantee distinct output a single integer : maximum number banknotes oleg take first example oleg take banknotes position 4 5 6 ( note 2 banknotes position 5 ) oleg ca n't take banknotes safes 7 8 ca n't run second security guard similarly oleg take banknotes position 3 2 ca n't run first security guard thus take a maximum 4 banknotes second sample oleg ca n't take banknotes without bump security guard,['implementation'],800.0
793/B,wake alarm clock igor financial <unknown> hurry work eat <unknown> sit car <unknown> open gps <unknown> find roads bankopolis city live close due road work moreover igor problems <unknown> wheel make two turn way office bank bankopolis look like a grid n row m columns igor find a way home bank two turn n't contain cells road work determine impossible work home a turn a change movement direction igor 's car move leave right upwards downwards initially igor choose direction igor still sleepy help first line contain two integers n m ( 1 ≤ n m ≤ 1000 ) — number row number columns grid next n line contain m character denote correspond row grid follow character occur : guarantee ` ` s '' ` ` t '' appear exactly line print ` ` yes '' a path igor 's home igor 's office two turn ` ` '' otherwise first sample show follow picture : second sample impossible reach igor 's office use less 4 turn thus exist path use 2 turn path use exactly 4 turn show picture :,['implementation'],1600.0
792/B,n children stand a circle play counting - out game children number clockwise 1 n. begin first child consider leader game play k step i - th step leader count ai people clockwise order start next person last one point leader eliminate next player become new leader example children number [ 8 10 13 14 16 ] currently circle leader child 13 ai = 12 counting - out <unknown> end child 16 eliminate child 8 become leader write a program print number child eliminate every step first line contain two integer number n k ( 2 ≤ n ≤ 100 1 ≤ k ≤ n - 1 ) next line contain k integer number a1 a2 ... ak ( 1 ≤ ai ≤ 109 ) print k number i - th one correspond number child eliminate i - th step let 's consider first example :,['implementation'],1300.0
792/A,"n cities <unknown> along main road berland cities represent coordinate — integer number a1 a2 ... , coordinate pairwise distinct possible get one city another bus bus roads old minister transport decide build a new bus route minister n't want spend large amount money — want choose two cities a way distance minimal possible distance two cities equal absolute value difference coordinate possible multiple pair cities minimal possible distance minister want know quantity pair task write a program calculate minimal possible distance two pair cities quantity pair distance first line contain one integer number n ( 2 ≤ n ≤ 2·105 ) second line contain n integer number a1 a2 ... ( - 109 ≤ ai ≤ 109 ) number ai pairwise distinct print two integer number — minimal distance quantity pair distance first example distance first city fourth city |4 - 6| = 2 pair distance",['implementation'],1100.0
791/A,bear limak want become largest bear least become larger brother bob right limak bob weigh a b respectively 's guarantee limak 's weight smaller equal brother 's weight limak eat a lot weight triple every year bob 's weight double every year many full years limak become strictly larger ( strictly <unknown> ) bob ? line input contain two integers a b ( 1 ≤ a ≤ b ≤ 10 ) — weight limak weight bob respectively print one integer denote integer number years limak become strictly larger bob first sample limak weigh 4 bob weigh 7 initially one year weight <unknown> = 12 <unknown> = 14 respectively ( one weight triple one double ) limak n't larger bob yet second year weight 36 28 first weight greater second one limak become larger bob two years print 2 . second sample limak 's bob 's weight next years : 12 18 36 36 finally 108 72 ( three years ) answer 3 . remember limak want larger bob wo n't satisfy equal weight third sample limak become larger bob first year weight 3 2,['implementation'],800.0
677/C,walk street vanya saw a label ` ` hide & seek '' a programmer use & a bitwise two word represent a integers base 64 get new word vanya think string s want know number pair word length |s| ( length s ) bitwise equal s. number large output modulo 109 + 7 . represent string a number numeral system base 64 vanya use follow rule : line input contain a single word s ( 1 ≤ |s| ≤ 100 000 ) consist digits lowercase uppercase english letter character ' - ' ' _ ' print a single integer — number possible pair word bitwise equal string s modulo 109 + 7 . a detail definition bitwise recommend take a look correspond article wikipedia first sample 3 possible solutions :,['implementation'],1500.0
545/A,"little susie <unknown> older brother like play cars today decide set a tournament process a tournament describe next paragraph n toy cars pair collide result a collision one follow : car turn one car turn cars turn a car good turn collision result <unknown> determine n × n matrix а : a number intersection і - th row j - th column describe result collision і - th j - th car : susie want find good cars quickly determine cars good cope task ? first line contain integer n ( 1 ≤ n ≤ 100 ) — number cars next n line contain n space - separated integers determine matrix a. guarantee main diagonal - 1 - 1 n't appear anywhere else matrix guarantee input correct , aij = 1 aji = 2 aij = 3 aji = 3 aij = 0 aji = 0 . print number good cars next line print space - separated indices increase order",['implementation'],900.0
471/B,'s time polar bear menshykov uslada zoo st . petersburg elephant horace zoo kiev get business total n task day animal task task evaluate difficulty also animals decide task order difficulty unfortunately task difficulty order one perform task may vary menshykov uslada horace ask deal <unknown> come individual plan plan a sequence describe order animal n task besides want unique plan therefore three plan must form three different sequence find require plan otherwise deliver sad news state impossible come three distinct plan give task first line contain integer n ( 1 ≤ n ≤ 2000 ) — number task second line contain n integers h1 h2 ... hn ( 1 ≤ hi ≤ 2000 ) hi difficulty i - th task larger number hi difficult i - th task first line print ` ` yes '' ( without quote ) possible come three distinct plan task otherwise print first line ` ` '' ( without quote ) three desire plan exist print second line n distinct integers represent number task order do accord first plan third fourth line print two remain plan form multiple possible answer print first sample difficulty task set one limit : task 1 4 must do task 2 3 . give total four possible sequence task : [ 1 4 2 3 ] [ 4 1 2 3 ] [ 1 4 3 2 ] [ 4 1 3 2 ] print three answer second sample two sequence task meet condition — [ 3 1 2 4 5 ] [ 3 1 4 2 5 ] consequently impossible make three distinct sequence task,['implementation'],1300.0
785/A,anton 's favourite <unknown> figure regular polyhedrons note five kinds regular polyhedrons : five kinds polyhedrons show picture : anton a collection n polyhedrons one day decide know many face polyhedrons total help anton find number ! first line input contain a single integer n ( 1 ≤ n ≤ 200 000 ) — number polyhedrons anton 's collection follow n line input contain a string si — name i - th <unknown> anton 's collection string look like : output one number — total number face polyhedrons anton 's collection first sample anton one icosahedron one cube one tetrahedron one dodecahedron icosahedron 20 face cube 6 face tetrahedron 4 face dodecahedron 12 face total 20 + 6 + 4 + 12 = 42 face,['implementation'],800.0
721/A,recently adaltik discover japanese crosswords japanese crossword a picture represent a table size a × b square square color white black integers leave row top columns encrypt correspond row column number integers represent many group black square correspond row column integers represent number consecutive black square correspond group ( find detail explanation wikipedia https : //en.wikipedia.org / wiki / <unknown> ) adaltik decide general case japanese crossword complicate draw a row consist n square ( e.g japanese crossword size 1 × n ) want encrypt way japanese crossword help adaltik find number encrypt row draw first line input contain a single integer n ( 1 ≤ n ≤ 100 ) — length row second line input contain a single string consist n character ' b ' ' w ' ( ' b ' correspond black square ' w ' — white square row adaltik draw ) first line contain a single integer k — number integers encrypt row e.g number group black square row second line contain k integers encrypt row e.g correspond size group consecutive black square order leave right last sample case correspond picture statement,['implementation'],800.0
780/A,"andryusha orderly boy like keep things place today face a problem put sock wardrobe n distinct pair sock initially a bag pair number 1 n. andryusha want put pair sock together put wardrobe take sock one one bag sock look whether pair sock already take bag , ( mean pair sock still bag ) put current sock table front otherwise put sock pair wardrobe andryusha remember order take sock bag tell maximum number sock table time ? first line contain single integer n ( 1 ≤ n ≤ 105 ) — number sock pair second line contain 2n integers x1 x2 ... <unknown> ( 1 ≤ xi ≤ n ) describe order andryusha take sock bag precisely xi mean i - th sock andryusha take pair xi guarantee andryusha take exactly two sock pair print single integer — maximum number sock table time first example andryusha take a sock first pair put table take next sock first pair well immediately put sock wardrobe thus one sock table time second example andryusha behave follow :",['implementation'],800.0
778/B,"bob recently read bitwise operations use computers : xor study properties invent a new game initially bob choose integer m bite depth game mean number game consist m bits ask peter choose m - bit number , bob compute value n variables variable assign either a constant m - bit number result bitwise operation <unknown> operation may either variables define number choose peter , peter 's score equal sum variable value bob want know number peter need choose get minimum possible score number need choose get maximum possible score case several ways get score find minimum number choose first line contain two integers n m number variables bite depth respectively ( 1 ≤ n ≤ 5000 ; 1 ≤ m ≤ 1000 ) follow n line contain descriptions variables line describe exactly one variable description follow format : name a new variable space sign ` ` : = '' space follow one : variable name string consist lowercase latin letter length 10 . variable name different first line output minimum number choose peter make sum variable value minimum possible second line output minimum number choose peter make sum variable value maximum possible number print m - bit binary number first sample peter choose a number 0112 a = 1012 b = 0112 c = 0002 sum value 8 . choose number <unknown> a = 1012 b = 0112 c = 1112 sum value 15 . second test minimum maximum sum variables a bb cx d e 2 sum n't depend number choose peter minimum peter choose 0",['implementation'],1800.0
776/A,"beloved detective sherlock currently try catch a <unknown> killer kill a person day use power <unknown> come know killer a strategy select next victim killer start two potential victims first day select one two kill select victim replace a new person repeat procedure day way day two potential victims choose sherlock know initial two potential victims also know murder happen a particular day new person replace victim need help get pair potential victims day sherlock observe pattern first line input contain two name ( length n't exceed 10 ) two initial potential victims next line contain integer n ( 1 ≤ n ≤ 1000 ) number days next n line contain two name ( length n't exceed 10 ) first person murder day second one replace person input format consistent , a person murder guarantee two potential victims time also name guarantee distinct consist lowercase english letter output n + 1 line i - th line contain two persons killer select i - th murder ( n + 1 ) -th line contain two persons next victim select line two name print order first example killer start <unknown> <unknown>",['implementation'],900.0
774/K,stepan like repeat vowel letter write word example instead word ` ` <unknown> '' write ` ` <unknown> '' sergey like behavior want write a program format word write stepan program must combine consecutive equal vowels a single vowel vowel letter ` ` a '' ` ` e '' ` ` i '' ` ` o '' ` ` u '' ` ` y '' exceptions : letter ` ` e '' ` ` o '' repeat a row exactly 2 time like word ` ` feet '' ` ` foot '' program must skip transform one vowel example word ` ` <unknown> '' must convert word ` ` <unknown> '' sergey busy ask help write require program first line contain integer n ( 1 ≤ n ≤ 100 000 ) — number letter word write stepan second line contain string s length equal n contain lowercase english letter — word write stepan print single string — word write stepan convert accord rule describe statement,['implementation'],1600.0
774/D,"vasya a sequence cub exactly one integer write cube vasya exhibit cub a row sequence number write cub order leave right equal a1 a2 ... , vasya walk little brother stepan play vasya 's cub change order sequence number write cub become equal b1 b2 ... bn stepan say swap cub position l r inclusive remove add cub ( i. e. say reorder cub position l r inclusive way ) task determine possible stepan say truth guarantee stepan deceive brother first line contain three integers n l r ( 1 ≤ n ≤ 105 1 ≤ l ≤ r ≤ n ) — number vasya 's cub position tell stepan second line contain sequence a1 a2 ... ( 1 ≤ ai ≤ n ) — sequence integers write cub vasya 's order third line contain sequence b1 b2 ... bn ( 1 ≤ bi ≤ n ) — sequence integers write cub stepan rearrange order guarantee stepan remove add cub rearrange vasya 's cub print ` ` lie '' ( without quote ) guarantee stepan deceive brother case print ` ` truth '' ( without quote ) first example a situation stepan say truth initially sequence integers cub equal [ 3 4 2 3 1 ] stepan could first swap cub position 2 3 ( sequence integers cub become equal [ 3 2 4 3 1 ] ) swap cub position 3 4 ( sequence integers cub become equal [ 3 2 3 4 1 ] ) second example possible stepan say truth say swap cub position 1 2 see guarantee change position cube position 3 first guarantee stepan deceive brother third example value l r a situation stepan say truth",['implementation'],1500.0
770/D,a sequence square bracket regular insert symbols ` ` + '' ` ` 1 '' get a regular mathematical expression example sequence ` ` [ [ ] ] [ ] '' ` ` [ ] '' ` ` [ [ ] [ [ ] ] ] '' — regular time ` ` ] [ ` ` ` ` [ [ ] '' ` ` [ [ ] ] ] [ ` ` — <unknown> draw give sequence use a <unknown> <unknown> strip lowest possible height — use symbols ' + ' ' - ' ' | ' example sequence ` ` [ [ ] [ ] ] [ ] '' represent : bracket represent <unknown> one symbols ' | ' ( vertical part ) symbols ' + ' ' - ' example give bracket draw without space one one divide pair consecutive pairwise bracket a single - space bar ( two bracket <unknown> merge one symbol ) image minimum possible height enclose bracket always smaller surround bracket bracket separately <unknown> maximize height image pair final bracket example occupy entire height image study carefully examples <unknown> explain condition problem pay attention problem answer ( image ) unique first line contain even integer n ( 2 ≤ n ≤ 100 ) — length sequence bracket second line contain sequence bracket — n symbols ` ` [ ` ` ` ` ] '' guarantee give sequence bracket regular print draw bracket sequence format give condition n't print extra ( unnecessary ) space,['implementation'],1400.0
770/C,take online course berland state university ! polycarp need pass k main online course specialty get a <unknown> total n course <unknown> passage situation complicate dependence online course course a list must pass start online course ( list empty mean limitation ) help polycarp pass least number course total get specialty ( mean pass main necessary course ) write a program print order course polycarp pass course consistently start next course finish previous one course ca n't pass first line contain n k ( 1 ≤ k ≤ n ≤ 105 ) — number online - courses number main course polycarp 's specialty second line contain k distinct integers 1 n — number main online - courses polycarp 's specialty n line follow describe next course : i - th correspond course i. line start integer ti ( 0 ≤ ti ≤ n - 1 ) — number course i - th depend follow sequence ti distinct integers 1 n — number course random order i - th depend guarantee course depend guarantee sum value ti n't exceed 105 . print -1 way get a specialty otherwise first line print integer m — minimum number online - courses necessary pass get a specialty second line print m distinct integers — number course necessary pass chronological order passage several answer allow print first test firstly take course number 1 2 take course number 4 take course number 5 main take course number 3 last pass main course,['implementation'],1500.0
770/A,innokentiy decide change password social net ` ` contact ! ` ` lazy invent a new password need help innokentiy decide new password satisfy follow condition : task help innokentiy invent a new password satisfy give condition first line contain two positive integers n k ( 2 ≤ n ≤ 100 2 ≤ k ≤ min ( n 26 ) ) — length password number distinct symbols pay attention a desire new password always exist print password satisfy condition give innokentiy first test one appropriate new passwords — java length equal 4 3 distinct lowercase letter a j v use second test one appropriate new passwords — python length equal 6 consist 6 distinct lowercase letter third test one appropriate new passwords — <unknown> length equal 5 2 distinct lowercase letter p h use pay attention condition two identical symbols consecutive correct appropriate passwords test,['implementation'],800.0
769/A,faculty computer science berland social net ` ` <unknown> ! '' course faculty special group whose name equal year university entrance correspond course students university students join group course join group year student 's university entrance differ x year university entrance student x — non - negative integer a value x give uniquely determine available data note students n't join group give list group student igor join accord information need determine year igor 's university entrance first line contain positive odd integer n ( 1 ≤ n ≤ 5 ) — number group igor join next line contain n distinct integers a1 a2 ... ( <unknown> ≤ ai ≤ <unknown> ) — years student 's university entrance group igor member guarantee input data correct answer always exist group give randomly print year igor 's university entrance first test value x = 1 . igor enter university 2015 . join group members students enter university <unknown> 2015 2016 . second test value x = 0 . igor enter group correspond year university entrance,['implementation'],800.0
764/B,young timofey a birthday today ! get <unknown> n cub a birthday present parent every cube a number ai write timofey put cub a row go unpack present time timofey 's elder brother dima reorder cub use follow rule suppose cub number 1 n order dima perform several step step i reverse segment cub i - th ( n - i + 1 ) -th i ≤ n - i + 1 . perform operations dima go away proud timofey return cub understand order change help timofey fast save holiday — restore initial order cub use information current location first line contain single integer n ( 1 ≤ n ≤ 2·105 ) — number cub second line contain n integers a1 a2 ... ( - 109 ≤ ai ≤ 109 ) ai number write i - th cube dima change order print n integers separate space — number write cub initial order show answer unique consider first sample,['implementation'],900.0
780/H,"a new bus route open city route a close polygon line place segment parallel one ax m bus operate route bus move a loop along route direction equal constant <unknown> ( stop time negligible problem ) bus start movement first vertex route equal interval suppose t total time a single bus travel whole loop route , bus 1 start move time 0 bus 2 start time t / m bus 3 start time 2 t / m ; finally bus m start move time ( m - 1 ) t / m. thus intervals pair consecutive bus ( include interval last first bus ) equal bus communicate via <unknown> transmitters equal power transmitters power d bus within distance d communicate bus also equip a distribute system schedule track bus stick schedule system synchronize necessary data bus time time moment synchronization bus 1 communicate bus 2 bus 2 — bus 3 ; also bus m communicate bus 1 . a research employee task find smallest value d possible find a time moment perform synchronization bus start move first line contain two integers n m ( 2 ≤ n m ≤ 105 ) — number vertices <unknown> line number bus respectively next n line describe vertices route traverse order line contain two integers xi yi ( - 1000 ≤ xi yi ≤ 1000 ) — coordinate respective vertex guarantee leg route ( include leg last first vertex ) <unknown> one coordinate ax moreover two subsequent vertices route coincide route allow self - intersections travel along segment multiple time print one real number — answer problem answer accept relative absolute error n't exceed 10 - 6 . suppose bus travel 1 distance unit per second first sample case 0.5 second bus distance 1 hence choose d = 1 . second sample case 0.5 second bus ( 0.5 0 ) hence choose d = 0",['implementation'],3100.0
784/D,line input contain a string digits length string 1 10 inclusive output ` ` yes '' ` ` '',['implementation'],1900.0
811/A,regular competition vladik valera a b candy respectively vladik offer 1 candy valera valera give vladik 2 candy one think less generous vladik reason give 3 candy valera next turn formally guy take turn give one candy receive previous turn continue moment one ’ t give right amount candy candy guy get ’ t consider need know first ’ t give right amount candy single line input data contain two space - separated integers a b ( 1 ≤ a b ≤ 109 ) — number vladik valera candy respectively <unknown> a single line ` ` vladik ’ ’ case vladik first ’ t give right amount candy ` ` valera ’ ’ otherwise illustration first test case : illustration second test case :,['implementation'],800.0
811/B,vladik start read a complicate book algorithms contain n page improve understand write friends advise read page order give permutation p = [ p1 p2 ... pn ] pi denote number page read i - th turn sometimes vladik ’ s mom sort subsegment permutation p position l position r inclusive love order every sort vladik know number x — index page permutation read wonder page read sort change word px change ? every sort vladik return permutation initial state assume sort independent first line contain two space - separated integers n m ( 1 ≤ n m ≤ 104 ) — length permutation number time vladik 's mom sort subsegment book second line contain n space - separated integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) — permutation p. note elements permutation distinct next m line contain three space - separated integers li ri xi ( 1 ≤ li ≤ xi ≤ ri ≤ n ) — leave right border sort subsegment i - th sort position interest vladik mom ’ s sort ’ s line print ` ` yes '' page interest vladik n't change ` ` '' otherwise explanation first test case :,['implementation'],1200.0
847/G,n student group university study day group take 7 class seven time slot number 1 7 <unknown> class schedule monday know group i. e. time slot group class know task determine minimum number room need hold class group monday note one room hold one group class a single time slot first line contain a single integer n ( 1 ≤ n ≤ 1000 ) — number group follow n line contain a sequence consist 7 zero ones — schedule class monday a group symbol a position equal 1 group class correspond time slot case group class correspond time slot print minimum number room need hold group class monday first example one room enough occupy seven time slot first group second group second example three room enough seventh time slot three group class,['implementation'],900.0
847/A,doubly link list one <unknown> data structure a doubly link list a sequence elements contain information previous next elements list problem list linear structure i.e element except first exactly one previous element element except last exactly one next element list close a cycle problem give n memory cells form one doubly link list cell contain information element list memory cells number 1 n. cell i give two value : cell i contain information element previous element li = 0 . similarly cell i contain information element next element ri = 0 . example picture value l r follow : l1 = 4 r1 = 7 ; l2 = 5 r2 = 0 ; <unknown> = 0 <unknown> = 0 ; <unknown> = 6 <unknown> = 1 ; <unknown> = 0 <unknown> = 2 ; <unknown> = 0 <unknown> = 4 ; <unknown> = 1 <unknown> = 0 . task unite give list a single list join order particular input data already contain a single list need perform action print result list form value li ri action join begin one list end another perform first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number memory cells doubly link list locate follow n line contain two integers li ri ( 0 ≤ li ri ≤ n ) — cells previous next element list cell i. value li = 0 element cell i previous element list value ri = 0 element cell i next element list guarantee input contain correct description a single doubly link list list linear structure : element list except first exactly one previous element ; element list except last exactly one next element memory cell contain information one element list element list write one n give cells print n line i - th line must contain two integers li ri — cells previous next element list cell i list input unite a single list many solutions print,['implementation'],1500.0
846/A,"hideo <unknown> quit job <unknown> go find a new place work despite a well - known person still need a cv apply a job <unknown> hideo produce n game successful , hideo want remove several ( possibly zero ) cv make a better impression <unknown> a result unsuccessful game come right successful one cv formally give array s1 s2 ... sn zero ones zero correspond unsuccessful game one — a successful one game give order produce hideo ca n't swap value remove elements array a way zero come right one besides hideo still want mention much game cv possible help genius a man determine maximum number game leave cv first line contain one integer number n ( 1 ≤ n ≤ 100 ) second line contain n space - separated integer number s1 s2 ... sn ( 0 ≤ si ≤ 1 ) 0 correspond unsuccessful game 1 — a successful one print one integer — maximum number game hideo leave cv unsuccessful game come a successful one",['implementation'],1500.0
845/A,berland annual chess tournament come ! organizers gather 2·n chess players divide two team n people first team sponsor beroil second team sponsor <unknown> obviously organizers guarantee win team beroil thus organizers divide 2·n players two team n people a way first team always win every chess player rat ri know chess player greater rat always win player lower rat rat equal players win team assignment come a draw form n pair opponents : pair a player first team a player second team every chess player exactly one pair every pair play draw totally random possible divide 2·n players two team n people player first team every pair win regardless result draw ? first line contain one integer n ( 1 ≤ n ≤ 100 ) second line contain 2·n integers a1 a2 ... a2n ( 1 ≤ ai ≤ 1000 ) 's possible divide 2·n players two team n people player first team every pair win regardless result draw print ` ` yes '' otherwise print ` ` '',['implementation'],1100.0
841/A,"one day kefa find n baloons convenience denote color i - th baloon si — lowercase letter latin alphabet also kefa k friends friend upset get two baloons color kefa want give baloons friends help kefa find give baloons one <unknown> upset — print « yes » , « » otherwise note kefa 's friend upset n't get baloons first line contain two integers n k ( 1 ≤ n k ≤ 100 ) — number baloons friends next line contain string s — color baloons answer task — « yes » « » a single line choose case ( lower upper ) letter arbitrary first sample kefa give 1 - st 3 - rd baloon first friend 2 - nd 4 - th second second sample kefa need give friends baloons color a one baloon stay <unknown> s answer « »",['implementation'],900.0
839/A,bran older sister arya house bran like candy much arya go give candy first arya bran 0 candy n days i - th day arya find ai candy a box give many - <unknown> god every day give bran 8 candy n't give candy day save give later task find minimum number days arya need give bran k candy end n - th day formally need output minimum day index end k candy give ( days index 1 n ) print -1 ca n't give k candy n give days first line contain two integers n k ( 1 ≤ n ≤ 100 1 ≤ k ≤ 10000 ) second line contain n integers a1 a2 a3 ... ( 1 ≤ ai ≤ 100 ) impossible arya give bran k candy within n days print -1 . otherwise print a single integer — minimum number days arya need give bran k candy end n - th day first sample arya give bran 3 candy 2 days second sample arya give bran 17 candy 3 days give 8 candy per day third sample arya ca n't give bran 9 candy give 8 candy per day must give candy within 1 day,['implementation'],900.0
837/C,one important person a piece paper form a rectangle a × b. also n seal seal leave impression paper form a rectangle size xi × yi impression must parallel side piece paper ( seal rotate 90 degrees ) a important person want choose two different seal put two impressions select seal put exactly one impression impressions overlap ( touch side ) total area occupy largest possible largest area occupy two seal ? first line contain three integer number n a b ( 1 ≤ n a b ≤ 100 ) next n line contain two number xi yi ( 1 ≤ xi yi ≤ 100 ) print largest total area occupy two seal select two seal print 0 . first example rotate second seal 90 degrees put impression right impression first seal occupy piece paper second example ca n't choose last seal n't fit choose first third seal occupy largest area third example pair seal fit a piece paper,['implementation'],1500.0
711/B,zs coder chris baboon arrive entrance udayland a n × n magic grid entrance fill integers chris notice exactly one cells grid empty enter udayland need fill a positive integer empty cell chris try fill random number n't work zs coder realize need fill a positive integer number grid form a magic square mean fill a positive integer sum number row grid ( ) column grid ( ) two long diagonals grid ( main diagonal — <unknown> diagonal — ) equal chris n't know number fill help chris find correct positive integer fill determine impossible ? first line input contain a single integer n ( 1 ≤ n ≤ 500 ) — number row columns magic <unknown> line follow contain n integers j - th number i - th denote ai j ( 1 ≤ ai j ≤ 109 ai j = 0 ) number i - th row j - th column magic grid correspond cell empty ai j equal 0 . otherwise ai j positive guarantee exactly one pair integers i j ( 1 ≤ i j ≤ n ) ai j = 0 . output a single integer positive integer x ( 1 ≤ x ≤ 1018 ) fill empty cell whole grid become a magic square positive integer x exist output - 1 instead multiple solutions may print first sample case fill 9 empty cell make result grid a magic square indeed sum number row is:4 + 9 + 2 = 3 + 5 + 7 = 8 + 1 + 6 = 15 . sum number column is:4 + 3 + 8 = 9 + 5 + 1 = 2 + 7 + 6 = 15 . sum number two diagonals is:4 + 5 + 6 = 2 + 5 + 8 = 15 . third sample case impossible fill a number empty square result grid a magic square,['implementation'],1400.0
808/A,apart lot holiday throughout year residents berland also whole lucky years year consider lucky 1 non - zero digit number years 100 40000 5 lucky 12 <unknown> 12345 give current year berland task find long residents berland wait till next lucky year first line contain integer number n ( 1 ≤ n ≤ 109 ) — current year berland output amount years current year next lucky one first example next lucky year 5 . second one — 300 . third — 5000,['implementation'],900.0
784/C,expect find ? base and / xor language include string ? n't <unknown> <unknown> <unknown> largest mathematics <unknown> ` ` <unknown> '' without a magic wo n't <unknown> last stack <unknown> die oh <unknown> ! i array i must <unknown> may store west <unknown> first line input data contain a single integer n ( 1 ≤ n ≤ 10 ) second line input data contain n space - separated integers ai ( 1 ≤ ai ≤ 11 ) output a single integer,['implementation'],1800.0
837/B,flag berland rectangular field n × m satisfy follow condition : give a field n × m consist character ' r ' ' g ' ' b ' output ` ` yes '' ( without quote ) field correspond correct flag berland otherwise print ` ` '' ( without quote ) first line contain two integer number n m ( 1 ≤ n m ≤ 100 ) — size field follow n line consist m character ' r ' ' g ' ' b ' — description field print ` ` yes '' ( without quote ) give field correspond correct flag berland otherwise print ` ` '' ( without quote ) field third example n't three parralel strip row field fourth example parralel border different heights — 2 1 1,['implementation'],1600.0
837/A,give a text single - space separate word consist small capital latin letter volume word number capital letter word volume text maximum volume word text calculate volume give text first line contain one integer number n ( 1 ≤ n ≤ 200 ) — length text second line contain text single - space separate word s1 s2 ... si consist small capital latin letter print one integer number — volume text first example one word 5 capital letter second example word contain 0 capital letter,['implementation'],800.0
831/A,array integers unimodal : first block ( increase ) last block ( decrease ) may absent allow block absent example follow three array unimodal : [ 5 7 11 11 2 1 ] [ 4 4 2 ] [ 7 ] follow three unimodal : [ 5 5 6 6 1 ] [ 1 2 1 2 ] [ 4 5 5 6 ] write a program check array unimodal first line contain integer n ( 1 ≤ n ≤ 100 ) — number elements array second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 1 000 ) — elements array print ` ` yes '' give array unimodal otherwise print ` ` '' output letter case ( upper lower ) first example array unimodal strictly increase begin ( position 1 position 2 inclusively ) constant ( position 2 position 4 inclusively ) strictly decrease ( position 4 position 6 inclusively ),['implementation'],1000.0
828/B,polycarp a checker sheet paper size n × m. polycarp paint cells black others remain white inspire malevich 's ` ` black square '' polycarp want paint minimum possible number white cells black black cells form a square determine minimum possible number cells need paint black black cells form a black square side parallel paint 's side cells belong square white square 's side positive length first line contain two integers n m ( 1 ≤ n m ≤ 100 ) — size sheet next n line contain m letter ' b ' ' w ' — description initial cells ' color a letter ' b ' correspond cell paint black otherwise paint white print minimum number cells need paint black black cells form a black square side parallel paint 's side cells belong square white impossible print -1 . first example need paint 5 cells — ( 2 2 ) ( 2 3 ) ( 3 2 ) ( 3 3 ) ( 4 2 ) a square side equal three upper leave corner ( 2 2 ) second example cells paint black form a rectangle 's impossible get a square third example cells color white 's sufficient color cell black,['implementation'],1300.0
828/A,a small restaurant a table one person b table two persons know n group people come today consist one two people a group consist one person seat a vacant one - seater table none seat a vacant two - seater table none seat a two - seater table occupy single person still none restaurant deny service group a group consist two people seat a vacant two - seater table none restaurant deny service group give a chronological order group come determine total number people restaurant deny service first line contain three integers n a b ( 1 ≤ n ≤ 2·105 1 ≤ a b ≤ 2·105 ) — number group come restaurant number one - seater number two - seater table second line contain a sequence integers t1 t2 ... tn ( 1 ≤ ti ≤ 2 ) — description clients chronological order ti equal one i - th group consist one person otherwise i - th group consist two people print total number people restaurant deny service first example first group consist one person seat a vacant one - seater table next group occupy a whole two - seater table third group consist one person occupy one place remain two - seater table fourth group consist one person seat remain seat two - seater table thus clients serve second example first group consist one person seat vacant one - seater table next group consist one person occupy one place two - seater table 's impossible seat next group two people restaurant deny service fourth group consist one person seat remain seat two - seater table thus restaurant deny service 2 clients,['implementation'],1200.0
825/B,alice bob play 5 - in - a - row game a play field size 10 × 10 . turn put either cross noughts one a time alice put cross bob put noughts current match make turn 's alice 's turn wonder put cross empty cell win immediately alice win cross field form line length smaller 5 . line horizontal vertical diagonal give matrix 10 × 10 ( 10 line 10 character ) capital latin letter ' x ' a cross letter ' o ' a <unknown> ' . ' empty cell number ' x ' cells equal number ' o ' cells least one type least one empty cell guarantee current arrangement nobody still print ' yes ' 's possible alice win one turn put cross empty cell otherwise print ' no ',['implementation'],1600.0
825/A,polycarp invent a new binary protocol data transmission encode positive integer decimal number binary string use follow algorithm : though polycarp learn encode number idea decode back help calculate decode number first line contain one integer number n ( 1 ≤ n ≤ 89 ) — length string s. second line contain string s — sequence ' 0 ' ' 1 ' character number encode format guarantee number correspond string positive n't exceed 109 . string always start ' 1 ' print decode number,['implementation'],1100.0
822/B,<unknown> leha bore calculate greatest common divisor two <unknown> therefore decide solve crosswords 's well know a interest occupation though difficult time time course solve one crosswords leha solve a simple task able n't ? leha two string s t. hacker want change string s way find t a substring change follow : leha choose one position string s replace symbol position question mark ` ` ? ` ` hacker sure question mark comparison play role arbitrary symbol example get string s= '' ab ? b '' a result appear <unknown> '' <unknown> '' a substring guarantee length string s n't exceed length string t. help hacker replace s symbols possible result <unknown> find t a substring symbol ` ` ? '' consider equal symbol first line contain two integers n m ( 1 ≤ n ≤ m ≤ 1000 ) — length string s length string t correspondingly second line contain n lowercase english letter — string s. third line contain m lowercase english letter — string t. first line print single integer k — minimal number symbols need replace second line print k distinct integers denote position symbols string s need replace print position order several solutions print number position begin one,['implementation'],1000.0
821/A,okabe need <unknown> future <unknown> laboratory try crazy experiment ! lab represent n n square grid integers a good lab define a lab every number equal 1 express sum a number row a number column word every x y 1 ≤ x y ≤ n ax y ≠ 1 exist two indices s t ax y = ax s + y ai j denote integer i - th row j - th column help okabe determine whether a give lab good ! first line input contain integer n ( 1 ≤ n ≤ 50 ) — size lab next n line contain n space - separated integers denote a row grid j - th integer i - th row ai j ( 1 ≤ ai j ≤ 105 ) print ` ` yes '' give lab good ` ` '' otherwise output letter upper lower case first sample test 6 bottom leave corner valid sum 2 4 right hold every number equal 1 table answer ` ` yes '' second sample test 5 form sum integer row integer column thus answer ` ` '',['implementation'],800.0
820/A,mister b receive a gift : a book alien start read immediately book c page first day mister b read v0 page start speed every day start second read a page previous day ( first day read v0 page second — v0 + a page third — v0 + <unknown> page ) mister b a human <unknown> n't able read v1 page per day also refresh memory every day start second mister b reread last l page read previous day mister b finish book read last page first time help mister b calculate many days need finish book first line contain five space - separated integers : c v0 v1 a l ( 1 ≤ c ≤ 1000 0 ≤ l < v0 ≤ v1 ≤ 1000 0 ≤ a ≤ 1000 ) — length book page initial read speed maximum read speed <unknown> read speed number page reread print one integer — number days mister b need finish book first sample test book contain 5 page mister b read right first day second sample test first day mister b read page number 1 - 4 second day — 4 - 11 third day — 11 - 12 finish book third sample test every day mister b read 1 page book finish 15 days,['implementation'],900.0
818/C,yet another round <unknown> come ! grandpa maks want participate someone steal <unknown> sofa ! one perform well a major loss ? fortunately thief leave a note grandpa maks note get maks sofa storehouse still idea sofa belong look ! storehouse represent matrix n × m. every sofa take two neighbour side cells cell cover one sofa empty cells sofa a stand leave sofa b exist two cells a b xa < <unknown> a cover a b cover b. sofa a stand top sofa b exist two cells a b ya < yb a cover a b cover b. right bottom condition declare way note condition a ≠ b. also sofa a top another sofa b bottom leave right condition note also state cntl sofas leave grandpa maks 's sofa cntr — right cntt — top cntb — bottom grandpa maks ask help identify sofa guarantee one sofa give condition output number grandpa maks 's sofa sofa condition meet output -1 . first line contain one integer number d ( 1 ≤ d ≤ 105 ) — number sofas storehouse second line contain two integer number n m ( 1 ≤ n m ≤ 105 ) — size storehouse next d line contain four integer number x1 y1 x2 y2 ( 1 ≤ x1 x2 ≤ n 1 ≤ y1 y2 ≤ m ) — coordinate i - th sofa guarantee cells ( x1 y1 ) ( x2 y2 ) common side ( x1 y1 ) ≠ ( x2 y2 ) cell cover one sofa last line contain four integer number cntl cntr cntt cntb ( 0 ≤ cntl cntr cntt cntb ≤ d - 1 ) print number sofa condition meet sofas number 1 d give input sofa print -1 . let 's consider second example second one correspond give condition third example sofa set ( 1 0 0 0 ) answer -1,['implementation'],2000.0
832/B,'s hard time today petya need score 100 point informatics exam task seem easy petya think lack time finish ask help one .. a <unknown> pattern statements ( a string consist lowercase english letter character ` ` ? '' ` ` * '' ) know character ` ` * '' occur pattern also n query string give require determine pattern match everything seem easy petya discover special pattern character differ usual mean a pattern match a string possible replace character ` ` ? '' one good lowercase english letter character ` ` * '' ( one ) include empty string bad lowercase english letter result string give string good letter give petya others bad first line contain a string length 1 26 consist distinct lowercase english letter letter good letter others bad second line contain pattern — a string s lowercase english letter character ` ` ? '' ` ` * '' ( 1 ≤ |s| ≤ 105 ) guarantee character ` ` * '' occur s third line contain integer n ( 1 ≤ n ≤ 105 ) — number query <unknown> line follow contain single non - empty string consist lowercase english letter — a query string guarantee total length query string greater 105 . print n line : i - th print ` ` yes '' pattern match i - th query string ` ` '' otherwise choose case ( lower upper ) letter arbitrary first example replace ` ` ? '' good letter ` ` a '' ` ` b '' see answer first query ` ` yes '' answer second query ` ` '' ca n't match third letter explanation second example,['implementation'],1600.0
818/B,"n children stand a circle play a game children 's number clockwise order form a permutation a1 a2 ... length n. integer sequence integer 1 n appear exactly game consist m step step current leader index i count ai people clockwise order start next person last one point leader become new leader give number l1 l2 ... lm — indices leaders begin step child number l1 first leader game write a program restore a possible permutation a1 a2 ... , multiple solutions print solution print -1 . first line contain two integer number n m ( 1 ≤ n m ≤ 100 ) second line contain m integer number l1 l2 ... lm ( 1 ≤ li ≤ n ) — indices leaders begin step print permutation n number a1 a2 ... leaders game exactly l1 l2 ... lm rule follow multiple solutions print permutation satisfy describe condition print -1 . let 's follow leadership first example :",['implementation'],1600.0
815/E,"'s long events previous problems karen move student life look relocate a new neighborhood neighborhood consist n house a straight line label 1 n leave right equal distance apart everyone neighborhood love peace quiet , whenever a new person move neighborhood always choose house whose minimum distance occupy house maximize multiple house maximum possible minimum distance choose leftmost one note first person arrive always move house 1 . karen k - th person enter neighborhood everyone include follow rule house move ? first line input contain two integers n k ( 1 ≤ k ≤ n ≤ 1018 ) describe number house neighborhood karen k - th person move respectively output a single integer a line label house karen move first test case 6 house neighborhood karen fourth person move : second test case 39 house neighborhood karen third person move :",['implementation'],2900.0
813/A,pasha participate a contest one well - known website time want win contest anything get first place ! contest consist n problems pasha solve ith problem ai time units ( solutions always correct ) moment time think a solution one problems ( solve two problems time ) time pasha spend send solutions negligible pasha send number solutions moment unfortunately many participants website always work pasha receive information website work m time periods jth period represent start moment lj end moment rj course pasha send solution website work word pasha send solution moment t iff exist a period x <unknown> ≤ t ≤ <unknown> pasha want know best possible result need tell minimal moment time able solutions problems submit act optimally say 's impossible matter pasha solve problems first line contain one integer n ( 1 ≤ n ≤ 1000 ) — number problems second line contain n integers ai ( 1 ≤ ai ≤ 105 ) — time pasha need solve ith problem third line contain one integer m ( 0 ≤ m ≤ 1000 ) — number periods time website work next m line represent periods jth line contain two number lj rj ( 1 ≤ lj < rj ≤ 105 ) — start end moment jth period guarantee periods intersect give chronological order every j > 1 condition lj > rj - 1 meet pasha solve submit problems end contest print minimal moment time solutions submit otherwise print ` ` -1 '' ( without bracket ) first example pasha act like : solve second problem 4 units time send immediately spend 3 time units solve first problem send 7 time units contest start moment website start work second example pasha invent solution website stop work last time third example pasha send solution exactly end first period,['implementation'],1100.0
812/D,"sagheer work a kindergarten n children m different toy children use well - <unknown> <unknown> play toy : children n't like play 's never share toy a child request a toy <unknown> toy child depend whether toy free toy free sagheer give child otherwise child wait ca n't request another toy children smart detect wait forever get toy want case start cry word a cry set a set children child wait a toy keep another child set , reach a scenario children make request lovely set except one child x still one last request lovely set children play others wait a toy child cry one yet finish play child x currently wait toy make last request get toy otherwise make request right away child x make last request many children start cry ? give scenario q independent query query form x y mean last request child x toy y. task help sagheer find size maximal cry set child x make last request first line contain four integers n m k q ( 1 ≤ n m k q ≤ 105 ) — number children toy scenario request query next k line contain two integers a b ( 1 ≤ a ≤ n 1 ≤ b ≤ m ) — a scenario request mean child a request toy b. request give order make children next q line contain two integers x y ( 1 ≤ x ≤ n 1 ≤ y ≤ m ) — request add scenario mean child x request toy y get toy wait ( ) guarantee scenario request consistent child initially cry scenario request distinct query coincide a scenario request query print a single line number children start cry child x make last request toy y. please answer query independent first example child 1 wait toy 2 child 2 child 2 wait top 3 child 3 child 3 make last request toy request hold child 1 . three children wait a toy hold another child one play three start cry second example begin child i hold toy i 1 ≤ i ≤ 4 . children 1 3 complete lovely set finish play toy 3 free toy 1 take child 2 complete lovely set finish toy 1 2 free child 5 take toy 1 . :",['implementation'],2700.0
812/A,"sagheer walk street come intersection two roads road represent two part part 3 lanes get intersection ( one direction ) 3 lanes get intersection 4 part total part 4 light one lane get intersection ( l — leave s — straight r — right ) a light p a pedestrian cross accident possible a car hit a pedestrian happen light a pedestrian cross part light a lane get part green time , sagheer monitor configuration traffic light task help detect whether accident possible input consist four line line describe a road part give a counter - clockwise order line contain four integers l s r p — leave straight right pedestrian light respectively possible value 0 red light 1 green light a single line print ` ` yes '' accident possible ` ` '' otherwise first example <unknown> possible cars part 1 hit pedestrians part 1 4 . also cars part 2 3 hit pedestrians part 4 . second example car pass pedestrian cross part 4 green pedestrian light , accident occur",['implementation'],1200.0
758/B,nothing eternal world kostya understand 7 - th <unknown> saw partially dead four - color garland a goal replace dead light bulbs however n't know many light bulbs color require guarantee four color least one light work know garland contain light bulbs four color : red blue yellow green garland make follow : take four consecutive light bulbs light bulbs color among example garland look like ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' look like ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' letter denote color : ' r ' — red ' b ' — blue ' y ' — yellow ' g ' — green use information color least one light bulb still work count number dead light bulbs four color first line contain string s ( 4 ≤ |s| ≤ 100 ) describe garland i - th symbol describe color i - th light bulb order begin garland : string s contain symbols except five describe guarantee give string least four letter ' r ' ' b ' ' y ' ' g ' guarantee string s correct garland blow light bulbs mean example line ` ` <unknown> ! ! ! b '' input data line print four integers <unknown> <unknown> <unknown> <unknown> — number dead light bulbs red blue yellow green color accordingly first example dead light bulbs second example obvious one blue bulb blow could light bulbs color place accord statements,['implementation'],1100.0
467/A,george recently enter <unknown> ( berland state university cool programmers ) george a friend alex also enter university move a dormitory george alex want live room dormitory n room total moment i - th room pi people live room accommodate qi people total ( pi ≤ qi ) task count many room free place george alex first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number room i - th next n line contain two integers pi qi ( 0 ≤ pi ≤ qi ≤ 100 ) — number people already live i - th room room 's capacity print a single integer — number room george alex move,['implementation'],800.0
757/A,bash want become a pokemon master one day although like a lot pokemon always fascinate bulbasaur soon things start get serious <unknown> turn <unknown> since young go catch bulbasaur come way catch a bulbasaur day take front page newspaper cut letter one a time anywhere front page newspaper form word ` ` bulbasaur '' ( without quote ) stick wall bash particular case — first letter ` ` bulbasaur '' must upper case rest must lower case think catch one bulbasaur repeat step leave part newspaper keep possible form word ` ` bulbasaur '' newspaper give text front page newspaper tell many <unknown> catch today ? note : uppercase lowercase letter consider different input contain a single line contain a string s ( 1 ≤ |s| ≤ 105 ) — text front page newspaper without space <unknown> mark |s| length string s. string s contain lowercase uppercase english letter i.e   output a single integer answer problem first case could pick : <unknown> second case way pick even a single bulbasaur third case rearrange string <unknown> get two word ` ` bulbasaur '',['implementation'],1000.0
753/B,problem a little bite unusual implement interaction a test system mean make query get responses online mode please sure use stream flush operation query 's output order leave part output buffer example c++ ' ve get use fflush ( stdout ) function java — call system.out.flush ( ) pascal — flush ( output ) bull cow ( also know cow bull pig bull bull <unknown> ) old code - <unknown> paper <unknown> game two players <unknown> similar <unknown> market board game <unknown> a sheet paper first player think a secret string string consist digits length 4 . digits string must different two equal digits allow second player try guess opponent 's string every guess first player give number match match digits right position ` ` bull '' different position ` ` cow '' thus a response a pair number — number ` ` bull '' number ` ` cow '' a try contain equal digits formally let 's secret string s second player try guess a string x. number ` ` bull '' a number position i ( 1 ≤ i ≤ 4 ) s [ i ] = x [ i ] number ` ` cow '' a number digits c s contain c position i ( i.e s [ i ] = c ) x contain c x [ i ] ≠ c. example secret string ` ` <unknown> '' opponent 's try ` ` <unknown> '' answer 2 bull 2 cow ( bull ` ` 0 '' ` ` 2 '' cow ` ` 4 '' ` ` 7 '' ) secret string ` ` 0123 '' opponent 's try ` ` <unknown> '' answer 1 bull 1 cow problem guess string s system choose know choose string consist 4 distinct digits make query test system query output a single 4 - digit string answer query number bull number cow system 's response equal ` ` 4 0 '' mean interaction problem program must terminate possible two reason — program either guess number x make invalid action ( example print letter instead digits ) program allow 50 query hack solutions participants provide a 4 - digit string contain distinct digits — secret string read answer query program must use standard input program receive pair non - negative integers input one pair per line first number a pair a number bull second one a number cow string s string xi print program system response equal ` ` 4 0 '' solution terminate test system let program read i - th pair integers input program display correspond system query output : print value xi a single line execute operation flush program must use standard output print query program must output request — 4 - digit string x1 x2 ... one per line output line program must execute flush operation program read answer query standard input program allow 50 query secret string s example ` ` 0123 '',['implementation'],1600.0
714/B,"today hedgehog filya go school first time ! teacher give a homework filya unable complete without help filya give array non - negative integers a1 a2 ... , first pick integer x add x elements array ( ) subtract x elements ( also ) change elements want elements array equal wonder 's possible pick integer x change elements array use x order make elements equal first line input contain integer n ( 1 ≤ n ≤ 100 000 ) — number integers filya 's array second line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 109 ) — elements array 's impossible make elements array equal use process give problem statement print ` ` '' ( without quote ) line output otherwise print ` ` yes '' ( without quote ) first sample filya select x = 1 add first last elements array subtract second third elements",['implementation'],1200.0
712/B,"memory perform a walk two - dimensional plane start origin give a string s directions <unknown> : memory want end origin , a special trident trident replace character s ' l ' ' r ' ' u ' 'd ' however n't want wear trident want make minimum number edit possible please tell memory minimum number change need make produce a string walk end origin string first line contain string s ( 1 ≤ |s| ≤ 100 000 ) — instructions memory give a string satisfy condition output a single integer — minimum number edit require case 's possible change sequence a way bring memory origin output -1 . first sample test memory tell walk right right , easy see impossible edit instructions form a valid walk second sample test memory tell walk , right one possible solution change s ` ` <unknown> '' string use 1 edit minimum possible also end origin",['implementation'],1100.0
816/A,"karen get ready a new school day ! currently hh : mm give a 24 - hour format know karen love palindromes believe good luck wake time a palindrome minimum number minutes sleep , wake time a palindrome ? remember a palindrome a string read forward backwards instance 05:39 a palindrome 05:39 backwards <unknown> . hand 05:50 a palindrome 05:50 backwards 05:50 . first line input contain a single string format hh : mm ( 00 ≤ hh ≤ 23 00 ≤ mm ≤ 59 ) output a single integer a line minimum number minutes sleep , wake time a palindrome first test case minimum number minutes karen sleep 11 . wake 05:50 time a palindrome second test case karen wake immediately current time <unknown> already a palindrome third test case minimum number minutes karen sleep 1 minute wake <unknown> time a palindrome",['implementation'],1000.0
834/A,walk streets <unknown> city slastyona spot <unknown> sell a kind <unknown> toy popular nowadays – caramel spinner ! want join <unknown> immediately buy strange <unknown> <unknown> <unknown> form v - shaped piece caramel spinner well spin around invisible magic axis a specific point time a spinner take 4 position show ( one rotate 90 degrees relative previous fourth one follow first one ) : spinner spin start rotation describe a follow algorithm : spinner maintain position a second <unknown> switch next position clockwise counter - clockwise order depend direction spinner spin slastyona manage spinner rotate exactly n second fascinate <unknown> process completely forget direction spinner spin ! lucky manage recall start position want <unknown> direction give information know help two character first string – start end position a spinner position encode one follow character : v ( ascii code <unknown> lowercase v ) < ( ascii code 60 ) ^ ( ascii code <unknown> ) > ( ascii code <unknown> ) ( see picture <unknown> ) character separate a single space second string a single number n give ( 0 ≤ n ≤ 109 ) – duration rotation guarantee end position a spinner a result a n second spin directions assume give start position output <unknown> direction clockwise <unknown> – counter - clockwise undefined otherwise,['implementation'],900.0
784/E,input consist four line line contain a single digit 0 1 . output a single digit 0 1,['implementation'],2000.0
807/B,long ago codecraft-17 contest hold codeforces top 25 participants additionally random 25 participants get top 500 receive a codeforces t - shirt unfortunately n't manage get top 25 get top 500 take place p. elimination round 8vc venture cup 2017 hold announce codecraft-17 t - shirt <unknown> choose follow let s number point winner elimination round 8vc venture cup 2017 . follow pseudocode execute : ` ` <unknown> '' integer division operator ` ` mod '' modulo ( remainder division ) operator result pseudocode execution 25 integers 26 500 inclusive print number place participants get codecraft-17 t - shirts guarantee 25 print integers pairwise distinct value s. 're lead elimination round 8vc venture cup 2017 x point believe least y point current round enough victory change final score make number successful unsuccessful hack a successful hack bring 100 point unsuccessful one take 50 point 's difficult successful hack though want win current round time ensure get a codecraft-17 t - shirt smallest number successful hack achieve ? line contain three integers p x y ( 26 ≤ p ≤ 500 ; 1 ≤ y ≤ x ≤ 20000 ) — place codecraft-17 current score elimination round 8vc venture cup 2017 smallest number point consider sufficient win current round output a single integer — smallest number successful hack order win elimination round 8vc venture cup 2017 ensure get a codecraft-17 t - shirt 's guarantee goal achievable valid input data first example need hack since <unknown> point already bring t - shirt <unknown> - th place codecraft-17 ( ) case accord pseudocode t - shirts give participants follow place : second example two successful one unsuccessful hack make score equal <unknown> . third example need many 24 successful hack make score equal <unknown> . fourth example 's sufficient 6 unsuccessful hack ( successful ones ) make score equal <unknown> enough win current round also get t - shirt,['implementation'],1300.0
711/A,"zs coder chris baboon travel udayland ! get get special ioi bus ioi bus n row seat 4 seat row seat separate pair a walkway zs chris come place bus already occupy zs chris good friends <unknown> get a pair neighbour empty seat two seat consider neighbour row pair give configuration bus help zs chris determine sit ? first line input contain a single integer n ( 1 ≤ n ≤ 1000 ) — number row seat bus , n line follow line contain exactly 5 character first two denote first pair seat row third character denote walkway ( always equal ' | ' ) last two denote second pair seat row character except walkway equal ' o ' ' x ' ' o ' denote empty seat ' x ' denote occupy seat see sample case detail possible chris zs sit neighbour empty seat print ` ` yes '' ( without quote ) first line next n line print bus configuration character pair seat chris zs change character ' + ' thus configuration differ input one exactly two <unknown> ( equal ' o ' input ' + ' output ) pair seat chris zs print ` ` '' ( without quote ) a single line multiple solutions may print note follow incorrect configuration first sample case seat must pair <unknown>",['implementation'],800.0
747/E,"a rare article internet post without a possibility comment a polycarp 's website article comment fee comment polycarp 's website a non - empty string consist uppercase lowercase letter english alphabet comment tree - like structure mean comment except root comment ( comment highest level ) exactly one parent comment polycarp want save comment hard drive use follow format comment write follow format : example comment look like : first comment write ` ` hello,2 ok,0 bye,0 '' second write ` ` test,0 '' third comment write ` ` one,1 two,2 a,0 b,0 '' whole comment fee write : ` ` hello,2 ok,0 bye,0 test,0 one,1 two,2 a,0 b,0 '' a give comment fee format specify print comment a different format : first line contain non - empty comment fee describe format consist uppercase lowercase letter english alphabet digits <unknown> guarantee comment a non - empty string consist uppercase lowercase english character number comment integer ( consist least one digit ) either equal 0 contain lead zero length whole string exceed 106 . guarantee give structure comment valid print comment a format give statement level nest comment print order give input first example explain statements",['implementation'],1700.0
705/A,dr . <unknown> banner hat enemies ( like others n't ) know barely talk turn incredible hulk 's ask help express feel hulk like <unknown> much like feel complicate n layer first layer hate second one love third one hate ... example n = 1 feel ` ` i hate '' n = 2 's ` ` i hate i love '' n = 3 's ` ` i hate i love i hate '' please help dr . banner line input contain a single integer n ( 1 ≤ n ≤ 100 ) — number layer love hate print dr . banner 's feel one line,['implementation'],800.0
703/C,mishka enjoy trip ... chris a little brown bear one know meet mishka a long time together ( exclude current trip ) however best friends important john chris ' best friend walk friend john give chris follow problem : infinite horizontal road width w bound line y = 0 y = w a bus move present a convex polygon n vertices bus move continuously a constant speed v a straight ox line direction decrease x coordinate thus time x coordinate point change formally time t x coordinate point decrease <unknown> . a pedestrian point ( 0 0 ) move a vertical pedestrian cross present a segment connect point ( 0 0 ) ( 0 w ) speed exceed u. thus pedestrian move a straight line oy direction speed exceed u leave road border pedestrian instantly change speed thus example stop instantly please look sample note picture better understand consider pedestrian hit bus moment point locate lie strictly inside bus polygon ( mean point lie polygon vertex edge pedestrian hit bus ) give bus position moment 0 . please help chris determine minimum amount time pedestrian need cross road reach point ( 0 w ) hit bus first line input contain four integers n w v u ( 3 ≤ n ≤ 10 000 1 ≤ w ≤ 109 1 ≤ v u ≤ 1000 ) — number bus polygon vertices road width bus speed pedestrian speed respectively next n line describe polygon vertices counter - clockwise order i - th contain pair integers xi yi ( - 109 ≤ xi ≤ 109 0 ≤ yi ≤ w ) — coordinate i - th polygon point guarantee polygon non - degenerate print single real t — time pedestrian need <unknown> road hit bus answer consider correct relative absolute error n't exceed 10 - 6 . follow image describe initial position first sample case :,['implementation'],2100.0
703/A,mishka a little polar bear know little bear love spend free time play dice chocolates a wonderful <unknown> morning walk around block ice mishka meet friend chris start play game rule game simple : first number round n define every round players throw a cubical dice distinct number 1 6 write face player whose value throw dice greater win round case player dice value equal one a winner average player round winner game case two players number round result game draw mishka still little ca n't count win losses ask watch game determine result please help ! first line input contain single integer n n ( 1 ≤ n ≤ 100 ) — number game round next n line contain round description i - th contain pair integers mi ci ( 1 ≤ mi ci ≤ 6 ) — value dice upper face mishka 's chris ' throw i - th round respectively mishka winner game print ` ` mishka '' ( without quote ) line chris winner game print ` ` chris '' ( without quote ) line result game draw print ` ` friendship magic ! <unknown> '' ( without quote ) line first sample case mishka lose first round win second third round thus winner game second sample case mishka win first round chris win second round game end draw score <unknown> . third sample case chris win first round winner next two round winner game chris,['implementation'],800.0
702/C,give n point straight line — position ( x - coordinates ) cities m point line — position ( x - coordinates ) cellular tower tower work way — provide cellular network cities locate distance r tower task find minimal r city provide cellular network i.e city least one cellular tower distance r. r = 0 a tower provide cellular network point locate one tower provide cellular network number cities cities must distance r tower first line contain two positive integers n m ( 1 ≤ n m ≤ 105 ) — number cities number cellular tower second line contain a sequence n integers a1 a2 ... ( - 109 ≤ ai ≤ 109 ) — coordinate cities allow number cities point coordinate ai give non - decreasing order third line contain a sequence m integers b1 b2 ... bm ( - 109 ≤ bj ≤ 109 ) — coordinate cellular tower allow number tower point coordinate bj give non - decreasing order print minimal r city cover cellular network,['implementation'],1500.0
716/A,"zs coder cod a crazy computer n't type a word a c consecutive second everything type disappear ! formally type a word second a next word second b b - a ≤ c new word append word screen b - a > c everything screen disappear word type appear screen example c = 5 type word second 1 3 8 14 19 20 second 8 3 word screen , everything disappear second 13 nothing type second 14 19 another two word type finally second 20 one word type a total 3 word remain screen 're give time zs coder type word determine many word remain screen finish type everything first line contain two integers n c ( 1 ≤ n ≤ 100 000 1 ≤ c ≤ 109 ) — number word zs coder type crazy computer <unknown> respectively next line contain n integers t1 t2 ... tn ( 1 ≤ t1 < t2 < ... < tn ≤ 109 ) ti denote second zs coder type i - th word print a single positive integer number word remain screen n word type word second tn first sample already explain problem statement second sample type first word second 1 disappear next word type second 3 3 - 1 > 1 . similarly 1 word remain second 9 . a word type second 10 two word screen old word wo n't disappear 10 - 9 ≤ 1",['implementation'],800.0
699/B,give a description a depot a rectangular checker field n × m size cell a field empty ( ` ` . '' ) occupy a wall ( ` ` * '' ) one bomb lay bomb cell ( x y ) trigger wipe wall row x wall column y. determine possible wipe wall depot place trigger exactly one bomb bomb lay empty cell a cell occupy a wall first line contain two positive integers n m ( 1 ≤ n m ≤ 1000 ) — number row columns depot field next n line contain m symbols ` ` . '' ` ` * '' — description field j - th symbol i - th stand cell ( i j ) symbol equal ` ` ` ` correspond cell empty otherwise equal ` ` * '' correspond cell occupy a wall impossible wipe wall place trigger exactly one bomb print ` ` '' first line ( without quote ) otherwise print ` ` yes '' ( without quote ) first line two integers second line — coordinate cell bomb lay multiple answer print,['implementation'],1400.0
691/C,give a positive decimal number x. task convert ` ` simple exponential notation '' let x = <unknown> 1 ≤ a < 10 general case ` ` simple exponential notation '' look like ` ` <unknown> '' b equal zero part ` ` eb '' skip a integer write without decimal point also extra zero a b. line contain positive decimal number x. length line exceed 106 . note give large number ca n't use standard built - in data type ` ` float '' ` ` double '' print line — ` ` simple exponential notation '' give number x,['implementation'],1800.0
691/B,let 's call a string ` ` s - palindrome '' symmetric middle string example string ` ` <unknown> '' ` ` s - palindrome '' string ` ` aa '' string ` ` aa '' ` ` s - palindrome '' second half a mirror reflection first half give a string s. check string ` ` s - palindrome '' line contain string s ( 1 ≤ |s| ≤ 1000 ) consist english letter print ` ` tak '' string s ` ` s - palindrome '' ` ` nie '' otherwise,['implementation'],1600.0
691/A,accord rule berland <unknown> a jacket fasten button except one necessarily last one also jacket one button fasten jacket <unknown> open give a jacket n button determine fasten a right way first line contain integer n ( 1 ≤ n ≤ 1000 ) — number button jacket second line contain n integers ai ( 0 ≤ ai ≤ 1 ) number ai = 0 i - th button fasten otherwise ai = 1 . line print word ` ` yes '' jacket fasten a right way otherwise print word ` ` '',['implementation'],1000.0
689/A,swim beach mike accidentally drop <unknown> water worry buy a <unknown> replacement phone old - <unknown> keyboard keyboard ten digital equal - <unknown> key locate follow way : together old phone lose contact remember way finger move put number one formally consider finger movements a sequence vectors connect center key press consecutively put a number example finger movements number ` ` <unknown> '' finger movements number ` ` <unknown> '' : mike already put a number ` ` finger memory '' start call worry sure call correct number ? word number finger movements ? first line input contain integer n ( 1 ≤ n ≤ 9 ) — number digits phone number mike put second line contain string consist n digits ( character ' 0 ' ' 9 ' ) represent number mike put phone number finger movements mike sure call correct number print ` ` yes '' ( without quote ) line otherwise print ` ` '' ( without quote ) first line find picture clarify first sample case statement,['implementation'],1400.0
706/A,"vasiliy live point ( a b ) coordinate plane hurry work want get house soon possible new app suggest n available beru - taxi nearby i - th taxi locate point ( xi yi ) move a speed vi consider n <unknown> move directly vasiliy a maximum possible speed compute minimum time vasiliy get beru - taxi cars first line input contain two integers a b ( - 100 ≤ a b ≤ 100 ) — coordinate vasiliy 's home second line contain a single integer n ( 1 ≤ n ≤ 1000 ) — number available beru - taxi cars nearby i - th follow n line contain three integers xi yi vi ( - 100 ≤ xi yi ≤ 100 1 ≤ vi ≤ 100 ) — coordinate i - th car speed 's allow several cars locate point also cars may locate exactly point vasiliy live print a single real value — minimum time vasiliy need get beru - taxi cars answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer a answer jury b. checker program consider answer correct , first sample first taxi get vasiliy time 2 second time 1 therefore 1 answer second sample cars 2 3 arrive simultaneously",['implementation'],900.0
688/A,arya n opponents school day fight opponents present day opponents fight plan guarantee win implement plan require presence mean one day least one arya 's opponents absent school arya beat present opponents otherwise opponents present beat arya opponent arya know schedule — whether go present particular day tell maximum number consecutive days beat present opponents note day opponents present arya still consider beat present opponents first line input contain two integers n d ( 1 ≤ n d ≤ 100 ) — number opponents number days respectively i - th follow d line contain a string length n consist character ' 0 ' ' 1 ' j - th character string ' 0 ' j - th opponent go absent i - th day print integer — maximum number consecutive days arya beat present opponents first second sample arya beat present opponents d days third sample arya beat opponents days 1 3 4 opponents beat days 2 5 . thus maximum number consecutive win days 2 happen days 3 4,['implementation'],800.0
686/A,adventure magic mirror kay gerda return home sometimes give free ice cream kid summer start day x ice cream pack since ice cream free people start stand queue kay gerda 's house even night person queue want either take several ice cream pack friends give several ice cream pack kay gerda ( <unknown> bring ice cream stand queue ) a carrier d ice cream pack come house kay gerda take pack a child want take d ice cream pack come house kay gerda give d pack enough ice cream otherwise child get ice cream leave distress kay want find amount ice cream people leave queue gerda want find number distress kid first line contain two space - separated integers n x ( 1 ≤ n ≤ 1000 0 ≤ x ≤ 109 ) next n line contain a character ' + ' ' - ' integer di separate a space ( 1 ≤ di ≤ 109 ) record ` ` + di '' i - th line mean a carrier di ice cream pack occupy i - th place start queue record ` ` - di '' mean a child want take di pack stand i - th place print two space - separated integers — number ice cream pack leave operations number kid leave house distress consider first sample,['implementation'],800.0
685/D,snow queen tell kay form a word ` ` eternity '' use piece ice kay eager deal task become free snow queen give world a pair skate behind palace snow queen infinite field consist cells n piece ice spread field piece occupy exactly one cell two piece occupy cell estimate difficulty task kay look square size k × k cells corner locate corner cells side parallel coordinate axis count number piece ice inside method give <unknown> difficulty part field however kay also want estimate total difficulty come follow criteria : x ( 1 ≤ x ≤ n ) want count number square size k × k exactly x piece ice inside please help kay estimate difficulty task give snow queen first line input contain two integers n k ( 1 ≤ n ≤ 100 000 1 ≤ k ≤ 300 ) — number piece ice value k respectively next n line contain two integers xi yi ( - 109 ≤ xi yi ≤ 109 ) — coordinate cell contain i - th piece ice 's guarantee two piece ice occupy cell print n integers : number square size k × k contain exactly 1 2 ... n piece ice,['implementation'],2600.0
681/A,codeforces user ' handle color depend rat — red rat greater equal 2400 ; orange rat less 2400 greater equal <unknown> etc time participant take part a rat contest rat change depend performance anton want color handle become red consider performance rat contest good outscore participant whose handle color red contest rat increase anton write a program analyse contest result determine whether perform good able ? first line input contain a single integer n ( 1 ≤ n ≤ 100 ) — number participants anton outscore contest next n line describe participants result : i - th consist a participant handle <unknown> two integers beforei afteri ( - 4000 ≤ beforei afteri ≤ 4000 ) — participant 's rat contest respectively handle a non - empty string consist 10 character might lowercase uppercase english letter digits character « _ » « - » character guarantee handle distinct print « yes » ( quote clarity ) anton perform good contest « » ( quote clarity ) otherwise first sample anton outscore user handle <unknown> whose handle color red contest rat increase contest second sample <unknown> 's rat increase contest <unknown> 's <unknown> 's handle color red contest,['implementation'],800.0
680/A,a little bear limak play a game five card one number write card number a positive integer limak discard ( throw ) card goal minimize sum number write remain ( discard ) card allow discard two three card number course wo n't discard card 's impossible choose two three card number give five number write card <unknown> find minimum sum number remain card ? line input contain five integers t1 t2 <unknown> t4 <unknown> ( 1 ≤ ti ≤ 100 ) — number write card print minimum possible sum number write remain card first sample limak card number 7 3 7 3 20 . limak one follow ask minimize sum answer 26 . second sample 's impossible find two three card number hence limak nothing sum 7 + 9 + 1 + 3 + 8 = 28 . third sample card number 's optimal discard three card sum two remain number 10 + 10 = 20,['implementation'],800.0
679/C,"a grid n row n columns cell either empty ( denote ' . ' ) block ( denote ' x ' ) two empty cells directly connect share a side two cells ( r1 c1 ) ( locate row r1 column c1 ) ( r2 c2 ) connect exist a sequence empty cells start ( r1 c1 ) finish ( r2 c2 ) two consecutive cells sequence directly connect a connect component a set empty cells two cells component connect cell set connect cell set friend limak a big <unknown> bear able destroy obstacles range precisely choose a square size k × k grid limak transform block cells empty ones however ask limak help choose square must completely inside grid 's possible limak wo n't change anything cells empty anyway like big connect components limak help maximum possible size biggest connect component grid ? first line input contain two integers n k ( 1 ≤ k ≤ n ≤ 500 ) — size grid limak 's range respectively next n line contain a string n character denote i - th row grid character ' . ' ' x ' denote empty cell a block one respectively print maximum possible size ( number cells ) biggest connect component use limak 's help first sample choose a square size 2 × 2 . 's optimal choose a square red <unknown> leave draw , get a connect component 10 cells mark blue right draw",['implementation'],2400.0
678/B,girl taylor a beautiful calendar year y. calendar days give days week : monday <unknown> wednesday thursday <unknown> <unknown> sunday calendar beautiful want know next year y calendar exactly help taylor find year note leap years <unknown> days year leap divisible 400 divisible 4 100 ( https : //en.wikipedia.org / wiki / <unknown> ) line contain integer y ( 1000 ≤ y < <unknown> ) — year calendar print integer y ' — next year y calendar note find first year y calendar today monday <unknown> <unknown> 2016,['implementation'],1600.0
699/A,a launch a new powerful unusual collider soon locate along a straight line n particles launch inside locate a straight line two particles locate point coordinate particles coincide distance meter center collider xi coordinate i - th particle position collider time coordinate particle position even integers know direction particle movement — move right leave collider 's launch start particles begin move simultaneously time collider 's launch start particle move straight leave straight right constant speed 1 meter per microsecond collider big enough particles leave <unknown> time write program find moment first collision two particles collider word find number microseconds first moment two particles point first line contain positive integer n ( 1 ≤ n ≤ 200 000 ) — number particles second line contain n symbols ` ` l '' ` ` r '' i - th symbol equal ` ` l '' i - th particle move leave otherwise i - th symbol equal ` ` r '' i - th particle move right third line contain sequence pairwise distinct even integers x1 x2 ... xn ( 0 ≤ xi ≤ 109 ) — coordinate particles order leave right guarantee coordinate particles give increase order first line print integer — first moment ( microseconds ) two particles point explosion print integer -1 collision particles n't happen first sample case first explosion happen 1 microsecond particles number 1 2 simultaneously point coordinate 3 . second sample case explosion particles simultaneously point,['implementation'],1000.0
717/C,harry water <unknown> her - <unknown> - oh - <unknown> friends start a new school year <unknown> school <unknown> <unknown> time happy see a long time sun <unknown> bird <unknown> flower <unknown> potions class teacher professor snipe <unknown> usual due <unknown> fuel <unknown> life give a lot homework potions class n students assign a single task students certain task faster others thus want redistribute task student still exactly one task task finish student laziness level task difficulty level professor snipe try hard improve work <unknown> student ’ s laziness level equal task ’ s difficulty level set value give sequence a ai represent laziness level i - th student difficulty task time a student need finish a task equal product laziness level task ’ s difficulty wonder minimum possible total time must spend finish task distribute optimal way person receive one task task give one person print answer modulo 10 007 . first line input contain integer n ( 1 ≤ n ≤ 100 000 ) — number task next n line contain exactly one integer number ai ( 1 ≤ ai ≤ 100 000 ) — difficulty initial task laziness i - th students print minimum total time finish task modulo 10 007 . first sample students switch task able finish 3 + 3 = 6 time units,['implementation'],1200.0
719/A,every summer vitya come visit grandmother countryside summer get a huge <unknown> every <unknown> know one treat <unknown> moon go thus vitya catch moment moon moon cycle last 30 days size visible part moon ( vitya 's units ) day 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 cycle repeat thus second 1 go 0 . internet countryside vitya watch moon n consecutive days days write size visible part moon help find whether moon next day determine data first line input contain a single integer n ( 1 ≤ n ≤ 92 ) — number consecutive days vitya watch size visible part moon second line contain n integers ai ( 0 ≤ ai ≤ 15 ) — vitya 's record 's guarantee input data consistent vitya sure size visible part moon day n + 1 less size visible part day n print ` ` '' line output might sure size visible part increase print ` ` '' 's impossible determine exactly happen moon print -1 . first sample size moon next day equal 8 thus answer ` ` '' second sample size moon next day 11 thus answer ` ` '' third sample way determine whether size moon next day 7 9 thus answer -1,['implementation'],1100.0
710/A,king stand standard chess board give position format ` ` cd '' c column ' a ' ' h ' d row ' 1 ' ' 8 ' find number move permit king check king 's move https : //en.wikipedia.org / wiki / king _ ( chess ) line contain king 's position format ` ` cd '' ' c ' column ' a ' ' h ' 'd ' row ' 1 ' ' 8 ' print integer x — number move permit king,['implementation'],800.0
686/B,little robber girl like scare animals zoo fun decide arrange animals a row order non - decreasing height however animals scar could n't stay right place robber girl angry first decide arrange animals repeatedly name number l r r - l + 1 even animals occupy position l r inclusively rearrange follow : animal position l swap place animal position l + 1 animal l + 2 swap animal l + 3 ... finally animal position r - 1 swap animal r. help robber girl arrange animals order non - decreasing height name 20 000 segment since otherwise robber girl become bore start scar animals first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number animals robber girl 's zoo second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) ai height animal occupy i - th place print sequence operations rearrange animals non - decreasing height output contain several line i - th line contain two space - separated integers li ri ( 1 ≤ li < ri ≤ n ) — descriptions segment robber girl name segment describe order operations perform number operations exceed 20 000 . animals arrange correctly start allow output nothing note n't minimize number operations solution perform 20 000 operations allow,['implementation'],1100.0
