,description,tags,rating
1486/B,friends live $$$ n $$$ house house locate a 2d plane a point integer coordinate might different house locate point mayor city ask place build eastern exhibition find number place ( point integer coordinate ) <unknown> distance house exhibition minimal exhibition build point house distance two point $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ $$$ <unknown> - <unknown> + <unknown> - <unknown> $$$ $$$ |x| $$$ absolute value $$$ x $$$ first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000 ) $$$ — number test case first line test case contain a single integer $$$ n $$$ $$$ ( 1 \leq n \leq 1000 ) $$$ next $$$ n $$$ line describe position house $$$ ( x_i y_i ) $$$ $$$ ( 0 \leq x_i y_i \leq 1000000000 ) $$$ 's guarantee sum $$$ n $$$ exceed $$$ 1000 $$$ test case output a single integer - number different position exhibition exhibition build point house image example test case blue dot stand house green — possible position exhibition first test case second test case third test case fourth test case fifth test case sixth test case house locate $$$ ( 0 0 ) $$$,['geometry'],1500.0
75/E,get a new job 's interest a ship captain first task move ship one point another point sure want move minimum cost 's well know shortest distance 2 point length line segment 2 point unfortunately island sea sometimes wo n't able move ship line segment 2 point move safe point a point call safe 's line segment start end point 's island 's edge lucky get clever strong workers help trip help move ship sea take 1 egyptian pound move unit sea carry ship ( yes strong ) walk island take 2 egyptian pound move unit island money give divide workers number workers matter move ship island edge consider move sea a sea map decide minimum cost trip start point ( xstart ystart ) end point ( xend yend ) point different island a convex polygon 2 polygon point line also start end point wo n't inside boundary island point polygon give <unknown> - clockwise order first line contain 4 integers xstart ystart xend yend ( - 100 ≤ xstart ystart xend yend ≤ 100 ) second line contain integer n number point polygon ( 3 ≤ n ≤ 30 ) follow a line contain n pair integers x y coordinate point ( - 100 ≤ x y ≤ 100 ) polygon point distinct print one line contain minimum possible cost absolute relative error answer exceed 10 - 6,['geometry'],2400.0
33/D,berland face dark time army evil lord van de mart go conquer whole kingdom council war call berland 's king valery <unknown> come n knight long discussions become clear kingdom exactly n control point ( enemy conquer least one point war lose ) knight occupy one point berland divide m + 1 regions m fence way get one region another climb fence fence a circle a plane two fence common point control point fence give k pair number ai bi pair find : many fence a knight control point index ai climb reach control point bi ( case van de mart attack control point bi first ) knight rid a horse ( difficult throw a horse a fence ) find pair minimum amount fence climb first input line contain three integers n m k ( 1 ≤ n m ≤ 1000 0 ≤ k ≤ 100000 ) follow n line contain two integers kxi kyi ( - 109 ≤ kxi kyi ≤ 109 ) — coordinate control point index i. control point coincide follow m line describe fence index i three integers ri cxi cyi ( 1 ≤ ri ≤ 109 - 109 ≤ cxi cyi ≤ 109 ) — radius center circle correspond fence situate follow k pair integers ai bi ( 1 ≤ ai bi ≤ n ) a separate line — request answer ai bi coincide output exactly k line contain one integer — answer correspond request,['geometry'],2000.0
1036/E,give $$$ n $$$ segment a cartesian plane segment 's endpoints integer coordinate segment intersect two segment lie line count number distinct point integer coordinate cover least one segment first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — number segment next $$$ n $$$ line contain four integers $$$ ax_i ay_i bx_i by_i $$$ ( $$$ -1000000 \le ax_i ay_i bx_i by_i \le 1000000 $$$ ) — coordinate endpoints $$$ a $$$ $$$ b $$$ ( $$$ a \ne b $$$ ) $$$ i $$$ -th segment guarantee two segment lie line print a single integer — number distinct point integer coordinate cover least one segment image first example : several key point mark blue answer contain non - <unknown> point well image second example :,['geometry'],2400.0
1571/H,"ira develop a computer game game feature randomize generation difficulty level achieve randomize difficulty enemies level randomly replace stronger ones describe level game look let 's introduce a coordinate system a way $$$ ox $$$ axis go leave right $$$ oy $$$ axis go bottom top a level a rectangle opposite corner point $$$ ( 0 0 ) $$$ $$$ ( a b ) $$$ enemy 's position a point rectangle , ira implement one type enemy game two different versions — basic upgrade versions enemies ira implement fire laser ray several directions : laser ray pass enemies block border level ( side rectangle denote level ) enemies unaffected lasers level ira work $$$ n $$$ enemies $$$ i $$$ -th enemy point $$$ ( x_i y_i ) $$$ a probability $$$ p_i $$$ upgrade ( 's either upgrade probability $$$ p_i $$$ basic probability $$$ 1 - p_i $$$ ) events independent ira want estimate expect difficulty consider a good way evaluate difficulty level count number part level divide laser ray , want calculate expect number part help evaluation level ! first line contain three integers $$$ n $$$ $$$ a $$$ $$$ b $$$ ( $$$ 1 \le n \le 100 $$$ ; $$$ 2 \le a b \le 100 $$$ ) — number enemies level dimension level $$$ n $$$ line follow $$$ i $$$ -th contain three integers $$$ x_i $$$ $$$ y_i $$$ $$$ p'_i $$$ ( $$$ 1 \le x_i \le a - 1 $$$ ; $$$ 1 \le y_i \le b - 1 $$$ ; $$$ 1 \le p'_i \le <unknown> $$$ ) mean $$$ i $$$ -th enemy locate $$$ ( x_i y_i ) $$$ a probability $$$ \frac { p'_i } { 1000000 } $$$ upgrade two enemies locate point print one integer — expect number part lasers divide level take modulo $$$ 998244353 $$$ ( i. e. let expect number part $$$ \frac { x } { y } $$$ irreducible fraction ; print $$$ x \cdot y^ { -1 } \bmod 998244353 $$$ $$$ y^ { -1 } $$$ a number $$$ y \cdot y^ { -1 } \bmod 998244353 = 1 $$$ ) explanation first example : probability $$$ \frac { 1 } { 2 } $$$ enemy upgrade level look like ( $$$ 4 $$$ part ) : probability $$$ \frac { 1 } { 2 } $$$ enemy upgrade level look like ( $$$ 8 $$$ part ) : expect number part $$$ 4 \cdot \frac { 1 } { 2 } + 8 \cdot \frac { 1 } { 2 } = 6 $$$",['geometry'],2900.0
559/D,gerald get tire play board game usual six - sided die buy a toy call randomizer function follow a randomizer coordinate plane a strictly convex polygon paint polygon call a basic polygon shake a randomizer draw nondegenerate ( i.e a non - zero area ) convex polygon vertices vertices basic polygon result roll ( precisely result shake ) consider number point integer coordinate strictly inside ( point border consider ) select polygon gerald wonder : expect result shake randomizer ? shake randomizer consider possible non - degenerate convex polygons vertices vertices basic polygon let 's assume k versions polygons randomizer choose probability first line input contain a single integer n ( 3 ≤ n ≤ 100 000 ) — number vertices basic polygon next n line contain coordinate vertices basic polygon i - th line contain two integers xi yi ( - 109 ≤ xi yi ≤ 109 ) — coordinate i - th vertex polygon vertices give counter - clockwise order print seek expect value absolute relative error 10 - 9 . a polygon call strictly convex convex vertices lie line let 's assume a random variable take value x1 ... xn probabilities p1 ... pn correspondingly expect value variable equal,['geometry'],2800.0
1578/I,"interactive problem goal find a circle a plane shoot ray get distance circle a result interactor three hide integer parameters determine advance test n't know — $$$ x_c $$$ $$$ y_c $$$ $$$ r_c $$$ $$$ ( x_c y_c ) $$$ coordinate circle 's center $$$ r_c $$$ radius absolute value $$$ x_c $$$ $$$ y_c $$$ $$$ r_c $$$ exceed $$$ 100000 $$$ $$$ 1 \leq r_c \leq \sqrt { <unknown> + <unknown> } - 1 $$$ shoot ray extend origin $$$ ( 0,0 ) $$$ go via a point $$$ ( x_q y_q ) $$$ integer coordinate specify ray get a distance ray circle $$$ 0 $$$ ray intersect circle interaction start program print a query standard output finish program find print answer problem query a form ` ` ? $$$ x_q $$$ $$$ y_q $$$ ` ` $$$ x_q $$$ $$$ y_q $$$ integers ( $$$ <unknown> <unknown> \le 1000000 $$$ ; $$$ x_q \ne 0 $$$ $$$ y_q \ne 0 $$$ ) interactor output a line a single floating - point number — distance a query ray a circle precise $$$ 10^ { <unknown> } $$$ absolute value program make next query read output , allow $$$ 60 $$$ query end interaction print answer line ` ` ! $$$ x_c $$$ $$$ y_c $$$ $$$ r_c $$$ ` ` flush output exit note output interactor actually round 10 - th digit a decimal point stress - <unknown> solution <unknown> make sure also perform correspond round",['geometry'],3300.0
107/E,"night graduation ceremony <unknown> students german university cairo ( guc ) play dart 's real dart board available photograph members guc upper management use , n rectangular photos place wall overlap arbitrary even coincide photos necessarily place horizontally vertically could also rotate pin wall score one dart throw simply number photos dart go fatma make a throw score record remember make least one photo assume probability distribution throw equal across whole wall would expectation fatma 's score ? first line input contain integer n ( 1 ≤ n ≤ 500 ) — number photos wall follow n line describe photos contain 8 single - space - separated integers ( coordinate 4 vertices ) : x1 y1 x2 y2 x3 y3 x4 <unknown> photo a rectangle a nonzero area coordinate integers exceed 104 absolute value coordinate rectangle give either clockwise counterclockwise order print expect score throw answer accept absolute relative error exceed 10 - 6",['geometry'],2700.0
89/D,upon a time galaxy far far away ... <unknown> <unknown> find location a rebel ' base go destroy base ( whole planet base locate ) use death star rebel learn death star come decide use new secret weapon — space mine let 's describe a space mine 's build space mine shape like a ball ( 'll call mine body ) a certain radius r center point o. several spike <unknown> center spike represent a segment connect center mine point p ( transport long - <unknown> mine <unknown> ) <unknown> length segment connect o p. convenient describe point p a vector p p = o + p. death star shape like a ball radius r ( r exceed mine 's radius ) move a constant speed along v vector speed equal |v| moment rebel notice star death locate point a. rebel locate n space mine along death star 's way may regard mine idle death star know mine ' existence notice n't change direction movement soon star death touch mine ( body one spike ) mine burst destroy star death a touch situation a point space belong mine death star consider death star destroy move infinitely long time without touch mine help rebel determine whether succeed destroy death star use space mine succeed determine moment time happen ( start moment death star notice ) first input data line contain 7 integers ax ay az vx vy vz r. death star 's initial position direction movement radius ( - 10 ≤ vx vy vz ≤ 10 |v| > 0 0 < r ≤ 100 ) second line contain integer n number mine ( 1 ≤ n ≤ 100 ) follow n data block i - th describe i - th mine first line block contain 5 integers <unknown> <unknown> <unknown> ri mi coordinate mine centre radius body number spike ( 0 < ri < 100 0 ≤ mi ≤ 10 ) follow mi line describe spike i - th mine j - th describe i - th spike contain 3 integers <unknown> <unknown> <unknown> — coordinate vector give spike direct ( ) coordinate mine ' center center death star integers absolute value exceed 10000 . guarantee r > ri 1 ≤ i ≤ n. mine i ≠ j follow inequality fulfil : initially death star mine common point rebel succeed stop death star use space mine print time moment death star notice <unknown> death star touch a mine print ` ` -1 '' ( without quote ) answer absolute relative error 10 - 6 acceptable,['geometry'],2500.0
98/C,a unusual citizen live a far away kingdom — dwarf <unknown> however unusual name <unknown> thing ( besides everyone long ago get use call simply dwarf greg ) special dwarf greg — 's live 200 years ; besides live a crypt <unknown> <unknown> nobody ever see <unknown> moreover nobody ever see greg buy food 's nobody get <unknown> surprise <unknown> dragon 's <unknown> death cattle continue disappear field people <unknown> long sure harmless dragon never responsible disappear cattle ( consider dragon use <unknown> <unknown> view ) even 's worst part whole story worst part <unknown> several minutes ago dwarf greg <unknown> way get inside house ask help solve a problem point a short time ago greg decide order a new coffin ( know peculiar character surprise ) problem : a long directions l - shaped corridor lead greg 's crypt ca n't drag coffin corridor 's ask help ' ve formalize task a plane like : let corridor 's width turn equal a b correspondingly ( see picture ) corridor turn directly a right angle coffin a rectangle whose length width equal l w ( l ≥ w ) correspondingly dwarf greg already determine coffin 's length ( l ) base height ; task determine coffin 's maximally possible width ( w ) bring crypt besides due large mass ( <unknown> marble ! ) coffin equip rotate wheel ; therefore impossible <unknown> grind however arbitrary move rotations coffin plane become possible coffin may rotate arbitrarily drag crypt move corridor greg promise help <unknown> <unknown> ( i wonder ? ) n't well ... trust n't want know happen n't help ... first line contain three space - separated integers a b l problem 's statement ( 1 ≤ a b l ≤ 104 ) print maximally possible width a coffin absolute relative error 10 - 7 . a coffin give length positive width ( coffin would meet condition problem 's statement ) exist print ` ` poor head = ( ` ` ( without quote ) guarantee answer positive less 10 - 7 . hack also check meet condition first example answer restrict coffin 's length ( remember — coffin 's <unknown> larger 's length ) second example possible drag coffin corridor <unknown> rotate wheel : firstly drag forward one side <unknown> wall move forward adjacent side <unknown> initial movement direction ( remember — arbitrary move rotations coffin possible ),['geometry'],2500.0
106/E,galaxy contain n planets many different live creatures inhabit planet creature get trouble ! space rescuers know perfectly well always ready help anyone really need help need call space rescuers plan build largest history galaxy rescue station ; however rescue station 's location yet determine case real <unknown> rescuers want find a point galaxy would possible get remotest planet minimum possible time word rescuers need point space distance planet remotest minimal ( compare point possible point space ) unfortunately rescuers ca n't sole problem planets quite <unknown> consider point euclidean three - dimensional space distance point ( xi yi zi ) ( xj yj zj ) calculate formula rescue station position point space also coincide planet galaxy danger ! save space rescuers find require point first line input file contain integer n — number planets ( 1 ≤ n ≤ 100 ) follow n line contain information planets i - th line contain three integers xi yi zi — coordinate i - th planet ( - 104 ≤ xi yi zi ≤ 104 1 ≤ i ≤ n ) two planets coincide print first line output file three space - separated real number x0 y0 z0 — coordinate future base several solutions allow print answer accept distance point remotest planet differ <unknown> ' variant 10 - 6 absolute relative value,['geometry'],2100.0
127/A,mr . scrooge a busy man decide count time waste sort useless stuff evaluate lose profit already count time waste sleep eat mr . scrooge want count time waste sign paper mr . scrooge 's signature represent a polyline <unknown> ... scrooge sign like : first place a pen point a1 draw a segment point a1 point a2 draw a segment point a2 point a3 point stop sign take pen paper result line intersect partially repeat scrooge pay attention never change sign style scrooge make signature never take pen paper write speed constant — 50 millimeters per second scrooge sign exactly k paper throughout life <unknown> look find total time scrooge waste sign paper first line contain two integers n k ( 2 ≤ n ≤ 100 1 ≤ k ≤ 1000 ) follow n line contain coordinate polyline 's endpoints i - th one contain coordinate point ai — integers xi yi separate a space point ai different absolute value coordinate exceed 20 . coordinate measure millimeters print one real number — total time <unknown> waste sign paper second absolute relative error exceed 10 - 6,['geometry'],900.0
87/E,a long time ago somewhere depths <unknown> exist a powerful tribe govern great leader pinnie - the - wooh tribe conquer three <unknown> cities pinnie - the - wooh grow concern : control conquer <unknown> 's appeal priests supreme god mogohu - rea help priests convey god 's : control three cities put idol mogohu - rea — create a religious field cities however idol powerful easily drive people around mad unless balance exactly three sacrifice altars place one city balance idol altars place center mass system three point coincide idol count center mass consider altars mass pinnie - the - wooh think put idol a list hill suitable put idol help identify put idol without <unknown> fry brain cities ' population religious field city a shape a convex polygon three vertexes lie a straight line cities intersect <unknown> attach city a special ceremony besides must situate city 's territory ( possibly border ) thus may several altars a city 's territory exactly one attach city altars idol hill point plane may coincide hill take consideration independently altars ' location different hill may also different first follow descriptions three cities divide empty line descriptions follow format : first line contain integer n represent number polygon 's vertexes ( 3 ≤ n ≤ 5·104 ) next n line contain two integers xi yi coordinate polygon 's i - th vertex counterclockwise order cities ' description follow integer m ( 1 ≤ m ≤ 105 ) represent number hill next m line contain two integers xj yj coordinate j - th hill coordinate input data exceed 5·108 absolute value hill print a single line ` ` yes '' ( without quote ) ` ` '' ( without quote ) depend whether three sacrifice altars put balance idol hill ( 2 1 ) altars place point ( 1 0 ) ( 7 5 ) ( - 2 - 2 ) hill ( 1 1 ) — point ( 0 0 ) ( 6 4 ) ( - 3 - 1 ) many group three point trick suitable point hill,['geometry'],2600.0
154/E,"first ship earth <unknown> land <unknown> colonists manage build n necessary structure surface planet ( regard a plane construction regard point ) one day <unknown> record suspicious activity <unknown> colony decide use protective force field generate system protect colony possible trouble system work follow : surface contain a number generators field ( also consider point ) active range generator a circle radius r center location generator ( boundary circle also include range ) system activate stretch protective force field part surface within area generators ' activity , protect part intersection generators ' active range number generators available colonists limit system field generation consume a lot energy precisely energy consumption depend number generators directly proportional area protect field also necessary exist build locate within protect area determine smallest possible area protect part surface contain build first line contain two integers n r ( 1 ≤ n ≤ 105 1 ≤ r ≤ 50000 ) — number build active range generators correspondingly next n line contain build ' coordinate i + 1 - th ( 1 ≤ i ≤ n ) line contain two real number three digits decimal point xi yi ( |xi| |yi| ≤ 50000 ) — coordinate i - th build guarantee two build locate point two different build locate closer 1 . guarantee exist a circle radius r contain build print single real number — minimum area protect part contain build answer accept absolute relative error n't exceed 10 - 4 . first sample give radius equal radius circle <unknown> around give point 's circle correspond seek area answer <unknown> second sample area <unknown> coincide square vertexes give point area third sample show picture",['geometry'],3000.0
199/B,a <unknown> <unknown> artist sasha draw <unknown> <unknown> decide paint a picture <unknown> ` ` special <unknown> '' <unknown> think regular olympic game five ring special ones exactly two ring fine let us remind a ring a region locate two concentric circle radii r r ( r < r ) radii call internal external respectively concentric circle circle center locate point soon a white canvas consider infinite cartesian plane two perfect ring paint solid black paint sasha <unknown> ring could different radii size intersect overlap way know one thing sure : center pair ring sasha get tire fell a deep sleep a girl call <unknown> come room want cut a circle sake good memories make circle beautiful decide cut along contour 'll consider a contour a continuous close line transition one color another ( see note clarification ) contour take form a circle result cut a circle <unknown> want girl 's <unknown> mathematical mind rest : many ways cut a circle canvas ? input contain two line line four space - separated integers xi yi ri ri describe i - th ring ; xi yi coordinate ring 's center ri ri internal external radii ring correspondingly ( - 100 ≤ xi yi ≤ 100 ; 1 ≤ ri < ri ≤ 100 ) guarantee center ring <unknown> a single integer — number ways cut a circle canvas figure test sample give possible cut mark red dot line,['geometry'],1900.0
227/A,trouble come <unknown> land : a three - <unknown> dragon gorynych arrive dragon settle point c begin <unknown> residents surround villages a brave hero decide put end dragon move point a fight gorynych hero ride point a along a straight road meet point b way hero know land every pair roads true either parallel lie a straight line perpendicular also know well point b c connect a road hero must either turn 90 degrees leave continue rid straight ahead turn 90 degrees right forget point c locate fortunately a brave falcon fly right see three point sky hero ask way go get dragon 's lair get falcon help hero tell get point c : turn leave go straight turn right moment hero believe stand point b turn back point a. first input line contain two space - separated integers <unknown> <unknown> ( <unknown> <unknown> ≤ 109 ) — coordinate point a. second line contain coordinate point b form third line contain coordinate point c. guarantee point pairwise different also guarantee either point b lie segment ac angle abc right print a single line a hero must turn leave print ` ` leave '' ( without quote ) ; must go straight ahead print ` ` towards '' ( without quote ) ; turn right print ` ` right '' ( without quote ) picture first sample : red color show point a b c. blue arrow show hero 's direction green color show hero 's trajectory picture second sample :,['geometry'],1300.0
280/A,give two rectangles a plane center rectangles locate origin coordinate ( mean center rectangle 's symmetry ) first rectangle 's side parallel coordinate ax : length side parallel ox axis equal w length side parallel oy axis equal h. second rectangle obtain rotate first rectangle relative origin coordinate angle α . task find area region belong give rectangles region shade picture first line contain three integers w h α ( 1 ≤ w h ≤ 106 ; 0 ≤ α ≤ 180 ) angle α give degrees a single line print a real number — area region belong give rectangles answer consider correct relative absolute error n't exceed 10 - 6 . second sample draw picture,['geometry'],2000.0
342/C,"a girl name xenia a cupboard look like arc ahead arc make a <unknown> radius r ( cupboard 's top ) two wall height h ( cupboard 's side ) cupboard 's depth r , look like a rectangle base r height h + r side figure show cupboard look like ( front view leave side view right ) xenia get lot balloon birthday girl hat mess want store balloon cupboard luckily balloon a sphere radius help xenia calculate maximum number balloon put cupboard say a balloon cupboard ca n't see part balloon leave right view balloon cupboard touch allow <unknown> balloon <unknown> way assume cupboard 's wall negligibly <unknown> single line contain two integers r h ( 1 ≤ r h ≤ 107 ) print a single integer — maximum number balloon xenia put cupboard",['geometry'],1900.0
372/E,a set point s plane set n't contain origin o ( 0 0 ) two distinct point set a b triangle <unknown> strictly positive area consider a set pair point ( p1 p2 ) ( p3 <unknown> ) ... ( p2k - 1 p2k ) 'll call set good : calculate number good set pair modulo 1000000007 ( 109 + 7 ) first line contain a single integer n ( 1 ≤ n ≤ 1000 ) — number point s. next n line contain four integers ai bi ci di ( 0 ≤ |ai| <unknown> ≤ 50 ; 1 ≤ bi di ≤ 50 ; ( ai ci ) ≠ ( 0 0 ) ) integers represent a point two point coincide print a single integer — answer problem modulo 1000000007 ( 109 + 7 ),['geometry'],3000.0
388/E,a meteor <unknown> sky n meteors sky view a 2d <unknown> plane meteor point plane fox ciel look sky find orbit meteor a straight line meteor a constant velocity ciel want know : maximum number meteors pair meet position a certain time ? note time limit also negative meteors never collide appear position time first line contain integer n ( 1 ≤ n ≤ 1000 ) next n line contain six integers : t1 x1 y1 t2 x2 y2 — description a meteor 's orbit : time t1 current meteor locate point ( x1 y1 ) time t2 meteor locate point ( x2 y2 ) ( - 106 ≤ t1 x1 y1 t2 x2 y2 ≤ 106 ; t1 ≠ t2 ) two meteors always position time print a single integer — maximum number meteors pair meet position a certain time example 1 meteor 1 2 meet <unknown> ( 0 0 ) example 2 meteor 1 2 meet t=1 ( 1 0 ) meteor 1 3 meet t=0 ( 0 0 ) meteor 2 3 meet t=2 ( 0 1 ) example 3 two meteor meet example 4 1 meteor velocity zero browser n't support <unknown> <unknown> please see <unknown> version : http : //assets.codeforces.com / images/388e / <unknown> : //assets.codeforces.com / images/388e / <unknown> : //assets.codeforces.com / images/388e / <unknown> : //assets.codeforces.com / images/388e / <unknown>,['geometry'],3100.0
190/B,", berland war <unknown> enemy flatland vasya accountant assign fulfil duty <unknown> right situation berland <unknown> — cities surround ! armies flatlanders stand border circle circle ' center surround cities moment point flatland ring begin move quickly direction city — 's strategy flatlanders usually follow <unknown> cities berlanders sure <unknown> enemy 's attack learn exact time attack start need construct a radar would register movement distance r thus install a radar point least one point enemy ring detect range ( a distance r ) radar immediately inform enemy 's attack due newest technologies place a radar point without problems problem berlanders time make one radar besides larger detection radius ( r ) radar cost 's vasya 's task ( task ) find minimum possible detection radius radar word task find minimum radius r ( r ≥ 0 ) a radar radius r instal point register start movements flatland ring point problem consider cities <unknown> point attack enemy ring - circle center cities radar 's detection range — a <unknown> ( include border ) center point radar place input file consist two line line represent city flatland ring surround three space - separated integers xi yi ri ( |xi| |yi| ≤ 104 ; 1 ≤ ri ≤ 104 ) — city 's coordinate distance city flatlanders correspondingly guarantee cities locate different point print a single real number — minimum detection radius describe radar answer consider correct absolute relative error exceed 10 - 6 . figure show answer first sample sample best decision put radar point coordinate ( 2 0 ) figure show answer second sample sample best decision put radar point coordinate ( 0 0 )",['geometry'],1800.0
119/E,year 3000 travel around parallel <unknown> become a routine thing however one take consideration travel like highly dangerous never know beforehand 're gon <unknown> get ... little vasya instance find a game reality successfully complete level a weird game get back game reality a three - dimensional space n point give game m level begin i - th level player position plane qi pass origin level vasya use special <unknown> construct activate n powerful energy spheres equal radius center give point player choose radius spheres player spend r units money construct spheres whose radius equal r ( consequently one construct spheres whose radius equal zero free ) besides level a player choose point space release a laser ray perpendicular plane qi ( action cost nothing ) ray either direct towards plane plane spheres share least one point ray immediately activate level consider complete player manage activate spheres note center spheres m level spheres remain : player construct anew new level help vasya find minimum sum money enough complete level first line contain two integers n m ( 1 ≤ n ≤ <unknown> 1 ≤ m ≤ 100 ) — number <unknown> spheres number level game correspondingly follow n line contain three integers xi yi zi ( 0 ≤ xi yi zi ≤ 104 ) — coordinate center i - th sphere assume point change position throughout game follow m line contain three integers ai bi ci ( 0 ≤ ai bi ci ≤ 100 ai2 + <unknown> + <unknown> > 0 ) number coefficients equation plane qi ( aix + biy + <unknown> = 0 ) player position begin i - th level print m number one per line : i - th line contain minimum sum money need complete i - th level absolute relative error exceed 10 - 6,['geometry'],2400.0
82/E,consider a house plan let house represent infinite horizontal strip define inequality - h ≤ y ≤ h. strictly outside house two light source point ( 0 f ) ( 0 - f ) windows locate wall windows represent segment line y = h y = - h. also windows arrange <unknown> line y = 0 . task find area floor home light source light first line input file contain three integers n h f ( 1 ≤ n ≤ 500 1 ≤ h ≤ 10 h < f ≤ 1000 ) next n line contain two integers li ri ( - 5000 ≤ li < ri ≤ 5000 ) <unknown> indicate two segment endpoints first segment ( li h ) - ( ri h ) endpoints second segment ( li - h ) - ( ri - h ) segment describe location windows number line space - separated guarantee two distinct segment common point print single real number — area illuminate part floor absolute relative error 10 - 4 . second sample test show figure green area desire area illuminate part floor <unknown> segment indicate windows,['geometry'],2600.0
142/E,"greg dwarf really busy recently excavations neverland mountain however well - known reason ( probably remember a unusual dwarf stand <unknown> ) greg excavate night morning crypt first sun ray strike 's want find shortest route <unknown> point crypt greg <unknown> codeforces participants successfully solve problem transport coffin a crypt , <unknown> way greg appear <unknown> ask help a highly <unknown> manner usual n't feel like turn think formalize task follow : neverland mountain a regular shape end a rather <unknown> <unknown> represent a cone whose base radius equal r whose height equal h. <unknown> greg busy excavate crypt represent two point cone 's surface ' ve get find distance point cone 's surface task complicate fact mountain 's base grind level even everything mountain <unknown> gnome ( one may wonder whether ' ve look stuff greg ... ) , one consider shortest way pass along side surface also along cone 's base ( a specific case point lie cone 's base — see first sample test ) greg satisfy problem solution represent length shortest path two point — find way pretty well give two hours solve problem time <unknown> ! first input line contain space - separated integers r h ( 1 ≤ r h ≤ 1000 ) — base radius cone height correspondingly second third line contain coordinate two point cone surface group three space - separated real number coordinate point give systems coordinate origin coordinate locate centre cone 's base rotation axis match <unknown> axis coordinate system vertex cone locate point ( 0 0 h ) base cone a circle whose center point ( 0 0 0 ) lie <unknown> plane point cone surface a non - negative coordinate <unknown> guarantee distance point cone surface exceed 10 - 12 . real number input 16 digits decimal point print length shortest path point give input absolute relative error exceed 10 - 6",['geometry'],3000.0
68/E,little petya prepare first contact alien know alien spaceships shape non - degenerate triangles exactly 4 ship land platform a ship make 3 special columns locate point a cartesian plane 3 point form a triangle equal ship respect rotations <unknown> ( parallel shift along vector ) reflections ( <unknown> along edge ) ship overlap land column use land one ship example two equal ship n't need build 6 columns land ship 3 enough petya want know minimum number columns enough land ship 4 line contain 6 integers x1 y1 x2 y2 x3 y3 ( 0 ≤ x1 y1 x2 y2 x3 y3 ≤ 20 ) represent 3 point describe shape 4 ship guarantee 3 point line represent a non - degenerate triangle first line contain minimum number columns enough land spaceships first test case columns put point : ( 0 0 ) ( 1 0 ) ( 3 0 ) ( 1 2 ) note second ship land use last 3 columns second test case follow point choose : ( 0 0 ) ( 0 1 ) ( 1 0 ) ( 0 2 ) ( 2 0 ) ( 0 5 ) ( 5 0 ) ( 0 17 ) ( 17 0 ) impossible use less 9 columns,['geometry'],2900.0
1220/G,work gryzzl company headquarter pawnee <unknown> new national park open near pawnee recently implement a <unknown> system people wo n't get lose <unknown> develop <unknown> <unknown> $$$ n $$$ antennas locate somewhere park someone would like know current location gryzzl <unknown> phone communicate antennas obtain distance a user 's current location antennas know distance antennas locations easy recover a user 's location ... right ? well almost issue way distinguish antennas n't know distance correspond antenna task find a user 's location give little antennas location unordered multiset distance first line input contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100000 $$$ ) number antennas follow $$$ n $$$ line contain coordinate antennas $$$ i $$$ -th line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \leq x_i y_i \leq 100000000 $$$ ) guarantee two antennas coincide next line input contain integer $$$ m $$$ ( $$$ 1 \leq n \cdot m \leq 100000 $$$ ) number query determine location user follow $$$ m $$$ line contain $$$ n $$$ integers $$$ 0 \leq d_1 \leq d_2 \leq \dots \leq d_n \leq 2 \cdot 10^ { 16 } $$$ integers form a multiset square distance unknown user 's location $$$ ( x ; y ) $$$ antennas test case except examples guarantee user 's locations $$$ ( x ; y ) $$$ choose uniformly random independently among possible integer locations $$$ 0 \leq x y \leq 100000000 $$$ query output $$$ k $$$ number possible a user 's locations match give input output list locations <unknown> order guarantee sum $$$ k $$$ point exceed $$$ 1000000 $$$ see second example although initially a user 's location pick non - negative coordinate output possible integer locations,['geometry'],3400.0
77/E,"ever taste martian food ? well , signature dish serve a completely black plate radius r flat a <unknown> first put a perfectly circular portion golden honduras plate radius r locate close edge plate possible stay entirely within plate i. e. golden honduras touch edge plate inside believe <unknown> portion golden honduras edge a plate demonstrate <unknown> <unknown> martians a perfectly round portion pink guadeloupe put plate guadeloupe overlap honduras go beyond border plate maximum radius i. e. pink guadeloupe touch edge plate inside touch golden honduras outside size rise guadeloupe show <unknown> <unknown> martians , first portion ( perfectly round shape ) green bull terrier put plate come contact honduras guadeloupe go beyond border plate maximum radius follow portion green bull terrier must necessarily touch golden honduras previous portion green bull terrier touch edge a plate go beyond border determine whether a stranger worthy touch food martians ask find radius k - th portion green bull terrier know radii a plate a portion golden honduras worthy ? first line contain integer t ( 1 ≤ t ≤ 104 ) — amount testcases follow t line contain three positive integers : radii plate a portion golden honduras r r ( 1 ≤ r < r ≤ 104 ) number k ( 1 ≤ k ≤ 104 ) pretests 1 ≤ k ≤ 2 . print t line — radius k - th portion green bull terrier test absolute relative error answer exceed 10 - 6 . dish first sample look like : dish second sample look like :",['geometry'],2800.0
2/C,olympic game <unknown> full swing everyone <unknown> : sportsmen compete <unknown> sport <unknown> compete convenient position give a run <unknown> today main sport events take place three round stadiums commentator 's objective choose best point observation say point three stadiums observe sport competitions importance stadiums observe angle number point meet condition one point maximum angle observation prefer would please help famous berland commentator <unknown> <unknown> find best point observation note stadiums hide commentator easily see one stadium input data consist three line describe position one stadium line format x y r ( x y ) coordinate stadium 's center ( - 103 ≤ x y ≤ 103 ) r ( 1 ≤ r ≤ 103 ) radius number input data integer stadiums common point center line print coordinate require point five digits decimal point answer meet condition program n't print anything output data leave blank,['geometry'],2600.0
46/G,happen time great berland empire emperor dream messenger gods order build a temple whose base would a convex polygon n angle next morning emperor give command build a temple whose base a regular polygon n angle temple build soon empire shake <unknown> <unknown> <unknown> <unknown> destroy temple emperor understand somehow cause wrath gods fall people order bring wise man wise man appear emperor <unknown> dream ask ` ` oh wisest among wisest tell could i infuriate gods ? ` ` ` ` lord '' wise man answer ` ` far i judge gods angry <unknown> fulfill order n't listen end message '' indeed follow night messenger appear <unknown> emperor choose <unknown> shape temple ` ` shape perfect a regular polygon ! ? '' cry emperor dream messenger give a complete <unknown> reply <unknown> architect go make temple 's plan note polygon simple ( a border without self - intersections overlap ) convex however acceptable three consecutive vertices lie line first line contain single number n ( 3 ≤ n ≤ 10000 ) print ` ` yes '' ( without quote ) first line possible build a polygon possess need qualities next n line print integer coordinate polygon vertices order would pass counter clockwise absolute value coordinate n't exceed 109 . two vertices coincide permit print possible solutions print ` ` '' build polygon impossible,['geometry'],2500.0
50/C,happy <unknown> 5 creators decide invent mechanism cow <unknown> cow game slow move <unknown> even consider stand still however <unknown> always chase a young player vasya decide make shepherd run round cow along one close path important cow stay strictly inside area limit path otherwise cow sooner later eat absolutely sure cow ' safety vasya want path completion time minimum new game launch different <unknown> include mobile phone 's developers decide <unknown> use arithmetics float decimal point use arithmetics integers cow shepherd game represent point plane integer coordinate play time model turn every turn shepherd either stay stand step one eight directions : horizontally vertically diagonally coordinate always remain integer length a horizontal vertical step equal 1 length a diagonal step equal cow move minimize number move shepherd need run round whole herd first line contain integer n represent number cow herd ( 1 ≤ n ≤ 105 ) next n line contain two integers xi yi represent coordinate one cow ( |xi| |yi| ≤ 106 ) several cow stand one point print single number — minimum number move seek path picture example test : coordinate grid paint <unknown> coordinate ax paint black cow paint red seek route paint green,['geometry'],2000.0
54/E,one winter even hedgehog <unknown> home <unknown> <unknown> click tv channel stumble issue « <unknown> » hedgehog change channel a sudden stop <unknown> a new <unknown> invention actually a vacuum cleaner advertise call <unknown> vacuum n't even need a human operate clean ! vacuum cleaner move around flat : move direction hit obstacle automatically choose a new direction sooner later vacuum cleaner travel room clean remember much time hedgehog spend every time clean ( <unknown> less a half day ) get eager buy wonder however hedgehog quickly understand cleaner least one weak point : wo n't clean well room 's corner often wo n't able reach corner due shape estimate serious <unknown> practice hedgehog ask write correspond program give cleaner 's shape top view consider case vacuum cleaner represent a convex polygon room infinitely large rectangle consider one corner room want find a rotation vacuum cleaner <unknown> corner leave minimum possible area corner uncover first line contain integer n represent number vertices vacuum cleaner 's polygon ( 3 ≤ n ≤ <unknown> ) follow n line contain two number — coordinate a vertex polygon coordinate integer absolute value exceed 106 . guarantee give polygon nondegenerate convex ( three point lie line ) polygon vertices give a clockwise counter - clockwise direction print minimum possible uncover area answer accept within 10 - 6 absolute relative error correct answer,['geometry'],2700.0
67/E,"town aalam - aara ( mean light earth ) previously <unknown> criminals time progress sin start <unknown> <unknown> <unknown> people seek solution problem <unknown> find long corrupt part population keep away <unknown> part <unknown> could stop , try set a compound keep corrupt people ensure criminals n't escape compound a watchtower need set watch since people aalam - aara n't rich meet a <unknown> rich town agree sell a land - plot already a straight line fence ab along a point set put a watchtower task help find number point fence tower put criminals watch one watchtower set a criminal watchable watchtower line <unknown> watchtower n't cross plot - <unknown> point tower i.e show figure 1 point x y c a visible point b point e d assume land plot shape a polygon coordinate ax setup fence ab parallel x - axis point watchtower set integer point line example give figure 2 watchtower setup five integer point ab i.e ( 4 8 ) ( 5 8 ) ( 6 8 ) ( 7 8 ) ( 8 8 ) assume three consecutive point collinear corner point a b lie towards side fence ab give polygon n't contain self - intersections first line test case consist number vertices n ( 3 ≤ n ≤ 1000 ) next n line contain coordinate vertices clockwise order polygon i - th line integers xi yi ( 0 ≤ xi yi ≤ 106 ) separate a space endpoints fence ab first two point ( x1 y1 ) ( x2 y2 ) output consist a single line contain number point watchtower set figure 2 show first test case point figure watchable point fence ab since ab 5 integer coordinate answer 5 . case two fence cd de completely visible thus answer 0",['geometry'],2500.0
1584/G,give $$$ n $$$ distinct point $$$ p_1 p_2 \ldots p_n $$$ plane a positive integer $$$ r $$$ find number pair indices $$$ ( i j ) $$$ $$$ 1 \le i < j \le n $$$ every possible $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) distance point $$$ p_k $$$ segment point $$$ p_i $$$ $$$ p_j $$$ $$$ r $$$ first line contain two integers $$$ n $$$ $$$ r $$$ ( $$$ 1 \le n \le 3000 $$$ $$$ 1 \le r \le 100000 $$$ ) — number point maximum distance a point a segment next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ -100000 \le x_i y_i \le 100000 $$$ ) define $$$ i $$$ -th point $$$ <unknown> ( x_i y_i ) $$$ point distinct guarantee answer change parameter $$$ r $$$ change $$$ 10^ { -2 } $$$ print number suitable pair $$$ ( i j ) $$$ first example pair point $$$ ( -3 0 ) $$$ $$$ ( 3 0 ) $$$ suitable distance segment point point $$$ ( 0 1 ) $$$ $$$ ( 0 -1 ) $$$ equal $$$ 1 $$$ less $$$ r=2 $$$ second example possible pair point eligible,['geometry'],3200.0
442/E,gena n't like geometry ask solve problem a rectangle side parallel coordinate ax contain n dot let 's consider point plane let 's count distance point give n point let 's sort number non - decreasing order 'll call beauty point second element array two <unknown> elements array <unknown> equal minimum find maximum beauty a point inside give rectangle first line contain three integers w h n ( 1 ≤ w h ≤ 106 2 ≤ n ≤ 1000 ) — lengths rectangle side number point next n line contain two integers xi yi ( 0 ≤ xi ≤ w 0 ≤ yi ≤ h ) — coordinate a point possible <unknown> point print a single number — maximum beauty a point absolute relative error 10 - 9 . point beauty need find must coordinate ( x y ) 0 ≤ x ≤ w 0 ≤ y ≤ h. n point coincide,['geometry'],3100.0
961/D,give n point cartesian plane every point a lattice point ( i. e. coordinate integers ) point distinct may draw two straight line ( necessarily distinct ) possible a way every point lie least one line ? first line contain one integer n ( 1 ≤ n ≤ 105 ) — number point give n line follow line contain two integers xi yi ( |xi| |yi| ≤ 109 ) — coordinate i - th point n point distinct possible draw two straight line a way give point belong least one line print yes otherwise print first example possible draw two line one contain point 1 3 5 another one contain two remain point,['geometry'],2000.0
975/E,"hag a talented person always artist inside father force study <unknown> engineer yesterday spend time cut a giant piece wood try make look like a <unknown> anyway dad find arts rather study mechanics bore subject confront hag fact a spoil son care future continue arts cut 25 <unknown> <unknown> allowance hag try prove dad wooden piece a project mechanics subject also tell dad wooden piece a strictly convex polygon $$$ n $$$ vertices hag bring two pin pin polygon $$$ 1 $$$ -st $$$ 2 $$$ -nd vertices wall dad $$$ q $$$ query hag two type please help hag answer father 's query assume wood form polygon uniform <unknown> polygon a positive thickness point every query 1 - st type hag 's dad try move polygon a bite watch <unknown> first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ <unknown> n \leq 10\,000 $$$ $$$ 1 \leq q \leq 200000 $$$ ) — number vertices polygon number query next $$$ n $$$ line describe wooden polygon $$$ i $$$ -th line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ |x_i| <unknown> 100000000 $$$ ) — coordinate $$$ i $$$ -th vertex polygon guarantee polygon strictly convex vertices give counter - clockwise order vertices distinct next $$$ q $$$ line describe query one per line query start type $$$ 1 $$$ $$$ 2 $$$ query first type continue two integers $$$ f $$$ $$$ t $$$ ( $$$ 1 \le f t \le n $$$ ) — vertex pin take vertex pin put polygon finish rotate guarantee vertex $$$ f $$$ contain a pin query second type continue a single integer $$$ v $$$ ( $$$ 1 \le v \le n $$$ ) — vertex coordinate hag tell father guarantee least one query second type output contain answer query second type — two number a separate line answer consider correct absolute relative error exceed $$$ 10^ { -4 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer consider correct $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -4 } $$$ first test note initial final state wooden polygon red triangle initial state green one triangle rotation around $$$ ( <unknown> ) $$$ second sample note polygon rotate $$$ 180 $$$ degrees counter - clockwise clockwise direction ( matter ) hag 's father make sure polygon stable son trick",['geometry'],2600.0
1025/F,a point belong a triangle lie inside triangle one side two triangles disjoint point plane belong triangles give $$$ n $$$ point plane two point coincide three point collinear find number different ways choose two disjoint triangles vertices give point two ways differ order triangles order vertices inside triangles consider equal first line input contain integer $$$ n $$$ ( $$$ 6 \le n \le 2000 $$$ ) – number point next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ |x_i| |y_i| \le 1000000000 $$$ ) – coordinate a point two point coincide three point collinear print one integer – number ways choose two disjoint triangles first example six pair disjoint triangles show picture pair triangles disjoint example follow pair :,['geometry'],2700.0
1030/B,vasya own a cornfield define two integers $$$ n $$$ $$$ d $$$ cornfield represent rectangle vertices cartesian coordinate $$$ ( 0 d ) ( d 0 ) ( n n - d ) $$$ $$$ ( n - d n ) $$$ vasya also know $$$ m $$$ grasshoppers near field ( maybe even inside ) $$$ i $$$ -th grasshopper point $$$ ( x_i y_i ) $$$ vasya like grasshoppers eat <unknown> grasshopper want know whether position inside cornfield ( include border ) outside help vasya ! grasshopper determine inside field ( include border ) first line contain two integers $$$ n $$$ $$$ d $$$ ( $$$ 1 \le d < n \le 100 $$$ ) second line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 100 $$$ ) — number grasshoppers $$$ i $$$ -th next $$$ m $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \le x_i y_i \le n $$$ ) — position $$$ i $$$ -th grasshopper print $$$ m $$$ line $$$ i $$$ -th line contain ` ` yes '' position $$$ i $$$ -th grasshopper lie inside border cornfield otherwise $$$ i $$$ -th line contain ` ` '' print letter case ( upper lower ) cornfield first example picture grasshoppers indices $$$ 1 $$$ ( coordinate $$$ ( 2 4 ) $$$ ) $$$ 4 $$$ ( coordinate $$$ ( 4 5 ) $$$ ) inside cornfield cornfield second example picture grasshoppers indices $$$ 1 $$$ ( coordinate $$$ ( 4 4 ) $$$ ) $$$ 3 $$$ ( coordinate $$$ ( 8 1 ) $$$ ) $$$ 4 $$$ ( coordinate $$$ ( 6 1 ) $$$ ) inside cornfield,['geometry'],1100.0
1046/I,"two friends travel bubble galaxy say ` ` hello ! '' via signal distance smaller equal $$$ d_1 $$$ need calculate many time friends say ` ` hello ! ''   $$$ n $$$ moments 'll array point friend represent position moment a person stay position two moments time a person make a move assume movement movement constant speed constant direction first line contain one integer number $$$ n $$$ ( $$$ 2 \leq n \leq 100\,000 $$$ ) represent number moments capture position two friends second line contain two integer number $$$ d_1 $$$ $$$ d_2 \ ( 0 < d_1 < d_2 < 1000 ) $$$ next $$$ n $$$ line contain four integer number $$$ a_x a_y b_x b_y $$$ ( $$$ 0 \leq a_x a_y b_x b_y \leq 1000 $$$ ) represent coordinate friends a b capture moment output contain one integer number represent many time friends say ` ` hello ! ''   explanation : friends send signal 2 time first time around point $$$ a2 $$$ $$$ b2 $$$ second time a 's travel point $$$ a3 $$$ $$$ a4 $$$ b stay point $$$ b3 = <unknown> $$$",['geometry'],2300.0
1142/C,"recently vasya learn give two point different $$$ x $$$ coordinate draw exactly one parabola equation type $$$ y = <unknown> + bx + c $$$ $$$ b $$$ $$$ c $$$ <unknown> let 's call a parabola $$$ u $$$ -shaped one vasya draw several distinct point integer coordinate a plane draw $$$ u $$$ -shaped parabola pair point different $$$ x $$$ coordinate picture become <unknown> <unknown> vasya still want count many parabolas draw n't draw point inside internal area help vasya internal area $$$ u $$$ -shaped parabola part plane lie strictly parabola $$$ y $$$ axis direct upwards first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100\,000 $$$ ) — number point next $$$ n $$$ line describe point $$$ i $$$ -th contain two integers $$$ x_i $$$ $$$ y_i $$$ — coordinate $$$ i $$$ -th point guarantee point distinct coordinate exceed $$$ 1000000 $$$ absolute value line print a single integer — number $$$ u $$$ -shaped parabolas pass least two give point contain give point inside internal area ( exclude parabola ) picture $$$ u $$$ -shaped parabolas pass least two give point draw examples $$$ u $$$ -shaped parabolas give point inside internal area draw red",['geometry'],2400.0
958/E3,"heidi know assign rebel spaceships base ( recall easy subtask ) ask : exactly ? , give position n spaceships n base a plane task connect spaceships base line segment : first line contain integer n ( 1 ≤ n ≤ 10000 ) 1 ≤ i ≤ n i + 1 - th line contain two integers xi yi ( |xi| |yi| ≤ 10000 ) denote coordinate i - th spaceship follow n line format denote position base guarantee two point coincide three point line output n line i - th line contain integer pi index base i - th spaceship connect sequence p1 ... pn form a permutation 1 ... n. guarantee a solution exist multiple solutions output one",['geometry'],2700.0
1156/A,math faculty berland state university suffer sudden drop math skills <unknown> students year highest grade entrance math test 8 . 100 ! thus decision make make test easier future students ask a single question give a sequence integer number $$$ a_1 a_2 \dots a_n $$$ number $$$ 1 $$$ $$$ 3 $$$ $$$ a_i \ne a _ { i + 1 } $$$ valid $$$ i $$$ $$$ i $$$ -th number represent a type $$$ i $$$ -th figure : figure give sequence place somewhere a cartesian plane a way : note construction unique fix position size first figure task calculate number distinct point ( necessarily integer coordinate ) figure touch trick however number sometimes infinite wo n't make task difficult ? pass math test <unknown> berland state university ? first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — number figure second line contain $$$ n $$$ integer number $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 3 $$$ $$$ a_i \ne a _ { i + 1 } $$$ ) — type figure first line contain either word ` ` infinite '' number distinct point figure touch infinite ` ` finite '' otherwise number finite print second line 's guarantee number fit 32 - bit integer type <unknown> picture examples note triangle equilateral isosceles length height equal length base thus fit a square a unique way distinct point figure touch mark red second example triangle square touch whole segment contain infinite number point,['geometry'],1400.0
1299/B,"guy - <unknown> thomas go build a polygon spaceship 're give a strictly convex ( i. e. three point collinear ) polygon $$$ p $$$ define coordinate vertices define $$$ p ( x y ) $$$ a polygon obtain translate $$$ p $$$ vector $$$ \overrightarrow { ( x y ) } $$$ picture depict example <unknown> : define $$$ t $$$ a set point union $$$ p ( x y ) $$$ origin $$$ ( 0,0 ) $$$ lie $$$ p ( x y ) $$$ ( strictly inside boundary ) also equivalent definition : a point $$$ ( x y ) $$$ lie $$$ t $$$ two point $$$ a b $$$ $$$ p $$$ $$$ \overrightarrow { ab } = \overrightarrow { ( x y ) } $$$ one prove $$$ t $$$ a polygon example $$$ p $$$ a regular triangle $$$ t $$$ a regular <unknown> picture $$$ p $$$ draw black $$$ p ( x y ) $$$ contain origin draw color : spaceship best <unknown> performance $$$ p $$$ $$$ t $$$ similar task check whether polygons $$$ p $$$ $$$ t $$$ similar first line input contain a single integer $$$ n $$$ ( $$$ 3 \le n \le 100000 $$$ ) — number point $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ x_i y_i $$$ ( $$$ |x_i| |y_i| \le 1000000000 $$$ ) denote coordinate $$$ i $$$ -th vertex guarantee point list counterclockwise order point form a strictly convex polygon output ` ` yes '' a separate line $$$ p $$$ $$$ t $$$ similar otherwise output ` ` '' a separate line print letter case ( upper lower ) follow image show first sample : $$$ p $$$ $$$ t $$$ square second sample show statements",['geometry'],1800.0
1423/E,make a strategic plan <unknown> <unknown> mobile network throughout whole country government decide cover <unknown> areas last generation 5 g network since 5 g antenna tower build area <unknown> <unknown> properties government need easy way find information <unknown> property partially fully contain plan build area plan build area represent a rectangle side $$$ width $$$ $$$ height $$$ every 5 g antenna tower occupy a circle a center $$$ ( x y ) $$$ radius $$$ r $$$ a database <unknown> institute contain information property property define identification number polygon represent array $$$ ( x y ) $$$ point counter - clockwise direction task build system handle query type $$$ ( x y r ) $$$ $$$ ( x y ) $$$ represent a circle center $$$ r $$$ represent radius system return total area properties need acquire build a tower government estimate price furthermore system return a list identification number properties ( <unknown> contact land <unknown> ) a property need acquire circle antenna tower intersect touch first line contain size build area double value $$$ width $$$ $$$ height $$$ integer $$$ n $$$ — number properties database next $$$ n $$$ line contain description a single property form integer number $$$ v $$$ ( $$$ 3 \le v \le 40 $$$ ) — number point define a property well $$$ 2 * v $$$ double number — coordinate $$$ ( x y ) $$$ property point line $$$ i $$$ ( $$$ 0 \le i \le n-1 $$$ ) contain information property i d $$$ i $$$ next line contain integer $$$ q $$$ — number query next $$$ q $$$ line contain double value $$$ x $$$ $$$ y $$$ $$$ r $$$ — coordinate antenna circle center $$$ ( x y ) $$$ radius $$$ r $$$ $$$ 1 \le n * q \le 1000000 $$$ $$$ q $$$ query program output a line contain total area properties need acquire integer represent number properties well list ids properties ( separate blank character arbitrary order ) assume land cover properties ( polygons ) government 's <unknown> therefore n't need acquire properties intersect precision use solution check $$$ 10^ { -4 } $$$,['geometry'],2700.0
409/G,first line contain a single integer n ( 1 ≤ n ≤ 1000 ) — number point a plane next n line contain two real coordinate xi yi point specify exactly 2 fractional digits coordinate - 1000 1000 inclusive output a single real number <unknown> — answer problem statement absolute relative error answer 10 - 2,['geometry'],2200.0
420/E,a coder sit code day sometimes a good idea rise desk a rest small talk <unknown> even play coders f company favorite ball game let 's imagine game plane a cartesian coordinate system point ( 0 0 ) contain player choose arbitrary direction throw a ball direction ball hit plane distance d player 's original position continue fly direction ball hit plane first time fly hit plane distance <unknown> player 's original position ( continue fly choose direction hit plane d units ) coders f company strong ball fly infinitely far away plane n circle paint a ball hit plane hit a circle paint plane ( include border ) player get one point ball hit multiple circle get one point ( ball hit circle x time move player also get x point ) count maximum number point a player get throw a ball arbitrary direction note direction may real <unknown> first line contain two space - separated integers — n и d ( 1 ≤ n ≤ <unknown> ; 5 ≤ d ≤ 10 ) next n line contain circle ' description i - th line contain three space - separated integers xi yi ri ( - 10000 ≤ xi yi ≤ 10000 ; 1 ≤ r ≤ 50 ) ( xi yi ri ) coordinate center radius circle correspondingly point ( 0 0 ) inside border circle print a single integer — maximum number point get,['geometry'],2600.0
1578/F,"life discover venus ! , life form appear convex polygons international <unknown> design a probe send venus take picture need estimate bandwidth need send back picture probe take a picture a life form wish send back earth bandwidth require proportional area bound box ( word smallest axis - aligned rectangle contain life - form ) shape size life form know orientation relative camera random must thus determine expect ( average ) area bound box across orientations input describe shape a life form a convex polygon two dimension first line input contain integer $$$ n $$$ ( $$$ 3 \le n \le 200\,000 $$$ ) — number vertices remain $$$ n $$$ line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ -1000000000 \le x y \le 1000000000 $$$ ) — coordinate a vertex vertices give counterclockwise order three vertices lie a straight line output a single line contain expect area bound box polygon answer absolute relative error $$$ 10^ { -6 } $$$ picture show example life form various camera orientations",['geometry'],2900.0
935/C,fifa fafa share a flat fifa love video game want <unknown> a new <unknown> game unfortunately fafa heavily use internet consume <unknown> fifa access internet wi - fi access point access point access within a range r meter ( range choose fifa ) position fifa must put access point inside flat a circular shape radius r. fifa want minimize area cover access point inside flat without let fafa anyone outside flat get access internet world represent infinite 2d plane flat center ( x1 y1 ) radius r fafa 's laptop locate ( x2 y2 ) necessarily inside flat find position radius choose fifa access point minimize uncover area single line input contain 5 space - separated integers r x1 y1 x2 y2 ( 1 ≤ r ≤ 105 <unknown> <unknown> <unknown> <unknown> ≤ 105 ) print three space - separated number xap yap r ( xap yap ) position fifa choose access point r radius range answer consider correct radius differ optimal 10 - 6 absolutely relatively also radius print change 10 - 6 ( absolutely relatively ) a way point outside flat fafa 's laptop position outside circle access point range,['geometry'],1600.0
886/F,give a set n point plane a line contain origin call good projection give set line form a symmetric multiset point find total number good line multiset a set equal elements allow multiset call symmetric a point p plane multiset <unknown> symmetric respect point p. first line contain a single integer n ( 1 ≤ n ≤ 2000 ) — number point set next n line contain two integers xi yi ( - 106 ≤ xi yi ≤ 106 ) — coordinate point guarantee two point coincide infinitely many good line print -1 . otherwise print single integer — number good line picture first sample test : second sample line contain origin good,['geometry'],2900.0
842/B,gleb order pizza home courier deliver pizza upset several piece sausage lay crust really like crust pizza a circle radius r center origin pizza consist main part — circle radius r - d center origin crust around main part width d. piece sausage also circle radius i -th piece sausage ri center give a pair ( xi yi ) gleb ask help determine number piece sausage catch crust a piece sausage get crust completely lie crust first string contain two integer number r d ( 0 ≤ d < r ≤ 500 ) — radius pizza width crust next line contain one integer number n — number piece sausage ( 1 ≤ n ≤ 105 ) next n line contain three integer number xi yi ri ( - 500 ≤ xi yi ≤ 500 0 ≤ ri ≤ 500 ) xi yi coordinate center i - th peace sausage ri — radius i - th peace sausage output number piece sausage lay crust a picture explain first example circle green color denote piece sausage lie crust,['geometry'],1100.0
498/A,crazy town a plane n infinite line roads road define equation aix + biy + ci = 0 ai bi equal zero roads divide plane connect regions possibly infinite space let 's call region a block define intersection point least two different roads intersect home locate one block today need get university also locate block one step move one block another length common border nonzero ( particular mean block adjacent one intersection share nonzero boundary segment allow move one another one one step ) determine minimum number step perform get block contain university guarantee neither home university locate road first line contain two space - separated integers x1 y1 ( - 106 ≤ x1 y1 ≤ 106 ) — coordinate home second line contain two integers separate a space x2 y2 ( - 106 ≤ x2 y2 ≤ 106 ) — coordinate university study third line contain integer n ( 1 ≤ n ≤ 300 ) — number roads city follow n line contain 3 space - separated integers ( - 106 ≤ ai bi ci ≤ 106 ; |ai| + |bi| > 0 ) — coefficients line aix + biy + ci = 0 define i - th road guarantee two roads addition neither home university lie road ( i.e belong one line ) output answer problem picture sample present ( a point represent house ; b point represent university different block fill different color ) :,['geometry'],1700.0
530/H,give a set point a plane positive integer coordinate find a triangle minimum area vertices point ( 0 0 ) ( a 0 ) ( 0 b ) ( a b unknown positive integers ) contain give point inside ( point edge count towards inside ) first line input contain integer n ( 1 ≤ n ≤ 100 ) — number point follow n line contain pair number x y ( 1 ≤ x y ≤ 100 ) - coordinate point point distinct output one floating - point number — minimal area triangle answer consider correct absolute relative error exceed 10 - 4,['geometry'],2100.0
566/G,two kitten max min play a pair non - negative integers x y. guess name kitten max love maximize kitten min love minimize part game min want make sure number x y become negative time kitten max try prevent kitten a set pair integers available kitten max n pair non - negative integers ( ai bi ) ( 1 ≤ i ≤ n ) kitten min m pair non - negative integers ( cj dj ) ( 1 ≤ j ≤ m ) kitten max make a move take available pair ( ai bi ) add ai x bi y kitten min take available pair ( cj dj ) subtract cj x dj y. kitten use pair multiple time distinct move max move first kitten min win moment number a b negative simultaneously otherwise winner game kitten max determine kitten win play optimally first line contain two integers n m ( 1 ≤ n m ≤ 100 000 ) — number pair number available max min correspondingly second line contain two integers x y ( 1 ≤ x y ≤ 109 ) — initial value number kitten play next n line contain pair number ai bi ( 1 ≤ ai bi ≤ 109 ) — pair available max last m line contain pair number cj dj ( 1 ≤ cj dj ≤ 109 ) — pair available min print « max » ( without quote ) kitten max win ` ` min '' ( without quote ) kitten min win first test statement min respond move ( 2 3 ) move ( 3 10 ) move ( 3 2 ) move ( 10 3 ) thus pair max min 's move value number x y strictly decrease <unknown> min win sooner later second sample test pair max min 's move number x y increase thus none become negative,['geometry'],2500.0
575/E,"’ s riot time football stadium <unknown> ! <unknown> fan enter field police find a difficult situation field represent a square coordinate system define two diagonal vertices ( 0,0 ) ( 105 105 ) side square also consider inside field everything else outside begin n fan field fan give speed integer vi well integer coordinate ( xi yi ) a fan coordinate might move one second might point ( xi + p yi + q ) 0 ≤ <unknown> + <unknown> ≤ vi p q integers point go outside square represent field exclude others equal probability location specific fan one second <unknown> a young promise police officer send a fly drone take a photo riot drone ’ s camera work like : goal select three point expect number fan see photo maximize selections select three point give circle largest radius among still suitable selections one accept answer follow condition radius circle return smaller optimal one <unknown> output consider correct test optimal radius bigger 1010 . first line contain number fan field n. next n line contain three integers : xi yi vi x - coordinate y - coordinate speed fan i begin one second interval consider task need output three point camera need select print three line every line contain x - coordinate y - coordinate separate a single space order point matter",['geometry'],2800.0
598/F,give simple ( without self - intersections ) n - gon necessary convex also give m line line find length common part line n - gon boundary n - gon belong polygon possible n - gon contain 180 - degree angle first line contain integers n m ( 3 ≤ n ≤ 1000 ; 1 ≤ m ≤ 100 ) follow n line contain coordinate polygon vertices ( clockwise counterclockwise direction ) vertices distinct follow m line contain line descriptions contain two <unknown> point a line coordinate give input coordinate real number give two digits decimal point exceed 105 absolute value print m line i - th line contain length common part give n - gon i - th line answer consider correct absolute relative error n't exceed 10 - 6,['geometry'],2900.0
600/D,give two circle find area intersection first line contain three integers x1 y1 r1 ( - 109 ≤ x1 y1 ≤ 109 1 ≤ r1 ≤ 109 ) — position center radius first circle second line contain three integers x2 y2 r2 ( - 109 ≤ x2 y2 ≤ 109 1 ≤ r2 ≤ 109 ) — position center radius second circle print area intersection circle answer consider correct absolute relative error n't exceed 10 - 6,['geometry'],2000.0
605/C,"mikhail <unknown> dream two things : become a cool programmer buy a flat moscow become a cool programmer need least p experience point a desire flat moscow cost q dollars mikhail determine follow dream register a freelance site <unknown> work n distinct project mikhail already evaluate <unknown> i - th project increase experience ai per day bring bi dollars per day freelance work imply <unknown> work hours mikhail free stop work one project time start work another project , receive respective share experience money mikhail try become a cool programmer able work one project moment time find real value equal minimum number days mikhail need make dream come true example suppose mikhail suggest work three project a1 = 6 b1 = 2 a2 = 1 b2 = 3 a3 = 2 b3 = 6 . also p = 20 q = 20 . order achieve aim mikhail work 2.5 days first third project indeed <unknown> + <unknown> + <unknown> = 6·2.5 + <unknown> + 2·2.5 = 20 <unknown> + <unknown> + <unknown> = 2·2.5 + <unknown> + 6·2.5 = 20 . first line input contain three integers n p q ( 1 ≤ n ≤ 100 000 1 ≤ p q ≤ 1 000 000 ) — number project require number experience money next n line contain two integers ai bi ( 1 ≤ ai bi ≤ 1 000 000 ) — daily increase experience daily income work i - th project print a real value — minimum number days mikhail need get require amount experience money answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer a answer jury b. checker program consider answer correct , first sample correspond example problem statement",['geometry'],2400.0
630/O,petya recently start work a programmer city company develop computer game besides game mechanics implementation create a game necessary create tool program use game designers create game level petya 's first assignment create a tool allow paint different arrows screen a user tool choose a point screen specify a vector ( arrow direction ) vary several parameters get require <unknown> effect first version program petya decide limit parameters arrow follow : a point coordinate ( px py ) a nonzero vector coordinate ( vx vy ) positive <unknown> a b c d a > c. produce arrow follow properties arrow consist a triangle a rectangle triangle isosceles base length a altitude length b perpendicular base rectangle side lengths c d. point ( px py ) situate middle triangle base middle side rectangle length c. area intersection triangle rectangle zero direction ( px py ) point triangle vertex opposite base contain point coincide direction ( vx vy ) vector enumerate arrow point coordinate counter - clockwise order start <unknown> line input contain eight integers px py vx vy ( - 1000 ≤ px py vx vy ≤ 1000 <unknown> + <unknown> > 0 ) a b c d ( 1 ≤ a b c d ≤ 1000 a > c ) output coordinate arrow point counter - clockwise order line contain two coordinate first x y. relative absolute error greater 10 - 9,['geometry'],2000.0
1642/A,sam live <unknown> downtown a triangular shape also follow true triangle : call a point downtown 's border ( border triangle ) safe reach point least one point line $$$ y = 0 $$$ walk along straight line without cross interior triangle find total length unsafe part downtown border prove part segment number finite test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case description test case follow test case contain three line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \le x_i y_i \le 1000000000 $$$ ) — coordinate vertices downtown 's border test case print a single number — answer problem answer consider correct absolute relative error exceed $$$ 10^ { -9 } $$$ formally let answer $$$ a $$$ jury answer $$$ b $$$ answer consider correct $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -9 } $$$ picture downtowns first three test case illustrate triangles enumerate accord indices test case belong first two test case point border downtowns safe thus answer $$$ 0 $$$ follow picture unsafe point third test case mark black color : fourth test case point border downtown safe,['geometry'],800.0
1641/F,"sam start play round bucket <unknown> also <unknown> <unknown> mom decide buy a new bucket need solve follow task give $$$ n $$$ distinct point integer coordinate $$$ a_1 a_2 \ldots a_n $$$ point generate square $$$ [ -100000000 100000000 ] \times [ -100000000 100000000 ] $$$ uniformly independently give positive integers $$$ k $$$ $$$ l $$$ $$$ k \leq l \leq n $$$ want select a subsegment $$$ a_i a _ { i+1 } \ldots a _ { <unknown> } $$$ point array ( $$$ 1 \leq i \leq n + 1 - l $$$ ) circle plane contain $$$ \geq k $$$ point select subsegment ( inside border ) smallest possible radius circle ? test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case descriptions test case follow first line test case contain three integers $$$ n $$$ $$$ l $$$ $$$ k $$$ ( $$$ 2 \leq k \leq l \leq n \leq 50\,000 $$$ $$$ k \leq 20 $$$ ) next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ -100000000 \leq x_i y_i \leq 100000000 $$$ ) — coordinate point $$$ a_i $$$ guarantee point distinct generate independently uniform distribution $$$ [ -100000000 100000000 ] \times [ -100000000 100000000 ] $$$ guarantee sum $$$ n $$$ test case exceed $$$ 50\,000 $$$ first test point generate uniform distribution $$$ [ -100000000 100000000 ] \times [ -100000000 100000000 ] $$$ simplicity test solution must pass hack <unknown> problem test case print a single real number — answer problem answer consider correct absolute relative error exceed $$$ 10^ { -9 } $$$ formally let answer $$$ a $$$ jury answer $$$ b $$$ answer consider correct $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -9 } $$$ first test case select subsegment $$$ a_1 a_2 $$$ a circle center $$$ ( 0 2 ) $$$ radius $$$ 2 $$$ second test case select subsegment $$$ a_1 a_2 a_3 a_4 $$$ a circle center $$$ ( 1 2 ) $$$ radius $$$ 1 $$$",['geometry'],3500.0
630/P,decide city distinguish <unknown> local company award form star cover gold one side order star necessary estimate order cost depend area gold - plate write a program calculate area a star a ` ` star '' figure n ≥ 5 corner n a prime number construct follow way circle radius r n point select distance adjacent ones equal every point connect a segment two maximally distant point areas bound segment part figure part line input contain two integers n ( 5 ≤ n < 109 n prime ) r ( 1 ≤ r ≤ 109 ) — number star corner radius <unknown> correspondingly output one number — star area relative error answer greater 10 - 7,['geometry'],2100.0
690/B2,heidi make sure zombie contamination level checker work 's time strike ! time zombie lair a strictly convex polygon lattice vertex polygon occupy a point lattice cell lattice heidi know level zombie contamination – number corner cell inside border lair give information heidi want know exact shape lair rain destruction zombies help ! input contain multiple test case first line test case contain one integer n size lattice grid ( 5 ≤ n ≤ 500 ) next n line contain n character describe level zombie contamination cell lattice every character every line a digit 0 4 . cells give order show picture : row go decrease value y coordinate one row cells go order increase x coordinate mean first row correspond cells coordinate ( 1 n ) ... ( n n ) last row correspond cells coordinate ( 1 1 ) ... ( n 1 ) last line file contain a zero line treat a test case sum n value test one file exceed 5000 . test case give follow output : first line output contain one integer v number vertices polygon secret lair next v line contain two integers denote vertices polygon clockwise order start lexicographically smallest vertex guarantee solution always exist unique guarantee correct solution coordinate polygon vertices 2 n - 2 . a vertex ( x1 y1 ) lexicographically smaller vertex ( x2 y2 ) x1 < x2,['geometry'],2600.0
717/I,cowboy beblop a funny little boy like sit computer somehow obtain two elastic hoop shape 2d polygons necessarily convex since 's gravity spaceship hoop stand still air since hoop elastic cowboy beblop stretch rotate translate shorten edge much want hoop give number vertices well position vertex define x y z coordinate vertices give order 're connect : 1st vertex connect 2nd connect 3rd etc . last vertex connect first one two hoop connect 's impossible pull infinity different directions <unknown> edge without edge vertices intersect point – like two link a chain connect polygons ' edge intersect overlap make things easier say two polygons well - connected edge one polygon cross area polygon two different directions ( upper lower side plane define polygon ) a different number time cowboy beblop fascinate hoop obtain would like know whether well - connected since ’ s busy play <unknown> <unknown> ’ d like figure promise sweets help ! first line input contain integer n ( 3 ≤ n ≤ 100 000 ) denote number edge first polygon next n line contain integers x y z ( - 1 000 000 ≤ x y z ≤ 1 000 000 ) — coordinate vertices manner mention next line contain integer m ( 3 ≤ m ≤ 100 000 ) denote number edge second polygon follow m line contain coordinate second polygon ’ s vertices guarantee polygons simple ( self - intersections ) general obtain polygonal line intersect also assume 3 consecutive point a polygon lie line output contain one line word ` ` yes '' ` ` '' depend whether two give polygons well - connected picture two polygons well - connected edge vertical polygon cross area horizontal one exactly one direction ( example ) zero time ( case ) note polygons parallel <unknown> <unknown> <unknown> plan general,['geometry'],2800.0
744/D,hongcow really like color red hongcow n't like color blue hongcow stand infinite field n red point m blue point hongcow want draw a circle field circle contain least one red point blue point point line exactly boundary circle count either inside outside compute radius largest circle satisfy condition circle arbitrarily large size print - 1 . otherwise answer accept relative absolute error 10 - 4 . first line input contain two integers n m ( 1 ≤ n m ≤ 1 000 ) next n line contain two integers xi yi ( 1 ≤ xi yi ≤ 104 ) denote coordinate a red point next m line contain two integers xi yi ( 1 ≤ xi yi ≤ 104 ) denote coordinate a blue point two point coordinate print - 1 circle arbitrary size otherwise print a float point number represent largest radius circle satisfy condition answer consider correct absolute relative error exceed 10 - 4 . namely let 's assume answer a answer jury b. checker program consider answer correct a picture first sample a picture second sample,['geometry'],3200.0
772/B,give a convex polygon p n distinct vertices p1 p2 ... pn vertex pi coordinate ( xi yi ) 2d plane vertices list clockwise order choose a real number d move vertex polygon a distance d original position find maximum value d matter move vertices polygon intersect stay convex first line one integer n ( 4 ≤ n ≤ 1 000 ) — number vertices next n line contain coordinate vertices line i contain two integers xi yi ( - 109 ≤ xi yi ≤ 109 ) — coordinate i - th vertex point guarantee give clockwise order form a strictly convex polygon ( particular three consecutive point lie straight line ) print one real number d maximum real number matter move vertices polygon stay convex answer consider correct absolute relative error exceed 10 - 6 . namely let 's assume answer a answer jury b. checker program consider answer correct a picture first <unknown> example make polygon non - convex optimal solution since maximum distance move one point ≈ <unknown> whereas make non - convex move point a distance ≈ <unknown>,['geometry'],1800.0
660/D,give n point a plane point distinct three lie line find number parallelograms vertices give point first line input contain integer n ( 1 ≤ n ≤ 2000 ) — number point next n line contain two integers ( xi yi ) ( 0 ≤ xi yi ≤ 109 ) — coordinate i - th point print integer c — number parallelograms vertices give point,['geometry'],1900.0
683/A,coordinate plane a square side parallel coordinate ax length square side equal a. lower leave corner square coincide point ( 0 0 ) ( point origin ) upper right corner square positive coordinate give a point coordinate ( x y ) task determine whether point locate strictly inside square side strictly outside square first line contain three integers a x y ( 1 ≤ a ≤ 1000 - 1000 ≤ x y ≤ 1000 ) — length square side coordinate point check print one integer :,['geometry'],1200.0
887/E,"masha 's little brother draw two point a sheet paper , draw circle give sheet sister masha return geometry lesson instantly notice interest facts brother 's draw first line go two point brother draw n't intersect touch circle also two circle intersect touch pair circle one circle locate inside another moreover circle masha draw a square minimal area side parallel axis circle locate inside square notice two square intersect touch pair square one square locate inside masha want draw circle minimal possible radius go two point brother draw n't intersect circle circle touch masha 's circle locate inside 's guarantee answer wo n't exceed 1012 . hold hack well first line contain four integers x1 y1 x2 y2 ( - 105 ≤ x1 y1 x2 y2 ≤ 105 ) — coordinate point brother draw first point coordinate ( x1 y1 ) second point coordinate ( x2 y2 ) two point different second line contain single integer n ( 1 ≤ n ≤ 105 ) — number circle brother draw next n line contain descriptions circle line contain three integers xi yi ri ( - 105 ≤ xi yi ≤ 105 1 ≤ ri ≤ 105 ) describe circle center ( xi yi ) radius ri output smallest real number 's possible draw a circle radius give point a way n't intersect circle output consider correct a relative absolute error 10 - 4",['geometry'],2800.0
1019/D,students many different part russia <unknown> come summer informatics school mark <unknown> sis participants a map decide prepare interest <unknown> base map first thing choose find three cities map form a triangle area $$$ s $$$ first line input contain two integers $$$ n $$$ $$$ s $$$ ( $$$ 3 \le n \le 2000 $$$ $$$ 1 \le s \le 2 \cdot 10^ { 18 } $$$ ) — number cities map area triangle find next $$$ n $$$ line contain descriptions cities one per line city describe integer coordinate $$$ x_i $$$ $$$ y_i $$$ ( $$$ -1000000000 \le x_i y_i \le 1000000000 $$$ ) guarantee cities locate distinct point also guarantee three cities lie line solution n't exist — print « » otherwise print « yes » follow three pair coordinate $$$ ( x y ) $$$ — locations three cities form triangle area $$$ s $$$,['geometry'],2700.0
1402/B,government treeland want build a new road network $$$ 2n $$$ cities treeland unfinished plan road network already contain $$$ n $$$ road segment connect two cities a straight line two road segment a common point ( include endpoints ) task determine $$$ n-1 $$$ additional road segment satisfy follow condition : first line standard input contain $$$ n $$$ ( $$$ { 2 \leq n \leq 100000 } $$$ ) – number exist road segment follow $$$ n $$$ line contain four integers : $$$ x_1 y_1 x_2 y_2 $$$ $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ coordinate endpoints segment $$$ ( -10000000 \leq x_i <unknown> 10000000 ) $$$ standard output must contain $$$ n-1 $$$ line contain four integers $$$ x_1 y_1 x_2 y_2 $$$ $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ coordinate cities endpoints a new road segment multiple solutions program may output,['geometry'],2900.0
157/B,"one day sherlock holmes track one important criminal find a wonderful paint wall wall could represent a plane paint several concentric circle divide wall several part part paint red paint blue besides two neighbor part paint different color , red blue color alternate i. e. follow one outer area wall ( area lie outside circle ) paint blue help sherlock holmes determine total area red part wall let us remind two circle call concentric center coincide several circle call concentric two concentric first line contain single integer n ( 1 ≤ n ≤ 100 ) second line contain n space - separated integers ri ( 1 ≤ ri ≤ 1000 ) — circle ' radii guarantee circle different print single real number — total area part wall paint red answer accept absolute relative error n't exceed 10 - 4 . first sample picture one circle radius 1 . inner part circle paint red area red part equal π × 12 = π . second sample three circle radii 1 4 2 . outside part second circle paint blue part second third circle paint red part first third paint blue , finally inner part first circle paint red overall two red part : ring second third circle inner part first circle total area red part equal ( π × 42 - π × 22 ) + π × 12 = π × 12 + π = <unknown>",['geometry'],1000.0
140/F,gerald ... word a new year eve constantine prepare unusual present beautiful lady present magic new year snowflake make dream come true new year snowflake consist tiny ice crystals <unknown> regard point plane beauty new year snowflake a center symmetry a point crystal snowflake exist another crystal symmetrical relative point one crystals place directly center symmetry constantine choose a snowflake among <unknown> snowflakes less symmetrical less magical <unknown> a difficult path <unknown> house mistress wait <unknown> <unknown> a long moments beautiful lady open door snowflake crystals melt naturally disappear constantine sure k crystals handle snowflake carefully ready demonstrate beautiful lady power <unknown> restore symmetry snowflakes give coordinate survive snowflake crystals give <unknown> task identify possible position original center symmetry first line contain two integers n k ( 1 ≤ n ≤ 200 000 0 ≤ k ≤ 10 ) — number survive snowflake crystals maximum number melt crystals correspondingly next n line contain coordinate crystals leave follow form : ` ` xi yi '' coordinate integers exceed 5·108 absolute value give point different first line contain integer c — number possible symmetry center next c line contain center ' descriptions symmetry center describe a couple coordinate ` ` x y '' separate a space print coordinate absolute error exceed 10 - 6 . allow print symmetry center order print point different exist infinite number possible symmetry center print single number ` ` -1 '',['geometry'],2600.0
681/E,dima live a dormitory well cockroaches moment 0 dima saw a cockroach run a table decide kill dima need exactly t second aim precisely strike cockroach finish survive cockroach run a shadow cast round plat stand table t second shadow cast plat shape a circle shadow circle may intersect nest overlap arbitrarily cockroach use follow strategy : first equiprobably pick a direction run towards run towards constant speed v. moment t ≤ t reach shadow circle immediately stop shadow thus stay alive otherwise cockroach kill dima 's precise strike consider dima 's precise strike instant determine probability cockroach stay alive first line input four integers x0 y0 v t ( <unknown> <unknown> ≤ 109 0 ≤ v t ≤ 109 ) give — cockroach initial position table cartesian system moment 0 cockroach 's constant speed time second dima need aim respectively next line number n ( 1 ≤ n ≤ 100 000 ) give — number shadow circle cast plat next n line shadow circle description give : ith consist three integers xi yi ri ( |xi| |yi| ≤ 109 0 ≤ r ≤ 109 ) — ith shadow circle <unknown> - table position cartesian system radius respectively consider table big enough cockroach run table edge avoid dima 's precise strike print real number p — probability cockroach stay alive answer consider correct absolute relative error exceed 10 - 4 . picture first sample give red color stand point choose cockroach 's run direction cause kill green color stand <unknown> directions please note despite contain a circle center ( - 2 2 ) a part <unknown> color red cockroach able reach one second,['geometry'],2500.0
593/B,"teacher give anton a large geometry homework n't ( usual ) participate a regular round codeforces task give a set n line define equations y = <unknown> + bi necessary determine whether least one point intersection two line lay strictly inside strip x1 < x2 word true 1 ≤ i < j ≤ n x ' y ' : ca n't leave anton trouble ? write a program solve give task first line input contain integer n ( 2 ≤ n ≤ 100 000 ) — number line task give anton second line contain integers x1 x2 ( - 1 000 000 ≤ x1 < x2 ≤ 1 000 000 ) define strip inside need find a point intersection least two line follow n line contain integers ki bi ( - 1 000 000 ≤ ki bi ≤ 1 000 000 ) — descriptions line guarantee line pairwise distinct , two i ≠ j true either ki ≠ kj bi ≠ bj print ` ` yes '' ( without quote ) least one intersection two distinct line locate strictly inside strip otherwise print ` ` '' ( without quote ) first sample intersections locate border strip intersections locate strictly inside",['geometry'],1600.0
379/E,"due <unknown> <unknown> past christmas n't <unknown> celebrate russia <unknown> century a result russian traditions christmas new year mix one event celebrate new year include tree a <unknown> - like ' grandfather frost ' present huge family <unknown> dinner party country <unknown> a tree new year instal house a tradition usually whole family decorate tree new year eve hope codeforces a big love family problem go decorate a tree well , decoration consist n piece piece a piece color paper border a close polyline a special shape piece go one one show picture i - th piece a polyline go point : ( 0 0 ) ( 0 y0 ) ( 1 y1 ) ( 2 y2 ) ... ( k yk ) ( k 0 ) width piece equal k. piece number 1 ( show red figure ) outer piece ( see completely ) piece number 2 ( show yellow ) follow ( n't see completely partially close first piece ) programmers quite curious guy moment hang a decoration new year tree start wonder : area piece people see ? first line contain two integers n k ( 1 ≤ n k ≤ 300 ) follow n line contain k + 1 integers — description polyline i - th line contain <unknown> yi 0 yi 1 ... yi k mean polyline i - th piece go point ( 0 0 ) ( 0 yi 0 ) ( 1 yi 1 ) ( 2 yi 2 ) ... ( k yi k ) ( k 0 ) ( 1 ≤ yi j ≤ 1000 ) print n real number — polyline area visible part answer consider correct relative absolute error exceed 10 - 4",['geometry'],2500.0
598/C,give set vectors plane start origin task find a pair vectors minimal non - oriented angle non - oriented angle non - negative value minimal clockwise counterclockwise direction angle non - oriented angle always 0 π . example opposite directions vectors angle equal π . first line input contain a single integer n ( 2 ≤ n ≤ 100 000 ) — number vectors i - th follow n line contain two integers xi yi ( |x| |y| ≤ 10 000 x2 + y2 > 0 ) — coordinate i - th vector vectors number 1 n order appear input guarantee two vectors input share direction ( still opposite directions ) print two integer number a b ( a ≠ b ) — a pair indices vectors minimal non - oriented angle print number order many possible answer print,['geometry'],2300.0
933/C,"<unknown> <unknown> nian monster 're <unknown> <unknown> ! maybe <unknown> make a nice <unknown> little tommy watch a <unknown> show circular shape spread across sky a <unknown> view <unknown> night <unknown> new year 's eve a wonder strike tommy many regions form circle sky ? consider sky a flat plane a region a connect part plane positive area whose bind consist part bound circle a curve several curve without self - intersections contain curve boundaries note exactly one regions extend infinitely first line input contain one integer n ( 1 ≤ n ≤ 3 ) denote number circle follow n line contain three space - separated integers x y r ( - 10 ≤ x y ≤ 10 1 ≤ r ≤ 10 ) describe a circle whose center ( x y ) radius r. two circle x y r time print a single integer — number regions plane first example second example third example ,",['geometry'],2700.0
1841/F,"monocarp play a strategic computer game develop a city city inhabit creatures four different race — humans elves orcs dwarves inhabitant city a happiness value integer depend many creatures different race inhabit city specifically happiness inhabitant $$$ 0 $$$ default ; increase $$$ 1 $$$ creature race decrease $$$ 1 $$$ creature a hostile race humans hostile orcs ( vice versa ) elves hostile dwarves ( vice versa ) begin game monocarp 's city inhabit anyone game $$$ n $$$ group creatures come city wish settle $$$ i $$$ -th group consist $$$ a_i $$$ humans $$$ b_i $$$ orcs $$$ c_i $$$ elves $$$ d_i $$$ dwarves time monocarp either accept entire group creatures city reject entire group game calculate monocarp 's score accord follow formula : $$$ m + k $$$ $$$ m $$$ number inhabitants city $$$ k $$$ sum happiness value creatures city help monocarp earn maximum possible number point end game ! first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 3 \cdot 10^ { 5 } $$$ ) — number group creatures come monocarp 's city $$$ n $$$ line follow $$$ i $$$ -th contain four integers $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ $$$ d_i $$$ ( $$$ 0 \leq a_i b_i c_i d_i \leq 10^ { 9 } $$$ ) — number humans orcs elves dwarves ( respectively ) $$$ i $$$ -th group output a single number — maximum score monocarp end game answer consider correct absolute relative error exceed $$$ 10^ { -9 } $$$ , answer $$$ a $$$ jury 's answer $$$ b $$$ solution accept $$$ \frac { |a - b| } { \max ( 1 |b| ) } \le 10^ { -9 } $$$ note correct answer always integer sometimes n't fit $$$ 64 $$$ -bit integer type allow print a non - integer number first example best course action accept group second example best course action accept group $$$ 2 $$$ $$$ 3 $$$ <unknown> group $$$ 1 $$$ $$$ 4 $$$",['geometry'],2700.0
223/E,"a graph call planar draw a way edge intersect vertexes articulation point a vertex undirected graph remove increase number connect components graph a bridge edge undirected graph remove increase number connect components graph ' ve get a connect undirected planar graph consist n vertexes number 1 n draw plane graph bridge articulation point loop multiple edge also give q query query a cycle graph query response number graph vertexes ( draw a graph cycle plane ) locate either inside cycle , write a program give graph query answer query first line contain two space - separated integers n m ( 3 ≤ n m ≤ 105 ) — number vertexes edge graph next m line contain edge graph : i - th line contain two space - separated integers ui vi ( 1 ≤ ui vi ≤ n ) — number vertexes connect i - th edge next n line contain position planar graph vertexes plane : i - th line contain a pair space - separated integers xi yi ( |xi| |yi| ≤ 109 ) — coordinate i - th vertex graph plane next line contain integer q ( 1 ≤ q ≤ 105 ) — number query follow q line describe query : i - th line contain sequence space - separated integers ki a1 a2 ... aki ( 1 ≤ aj ≤ n ; ki > 2 ) ki cycle length i - th query aj number vertexes form a cycle number vertexes cycle give clockwise counterclockwise order give cycle simple go a graph vertex total length cycle query exceed 105 . guarantee give graph contain bridge articulation point loop multiple edge guarantee edge segment common point graph 's vertexes query print a single integer — number vertexes inside cycle print answer order query follow input separate number space",['geometry'],3000.0
1468/F,$$$ n $$$ persons locate a plane $$$ i $$$ -th person locate point $$$ ( x_i y_i ) $$$ initially look point $$$ ( u_i v_i ) $$$ moment time persons start rotate clockwise <unknown> <unknown> speed rotate one full $$$ <unknown> $$$ <unknown> turn say persons $$$ a $$$ $$$ b $$$ make eye contact person $$$ a $$$ look person $$$ b $$$ 's direction moment person $$$ b $$$ look person $$$ a $$$ 's direction a person $$$ c $$$ locate persons $$$ a $$$ $$$ b $$$ <unknown> $$$ a $$$ $$$ b $$$ make eye contact a person make eye contact one person time calculate number pair persons make eye contact least rotation ( include initial moment ) first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number persons follow $$$ n $$$ line describe persons line contain four space - separated integers $$$ x_i y_i u_i v_i $$$ ( $$$ |x_i| |y_i| <unknown> <unknown> \le 1000000000 $$$ ; $$$ x_i \ne u_i $$$ $$$ y_i \ne v_i $$$ ) ( $$$ x_i y_i $$$ ) coordinate point $$$ i $$$ -th person locate ( $$$ u_i $$$ $$$ v_i $$$ ) coordinate point $$$ i $$$ -th person look initially person 's location unique test case sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print one integer — number pair persons make eye contact least rotation include initial moment,['geometry'],1700.0
44/F,anfisa <unknown> get disappoint word processors n't good enough reflect range emotions 's decide switch <unknown> editors open <unknown> saw a white rectangle w × h size paint first anfisa learn navigate draw tool use paint segment quickly paint rectangle a certain number black - colored segment result picture n't seem bright enough anfisa 's turn attention ` ` fill '' tool use find a point rectangle paint choose a color area color point contain completely paint choose color apply fill several time anfisa express emotions completely stop paint task information paint segment apply fill find every color total area areas paint color fill first input line two integers w h ( 3 ≤ w h ≤ 104 ) — size initially white rectangular paint area second line contain integer n — number black segment ( 0 ≤ n ≤ 100 ) next n line describe segment give coordinate endpoints x1 y1 x2 y2 ( 0 < x1 x2 < w 0 < y1 y2 < h ) segment non - zero length next line contain <unknown> number fill m ( 0 ≤ m ≤ 100 ) follow m line define fill operation form ` ` x y color '' ( x y ) coordinate choose point ( 0 < x < w 0 < y < h ) color — a line lowercase latin letter 1 15 symbols length determine color coordinate give input integers initially rectangle ` ` white '' color whereas segment draw ` ` black '' color every color present final picture print single line name color total area areas paint color accuracy 10 - 6 . print color order initially black segment paint anfisa also paint a color choose point lay segment segment areas equal 0 . final picture part segment paint color area paint color equal 0,['geometry'],2700.0
85/E,a far away kingdom live a greedy king <unknown> land build n guard tower apart tower kingdom two armies head a <unknown> <unknown> general general ca n't stand specifically never let soldier two armies present one tower <unknown> operations manage a guard tower a general send part army tower general ask fee king manage tower live a really far away kingdom general evaluate fee follow weird manner : find two remotest ( distant ) tower soldier army situate ask fee equal distance tower represent a point plane coordinate ( x y ) distance two point coordinate ( x1 y1 ) ( x2 y2 ) determine kingdom <unknown> - <unknown> + <unknown> - <unknown> greedy king exactly satisfy a requirement general 's agree pay one fee two general equal maximum two demand fee however king still green greed among ways arrange tower armies want find cheapest one tower occupy soldier exactly one army hire find minimum amount money enough pay fee king also <unknown> also count number arrangements cost amount money number quite large enough king know a remainder divide 109 + 7 . two arrangements distinct set tower occupy soldier first general distinct first line contain integer n ( 2 ≤ n ≤ 5000 ) n number guard tower follow n line contain two integers x y — coordinate i - th tower ( 0 ≤ x y ≤ 5000 ) two tower present one point pretest 6 one maximal test problem print first line smallest possible amount money enough pay fee general print second line number arrangements carry use smallest possible fee number calculate modulo 1000000007 ( 109 + 7 ) first example two tower distance equal 2 . give tower one general well pay 2 units money general receive a tower manage fee equal 0 . smallest possible fee easily see obtain two ways,['geometry'],2600.0
223/D,"a plane contain a necessarily convex polygon without self - intersections consist n vertexes number 1 n. a spider sit border polygon spider move like : initially spider locate polygon vertex number s. find length shortest path vertex number t consist transfer descend distance determine usual euclidean <unknown> first line contain integer n ( 3 ≤ n ≤ 105 ) — number vertexes give polygon next n line contain two space - separated integers — coordinate polygon vertexes vertexes list counter - clockwise order coordinate polygon vertexes exceed 104 absolute value last line contain two space - separated integers s t ( 1 ≤ s t ≤ n ) — start end vertexes seek shortest way consider polygon vertexes number order give input , coordinate first vertex locate second line input coordinate n - th vertex ( n + 1 ) -th line guarantee give polygon simple , contain self - intersections self - <unknown> output print a single real number — length shortest way vertex s vertex t. answer consider correct absolute relative error exceed 10 - 6 . first sample spider transfer along side connect vertexes 1 4 . second sample spider n't transfer anywhere distance equal zero third sample best strategy spider transfer vertex 3 point ( 2,3 ) descend point ( 2,1 ) transfer vertex 1",['geometry'],3000.0
1016/E,a light source plane source small represent point light source move point $$$ ( a s_y ) $$$ $$$ ( b s_y ) $$$ $$$ ( s_y < 0 ) $$$ speed equal $$$ 1 $$$ unit per second trajectory light source a straight segment connect two point also a fence $$$ ox $$$ axis represent $$$ n $$$ segment $$$ ( l_i r_i ) $$$ ( actual coordinate endpoints segment $$$ ( l_i 0 ) $$$ $$$ ( r_i 0 ) $$$ ) point $$$ ( x y ) $$$ shade segment connect $$$ ( x y ) $$$ current position light source intersect touch segment fence give $$$ q $$$ point point calculate total time point shade light source move $$$ ( a s_y ) $$$ $$$ ( b s_y ) $$$ first line contain three space separate integers $$$ s_y $$$ $$$ a $$$ $$$ b $$$ ( $$$ -1000000000 \le s_y < 0 $$$ $$$ 1 \le a < b \le 1000000000 $$$ ) — correspond coordinate light source second line contain single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number segment fence next $$$ n $$$ line contain two integers per line : $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i < r_i \le 1000000000 $$$ $$$ r _ { i - 1 } < l_i $$$ ) — segment fence increase order segment n't intersect touch next line contain single integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number point check next $$$ q $$$ line contain two integers per line : $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le 1000000000 $$$ ) — point process print $$$ q $$$ line $$$ i $$$ -th line contain one real number — total time $$$ i $$$ -th point shade light source move $$$ ( a s_y ) $$$ $$$ ( b s_y ) $$$ answer consider correct absolute relative error n't exceed $$$ 10^ { -6 } $$$,['geometry'],2400.0
1059/D,a forest model a plane live $$$ n $$$ rare animals animal number $$$ i $$$ lair point $$$ ( x _ { i } y _ { i } ) $$$ order protect a decision build a nature reserve make reserve must a form a circle contain lairs also a straight river flow forest animals drink river therefore must least one common point reserve hand ship constantly <unknown> along river reserve must one common point river convenience scientists make a transformation coordinate river define $$$ y = 0 $$$ check whether possible build a reserve possible find minimum possible radius a reserve first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number animals next $$$ n $$$ line contain two integers $$$ x _ { i } $$$ $$$ y _ { i } $$$ ( $$$ -10000000 \le x _ { i } y _ { i } \le 10000000 $$$ ) — coordinate $$$ i $$$ -th animal 's lair guarantee $$$ y _ { i } \neq 0 $$$ two lairs coincide reserve build print $$$ -1 $$$ otherwise print minimum radius answer accept absolute relative error exceed $$$ 10^ { -6 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer consider correct $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -6 } $$$ first sample optimal build reserve radius equal $$$ 0.5 $$$ center $$$ ( 0 \ 0.5 ) $$$ second sample impossible build a reserve third sample optimal build reserve radius equal $$$ \frac { 5 } { 8 } $$$ center $$$ ( \frac { 1 } { 2 } \ \frac { 5 } { 8 } ) $$$,['geometry'],2200.0
1071/E,a lot people dream convertibles ( also often call <unknown> ) convertibles however n't roof <unknown> rain <unknown> ask famous <unknown> decide create a rain <unknown> mechanism convertibles workplace mechanism a part plane driver <unknown> part consist two rail slide endpoints a piece stretch rope sake simplicity consider a pair parallel segment a plane rope segment whose endpoints free choose point rail segment algorithmic part mechanism detect particular raindrop predict reach plane exact moment rope segment must contain raindrop point ( rope <unknown> raindrop ) give initial position rope endpoints information raindrops choose minimal possible speed $$$ v $$$ endpoints slide ( endpoints slide direction along segment independently ) a way possible catch raindrops move endpoints speed greater $$$ v $$$ find 's impossible matter high speed first line contain three integers $$$ n $$$ $$$ w $$$ $$$ h $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 1\le w h \le 1000 $$$ ) mean $$$ n $$$ raindrops two rail represent segment connect $$$ ( 0 0 ) $$$ $$$ ( w 0 ) $$$ connect $$$ ( 0 h ) $$$ $$$ ( w h ) $$$ second line contain two integers $$$ e_1 $$$ $$$ e_2 $$$ mean initial ( moment $$$ t = 0 $$$ ) position endpoints $$$ ( e_1 0 ) $$$ $$$ ( e_2 h ) $$$ ( $$$ 0\le e_1 <unknown> w $$$ ) $$$ i $$$ -th follow $$$ n $$$ line contain three integers $$$ t_i $$$ $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1\le <unknown> 100000 $$$ $$$ 0\le x_i \le w $$$ $$$ 0 < y_i < h $$$ ) mean $$$ i $$$ -th raindrop touch plane point $$$ ( x_i y_i ) $$$ time moment $$$ t_i $$$ guarantee $$$ t_i \le t _ { i+1 } $$$ valid $$$ i $$$ impossible catch raindrops print $$$ -1 $$$ otherwise print least possible maximum speed rope endpoints possible catch answer consider correct absolute relative error n't exceed $$$ 10^ { -4 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer consider correct $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -4 } $$$ one act first sample test : second :,['geometry'],3500.0
1468/G,hobbits <unknown> sam carry one ring <unknown> order spot orcs decide go mountains mountain relief represent a polyline $$$ n $$$ point $$$ ( x_i y_i ) $$$ number $$$ 1 $$$ $$$ n $$$ ( $$$ x_i < x _ { i + 1 } $$$ $$$ 1 \le i \le n - 1 $$$ ) hobbits start journey point $$$ ( x_1 y_1 ) $$$ reach point $$$ ( x_n y_n ) $$$ complete mission problem a tower eye sauron watch tower locate point $$$ ( x_n y_n ) $$$ height $$$ h $$$ eye locate point $$$ ( x_n y_n + h ) $$$ order complete mission successfully hobbits wear cloak time sauron eye see i. e. a direct line eye hobbits intersect relief hobbits low height consider negligibly small still positive a direct line sauron eye hobbits touch relief eye see hobbits like wear cloak wear spot eye task calculate total distance hobbits walk wear cloak first line input contain two integers $$$ n $$$ $$$ h $$$ ( $$$ 2 \le n \le 200000 $$$ ; $$$ 1 \le h \le 10000 $$$ ) — number vertices polyline tower height next $$$ n $$$ line contain two integers $$$ x_i y_i $$$ ( $$$ 0 \le x_i \le 400000 $$$ ; $$$ 0 \le y_i \le 10000 $$$ ) — coordinate polyline vertices guarantee $$$ x_i < x _ { i + 1 } $$$ $$$ 1 \le i \le n - 1 $$$ print one real number — total distance hobbits walk wear cloak answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ — formally answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \dfrac { |a - b| } { \max ( 1 b ) } \le 10^ { -6 } $$$,['geometry'],2500.0
1575/B,mr . chanek live a city represent a plane want build amusement park shape a circle radius $$$ r $$$ circle must touch origin ( point $$$ ( 0 0 ) $$$ ) $$$ n $$$ bird habitats a photo spot tourists park $$$ i $$$ -th bird habitat point $$$ p_i = ( x_i y_i ) $$$ find minimum radius $$$ r $$$ a park least $$$ k $$$ bird habitats inside a point consider inside park distance $$$ p_i $$$ center park less equal radius park note center radius park need integers problem guarantee give input always a solution $$$ r \leq 200000 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ 1 \leq k \leq n $$$ ) — number bird habitats city number bird habitats require inside park $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 0 \leq |x_i| |y_i| \leq 100000 $$$ ) — position $$$ i $$$ -th bird habitat output a single real number $$$ r $$$ denote minimum radius a park least $$$ k $$$ bird habitats inside guarantee give input always a solution $$$ r \leq 200000 $$$ answer consider correct absolute relative error exceed $$$ 10^ { -4 } $$$ formally let answer $$$ a $$$ jury 's answer $$$ b $$$ answer accept $$$ \frac { |a - b| } { \max { ( 1 |b| ) } } \le 10^ { -4 } $$$ first example mr . chanek put center park $$$ ( -3 -1 ) $$$ radius $$$ \sqrt { 10 } <unknown> <unknown> $$$ prove minimum $$$ r $$$ follow illustrate first example blue point represent bird habitats red circle represent amusement park,['geometry'],2300.0
65/C,"brothers <unknown> <unknown> weasley get sport goods store open a box <unknown> ball long <unknown> experiment find golden snitch <unknown> simply a program device always move along trajectory a polyline vertices point ( x0 y0 z0 ) ( x1 y1 <unknown> ) ... ( xn yn zn ) begin game snitch position point ( x0 y0 z0 ) move along polyline constant speed vs. <unknown> yet find snitch behave nevertheless hope retrieve information help harry potter team upcoming match slytherin harry potter learn begin game point ( px py pz ) super fast <unknown> <unknown> <unknown> allow move constant speed vp direction remain idle vp less speed snitch vs. harry potter course want catch snitch soon possible , catch snitch move along polyline impossible want hurry weasley brothers experiment harry potter catch snitch time point help harry first line contain a single integer n ( 1 ≤ n ≤ 10000 ) follow n + 1 line contain coordinate xi yi zi separate single space coordinate two consecutive point coincide next line contain <unknown> vp vs last line contain px py pz separate single space number input integers absolute value exceed 104 . speed strictly positive guarantee vs ≤ vp harry potter catch snitch move along polyline ( include end ( xn yn zn ) ) print ` ` yes '' first line ( without quote ) print second line t earliest moment time harry able catch snitch third line print three number x y z coordinate point happen absolute relative error answer exceed 10 - 6 . harry able catch snitch move along describe polyline print ` ` ''",['geometry'],2100.0
1394/C,boboniu define bn - string a string $$$ s $$$ character ' b ' ' n ' perform follow operations bn - string $$$ s $$$ : note a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end boboniu think bn - strings $$$ s $$$ $$$ t $$$ similar : boboniu also define $$$ \text { dist } ( s t ) $$$ distance $$$ s $$$ $$$ t $$$ minimum number operations make $$$ s $$$ similar $$$ t $$$ boboniu give $$$ n $$$ non - empty bn - strings $$$ s_1 s_2 \ldots s_n $$$ ask find a non - empty bn - string $$$ t $$$ maximum distance string $$$ s $$$ minimize i.e need minimize $$$ \max _ { i=1 } ^n \text { dist } ( s_i t ) $$$ first line contain a single integer $$$ n $$$ ( $$$ 1\le n\le 3\cdot 100000 $$$ ) next $$$ n $$$ line contain a string $$$ s_i $$$ ( $$$ 1\le |s_i| \le 5\cdot 100000 $$$ ) guarantee $$$ s_i $$$ contain ' b ' ' n ' sum $$$ |s_i| $$$ exceed $$$ 5\cdot 100000 $$$ first line print minimum $$$ \max _ { i=1 } ^n \text { dist } ( s_i t ) $$$ second line print suitable $$$ t $$$ several possible $$$ t $$$ 's print first example $$$ \text { dist ( b bn ) } = \text { dist ( n bn ) } = 1 $$$ $$$ \text { dist ( bn bn ) } = 0 $$$ maximum distance $$$ 1 $$$,['geometry'],2600.0
613/A,"peter get a new snow <unknown> a new year present course peter decide try immediately read instructions realize work like regular snow blow machine order make work need tie point cover switch a result go along a circle around point remove snow path formally assume peter 's machine a polygon a plane , machine switch make a circle around point peter tie ( point lie strictly outside polygon ) , point lie within border polygon move along circular trajectory center circle point peter tie machine peter decide tie car point p wonder area <unknown> region clear snow help first line input contain three integers — number vertices polygon n ( ) coordinate point p. next n line contain two integers — coordinate vertices polygon clockwise counterclockwise order guarantee three consecutive vertices lie a common straight line number input integers exceed 1 000 000 absolute value print a single real value number — area region clear answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer a answer jury b. checker program consider answer correct , first sample snow remove area :",['geometry'],1900.0
8/D,"two neighbour alan bob live city three build : a cinema a shop house live rest a big asphalt square go cinema film impress deeply leave cinema want stop discuss bob want get home alan go shop first go home , agree cover distance together discuss film ( common path might pass shop might walk circle around cinema together ) part 's company go way part start think daily <unknown> ; even meet wo n't able go discussion thus bob 's path a continuous curve cinema house end alan 's path — a continuous curve go shop cinema house end film end late 's whole distance cover alan differ shortest one t1 distance cover bob differ shortest one t2 find maximum distance alan bob cover together discuss film first line contain two integers : t1 t2 ( 0 ≤ t1 t2 ≤ 100 ) second line contain cinema 's coordinate third one — house 's last line — shop 's coordinate give meter integer exceed 100 absolute <unknown> two give place build line output one number — maximum distance alan bob cover together discuss film output answer accurate less 4 decimal place",['geometry'],2600.0
55/E,give a convex polygon count please number triangles contain a give point plane vertices vertices polygon guarantee point n't lie side diagonals polygon first line contain integer n — number vertices polygon ( 3 ≤ n ≤ 100000 ) polygon description follow : n line contain coordinate vertices clockwise order ( integer x y greater 109 absolute value ) guarantee give polygon nondegenerate convex ( three point lie line ) next line contain integer t ( 1 ≤ t ≤ 20 ) — number point count answer follow t line coordinate point ( integer x y greater 109 absolute value ) output contain t integer number a separate line i - th number answer i - th point please use % lld specificator read write 64 - bit integers c++ preffered use cin ( also may use % i64d ),['geometry'],2500.0
771/F,bearland a big square plane contain point coordinate exceed 106 absolute value n house bearland i - th locate point ( xi yi ) n point distinct subsets may collinear bear limak live first house want destroy house build a new one somewhere bearland bear n't like big change every three point ( house ) pi pj pk sign cross product ( pj - pi ) × ( pk - pi ) relocation negative / positive / zero still negative / positive / zero respectively condition satisfy triple indices ( i j k ) possibly equal different 1 . additionally limak n't allow build house point house already exist ( point old house ) formula define difference cross product point ( ax ay ) ( bx ) : consider a set possible new placements limak 's house task find area set point formally let 's say limak choose new placement randomly ( coordinate choose independently uniformly random interval [ - 106 106 ] ) let p denote probability get allow placement new house let s denote area bearland ( s = <unknown> ) task find <unknown> first line input contain integer t ( 1 ≤ t ≤ 500 ) — number test case description test case follow first line description a test case contain integer n ( 3 ≤ n ≤ 200 000 ) — number house i - th next n line contain two integers xi yi ( - 106 ≤ xi yi ≤ 106 ) — coordinate i - th house two house locate point test case limak live first house sum n wo n't exceed 200 000 . print one real value denote area set point possible new placements limak 's house answer consider correct absolute relative error n't exceed 10 - 6 . precisely let jury 's answer b answer a. answer accept sample test 4 test case first test case four house limak 's one ( 5 3 ) set valid new placements form a triangle vertices point ( 0 1 ) ( 10 1 ) ( 3 51 ) without side area a triangle 250 . second test case set valid new placements form a rectangle width 50 000 height 2 000 000 . n't forget new placement must inside big square represent bearland third test case three give point collinear cross product equal 0 0 relocation well hence limak 's new house must lie line go give point since must also inside big square new possible placements limit segment ( exclude two point house ) area segment 0,['geometry'],3300.0
250/D,two villages separate a river flow north south villagers want build a bridge across river make easier move across villages river bank assume vertical straight line x = a x = b ( 0 < a < b ) west village lie a <unknown> point o = ( 0 0 ) n pathways lead village river end point ai = ( a yi ) villagers plain simple pathways straight segment well east village reserve cunning people village forest east bank river exact position clear m <unknown> paths lead village river end point bi = ( b y ' i ) lengths paths know length path lead eastern village point bi equal li villagers want choose exactly one point leave bank river ai exactly one point right bank bj connect a straight - line bridge make total distance villages ( sum <unknown> + <unknown> + lj <unknown> euclidean distance point x y ) minimum euclidean distance point ( x1 y1 ) ( x2 y2 ) equal help find require pair point first line contain integers n m a b ( 1 ≤ n m ≤ 105 0 < a < b < 106 ) second line contain n integers ascend order : i - th integer determine coordinate point ai equal yi ( |yi| ≤ 106 ) third line contain m integers ascend order : i - th integer determine coordinate point bi equal y ' i ( <unknown> ' <unknown> ≤ 106 ) fourth line contain m integers : i - th determine length path connect eastern village point bi equal li ( 1 ≤ li ≤ 106 ) guarantee a point c <unknown> least b <unknown> ≤ li i ( 1 ≤ i ≤ m ) guarantee two point ai coincide guarantee two point bi coincide print two integers — number point leave ( west ) right ( east ) bank respectively need build a bridge assume point west bank number 1 n order give input similarly point east bank number 1 m order give input multiple solutions print solution accept final length path differ answer jury 10 - 6 absolute relative value,['geometry'],1900.0
682/E,"give n point integer coordinate plane point give a way triangle form three n point area exceed s. alyona try construct a triangle integer coordinate contain n point area n't exceed 4s , obvious reason success please help alyona construct triangle please note vertices result triangle necessarily choose n give point first line input two integers n s ( 3 ≤ n ≤ 5000 1 ≤ s ≤ 1018 ) give — number point give upper bind value triangle 's area form three give n point next n line describe give point : ith consist two integers xi yi ( - 108 ≤ xi yi ≤ 108 ) — coordinate ith point guarantee least one triple point lie line print coordinate three point — vertices a triangle contain n point area n't exceed 4s coordinate every triangle 's vertex print a separate line every coordinate pair separate a single space coordinate integers exceed 109 absolute value guarantee least one desire triangle one answer print",['geometry'],2600.0
198/C,qwerty <unknown> arrive diatar system a important task deliver a special carcinogen scientific research planet persephone <unknown> qwerty get planet soon possible a lose day may fail negotiations nobody go pay <unknown> carcinogen consider qwerty 's ship planet persephone star diatar point a plane diatar locate origin coordinate ax — point ( 0 0 ) persephone go round diatar along a circular orbit radius r counter - clockwise direction constant linear speed vp ( thus instance a full circle around star take time ) initial moment time persephone locate point ( xp yp ) initial moment time qwerty 's ship point ( x y ) qwerty move direction speed v ( v > vp ) star diatar hot ( star ) qwerty ca n't get close ship 's metal <unknown> melt distance r ( r < r ) star find minimum time qwerty need get carcinogen planet persephone first line contain space - separated integers xp yp vp ( - 104 ≤ xp yp ≤ 104 1 ≤ vp < 104 ) — persephone 's initial position speed go round diatar second line contain space - separated integers x y v r ( - 104 ≤ x y ≤ 104 1 < v ≤ 104 1 ≤ r ≤ 104 ) — <unknown> position qwerty 's ship maximum speed minimum safe distance star diatar guarantee r2 < x2 + y2 r2 < <unknown> + <unknown> vp < v. print a single real number — minimum possible delivery time answer consider valid absolute relative error exceed 10 - 6,['geometry'],2400.0
607/E,genos give n distinct line cartesian plane let a list intersection point line a single point might appear multiple time list intersection multiple pair line order list matter give a query point ( p q ) let correspond list distance point query point distance refer euclidean distance a <unknown> euclidean distance two point ( x1 y1 ) ( x2 y2 ) genos give a point ( p q ) a positive integer m. ask find sum m smallest elements duplicate elements treat separate elements genos <unknown> <unknown> e problems ask help first line input contain a single integer n ( 2 ≤ n ≤ 50 000 ) — number line second line contain three integers x y m ( |x| |y| ≤ 1 000 000 ) — encode coordinate query point integer m statement query point ( p q ) obtain word divide x y 1000 get actual query point denote length list guarantee next n line contain two integers ai bi ( |ai| |bi| ≤ 1 000 000 ) — parameters a line form : guarantee two line ( ai bi ) ≠ ( aj bj ) i ≠ j. print a single real number sum m smallest elements answer consider correct absolute relative error exceed 10 - 6 . clarify let 's assume answer a answer jury b. checker program consider answer correct first sample three closest point distance second sample two line y = <unknown> - 1000 intersect ( <unknown> <unknown> ) point a distance ( - 1000 - 1000 ) third sample three line intersect point ( 1 1 ) intersection point present three time since intersection three pair line since distance intersection point query point 2 answer three time 6,['geometry'],3300.0
611/G,limak a little polar bear accord old traditions bear family prepare a new year cake limak like cake may know a new year cake a strictly convex polygon n vertices parent wo n't allow limak eat half a cake would get <unknown> think decide cut a cake along one n · ( n - 3 ) / 2 diagonals limak get a non - greater piece limak understand rule wo n't happy second piece happen much bigger limak 's disappointment equal difference piece ' areas multiply two prove integer give constraints n · ( n - 3 ) / 2 possible scenarios consider find sum value limak 's disappointment modulo 109 + 7 . first line input contain a single integer n ( 4 ≤ n ≤ 500 000 ) — number vertices polygon denote cake next n line contain two integers xi yi ( |xi| |yi| ≤ 109 ) — coordinate i - th point 's guarantee point distinct polygon strictly convex point give clockwise order print sum value limak 's disappointment possible scenarios modulo 109 + 7 . first sample possible value limak 's disappointment 0 18 18 24 30,['geometry'],2900.0
594/B,"months maxim come work favorite bicycle quite recently decide ready take part a <unknown> ' competitions know year n competitions take place i - th competition participant must quickly possible complete a ride along a straight line point si point fi ( si < fi ) measure time a complex process relate <unknown> a special sensor a time counter think front wheel a bicycle a circle radius r. let 's neglect thickness a tire size sensor physical effect sensor place rim wheel , fix point a circle radius r. counter move like choose point circle i.e move forward rotate around center circle begin participant choose point bi bike fully behind start line , bi < si - r. start movement instantly accelerate maximum speed time tsi coordinate sensor equal coordinate start time counter start <unknown> make a complete ride move maximum speed moment sensor 's coordinate equal coordinate finish ( moment time tfi ) time counter <unknown> record final time thus counter record participant make a complete ride time tfi - tsi maxim good math suspect total result n't depend maximum speed v also choice initial point bi maxim ask calculate n competitions minimum possible time measure time counter radius wheel bike equal r. first line contain three integers n r v ( 1 ≤ n ≤ 100 000 1 ≤ r v ≤ 109 ) — number competitions radius front wheel max 's bike maximum speed respectively next n line contain descriptions contest i - th line contain two integers si fi ( 1 ≤ si < fi ≤ 109 ) — coordinate start coordinate finish i - th competition print n real number i - th number equal minimum possible time measure time counter answer consider correct absolute relative error exceed 10 - 6 . namely : let 's assume answer equal a answer jury b. checker program consider answer correct",['geometry'],2500.0
696/F,barney finally find one a beautiful young lady name lyanna problem lyanna barney trap lord loss ' castle castle shape a convex polygon n point like castle <unknown> <unknown> castle <unknown> barney lyanna escape plan require geometry knowledge ask help barney know demons organize move line lyanna want wait appropriate time need watch demons want stay a point inside castle ( possibly edge corner ) also may stay position want pick a real number r watch point circle radius r around ( two circle may overlap ) say barney lyanna watch carefully every edge polygon least one see least one point line edge lie thus point may edge edge 's line formally edge line least one common point least one two circle greater r energy focus need ask tell minimum value r watch carefully first line input contain a single integer n ( 3 ≤ n ≤ 300 ) — number castle polygon vertices next n line describe polygon vertices counter - clockwise order i - th contain two integers xi yi ( |xi| |yi| ≤ 104 ) — coordinate i - th point castle guarantee give point form a convex polygon particular three line line first line print single number r — minimum radius guy ' watch circle second line print pair coordinate point barney stay third line print pair coordinate point lyanna stay point lie inside polygon coordinate may integers multiple answer print answer consider correct absolute relative error n't exceed 10 - 6 . first example guy stay opposite corner castle,['geometry'],3300.0
1800/F,dasha excellent student study best mathematical lyceum country recently a mysterious stranger bring $$$ n $$$ word consist small latin letter $$$ s_1 s_2 \ldots s_n $$$ lyceum since day dasha <unknown> nightmares consider pair integers $$$ \langle i j \rangle $$$ ( $$$ 1 \le i \le j \le n $$$ ) a nightmare a string true : example $$$ <unknown> $$$ ` ` <unknown> '' $$$ <unknown> $$$ ` ` <unknown> '' pair $$$ \langle i j \rangle $$$ create a nightmare dasha stop nightmares count number many nightmares dasha need help count number different nightmares nightmares call different correspond pair $$$ \langle i j \rangle $$$ different pair $$$ \langle i_1 j_1 \rangle $$$ $$$ \langle i_2 j_2 \rangle $$$ call different $$$ i_1 \neq i_2 $$$ $$$ j_1 \neq j_2 $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number word follow $$$ n $$$ line contain word $$$ s_1 s_2 \ldots s_n $$$ consist small latin letter guarantee total length word exceed $$$ <unknown> $$$ print a single integer — number different nightmares first test nightmares create pair $$$ \langle 1 3 \rangle $$$ $$$ \langle 2 5 \rangle $$$ $$$ \langle 3 4 \rangle $$$ $$$ \langle 6 7 \rangle $$$ $$$ \langle 9 10 \rangle $$$,['strings'],1900.0
461/E,appleman toastman like game today play a game string follow rule firstly toastman tell appleman two string s t consist letter ' a ' ' b ' ' c ' 'd ' appleman must build string s quickly possible initially empty string one second append end current string contiguous substring t. toastman appleman begin play game toastman already tell string t appleman n't come string s yet toastman think choose string s consist n character course want find worst string appleman ( string appleman spend much time possible game ) tell toastman much time appleman spend game toastman find worst string assume appleman play optimally therefore build string s minimal possible time first line contain integer n ( 1 ≤ n ≤ 1018 ) second line contain string t ( 1 ≤ |t| ≤ 105 ) string t consist letter ' a ' ' b ' ' c ' 'd ' letter appear least string t. print a single integer — largest possible time appleman need first example toastman choose s equal ` ` aaaaa '' second example toastman choose s equal ` ` <unknown> '',['strings'],3000.0
559/B,today a <unknown> string gerald learn a new definition string <unknown> two string a b equal length call equivalent one two case : a home task teacher give two string students ask determine equivalent gerald already complete home task 's turn ! first two line input contain two string give teacher length 1 200 000 consist lowercase english letter string length print ` ` yes '' ( without quote ) two string equivalent ` ` '' ( without quote ) otherwise first sample split first string string ` ` aa '' ` ` ba '' second one — string ` ` ab '' ` ` aa '' ` ` aa '' equivalent ` ` aa '' ; ` ` ab '' equivalent ` ` ba '' ` ` ab '' = ` ` a '' + ` ` b '' ` ` ba '' = ` ` b '' + ` ` a '' second sample first string <unknown> string ` ` aa '' ` ` bb '' equivalent 's string ` ` aabb '' equivalent string ` ` bbaa '',['strings'],1700.0
149/E,"study martians petya clearly understand martians absolutely lazy like sleep n't like wake imagine a martian exactly n eye locate a row number leave right 1 n. a martian sleep put a patch eye ( martian morning n't wake ) inner side patch uppercase latin letter , a martian wake open eye see a string s consist uppercase latin letter string 's length n. ` ` <unknown> <unknown> ! '' — alarm go a martian already wake n't open eye feel today go a hard day want open eye see something good martian consider m martian word beautiful besides hard open eye early morning open two non - <unknown> segment consecutive eye formally martian choose four number a b c d ( 1 ≤ a ≤ b < c ≤ d ≤ n ) open eye number i a ≤ i ≤ b c ≤ i ≤ d. martian open eye need read visible character leave right thus see word let 's consider different word martian see morning task find many beautiful word among first line contain a non - empty string s consist uppercase latin letter string ' length n ( 2 ≤ n ≤ 105 ) second line contain integer m ( 1 ≤ m ≤ 100 ) — number beautiful word next m line contain beautiful word pi consist uppercase latin letter length 1 1000 . beautiful string pairwise different print single integer — number different beautiful string martian see morning let 's consider sample test martian get second beautiful string open segment eye a = 1 b = 2 c = 4 d = 5 open segment eye a = 1 b = 2 c = 6 d = 7",['strings'],2300.0
471/D,polar bear menshykov uslada zoo st . petersburg elephant horace zoo kiev get hold lot wooden cub somewhere start make cube tower place cub one top define multiple tower stand a line a wall a wall consist tower different heights horace first finish make wall call wall elephant wall consist w tower bear also finish make wall n't give a name wall consist n tower horace look bear ' tower wonder : many part wall ` ` see elephant '' ? ` ` see elephant '' a segment w contiguous tower heights tower segment match a sequence heights tower horace 's wall order see many elephants possible horace raise lower wall even lower wall grind level ( see picture sample clarification ) task count number segment horace ` ` see elephant '' first line contain two integers n w ( 1 ≤ n w ≤ 2·105 ) — number tower bear ' elephant 's wall correspondingly second line contain n integers ai ( 1 ≤ ai ≤ 109 ) — heights tower bear ' wall third line contain w integers bi ( 1 ≤ bi ≤ 109 ) — heights tower elephant 's wall print number segment bear ' wall horace ` ` see elephant '' picture leave show horace 's wall sample picture right show bear ' wall segment horace ` ` see elephant '' gray,['strings'],1800.0
1817/F,give a string $$$ s $$$ a pair non - empty substrings $$$ ( a b ) $$$ call entangle a ( possibly empty ) link string $$$ c $$$ : word $$$ a $$$ $$$ b $$$ occur $$$ s $$$ substrings $$$ acb $$$ compute total number entangle pair substrings $$$ s $$$ a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end first line contain a string $$$ s $$$ lowercase english letter ( $$$ 1 \leq |s| \leq 100000 $$$ ) — string count pair entangle substrings output a single integer number entangle pair substrings $$$ s $$$ first example entangle pair ( ab ba ) pair correspond link string $$$ c $$$ empty occur substrings whole string abba n't character ab ba second example entangle pair third example entangle pair ( a b ) ( b c ) ( a c ) ( a bc ) ( ab c ) pair correspond link string $$$ c $$$ empty except pair ( a c ) link string $$$ c $$$ b a c occur substrings string abc,['strings'],3500.0
526/D,one day om nom find a thread n bead different color decide cut first several bead thread make a bead necklace present girlfriend om nelly om nom know girlfriend love beautiful pattern 's want bead necklace form a regular pattern a sequence bead s regular represent s = a + b + a + b + a + ... + a + b + a a b bead sequence ` ` + ` ` concatenation sequence exactly 2k + 1 summands sum among k + 1 ` ` a '' summands k ` ` b '' summands follow alternate order om nelly know friend eager mathematician n't mind a b empty sequence help om nom determine ways cut first several bead find thread ( least one ; probably ) form a regular pattern om nom cut bead n't change order first line contain two integers n k ( 1 ≤ n k ≤ 1 000 000 ) — number bead thread om nom find number k definition regular sequence second line contain sequence n lowercase latin letter represent color bead color correspond a single letter print a string consist n zero ones position i ( 1 ≤ i ≤ n ) must contain either number one first i bead thread form a regular sequence a zero otherwise first sample test a regular sequence a sequence first 6 bead ( take a = ` ` '' b = ` ` bca '' ) a sequence first 7 bead ( take a = ` ` b '' b = ` ` ca '' ) second sample test example a sequence first 13 bead regular take a = ` ` aba '' b = ` ` ba '',['strings'],2200.0
533/F,polycarp invent a new way encode string let 's assume string t consist lowercase english letter let 's choose several pair letter english alphabet a way letter occur one pair let 's replace letter t pair letter a pair letter example choose pair ( l r ) ( p q ) ( a o ) word ` ` <unknown> '' accord give encode principle transform word ` ` <unknown> '' polycarpus already two string s t. suspect string t obtain apply give encode method substring string s. find position mi s ( 1 ≤ mi ≤ |s| - |t| + 1 ) t obtain <unknown> substring <unknown> + 1 ... <unknown> + |t| - 1 apply describe encode operation use set pair english alphabet <unknown> first line input contain two integers |s| |t| ( 1 ≤ |t| ≤ |s| ≤ 2·105 ) — lengths string s string t respectively second third line input contain string s t respectively string consist lowercase english letter print number k — number suitable position string s. next line print k integers <unknown> <unknown> ... <unknown> — number suitable position increase order,['strings'],2400.0
594/E,give a non - empty line s integer k. follow operation perform line exactly : task determine lexicographically smallest string could result apply give operation string s. first line input contain string s ( 1 ≤ |s| ≤ 5 000 000 ) consist lowercase english letter second line contain integer k ( 1 ≤ k ≤ |s| ) — maximum number part partition single line print lexicographically minimum string s ' obtain a result perform describe operation,['strings'],3100.0
616/F,give n string ti string cost ci let 's define function string ps i number occurrences s ti |s| length string s. find maximal value function f ( s ) string note string s necessarily string t. first line contain integer n ( 1 ≤ n ≤ 105 ) — number string t. next n line contain contain a non - empty string ti ti contain lowercase english letter guarantee sum lengths string t greater 5·105 last line contain n integers ci ( - 107 ≤ ci ≤ 107 ) — cost i - th string print integer a — maximal value function f ( s ) string s. note one time string s necessarily t,['strings'],2700.0
700/E,bomboslav set a brand agency help company create new <unknown> advertise slogans term problems slogan company a non - empty substring name example company name ` ` <unknown> '' substrings ` ` <unknown> '' ` ` <unknown> '' could slogans string ` ` e '' ` ` <unknown> '' sometimes company perform rebranding change slogan slogan a consider cooler slogan b b appear a a substring least twice ( occurrences allow overlap ) example slogan a = ` ` abacaba '' cooler slogan b = ` ` ba '' slogan a = ` ` <unknown> '' cooler slogan b = ` ` bcb '' slogan a = ` ` aaaaaa '' cooler slogan b = ` ` aba '' give company name w task help bomboslav determine length longest sequence slogans s1 s2 ... sk slogan sequence cooler previous one first line input contain a single integer n ( 1 ≤ n ≤ 200 000 ) — length company name ask bomboslav help second line contain string w length n consist lowercase english letter print a single integer — maximum possible length sequence slogans company name w slogan sequence ( except first one ) cooler previous,['strings'],3300.0
963/D,give a string $$$ s $$$ answer $$$ n $$$ query $$$ i $$$ -th query consist integer $$$ k_i $$$ string $$$ m_i $$$ answer query minimum length a string $$$ t $$$ $$$ t $$$ a substring $$$ s $$$ $$$ m_i $$$ least $$$ k_i $$$ occurrences a substring $$$ t $$$ a substring a string a continuous segment character string guarantee two query string $$$ m_i $$$ query different first line contain string $$$ s $$$ $$$ ( 1 \leq \left | s \right | \leq 10^ { 5 } ) $$$ second line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) next $$$ n $$$ line contain integer $$$ k_i $$$ $$$ ( 1 \leq k_i \leq |s| ) $$$ a non - empty string $$$ m_i $$$ — parameters query number $$$ i $$$ order string input consist lowercase english letter sum length string input n't exceed $$$ 100000 $$$ $$$ m_i $$$ distinct query output answer a separate line a string $$$ m _ { i } $$$ occur $$$ s $$$ less $$$ k _ { i } $$$ time output -1,['strings'],2500.0
1098/F,"length longest common prefix two string $$$ s = s_1 s_2 \ldots s_n $$$ $$$ t = t_1 t_2 \ldots t_m $$$ define maximum $$$ k \le \min ( n m ) $$$ $$$ s_1 s_2 \ldots s_k $$$ equal $$$ t_1 t_2 \ldots t_k $$$ let 's denote longest common prefix two string $$$ s $$$ $$$ t $$$ $$$ lcp ( s t ) $$$ z - function a string $$$ s_1 s_2 \dots s_n $$$ a sequence integers $$$ z_1 z_2 \ldots z_n $$$ $$$ <unknown> = lcp ( s_1 s_2 \ldots s_n \ \ s_i s _ { i+1 } \dots s_n ) $$$ ж - function a string $$$ s $$$ define $$$ z_1 + z_2 + \ldots + z_n $$$ 're give a string $$$ s = s_1 s_2 \ldots s_n $$$ $$$ q $$$ query query describe two integers $$$ l_i $$$ $$$ r_i $$$ $$$ 1 \le l_i \le r_i \le n $$$ answer query define ж - function string $$$ s _ { l_i } s _ { l_i +1 } \ldots s _ { r_i } $$$ first line contain string $$$ s $$$ consist lowercase english letter ( $$$ 1 \leq |s| \leq 200\,000 $$$ ) second line contain one integer $$$ q $$$ — number query ( $$$ 1 \leq q \leq 200\,000 $$$ ) follow $$$ q $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ describe query ( $$$ 1 \leq l_i \leq r_i \leq |s| $$$ ) every query output one integer : value ж - function correspond substring first sample case four query :",['strings'],3500.0
1326/D1,easy version problem difference constraint sum lengths string number test case make hack solve versions task give a string $$$ s $$$ consist lowercase english letter find longest string $$$ t $$$ satisfy follow condition : input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) number test case next $$$ t $$$ line describe a test case test case a non - empty string $$$ s $$$ consist lowercase english letter guarantee sum lengths string test case exceed $$$ 5000 $$$ test case print longest string satisfy condition describe exist multiple possible solutions print first test string $$$ s = $$$ ` ` a '' satisfy condition second test string ` ` <unknown> '' satisfy condition : prove exist a longer string satisfy condition fourth test string ` ` c '' correct ` ` c '' $$$ = $$$ ` ` c '' $$$ + $$$ ` ` '' $$$ a $$$ $$$ b $$$ empty possible solution test ` ` s '',['strings'],1500.0
873/F,"give a string s consist n lowercase latin letter indices string mark forbid want find a string a value |a|·f ( a ) maximum possible f ( a ) number occurences a s occurences end non - <unknown> indices , example s aaaa a aa index 3 forbid f ( a ) = 2 three occurences a s ( start indices 1 2 3 ) one ( start index 2 ) end a forbid index calculate maximum possible value |a|·f ( a ) get first line contain integer number n ( 1 ≤ n ≤ 200000 ) — length s. second line contain a string s consist n lowercase latin letter third line contain a string t consist n character 0 1 . i - th character t 1 i a forbid index ( otherwise i forbid ) print maximum possible value |a|·f ( a )",['strings'],2400.0
17/E,english class nick nothing remember wonderful string call palindromes remind a string call a palindrome read way leave right right leave examples string : « eye » « pop » « level » « aba » « <unknown> » « racecar » « <unknown> » « <unknown> » nick start look carefully palindromes text read class occurrence palindrome text write a pair — position begin position end occurrence text nick call occurrence palindrome find text subpalindrome find subpalindromes decide find many different pair among subpalindromes cross two subpalindromes cross cover common position text palindrome cross let 's look action perform nick example text « <unknown> » first write subpalindromes : nick count amount different pair among subpalindromes cross pair six : since 's exhaust perform describe action manually nick ask help write a program find amount different subpalindrome pair cross two subpalindrome pair regard different one pair contain a subpalindrome first input line contain integer n ( 1 ≤ n ≤ <unknown> ) — length text follow line contain n lower - case latin letter ( a z ) line output amount different pair two subpalindromes cross output answer modulo <unknown>,['strings'],2900.0
1055/F,"give a connect undirected graph without cycle ( a tree ) $$$ n $$$ vertices moreover a non - negative integer write every edge consider pair vertices $$$ ( v u ) $$$ ( exactly $$$ n^2 $$$ pair ) pair calculate bitwise exclusive ( xor ) integers edge simple path $$$ v $$$ $$$ u $$$ path consist one vertex xor integers edge path equal $$$ 0 $$$ suppose sort result $$$ n^2 $$$ value non - decreasing order need find $$$ k $$$ -th definition xor follow give two integers $$$ x $$$ $$$ y $$$ consider binary representations ( possibly lead zero ) : $$$ x_k \dots x_2 x_1 x_0 $$$ $$$ <unknown> \dots y_2 y_1 y_0 $$$ ( $$$ k $$$ number bits $$$ x $$$ $$$ y $$$ represent ) , $$$ x_i $$$ $$$ i $$$ -th bite number $$$ x $$$ $$$ y_i $$$ $$$ i $$$ -th bite number $$$ y $$$ let $$$ r = x \oplus y $$$ result xor operation $$$ x $$$ $$$ y $$$ $$$ r $$$ define $$$ <unknown> \dots r_2 r_1 <unknown> $$$ : $$$ $$$ r_i = <unknown> { \begin { align } 1 ~ \text { } ~ x_i \ne y_i \\ 0 ~ \text { } ~ x_i = y_i \end { align } \right $$$ $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 1000000 $$$ $$$ 1 \le k \le n^2 $$$ ) — number vertices tree number path list non - decreasing order follow $$$ n - 1 $$$ line contain two integers $$$ p_i $$$ $$$ w_i $$$ ( $$$ 1 \le p_i \le i $$$ $$$ 0 \le w_i < 2^ { 62 } $$$ ) — ancestor vertex $$$ i + 1 $$$ weight correspond edge print one integer : $$$ k $$$ -th smallest xor a path tree tree second sample test look like : a tree total $$$ 9 $$$ paths exist :",['strings'],2900.0
208/A,vasya work a dj best berland <unknown> often use dubstep music performance recently decide take a couple old songs make dubstep <unknown> let 's assume a song consist number word make dubstep remix song vasya insert a certain number word ` ` wub '' first word song ( number may zero ) last word ( number may zero ) word ( least one pair neighbour word ) boy glue together word include ` ` wub '' one string play song club example a song word ` ` i x '' transform a dubstep remix ` ` <unknown> '' transform ` ` <unknown> '' recently petya hear vasya 's new dubstep track since n't modern music decide find initial song vasya remixed help petya restore original song input consist a single non - empty string consist uppercase english letter string 's length n't exceed 200 character guarantee vasya remixed song word contain substring ` ` wub '' ; vasya n't change word order also guarantee initially song least one word print word initial song vasya use make a <unknown> remix separate word a space first sample : ` ` <unknown> '' = ` ` wub '' + ` ` wub '' + ` ` abc '' + ` ` wub '' mean song <unknown> consist a single word ` ` abc '' word ` ` wub '' add vasya second sample vasya add a single word ` ` wub '' neighbour word begin end except word ` ` '' ` ` '' — vasya add two ` ` wub '',['strings'],900.0
1431/I,"give a matrix consist $$$ n $$$ row $$$ m $$$ columns matrix contain lowercase letter latin alphabet perform follow operation number time want : choose two integers $$$ i $$$ ( $$$ 1 \le i \le m $$$ ) $$$ k $$$ ( $$$ 0 < k < n $$$ ) shift every column $$$ j $$$ $$$ i \le j \le m $$$ cyclically $$$ k $$$ shift perform upwards example a matrix process $$$ q $$$ query query a string length $$$ m $$$ consist lowercase letter latin alphabet query calculate minimum number operations describe perform least one row matrix equal string query note query independent , operations perform a query n't affect initial matrix query first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 2 \le n m q \le 2.5 \cdot 100000 $$$ ; $$$ n \cdot m \le 500000 $$$ ; $$$ q \cdot m \le 500000 $$$ ) — number row columns matrix number query respectively next $$$ n $$$ line contain $$$ m $$$ lowercase latin letter — elements matrix follow $$$ q $$$ line contain a description query — string length $$$ m $$$ consist lowercase letter latin alphabet print $$$ q $$$ integers $$$ i $$$ -th integer equal minimum number operations perform matrix contain a string $$$ i $$$ -th query $$$ -1 $$$ specify string obtain",['strings'],2900.0
1606/A,give a string $$$ s $$$ length $$$ n $$$ consist character a and/or b. let $$$ \operatorname { ab } ( s ) $$$ number occurrences string ab $$$ s $$$ a substring <unknown> $$$ \operatorname { ba } ( s ) $$$ number occurrences ba $$$ s $$$ a substring one step choose index $$$ i $$$ replace $$$ s_i $$$ character a b. minimum number step need make achieve $$$ \operatorname { ab } ( s ) = \operatorname { ba } ( s ) $$$ ? <unknown> : number occurrences string $$$ d $$$ $$$ s $$$ substring number indices $$$ i $$$ ( $$$ 1 \le i \le |s| - |d| + 1 $$$ ) substring $$$ s_i s _ { i + 1 } \dots s _ { i + |d| - 1 } $$$ equal $$$ d $$$ example $$$ \operatorname { ab } ( $$$ aabbbabaa $$$ ) = 2 $$$ since two indices $$$ i $$$ : $$$ i = 2 $$$ aabbbabaa $$$ i = 6 $$$ aabbbabaa test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) description test case follow first line test case contain a single string $$$ s $$$ ( $$$ 1 \le |s| \le 100 $$$ $$$ |s| $$$ length string $$$ s $$$ ) consist character a and/or b. test case print result string $$$ s $$$ $$$ \operatorname { ab } ( s ) = \operatorname { ba } ( s ) $$$ 'll get make minimum number step multiple answer print first test case $$$ \operatorname { ab } ( s ) = 0 $$$ $$$ \operatorname { ba } ( s ) = 0 $$$ ( occurrences ab ( ba ) b ) leave $$$ s $$$ untouched second test case $$$ \operatorname { ab } ( s ) = 2 $$$ $$$ \operatorname { ba } ( s ) = 2 $$$ leave $$$ s $$$ untouched third test case $$$ \operatorname { ab } ( s ) = 1 $$$ $$$ \operatorname { ba } ( s ) = 0 $$$ example change $$$ s_1 $$$ b make value zero fourth test case $$$ \operatorname { ab } ( s ) = 2 $$$ $$$ \operatorname { ba } ( s ) = 1 $$$ example change $$$ <unknown> $$$ a make value equal $$$ 1 $$$,['strings'],900.0
1654/B,"give a string $$$ s $$$ consist lowercase letter english alphabet must perform follow algorithm $$$ s $$$ : a prefix a string consist several first letter a give string without reorder empty prefix also a valid prefix example string ` ` abcd '' 5 prefix : empty string ` ` a '' ` ` ab '' ` ` abc '' ` ` abcd '' instance perform algorithm $$$ s = $$$ ` ` <unknown> '' find final state string perform algorithm first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow $$$ t $$$ line contain a description one test case line contain a string $$$ s $$$ give string consist lowercase letter english alphabet lengths $$$ 1 $$$ $$$ 200000 $$$ inclusive guarantee sum lengths $$$ s $$$ test case exceed $$$ 200000 $$$ test case print a single line contain string $$$ s $$$ execute algorithm show string non - empty first test case explain statement second test case operations perform $$$ s $$$ third test case fourth test case ,",['strings'],800.0
1794/A,"marcos love string a lot a favorite string $$$ s $$$ consist lowercase english letter string write non - empty prefix suffix ( except $$$ s $$$ ) a piece paper arbitrary order see string wonder marcos ' favorite string a palindrome , task decide whether $$$ s $$$ a palindrome look piece paper a string $$$ a $$$ a prefix a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character end a string $$$ a $$$ a suffix a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin a palindrome a string read backward forward example string ` ` gg '' ` ` ioi '' ` ` abba '' ` ` <unknown> '' palindromes string ` ` codeforces '' ` ` abcd '' ` ` alt '' test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 120 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2\le n \le 20 $$$ ) — length string $$$ s $$$ second line test case contain $$$ 2n-2 $$$ string $$$ a_1 a_2 \cdots a _ { 2n-2 } $$$ — non - empty prefix suffix $$$ s $$$ include arbitrary order guarantee string non - empty prefix suffix string consist lowercase english letter test case output ` ` yes '' $$$ s $$$ a palindrome ` ` '' otherwise output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses first test case $$$ s $$$ ` ` abcd '' prefix ` ` a '' ` ` ab '' ` ` abc '' suffix ` ` d '' ` ` cd '' ` ` <unknown> '' string ` ` abcd '' a palindrome answer second test case $$$ s $$$ ` ` ioi '' prefix ` ` i '' ` ` io '' suffix ` ` i '' ` ` oi '' string ` ` ioi '' a palindrome answer yes third test case $$$ s $$$ ` ` gg '' a palindrome fourth test case $$$ s $$$ ` ` alt '' a palindrome",['strings'],800.0
1832/A,"a palindrome a string read leave right right leave example abacaba aaaa abba racecar palindromes give a string $$$ s $$$ consist lowercase latin letter string $$$ s $$$ a palindrome check whether possible rearrange letter get another palindrome ( equal give string $$$ s $$$ ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case line test case contain a string $$$ s $$$ ( $$$ 2 \le |s| \le 50 $$$ ) consist lowercase latin letter string a palindrome test case print yes possible rearrange letter give string get another palindrome otherwise print may print letter case ( yes yes yes recognize positive answer , recognize negative answer ) first test case possible rearrange letter palindrome <unknown> obtain string <unknown> different give string also a palindrome",['strings'],800.0
1394/E,"matter trouble 're n't afraid face a smile i ' ve make another <unknown> dollars ! — <unknown> issue currencies name bobo yuan bobo yuan ( bby ) a series currencies boboniu give a positive integer identifier <unknown> <unknown> etc boboniu a bby collection collection look like a sequence example : use sequence $$$ a= [ 1,2,3,3,2,1,4,4,1 ] $$$ length $$$ <unknown> $$$ denote boboniu want fold collection imagine boboniu stick collection a long piece paper fold currencies : boboniu fold identifier currencies together word $$$ a_i $$$ fold $$$ a_j $$$ ( $$$ 1\le i j\le n $$$ ) $$$ a_i = a_j $$$ must hold boboniu n't care follow rule process fold finish rule obey a formal definition fold describe note accord picture fold $$$ a $$$ two time fact fold $$$ a= [ 1,2,3,3,2,1,4,4,1 ] $$$ two time maximum number fold $$$ 2 $$$ international fan boboniu 're ask calculate maximum number fold 're give a sequence $$$ a $$$ length $$$ n $$$ $$$ i $$$ ( $$$ 1\le i\le n $$$ ) need calculate maximum number fold $$$ [ a_1 a_2 \ldots a_i ] $$$ first line contain integer $$$ n $$$ ( $$$ 1\le n\le 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1\le a_i\le n $$$ ) print $$$ n $$$ integers $$$ i $$$ -th equal maximum number fold $$$ [ a_1 a_2 \ldots a_i ] $$$ formally a sequence $$$ a $$$ length $$$ n $$$ let 's define fold sequence a sequence $$$ b $$$ length $$$ n $$$ : ( $$$ [ a ] $$$ value boolean expression $$$ a $$$ i. e. $$$ [ a ] = 1 $$$ $$$ a $$$ true else $$$ [ a ] = 0 $$$ ) define number fold $$$ b $$$ $$$ f ( b ) = \sum _ { i=1 } ^ { n-1 } [ <unknown> b _ { i+1 } ] $$$ maximum number fold $$$ a $$$ $$$ f ( a ) = <unknown> { f ( b ) \mid b \text { a fold sequence } a \ } $$$",['strings'],3500.0
608/B,genos need help ask solve follow program problem <unknown> : length string s denote |s| ham distance two string s t equal length define si i - th character s ti i - th character t. example ham distance string ` ` <unknown> '' string ` ` <unknown> '' |0 - 0| + |0 - 1| + |1 - 1| + |1 - 0| = 0 + 1 + 0 + 1 = 2 . give two binary string a b find sum ham distance a contiguous substrings b length |a| first line input contain binary string a ( 1 ≤ |a| ≤ 200 000 ) second line input contain binary string b ( |a| ≤ |b| ≤ 200 000 ) string guarantee consist character ' 0 ' ' 1 ' print a single integer — sum ham distance a contiguous substrings b length |a| first sample case four contiguous substrings b length |a| : ` ` 00 '' ` ` 01 '' ` ` 11 '' ` ` 11 '' distance ` ` 01 '' ` ` 00 '' |0 - 0| + |1 - 0| = 1 . distance ` ` 01 '' ` ` 01 '' |0 - 0| + |1 - 1| = 0 . distance ` ` 01 '' ` ` 11 '' |0 - 1| + |1 - 1| = 1 . last distance count twice two occurrences string ` ` 11 '' sum edit distance 1 + 0 + 1 + 1 = 3 . second sample case describe statement,['strings'],1500.0
1065/E,consider set distinct character $$$ a $$$ string $$$ s $$$ consist exactly $$$ n $$$ character character present $$$ a $$$ give array $$$ m $$$ integers $$$ b $$$ ( $$$ b_1 < b_2 < \dots < b_m $$$ ) allow perform follow move string $$$ s $$$ : example let 's take a look $$$ s = $$$ ` ` abcdefghi '' $$$ k = 2 $$$ $$$ pr_2 = $$$ ` ` ab '' $$$ su_2 = $$$ ` ` hi '' reverse $$$ pr_2 = $$$ ` ` ba '' $$$ su_2 = $$$ ` ` <unknown> '' thus result $$$ s $$$ ` ` ihcdefgba '' move perform arbitrary number time ( possibly zero ) $$$ i $$$ select multiple time move let 's call string $$$ s $$$ $$$ t $$$ equal exist a sequence move <unknown> string $$$ s $$$ string $$$ t $$$ example string ` ` abcdefghi '' ` ` ihcdefgba '' equal also note imply $$$ s = s $$$ task simple count number distinct string answer huge enough calculate modulo $$$ 998244353 $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ |a| $$$ ( $$$ 2 \le n \le 1000000000 $$$ $$$ 1 \le m \le min ( \frac n 2 2 \cdot 100000 ) $$$ $$$ 1 \le |a| \le 1000000000 $$$ ) — length string size array $$$ b $$$ size set $$$ a $$$ respectively second line contain $$$ m $$$ integers $$$ b_1 b_2 \dots b_m $$$ ( $$$ 1 \le b_i \le \frac n 2 $$$ $$$ b_1 < b_2 < \dots < b_m $$$ ) print a single integer — number distinct string length $$$ n $$$ character set $$$ a $$$ modulo $$$ 998244353 $$$ distinct string first example choose letter ' a ' ' b ' show character $$$ a $$$ different,['strings'],2300.0
1205/E,give integers $$$ n $$$ $$$ k $$$ let 's consider alphabet consist $$$ k $$$ different elements let beauty $$$ f ( s ) $$$ string $$$ s $$$ number index $$$ i $$$ $$$ 1\le i < |s| $$$ prefix $$$ s $$$ length $$$ i $$$ equal suffix $$$ s $$$ length $$$ i $$$ example beauty string $$$ abacaba $$$ equal $$$ 2 $$$ $$$ i = 1 3 $$$ prefix suffix length $$$ i $$$ equal consider word length $$$ n $$$ give alphabet find expect value $$$ f ( s ) <unknown> $$$ a uniformly choose random word show express $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ coprime $$$ q $$$ n't divide $$$ 1000000000 + 7 $$$ output $$$ p\cdot q^ { -1 } \bmod 1000000000 + 7 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1\le n \le 100000 $$$ $$$ 1\le k\le 1000000000 $$$ ) — length a string size alphabet respectively output a single integer — $$$ <unknown> q^ { -1 } \bmod 1000000000 + 7 $$$ first example $$$ 9 $$$ word length $$$ 2 $$$ alphabet size $$$ 3 $$$ — $$$ aa $$$ $$$ ab $$$ $$$ ac $$$ $$$ ba $$$ $$$ bb $$$ $$$ bc $$$ $$$ ca $$$ $$$ cb $$$ $$$ <unknown> $$$ $$$ 3 $$$ beauty $$$ 1 $$$ $$$ 6 $$$ beauty $$$ 0 $$$ average value $$$ \frac { 1 } { 3 } $$$ third example one word beauty $$$ 99 $$$ average value $$$ 99 ^ 2 $$$,['strings'],3100.0
666/C,famous sculptor <unknown> a reberlandian spy ! break news berlandian paper today sculptor hide time give <unknown> <unknown> a protect bunker provide friend set security system way open bunker open one solve problem hard others simple every day bunker generate a <unknown> s. every time someone want enter bunker integer n appear screen answer one enter another integer — residue modulo 109 + 7 number string length n consist lowercase english letter contain string s subsequence subsequence string a a string b derive string a remove symbols ( maybe none ) particular string subsequence example string ` ` <unknown> '' subsequence string ` ` codeforces '' n't implement algorithm calculate correct answer yet <unknown> first line contain integer m ( 1 ≤ m ≤ 105 ) — number events test case second line contain nonempty string s — string generate bunker current day next m line contain description events description start integer t — type event t = 1 consider a new day come a new string s use case line contain a new value string s. t = 2 integer n give ( 1 ≤ n ≤ 105 ) event mean 's need find answer current string s value n. sum lengths generate string n't exceed 105 . give string consist lowercase english letter query type 2 print answer modulo 109 + 7 separate line first event word form ` ` a ? '' ` ` ? a '' count ? arbitrary symbol 26 word type word ` ` aa '' satisfy pattern answer 51,['strings'],2500.0
1243/B2,problem different easy version version ujan make $$$ 2n $$$ swap addition $$$ k \le 1000 n \le 50 $$$ necessary print swap hack problem solve hack previous problem solve problems struggle fail many time ujan decide try clean house decide get string order first ujan two distinct string $$$ s $$$ $$$ t $$$ length $$$ n $$$ consist lowercase english character want make equal since ujan lazy perform follow operation $$$ 2n $$$ time : take two position $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i j \le n $$$ value $$$ i $$$ $$$ j $$$ equal different ) swap character $$$ s_i $$$ $$$ t_j $$$ ujan 's goal make string $$$ s $$$ $$$ t $$$ equal need minimize number perform operations : sequence operations length $$$ 2n $$$ shorter suitable first line contain a single integer $$$ k $$$ ( $$$ 1 \leq k \leq 1000 $$$ ) number test case test case first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 50 $$$ ) length string $$$ s $$$ $$$ t $$$ next two line contain string $$$ s $$$ $$$ t $$$ length exactly $$$ n $$$ string consist lowercase english letter guarantee string different test case output ` ` yes '' ujan make two string equal $$$ 2n $$$ operations ` ` '' otherwise print letter case ( upper lower ) case ` ` yes '' print $$$ m $$$ ( $$$ 1 \le m \le 2n $$$ ) next line $$$ m $$$ number swap operations make string equal print $$$ m $$$ line line contain two integers $$$ i j $$$ ( $$$ 1 \le i j \le n $$$ ) mean ujan swap $$$ s_i $$$ $$$ t_j $$$ correspond operation need minimize number operations sequence length $$$ 2n $$$ suitable,['strings'],1600.0
1223/B,give two string equal length $$$ s $$$ $$$ t $$$ consist lowercase latin letter may perform number ( possibly zero ) operations string operation choose two adjacent character string assign value first character value second vice versa example $$$ s $$$ ` ` <unknown> '' get follow string one operation : note also apply operation string $$$ t $$$ please determine whether possible transform $$$ s $$$ $$$ t $$$ apply operation number time note answer $$$ q $$$ independent query first line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100 $$$ ) — number query query represent two consecutive line first line query contain string $$$ s $$$ ( $$$ 1 \le |s| \le 100 $$$ ) consist lowercase latin letter second line query contain string $$$ t $$$ ( $$$ 1 \le |t| \leq 100 $$$ $$$ |t| = |s| $$$ ) consist lowercase latin letter query print ` ` yes '' possible make $$$ s $$$ equal $$$ t $$$ ` ` '' otherwise may print every letter case want ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive answer ) first query perform two operations $$$ s_1 = s_2 $$$ ( $$$ s $$$ turn ` ` aabb '' ) $$$ t_4 = t_3 $$$ ( $$$ t $$$ turn ` ` aabb '' ) second query string equal initially answer ` ` yes '' third query make string $$$ s $$$ $$$ t $$$ equal therefore answer ` ` '',['strings'],1000.0
50/B,a give string s consist n symbols task find number order pair integers i j <unknown> 1 ≤ i j ≤ n2 s [ i ] = s [ j ] i - th symbol string s equal j - th single input line contain s consist lowercase latin letter digits guarantee string s empty length exceed 105 . print a single number represent number pair i j need property pair ( x y ) ( y x ) consider different i.e order pair count,['strings'],1500.0
61/B,contest compare number shapur 's teacher find a real genius one could possibly calculations faster even use a super computer ! days contest teacher take a simple - looking exam n students take part exam teacher give 3 string ask concatenate concatenate string mean put arbitrary order one example concatenate <unknown> <unknown> get <unknown> <unknown> depend order concatenation unfortunately enough teacher forget ask students concatenate string a pre - <unknown> order student way he / she like teacher know shapur a fast - <unknown> genius boy ask correct students ' paper shapur good a time - <unknown> task rather like finish soon possible take time solve 3 - <unknown> polynomial time moreover teacher give <unknown> shapur follow 's teacher say : first three line contain a string initial string consist lowercase uppercase latin letter sign ( ` ` - '' ` ` ; '' ` ` _ '' ) initial string length 1 100 inclusively fourth line a single integer n ( 0 ≤ n ≤ 1000 ) number students next n line contain a student 's answer guarantee answer meet teacher say answer <unknown> lowercase uppercase latin letter sign ( ` ` - '' ` ` ; '' ` ` _ '' ) length 1 600 inclusively student write a different line print ` ` <unknown> '' answer wrong ` ` <unknown> '' answer ok,['strings'],1300.0
71/A,sometimes word like ` ` localization '' ` ` internationalization '' long write many time one text quite tiresome let 's consider a word long length strictly 10 character long word replace a special abbreviation abbreviation make like : write first last letter a word write number letter first last letter number decimal system n't contain lead zero thus ` ` localization '' spell ` ` <unknown> '' ` ` internationalization » spell ` ` <unknown> '' suggest <unknown> process change word <unknown> long word replace abbreviation word long <unknown> change first line contain integer n ( 1 ≤ n ≤ 100 ) follow n line contain one word word consist lowercase latin letter possess lengths 1 100 character print n line i - th line contain result replace i - th word input data,['strings'],800.0
99/A,a far away kingdom live king <unknown> <unknown> <unknown> many citizens live <unknown> great trouble come kingdom acmers settle damage strange creatures <unknown> upon kingdom love high precision number a result kingdom <unknown> already three <unknown> merchants ask sell say exactly <unknown> <unknown> barrel deal problem somehow king issue order <unknown> round number closest integer simplify calculations specifically order go like : merchants find algorithm <unknown> ask ( acmers ) help write a program would perform round accord king ’ s order ? first line contain a single number round — integer part ( a non - empty set decimal digits start 0 — exception a case set consist a single digit — case 0 go first ) follow character « . » ( a dot ) follow fractional part ( non - empty set decimal digits ) number 's length exceed 1000 character include dot character input data last number integer part equal 9 print <unknown> - up number without lead zero otherwise print message ` ` <unknown> <unknown> . '' ( without quote ),['strings'],800.0
100/D,a lot rumor media days one day aida decide find rumor make ask n friends help form a circle aida tell person right a piece news a simple string person tell string person his / her right n't tell string exactly 'd hear person make one two type change : finally rumor pass exactly n move ( a complete cycle ) aida hear something quite different expect person leave think someone cheat make change explain want write a <unknown> piece code get initial final string tell aida whether 's possible get final string initial one rule describe first line contain a single integer n ( 2 ≤ n ≤ 8 × 106 ) number aida 's friends follow two line contain a non - empty string — initial final string lengths string 107 contain english alphabet letter write a single yes write yes 's possible get final string initial string input case - sensitive output,['strings'],1500.0
121/B,petya love lucky number everybody know lucky number positive integers whose decimal representation contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 petya a number consist n digits without lead zero represent array digits without lead zero let 's call d. numeration start 1 start significant digit petya want perform follow operation k time : find minimum x ( 1 ≤ x < n ) dx = 4 dx + 1 = 7 x odd assign dx = dx + 1 = 4 otherwise assign dx = dx + 1 = 7 . note x find operation count complete array n't change give initial number array digits number k. help petya find result complete k operations first line contain two integers n k ( 1 ≤ n ≤ 105 0 ≤ k ≤ 109 ) — number digits number number complete operations second line contain n digits without space represent array digits d start d1 guarantee first digit number equal zero single line print result without space — number k operations fulfil first sample number change follow sequence : <unknown> → 4427447 → 4427477 → 4427447 → 4427477 . second sample : 4478 → <unknown> → 4478,['strings'],1500.0
1243/B1,problem different hard version version ujan make exactly one exchange hack problem solve problems struggle fail many time ujan decide try clean house decide get string order first ujan two distinct string $$$ s $$$ $$$ t $$$ length $$$ n $$$ consist lowercase english character want make equal since ujan lazy perform follow operation exactly : take two position $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i j \le n $$$ value $$$ i $$$ $$$ j $$$ equal different ) swap character $$$ s_i $$$ $$$ t_j $$$ succeed ? note perform operation exactly perform operation first line contain a single integer $$$ k $$$ ( $$$ 1 \leq k \leq 10 $$$ ) number test case test case first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 10000 $$$ ) length string $$$ s $$$ $$$ t $$$ next two line contain string $$$ s $$$ $$$ t $$$ length exactly $$$ n $$$ string consist lowercase english letter guarantee string different test case output ` ` yes '' ujan make two string equal ` ` '' otherwise print letter case ( upper lower ) first test case ujan swap character $$$ s_1 $$$ $$$ t_4 $$$ obtain word ` ` house '' second test case possible make string equal use exactly one swap $$$ s_i $$$ $$$ t_j $$$,['strings'],1000.0
1189/A,play <unknown> legendary ` ` matrix '' <unknown> keanu <unknown> start doubt : maybe really live virtual reality ? find true need solve follow problem let 's call a string consist zero ones good contain different number zero ones example 1 101 0000 good 01 1001 <unknown> good give a string $$$ s $$$ length $$$ n $$$ consist zero ones need cut $$$ s $$$ minimal possible number substrings $$$ s_1 s_2 \ldots s_k $$$ good formally find minimal number string sequence good string $$$ s_1 s_2 \ldots s_k $$$ concatenation ( join ) equal $$$ s $$$ i.e $$$ s_1 + s_2 + \dots + s_k = s $$$ example <unknown> 110010 110 010 11 0010 valid 110 010 11 0010 good ca n't cut 110010 smaller number substrings 110010 n't good time cut 110010 <unknown> 10 n't valid string n't good also cut 110010 1 1 0010 n't valid n't minimal even though $$$ 3 $$$ string good help keanu ? show solution always exist multiple optimal answer print first line input contain a single integer $$$ n $$$ ( $$$ 1\le n \le 100 $$$ ) — length string $$$ s $$$ second line contain string $$$ s $$$ length $$$ n $$$ consist zero ones first line output a single integer $$$ k $$$ ( $$$ 1\le k $$$ ) — a minimal number string cut $$$ s $$$ second line output $$$ k $$$ string $$$ s_1 s_2 \ldots s_k $$$ separate space length string positive concatenation equal $$$ s $$$ good multiple answer print first example string 1 n't cut good condition satisfy second example 1 0 good 10 n't good answer indeed minimal third example 100 011 good <unknown> n't good answer indeed minimal,['strings'],800.0
1216/A,nikolay get a string $$$ s $$$ even length $$$ n $$$ consist lowercase latin letter ' a ' ' b ' position number $$$ 1 $$$ $$$ n $$$ want modify string every prefix even length equal amount letter ' a ' ' b ' achieve nikolay perform follow operation arbitrary number time ( possibly zero ) : choose position string replace letter position letter ( i.e replace ' a ' ' b ' replace ' b ' ' a ' ) nikolay use letter except ' a ' ' b ' prefix string $$$ s $$$ length $$$ l $$$ ( $$$ 1 \le l \le n $$$ ) a string $$$ s [ 1 .. l ] $$$ example string $$$ s= $$$ ` ` abba '' two prefix even length first $$$ s [ <unknown> ] = $$$ ` ` ab '' second $$$ s [ <unknown> ] = $$$ ` ` abba '' number ' a ' ' b ' task calculate minimum number operations nikolay perform string $$$ s $$$ modify every prefix even length equal amount letter ' a ' ' b ' first line input contain one even integer $$$ n $$$ $$$ ( 2 \le n \le 2\cdot10^ { 5 } ) $$$ — length string $$$ s $$$ second line input contain string $$$ s $$$ length $$$ n $$$ consist lowercase latin letter ' a ' ' b ' first line print minimum number operations nikolay perform string $$$ s $$$ modify every prefix even length equal amount letter ' a ' ' b ' second line print string nikolay obtain apply operations multiple answer print first example nikolay perform two operations example replace first ' b ' ' a ' last ' b ' ' a ' second example nikolay n't need anything prefix even length initial string already contain equal amount letter ' a ' ' b ',['strings'],800.0
345/G,give a group n string : s1 s2 ... sn find a subgroup <unknown> <unknown> ... <unknown> ( 1 ≤ i1 < i2 < ... < ik ≤ n ) group follow two condition must hold : task print number string find subgroup first line contain integer n ( 1 ≤ n ≤ 105 ) — number string group next n line contain a string i - th line contain non - empty string si string consist lowercase latin letter sum string si n't exceed 105 . output a single integer — number string find subgroup look test sample require subgroup s1 s2 s3,['strings'],2200.0
1090/J,misha n't math homework today 's lesson a punishment teacher dr . andrew decide give a hard useless task dr . andrew write two string s t lowercase english letter blackboard remind misha prefix a string a string form remove several ( possibly none ) last character a concatenation two string a string form append second string right first string teacher ask misha write blackboard string concatenations non - empty prefix s non - empty prefix t. misha dr . andrew ask many distinct string misha spend almost entire lesson complete task ask write a program would task automatically first line contain string s consist lowercase english letter second line contain string t consist lowercase english letter lengths string exceed 105 . output a single integer — number distinct string concatenations non - empty prefix s non - empty prefix t. first example string s three non - empty prefix : { a ab aba } string t two non - empty prefix : { a aa } total misha write five distinct string : { aa aaa aba abaa <unknown> } string abaa write twice second example misha write eight distinct string : { aa aaa aaaa aaaaa aaaaaa <unknown> <unknown> <unknown> },['strings'],2600.0
1080/E,sonya a birthday recently present matrix size $$$ n\times m $$$ consist lowercase latin letter assume row number integers $$$ 1 $$$ $$$ n $$$ bottom top columns number $$$ 1 $$$ $$$ m $$$ leave right let 's call a submatrix $$$ ( i_1 j_1 i_2 j_2 ) $$$ $$$ ( 1\leq i_1\leq <unknown> n ; 1\leq j_1\leq <unknown> m ) $$$ elements $$$ a _ { ij } $$$ matrix $$$ i_1\leq <unknown> i_2 $$$ $$$ j_1\leq <unknown> j_2 $$$ sonya state a submatrix beautiful independently reorder character row ( column ) row columns submatrix form <unknown> let 's recall a string call palindrome read leave right right leave example string $$$ abacaba <unknown> a $$$ palindromes string $$$ abca <unknown> ab $$$ help sonya find number beautiful submatrixes submatrixes different element belong one submatrix first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 1\leq n m\leq 250 ) $$$ — matrix dimension next $$$ n $$$ line contain $$$ m $$$ lowercase latin letter print one integer — number beautiful submatrixes first example follow submatrixes beautiful : $$$ ( ( 1 1 ) ( 1 1 ) ) ; ( ( 1 2 ) ( 1 2 ) ) ; $$$ $$$ ( ( 1 3 ) ( 1 3 ) ) ; ( ( 1 1 ) ( 1 3 ) ) $$$ second example submatrixes consist one element follow beautiful : $$$ ( ( 1 1 ) ( 2 1 ) ) ; $$$ $$$ ( ( 1 1 ) ( 1 3 ) ) ; ( ( 2 1 ) ( 2 3 ) ) ; ( ( 1 1 ) ( 2 3 ) ) ; ( ( 2 1 ) ( 2 2 ) ) $$$ beautiful submatrixes : $$$ ( ( 1 1 ) ( 1 5 ) ) ; ( ( 1 2 ) ( 3 4 ) ) ; $$$ $$$ ( ( 1 1 ) ( 3 5 ) ) $$$ submatrix $$$ ( ( 1 1 ) ( 3 5 ) ) $$$ beautiful since reorder : a matrix every row every column form palindromes,['strings'],2400.0
928/A,register a social network users allow create convenient login make easier share contact print business card etc login arbitrary sequence lower uppercase latin letter digits underline symbols ( « _ » ) however order decrease number <unknown> user - <unknown> relate issue prohibit register a login similar already exist login precisely two logins s t consider similar transform s t via a sequence operations follow type : example logins « codeforces » « <unknown> » well « <unknown> » « <unknown> » consider similar whereas « codeforces » « <unknown> » 're give a list exist logins two similar <unknown> a newly create user login check whether new login similar exist ones first line contain a non - empty string s consist lower uppercase latin letter digits underline symbols ( « _ » ) length exceed 50 — login second line contain a single integer n ( 1 ≤ n ≤ 1 000 ) — number exist logins next n line describe exist logins follow constraints user login ( refer first line input ) 's guarantee two exist logins similar print « yes » ( without quote ) user register via login i.e none exist logins similar otherwise print « » ( without quote ) second sample case user want create a login consist three zero 's impossible due collision third among exist third sample case new login similar second one,['strings'],1200.0
1065/G,let 's denote ( yet ) sequence fibonacci string : $$$ f ( 0 ) = $$$ 0 $$$ f ( 1 ) = $$$ 1 $$$ f ( i ) = f ( i - 2 ) + f ( i - 1 ) $$$ plus sign denote concatenation two string let 's denote lexicographically sort sequence suffix string $$$ f ( i ) $$$ $$$ a ( f ( i ) ) $$$ example $$$ f ( 4 ) $$$ 01101 $$$ a ( f ( 4 ) ) $$$ follow sequence : 01 01101 1 101 <unknown> . elements sequence number $$$ 1 $$$ task print $$$ m $$$ first character $$$ k $$$ -th element $$$ a ( f ( n ) ) $$$ less $$$ m $$$ character suffix output whole suffix line input contain three number $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200 $$$ $$$ 1 \le k \le 10^ { 18 } $$$ ) denote index fibonacci string consider index element $$$ a ( f ( n ) ) $$$ number character output respectively guarantee $$$ k $$$ exceed length $$$ f ( n ) $$$ output $$$ m $$$ first character $$$ k $$$ -th element $$$ a ( f ( n ) ) $$$ whole element length less $$$ m $$$,['strings'],2700.0
988/B,give $$$ n $$$ string string consist lowercase english letter rearrange ( reorder ) give string a way every string string place substrings string $$$ a $$$ a substring string $$$ b $$$ possible choose several consecutive letter $$$ b $$$ a way form $$$ a $$$ example string ` ` '' contain a substring string ` ` codeforces '' ` ` '' ` ` therefore '' contain a substring string ` ` four '' ` ` <unknown> '' ` ` <unknown> '' first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number string next $$$ n $$$ line contain give string number letter string $$$ 1 $$$ $$$ 100 $$$ inclusive string consist lowercase english letter string might equal impossible reorder $$$ n $$$ give string require order print ` ` '' ( without quote ) otherwise print ` ` yes '' ( without quote ) $$$ n $$$ give string require order second example reorder string string ` ` abab '' a substring string ` ` abacaba '',['strings'],1100.0
1552/A,"a string $$$ s $$$ length $$$ n $$$ consist lowercase letter english alphabet give must choose number $$$ k $$$ $$$ 0 $$$ $$$ n $$$ , select $$$ k $$$ character $$$ s $$$ permute however want process position $$$ n - k $$$ character remain unchanged perform operation exactly example $$$ <unknown> { ` ` <unknown> '' } $$$ choose $$$ k=4 $$$ character $$$ \texttt { ` ` <unknown> '' } $$$ permute $$$ \texttt { ` ` <unknown> '' } $$$ operation string become $$$ \texttt { ` ` <unknown> '' } $$$ determine minimum $$$ k $$$ possible sort $$$ s $$$ alphabetically ( operation character appear alphabetical order ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 40 $$$ ) — length string second line test case contain string $$$ s $$$ guarantee $$$ s $$$ contain lowercase letter english alphabet test case output minimum $$$ k $$$ allow obtain a string sort alphabetically operation describe first test case choose $$$ k=2 $$$ character $$$ \texttt { ` ` _ ol '' } $$$ rearrange $$$ \texttt { ` ` _ <unknown> '' } $$$ ( result string $$$ \texttt { ` ` <unknown> '' } $$$ ) possible sort string choose strictly less $$$ 2 $$$ character second test case one possible way sort $$$ s $$$ consider $$$ <unknown> $$$ character $$$ \texttt { ` ` _ <unknown> _ '' } $$$ rearrange $$$ \texttt { ` ` _ <unknown> _ '' } $$$ ( result string $$$ \texttt { ` ` <unknown> '' } $$$ ) one show possible sort string choose strictly less $$$ 6 $$$ character third test case string $$$ s $$$ already sort ( choose $$$ k=0 $$$ character ) fourth test case choose $$$ k=4 $$$ character $$$ \texttt { ` ` <unknown> '' } $$$ reverse whole string ( result string $$$ \texttt { ` ` abcd '' } $$$ )",['strings'],800.0
632/C,"'re give a list n string a1 a2 ... , 'd like concatenate together order result string would lexicographically smallest give list string output lexicographically smallest concatenation first line contain integer n — number string ( 1 ≤ n ≤ 5·104 ) next n line contain one string ai ( 1 ≤ |ai| ≤ 50 ) consist lowercase english letter sum string lengths exceed 5·104 print string a — lexicographically smallest string concatenation",['strings'],1700.0
25/E,sometimes hard prepare test program problems bob prepare test new problem string — input data problem one string bob 3 wrong solutions problem first give wrong answer input data contain substring s1 second enter infinite loop input data contain substring s2 third require much memory input data contain substring s3 bob want solutions fail single test minimal length test could n't pass three bob 's solutions ? exactly 3 line input data i - th line contain string si string non - empty consist lowercase latin letter length string n't exceed 105 . output one number — minimal length string contain s1 s2 s3 substrings,['strings'],2200.0
7/D,string s length n call k - palindrome a palindrome prefix suffix length ( k - 1 ) <unknown> definition string ( even empty ) 0 - palindrome let 's call palindrome degree string s a maximum number k s k - palindrome example ` ` <unknown> '' degree equal 3 . give a string task find sum palindrome degrees prefix first line input data contain a non - empty string consist latin letter digits length string exceed 5·106 string case - sensitive output number — sum <unknown> degrees string 's prefix,['strings'],2200.0
762/C,give two string a b. remove minimum possible number consecutive ( stand one another ) character string b a way become a subsequence string a. happen need remove character maybe remove character b make empty subsequence string s string obtain erase zero character ( necessarily consecutive ) string s. first line contain string a second line — string b. string nonempty consist lowercase letter english alphabet length string bigger 105 character first line output a subsequence string a obtain b erase minimum number consecutive character answer consist zero character output « - » ( a <unknown> sign ) first example string a b n't share symbols longest string get empty second example ac a subsequence a time obtain erase consecutive symbols <unknown> string b,['strings'],2100.0
119/D,let s a string whose length equal n. character number 0 n - 1 i j integers 0 ≤ i < j < n. let 's define function f follow : f ( s i j ) = s [ i + 1 ... j - 1 ] + r ( s [ j ... n - 1 ] ) + r ( s [ 0 ... i ] ) s [ p ... q ] a substring string s start position p end position q ( inclusive ) ; ` ` + '' string concatenation operator ; r ( x ) a string result write character x string reverse order j = i + 1 substring s [ i + 1 ... j - 1 ] consider empty give two string a b. find value i j f ( a i j ) = b. number i maximally possible i exist several valid value j choose minimal j. first two input line non - empty string a b correspondingly string 's length exceed 106 character string contain character ascii cod 32 <unknown> inclusive print two integers i j — answer problem solution exist print ` ` -1 -1 '' ( without quote ),['strings'],2500.0
958/A2,<unknown> <unknown> princess heidi get better detect death star time two rebel spy yet give heidi two map possible locations death star since get rid double <unknown> last time know map correct indeed show map solar system contain death star however time empire hide death star well heidi need find a place appear map order detect death star first map n × m grid cell show type cosmic object present correspond <unknown> space second map m × n grid heidi need align two map a way overlap m × m section cosmic object identical help heidi identify m × m section lie within map first line input contain two space - separated integers n m ( 1 ≤ n ≤ 2000 1 ≤ m ≤ 200 m ≤ n ) next n line contain m lower - case latin character ( a - z ) denote first map different character correspond different cosmic object type next m line contain n character describe second map format line output contain two space - separated integers i j denote section size m × m first map start i - th row equal section second map start j - th column row columns number start 1 . several possible ways align map heidi satisfy guarantee a solution exist 5 - <unknown> grid first test case look like :,['strings'],2000.0
985/F,give a string s length n consist lowercase english letter two give string s t say s set distinct character s t set distinct character t. string s t isomorphic lengths equal a one - to - one map ( <unknown> ) f s t f ( si ) = ti formally : example string ` ` <unknown> '' ` ` <unknown> '' isomorphic also string ` ` <unknown> '' ` ` <unknown> '' isomorphic follow pair string isomorphic : ` ` aab '' ` ` <unknown> '' ` ` test '' ` ` best '' handle m query characterize three integers x y len ( 1 ≤ x y ≤ n - len + 1 ) query check two substrings s [ x ... x + len - 1 ] s [ y ... y + len - 1 ] isomorphic first line contain two space - separated integers n m ( 1 ≤ n ≤ 2·105 1 ≤ m ≤ 2·105 ) — length string s number query second line contain string s consist n lowercase english letter follow m line contain a single query line : xi yi leni ( 1 ≤ xi yi ≤ n 1 ≤ leni ≤ n - max ( xi yi ) + 1 ) — description pair substrings check query a separate line print ` ` yes '' substrings s [ xi ... xi + leni - 1 ] s [ yi ... yi + leni - 1 ] isomorphic ` ` '' otherwise query example follow :,['strings'],2300.0
1045/I,"learn a lot space <unknown> a little girl name ana want change subject ana a girl love palindromes ( string read backwards forward ) learn check a give string whether 's a palindrome soon grow tire problem come a interest one need help solve : give array string consist small letter alphabet task find many palindrome pair array a palindrome pair a pair string follow condition hold : least one permutation concatenation two string a palindrome word two string let 's say ` ` aab '' ` ` <unknown> '' concatenate ` ` <unknown> '' check exist a permutation new string a palindrome ( case exist permutation ` ` <unknown> '' ) two pair consider different string locate different indices pair string indices $$$ ( i j ) $$$ consider pair $$$ ( j i ) $$$ first line contain a positive integer $$$ n $$$ ( $$$ 1 \le n \le 100\,000 $$$ ) represent length input array <unknown> next $$$ n $$$ line contain a string ( consist lowercase english letter ' a ' ' z ' ) — element input array total number character input array less $$$ 1\,000\,000 $$$ output one number represent many palindrome pair array first example : second example :",['strings'],1600.0
744/E,hongcow 's teacher hear hongcow learn cyclic shift decide set follow problem give a list n string s1 s2 ... sn contain list a. a list x string call stable follow condition hold first a message define a concatenation elements list x. use arbitrary element many time want may concatenate elements arbitrary order let sx denote set message construct list course set infinite size list nonempty call a single message good follow condition hold : list x call stable every element sx good let f ( l ) 1 l a stable list 0 otherwise find sum f ( l ) l a nonempty contiguous <unknown> a ( contiguous sublists total ) first line input contain a single integer n ( 1 ≤ n ≤ 30 ) denote number string list next n line contain a string si ( ) print a single integer number nonempty contiguous sublists stable first sample 10 sublists consider sublists [ ` ` a '' ` ` ab '' ` ` b '' ] [ ` ` ab '' ` ` b '' ` ` bba '' ] [ ` ` a '' ` ` ab '' ` ` b '' ` ` bba '' ] stable seven sublists stable example x = [ ` ` a '' ` ` ab '' ` ` b '' ] stable since message ` ` ab '' + ` ` ab '' = ` ` abab '' four cyclic shift [ ` ` abab '' ` ` baba '' ` ` abab '' ` ` baba '' ] elements sx,['strings'],3200.0
701/C,sergei b. young coach pokemons find big house consist n flats order a row leave right possible enter flat street possible go flat also flat connect flat leave flat right flat number 1 connect flat number 2 flat number n connect flat number n - 1 . exactly one pokemon type flats sergei b. ask residents house let enter flats order catch pokemons consult residents house decide let sergei b. enter one flat street visit several flats go flat wo n't let visit flat sergei b. please want visit flats possible order collect pokemons type appear house task help determine minimum number flats visit first line contain integer n ( 1 ≤ n ≤ 100 000 ) — number flats house second line contain row s length n consist uppercase lowercase letter english alphabet i - th letter equal type pokemon flat number i. print minimum number flats sergei b. visit order catch pokemons type house first test sergei b. begin example flat number 1 end flat number 2 . second test sergei b. begin example flat number 4 end flat number 6 . third test sergei b. must begin flat number 2 end flat number 6,['strings'],1500.0
8/A,peter like travel train like much train fall asleep summer peter go train city a city b usual sleep wake start look window notice every <unknown> station a flag a particular colour boy start memorize order flag ' colour see soon fell asleep unfortunately n't sleep long wake go memorize colour fell asleep time sleep till end journey station tell parent write two sequence colour see sleep respectively peter 's parent know son like <unknown> give list flag ' colour station train pass sequentially way a b ask find peter could see sequence way a b b a. remember please peter two periods wakefulness peter 's parent put lowercase latin letter colour letter stand colour different letter — different colour input data contain three line first line contain a non - empty string whose length exceed 105 string consist lowercase latin letter — flag ' colour station way a b. way b a train pass station reverse order second line contain sequence write peter first period wakefulness third line contain sequence write second period wakefulness sequence non - empty consist lowercase latin letter length exceed 100 letter sequence write chronological order output one four word without invert commas : assume train move time one flag see twice flag station a b,['strings'],1200.0
665/E,"one day zs coder write array integers a elements a1 a2 ... , a subarray array a a sequence al al + 1 ... ar integers ( l r ) 1 ≤ l ≤ r ≤ n. zs coder think a subarray a beautiful bitwise xor elements subarray least k. help zs coder find number beautiful subarrays a ! first line contain two integers n k ( 1 ≤ n ≤ 106 1 ≤ k ≤ 109 ) — number elements array a value parameter k. second line contain n integers ai ( 0 ≤ ai ≤ 109 ) — elements array a. print integer c — number beautiful subarrays array a","['data structures', 'strings']",2100.0
610/E,give a string s length n consist first k lowercase english letter define a c - repeat string q a string consist c copy string <unknown> example string ` ` <unknown> '' a 4 - repeat string ` ` acb '' let 's say string a contain string b a subsequence string b obtain a erase symbols let p a string represent permutation first k lowercase english letter define function d ( p ) smallest integer a d ( p ) <unknown> string p contain string s a subsequence m operations one two type apply string s : operations perform sequentially order appear input task determine value function d ( p ) operations second type first line contain three positive integers n m k ( 1 ≤ n ≤ 200 000 1 ≤ m ≤ 20000 1 ≤ k ≤ 10 ) — length string s number operations size alphabet respectively second line contain string s follow line m contain a description operation : query second type value function d ( p ) first operation string s <unknown> second operation answer 6 - repeat abc : <unknown> third operation string s <unknown> fourth operation answer 5 - repeat cba : <unknown> uppercase letter mean occurrences symbols string s,"['data structures', 'strings']",2500.0
785/A,anton 's favourite <unknown> figure regular polyhedrons note five kinds regular polyhedrons : five kinds polyhedrons show picture : anton a collection n polyhedrons one day decide know many face polyhedrons total help anton find number ! first line input contain a single integer n ( 1 ≤ n ≤ 200 000 ) — number polyhedrons anton 's collection follow n line input contain a string si — name i - th <unknown> anton 's collection string look like : output one number — total number face polyhedrons anton 's collection first sample anton one icosahedron one cube one tetrahedron one dodecahedron icosahedron 20 face cube 6 face tetrahedron 4 face dodecahedron 12 face total 20 + 6 + 4 + 12 = 42 face,"['implementation', 'strings']",800.0
1575/H,"winter holiday soon mr . chanek want decorate house 's wall <unknown> wall represent a binary string $$$ a $$$ length $$$ n $$$ favorite nephew another binary string $$$ b $$$ length $$$ m $$$ ( $$$ m \leq n $$$ ) mr . chanek 's nephew love non - negative integer $$$ k $$$ nephew want exactly $$$ k $$$ occurrences $$$ b $$$ substrings $$$ a $$$ however mr . chanek know value $$$ k $$$ , $$$ k $$$ ( $$$ 0 \leq k \leq n - m + 1 $$$ ) find minimum number elements $$$ a $$$ change exactly $$$ k $$$ occurrences $$$ b $$$ $$$ a $$$ a string $$$ s $$$ occur exactly $$$ k $$$ time $$$ t $$$ exactly $$$ k $$$ different pair $$$ ( p q ) $$$ obtain $$$ s $$$ delete $$$ p $$$ character begin $$$ q $$$ character end $$$ t $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq m \leq n \leq 500 $$$ ) — size binary string $$$ a $$$ $$$ b $$$ respectively second line contain a binary string $$$ a $$$ length $$$ n $$$ third line contain a binary string $$$ b $$$ length $$$ m $$$ output $$$ n - m + 2 $$$ integers — $$$ ( k+1 ) $$$ -th integer denote minimal number elements $$$ a $$$ change exactly $$$ k $$$ occurrences $$$ b $$$ a substring $$$ a $$$ $$$ k = 0 $$$ make string $$$ a $$$ occurrence 101 one character change <unknown> $$$ \rightarrow $$$ <unknown> $$$ k = 1 $$$ also change a single <unknown> $$$ \rightarrow $$$ <unknown> $$$ k = 2 $$$ change need","['dp', 'strings']",2200.0
1446/B,give two string $$$ a $$$ $$$ b $$$ represent essay two students suspect <unknown> two string $$$ c $$$ $$$ d $$$ define similarity score $$$ s ( c d ) $$$ $$$ <unknown> lcs ( c d ) - |c| - |d| $$$ $$$ lcs ( c d ) $$$ denote length longest common subsequence string $$$ c $$$ $$$ d $$$ believe part essay could copy therefore 're interest substrings calculate maximal similarity score pair substrings formally output maximal $$$ s ( c d ) $$$ pair $$$ ( c d ) $$$ $$$ c $$$ substring $$$ a $$$ $$$ d $$$ substring $$$ b $$$ $$$ x $$$ a string $$$ |x| $$$ denote length a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end a string $$$ a $$$ a subsequence a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character pay attention difference substring subsequence appear problem statement may wish read wikipedia page longest common subsequence problem first line contain two positive integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 5000 $$$ ) — lengths two string $$$ a $$$ $$$ b $$$ second line contain a string consist $$$ n $$$ lowercase latin letter — string $$$ a $$$ third line contain a string consist $$$ m $$$ lowercase latin letter — string $$$ b $$$ output maximal $$$ s ( c d ) $$$ pair $$$ ( c d ) $$$ $$$ c $$$ substring $$$ a $$$ $$$ d $$$ substring $$$ b $$$ first case : abb first string abab second string lcs equal abb result $$$ s ( abb abab ) = ( 4 \cdot |abb| $$$ ) - $$$ |abb| $$$ - $$$ <unknown> $$$ = $$$ 12 - 3 - 4 = 5 $$$,"['dp', 'strings']",1800.0
774/K,stepan like repeat vowel letter write word example instead word ` ` <unknown> '' write ` ` <unknown> '' sergey like behavior want write a program format word write stepan program must combine consecutive equal <unknown> a single vowel vowel letter ` ` a '' ` ` e '' ` ` i '' ` ` o '' ` ` u '' ` ` y '' <unknown> : letter ` ` e '' ` ` o '' repeat a row exactly 2 time like word ` ` <unknown> '' ` ` foot '' program must skip transform one vowel example word ` ` <unknown> '' must convert word ` ` <unknown> '' sergey busy ask help write require program first line contain integer n ( 1 ≤ n ≤ 100 000 ) — number letter word write stepan second line contain string s length equal n contain lowercase english letter — word write stepan print single string — word write stepan convert accord rule describe statement,"['implementation', 'strings']",1600.0
1220/C,mike ann sit classroom lesson bore decide play interest game fortunately need play game a string $$$ s $$$ a number $$$ k $$$ ( $$$ 0 \le k < |s| $$$ ) begin game players give a substring $$$ s $$$ leave border $$$ l $$$ right border $$$ r $$$ equal $$$ k $$$ ( i.e initially $$$ l = r = k $$$ ) players start make move one one accord follow rule : recall a substring $$$ s [ l r ] $$$ ( $$$ l \le r $$$ ) a string $$$ s $$$ a continuous segment letter s start position $$$ l $$$ end position $$$ r $$$ example ` ` <unknown> '' a substring ( $$$ s [ 3 5 ] $$$ ) ` ` <unknown> '' ` ` <unknown> '' mike ann play <unknown> notice teacher approach <unknown> teacher n't <unknown> instead say figure winner game start even know $$$ s $$$ $$$ k $$$ unfortunately mike ann keen game theory ask write a program take $$$ s $$$ determine winner possible $$$ k $$$ first line input contain a single string $$$ s $$$ ( $$$ 1 \leq |s| \leq 500000 $$$ ) consist lowercase english letter print $$$ |s| $$$ line line $$$ i $$$ write name winner ( print mike ann ) game string $$$ s $$$ $$$ k = i $$$ play optimally,"['greedy', 'strings']",1300.0
1480/A,homer two friends alice bob string fan one day alice bob decide play a game a string $$$ s = s_1 s_2 \dots s_n $$$ length $$$ n $$$ consist lowercase english letter move turn alternatively alice make first move a move a player must choose index $$$ i $$$ ( $$$ 1 \leq i \leq n $$$ ) choose change $$$ s_i $$$ lowercase english letter $$$ c $$$ $$$ c \neq s_i $$$ indices choose game end goal alice make final string lexicographically small possible goal bob make final string lexicographically large possible game <unknown> always play game optimally homer a game expert wonder final string a string $$$ a $$$ lexicographically smaller a string $$$ b $$$ one follow hold : test contain multiple test case first line contain $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case description test case follow line test case contain a single string $$$ s $$$ ( $$$ 1 \leq |s| \leq 50 $$$ ) consist lowercase english letter test case print final string a single line first test case : alice make first move must change letter a different one change ' b ' second test case : alice change first letter ' a ' bob change second letter ' z ' alice change third letter ' a ' bob change fourth letter ' z ' third test case : alice change first letter ' b ' bob change second letter ' y ',"['greedy', 'strings']",800.0
802/G,'s first april heidi suspect news read today fake want look silly front contestants know a <unknown> fake contain heidi a subsequence help heidi <unknown> whether give piece true please <unknown> ... first line input contain a single nonempty string s length 1000 compose lowercase letter ( a - z ) output yes string s contain heidi a subsequence otherwise a string s contain another string p a subsequence possible delete character s obtain p,"['implementation', 'strings']",800.0
587/F,duff mad friends 's sometimes make malek take candy one friends reason ! n friends i - th friend 's name si ( name necessarily unique ) q time ask malek take candy friends 's angry also act rule want ask malek take candy one friends like k choose two number l r tell malek take exactly candy him / her occur ( t s ) number occurrences string t s. malek able calculate many candy take request duff 's ask help please tell many candy take request first line input contain two integers n q ( 1 ≤ n q ≤ 105 ) next n line contain name i - th contain string si consist lowercase english letter ( ) next q line contain request contain three integers l r k ( say malek take candy duff 's k - th friend ) print answer request one line,"['data structures', 'strings']",3000.0
831/B,two popular keyboard layouts berland differ letter position key berland use alphabet 26 letter coincide english alphabet give two string consist 26 distinct letter : key first second layouts order also give text consist small capital english letter digits know type first layout <unknown> intend type second layout print text key press second layout since key letter layouts <unknown> letter remain well character first line contain a string length 26 consist distinct lowercase english letter first layout second line contain a string length 26 consist distinct lowercase english letter second layout third line contain a non - empty string s consist lowercase uppercase english letter digits text type first layout length s exceed 1000 . print text key press second layout,"['implementation', 'strings']",800.0
38/F,petya vasya invent a new game call ` ` smart boy '' locate a certain set word — dictionary — game <unknown> dictionary contain similar word rule game follow : first first player choose letter ( a word long 1 ) word dictionary write a piece paper second player add letter one 's initial final position thus make a word long 2 's first player 's turn add a letter begin end thus make a word long 3 player must n't break one condition : newly create word must a substring a word a dictionary player ca n't add a letter current word without break condition lose also end a turn a certain string s write paper player whose turn get a number point accord formula : task learn win game final score every player play optimally try win — maximize number point — minimize number point opponent first input line contain integer n number word locate dictionary ( 1 ≤ n ≤ 30 ) n line contain word dictionary — one word write one line line nonempty consist latin lower - case character longer 30 character equal word list word first output line print a line ` ` first '' ` ` second '' mean win game second line output number point first player number point second player game end separate number a single space,"['dp', 'strings']",2100.0
827/C,"everyone know dna strand consist nucleotides four type nucleotides : ` ` a '' ` ` t '' ` ` g '' ` ` c '' a dna strand a sequence nucleotides scientists decide track evolution a rare species dna strand string s initially evolution species describe a sequence change dna every change a change nucleotide example follow change happen dna strand ` ` <unknown> '' : second nucleotide change ` ` t '' result dna strand ` ` <unknown> '' scientists know segment dna strand affect unknown infections represent infection a sequence nucleotides scientists interest change cause infections thus sometimes want know value impact infection segment dna value compute follow : a developer innokenty interest bioinformatics also scientists ask help innokenty busy prepare vk cup decide delegate problem <unknown> help scientists ! first line contain string s ( 1 ≤ |s| ≤ 105 ) describe initial dna strand consist capital english letter ` ` a '' ` ` t '' ` ` g '' ` ` c '' next line contain single integer q ( 1 ≤ q ≤ 105 ) — number events , q line follow describe one event line one two format : scientists ' query ( second type query ) print a single integer a new line — value impact infection dna consider first example first query second type character coincide answer 8 . second query compare string ` ` <unknown> ... '' substring ` ` <unknown> '' two match third query dna change compare string ` ` <unknown> ... '' ' substring ` ` <unknown> '' 4 match","['data structures', 'strings']",2100.0
955/D,jenya recently acquire quite a useful tool — k - scissors cut string generally use cut two non - intersecting substrings length k arbitrary string s ( length least 2·k order perform operation ) concatenate afterwards ( preserve initial order ) example help 2 - scissors cut ab de abcde concatenate <unknown> ab bc since 're intersect 's a nice idea test tool use practice look paper jenya come two string s t. question whether possible apply scissor string s result concatenation contain t a substring ? first line contain three integers n m k ( 2 ≤ m ≤ 2·k ≤ n ≤ 5·105 ) — length s length t aforementioned scissor ' parameter correspondingly next two line feature s t consist lowercase latin letter answer print « » otherwise print « yes » two integers l r denote index <unknown> substrings start ( 1 - indexed ) several possible answer output first sample case cut two substrings start 1 5 . result string <unknown> contain aaaa a substring second sample case result string <unknown>,"['brute force', 'strings']",2600.0
259/A,"little elephant love chess much one day little elephant friend decide play chess ' ve get chess piece board a problem ' ve get 8 × 8 checker board square paint either black white little elephant friend know a proper chessboard n't side - adjacent cells color upper leave cell white play chess want make board a proper chessboard friends choose row board cyclically shift cells choose row , put last ( rightmost ) square first place row shift others one position right run describe operation multiple time ( run ) example first line board look like ` ` <unknown> '' ( white cells line mark character ` ` w '' black cells mark character ` ` b '' ) one cyclic shift look like ` ` <unknown> '' help little elephant friend find whether use number describe operations turn board a proper chessboard input consist exactly eight line line contain exactly eight character ` ` w '' ` ` b '' without space : j - th character i - th line stand color j - th cell i - th row elephants ' board character ` ` w '' stand white color character ` ` b '' stand black color consider row board number 1 8 top bottom columns — 1 8 leave right give board initially a proper chessboard a single line print ` ` yes '' ( without quote ) make board a proper chessboard ` ` '' ( without quote ) otherwise first sample shift follow line one position right : 3 - rd 6 - th 7 - th 8 - th second sample way achieve goal","['brute force', 'strings']",1000.0
918/B,guy fry radio station <unknown> school <unknown> give task a punishment dustin 's task add comment nginx configuration school 's website school n servers server a name ip ( name n't necessarily unique ips ) dustin know ip name server simplicity 'll assume nginx command form ` ` command ip ; '' command a string consist english lowercase letter ip ip one school servers ip form ` ` <unknown> '' a b c d non - negative integers less equal 255 ( lead zero ) nginx configuration file dustin add comment m command nobody ever memorize ips servers understand configuration better dustin comment name server ip belong end line ( command ) formally a line ` ` command ip ; '' dustin replace ` ` command ip ; # name '' name name server ip equal ip dustin n't know anything nginx panic friends ask task first line input contain two integers n m ( 1 ≤ n m ≤ 1000 ) next n line contain name ips servers line contain a string name name server a string ip ip server separate space ( 1 ≤ <unknown> ≤ 10 name consist english lowercase letter ) guarantee ip distinct next m line contain command configuration file line form ` ` command ip ; '' ( 1 ≤ <unknown> ≤ 10 command consist english lowercase letter ) guarantee ip belong one n school servers print m line command configuration file dustin task,"['implementation', 'strings']",900.0
278/B,come a new problem n't easy many people think sometimes hard enough name 'll consider a title original n't occur a substring title recent codeforces problems ' ve get title n last problems — string consist lowercase english letter task find shortest original title new problem multiple title choose lexicographically minimum one note title problem ca n't empty string a substring s [ l ... r ] ( 1 ≤ l ≤ r ≤ |s| ) string s = s1s2 ... s|s| ( |s| length string s ) string <unknown> + 1 ... sr . string x = x1x2 ... xp lexicographically smaller string y = y1y2 ... yq either p < q x1 = y1 x2 = y2 ... xp = yp exist number r ( r < p r < q ) x1 = y1 x2 = y2 ... xr = yr xr + 1 < yr + 1 . string character compare ascii cod first line contain integer n ( 1 ≤ n ≤ 30 ) — number title ' ve get consider follow n problem title one per line title consist lowercase english letter ( specifically n't contain space ) length 1 20 inclusive print a string consist lowercase english letter — lexicographically minimum shortest original title first sample first 9 letter english alphabet ( a b c d e f g h i ) occur problem title answer letter j. second sample title contain 26 english letter shortest original title length 1 . title aa occur a substring first title,"['brute force', 'strings']",1500.0
1673/A,alice bob play a game string $$$ t $$$ round game round a string $$$ s $$$ consist lowercase english letter alice move first players take alternate turn alice allow remove substring even length ( possibly empty ) bob allow remove substring odd length $$$ s $$$ formally a string $$$ s = <unknown> \ldots s_k $$$ player choose a substring $$$ s_ls _ { l+1 } \ldots s _ { r-1 } s_r $$$ length correspond parity remove string become $$$ s = s_1 \ldots s _ { <unknown> } s _ { <unknown> } \ldots s_k $$$ string become empty round end player calculate his / her score round score a player sum value character remove him / her value $$$ \texttt { a } $$$ $$$ 1 $$$ value $$$ \texttt { b } $$$ $$$ 2 $$$ value $$$ \texttt { c } $$$ $$$ 3 $$$ $$$ \ldots $$$ value $$$ \texttt { z } $$$ $$$ 26 $$$ player higher score win round round determine winner difference winner 's loser 's score assume players play optimally maximize score prove a draw impossible first line input contain a single integer $$$ t $$$ ( $$$ 1\leq <unknown> 5\cdot 10000 $$$ ) denote number round next $$$ t $$$ line contain a single string $$$ s $$$ ( $$$ 1\leq <unknown> 2\cdot 100000 $$$ ) consist lowercase english letter denote string use round $$$ |s| $$$ denote length string $$$ s $$$ guarantee sum $$$ |s| $$$ round exceed $$$ 2\cdot 100000 $$$ round print a single line contain a string integer alice win round string must ` ` alice '' bob win round string must ` ` bob '' integer must difference score assume players play optimally first round $$$ \texttt { ` ` aba '' } \xrightarrow { \texttt { alice } } \texttt { ` ` } { \color { red } { \texttt { ab } } } \texttt { a '' } \xrightarrow { } \texttt { ` ` a '' } \xrightarrow { \texttt { bob } } \texttt { ` ` } { \color { red } { \texttt { a } } } \texttt { ` ` } \xrightarrow { } \texttt { ` ` '' } $$$ alice 's total score $$$ 1 + 2=3 $$$ bob 's total score $$$ 1 $$$ second round $$$ \texttt { ` ` abc '' } \xrightarrow { \texttt { alice } } \texttt { ` ` a } { \color { red } { \texttt { bc } } } \texttt { ` ` } \xrightarrow { } \texttt { ` ` a '' } \xrightarrow { \texttt { bob } } \texttt { ` ` } { \color { red } { \texttt { a } } } \texttt { ` ` } \xrightarrow { } \texttt { ` ` '' } $$$ alice 's total score $$$ 2 + <unknown> $$$ bob 's total score $$$ 1 $$$ third round $$$ \texttt { ` ` cba '' } \xrightarrow { \texttt { alice } } \texttt { ` ` } { \color { red } { \texttt { cb } } } \texttt { a '' } \xrightarrow { } \texttt { ` ` a '' } \xrightarrow { \texttt { bob } } \texttt { ` ` } { \color { red } { \texttt { a } } } \texttt { ` ` } \xrightarrow { } \texttt { ` ` '' } $$$ alice 's total score $$$ 3 + 2=5 $$$ bob 's total score $$$ 1 $$$ fourth round $$$ \texttt { ` ` n '' } \xrightarrow { \texttt { alice } } \texttt { ` ` n '' } \xrightarrow { } \texttt { ` ` n '' } \xrightarrow { \texttt { bob } } \texttt { ` ` } { \color { red } { \texttt { n } } } \texttt { ` ` } \xrightarrow { } \texttt { ` ` '' } $$$ alice 's total score $$$ 0 $$$ bob 's total score $$$ 14 $$$ fifth round $$$ \texttt { ` ` codeforces '' } \xrightarrow { \texttt { alice } } \texttt { ` ` } { \color { red } { \texttt { codeforces } } } \texttt { ` ` } \xrightarrow { } \texttt { ` ` '' } $$$ alice 's total score $$$ 3 + 15 + 4 + 5 + 6 + 15 + 18 + 3 + 5 + <unknown> $$$ bob 's total score $$$ 0 $$$,"['greedy', 'strings']",800.0
906/A,valentin participate a show call ` ` <unknown> '' rule quite easy : jury select one letter valentin n't know make a small <unknown> every time pronounce a word contain select letter receive electric shock make guess letter select incorrect guess receive electric shock show end valentin guess select letter correctly valentin ca n't keep mind everything could guess select letter much later uniquely determine get excessive electric shock excessive electric shock valentin get moment select letter uniquely determine find number excessive electric shock first line contain a single integer n ( 1 ≤ n ≤ 105 ) — number action valentin next n line contain descriptions action line contain description one action action one three type : word consist lowercase english letter total length word exceed 105 . guarantee last action a guess select letter also guarantee valentin n't make correct guess select letter last action moreover 's guarantee valentin get electric shock pronounce word contain select letter ; also valentin n't get electric shock pronounce word contain select letter output a single integer — number electric shock valentin could avoid tell select letter become uniquely determine first test case first action become clear select letter one follow : a b c. second action note select letter a. valentin tell word ` ` b '' n't get a shock clear select letter c valentin pronounce word cd get excessive electric shock second test case first two electric shock understand select letter e o. valentin try word consist letter second word 's clear select letter e valentin make 3 action make a correct <unknown> third example select letter uniquely determine valentin guess n't get excessive electric shock,"['implementation', 'strings']",1600.0
1286/E,"fedya a string $$$ s $$$ initially empty array $$$ w $$$ also initially empty $$$ n $$$ query process one a time query $$$ i $$$ consist a lowercase english letter $$$ c_i $$$ a nonnegative integer $$$ w_i $$$ first $$$ c_i $$$ must append $$$ s $$$ $$$ w_i $$$ must append $$$ w $$$ answer query sum <unknown> subsegments $$$ w $$$ $$$ [ l \ r ] $$$ $$$ ( 1 \leq l \leq r \leq i ) $$$ define suspiciousness a subsegment follow : substring $$$ s $$$ correspond subsegment ( a string consecutive character $$$ l $$$ -th $$$ r $$$ -th inclusive ) match prefix $$$ s $$$ length ( a substring correspond subsegment $$$ [ 1 \ r - l + 1 ] $$$ ) suspiciousness equal minimum array $$$ w $$$ $$$ [ l \ r ] $$$ subsegment otherwise case substring match correspond prefix suspiciousness $$$ 0 $$$ help fedya answer query <unknown> come ! first line contain integer $$$ n $$$ $$$ ( 1 \leq n \leq <unknown> ) $$$ — number query $$$ i $$$ -th follow $$$ n $$$ line contain query $$$ i $$$ : a lowercase letter latin alphabet $$$ c_i $$$ integer $$$ w_i $$$ $$$ ( 0 \leq w_i \leq 2^ { 30 } - 1 ) $$$ query give encrypt form let $$$ ans $$$ answer previous query ( first query set value equal $$$ 0 $$$ ) , order get real query need follow : perform a cyclic shift $$$ c_i $$$ alphabet forward $$$ ans $$$ set $$$ w_i $$$ equal $$$ w_i \oplus ( ans \ \ & \ mask ) $$$ $$$ \oplus $$$ bitwise exclusive ` ` '' $$$ \ & $$$ bitwise ` ` '' $$$ mask = 2^ { 30 } - 1 $$$ print $$$ n $$$ line $$$ i $$$ -th line contain a single integer — answer $$$ i $$$ -th query convenience call ` ` suspicious '' subsegments correspond line prefix $$$ s $$$ , whose suspiciousness may zero a result <unknown> first example request string $$$ s $$$ equal ` ` abacaba '' $$$ w_i = 1 $$$ , suspiciousness suspicious sub - <unknown> simply equal $$$ 1 $$$ let 's see answer obtain <unknown> $$$ s $$$ = ` ` a '' array $$$ w $$$ a single subsegment — $$$ [ 1 \ 1 ] $$$ correspond substring ` ` a '' , entire string $$$ s $$$ thus a prefix $$$ s $$$ suspiciousness subsegment $$$ 1 $$$ .2 $$$ s $$$ = ` ` ab '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ $$$ [ 1 \ 2 ] $$$ total $$$ 2 $$$ .3 $$$ s $$$ = ` ` aba '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ $$$ [ 1 \ 2 ] $$$ $$$ [ 1 \ 3 ] $$$ $$$ [ 3 \ 3 ] $$$ total $$$ 4 $$$ .4 $$$ s $$$ = ` ` <unknown> '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ $$$ [ 1 \ 2 ] $$$ $$$ [ 1 \ 3 ] $$$ $$$ [ 1 \ 4 ] $$$ $$$ [ 3 \ 3 ] $$$ total $$$ 5 $$$ .5 $$$ s $$$ = ` ` abaca '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ $$$ [ 1 \ 2 ] $$$ $$$ [ 1 \ 3 ] $$$ $$$ [ 1 \ 4 ] $$$ $$$ [ 1 \ 5 ] $$$ $$$ [ 3 \ 3 ] $$$ $$$ [ 5 \ 5 ] $$$ total $$$ 7 $$$ <unknown> $$$ s $$$ = ` ` <unknown> '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ $$$ [ 1 \ 2 ] $$$ $$$ [ 1 \ 3 ] $$$ $$$ [ 1 \ 4 ] $$$ $$$ [ 1 \ 5 ] $$$ $$$ [ 1 \ 6 ] $$$ $$$ [ 3 \ 3 ] $$$ $$$ [ 5 \ 5 ] $$$ $$$ [ 5 \ 6 ] $$$ total $$$ 9 $$$ <unknown> $$$ s $$$ = ` ` abacaba '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ $$$ [ 1 \ 2 ] $$$ $$$ [ 1 \ 3 ] $$$ $$$ [ 1 \ 4 ] $$$ $$$ [ 1 \ 5 ] $$$ $$$ [ 1 \ 6 ] $$$ $$$ [ 1 \ 7 ] $$$ $$$ [ 3 \ 3 ] $$$ $$$ [ 5 \ 5 ] $$$ $$$ [ 5 \ 6 ] $$$ $$$ [ 5 \ 7 ] $$$ $$$ [ 7 \ 7 ] $$$ total $$$ 12 $$$ second example request $$$ s $$$ = ` ` aaba '' $$$ w = [ 2 0 2 0 ] $$$ .1 $$$ s $$$ = ` ` a '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ ( suspiciousness $$$ 2 $$$ ) total $$$ 2 $$$ .2 $$$ s $$$ = ` ` aa '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ ( $$$ 2 $$$ ) $$$ [ 1 \ 2 ] $$$ ( $$$ 0 $$$ ) $$$ [ 2 \ 2 ] $$$ ( $$$ 0 $$$ ) total $$$ 2 $$$ .3 $$$ s $$$ = ` ` aab '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ ( $$$ 2 $$$ ) $$$ [ 1 \ 2 ] $$$ ( $$$ 0 $$$ ) $$$ [ 1 \ 3 ] $$$ ( $$$ 0 $$$ ) $$$ [ 2 \ 2 ] $$$ ( $$$ 0 $$$ ) total $$$ 2 $$$ .4 $$$ s $$$ = ` ` aaba '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ ( $$$ 2 $$$ ) $$$ [ 1 \ 2 ] $$$ ( $$$ 0 $$$ ) $$$ [ 1 \ 3 ] $$$ ( $$$ 0 $$$ ) $$$ [ 1 \ 4 ] $$$ ( $$$ 0 $$$ ) $$$ [ 2 \ 2 ] $$$ ( $$$ 0 $$$ ) $$$ [ 4 \ 4 ] $$$ ( $$$ 0 $$$ ) total $$$ 2 $$$ third example condition request $$$ s $$$ = ` ` abcde '' $$$ w = [ 7 2 10 1 7 ] $$$ .1 $$$ s $$$ = ` ` a '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ ( $$$ 7 $$$ ) total $$$ 7 $$$ .2 $$$ s $$$ = ` ` ab '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ ( $$$ 7 $$$ ) $$$ [ 1 \ 2 ] $$$ ( $$$ 2 $$$ ) total $$$ 9 $$$ .3 $$$ s $$$ = ` ` abc '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ ( $$$ 7 $$$ ) $$$ [ 1 \ 2 ] $$$ ( $$$ 2 $$$ ) $$$ [ 1 \ 3 ] $$$ ( $$$ 2 $$$ ) total $$$ 11 $$$ .4 $$$ s $$$ = ` ` abcd '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ ( $$$ 7 $$$ ) $$$ [ 1 \ 2 ] $$$ ( $$$ 2 $$$ ) $$$ [ 1 \ 3 ] $$$ ( $$$ 2 $$$ ) $$$ [ 1 \ 4 ] $$$ ( $$$ 1 $$$ ) total $$$ 12 $$$ .5 $$$ s $$$ = ` ` abcde '' suspicious subsegments : $$$ [ 1 \ 1 ] $$$ ( $$$ 7 $$$ ) $$$ [ 1 \ 2 ] $$$ ( $$$ 2 $$$ ) $$$ [ 1 \ 3 ] $$$ ( $$$ 2 $$$ ) $$$ [ 1 \ 4 ] $$$ ( $$$ 1 $$$ ) $$$ [ 1 \ 5 ] $$$ ( $$$ 1 $$$ ) total $$$ 13 $$$","['data structures', 'strings']",3200.0
358/B,<unknown> a <unknown> character time <unknown> leave room dima girlfriend ( <unknown> inna way ) however two <unknown> always find a way communicate today write text message dima inna use a secret code text message dima want send inna <unknown> write word insert a heart word last word a heart a sequence two character : ` ` less '' character ( < ) digit three ( 3 ) apply code a test message look like : < <unknown> < <unknown> < 3 ... <unknown> < 3 encode n't end dima insert a random number small english character digits sign ` ` '' ` ` less '' place message inna know dima perfectly well know phrase dima go send beforehand inna get a text message help find dima encode message correctly word find a text message could receive encode manner describe first line contain integer n ( 1 ≤ n ≤ 105 ) — number word dima 's message next n line contain non - empty word one word per line word consist small english letter total length word n't exceed 105 . last line contain non - empty text message inna get number character text message n't exceed 105 . a text message contain small english letter digits sign less a single line print ` ` yes '' ( without quote ) dima decode text message correctly ` ` '' ( without quote ) otherwise please note dima get a good old <unknown> <unknown> second sample statement,"['brute force', 'strings']",1500.0
899/F,petya a string length n consist small large english letter digits perform m operations operation describe two integers l r a character c : petya remove string character c position l r inclusive 's obvious length string remain decrease operation find string look like petya perform m operations first string contain two integers n m ( 1 ≤ n m ≤ 2·105 ) — length string number operations second line contain string length n consist small large english letter digits position string enumerate 1 . next m line contain two integers l r ( 1 ≤ l ≤ r ) follow a character c a small large english letter a digit line describe one operation guarantee r n't exceed length string s current operation print string petya obtain perform m operations string become empty operations print empty line first example first operation letter ' a ' remove string become ` ` bc '' second operation letter ' c ' ( second position ) remove string become ` ` b '' second example first operation petya remove ' 0 ' second position string become ` ` az '' second operations string n't change,"['data structures', 'strings']",2100.0
883/E,polycarpus take part ` ` field wonder '' tv show participants show guess a hide word fast possible initially letter word hide game consist several turn turn participant tell a letter tv show host respond letter word letter host reveal letter example hide word ` ` abacaba '' player tell letter ` ` a '' host reveal letter position occupy ` ` a '' : 1 3 5 7 ( position number leave right start 1 ) polycarpus know m word exactly length hide word hide word also know appear one m word current moment a number turn already make letter ( possibly zero ) hide word already reveal previously polycarp tell exactly letter currently reveal polycarpus ' turn want tell a letter a way tv show host assuredly reveal least one letter polycarpus tell letter already reveal task help polycarpus find number letter tell show host assuredly reveal least one remain letter first line contain one integer n ( 1 ≤ n ≤ 50 ) — length hide word follow line describe already reveal letter contain string length n consist lowercase latin letter symbols ` ` * '' a letter position letter already reveal position contain symbol ` ` * '' letter position reveal yet guarantee least one letter still close third line contain integer m ( 1 ≤ m ≤ 1000 ) — number word length n polycarpus know follow m line contain word — n - letter string lowercase latin letter word distinct guarantee hide word appear one give m word current move polycarp tell exactly letter currently reveal output single integer — number letter polycarpus tell tv show host definitely reveal least one letter possible number zero first example polycarpus tell letter ` ` b '' ` ` c '' assuredly reveal second example contain letter tell clear letter ` ` v '' ` ` s '' locate third position hide word third example polycarpus exactly know hide word ` ` aba '' case ` ` aaa '' second letter ` ` a '' would already reveal one previous turn,"['implementation', 'strings']",1500.0
877/A,one day alex create a contest friends accidentally delete fortunately problems save need find among problems many problems manually alex ask write a program determine a problem contest name know problem contest name contain one alex 's friends ' name exactly friends ' name ` ` danil '' ` ` <unknown> '' ` ` slava '' ` ` ann '' ` ` nikita '' name case sensitive line contain string lowercase uppercase letter ` ` _ '' symbols length 100 — name problem print ` ` yes '' problem contest ` ` '' otherwise,"['implementation', 'strings']",1100.0
1674/C,"give a string $$$ s $$$ consist latin letter ' a ' a string $$$ t $$$ consist lowercase latin letter one move replace letter ' a ' string $$$ s $$$ a string $$$ t $$$ note replacement string $$$ s $$$ might contain letter ' a ' perform arbitrary number move ( include zero ) many different string obtain ? print number report infinitely large two string consider different different length differ index first line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 10000 $$$ ) — number testcases first line testcase contain a non - empty string $$$ s $$$ consist latin letter ' a ' length $$$ s $$$ n't exceed $$$ 50 $$$ second line contain a non - empty string $$$ t $$$ consist lowercase latin letter length $$$ t $$$ n't exceed $$$ 50 $$$ testcase print number different string $$$ s $$$ obtain arbitrary amount move ( include zero ) number infinitely large print -1 . otherwise print number first example replace letter ' a ' string ` ` a '' wo n't change string matter many move make ca n't obtain a string initial one second example replace second letter ' a ' ` ` abc '' string $$$ s $$$ become equal ` ` <unknown> '' second letter ' a ' string $$$ s $$$ become equal ` ` <unknown> '' , generate infinitely many different string third example either leave string $$$ s $$$ perform zero move replace ' a ' ` ` b '' string $$$ s $$$ become equal ` ` b '' ca n't perform move","['implementation', 'strings']",1000.0
862/F,mahmoud ehab solve dr . evil 's question give password door evil land try open door use door give a final question solve leave ( yes door digital dr . evil modern ) n't solve work useless wo n't leave evil land forever help ? mahmoud ehab give n string s1 s2 ... sn number 1 n q query query one follow form : ( r - l + 1 ) * lcp ( sl sl + 1 ... sr - 1 sr ) lcp ( str1 str2 str3 ... ) length longest common prefix string str1 str2 str3 ... first line input contain 2 integers n q ( 1 ≤ n ≤ 105 1 ≤ q ≤ 105 ) – number string number query respectively second line contain n string <unknown> consist lowercase english letter next q line describe query may one 2 form : total length string input wo n't exceed <unknown> query first type output answer a new line,"['data structures', 'strings']",2900.0
1251/A,recently polycarp notice button keyboard malfunction simplicity assume polycarp 's keyboard contain $$$ 26 $$$ button ( one letter latin alphabet ) button either work fine malfunction check button need replacement polycarp press button sequence a string $$$ s $$$ appear screen polycarp press a button character $$$ c $$$ one follow events happen : example suppose button correspond character a c work correctly button correspond b malfunction polycarp press button order a b a c a b a string type change follow : a $$$ \rightarrow $$$ abb $$$ \rightarrow $$$ abba $$$ \rightarrow $$$ <unknown> $$$ \rightarrow $$$ <unknown> $$$ \rightarrow $$$ <unknown> $$$ \rightarrow $$$ <unknown> give a string $$$ s $$$ appear screen polycarp press button help polycarp determine button work correctly sure ( string could appear screen button malfunction ) may assume button n't start malfunction polycarp type string : button either work correctly throughout whole process malfunction throughout whole process first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case input test case follow test case represent one line contain a string $$$ s $$$ consist less $$$ 1 $$$ $$$ 500 $$$ lowercase latin letter test case print one line contain a string $$$ res $$$ string $$$ res $$$ contain character correspond button work correctly alphabetical order without separators <unknown> button may malfunction $$$ res $$$ empty,"['brute force', 'strings']",1000.0
1151/A,today scientific lyceum kingdom <unknown> a biology lesson topic lesson <unknown> let 's call genome string ` ` actg '' maxim bore sit class teacher come a task : a give string $$$ s $$$ consist uppercase letter length least $$$ 4 $$$ need find minimum number operations need apply genome appear a substring one operation replace letter string $$$ s $$$ next previous alphabet example letter ` ` d '' previous one ` ` c '' next — ` ` e '' problem assume letter ` ` a '' previous one letter ` ` z '' next one ` ` b '' letter ` ` z '' previous one letter ` ` y '' next one letter ` ` a '' help maxim solve problem teacher give a string $$$ a $$$ a substring a string $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end first line contain a single integer $$$ n $$$ ( $$$ 4 \leq n \leq 50 $$$ ) — length string $$$ s $$$ second line contain string $$$ s $$$ consist exactly $$$ n $$$ uppercase letter latin alphabet output minimum number operations need apply string $$$ s $$$ genome appear a substring first example replace letter ` ` z '' ` ` a '' one operation letter ` ` h '' — letter ` ` g '' one operation get string ` ` actg '' genome present a substring second example replace letter ` ` a '' ` ` c '' two operations letter ` ` d '' — letter ` ` a '' three operations get string ` ` <unknown> '' a genome,"['brute force', 'strings']",1000.0
1056/H,successfully find poor arkady near exit station ' ve perfectly predict send home a taxi suddenly come a question $$$ n $$$ crossroads city several bidirectional roads connect a taxi ride a path crossroads another one without pass crossroads twice a collection rid make one driver wonder driver a robot definitely a human think driver a robot every two crossroads $$$ a $$$ $$$ b $$$ driver always choose path whenever drive $$$ a $$$ $$$ b $$$ note $$$ a $$$ $$$ b $$$ endpoints a ride path $$$ b $$$ $$$ a $$$ different contrary driver ever drive two different paths $$$ a $$$ $$$ b $$$ definitely a human give system roads description rid available determine driver a robot test contain one test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 300000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) — number crossroads city next line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 300000 $$$ ) — number rid available follow $$$ q $$$ line start a single integer $$$ k $$$ ( $$$ 2 \le k \le n $$$ ) — number crossroads visit driver ride follow $$$ k $$$ integers $$$ c_1 $$$ $$$ c_2 $$$ ... $$$ c_k $$$ ( $$$ 1 \le c_i \le n $$$ ) — crossroads order driver visit guarantee crossroads one ride distinct guarantee sum value $$$ k $$$ among rid test case exceed $$$ 300000 $$$ guarantee sum value $$$ n $$$ sum value $$$ q $$$ n't exceed $$$ 300000 $$$ among test case output a single line test case driver a robot output ` ` robot '' a single line otherwise output ` ` human '' print letter case ( upper lower ) first example clear driver use two different ways get crossroads $$$ 1 $$$ crossroads $$$ 3 $$$ must a human second example driver always drive cycle $$$ 1 \to 2 \to 3 \to 4 \to 1 $$$ reach destination,"['data structures', 'strings']",3200.0
1324/B,give array $$$ a $$$ consist $$$ n $$$ integers task determine $$$ a $$$ subsequence length least $$$ 3 $$$ a palindrome recall array $$$ b $$$ call a subsequence array $$$ a $$$ $$$ b $$$ obtain remove ( possibly zero ) elements $$$ a $$$ ( necessarily consecutive ) without change order remain elements example $$$ [ 2 ] $$$ $$$ [ 1 2 1 3 ] $$$ $$$ [ 2 3 ] $$$ subsequences $$$ [ 1 2 1 3 ] $$$ $$$ [ 1 1 2 ] $$$ $$$ [ 4 ] $$$ also recall a palindrome array read backward forward word array $$$ a $$$ length $$$ n $$$ palindrome $$$ a_i = a _ { n - i - 1 } $$$ $$$ i $$$ $$$ 1 $$$ $$$ n $$$ example array $$$ [ 1234 ] $$$ $$$ [ 1 2 1 ] $$$ $$$ [ 1 3 2 2 3 1 ] $$$ $$$ [ 10 100 10 ] $$$ palindromes array $$$ [ 1 2 ] $$$ $$$ [ 1 2 3 1 ] $$$ answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case next $$$ 2 t $$$ line describe test case first line test case contain one integer $$$ n $$$ ( $$$ 3 \le n \le 5000 $$$ ) — length $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ ( $$$ \sum n \le 5000 $$$ ) test case print answer — ` ` yes '' ( without quote ) $$$ a $$$ subsequence length least $$$ 3 $$$ a palindrome ` ` '' otherwise first test case example array $$$ a $$$ a subsequence $$$ [ 1 2 1 ] $$$ a palindrome second test case example array $$$ a $$$ two subsequences length $$$ 3 $$$ palindromes : $$$ [ 2 3 2 ] $$$ $$$ [ 2 2 2 ] $$$ third test case example array $$$ a $$$ subsequences length least $$$ 3 $$$ palindromes fourth test case example array $$$ a $$$ one subsequence length $$$ 4 $$$ a palindrome : $$$ [ 1 2 2 1 ] $$$ ( two subsequences length $$$ 3 $$$ palindromes : $$$ [ 1 2 1 ] $$$ ) fifth test case example array $$$ a $$$ subsequences length least $$$ 3 $$$ palindromes,"['brute force', 'strings']",1100.0
1820/A,hold one team contest boy yura get tire want change life move <unknown> honor a change yura change name something nice fascinate idea already think a name $$$ s $$$ consist character ` ` _ '' ` ` ^ '' 's a problem — yura like smiley face ` ` ^_^ '' ` ` ^^ '' therefore character name must a part least one smiley note consecutive character name a smiley face formally consider occurrences string ` ` ^_^ '' ` ` ^^ '' string $$$ s $$$ occurrences must cover whole string $$$ s $$$ possibly intersections example string ` ` <unknown> '' character position $$$ <unknown> $$$ $$$ 11 $$$ contain inside smileys character position $$$ <unknown> $$$ $$$ 8 $$$ contain inside smileys one operation <unknown> insert one character ` ` _ '' ` ` ^ '' name $$$ s $$$ ( insert position string ) ask tell minimum number operations need make name fit yura 's criteria test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — the number test case description test case follow first line test case contain a single string $$$ s $$$ ( $$$ 1 \leq |s| \leq 100 $$$ ) consist character ` ` _ '' ` ` ^ '' — name change test case output a single integer — minimum number character need add name make fit yura n't need change anything name print $$$ 0 $$$ first test case get follow name add $$$ 5 $$$ character : <unknown> third test case add one character ` ` ^ '' end name get name : <unknown> fourth test case add one character ` ` ^ '' end name get name : <unknown> fifth test case character already contain smiley face answer $$$ 0 $$$ <unknown> test case add one character ` ` ^ '' begin name one character ` ` ^ '' end name get name : ^_^,"['implementation', 'strings']",800.0
616/A,give two long integers a b ( lead zero allow ) check number a b greater determine equal input size large n't use read symbols one one instead use read a whole line token input / output reach huge size recommend use fast input / output methods : example prefer use scanf / printf instead cin / cout c++ prefer use bufferedreader / printwriter instead scanner / system.out java n't use function input ( ) <unknown> instead use function <unknown> ( ) first line contain a non - negative integer a. second line contain a non - negative integer b. number a b may contain lead zero contain 106 digits print symbol ` ` < ` ` a < b symbol ` ` > '' a > b. number equal print symbol ` ` = '',"['implementation', 'strings']",900.0
1147/B,"inaka a disc circumference $$$ n $$$ units circumference equally divide $$$ n $$$ point number clockwise $$$ 1 $$$ $$$ n $$$ point $$$ i $$$ $$$ i + 1 $$$ ( $$$ 1 \leq i < n $$$ ) adjacent point $$$ n $$$ $$$ 1 $$$ $$$ m $$$ straight segment disc endpoints among aforementioned $$$ n $$$ point inaka want know image rotationally symmetrical i.e integer $$$ k $$$ ( $$$ 1 \leq k < n $$$ ) segment rotate clockwise around center circle $$$ k $$$ units new image original one first line contain two space - separated integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 100\,000 $$$ $$$ 1 \leq m \leq 200\,000 $$$ ) — number point number segment respectively $$$ i $$$ -th follow $$$ m $$$ line contain two space - separated integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a_i b_i \leq n $$$ $$$ a_i \neq b_i $$$ ) describe a segment connect point $$$ a_i $$$ $$$ b_i $$$ guarantee segment coincide output one line — ` ` yes '' image rotationally symmetrical ` ` '' otherwise ( exclude quotation mark ) output letter case ( upper lower ) first two examples illustrate image become respective original ones a clockwise rotation $$$ 120 $$$ degrees around center","['brute force', 'strings']",1900.0
832/B,'s hard time today petya need score 100 point informatics exam task seem easy petya think lack time finish ask help one .. a <unknown> pattern statements ( a string consist lowercase english letter character ` ` ? '' ` ` * '' ) know character ` ` * '' occur pattern also n query string give require determine pattern match everything seem easy petya discover special pattern character differ usual mean a pattern match a string possible replace character ` ` ? '' one good lowercase english letter character ` ` * '' ( one ) include empty string bad lowercase english letter result string give string good letter give petya others bad first line contain a string length 1 26 consist distinct lowercase english letter letter good letter others bad second line contain pattern — a string s lowercase english letter character ` ` ? '' ` ` * '' ( 1 ≤ |s| ≤ 105 ) guarantee character ` ` * '' occur s third line contain integer n ( 1 ≤ n ≤ 105 ) — number query <unknown> line follow contain single non - empty string consist lowercase english letter — a query string guarantee total length query string greater 105 . print n line : i - th print ` ` yes '' pattern match i - th query string ` ` '' otherwise choose case ( lower upper ) letter arbitrary first example replace ` ` ? '' good letter ` ` a '' ` ` b '' see answer first query ` ` yes '' answer second query ` ` '' ca n't match third letter explanation second example,"['implementation', 'strings']",1600.0
150/D,"market <unknown> long - <unknown> game <unknown> <unknown> v : nvodsk game turn difficult <unknown> students ca n't complete last quest ( ` ` n't go nvodsk ... '' ) threaten winter exams <unknown> already start wonder whether <unknown> winter exams till april ( fact want complete quest ) a sudden a stranger appear door office ` ` good <unknown> name chuck i solve problems '' — say sit side side still ca n't complete mission thing kill final boss one prove one 's perfect skills art manage letter one a real magician imagine happen <unknown> start compete ... let 's put formally : give a string a set integers ai allow choose substring a palindrome delete receive number point equal ak k length delete palindrome k ak = -1 mean delete palindrome string length forbid a substring delete remain part ` ` shift together '' , moment time string gap process repeat string least one palindrome substring delete gain point sum determine maximum number point earn ` ` oh '' — say chuck raise <unknown> — ` ` i use love delete palindromes like one day i take arrow <unknown> '' first line contain integer l ( 1 ≤ l ≤ 150 ) — length string second line contain exactly l integers ak ( - 1 ≤ ak ≤ 105 ) — point a player gain delete third line contain exactly l lowercase latin letter — original string a player delete palindromes line contain character apart newline character end string print a single number — maximum number point one gain play give string first sample delete substring best result 0 . second sample allow delete palindromes whose length equal 1 thus delete whole string get 7 point third sample optimal strategy : first delete character c string aa bb last one aa get 1 + 3 * 5 = 16 point","['dp', 'strings']",2600.0
1833/A,"vlad decide compose a melody guitar let 's represent melody a sequence note correspond character ' a ' ' b ' ' c ' 'd ' ' e ' ' f ' ' g ' however vlad experience play guitar record exactly two note a time vlad want obtain melody $$$ s $$$ , merge record melodies together case last sound first melody must match first sound second melody example vlad record melodies ` ` ab '' ` ` ba '' merge together obtain melody ` ` aba '' merge result ` ` ab '' get ` ` abab '' help vlad determine minimum number melodies consist two note need record order obtain melody $$$ s $$$ first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case follow descriptions test case first line test case contain integer $$$ n $$$ ( $$$ 2 \le n \le 50 $$$ ) — length melody $$$ s $$$ second line test case contain a string $$$ s $$$ length $$$ n $$$ consist character ' a ' ' b ' ' c ' 'd ' ' e ' ' f ' ' g ' output $$$ t $$$ integers represent answer correspond test case answer output minimum number melodies consist two note vlad need record first sample need record melodies ` ` ab '' ` ` ba '' describe problem statement second sample need record melodies ` ` ab '' ` ` ba '' ` ` ac '' ` ` ca '' third sample necessary melody ` ` aa ''","['implementation', 'strings']",800.0
1840/A,a string $$$ a $$$ ( unknown ) consist lowercase latin letter encrypt accord follow rule string $$$ s $$$ : give string $$$ s $$$ need output initial string $$$ a $$$ word need decrypt string $$$ s $$$ note string encrypt way decrypt uniquely first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case descriptions test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — length encrypt message second line test case contain a string $$$ s $$$ length $$$ n $$$ — encrypt message obtain string $$$ a $$$ test case output decrypt message $$$ a $$$ a separate line first encrypt message letter $$$ a $$$ encrypt $$$ aba $$$ letter $$$ c $$$ encrypt $$$ <unknown> $$$ second encrypt message one letter $$$ q $$$ encrypt $$$ <unknown> $$$ third encrypt message zero character add letter,"['implementation', 'strings']",800.0
591/B,name one small proud corporation consist n lowercase english letter corporation decide try rebranding — active market strategy include a set measure change either brand ( company goods produce ) components : name <unknown> slogan decide start name purpose corporation consecutively hire m designers a company hire i - th designer immediately <unknown> creation a new corporation name follow : take newest version name replace letter xi yi letter yi xi result new version possible letter occur string may also happen xi coincide yi version name receive work last designer become new name corporation manager arkady recently get a job company already <unknown> spirit <unknown> worry success rebranding naturally ca n't wait find new name corporation receive satisfy arkady 's curiosity tell final version name first line input contain two integers n m ( 1 ≤ n m ≤ 200 000 ) — length initial name number designers hire respectively second line consist n lowercase english letter represent original name corporation next m line contain descriptions designers ' action : i - th contain two space - separated lowercase english letter xi yi print new name corporation second sample name corporation consecutively change follow :,"['implementation', 'strings']",1200.0
1829/A,timur love codeforces 's a string $$$ s $$$ length $$$ 10 $$$ make contain lowercase latin letter timur want know many indices string $$$ s $$$ differ string ` ` codeforces '' example string $$$ s = $$$ ` ` <unknown> '' differ ` ` codeforces '' $$$ 4 $$$ indices show bold help timur find number indices string $$$ s $$$ differ ` ` codeforces '' note ca n't reorder character string $$$ s $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case test case one line contain string $$$ s $$$ consist exactly $$$ 10 $$$ lowercase latin character test case output a single integer — number indices string $$$ s $$$ differ,"['implementation', 'strings']",800.0
598/B,give a string s process m query query describe two 1 - based indices li ri integer ki mean cyclically shift substring s [ li ... ri ] ki time query process one another order give one operation a cyclic shift ( rotation ) equivalent move last character position first character shift character one position right example string s abacaba query l1 = 3 r1 = 6 k1 = 1 answer <unknown> would process query l2 = 1 r2 = 4 k2 = 2 would get string <unknown> first line input contain string s ( 1 ≤ |s| ≤ 10 000 ) initial state |s| stand length s. contain lowercase english letter second line contain a single integer m ( 1 ≤ m ≤ 300 ) — number query i - th next m line contain three integers li ri ki ( 1 ≤ li ≤ ri ≤ |s| 1 ≤ ki ≤ 1 000 000 ) — description i - th query print result string s process m query sample describe problem statement,"['implementation', 'strings']",1300.0
600/A,"give string s. let 's call word largest sequence consecutive symbols without symbols ' ' ( <unknown> ) ' ; ' ( <unknown> ) example four word string ` ` aba,123 ; 1a ; 0 '' : ` ` aba '' ` ` 123 '' ` ` 1a '' ` ` 0 '' a word empty : example string s= '' ; ; '' contain three empty word separate ' ; ' find word give string nonnegative integer number without lead zero build new string a. string a contain word number separate ' ' ( order number remain string s ) word build string b way ( order number remain string s ) string ` ` 101 '' ` ` 0 '' integer number ` ` 01 '' ` ` 1.0 '' example string aba,123 ; 1a ; 0 string a would equal ` ` <unknown> '' string b would equal ` ` <unknown> '' line input contain string s ( 1 ≤ |s| ≤ 105 ) string contain symbols ' . ' ( ascii <unknown> ) ' ' ( ascii <unknown> ) ' ; ' ( ascii 59 ) digits lowercase uppercase latin letter print string a first line string b second line string surround quote ( ascii 34 ) word number print dash ( ascii <unknown> ) first line word number print dash second line second example string s contain five word : ` ` 1 '' ` ` '' ` ` 01 '' ` ` <unknown> '' ` ` ''","['implementation', 'strings']",1600.0
1120/C,suppose give a string $$$ s $$$ length $$$ n $$$ consist lowercase english letter need compress use smallest possible number coin compress string represent $$$ s $$$ a concatenation several non - empty string : $$$ s = t _ { 1 } t _ { 2 } \ldots t _ { k } $$$ $$$ i $$$ -th string encode one two ways : a string $$$ x $$$ a substring a string $$$ y $$$ $$$ x $$$ obtain $$$ y $$$ deletion several ( possibly zero ) character begin several ( possibly zero ) character end task calculate minimum possible number coin need spend order compress give string $$$ s $$$ first line contain three positive integers separate space : $$$ n $$$ $$$ a $$$ $$$ b $$$ ( $$$ 1 \leq n a b \leq 5000 $$$ ) — length string cost compress a one - character string cost compress a string appear second line contain a single string $$$ s $$$ consist $$$ n $$$ lowercase english letter output a single integer — smallest possible number coin need spend compress $$$ s $$$ first sample case set $$$ t _ { 1 } = $$$ ' a ' $$$ t _ { 2 } = $$$ ' b ' $$$ t _ { 3 } = $$$ ' a ' pay $$$ 3 + 3 + 1 = 7 $$$ coin since $$$ t _ { 3 } $$$ a substring $$$ t _ { 1 } t _ { 2 } $$$ second sample need compress every character third sample set $$$ t _ { 1 } = t _ { 2 } = $$$ ' a ' $$$ t _ { 3 } = $$$ ' aa ' pay $$$ 10 + 1 + 1 = 12 $$$ coin since $$$ t _ { 2 } $$$ a substring $$$ t _ { 1 } $$$ $$$ t _ { 3 } $$$ a substring $$$ t _ { 1 } t _ { 2 } $$$,"['dp', 'strings']",2100.0
723/B,modern text editors usually show information regard <unknown> edit example number word number page number character problem implement similar functionality give a string consist : guarantee open parenthesis a succeed close parenthesis similarly close parentheses a precede open parentheses match pair match parentheses parenthesis word parenthesis string belong a match ` ` <unknown> - <unknown> '' pair pair ca n't nest example follow string valid : ` ` _ <unknown> ( <unknown> ) _ _ bye _ ( <unknown> ) '' word a maximal sequence consecutive letter i.e sequence first character leave first character right underscore a parenthesis exist example string consist seven word : ` ` hello '' ` ` vasya '' ` ` '' ` ` petya '' ` ` bye '' ` ` '' ` ` ok '' write a program find : first line input contain a single integer n ( 1 ≤ n ≤ 255 ) — length give string second line contain string consist lowercase uppercase english letter parentheses underscore symbols print two space - separated integers : first sample word ` ` hello '' ` ` vasya '' ` ` bye '' outside parentheses word ` ` '' ` ` petya '' ` ` '' ` ` ok '' inside note word ` ` '' give twice count twice answer,"['implementation', 'strings']",1100.0
1183/H,difference easy hard versions constraints a subsequence a string derive another string delete symbols without change order remain symbols character delete require go successively gap example string ` ` abaca '' follow string subsequences : ` ` abaca '' ` ` aba '' ` ` aaa '' ` ` a '' ` ` '' ( empty string ) follow string subsequences : ` ` <unknown> '' ` ` cb '' ` ` <unknown> '' give a string $$$ s $$$ consist $$$ n $$$ lowercase latin letter one move take subsequence $$$ t $$$ give string add set $$$ s $$$ set $$$ s $$$ ca n't contain duplicate move cost $$$ n - |t| $$$ $$$ |t| $$$ length add subsequence ( i.e price equal number delete character ) task find minimum possible total cost obtain a set $$$ s $$$ size $$$ k $$$ report impossible first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100 1 \le k \le 10^ { 12 } $$$ ) — length string size set correspondingly second line input contain a string $$$ s $$$ consist $$$ n $$$ lowercase latin letter print one integer — impossible obtain set $$$ s $$$ size $$$ k $$$ print -1 . otherwise print minimum possible total cost first example generate $$$ s $$$ = { ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' } cost first element $$$ s $$$ $$$ 0 $$$ cost others $$$ 1 $$$ total cost $$$ s $$$ $$$ 4 $$$,"['dp', 'strings']",1900.0
1163/D,a normal walk forest katie stumble upon a mysterious code ! however mysterious code character unreadable write code a string $$$ c $$$ consist lowercase english character asterisk ( ` ` * '' ) asterisk denote unreadable character excite <unknown> katie decide recover unreadable character replace asterisk arbitrary lowercase english letter ( different asterisk might replace different letter ) katie a favorite string $$$ s $$$ a <unknown> - so - favorite string $$$ t $$$ would love recover mysterious code many occurrences $$$ s $$$ possible little occurrences $$$ t $$$ possible formally let 's denote $$$ f ( x y ) $$$ number occurrences $$$ y $$$ $$$ x $$$ ( example $$$ f ( <unknown> ab ) = 2 $$$ ) katie want recover code $$$ c ' $$$ conform original $$$ c $$$ $$$ f ( c ' s ) - f ( c ' t ) $$$ largest possible however katie good recover cod general would like help first line contain string $$$ c $$$ ( $$$ 1 \leq |c| \leq 1000 $$$ ) — mysterious code guarantee $$$ c $$$ consist lowercase english character asterisk ` ` * '' second third line contain string $$$ s $$$ $$$ t $$$ respectively ( $$$ 1 \leq |s| |t| \leq 50 $$$ $$$ s \neq t $$$ ) guarantee $$$ s $$$ $$$ t $$$ consist lowercase english character print a single integer — largest possible value $$$ f ( c ' s ) - f ( c ' t ) $$$ recover code first example $$$ c ' $$$ equal ` ` katie '' $$$ f ( c ' s ) = 1 $$$ $$$ f ( c ' t ) = 0 $$$ make $$$ f ( c ' s ) - f ( c ' t ) = 1 $$$ largest possible second example $$$ c ' $$$ conform give $$$ c $$$ ` ` <unknown> '' correspond $$$ f ( c ' s ) - f ( c ' t ) = 1 - 2 = -1 $$$ third example multiple ways recover code $$$ f ( c ' s ) - f ( c ' t ) $$$ largest possible example ` ` aaa '' ` ` <unknown> '' even ` ` <unknown> '' value $$$ f ( c ' s ) - f ( c ' t ) = 0 $$$ recover cod fourth example optimal recover code $$$ c ' $$$ would ` ` <unknown> '' correspond $$$ f ( c ' s ) - f ( c ' t ) = 2 $$$,"['dp', 'strings']",2100.0
949/C,bigdata inc . a corporation n data center index 1 n locate world data center provide storage client data ( figure client data really big ! ) main feature service offer bigdata inc . access <unknown> guarantee even circumstances data center <unknown> a guarantee ensure use two - way replication two - way replication approach data storage piece data represent two identical copy store two different data center m company clients let us denote indices two different data center store client data ci 1 ci 2 . order keep data center <unknown> safe software run data center computers update regularly release cycle bigdata inc . one day mean new version software deploy data center computers day data center software update a non - <unknown> long process a special hour - long time frame dedicate data center maintenance maintenance period data center computers instal software update thus may unavailable consider day exactly h hours long data center integer uj ( 0 ≤ uj ≤ h - 1 ) define index hour day hour data center j unavailable due maintenance sum everything condition uci 1 ≠ uci 2 hold client otherwise data may <unknown> data center store maintenance due <unknown> <unknown> change different cities world maintenance time data center may change one hour sometimes company prepare situation decide conduct experiment choose non - empty subset data center shift maintenance time hour later ( i.e uj = h - 1 new maintenance hour would become 0 otherwise would become uj + 1 ) <unknown> experiment break accessibility guarantee mean data client still available hour a day data center maintenance time change experiment would provide useful <unknown> change update time quite expensive procedure company ask find minimum number data center include experiment order keep data accessibility guarantee first line input contain three integers n m h ( 2 ≤ n ≤ 100 000 1 ≤ m ≤ 100 000 2 ≤ h ≤ 100 000 ) number company data center number clients day length day measure hours second line input contain n integers u1 u2 ... un ( 0 ≤ uj < h ) j - th number index a maintenance hour data center j. next m line contain two integers ci 1 ci 2 ( 1 ≤ ci 1 ci 2 ≤ n ci 1 ≠ ci 2 ) define data center indices contain data client i. guarantee give maintenance schedule allow client access least one copy data moment day first line print minimum possible number data center k ( 1 ≤ k ≤ n ) include experiment order keep data available client second line print k distinct integers x1 x2 ... xk ( 1 ≤ xi ≤ n ) indices data center whose maintenance time shift one hour later data center indices may print order several possible answer allow print guarantee least one valid choice data center consider first sample test give answer way conduct experiment involve data center a scenario third data center a maintenance hour 1 two data center store information client maintenance hour hand example shift maintenance time hour later first data center data clients 1 3 unavailable hour 0,['dfs and similar'],1900.0
954/D,little town nsk consist n junctions connect m bidirectional roads road connect two distinct junctions two roads connect pair junctions possible get junction junction roads distance two junctions equal minimum possible number roads a path order improve transportation system city council ask mayor build one new road problem mayor buy a wonderful new car really enjoy a ride home locate near junction s work locate near junction t. thus want build a new road a way distance two junctions wo n't decrease assign a task compute number pair junctions connect road new road two junctions build distance s t wo n't decrease <unknown> line input contain integers n m s t ( 2 ≤ n ≤ 1000 1 ≤ m ≤ 1000 1 ≤ s t ≤ n s ≠ t ) — number junctions number roads nsk well indices junctions <unknown> home work locate respectively i - th follow m line contain two integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) mean road connect junctions ui vi directly guarantee a path two junctions two roads connect pair junctions print one integer — number pair junctions connect a direct road build a road two junctions wo n't decrease distance junctions s t,['dfs and similar'],1600.0
962/F,"give undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge graph necessarily connect guarantee graph contain multiple edge ( one edge a pair vertices ) loop ( edge a vertex ) a cycle a graph call a simple contain vertex exactly simple cycle n't allow visit a vertex a cycle determine edge belong exactly one simple cycle first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 1 \le n \le 100\,000 $$$ $$$ 0 \le m \le \min ( n \cdot ( n - 1 ) / 2 100\,000 ) ) $$$ — number vertices number edge follow $$$ m $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \neq v $$$ ) — description edge first line print number edge belong exactly one simple cycle second line print indices edge belong exactly one simple cycle increase order edge number one order give input",['dfs and similar'],2400.0
883/G,vasya a graph contain direct ( orient ) undirected ( non - oriented ) edge multiple edge a pair vertices vasya pick a vertex s graph vasya want create two separate plan : two plan undirected edge must become direct edge choose directions differ two plan help vasya find plan first line contain three integers n m s ( 2 ≤ n ≤ 3·105 1 ≤ m ≤ 3·105 1 ≤ s ≤ n ) — number vertices edge graph vertex vasya pick follow m line contain information graph edge line contain three integers ti ui vi ( 1 ≤ ti ≤ 2 1 ≤ ui vi ≤ n ui ≠ vi ) — edge type vertices connect edge ti = 1 edge direct go vertex ui vertex vi ti = 2 edge undirected connect vertices ui vi guarantee least one undirected edge graph first two line describe plan maximize number reachable vertices line three four describe plan minimize number reachable vertices a description plan start a line contain number reachable vertices second line a plan consist f symbols ' + ' ' - ' f number undirected edge initial graph print ' + ' j - th symbol string j - th undirected edge ( u v ) input orient u v. print ' - ' <unknown> opposite direction ( v u ) consider undirected edge number order give input multiple solutions print,['dfs and similar'],1900.0
977/E,give undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge task find number connect components cycle definitions graph theory undirected graph consist two set : set nod ( call vertices ) set edge edge connect a pair vertices edge bidirectional ( i.e a vertex $$$ a $$$ connect a vertex $$$ b $$$ a vertex $$$ b $$$ also connect a vertex $$$ a $$$ ) edge ca n't connect vertex one edge a pair vertices two vertices $$$ u $$$ $$$ v $$$ belong connect component least one path along edge connect $$$ u $$$ $$$ v $$$ a connect component a cycle vertices reorder a way : a cycle n't contain edge except describe definition cycle contain three vertices first line contain two integer number $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 0 \le m \le 200000 $$$ ) — number vertices edge follow $$$ m $$$ line contain edge : edge $$$ i $$$ give a pair vertices $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ $$$ u_i \ne v_i $$$ ) multiple edge give graph i.e pair ( $$$ v_i u_i $$$ ) pair ( $$$ v_i u_i $$$ ) ( $$$ u_i v_i $$$ ) list edge print one integer — number connect components also cycle first example component $$$ [ 3 4 5 ] $$$ also a cycle illustration correspond second example,['dfs and similar'],1500.0
982/F,petr a <unknown> braginsk somebody steal a huge amount money a bank petr catch somebody tell petr <unknown> car move along roads without stop petr know robbers drive car roads braginsk one - directional connect two intersections petr want select one intersection robbers continue drive roads indefinitely sooner later come intersection initial position robbers unknown find intersection fit requirements first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \le 100000 $$$ $$$ 2 \leq m \leq 500000 $$$ ) — number intersections number direct roads braginsk respectively next $$$ m $$$ line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) — start finish $$$ i $$$ -th direct road guarantee robbers move along roads indefinitely print a single integer $$$ k $$$ — intersection petr need choose multiple answer print intersections print $$$ -1 $$$ first example robbers move example along follow rout : $$$ ( 1 - 2 - 3 - 1 ) $$$ $$$ ( 3 - 4 - 5 - 3 ) $$$ $$$ ( 1 - 2 - 3 - 4 - 5 - 3 - 1 ) $$$ show petr choose $$$ 3 $$$ -rd intersection eventually meet robbers independently route,['dfs and similar'],2700.0
1000/E,friend develop a computer game already decide game world look like — consist $$$ n $$$ locations connect $$$ m $$$ two - way passages passages design a way possible get location location course passages guard monsters ( go everywhere without difficulties 's fun right ? ) crucial passages guard really <unknown> monsters require hero prepare battle design tactics defeat ( <unknown> kinds monsters call boss ) friend want help place boss game start location $$$ s $$$ end location $$$ t $$$ locations choose yet choose locations friend place a boss passage impossible get $$$ s $$$ $$$ t $$$ without use passage friend want place much boss possible ( challenge mean fun right ? ) ask help determine maximum possible number boss consider location choose $$$ s $$$ $$$ t $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 300000 $$$ $$$ n - 1 \le m \le 300000 $$$ ) — number locations passages respectively $$$ m $$$ line follow contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ $$$ x \ne y $$$ ) describe endpoints one passages guarantee pair locations directly connect two passages location reachable location print one integer — maximum number boss friend place consider possible choices $$$ s $$$ $$$ t $$$,['dfs and similar'],2100.0
1006/E,"problem help berland army organize command delivery system $$$ n $$$ officer berland army first officer commander army superiors every officer exactly one direct superior officer $$$ a $$$ direct superior officer $$$ b $$$ also say officer $$$ b $$$ a direct subordinate officer $$$ a $$$ officer $$$ x $$$ consider a subordinate ( direct indirect ) officer $$$ y $$$ one follow condition hold : example picture subordinate officer $$$ 3 $$$ : $$$ 5 6 7 8 9 $$$ structure berland army organize a way every officer except commander a subordinate commander army formally let 's represent berland army a tree consist $$$ n $$$ vertices vertex $$$ u $$$ correspond officer $$$ u $$$ parent vertex $$$ u $$$ correspond direct superior officer $$$ u $$$ root ( index $$$ 1 $$$ ) correspond commander army berland war ministry order give answer $$$ q $$$ query $$$ i $$$ -th query give $$$ ( u_i k_i ) $$$ $$$ u_i $$$ officer $$$ k_i $$$ a positive integer process $$$ i $$$ -th query imagine a command $$$ u_i $$$ spread subordinate $$$ u_i $$$ <unknown> <unknown> ( depth first search ) algorithm use suppose current officer $$$ a $$$ spread a command officer $$$ a $$$ choose $$$ b $$$ — one direct subordinate ( i.e a child tree ) receive command yet many direct subordinate $$$ a $$$ choose one minimal index officer $$$ a $$$ give a command officer $$$ b $$$ afterwards $$$ b $$$ use exactly algorithm spread command subtree $$$ b $$$ finish spread command officer $$$ a $$$ choose next direct subordinate ( use strategy ) officer $$$ a $$$ choose direct subordinate still n't receive command officer $$$ a $$$ finish spread command let 's look follow example : officer $$$ 1 $$$ spread a command officer receive follow order : $$$ [ 1 2 3 5 , 6 8 7 9 4 ] $$$ officer $$$ 3 $$$ spread a command officer receive follow order : $$$ [ 3 5 6 8 7 9 ] $$$ officer $$$ 7 $$$ spread a command officer receive follow order : $$$ [ 7 9 ] $$$ officer $$$ 9 $$$ spread a command officer receive follow order : $$$ [ 9 ] $$$ answer $$$ i $$$ -th query $$$ ( u_i k_i ) $$$ construct a sequence describe order officer receive command $$$ u_i $$$ -th officer spread return $$$ k_i $$$ -th element construct list -1 fewer $$$ k_i $$$ elements process query independently a query n't affect follow query first line input contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \le n \le 2 \cdot 100000 1 \le q \le 200000 $$$ ) — number officer berland army number query second line input contain $$$ n - 1 $$$ integers $$$ p_2 p_3 \dots p_n $$$ ( $$$ 1 \le p_i < i $$$ ) $$$ p_i $$$ index direct superior officer index $$$ i $$$ commander index $$$ 1 $$$ n't superiors next $$$ q $$$ line describe query $$$ i $$$ -th query give a pair ( $$$ u_i k_i $$$ ) ( $$$ 1 \le u_i k_i \le n $$$ ) $$$ u_i $$$ index officer start spread a command $$$ k_i $$$ index require officer command spread sequence print $$$ q $$$ number $$$ i $$$ -th number officer position $$$ k_i $$$ list describe order officer receive command start spread officer $$$ u_i $$$ print ` ` -1 '' number officer receive command less $$$ k_i $$$ process query independently affect",['dfs and similar'],1600.0
1023/F,manage a mobile phone network want offer competitive price connect a network network $$$ n $$$ nod competitor already offer connections nod fix price connections bidirectional initially $$$ m $$$ connections competitor offer $$$ i $$$ -th connection competitor offer connect nod $$$ fa_i $$$ $$$ fb_i $$$ cost $$$ fw_i $$$ a list $$$ k $$$ connections want offer guarantee set connection form cycle $$$ j $$$ -th connections connect nod $$$ <unknown> $$$ $$$ <unknown> $$$ connections also bidirectional cost connections decide yet set price connections arbitrary integer value price set independently connection set price customer choose $$$ n - 1 $$$ connections nod connect a single network total cost choose connections minimum possible multiple ways choose network customer choose arbitrary one also maximize number connections want set price a way $$$ k $$$ connections choose customer sum price connections maximize print maximum profit achieve $$$ -1 $$$ unbounded first line input contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \leq n k m \leq 5 \cdot 100000 k \leq n-1 $$$ ) number nod number connections number competitor connections respectively next $$$ k $$$ line contain two integers $$$ ga_i $$$ $$$ gb_i $$$ ( $$$ 1 \leq ga_i gb_i \leq n $$$ $$$ ga_i \not= gb_i $$$ ) represent one connections nod $$$ ga_i $$$ $$$ gb_i $$$ set connections guarantee acyclic next $$$ m $$$ line contain three integers $$$ fa_i $$$ $$$ fb_i $$$ $$$ fw_i $$$ ( $$$ 1 \leq fa_i fb_i \leq n $$$ $$$ fa_i \not= fb_i $$$ $$$ 1 \leq fw_i \leq 1000000000 $$$ ) denote one competitor 's connections nod $$$ fa_i $$$ $$$ fb_i $$$ cost $$$ fw_i $$$ none connections connect a node pair connections connect pair nod addition connections give non - decreasing order cost ( $$$ <unknown> _ { i-1 } \leq fw_i $$$ valid $$$ i $$$ ) note may connections appear set competitor 's set ( though connection appear twice one set ) guarantee union connections competitor 's connections form a connect network print a single integer maximum possible profit achieve set price connections <unknown> profit unbounded print $$$ -1 $$$ first sample 's optimal give connection $$$ 1 - 3 $$$ cost $$$ 3 $$$ connection $$$ 1 - 2 $$$ cost $$$ 3 $$$ connection $$$ 3 - 4 $$$ cost $$$ 8 $$$ case cheapest connect network cost $$$ 14 $$$ customer choose one choose connections second sample long first connection cost $$$ 30 $$$ less customer choose connections matter cost second connection get unbounded profit case,['dfs and similar'],2600.0
1027/D,<unknown> faculty berland state university finish <unknown> campaign usual $$$ 80\ % $$$ <unknown> girls <unknown> go live university dormitory next $$$ 4 $$$ ( hopefully ) years dormitory consist $$$ n $$$ room a single mouse ! girls decide set mouse trap room get rid horrible monster set a trap room number $$$ i $$$ cost $$$ c_i $$$ burl room number $$$ 1 $$$ $$$ n $$$ mouse n't sit place time constantly run room $$$ i $$$ second $$$ t $$$ run room $$$ a_i $$$ second $$$ t + 1 $$$ without visit room <unknown> ( $$$ i = a_i $$$ mean mouse wo n't leave room $$$ i $$$ ) 's second $$$ 0 $$$ start mouse room a mouse trap mouse get catch trap would easy girls actually know mouse unfortunately 's case mouse room $$$ 1 $$$ $$$ n $$$ second $$$ 0 $$$ minimal total amount burl girls spend set trap order guarantee mouse eventually catch matter room start ? first line contain single integers $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number room dormitory second line contain $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \le c_i \le 10000 $$$ ) — $$$ c_i $$$ cost set trap room number $$$ i $$$ third line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — $$$ a_i $$$ room mouse run next second room $$$ i $$$ print a single integer — minimal total amount burl girls spend set trap order guarantee mouse eventually catch matter room start first example enough set mouse trap room $$$ 1 $$$ $$$ 4 $$$ mouse start room $$$ 1 $$$ get catch immideately mouse start room eventually come room $$$ 4 $$$ second example enough set mouse trap room $$$ 2 $$$ mouse start room $$$ 2 $$$ get catch immideately mouse start room run room $$$ 2 $$$ second $$$ 1 $$$ paths mouse different start third example : 's enough set trap room $$$ 2 $$$ $$$ 6 $$$,['dfs and similar'],1700.0
1093/D,give undirected unweighted graph consist $$$ n $$$ vertices $$$ m $$$ edge write a number vertex graph number $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ graph become beautiful edge sum number vertices connect edge odd calculate number possible ways write number $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ vertices graph become beautiful since number may large print modulo $$$ 998244353 $$$ note write exactly one number vertex graph self - loops multiple edge first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 300000 $$$ ) — number test input first line test contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 3 \cdot 100000 0 \le m \le 300000 $$$ ) — number vertices number edge respectively next $$$ m $$$ line describe edge : $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n ; u_i \neq v_i $$$ ) — indices vertices connect $$$ i $$$ -th edge guarantee $$$ \sum\limits _ { i=1 } ^ { t } n \le 300000 $$$ $$$ \sum\limits _ { i=1 } ^ { t } m \le 300000 $$$ test print one line contain one integer — number possible ways write number $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ vertices give graph become beautiful since answer may large print modulo $$$ 998244353 $$$ possible ways distribute number first test : second test way distribute number,['dfs and similar'],1700.0
1027/F,polycarp study berland state university soon take exam pass exactly $$$ n $$$ exams exam $$$ i $$$ know two days : $$$ a_i $$$ — day first opportunity pass exam $$$ b_i $$$ — day second opportunity pass exam ( $$$ a_i < b_i $$$ ) polycarp pass one exam day exam polycarp choose day pass exam pass $$$ n $$$ exams polycarp want pass exams soon possible print minimum index day polycarp pass $$$ n $$$ exams print -1 pass exams first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — number exams next $$$ n $$$ line contain two integers : $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i < b_i \le 1000000000 $$$ ) $$$ a_i $$$ number day first pass $$$ i $$$ -th exam $$$ b_i $$$ number day second pass $$$ i $$$ -th exam polycarp pass $$$ n $$$ exams print -1 . otherwise print minimum index day polycarp,['dfs and similar'],2400.0
1037/D,bfs algorithm define follow since order choose neighbor vertex vary turn may multiple sequence bfs print problem need check whether a give sequence correspond valid bfs traversal give tree start vertex $$$ 1 $$$ tree undirected graph exactly one simple path two vertices first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) denote number nod tree follow $$$ n - 1 $$$ line describe edge tree contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le n $$$ ) — endpoints correspond edge tree guarantee give graph a tree last line contain $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — sequence check print ` ` yes '' ( quote clarity ) sequence correspond valid bfs traversal give tree ` ` '' ( quote clarity ) otherwise print letter case ( upper lower ) sample test tree tree two valid bfs order : order $$$ 1 2 4 3 $$$ n't correspond valid bfs order,['dfs and similar'],1700.0
870/E,give n distinct point a plane integral coordinate point either draw a vertical line draw a horizontal line nothing consider several coincide straight line a single one many distinct picture get ? print answer modulo 109 + 7 . first line contain single integer n ( 1 ≤ n ≤ 105 ) — number <unknown> line follow ( i + 1 ) -th line contain two integers xi yi ( - 109 ≤ xi yi ≤ 109 ) — coordinate i - th point guarantee point distinct print number possible distinct picture modulo 109 + 7 . first example two vertical two horizontal line pass point get picture subset line example get picture contain four line two ways ( segment represent a line contain ) second example work two point independently number picture 32 = 9,['dfs and similar'],2300.0
862/B,mahmoud ehab continue <unknown> ! everybody evil land know dr . evil like bipartite graph especially tree a tree a connect acyclic graph a bipartite graph a graph whose vertices partition 2 set a way edge ( u v ) belong graph u v belong different set find formal definitions a tree a bipartite graph note section dr . evil give mahmoud ehab a tree consist n nod ask add edge a way graph still bipartite besides add edge graph simple ( n't contain loop multiple edge ) maximum number edge add ? a loop edge connect a node graph n't contain multiple edge pair nod one edge a cycle a loop n't first line input contain integer n — number nod tree ( 1 ≤ n ≤ 105 ) next n - 1 line contain integers u v ( 1 ≤ u v ≤ n u ≠ v ) — description edge tree 's guarantee give graph a tree output one integer — maximum number edge mahmoud ehab add tree fulfil condition tree definition : https : //en.wikipedia.org / wiki / tree _ ( <unknown> ) bipartite graph definition : https : //en.wikipedia.org / wiki / <unknown> first test case edge add a way graph wo n't contain loop multiple edge ( 2 3 ) add edge make graph non - bipartite answer 0 . second test case mahmoud ehab add edge ( 1 4 ) ( 2 5 ),['dfs and similar'],1300.0
732/F,berland a tourist country ! least become — government berland confident n cities berland pair connect two - ways roads road connect two different cities berland roads connect pair cities possible get city city use give two - ways roads accord reform road become one - way orient one two directions maximize tourist attraction berland reform city i value ri calculate equal number cities x orient path city i city x. word ri equal number cities reach city i roads government sure tourist 's attention focus minimum value ri help government berland make reform maximize minimum ri first line contain two integers n m ( 2 ≤ n ≤ 400 000 1 ≤ m ≤ 400 000 ) — number cities number roads next m line describe roads berland : j - th contain two integers uj vj ( 1 ≤ uj vj ≤ n uj ≠ vj ) uj vj number cities connect j - th road cities number 1 n. guarantee possible get city follow two - ways roads berland roads connect pair cities first line print single integer — maximum possible value <unknown> ≤ i ≤ n { ri } orientation roads next m line must contain description roads orientation : j - th must contain two integers uj vj mean j - th road direct city uj city vj print roads order give input data,['dfs and similar'],2300.0
744/A,hongcow ruler world ruler world want make easier people travel road within countries world model undirected graph n nod m edge k nod home governments k countries make world one edge connect two nod edge connect a node furthermore two nod correspond governments path two nod graph satisfy condition stable hongcow want add many edge possible graph keep stable determine maximum number edge hongcow add first line input contain three integers n m k ( 1 ≤ n ≤ 1 000 0 ≤ m ≤ 100 000 1 ≤ k ≤ n ) — number vertices edge graph number vertices home government next line input contain k integers c1 c2 ... ck ( 1 ≤ ci ≤ n ) integers pairwise distinct denote nod home governments world follow m line input contain two integers ui vi ( 1 ≤ ui vi ≤ n ) denote undirected edge nod ui vi guarantee graph describe input stable output a single integer maximum number edge hongcow add graph keep stable first sample test graph look like : second sample test graph look like :,['dfs and similar'],1500.0
750/H,"pay attention output section see information flush output bearland a grid h row w columns row number 1 h top bottom columns number 1 w leave right every cell either allow ( denote ' . ' input ) permanently block ( denote ' # ' ) bearland a cold land <unknown> snow often make travel harder every day a allow cells temporarily block snow note block work particular day next day cells might allow ( unless another temporarily block ) 's possible move directly two cells share a side none permanently temporarily block limak a little polar bear live bearland house top leave cell school bottom right cell every day limak first go house school return back house since get bore easily n't want visit cell twice one day except cell house start end limak reach a school return home avoid <unknown> cells call a day interest q days must process one another days check 's interest print ` ` yes '' ` ` '' a separate line order able read description next day print answer previous one flush output 's guarantee a day cells temporarily block snow would interest 's also guarantee cells limak 's house school never block ( neither permanently temporarily ) first line input contain three integers h w q ( 2 ≤ h w ≤ 1000 1 ≤ q ≤ 10 000 ) — height width grid number days respectively next h line describe cells allow permanently block i - th line contain a string length w describe i - th row every character either ' . ' ( denote allow cell ) ' # ' ( denote a permanently block cell ) 's guarantee a day cells temporarily block snow would interest , description q days give description i - th day start a line contain a single integer ki ( 1 ≤ ki ≤ 10 ) — number cells temporarily block snow day next ki line contain two integers ri j ci j ( 1 ≤ ri j ≤ h 1 ≤ ci j ≤ w ) represent a cell intersection row ri j column ci j. give ki cells distinct none permanently block also none contain limak 's house school q days print ` ` yes '' day interest otherwise print ` ` '' without quote print answer print end - of - line character flush output proceed next day get idleness limit exceed n't print anything forget flush output flush use ( print a yes / <unknown> end - of - line ) : first sample 4 days draw show limak could go school return home second third day ( leave right respectively ) a permanently block cell paint red cells temporarily block snow paint orange black green arrows limak 's way school back house respectively second sample see grid look like day ' # ' denote a cell block either temporarily permanently",['dfs and similar'],3500.0
755/C,polandball live a forest family tree forest tree undirected acyclic graph k vertices k - 1 edge k integer note one vertex a valid tree exactly one relative live vertex tree unique ids 1 n. ball i know i d distant relative live tree several vertices know value one smallest i d among many tree forest ? first line contain single integer n ( 1 ≤ n ≤ 104 ) — number ball live forest second line contain a sequence p1 p2 ... pn length n ( 1 ≤ pi ≤ n ) hold pi denote distant ball i relative live tree several distant relatives live tree pi i d one smallest i d 's guarantee sequence p correspond valid forest hack : hack someone provide a correct forest a test sequence p calculate accord forest give solution try hack input use follow format : first line output integer n ( 1 ≤ n ≤ 104 ) — number ball integer m ( 0 ≤ m < n ) — total number edge forest m line follow i - th contain two integers ai bi represent edge vertices relatives ai bi live example first sample write follow : output number tree forest polandball live technical side problem interactive however affect ( except hack ) since interaction first sample testcase possible forest : 1 - 2 3 - 4 - 5 . 2 tree overall second sample testcase possible graph one vertex edge therefore one tree,['dfs and similar'],1300.0
771/A,bear limak examine a social network main functionality two members become friends ( talk share funny picture ) n members number 1 n. m pair members friends course a member ca n't a friend let a - b denote members a b friends limak think a network reasonable follow condition satisfy : every three distinct members ( x y z ) x - y y - z also x - z example : alan bob friends bob ciri friends alan ciri friends well help limak check network reasonable ? print ` ` yes '' ` ` '' accordingly without quote first line input contain two integers n m ( 3 ≤ n ≤ 150 000 ) — number members number pair members friends i - th next m line contain two distinct integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) members ai bi friends pair members appear input give network reasonable print ` ` yes '' a single line ( without quote ) otherwise print ` ` '' a single line ( without quote ) draw show situation first sample ( leave ) second sample ( right ) edge represent two members friends answer ` ` '' second sample members ( 2 3 ) friends members ( 3 4 ) friends members ( 2 4 ),['dfs and similar'],1500.0
776/D,"moriarty trap n people n distinct room a hotel room lock others unlock , a condition people hotel escape doors unlock time m switch switch control doors room door control exactly two switch give initial configuration doors toggle switch , turn turn toggle condition doors switch control say toggle switch 1 connect room 1 2 3 respectively lock unlock unlock , toggle switch become unlock lock lock need tell sherlock exist a way unlock doors time first line input contain two integers n m ( 2 ≤ n ≤ 105 2 ≤ m ≤ 105 ) — number room number switch next line contain n space - separated integers r1 r2 ... rn ( 0 ≤ ri ≤ 1 ) tell <unknown> room doors i - th room lock ri = 0 otherwise unlock i - th next m line contain integer xi ( 0 ≤ xi ≤ n ) follow xi distinct integers separate space denote number room control i - th switch follow room number switch control guarantee room number range 1 n. guarantee door control exactly two switch output ` ` yes '' without quote possible open doors time otherwise output ` ` '' without quote second example input initial <unknown> doors [ 1 0 1 ] ( 0 mean lock 1 — unlock ) toggle switch 3 get [ 0 0 0 ] mean doors lock , toggle switch 1 get [ 1 1 1 ] mean doors unlock see first third example input possible make doors unlock",['dfs and similar'],2000.0
864/F,"n cities berland pair connect m direct roads one use roads move one city another roads connect a city pair cities ( x y ) one road x y. a path city s city t a sequence cities p1 p2 ... pk p1 = s pk = t a road city pi city pi + 1 i 1 k - 1 . path pass multiple time city except t. ca n't pass t a path p s t ideal lexicographically minimal path word p ideal path s t path q s t pi < qi i minimum integer pi ≠ qi a tourist agency country offer q unusual excursions : j - th excursion start city sj end city tj pair sj tj help agency study ideal path sj tj note possible ideal path sj tj possible due two reason : agency would like know ideal path sj tj kj - th city path ( way sj tj ) triple sj tj kj ( 1 ≤ j ≤ q ) find ideal path sj tj print kj - th city path , first line contain three integers n m q ( 2 ≤ n ≤ <unknown> ≤ m ≤ 3000 1 ≤ q ≤ 4·105 ) — number cities number roads number excursions next m line contain two integers xi yi ( 1 ≤ xi yi ≤ n xi ≠ yi ) denote i - th road go city xi city yi roads one - directional ca n't one road direction two cities next q line contain three integers sj tj kj ( 1 ≤ sj tj ≤ n sj ≠ tj 1 ≤ kj ≤ 3000 ) j - th line print city kj - th ideal path sj tj ideal path sj tj integer kj greater length path print string ' -1 ' ( without quote ) j - th line",['dfs and similar'],2700.0
788/C,"sasha kolya decide get drink coke , time k type coke i - th type characterise carbon dioxide concentration today party <unknown> <unknown> <unknown> decide prepare a glass coke carbon dioxide concentration drink also <unknown> glass contain integer number liters coke type ( type present glass ) also want minimize total volume coke glass carbon dioxide concentration define volume <unknown> dioxide coke divide total volume coke mix two coke volume carbon dioxide sum total volume coke sum well help find minimal natural number liters need create a glass carbon dioxide concentration assume friends unlimited amount coke type first line contain two integers n k ( 0 ≤ n ≤ 1000 1 ≤ k ≤ 106 ) — carbon dioxide concentration friends want number coke type second line contain k integers a1 a2 ... ak ( 0 ≤ ai ≤ 1000 ) — carbon dioxide concentration type coke coke type concentration print minimal natural number liter need prepare a glass carbon dioxide concentration -1 impossible first sample case achieve concentration use one liter coke type : second case achieve concentration use two liters type one liter type :",['dfs and similar'],2300.0
802/J,"heidi 's friend jenny ask heidi deliver important letter one common friends since jenny <unknown> heidi think might a prank precisely suspect message ask deliver state : ` ` send fool ! ` ` upon read recipient ask heidi deliver message yet another friend ( recipient common heidi ) , heidi believe friends want avoid awkward situations make visit person ( include jenny ) twice also know much cost travel two friends know want know : maximal amount money waste travel really a prank ? heidi 's n friends label 0 n - 1 network connections form a tree word every two friends a b know possibly <unknown> ( a sequence friends start a end b two consecutive friends sequence know directly ) exactly n - 1 pair friends know directly jenny give number 0 . first line input contain number friends n ( 3 ≤ n ≤ 100 ) next n - 1 line contain three space - separated integers u v c ( 0 ≤ u v ≤ n - 1 1 ≤ c ≤ 104 ) mean u v friends ( know directly ) cost travel u v c. guarantee social network input form a tree output a single integer – maximum sum cost second example worst - case scenario go like : jenny send heidi friend label number 2 ( incur a cost 100 ) friend 2 send friend 1 ( cost heidi 3 ) finally friend 1 <unknown> friend 4 ( incur additional cost 2 )",['dfs and similar'],1400.0
979/C,"kuro live a country call uberland consist $$$ n $$$ towns number $$$ 1 $$$ $$$ n $$$ $$$ n - 1 $$$ bidirectional roads connect towns possible reach town road connect two towns $$$ a $$$ $$$ b $$$ kuro love walk plan take a walk <unknown> choose a pair towns $$$ ( u v ) $$$ ( $$$ u \neq v $$$ ) walk $$$ u $$$ use shortest path $$$ v $$$ ( note $$$ ( u v ) $$$ consider different $$$ ( v u ) $$$ ) <unknown> 2 special towns uberland name flowrisa ( denote index $$$ x $$$ ) beetopia ( denote index $$$ y $$$ ) flowrisa a town many strong - <unknown> flower beetopia another town many be live particular kuro avoid pair towns $$$ ( u v ) $$$ path $$$ u $$$ $$$ v $$$ reach beetopia reach flowrisa since be attract flower <unknown> kuro ’ s body <unknown> kuro want know many pair city $$$ ( u v ) $$$ take route since ’ s really bright ask help problem first line contain three integers $$$ n $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq n \leq 300000 $$$ $$$ 1 \leq x y \leq n $$$ $$$ x \ne y $$$ ) - number towns index town flowrisa index town beetopia respectively $$$ n - 1 $$$ line follow line contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \leq a b \leq n $$$ $$$ a \ne b $$$ ) describe a road connect two towns $$$ a $$$ $$$ b $$$ guarantee town reach every town city use give roads , give map towns roads a tree a single integer resemble number pair towns $$$ ( u v ) $$$ kuro use walk route first example kuro choose pair : kuro ca n't choose pair $$$ ( 1 3 ) $$$ since walk route would $$$ 1 \rightarrow 2 \rightarrow 3 $$$ kuro visit town $$$ 1 $$$ ( flowrisa ) visit town $$$ 3 $$$ ( beetopia ) allow ( note pair $$$ ( 3 1 ) $$$ still allow although kuro visit flowrisa beetopia visit order ) second example kuro choose follow pair :",['dfs and similar'],1600.0
930/A,arcady 's garden grow a peculiar apple - tree fruit one time per year peculiarity explain follow way : n inflorescences number 1 n. inflorescence number 1 situate near base tree inflorescence number i ( i > 1 ) situate top branch bottom pi - th inflorescence pi < i. tree start fruit appear exactly one apple inflorescence moment apples appear start roll along branch base tree second apples except ones first inflorescence simultaneously roll one branch closer tree base e.g apple a - th inflorescence get <unknown> - th inflorescence apples end first inflorescence gather arcady exactly moment second peculiarity tree two apples inflorescence annihilate happen pair apples e.g 5 apples inflorescence time one annihilate 8 apples apples annihilate thus one apple inflorescence moment time help arcady count number apples able collect first inflorescence one harvest first line input contain single integer number n ( 2 ≤ n ≤ 100 000 ) — number inflorescences second line input contain sequence n - 1 integer number p2 p3 ... pn ( 1 ≤ pi < i ) pi number inflorescence apple i - th inflorescence roll single line output contain one integer number : amount apples arcady able collect first inflorescence one harvest first example arcady able collect one apple initially situate 1st inflorescence next second apples 2nd 3rd inflorescences roll annihilate arcady wo n't able collect second example arcady able collect 3 apples first one one initially situate first inflorescence a second apple 2nd inflorescence roll 1st ( arcady collect ) apples 3rd 4th 5th inflorescences roll 2nd two annihilate one annihilate roll 2 - nd inflorescence 1st one next second arcady collect,['dfs and similar'],1500.0
915/D,give a direct graph consist n vertices m edge ( edge direct traverse one direction ) allow remove one edge make graph acyclic remove one edge ? a direct graph call acyclic iff n't contain cycle ( a non - empty path start end vertex ) first line contain two integers n m ( 2 ≤ n ≤ 500 1 ≤ m ≤ min ( n ( n - 1 ) 100000 ) ) — number vertices number edge respectively m line follow line contain two integers u v denote a direct edge go vertex u vertex v ( 1 ≤ u v ≤ n u ≠ v ) order pair ( u v ) list ( one direct edge u v ) possible make graph acyclic remove one edge print yes otherwise print first example remove edge graph become acyclic second example remove least two edge ( example ) order make graph acyclic,['dfs and similar'],2200.0
813/C,alice get tire play tag game usual rule offer bob a little modification game play undirected root tree n vertices vertex 1 root tree alice start vertex 1 bob start vertex x ( x ≠ 1 ) move make turn bob go first one move one either stay current vertex travel neighbour one game end alice go vertex bob stand alice want minimize total number move bob want maximize write a program determine many move game last first line contain two integer number n x ( 2 ≤ n ≤ 2·105 2 ≤ x ≤ n ) next n - 1 line contain two integer number a b ( 1 ≤ a b ≤ n ) — edge tree guarantee edge form a valid tree print total number move alice bob make first example tree look like : red vertex alice 's start position blue one bob 's bob make game run longest stand vertex 3 game move : b : stay vertex 3a : go vertex 2b : stay vertex 3a : go vertex 3 in second example tree look like : move optimal strategy : b : go vertex 3a : go vertex 2b : go vertex 4a : go vertex <unknown> : stay vertex 4a : go vertex 4,['dfs and similar'],1700.0
821/D,"okabe like able walk city a path light street lamps way n't get beat schoolchildren okabe 's city represent a 2d grid cells row number 1 n top bottom columns number 1 m leave right exactly k cells city light a street lamp 's guarantee top - left cell light okabe start walk top - left cell want reach bottom - right cell course okabe walk light cells move adjacent cells , leave right directions however okabe also temporarily light cells single row column a time pay 1 coin allow walk cells light initially note okabe light a single row column a time pay a coin every time light a new row column change row column temporarily light must stand a cell light initially also remove <unknown> light a row column cells row / column initially light light help okabe find minimum number coin need pay complete walk ! first line input contain three space - separated integers n m k ( 2 ≤ n m k ≤ 104 ) next k line contain two space - separated integers ri ci ( 1 ≤ ri ≤ n 1 ≤ ci ≤ m ) — row column i - th light cell guarantee k light cells distinct guarantee top - left cell light print minimum number coin okabe need pay complete walk -1 's possible first sample test okabe take path pay move ( 2 3 ) ( 4 4 ) fourth sample okabe take path pay move ( 1 2 ) ( 3 4 ) ( 5 4 )",['dfs and similar'],2200.0
794/D,"oleg bank client live bankopolia n cities bankopolia pair cities connect directly bi - directional roads cities number 1 n. a total m roads bankopolia i - th road connect cities ui vi guarantee city possible travel city use roads oleg want give a label city suppose label city i equal xi , must hold pair cities ( u v ) condition |xu - xv| ≤ 1 hold a road connect u v. oleg wonder a label possible find example label task possible state impossible otherwise first line input contain two space - separated integers n m ( 2 ≤ n ≤ 3·105 1 ≤ m ≤ 3·105 ) — number cities number roads next m line follow i - th line contain two space - separated integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) — cities connect i - th road guarantee one road pair cities possible travel city city use roads require label possible output a single line contain string ` ` '' ( without quote ) otherwise output string ` ` yes '' ( without quote ) first line next line output n space - separated integers x1 x2 ... xn condition 1 ≤ xi ≤ 109 must hold i pair cities ( u v ) condition |xu - xv| ≤ 1 must hold a road connect u v. first sample x1 = 2 x2 = 3 x3 = x4 = 1 a valid label indeed ( 3 4 ) ( 1 2 ) ( 1 3 ) ( 1 4 ) pair cities difference label greater 1 precisely roads bankopolia second sample pair cities difference label greater 1 pair cities a road connect last sample impossible construct a label satisfy give constraints",['dfs and similar'],2400.0
730/C,a new trade empire rise berland bulmart <unknown> trade giant decide <unknown> market ... shovel ! almost every city berland a bulmart store cities even several ! problem moment <unknown> ... let 's say a little estimate people even say shovel <unknown> market small a big company make a profit company management believe future market seek new ways increase income n cities berland connect m bi - directional roads roads equal lengths happen impossible reach a city another city use roads road connect a city pair cities connect one road w bulmart store berland describe three number : latest idea bulmart management create a program help customers get shovel fast possible <unknown> budget formally program find minimum amount time need deliver rj shovel customer city gj total cost aj burl delivery time two adjacent cities equal 1 . shovel deliver several cities delivery time equal arrival time last package delivery free charge program need find answer q query query process independently others i.e a query change number shovel store next query first line contain two integers n m ( 1 ≤ n ≤ 5000 0 ≤ m ≤ min ( 5000 n · ( n - 1 ) / 2 ) ) next m line contain two integers xe ye mean e - th road connect cities xe ye ( 1 ≤ xe ye ≤ n ) next line contain a single integer w ( 1 ≤ w ≤ 5000 ) — total number bulmart store berland next w line contain three integers describe i - th store : ci ki pi ( 1 ≤ ci ≤ n 1 ≤ ki pi ≤ 2·105 ) next line contain a single integer q ( 1 ≤ q ≤ 1000 ) — number query next q line contain three integers describe j - th query : gj rj aj ( 1 ≤ gj ≤ n 1 ≤ rj aj ≤ 109 ) output q line j - th line print answer j - th query — minimum amount time need deliver rj shovel customer city gj spend aj burl print -1 solution j - th query,['dfs and similar'],2100.0
1044/B,"play a strange game li chen a tree $$$ n $$$ nod draw a piece paper nod <unknown> distinguishable independently label vertices $$$ 1 $$$ $$$ n $$$ neither know 's label tree li chen choose a subtree ( i.e. a connect subgraph ) tree subtree consist vertices label $$$ x_1 x_2 \ldots x _ { k_1 } $$$ label li chen 's subtree consist vertices label $$$ y_1 y_2 \ldots y _ { k_2 } $$$ label value $$$ x_1 x_2 \ldots x _ { k_1 } $$$ $$$ y_1 y_2 \ldots y _ { k_2 } $$$ know want determine whether subtrees least one common vertex luckily friend andrew know label tree ask andrew $$$ 5 $$$ question one follow two form : determine whether two subtrees least one common vertex ask question least one common vertex determine one label common vertices test consist several test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case testcase program interact follow format first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1\,000 $$$ ) — number nod tree next $$$ n-1 $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1\leq a_i b_i\leq n $$$ ) — edge tree indicate edge node $$$ a_i $$$ $$$ b_i $$$ accord label nod next line contain a single integer $$$ k_1 $$$ ( $$$ 1 \leq k_1 \leq n $$$ ) — number nod subtree next line contain $$$ k_1 $$$ distinct integers $$$ x_1 x_2 \ldots x _ { k_1 } $$$ ( $$$ 1 \leq x_i \leq n $$$ ) — indices nod subtree accord label guarantee vertices form a subtree next line contain a single integer $$$ k_2 $$$ ( $$$ 1 \leq k_2 \leq n $$$ ) — number nod li chen 's subtree next line contain $$$ k_2 $$$ distinct integers $$$ y_1 y_2 \ldots y _ { k_2 } $$$ ( $$$ 1 \leq y_i \leq n $$$ ) — indices ( accord li chen 's label ) nod li chen 's subtree guarantee vertices form a subtree accord li chen 's label tree 's nod test case provide one one must complete interact previous test ( i.e print a common node $$$ -1 $$$ node ) start receive next one ask andrew two different type question may ask $$$ 5 $$$ question per tree ready answer print ` ` c s '' $$$ s $$$ label a vertex common subtrees $$$ -1 $$$ vertex exist print answer count a question remember flush answer start receive next test case print a question forget print end line flush output otherwise get idleness limit exceed , use : judge respond $$$ -1 $$$ mean ask query allow ask invalid query program immediately terminate ( example call exit ( 0 ) ) receive wrong answer ; mean ask query allow ask invalid query ignore get verdicts since program continue read a close stream hack formatto hack use follow format note hack one test case first line contain a single integer $$$ t $$$ ( $$$ t=1 $$$ ) second line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1\,000 $$$ ) third line contain $$$ n $$$ integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1\leq <unknown> n $$$ ) — a permutation $$$ 1 $$$ $$$ n $$$ encode label li chen choose tree particular li chen choose label $$$ p_i $$$ node label $$$ i $$$ next $$$ n-1 $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1\leq a_i b_i\leq n $$$ ) edge form a tree next line contain a single integer $$$ k_1 $$$ ( $$$ 1 \leq k_1 \leq n $$$ ) next line contain $$$ k_1 $$$ distinct integers $$$ x_1 x_2 \ldots x _ { k_1 } $$$ ( $$$ 1 \leq x_i \leq n $$$ ) vertices form a subtree next line contain a single integer $$$ k_2 $$$ ( $$$ 1 \leq k_2 \leq n $$$ ) next line contain $$$ k_2 $$$ distinct integers $$$ y_1 y_2 \ldots y _ { k_2 } $$$ ( $$$ 1 \leq y_i \leq n $$$ ) vertices form a subtree li chen 's tree accord permutation first sample li chen 's hide permutation $$$ [ 2 3 1 ] $$$ second hide permutation $$$ [ 5 3 2 4 1 6 ] $$$ case first sample a tree three nod a line top label tree subtree choose bottom li chen label tree subtree choose : first question ask andrew look node $$$ 1 $$$ label tell label li chen 's label andrew respond $$$ 2 $$$ point know subtrees contain node ( i.e node $$$ 1 $$$ accord label ) output ` ` c 1 '' finish however also ask andrew look node $$$ 2 $$$ li chen 's label tell label label andrew respond $$$ 1 $$$ ( step give reason — show ask question ) second sample two test case first look one statement : first ask ` ` b 2 '' andrew tell us $$$ 3 $$$ case know $$$ 3 $$$ a common vertex moreover subtree size $$$ 3 $$$ contain node $$$ 3 $$$ must contain node $$$ 1 $$$ well output either ` ` c 1 '' ` ` c 3 '' answer second case second sample situation look follow : case know subtree size $$$ 3 $$$ n't contain node $$$ 1 $$$ subtree $$$ 4,5,6 $$$ ask andrew label node $$$ 1 $$$ li chen 's label andrew say $$$ 5 $$$ case know li chen 's subtree n't contain node $$$ 1 $$$ subtree must consist nod $$$ 4,5,6 $$$ ( label ) thus two subtrees common nod",['dfs and similar'],1900.0
1057/A,upon a time one router well - known company <unknown> years go time new routers purchase every time buy a new router connect one routers buy give value $$$ p_i $$$ — index router $$$ i $$$ -th router connect purchase ( $$$ p_i < i $$$ ) $$$ n $$$ routers <unknown> total print sequence routers path first $$$ n $$$ -th router first line contain integer number $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number routers follow line contain $$$ n-1 $$$ integers $$$ p_2 p_3 \dots p_n $$$ ( $$$ 1 \le p_i < i $$$ ) $$$ p_i $$$ equal index router $$$ i $$$ -th connect purchase print path $$$ 1 $$$ -st $$$ n $$$ -th router start $$$ 1 $$$ end $$$ n $$$ elements path distinct,['dfs and similar'],900.0
1272/E,give array $$$ a $$$ consist $$$ n $$$ integers one move jump position $$$ i $$$ position $$$ i - a_i $$$ ( $$$ 1 \le i - a_i $$$ ) position $$$ i + a_i $$$ ( $$$ i + a_i \le n $$$ ) position $$$ i $$$ $$$ 1 $$$ $$$ n $$$ want know minimum number move require reach position $$$ j $$$ $$$ a_j $$$ opposite parity $$$ a_i $$$ ( i.e $$$ a_i $$$ odd $$$ a_j $$$ even vice versa ) first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements $$$ a $$$ second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ print $$$ n $$$ integers $$$ d_1 d_2 \dots d_n $$$ $$$ d_i $$$ minimum number move require reach position $$$ j $$$ $$$ a_j $$$ opposite parity $$$ a_i $$$ ( i.e $$$ a_i $$$ odd $$$ a_j $$$ even vice versa ) -1 impossible reach a position,['dfs and similar'],1900.0
1276/B,"$$$ n $$$ cities berland pair connect two - way roads guarantee pass city move along roads cities numerate $$$ 1 $$$ $$$ n $$$ two fair currently take place berland — hold two different cities $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le n $$$ ; $$$ a \ne b $$$ ) find number pair cities $$$ x $$$ $$$ y $$$ ( $$$ x \ne a x \ne b y \ne a y \ne b $$$ ) go $$$ x $$$ $$$ y $$$ go fair ( order visit n't matter ) formally need find number pair cities $$$ x y $$$ path $$$ x $$$ $$$ y $$$ go $$$ a $$$ $$$ b $$$ ( order ) print require number pair order two cities a pair matter , pair $$$ ( x y ) $$$ $$$ ( y x ) $$$ must take account first line input contain integer $$$ t $$$ ( $$$ 1 \le t \le <unknown> $$$ ) — number test case input next $$$ t $$$ test case specify first line test case contain four integers $$$ n $$$ $$$ m $$$ $$$ a $$$ $$$ b $$$ ( $$$ 4 \le n \le 2\cdot100000 $$$ $$$ n - 1 \le m \le 5\cdot100000 $$$ $$$ 1 \le a b \le n $$$ $$$ a \ne b $$$ ) — number cities roads berland number two cities fair hold respectively follow $$$ m $$$ line contain descriptions roads cities road description contain a pair integers $$$ u_i v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) — number cities connect road road bi - directional connect two different cities guarantee city pass roads one road a pair cities sum value $$$ n $$$ set input data test exceed $$$ 2\cdot100000 $$$ sum value $$$ m $$$ set input data test exceed $$$ 5\cdot100000 $$$ print $$$ t $$$ integers — answer give test case order write input",['dfs and similar'],1900.0
1290/C,$$$ n $$$ lamps a line number $$$ 1 $$$ $$$ n $$$ one initial state ( $$$ 0 $$$ ) ( $$$ 1 $$$ ) 're give $$$ k $$$ subsets $$$ a_1 \ldots a_k $$$ $$$ \ { 1 2 \dots n\ } $$$ intersection three subsets empty word $$$ 1 \le i_1 < i_2 < i_3 \le k $$$ $$$ a _ { i_1 } \cap a _ { i_2 } \cap a _ { i_3 } = <unknown> $$$ one operation choose one $$$ k $$$ subsets switch state lamps guarantee give subsets 's possible make lamps simultaneously use type operation let $$$ m_i $$$ minimum number operations order make $$$ i $$$ first lamps simultaneously note condition upon state lamps ( $$$ i+1 $$$ $$$ n $$$ ) either compute $$$ m_i $$$ $$$ 1 \le i \le n $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 300000 $$$ ) second line contain a binary string length $$$ n $$$ represent initial state lamp ( lamp $$$ i $$$ $$$ s_i = 0 $$$ $$$ s_i = 1 $$$ ) description one $$$ k $$$ subsets follow follow format : first line description contain a single integer $$$ c $$$ ( $$$ 1 \le c \le n $$$ ) — number elements subset second line description contain $$$ c $$$ distinct integers $$$ x_1 \ldots x_c $$$ ( $$$ 1 \le x_i \le n $$$ ) — elements subset guarantee : must output $$$ n $$$ line $$$ i $$$ -th line contain a single integer $$$ m_i $$$ — minimum number operations require make lamps $$$ 1 $$$ $$$ i $$$ simultaneously first example : second example :,['dfs and similar'],2400.0
1307/F,bessie plan a vacation ! cow - <unknown> $$$ n $$$ cities $$$ n-1 $$$ bidirectional roads connect guarantee one reach city city bessie consider $$$ v $$$ possible vacation plan $$$ i $$$ -th one consist a start city $$$ a_i $$$ destination city $$$ b_i $$$ know $$$ r $$$ cities rest stop bessie get tire easily travel across $$$ k $$$ consecutive roads without rest fact <unknown> rest may travel city multiple time order vacation plan exist a way bessie travel start city destination city ? first line contain three integers $$$ n $$$ $$$ k $$$ $$$ r $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 1 \le k r \le n $$$ ) — number cities maximum number roads bessie will travel a row without rest number rest stop follow $$$ n-1 $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \neq y_i $$$ ) mean city $$$ x_i $$$ city $$$ y_i $$$ connect a road next line contain $$$ r $$$ integers separate space — cities rest stop city appear next line contain $$$ v $$$ ( $$$ 1 \le v \le 200000 $$$ ) — number vacation plan follow $$$ v $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ $$$ a_i \ne b_i $$$ ) — start end city vacation plan bessie reach destination without travel across $$$ k $$$ roads without rest $$$ i $$$ -th vacation plan print yes otherwise print graph first example show rest stop denote red first query bessie visit cities order : $$$ 1 2 3 $$$ second query bessie visit cities order : $$$ 3 2 4 5 $$$ third query bessie travel destination example attempt travel way : $$$ 3 2 4 5 6 $$$ travel $$$ 2 $$$ roads without rest graph second example show,['dfs and similar'],3300.0
1311/B,give array $$$ a $$$ length $$$ n $$$ also give a set distinct position $$$ p_1 p_2 \dots p_m $$$ $$$ 1 \le p_i < n $$$ position $$$ p_i $$$ mean swap elements $$$ a [ p_i ] $$$ $$$ a [ p_i + 1 ] $$$ apply operation number time give position task determine possible sort initial array non - decreasing order ( $$$ a_1 \le a_2 \le \dots \le a_n $$$ ) use allow swap example $$$ a = [ 3 2 1 ] $$$ $$$ p = [ 1 2 ] $$$ first swap elements $$$ a [ 2 ] $$$ $$$ a [ 3 ] $$$ ( position $$$ 2 $$$ contain give set $$$ p $$$ ) get array $$$ a = [ 3 1 2 ] $$$ swap $$$ a [ 1 ] $$$ $$$ a [ 2 ] $$$ ( position $$$ 1 $$$ also contain $$$ p $$$ ) get array $$$ a = [ 1 3 2 ] $$$ finally swap $$$ a [ 2 ] $$$ $$$ a [ 3 ] $$$ get array $$$ a = [ 1 2 3 ] $$$ sort non - decreasing order see $$$ a = [ 4 1 2 3 ] $$$ $$$ p = [ 3 2 ] $$$ sort array answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le m < n \le 100 $$$ ) — number elements $$$ a $$$ number elements $$$ p $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100 $$$ ) third line test case contain $$$ m $$$ integers $$$ p_1 p_2 \dots p_m $$$ ( $$$ 1 \le p_i < n $$$ $$$ p_i $$$ distinct ) — set position describe problem statement test case print answer — ` ` yes '' ( without quote ) sort initial array non - decreasing order ( $$$ a_1 \le a_2 \le \dots \le a_n $$$ ) use allow swap otherwise print ` ` '',['dfs and similar'],1200.0
1266/F,let $$$ g $$$ a simple graph let $$$ w $$$ a non - empty subset vertices $$$ w $$$ almost- $$$ k $$$ -uniform pair distinct vertices $$$ u v \in w $$$ distance $$$ u $$$ $$$ v $$$ either $$$ k $$$ $$$ k+1 $$$ give a tree $$$ n $$$ vertices $$$ i $$$ $$$ 1 $$$ $$$ n $$$ find maximum size almost- $$$ i $$$ -uniform set first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 500000 $$$ ) – number vertices tree $$$ n-1 $$$ line follow $$$ i $$$ -th consist two space separate integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ ) mean edge vertices $$$ u_i $$$ $$$ v_i $$$ guarantee give graph tree output a single line contain $$$ n $$$ space separate integers $$$ a_i $$$ $$$ a_i $$$ maximum size almost- $$$ i $$$ -uniform set consider first example second sample almost- $$$ 2 $$$ -uniform set size $$$ 4 $$$ $$$ \ { 2 3 5 6\ } $$$,['dfs and similar'],2900.0
1320/B,map bertown represent a set $$$ n $$$ intersections number $$$ 1 $$$ $$$ n $$$ connect $$$ m $$$ one - way roads possible move along roads intersection intersection length path one intersection another number roads one traverse along path shortest path one intersection $$$ v $$$ another intersection $$$ u $$$ path start $$$ v $$$ end $$$ u $$$ minimum length among paths polycarp live near intersection $$$ s $$$ work a build near intersection $$$ t $$$ every day get $$$ s $$$ $$$ t $$$ car today choose follow path workplace : $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_k $$$ $$$ p_1 = s $$$ $$$ p_k = t $$$ elements sequence intermediate intersections list order polycarp arrive polycarp never arrive intersection twice elements sequence pairwise distinct note know polycarp 's path beforehand ( fix ) necessarily one shortest paths $$$ s $$$ $$$ t $$$ polycarp 's car a complex navigation system instal let 's describe work polycarp start journey intersection $$$ s $$$ system choose shortest path $$$ s $$$ $$$ t $$$ show polycarp let 's denote next intersection choose path $$$ v $$$ polycarp choose drive along road $$$ s $$$ $$$ v $$$ navigator show shortest path ( obviously start $$$ v $$$ soon arrive intersection ) however polycarp choose drive another intersection $$$ w $$$ instead navigator rebuild path : soon polycarp arrive $$$ w $$$ navigation system choose shortest path $$$ w $$$ $$$ t $$$ show polycarp process continue polycarp arrive $$$ t $$$ : polycarp move along road recommend system maintain shortest path already build ; polycarp choose path system rebuild path rule example suppose map bertown look follow polycarp drive along path $$$ [ 1 2 3 4 ] $$$ ( $$$ s = 1 $$$ $$$ t = 4 $$$ ) : check picture link http : <unknown> / <unknown> get $$$ 2 $$$ rebuild scenario note system choose $$$ [ 2 3 4 ] $$$ instead $$$ [ 2 6 4 ] $$$ second step would $$$ 1 $$$ rebuild ( since polycarp go along path system maintain path $$$ [ 3 4 ] $$$ third step ) example show us number rebuild differ even map bertown path choose polycarp stay give information ( map polycarp 's path ) determine minimum maximum number rebuild could happen journey ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le m \le 200000 $$$ ) — number intersections one - way roads bertown respectively $$$ m $$$ line follow describe a road line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) denote a road intersection $$$ u $$$ intersection $$$ v $$$ roads bertown pairwise distinct mean order pair $$$ ( u v ) $$$ appear $$$ m $$$ line ( a road $$$ ( u v ) $$$ road $$$ ( v u ) $$$ also appear ) follow line contain one integer $$$ k $$$ ( $$$ 2 \le k \le n $$$ ) — number intersections polycarp 's path home workplace last line contain $$$ k $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_k $$$ ( $$$ 1 \le p_i \le n $$$ integers pairwise distinct ) — intersections along polycarp 's path order arrive $$$ p_1 $$$ intersection polycarp live ( $$$ s = p_1 $$$ ) $$$ p_k $$$ intersection polycarp 's workplace situate ( $$$ t = p_k $$$ ) guarantee every $$$ i \in [ 1 k - 1 ] $$$ road $$$ p_i $$$ $$$ p _ { i + 1 } $$$ exist path go along roads bertown print two integers : minimum maximum number rebuild could happen journey,['dfs and similar'],1700.0
1100/E,"andrew prefer taxi mean transport recently taxi drivers act <unknown> order earn money taxi drivers start drive circle roads andrew 's city one - way people necessary able travel one part another <unknown> comparison <unknown> taxi drivers mayor city decide change direction certain roads taxi drivers would n't able increase cost trip <unknown> formally taxi driver a certain crossroads would n't able reach perform a nonzero trip traffic controllers need order change direction road go every road know many traffic controllers need change direction road opposite one allow change directions roads one one mean traffic controller participate reverse two roads need calculate minimum number traffic controllers need hire perform task list roads need reverse first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 100\,000 $$$ $$$ 1 \leq m \leq 100\,000 $$$ ) — number crossroads number roads city respectively follow $$$ m $$$ line contain three integers $$$ u _ { i } $$$ $$$ v _ { i } $$$ $$$ c _ { i } $$$ ( $$$ 1 \leq u _ { i } v _ { i } \leq n $$$ $$$ 1 \leq c _ { i } \leq 1000000000 $$$ $$$ u _ { i } \ne v _ { i } $$$ ) — crossroads road start crossroads road end number traffic controllers require reverse road first line output two integers minimal amount traffic controllers require complete task amount roads $$$ k $$$ reverse $$$ k $$$ minimize next line output $$$ k $$$ integers separate space — number roads directions reverse roads numerate $$$ 1 $$$ order write input many solutions print two simple cycle first example : $$$ 1 \rightarrow 5 \rightarrow 2 \rightarrow 1 $$$ $$$ 2 \rightarrow 3 \rightarrow 4 \rightarrow 5 \rightarrow 2 $$$ one traffic controller reverse road $$$ 2 \rightarrow 1 $$$ ca n't destroy second cycle two traffic controllers reverse roads $$$ 2 \rightarrow 1 $$$ $$$ 2 \rightarrow 3 $$$ would satisfy condition second example one traffic controller ca n't destroy cycle $$$ 1 \rightarrow 3 \rightarrow 2 \rightarrow 1 $$$ help three controllers example reverse roads $$$ 1 \rightarrow 3 $$$ $$$ 2 \rightarrow 4 $$$ $$$ 1 \rightarrow 5 $$$",['dfs and similar'],2200.0
1361/E,"jam bond a new plan catch enemy cities direct roads possible travel two cities use roads enemy appear city bond know next destination idea path choose move city $$$ a $$$ call interest city $$$ b $$$ exactly one simple path $$$ a $$$ $$$ b $$$ a simple path understand a sequence distinct cities every two neighbor cities exist a direct road first second city bond 's enemy mistress escape chase start interest city give possibility catch jam want arrange people cities however enough interest cities whole action n't make sense since bond 's people may wait long enemy responsible find interest cities say enough enough jam mean strictly less $$$ 20\ % $$$ cities first line contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 2\,000 $$$ ) — number test case test case describe follow : first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \le 100000 $$$ $$$ 0 \leq m \le 200000 $$$ ) — number cities roads follow $$$ m $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ u \neq v $$$ ; $$$ 1 \leq u v \leq n $$$ ) denote a direct road $$$ u $$$ $$$ v $$$ assume order pair cities one road sum $$$ n $$$ test case n't exceed $$$ 100000 $$$ sum $$$ m $$$ n't exceed $$$ 200000 $$$ strictly less $$$ 20\ % $$$ cities interest print $$$ -1 $$$ otherwise let $$$ k $$$ number interest cities print $$$ k $$$ distinct integers increase order — indices interest cities draw a city color green interest ; otherwise color red first sample city interest second sample city interest third sample cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 5 $$$ interest last sample city $$$ 1 $$$ interest strictly less $$$ 20\ % $$$ cities answer $$$ -1 $$$",['dfs and similar'],3000.0
1370/F2,"note difference easy hard version constraint number query make hack versions problem solve interactive problem give a tree consist $$$ n $$$ nod number integers $$$ 1 $$$ $$$ n $$$ ayush ashish choose two secret distinct nod tree need find nod make follow query : recall a tree a connect graph without cycle distance two nod define number edge simple path formally let 's define two hide nod $$$ s $$$ $$$ f $$$ one query provide set nod $$$ \ { a_1 a_2 \ldots a_c\ } $$$ tree a result get two number $$$ a_i $$$ $$$ dist ( a_i s ) + dist ( a_i f ) $$$ node $$$ a_i $$$ node provide set number $$$ dist ( a_i s ) + dist ( a_i f ) $$$ minimal ask $$$ 11 $$$ query first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10 ) $$$ — number test case please note interaction process organize first line test case consist a single integer $$$ n $$$ $$$ ( 2 \le n \le 1000 ) $$$ — number nod tree next $$$ n - 1 $$$ line consist two integers $$$ u $$$ $$$ v $$$ $$$ ( 1 \le u v \le n u \ne v ) $$$ — edge tree ask a query print a single line : query receive two integers $$$ x $$$ $$$ d $$$ — node ( among query nod ) minimum sum distance hide nod sum distance node hide nod subset nod query invalid exceed number query get $$$ x = d = -1 $$$ case terminate program immediately guess hide nod print a single line ` ` ! ` ` ( without quote ) follow two integers range $$$ [ 1 n ] $$$ — hide nod output hide nod order , read a string guess nod correctly receive string ` ` correct '' case continue solve remain test case terminate program test case solve otherwise receive string ` ` incorrect '' case terminate program immediately guess hide nod count towards number query ask interactor adaptive hide nod change query forget read string ` ` correct '' / ` ` incorrect '' guess hide nod need solve test case receive input next test case limit $$$ 11 $$$ query apply test case entire input print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack solution use follow test format : first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10 ) $$$ — number test case description test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 2 \le n \le 1000 ) $$$ — number nod tree second line contain two distinct integers range $$$ [ 1 n ] $$$ — hide nod next $$$ n - 1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ $$$ ( 1 \le u v \le n u \ne v ) $$$ — edge tree tree first test show hide nod $$$ 1 $$$ $$$ 3 $$$",['dfs and similar'],2700.0
1387/B2,problem split two task task require find maximum possible answer task village ( minimum ) require find minimum possible answer task worth $$$ 50 $$$ point $$$ n $$$ house a certain village a single villager live house house connect roads road connect two house exactly $$$ 1 $$$ kilometer long house possible reach use one several consecutive roads total $$$ n-1 $$$ roads village one day villagers decide move different house — move house a single villager live villager live house would like know largest possible total length kilometers shortest paths old new house villagers example village seven house example seven house connect roads show figure largest total length $$$ 18 $$$ km ( achieve move $$$ 1 \to 7 $$$ $$$ 2 \to 3 $$$ $$$ 3 \to 4 $$$ $$$ 4 \to 1 $$$ $$$ 5 \to 2 $$$ $$$ 6 \to 5 $$$ $$$ 7 \to 6 $$$ ) write a program find largest total length shortest paths kilometers example assignment new house villagers first line contain integer $$$ n $$$ ( $$$ 1 < n \le 100000 $$$ ) house number consecutive integers $$$ 1 2 \ldots n $$$ $$$ n-1 $$$ line follow describe roads line contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le n $$$ $$$ a \neq b $$$ ) denote a road connect house $$$ a $$$ $$$ b $$$ first line output largest total length shortest paths kilometers second line describe one valid assignment new house largest total length : $$$ n $$$ space - separated distinct integers $$$ v_1 v_2 \ldots <unknown> $$$ $$$ i $$$ $$$ v_i $$$ house number villager house $$$ i $$$ move ( $$$ v_i \neq i $$$ ) several valid assignments output subtasks :,['dfs and similar'],2500.0
1411/C,give a $$$ n \times n $$$ chessboard row columns board number $$$ 1 $$$ $$$ n $$$ cell $$$ ( x y ) $$$ lie intersection column number $$$ x $$$ row number $$$ y $$$ rook a chess piece one turn move number cells vertically horizontally $$$ m $$$ rook ( $$$ m < n $$$ ) place chessboard a way pair rook attack i.e pair rook share a row a column one turn move one rook number cells vertically horizontally additionally n't attack rook movement minimum number move require place rook main diagonal ? main diagonal chessboard cells $$$ ( i i ) $$$ $$$ 1 \le i \le n $$$ first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) description $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ — size chessboard number rook ( $$$ 2 \leq n \leq 100000 $$$ $$$ 1 \leq m < n $$$ ) next $$$ m $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ — position rook $$$ i $$$ -th rook place cell $$$ ( x_i y_i ) $$$ ( $$$ 1 \leq x_i y_i \leq n $$$ ) 's guarantee two rook attack initial placement sum $$$ n $$$ test case exceed $$$ 100000 $$$ $$$ t $$$ test case print a single integer — minimum number move require place rook main diagonal prove always possible possible move first three test case :,['dfs and similar'],1700.0
1454/E,"give undirected graph consist $$$ n $$$ vertices $$$ n $$$ edge guarantee give graph connect ( i. e. possible reach vertex vertex ) self - loops multiple edge graph task calculate number simple paths length least $$$ 1 $$$ give graph note paths differ direction consider ( i. e. calculate number undirected paths ) example paths $$$ [ 1 2 3 ] $$$ $$$ [ 3 2 1 ] $$$ consider answer $$$ t $$$ independent test case recall a path graph a sequence vertices $$$ v_1 v_2 \ldots <unknown> $$$ pair adjacent ( consecutive ) vertices sequence connect edge length path number edge a simple path a path vertices distinct first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain one integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) — number vertices ( number edge ) graph next $$$ n $$$ line test case describe edge : edge $$$ i $$$ give a pair vertices $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) $$$ u_i $$$ $$$ v_i $$$ vertices $$$ i $$$ -th edge connect pair vertices $$$ ( u v ) $$$ one edge $$$ u $$$ $$$ v $$$ edge vertex , self - loops multiple edge graph graph undirected i. e. edge bidirectional graph connect i. e. possible reach vertex vertex move along edge graph guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print one integer : number simple paths length least $$$ 1 $$$ give graph note paths differ direction consider ( i. e. calculate number undirected paths ) consider second test case example look like : $$$ 11 $$$ different simple paths :",['dfs and similar'],2000.0
1328/E,give a root tree consist $$$ n $$$ vertices number $$$ 1 $$$ $$$ n $$$ root tree a vertex number $$$ 1 $$$ a tree a connect undirected graph $$$ n-1 $$$ edge give $$$ m $$$ query $$$ i $$$ -th query consist set $$$ k_i $$$ distinct vertices $$$ v_i [ 1 ] v_i [ 2 ] \dots v_i [ k_i ] $$$ task say a path root vertex $$$ u $$$ give $$$ k $$$ vertices either belong path distance $$$ 1 $$$ vertex path first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 1 \le m \le 200000 $$$ ) — number vertices tree number query next $$$ n-1 $$$ line describe edge tree edge $$$ i $$$ denote two integers $$$ u_i $$$ $$$ v_i $$$ label vertices connect $$$ ( 1 \le u_i v_i \le n u_i \ne v_i $$$ ) guarantee give edge form a tree next $$$ m $$$ line describe query $$$ i $$$ -th line describe $$$ i $$$ -th query start integer $$$ k_i $$$ ( $$$ 1 \le k_i \le n $$$ ) — number vertices current query $$$ k_i $$$ integers follow : $$$ v_i [ 1 ] v_i [ 2 ] \dots v_i [ k_i ] $$$ ( $$$ 1 \le v_i [ j ] \le n $$$ ) $$$ v_i [ j ] $$$ $$$ j $$$ -th vertex $$$ i $$$ -th query guarantee vertices a single query distinct guarantee sum $$$ k_i $$$ exceed $$$ 200000 $$$ ( $$$ \sum\limits _ { i=1 } ^ { m } k_i \le 200000 $$$ ) query print answer — ` ` yes '' a path root vertex $$$ u $$$ give $$$ k $$$ vertices either belong path distance $$$ 1 $$$ vertex path ` ` '' otherwise picture correspond example : consider query first query $$$ [ 3 8 9 10 ] $$$ answer ` ` yes '' choose path root $$$ 1 $$$ vertex $$$ <unknown> $$$ vertices $$$ [ 3 9 10 ] $$$ belong path $$$ 1 $$$ $$$ 10 $$$ vertex $$$ 8 $$$ distance $$$ 1 $$$ vertex $$$ 7 $$$ also belong path second query $$$ [ 2 4 6 ] $$$ answer ` ` yes '' choose path vertex $$$ <unknown> $$$ vertex $$$ 4 $$$ distance $$$ 1 $$$ vertex $$$ 1 $$$ belong path vertex $$$ 6 $$$ distance $$$ 1 $$$ vertex $$$ 2 $$$ belong path third query $$$ [ 2 1 5 ] $$$ answer ` ` yes '' choose path vertex $$$ <unknown> $$$ vertices query belong path fourth query $$$ [ 4 8 2 ] $$$ answer ` ` yes '' choose path vertex $$$ <unknown> $$$ vertices $$$ 2 $$$ $$$ 4 $$$ distance $$$ 1 $$$ vertex $$$ 1 $$$ belong path vertex $$$ 8 $$$ distance $$$ 1 $$$ vertex $$$ 7 $$$ belong path fifth sixth query answer ` ` '' choose suitable vertex $$$ u $$$,['dfs and similar'],1900.0
1045/C,"<unknown> solar system $$$ n $$$ planets a space government company recently hire space contractors build $$$ m $$$ bidirectional hyperspace ™ highways connect two different planets <unknown> objective make sure every planet reach planet take hyperspace ™ highways completely fulfil unfortunately lot space contractors friends <unknown> space board <unknown> company company decide much connect planets order make spend enormous amount space money hyperspace ™ highways look <unknown> decide enforce a strict rule hyperspace ™ highway network : whenever a way travel planets return start point without travel planet twice every pair planets <unknown> directly connect a hyperspace ™ highway word set planets every simple cycle induce a complete subgraph design a hyperspace ™ <unknown> app key technical problem face find minimal number hyperspace ™ highways one need use travel planet $$$ a $$$ planet $$$ b $$$ problem easy bubble cup a harder task : program need $$$ q $$$ pair planets first line contain three positive integers $$$ n $$$ ( $$$ 1\leq n\leq 100\,000 $$$ ) $$$ m $$$ ( $$$ 1\leq m\leq 500\,000 $$$ ) $$$ q $$$ ( $$$ 1\leq <unknown> 200\,000 $$$ ) denote number planets number hyperspace ™ highways number query respectively follow m line contain a highway : highway $$$ i $$$ give two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i < v_i \leq n $$$ ) mean planets $$$ u_i $$$ $$$ v_i $$$ connect a hyperspace ™ highway guarantee network planets hyperspace ™ highways form a simple connect graph follow $$$ q $$$ line contain a query : query $$$ j $$$ give two integers $$$ a_j $$$ $$$ b_j $$$ $$$ ( 1 \leq a_j < b_j \leq n ) $$$ mean interest minimal number hyperspace ™ highways one need take travel planet $$$ a_j $$$ planet $$$ b_j $$$ output $$$ q $$$ line : $$$ j $$$ -th line output contain minimal number hyperspace ™ highways one need take travel planet $$$ a_j $$$ planet $$$ b_j $$$ graph second sample :",['dfs and similar'],2300.0
1263/D,one unknown hacker want get admin 's password atforces test system get problems next contest achieve sneak administrator 's office steal a piece paper a list $$$ n $$$ passwords — string consist small latin letter hacker go home start prepare hack atforces find system contain passwords steal list system determine <unknown> passwords $$$ a $$$ $$$ b $$$ follow : a password set system equivalent one apply access system user access system example list contain passwords ` ` a '' ` ` b '' ` ` ab '' ` ` d '' passwords ` ` a '' ` ` b '' ` ` ab '' equivalent password ` ` d '' equivalent password list word : one password list admin 's password test system help hacker calculate minimal number passwords require guarantee access system keep mind hacker know password set system first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number passwords list next $$$ n $$$ line contain passwords list – non - empty string $$$ s_i $$$ length $$$ 50 $$$ letter passwords may equal guarantee total length passwords exceed $$$ 1000000 $$$ letter consist lowercase latin letter a single line print minimal number passwords use allow guarantee access system second example hacker need use passwords access system,['dfs and similar'],1500.0
1242/B,"ujan a lot useless stuff <unknown> a <unknown> part math <unknown> : time sort time find old <unknown> graph theory notebook a description a graph undirected weight graph $$$ n $$$ vertices a complete graph : pair vertices connect edge weight edge either $$$ 0 $$$ $$$ 1 $$$ ; exactly $$$ m $$$ edge weight $$$ 1 $$$ others weight $$$ 0 $$$ since ujan n't really want organize note decide find weight minimum span tree graph ( weight a span tree sum edge . ) find answer ujan stop <unknown> ? first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ 0 \leq m \leq \min ( \frac { n ( n-1 ) } { 2 } , 100000 ) $$$ ) number vertices number edge weight $$$ 1 $$$ graph $$$ i $$$ -th next $$$ m $$$ line contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a_i b_i \leq n $$$ $$$ a_i \neq b_i $$$ ) endpoints $$$ i $$$ -th edge weight $$$ 1 $$$ guarantee edge appear twice input output a single integer weight minimum span tree graph graph first sample show dash edge weight $$$ 0 $$$ edge weight $$$ 1 $$$ one minimum span tree highlight orange total weight $$$ 2 $$$ second sample edge weight $$$ 0 $$$ span tree total weight $$$ 0 $$$",['dfs and similar'],1900.0
1062/F,"$$$ n $$$ cities kingdom $$$ x $$$ number $$$ 1 $$$ $$$ n $$$ people travel cities one - way roads a passenger jatc find weird city $$$ u $$$ ca n't start a trip return back use roads kingdom , kingdom view acyclic graph <unknown> travel system jatc decide meet king ask something response king say upgrade cities make easier travel budget king upgrade cities important semi - important a city $$$ u $$$ call important every city $$$ v \neq u $$$ either a path $$$ u $$$ $$$ v $$$ a path $$$ v $$$ $$$ u $$$ a city $$$ u $$$ call semi - important important destroy exactly one city $$$ v \neq u $$$ $$$ u $$$ become important king start act soon find cities please help speed process first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 300\,000 $$$ $$$ 1 \le m \le 300\,000 $$$ ) — number cities number one - way roads next $$$ m $$$ line describe road system kingdom contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \neq v_i $$$ ) denote one - way road $$$ u_i $$$ $$$ v_i $$$ guarantee <unknown> ' roads make acyclic graph n't contain multiple edge self - loops print a single integer — number cities king upgrade first example : second example important cities $$$ 1 $$$ $$$ 4 $$$ semi - important cities $$$ 2 $$$ $$$ 3 $$$",['dfs and similar'],2900.0
1067/B,someone give a strange birthday present ivan hedgehog — connect undirected graph one vertex degree least $$$ 3 $$$ ( call center ) vertices degree 1 . ivan think hedgehog bore decide make $$$ k $$$ -multihedgehog let us define $$$ k $$$ -multihedgehog follow : <unknown> $$$ k $$$ -multihedgehog a tree ivan make $$$ k $$$ -multihedgehog sure make mistake ask check tree indeed $$$ k $$$ -multihedgehog first line input contain $$$ 2 $$$ integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 10^ { 5 } $$$ $$$ 1 \le k \le 10^ { 9 } $$$ ) — number vertices hedgehog parameter next $$$ n-1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u \ \ v \le n ; \ \ u \ne v $$$ ) — indices vertices connect edge guarantee give graph a tree print ` ` yes '' ( without quote ) give graph $$$ k $$$ -multihedgehog ` ` '' ( without quote ) <unknown> - <unknown> first example look like : center vertex $$$ 13 $$$ <unknown> create last step : [ 4 ( center ) 1 2 3 ] [ 6 ( center ) 7 8 9 ] [ 5 ( center ) 10 11 12 13 ] tree second example a hedgehog degree center least $$$ 3 $$$,['dfs and similar'],1800.0
842/E,nikita play a new computer game m level game begin level a new class appear game ; class a child - class class yi ( yi call parent - class new class ) thus class form a tree initially one class index 1 . change class neighbour ( child - class parent - class ) tree cost 1 coin change class back cost change class a class b equal total cost class change path a b class tree suppose i -th level maximum cost change one class another x. level output number class class exist class y distance class y exactly x. first line contain one integer number m — number query ( 1 ≤ m ≤ 3·105 ) next m line contain description query i -th line ( 1 ≤ i ≤ m ) describe i -th level contain integer yi — index parent - class class index i + 1 ( 1 ≤ yi ≤ i ) suppose i -th level maximum cost change one class another x. level output number class class exist class y distance class y exactly x,['dfs and similar'],2800.0
832/D,misha grisha funny boys like use new underground underground n station connect n - 1 rout route connect two station possible reach every station boys decide fun come a plan namely day morning misha ride underground station s station f shortest path draw <unknown> <unknown> text ` ` misha '' every station pass ( include s f ) day even grisha ride station t station f shortest path count station misha 's text night underground workers wash texts underground clean boys already choose three station a b c several follow days one station s day another station f remain station t. become interest choose station s f t number grisha count large possible ask help first line contain two integers n q ( 2 ≤ n ≤ 105 1 ≤ q ≤ 105 ) — number station number days second line contain n - 1 integers p2 p3 ... pn ( 1 ≤ pi ≤ n ) integer pi mean a route station pi i. guarantee 's possible reach every station next q line contain three integers a b c ( 1 ≤ a b c ≤ n ) — ids station choose boys day note ids could print q line i - th line print maximum possible number grisha get count station s t f choose optimally three station i - th day first example first day s = 1 f = 2 t = 3 misha would go route 1 2 grisha would go route 3 1 2 . would see text station 1 2 . second day s = 3 f = 2 t = 3 boys would go route 3 1 2 . grisha would see text 3 station second <unknown> s = 1 f = 3 t = 2 misha would go route 1 2 3 grisha would go route 2 3 would see text station,['dfs and similar'],1900.0
1370/F1,"note difference easy hard version constraint number query make hack versions problem solve interactive problem give a tree consist $$$ n $$$ nod number integers $$$ 1 $$$ $$$ n $$$ ayush ashish choose two secret distinct nod tree need find nod make follow query : recall a tree a connect graph without cycle distance two nod define number edge simple path formally let 's define two hide nod $$$ s $$$ $$$ f $$$ one query provide set nod $$$ \ { a_1 a_2 \ldots a_c\ } $$$ tree a result get two number $$$ a_i $$$ $$$ dist ( a_i s ) + dist ( a_i f ) $$$ node $$$ a_i $$$ node provide set number $$$ dist ( a_i s ) + dist ( a_i f ) $$$ minimal ask $$$ 14 $$$ query first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10 ) $$$ — number test case please note interaction process organize first line test case consist a single integer $$$ n $$$ $$$ ( 2 \le n \le 1000 ) $$$ — number nod tree next $$$ n - 1 $$$ line consist two integers $$$ u $$$ $$$ v $$$ $$$ ( 1 \le u v \le n u \ne v ) $$$ — edge tree ask a query print a single line : query receive two integers $$$ x $$$ $$$ d $$$ — node ( among query nod ) minimum sum distance hide nod sum distance node hide nod subset nod query invalid exceed number query get $$$ x = d = -1 $$$ case terminate program immediately guess hide nod print a single line ` ` ! ` ` ( without quote ) follow two integers range $$$ [ 1 n ] $$$ — hide nod output hide nod order , read a string guess nod correctly receive string ` ` correct '' case continue solve remain test case terminate program test case solve otherwise receive string ` ` incorrect '' case terminate program immediately guess hide nod count towards number query ask interactor adaptive hide nod change query forget read string ` ` correct '' / ` ` incorrect '' guess hide nod need solve test case receive input next test case limit $$$ 14 $$$ query apply test case entire input print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack solution use follow test format : first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 10 ) $$$ — number test case description test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 2 \le n \le 1000 ) $$$ — number nod tree second line contain two distinct integers range $$$ [ 1 n ] $$$ — hide nod next $$$ n - 1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ $$$ ( 1 \le u v \le n u \ne v ) $$$ — edge tree tree first test show hide nod $$$ 1 $$$ $$$ 3 $$$",['dfs and similar'],2400.0
1118/F1,give undirected tree $$$ n $$$ vertices vertices color blue color red uncolored guarantee tree contain least one red vertex least one blue vertex choose edge remove tree tree fall apart two connect components let 's call edge nice neither result components contain vertices red blue color many nice edge give tree ? first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 300000 $$$ ) — number vertices tree second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 2 $$$ ) — color vertices $$$ a_i = 1 $$$ mean vertex $$$ i $$$ color red $$$ a_i = 2 $$$ mean vertex $$$ i $$$ color blue $$$ a_i = 0 $$$ mean vertex $$$ i $$$ uncolored $$$ i $$$ -th next $$$ n - 1 $$$ line contain two integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ $$$ v_i \ne u_i $$$ ) — edge tree guarantee give edge form a tree guarantee tree contain least one red vertex least one blue vertex print a single integer — number nice edge give tree tree first example : nice edge edge $$$ ( 2 4 ) $$$ remove make tree fall apart components $$$ \ { 4\ } $$$ $$$ \ { 1 2 3 5\ } $$$ first component include a red vertex second component include blue vertices uncolored vertices tree second example : every edge nice tree third example : edge $$$ ( 1 3 ) $$$ split components $$$ \ { 1\ } $$$ $$$ \ { 3 2\ } $$$ latter one include red blue vertex thus edge n't nice edge $$$ ( 2 3 ) $$$ split components $$$ \ { 1 3\ } $$$ $$$ \ { 2\ } $$$ former one include red blue vertex thus edge also n't nice answer 0,['dfs and similar'],1800.0
1143/C,give a root tree vertices numerate $$$ 1 $$$ $$$ n $$$ a tree a connect graph without cycle a root tree a special vertex name root ancestors vertex $$$ i $$$ vertices path root vertex $$$ i $$$ except vertex $$$ i $$$ parent vertex $$$ i $$$ nearest vertex $$$ i $$$ ancestor $$$ i $$$ vertex a child parent give tree parent vertex $$$ i $$$ vertex $$$ p_i $$$ root value $$$ p_i $$$ $$$ -1 $$$ notice vertices respect others particular $$$ c_i = 1 $$$ vertex $$$ i $$$ respect ancestors $$$ c_i = 0 $$$ respect decide delete vertices tree one one step select a non - root vertex respect parent none children respect several vertices select one smallest number delete vertex $$$ v $$$ children $$$ v $$$ become connect parent $$$ v $$$ vertices match criteria deletion stop process print order delete vertices note order unique first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number vertices tree next $$$ n $$$ line describe tree : $$$ i $$$ -th line contain two integers $$$ p_i $$$ $$$ c_i $$$ ( $$$ 1 \le p_i \le n $$$ $$$ 0 \le c_i \le 1 $$$ ) $$$ p_i $$$ parent vertex $$$ i $$$ $$$ c_i = 0 $$$ vertex $$$ i $$$ respect parent $$$ c_i = 1 $$$ vertex $$$ i $$$ respect parent root tree $$$ -1 $$$ instead parent index also $$$ <unknown> $$$ root guarantee value $$$ p_i $$$ define a root tree $$$ n $$$ vertices case least one vertex delete print line contain indices vertices delete order delete otherwise print a single integer $$$ -1 $$$ deletion process first example follow ( see picture vertices $$$ <unknown> $$$ yellow ) : second example n't need delete vertex : third example tree change way :,['dfs and similar'],1400.0
1144/F,give a connect undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge self - loops multiple edge give graph direct edge a way obtain direct graph contain paths length two greater ( length path denote number traverse edge ) first line contain two integer number $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ n - 1 \le m \le 200000 $$$ ) — number vertices edge respectively follow $$$ m $$$ line contain edge : edge $$$ i $$$ give a pair vertices $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \ne v_i $$$ ) multiple edge give graph i. e. pair ( $$$ u_i v_i $$$ ) pair ( $$$ u_i v_i $$$ ) ( $$$ v_i u_i $$$ ) list edge also guarantee give graph connect ( a path pair vertex give graph ) impossible direct edge give graph a way obtain direct graph contain paths length least two print ` ` '' first line otherwise print ` ` yes '' first line print suitable orientation edge : a binary string ( string consist ' 0 ' ' 1 ' ) length $$$ m $$$ $$$ i $$$ -th element string ' 0 ' $$$ i $$$ -th edge graph direct $$$ u_i $$$ $$$ v_i $$$ ' 1 ' otherwise edge number order give input picture correspond first example : one possible answer :,['dfs and similar'],1700.0
1167/C,"social network $$$ n $$$ users communicate $$$ m $$$ group friends let 's analyze process distribute news users initially user $$$ x $$$ receive news source send news friends ( two users friends least one group belong group ) friends continue send news friends , process end pair friends one know news another one n't know user $$$ x $$$ determine number users know news initially user $$$ x $$$ start distribute first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 500000 $$$ ) — number users number group friends respectively $$$ m $$$ line follow describe a group friends $$$ i $$$ -th line begin integer $$$ k_i $$$ ( $$$ 0 \le k_i \le n $$$ ) — number users $$$ i $$$ -th group $$$ k_i $$$ distinct integers follow denote users belong $$$ i $$$ -th group guarantee $$$ \sum \limits _ { i = 1 } ^ { m } k_i \le 500000 $$$ print $$$ n $$$ integers $$$ i $$$ -th integer equal number users know news user $$$ i $$$ start distribute",['dfs and similar'],1400.0
1176/E,give undirected unweighted connect graph consist $$$ n $$$ vertices $$$ m $$$ edge guarantee self - loops multiple edge give graph task choose $$$ \lfloor\frac { n } { 2 } \rfloor $$$ vertices graph <unknown> vertex adjacent ( word connect edge ) least one choose vertices guarantee answer exist multiple answer print give multiple independent query answer first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200000 $$$ ) — number query $$$ t $$$ query follow first line query contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ n - 1 \le m \le min ( 2 \cdot 100000 \frac { n ( n-1 ) } { 2 } ) $$$ ) — number vertices number edge respectively follow $$$ m $$$ line denote edge : edge $$$ i $$$ represent a pair integers $$$ v_i $$$ $$$ u_i $$$ ( $$$ 1 \le v_i u_i \le n $$$ $$$ u_i \ne v_i $$$ ) indices vertices connect edge self - loops multiple edge give graph i. e. pair ( $$$ v_i u_i $$$ ) pair ( $$$ v_i u_i $$$ ) ( $$$ u_i v_i $$$ ) list edge pair ( $$$ v_i u_i $$$ ) condition $$$ v_i \ne u_i $$$ satisfy guarantee give graph connect guarantee $$$ \sum m \le 200000 $$$ query query print two line first line print $$$ k $$$ ( $$$ 1 \le \lfloor\frac { n } { 2 } \rfloor $$$ ) — number choose vertices second line print $$$ k $$$ distinct integers $$$ c_1 c_2 \dots c_k $$$ order $$$ c_i $$$ index $$$ i $$$ -th choose vertex guarantee answer exist multiple answer print first query vertex pair vertices <unknown> note n't minimize number choose vertices second query two vertices enough ( vertices $$$ 2 $$$ $$$ 4 $$$ ) three also ok,['dfs and similar'],1700.0
1184/E2,a successful field test heidi consider deploy a trap along corridor possibly first one want avoid meet daleks inside time <unknown> <unknown> <unknown> consider place trap along corridors go use accord current daleks ' plan – use a minimum span tree corridors heidi know energy requirements different corridors different daleks a single unique plan intend use task calculate number $$$ e _ { max } ( c ) $$$ define way easy version – i.e. largest $$$ e \le 1000000000 $$$ change energy corridor $$$ c $$$ $$$ e $$$ daleks might use – every corridor heidi consider first line : number $$$ n $$$ destinations number $$$ m $$$ time corridors ( $$$ 2 \leq n \leq 100000 $$$ $$$ n - 1 \leq m \leq 1000000 $$$ ) next $$$ m $$$ line : destinations $$$ a $$$ $$$ b $$$ energy $$$ e $$$ ( $$$ 1 \leq a b \leq n $$$ $$$ a \neq b $$$ $$$ 0 \leq e \leq 1000000000 $$$ ) pair $$$ \ { a <unknown> } $$$ repeat graph guarantee connect energy requirements $$$ e $$$ distinct output $$$ <unknown> ( n-1 ) $$$ line contain one integer : $$$ e _ { max } ( c_i ) $$$ $$$ i $$$ -th corridor $$$ c_i $$$ input part current daleks ' plan ( minimum span tree ) $$$ m = n-1 $$$ need output anything,['dfs and similar'],2100.0
1209/D,legendary <unknown> john throw a huge party animals world hang house guests hungry <unknown> cow bessie bring snack ! <unknown> ! $$$ n $$$ snack flavor number integers $$$ 1 2 \ldots n $$$ bessie $$$ n $$$ snack one snack flavor every guest exactly two favorite flavor procedure eat snack go follow : help bessie minimize number sad guests line guests optimal way first line contain integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 100000 $$$ $$$ 1 \le k \le 100000 $$$ ) number snack number guests $$$ i $$$ -th follow $$$ k $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ ) favorite snack flavor $$$ i $$$ -th guest output one integer smallest possible number sad guests first example bessie order guests like : $$$ 3 1 2 4 $$$ guest $$$ 3 $$$ go first eat snack $$$ 1 $$$ $$$ 4 $$$ guest $$$ 1 $$$ go eat snack $$$ 2 $$$ snack $$$ 1 $$$ already eat similarly guest $$$ 2 $$$ go eat snack $$$ 3 $$$ snack go guest $$$ 4 $$$ sad second example one optimal order $$$ 2 1 3 5 4 $$$ guests satisfy,['dfs and similar'],1700.0
1218/H,definitely go bother another <unknown> story alice find array alice bob play stupid game time 'll get a simple plain text first let us define several things define function $$$ f $$$ array $$$ a $$$ $$$ f ( i 1 ) = a [ i ] $$$ $$$ f ( i m ) = a [ f ( i m - 1 ) ] $$$ $$$ m > 1 $$$ word value $$$ f ( i m ) $$$ represent <unknown> $$$ a [ ... a [ i ] ] $$$ apply $$$ m $$$ time give array length $$$ n $$$ non - negative integers expect give answer $$$ q $$$ query query consist two number – $$$ m $$$ $$$ y $$$ query determine many $$$ x $$$ exist $$$ f ( x m ) = y $$$ first line contain one integer $$$ n $$$ $$$ ( 1 \leq n \leq 2 \cdot 100000 ) $$$ – size array $$$ a $$$ next line contain $$$ n $$$ non - negative integers – array $$$ a $$$ $$$ ( 1 \leq a_i \leq n ) $$$ next line contain one integer $$$ q $$$ $$$ ( 1 \leq q \leq 100000 ) $$$ – number query next $$$ q $$$ line contain two integers $$$ m $$$ $$$ y $$$ $$$ ( 1 \leq m \leq 10^ { 18 } 1\leq y \leq n ) $$$ output exactly $$$ q $$$ line a single integer represent solution output solutions order query ask first query notice $$$ f ( 3 10 ) = 1 \ f ( 9 10 ) = 1 $$$ $$$ f ( 10 10 ) = 1 $$$ second query $$$ x $$$ satisfy condition $$$ f ( x 5 ) = 7 $$$ third query $$$ f ( 5 10 ) = 6 $$$ hold fourth query $$$ f ( 3 1 ) = 1 $$$ fifth query $$$ x $$$ satisfy condition $$$ f ( x 10 ) = 8 $$$,['dfs and similar'],2900.0
1239/D,"catowice city next weekend cat contest hold however jury members contestants n't select yet $$$ n $$$ residents $$$ n $$$ cat catowice resident exactly one cat live house residents cat number integers $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th cat live house $$$ i $$$ -th resident catowice resident friendship several cat include one live house order conduct a contest least one jury member need least one cat contestant need course every jury member know none contestants contest successful 's also need number jury members plus number contestants equal $$$ n $$$ please help catowice residents select jury contestants upcoming competition determine 's impossible first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100\,000 $$$ ) number test case description $$$ t $$$ test case follow description follow : first line contain integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le m \le 1000000 $$$ ) number catowice residents number friendship pair residents cat next $$$ m $$$ line contain integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ ) denote $$$ a_i $$$ -th resident acquaintances $$$ b_i $$$ -th cat 's guarantee pair resident cat list 's guarantee every $$$ i $$$ exist a pair $$$ i $$$ -th resident $$$ i $$$ -th cat different test case separate empty line 's guarantee sum $$$ n $$$ test case $$$ 1000000 $$$ sum $$$ m $$$ test case $$$ 1000000 $$$ every test case print : second line print two integers $$$ j $$$ $$$ p $$$ ( $$$ 1 \le j $$$ $$$ 1 \le p $$$ $$$ j + p = n $$$ ) — number jury members number contest participants third line print $$$ j $$$ distinct integers $$$ 1 $$$ $$$ n $$$ indices residents form a jury fourth line print $$$ p $$$ distinct integers $$$ 1 $$$ $$$ n $$$ indices cat participate contest case several correct answer print first test case select first third resident a jury acquaintances a second cat select a contestant second test case select second resident a jury acquaintances a first a third cat select contestants third test case resident acquaintances cat ca n't contest together 's possible make a contest least one jury least one cat fourth test case resident acquaintances every cat 's possible make a contest least one jury least one cat",['dfs and similar'],2400.0
1147/D,"give a string $$$ s $$$ consist character ` ` 1 '' ` ` 0 '' ` ` ? ` ` first character $$$ s $$$ guarantee ` ` 1 '' let $$$ m $$$ number character $$$ s $$$ count number ways choose a pair integers $$$ a b $$$ satisfy follow : compute count modulo $$$ 998244353 $$$ first line contain a single string $$$ s $$$ ( $$$ 1 \leq |s| \leq 1\,000 $$$ ) $$$ s $$$ consist character ` ` 1 '' ` ` 0 '' ` ` ? ` ` guarantee first character $$$ s $$$ a ` ` 1 '' print a single integer count pair satisfy condition modulo $$$ 998244353 $$$ first example pair <unknown> $$$ ( 111 10001 ) ( 11 10101 ) ( 1001 <unknown> ) $$$",['dfs and similar'],2400.0
720/B,tree a connect undirected graph cycle edge cactus a connect undirected graph without loop parallel edge edge belong one cycle vasya edge cactus edge graph color vasya would like remove minimal number edge way cactus turn a tree vasya want make a way edge many different color result tree possible help find many different color result tree first line contain two integers : n m ( 2 ≤ n ≤ 10 000 ) — number vertices number edge vasya 's graph respectively follow m line contain three integers : u v c ( 1 ≤ u v ≤ n u ≠ v 1 ≤ c ≤ m ) — number vertices connect correspond edge color guarantee describe graph indeed edge cactus output one integer : maximal number different color result tree,['dfs and similar'],2400.0
717/E,"i see a pink boar i want paint black black boars look much <unknown> <unknown> pink ones since jaggy become ruler forest try best improve diplomatic relations forest region nearby ones <unknown> however request much return peace two regions realize resort <unknown> a delegate diplomatic relations a neighbor region visit jaggy ’ s forest see a whole bunch black boars might suddenly change mind attack jaggy black boars really <unknown> , jaggy ’ s forest represent a tree ( connect graph without cycle ) n vertices vertex represent a boar color either black pink jaggy send a squirrel travel forest paint boars black squirrel however quite <unknown> train traverse graph change color every vertex visit regardless initial color : pink vertices become black black vertices become pink since jaggy busy plan squirrel ’ s route need help want construct a walk tree start vertex 1 end vertices black a walk a sequence vertices every consecutive pair edge a tree first line input contain integer n ( 2 ≤ n ≤ 200 000 ) denote number vertices tree follow n line contain n integers represent color nod i - th integer 1 i - th vertex black - 1 i - th vertex pink next n - 1 line contain two integers represent index vertices connect edge vertices number start 1 . output path a squirrel : output a sequence visit nod ' index order visit case nod initially black print 1 . solution guarantee exist multiple solutions problem output provide length sequence longer 107 . begin squirrel node 1 color black next step follow :",['dfs and similar'],1900.0
715/C,zs coder a large tree represent undirected connect graph n vertices number 0 n - 1 n - 1 edge a single nonzero digit write edge one day zs coder bore decide investigate properties tree choose a positive integer m coprime 10 i.e   zs consider order pair distinct vertices ( u v ) interest would follow shortest path vertex u vertex v write digits encounter path order get a decimal <unknown> integer divisible m. formally zs consider order pair distinct vertices ( u v ) interest follow state true : help zs coder find number interest pair ! first line input contain two integers n m ( 2 ≤ n ≤ 100 000 1 ≤ m ≤ 109 ) — number vertices number zs choose respectively next n - 1 line contain three integers i - th contain ui vi wi denote edge vertices ui vi digit wi write ( 0 ≤ ui vi < n 1 ≤ wi ≤ 9 ) print a single integer — number interest ( zs coder 's consideration ) pair first sample case interest pair ( 0 4 ) ( 1 2 ) ( 1 5 ) ( 3 2 ) ( 2 5 ) ( 5 2 ) ( 3 5 ) number form pair 14 21 <unknown> <unknown> 7 7 <unknown> respectively multiples 7 . note ( 2 5 ) ( 5 2 ) consider different second sample case interest pair ( 4 0 ) ( 0 4 ) ( 3 2 ) ( 2 3 ) ( 0 1 ) ( 1 0 ) ( 4 1 ) ( 1 4 ) 6 pair give number 33 2 give number <unknown> multiples 11,['dfs and similar'],2700.0
345/D,a chain letter a kind a message <unknown> recipient forward many contact possible usually kind <unknown> explanation course a <unknown> n't believe friends know today one letter go around want know many time 'll receive — course 'll send ! give array string f n elements describe contact n - 1 friends : j - th character i - th string ( f [ i ] [ j ] ) ` ` 1 '' people i j send message ` ` 0 '' otherwise person 1 start send letter contact ; every person receive letter first time send contact person n n't forward letter receive calculate number copy letter 'll receive first line input contain integer n ( 2 ≤ n ≤ 50 ) — number people involve next n follow line contain elements f string length n. character f either ` ` 0 '' ` ` 1 '' 's guarantee two follow equations hold : f [ i ] [ j ] = f [ j ] [ i ] f [ i ] [ i ] = 0 i j ( 1 ≤ i j ≤ n ) output a single integer — number copy letter receive eventually first case everybody send letter everyone get copy three friends second case n't know people n't bother <unknown> stuff third case two friends send copy letter third friend n't know unaffected,['dfs and similar'],2200.0
1254/E,"christmas <unknown> door <unknown> bob prepare a <unknown> present long - time second best friend <unknown> chocolate box lame decide decorate a tree instead bob 's tree represent undirected connect graph $$$ n $$$ nod ( number $$$ 1 $$$ $$$ n $$$ ) $$$ n-1 $$$ edge initially bob place a decoration label $$$ i $$$ node $$$ i $$$ $$$ 1 \le i \le n $$$ however a simple arrangement lame decide shuffle decorations a bite formally bob follow step : finish bob seem satisfy arrangement go sleep next morning bob wake find beautiful arrangement <unknown> ! last night bob 's younger brother bobo drop decorations floor play tree fortunately decorations lose bob repair tree time however completely forget tree look like yesterday therefore give label decorations still tree bob want know number possible configurations tree result quite large bob happy output result modulo $$$ 1000000007 $$$ ( $$$ 1000000000 + 7 $$$ ) note possible exist possible configurations first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 500\,000 $$$ ) — number nod next $$$ n - 1 $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \leq u v \leq n $$$ ) denote edge connect two nod $$$ u $$$ $$$ v $$$ guarantee give edge form a tree last line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le n $$$ ) $$$ i $$$ $$$ a_i = 0 $$$ mean decoration node $$$ i $$$ drop floor otherwise $$$ a_i $$$ label decoration node $$$ i $$$ guarantee label appear output number possible configurations modulo $$$ 1000000007 $$$ ( $$$ 1000000000 + 7 $$$ ) first example possible configurations tree $$$ [ 2 4 1 3 ] $$$ $$$ [ 3 4 2 1 ] $$$ second example note $$$ 4 ! = 24 $$$ possible permutations edge result a possible configuration $$$ 12 $$$ different configurations third example easy see decoration $$$ 1 $$$ stay node $$$ 1 $$$ swap",['dfs and similar'],3300.0
160/D,give a connect weight undirected graph without loop multiple edge let us remind a graph 's span tree define acyclic connect subgraph give graph include graph 's vertexes weight a tree define sum weight edge give tree contain minimum span tree ( mst ) a graph define graph 's span tree minimum possible weight connect graph obviously exist minimum span tree general case a graph 's minimum span tree unique task determine follow edge give graph : whether either include mst include least one mst include mst first line contain two integers n m ( 2 ≤ n ≤ 105 ) — number graph 's vertexes edge correspondingly follow m line contain three integers — description graph 's edge ` ` ai bi wi '' ( 1 ≤ ai bi ≤ n 1 ≤ wi ≤ 106 ai ≠ bi ) ai bi number vertexes connect i - th edge wi edge 's weight guarantee graph connect n't contain loop multiple edge print m line — answer edge i - th edge include mst print ` ` '' ; i - th edge include least one mst print ` ` least one '' ; i - th edge n't include mst print ` ` none '' print answer edge order edge specify input second sample mst unique give graph : contain two first edge third sample two edge form mst give graph mean edge include least one mst,['dfs and similar'],2300.0
183/C,give a direct graph g n vertices m arc ( multiple arc self - loops allow ) paint vertex graph one k ( k ≤ n ) color way arc graph lead a vertex u vertex v vertex v paint next color color use paint vertex u. color number cyclically 1 k. mean color i ( i < k ) next color color i + 1 . addition next color color k color 1 . note k = 1 next color color 1 color 1 . task find print largest possible value k ( k ≤ n ) 's possible color g describe k color note n't necessarily use k color ( color i necessarily exist a vertex color color i ) first line contain two space - separated integers n m ( 1 ≤ n m ≤ 105 ) denote number vertices number arc give digraph respectively m line follow line contain two space - separated integers ai bi ( 1 ≤ ai bi ≤ n ) mean i - th arc go vertex ai vertex bi multiple arc self - loops allow print a single integer — maximum possible number color use paint digraph ( i.e k describe problem statement ) note desire value k must satisfy inequality 1 ≤ k ≤ n. first example k = 2 picture depict two color ( arrows denote next color color ) k = 2 a possible way paint graph follow prove larger value k exist test case second example 's picture k = 5 color a possible color graph : third example 's picture k = 3 color a possible color graph :,['dfs and similar'],2200.0
187/C,<unknown> pmp qualify icpc world finals <unknown> <unknown> team excursion sun island park snow <unknown> art <unknown> pmp get back bus leave park really big know find park n intersections number 1 n. m bidirectional roads connect pair intersections k intersections icpc volunteer help team show way destinations locations volunteer fix distinct pmp ask a volunteer way bus station he / she tell whole path park fully cover ice snow everywhere look almost pmp memorize q intersections question ( exclude intersection currently stand ) always tell volunteer weak memory direct path length ( number roads ) q lead bus station volunteer guide pmp another volunteer ( q intersections away course ) icpc volunteer know area well always tell pmp best way exist a way bus station pmp definitely find pmp 's initial location intersection s bus intersection t. always a volunteer intersection s. job find minimum q guarantee pmp find bus first line contain three space - separated integers n m k ( 2 ≤ n ≤ 105 0 ≤ m ≤ 2·105 1 ≤ k ≤ n ) — number intersections roads volunteer respectively next line contain k distinct space - separated integers 1 n inclusive — number cities volunteer locate next m line describe roads i - th line contain two space - separated integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) — two intersections i - th road connect one road two intersections last line input contain two space - separated integers s t ( 1 ≤ s t ≤ n s ≠ t ) — initial location pmp location bus might always possible reach t s. guarantee always a volunteer intersection s. print line answer problem — minimum value q guarantee pmp find bus pmp reach bus output -1 instead first sample illustrate blue intersections volunteer locate pmp go path dash line reach bus q = 3 : second sample pmp use intersection 6 intermediate intersection thus answer 3,['dfs and similar'],2000.0
190/C,"vasya use accountant war begin one know operate a computer assign programmer know program often store set integers example a problem a weight direct graph edge represent three integers : number start vertex number final vertex edge 's weight , vasya try represent characteristics a recently invent robot program face follow problem vasya a programmer ask friend gena convenient way store n integers gena use code language x -- use type occur language let 's define a ` ` type '' language x -- : formally : type : = int | pair < type type > example gena use follow type graph edge : pair < int pair < int int > > gena please help vasya dictate vasya a type language x -- store n integers unfortunately gena a hurry omit punctuation gena already leave vasya ca n't find correct punctuation result a type language x -- however hard try help vasya add punctuation mark receive valid type language x -- otherwise say task impossible perform first line contain a single integer n ( 1 ≤ n ≤ 105 ) show many number type dictate gena contain second line contain space - separated word say gena either ` ` pair '' ` ` int '' ( without quote ) guarantee total number word exceed 105 among word gena say exactly n word ` ` int '' possible add punctuation mark get a correct type language x -- a result print a single line represent result type otherwise print ` ` error occur '' ( without quote ) inside record a type extra space character guarantee type exist unique note print type dictate gena ( type exist ) type contain n value",['dfs and similar'],1500.0
131/D,a subway scheme classic berland cities represent a set n station connect n passages connect exactly two station pass others besides classic scheme one get station one along passages passages use move directions pair station one passage berland mathematicians recently prove a <unknown> state classic scheme a ringroad one ringroad word classic scheme one find scheme consist station ( two neighbour ones link a passage ) cycle n't contain station invention a powerful social impact station could compare accord distance ringroad example a citizen could say ` ` i live three passages ringroad '' another one could reply ` ` loser i live one passage ringroad '' internet soon get fill applications promise count distance station ringroad ( send a text message a short number ... ) berland government decide put end <unknown> start control situation request write a program determine <unknown> ringroad station city subway scheme first line contain integer n ( 3 ≤ n ≤ 3000 ) n number station ( train time ) subway scheme n line contain descriptions train one per line line contain a pair integers xi yi ( 1 ≤ xi yi ≤ n ) represent presence a passage station xi station yi station number 1 n arbitrary order guarantee xi ≠ yi pair station contain one passage passages use travel ways guarantee give description represent a classic subway scheme print n number separate number space i - th one equal distance i - th station ringroad ringroad station print number 0,['dfs and similar'],1600.0
196/B,"' ve get a rectangular n × m - cell maze cell either passable a wall ( impassable ) a little boy find maze cyclically tile a plane plane become infinite maze plane cell ( x y ) a wall cell a wall problem a remainder divide number a number b. little boy stand cell plane wonder whether walk infinitely far away start position cell ( x y ) go one follow cells : ( x y - 1 ) ( x y + 1 ) ( x - 1 y ) ( x + 1 y ) provide cell go a wall first line contain two space - separated integers n m ( 1 ≤ n m ≤ <unknown> ) — height width maze boy use cyclically tile plane next n line contain m character — description <unknown> character either a ` ` # '' mark a wall a ` ` ` ` mark a passable cell ` ` s '' mark little boy 's start point start point a passable cell guarantee character ` ` s '' occur exactly input print ` ` yes '' ( without quote ) little boy walk infinitely far start point otherwise print ` ` '' ( without quote ) first sample little boy go infinitely long a ` ` clear path '' go vertically need repeat follow step infinitely : , leave , right , second sample vertical path block path leave n't work — next ` ` copy '' maze trap boy",['dfs and similar'],2000.0
263/D,' ve get a undirected graph g consist n nod consider nod graph index integers 1 n. know node graph g connect edge least k nod graph task find give graph a simple cycle length least k + 1 . a simple cycle length d ( d > 1 ) graph g a sequence distinct graph nod v1 v2 ... vd nod v1 vd connect edge graph also integer i ( 1 ≤ i < d ) nod vi vi + 1 connect edge graph first line contain three integers n m k ( 3 ≤ n m ≤ 105 ; 2 ≤ k ≤ n - 1 ) — number nod graph number graph 's edge lower limit degree graph node next m line contain pair integers i - th line contain integers ai bi ( 1 ≤ ai bi ≤ n ; ai ≠ bi ) — index graph nod connect i - th edge guarantee give graph n't contain multiple edge self - loops guarantee node graph connect edge least k nod graph first line print integer r ( r ≥ k + 1 ) — length find cycle next line print r distinct integers v1 v2 ... vr ( 1 ≤ vi ≤ n ) — find simple cycle guarantee answer exist multiple correct answer allow print,['dfs and similar'],1800.0
277/A,` ` <unknown> '' company get n employees employees use m approve official languages formal correspondence languages number integers 1 m. employee list languages know list could empty i. e. employee may know official languages employees will learn number official languages long company pay lessons a study course one language one employee cost 1 <unknown> find minimum sum money company need spend employee could correspond one ( correspondence indirect i. e. employees help translate ) first line contain two integers n m ( 2 ≤ n m ≤ 100 ) — number employees number languages n line follow — employee 's language list begin i - th line integer ki ( 0 ≤ ki ≤ m ) — number languages i - th employee know next i - th line contain ki integers — aij ( 1 ≤ aij ≤ m ) — identifiers languages i - th employee know guarantee identifiers one list distinct note employee may know zero languages number line separate single space print a single integer — minimum amount money pay end every employee could write a letter every one ( employees help translate ) second sample employee 1 learn language 2 employee 8 learn language 4 . third sample employee 2 must learn language 2,['dfs and similar'],1400.0
288/D,little penguin polo get a tree — a non - <unknown> connect acyclic graph contain n nod n - 1 edge consider tree nod number integers 1 n. today polo wonder find number pair paths n't common nod formally find number group four integers a b c d : shortest path <unknown> two nod path shortest number edge help polo solve problem first line contain integer n ( 1 ≤ n ≤ <unknown> ) — number tree nod follow n - 1 line contain a pair integers ui vi ( 1 ≤ ui vi ≤ n ; ui ≠ vi ) — i - th edge tree guarantee give graph a tree a single line print a single integer — answer problem please use % lld specificator read write 64 - bit number с++ recommend use cin cout stream % i64d specificator,['dfs and similar'],2400.0
320/B,problem moment a set intervals move interval ( a b ) set interval ( c d ) set c < a < d c < b < d. also a path interval i1 set interval i2 set a sequence successive move start i1 reach i2 program handle query follow two type : answer query note initially empty set intervals first line input contain integer n denote number query ( 1 ≤ n ≤ 100 ) follow line contain a query describe number input integers n't exceed 109 absolute value 's guarantee query correct query second type print ` ` yes '' ` ` '' a separate line depend answer,['dfs and similar'],1500.0
325/C,piegirl find a monster a book monsters pies read book find n type monsters i d 1 n. fee a pie a monster monster split number monsters ( possibly zero ) least one colorful diamond monsters may able split multiple ways begin piegirl exactly one monster begin feed monster a pie continue feed pies monsters monsters leave collect diamonds create give a list split rule describe way various monsters split every monster split least one way a monster split multiple ways time split piegirl choose way split monster determine smallest largest number diamonds piegirl possibly collect initially a single instance monster piegirl unlimited supply pies first line contain two integers : m n ( 1 ≤ m n ≤ 105 ) number possible split number different monster type follow m line contain a split rule split rule start integer ( a monster i d ) mi ( 1 ≤ mi ≤ n ) a positive integer li indicate number monsters diamonds current monster split follow li integers positive integers represent a monster i d -1 represent a diamond monster least one split rule split rule least one diamond sum li across split rule 105 . monster order ids print a line two integers : smallest largest number diamonds possibly collect start monster piegirl possibly end a state without monsters print -1 smallest largest value collect arbitrarily large number diamonds print -2 largest number diamonds number output exceed 314000000 ( finite ) print 314000000 instead number,['dfs and similar'],2600.0
329/B,"'re a mikemon breeder currently middle journey become a mikemon master current obstacle go <unknown> biridian forest <unknown> biridian forest a two - dimensional grid consist r row c columns cell biridian forest may contain a tree may vacant a vacant cell may occupy zero mikemon breeders ( may also breeders forest ) mikemon breeders ( include ) enter cells tree one cells designate exit cell initial grid include initial position exit cell initial position breeders give 's example grid ( first example ) : <unknown> ( include ) may move forest a single move breeders may perform one follow action : time make a single move breeders simultaneously make a single move ( choice move make may different breeders ) mikemon <unknown> t ( t > 0 ) mikemon breeders locate cell exactly t mikemon battle ensue time ( since battle t breeders ) battle t breeders leave forest <unknown> respective <unknown> note moment leave forest mikemon battle ensue even another mikemon breeder move exit cell immediately also note a battle happen another breeders — battle two breeders ( may multiple breeders <unknown> a single cell ) <unknown> would like leave forest order make a sequence move end a move final type make move however post sequence personal virtual idol blog , follow sequence move <unknown> goal <unknown> post sequence blog breeders know exact sequence move even make first move move way guarantee a mikemon battle possible breeders could n't battle nothing <unknown> minimum number mikemon battle must participate assume pick sequence move minimize number note require minimize number move make first line consist two integers : r c ( 1 ≤ r c ≤ 1000 ) denote number row number columns biridian forest next r row depict a row map character represent content a single cell : guarantee possible go start position exit cell a sequence move a single line denote minimum possible number mikemon battle participate pick a strategy minimize number follow picture illustrate first example blue line denote a possible sequence move post blog : three breeders leave side map able battle — lone breeder simply stay place come two breeders move lone breeder stay come three breeders right a way battle stay place second example post sequence blog : 's happen first move one cell right , two breeders directly right exit simultaneously move leave three breeder battle nothing end cell 2 breeders 2 mikemon battle conduct battle opponents leave forest finally make another move leave forest",['dfs and similar'],1500.0
164/A,life easy perfectly common variable name vasya <unknown> go either assign a value simply ignore use ! vasya 's life go state a program state vasya either use ( example calculate value another variable ) assign a value ignore state direct ( orient ) transition a path a sequence state v1 v2 ... vx 1 ≤ i < x exist a transition vi vi + 1 . vasya 's value state v interest world exist path p1 p2 ... pk pi = v i ( 1 ≤ i ≤ k ) state p1 vasya get assign a value state pk vasya use state pi ( except p1 ) vasya get assign a value help vasya find state vasya 's value interest world first line contain two space - separated integers n m ( 1 ≤ n m ≤ 105 ) — number state transition correspondingly second line contain space - separated n integers f1 f2 ... fn ( 0 ≤ fi ≤ 2 ) fi describe action perform upon vasya state i : 0 represent ignore 1 — assign a value 2 — use next m line contain space - separated pair integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) pair represent transition state number ai state number bi two state number transition print n integers r1 r2 ... rn separate space new line number ri equal 1 vasya 's value state i interest world otherwise equal 0 . state number 1 n order describe input first sample program state use make path value vasya interest world 1 2 3 4 ; include state vasya 's value interest world second sample path vasya 's value interest world — 1 3 ; state 2 include third sample make state path value vasya would interest world value vasya never interest world,['dfs and similar'],1700.0
173/B,` ` chamber secrets open '' — news spread around <unknown> students petrify due see basilisk dumbledore get fire harry try enter chamber secrets n't good news lord voldemort problem n't want anybody able enter chamber dark lord go busy <unknown> life <unknown> chamber secrets n × m rectangular grid cells columns a light ray ( a basilisk 's gaze ) pass columns without change direction spell make a column magic reflect light ray ( gaze ) four directions receive ray show figure basilisk locate right side lower right cell grid look leave ( direction lower leave cell ) accord legend anyone meet a basilisk 's gaze directly die immediately someone meet a basilisk 's gaze a column person get petrify know door chamber locate leave side upper leave corner grid anyone want enter look direction movement ( direction upper right cell ) position give dimension chamber location regular columns lord voldemort ask find minimum number columns need make magic anyone want enter chamber would petrify declare 's impossible secure chamber first line input contain two integer number n m ( 2 ≤ n m ≤ 1000 ) next n line contain m character character either ` ` . '' ` ` # '' represent one cell chamber grid 's ` ` . '' correspond cell empty ` ` # '' 's a regular column print minimum number columns make magic -1 's impossible figure show first sample test first sample make columns magic dragon figure represent basilisk <unknown> represent person enter chamber secrets black star show place person petrify yellow line represent basilisk gaze move columns,['dfs and similar'],1800.0
859/E,a new set desks arrive 's time ! things get quite <unknown> office ' ve put charge create a new seat <unknown> engineer desks number send a survey engineer team ask engineer number desk currently sit number desk would like sit ( may current desk ) engineer must either remain sit move desire seat indicate survey two engineer currently sit desk may two engineer sit desk new seat arrangement many seat arrangements create meet specify requirements ? answer may large compute modulo 1000000007 = 109 + 7 . input begin a line contain n ( 1 ≤ n ≤ 100000 ) number engineer n line follow contain exactly two integers i - th line contain number current desk i - th engineer number desk i - th engineer want move desks number 1 2·n guarantee two engineer sit desk print number possible assignments modulo 1000000007 = 109 + 7 . possible assignments first example :,['dfs and similar'],2100.0
228/E,berland n cities connect bidirectional roads road know whether asphalt king berland valera ii want asphalt roads berland gather a group workers every day valera choose exactly one city order crew asphalt roads come city <unknown> crew fulfil king 's order a day workers go home unfortunately everything great valera ii would like main part group <unknown> — <unknown> <unknown> <unknown> exactly good understand order berlandian therefore receive order asphalt roads come city group asphalt non - <unknown> roads come city vice versa take asphalt roads upon learn progress valera ii upset since late change anything ask make a program determine whether way asphalt berlandian roads n days help king first line contain two space - separated integers n m — number cities roads berland correspondingly next m line contain descriptions roads berland : i - th line contain three space - separated integers ai bi ci ( 1 ≤ ai bi ≤ n ; ai ≠ bi ; 0 ≤ ci ≤ 1 ) first two integers ( ai bi ) index cities connect i - th road third integer ( ci ) equal 1 road initially asphalt 0 otherwise consider cities berland index 1 n roads index 1 m. guarantee two berlandian cities one road first line print a single integer x ( 0 ≤ x ≤ n ) — number days need asphalt roads second line print x space - separated integers — index cities send workers print cities order valera send workers asphalt roads multiple solutions print 's way asphalt roads print ` ` impossible '' ( without quote ),['dfs and similar'],1900.0
653/E,a tree a connect undirected graph consist n vertices n - 1 edge vertices number 1 n. limak a little polar bear a tree n vertices lose still remember something lose tree though give m pair vertices ( a1 b1 ) ( a2 b2 ) ... ( bm ) limak remember i edge ai bi also remember vertex 1 incident exactly k edge ( degree equal k ) possible limak remember everything correctly ? check whether exist a tree satisfy give condition first line input contain three integers n m k ( ) — number vertices limak 's tree number forbid pair vertices degree vertex 1 respectively i - th next m line contain two distinct integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) — i - th pair forbid 's guarantee pair vertices appear input print ` ` possible '' ( without quote ) exist least one tree satisfy give condition otherwise print ` ` impossible '' ( without quote ) first sample n = 5 vertices degree vertex 1 k = 2 . condition satisfy a tree edge 1 - 5 5 - 2 1 - 3 3 - 4 . second sample limak remember none follow edge exist : 1 - 2 1 - 3 1 - 4 1 - 5 1 - 6 . hence vertex 1 could n't connect vertex imply suitable tree,['dfs and similar'],2400.0
9/E,hexadecimal like draw draw many graph already direct recently start work a still - life « interest graph apples » undirected graph call interest vertices belong one cycle — a funny ring — belong cycle a funny ring a cycle go vertices moreover loop funny ring already draw apples graph edge clear connect rest vertices get interest graph a result answer contain minimal amount add edge furthermore answer lexicographically smallest one set edge ( x1 y1 ) ( x2 y2 ) ... ( xn yn ) xi ≤ yi lexicographically smaller set ( u1 v1 ) ( u2 v2 ) ... ( un vn ) ui ≤ vi provide sequence integers x1 y1 x2 y2 ... xn yn lexicographically smaller sequence u1 v1 u2 v2 ... un vn cope hexadecimal eat ... eat alive first line input data contain a pair integers n m ( 1 ≤ n ≤ 50 0 ≤ m ≤ 2500 ) — amount vertices edge respectively follow line contain pair number xi yi ( 1 ≤ xi yi ≤ n ) — vertices already connect edge initial graph may contain multiple edge loop first line output « yes » « » : possible construct interest graph answer « yes » second line output k — amount edge add initial graph finally output k line : pair vertices xj yj edge draw result may contain multiple edge loop k equal zero,['dfs and similar'],2300.0
19/E,upon a time live a good fairy a. one day a fine young man b come ask predict future fairy look magic ball say soon fine young man meet beautiful princess ever marry draw a sheet paper n point join segment segment start point end point draw picture ask young man erase one segment sheet try colour point red blue segment point colour end manage <unknown> come true b want meet beautiful princess 's ask help find segment help meet princess first input line contain two integer number : n — amount draw point m — amount draw segment ( 1 ≤ n ≤ 104 0 ≤ m ≤ 104 ) follow m line contain descriptions segment description contain two different space - separated integer number v u ( 1 ≤ v ≤ n 1 ≤ u ≤ n ) — index point join segment segment meet description twice first line output number k — amount segment answer second line output k space - separated number — index segment ascend order index output segment number 1 input order,['dfs and similar'],2900.0
22/E,learn soon possible latest news favourite <unknown> new operate system bolgenos community <unknown> <unknown> decide develop a scheme accord scheme a community member first learn news call member latter turn call third member ; i.e a person index i get a person index fi call learn news time bolgenos community members understand scheme n't work sometimes — case members n't learn news want <unknown> scheme : add scheme instructions type ( xi yi ) mean person xi call person yi well minimum amount instructions need add end everyone learn news matter first learn ? first input line contain number n ( 2 ≤ n ≤ 105 ) — amount bolgenos community members second line contain n space - separated integer number fi ( 1 ≤ fi ≤ n i ≠ fi ) — index a person call a person index i. first line output one number — minimum amount instructions add output one possible variants add instructions scheme one instruction line solution unique output,['dfs and similar'],2300.0
27/D,well know berland n cities form silver ring — cities i i + 1 ( 1 ≤ i < n ) connect a road well cities n 1 . <unknown> decide build m new roads list roads build prepare road connect two cities road a curve lie inside outside ring new roads common point ring ( except endpoints road ) designers construct plan wonder possible build roads a way two roads intersect ( note roads may intersect endpoints ) possible roads inside ring outside ? first line contain two integers n m ( 4 ≤ n ≤ 100 1 ≤ m ≤ 100 ) follow m line contain two integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) two cities connect one road list list contain roads exist silver ring impossible build roads a way two roads intersect output impossible otherwise print m character i - th character i road inside ring o road outside ring several solutions output,['dfs and similar'],2200.0
28/B,one day n cells array decide play follow game initially cell contain a number equal 's <unknown> number ( start 1 ) also cell determine 's favourite number 's move i - th cell exchange 's value value j - th cell |i - j| = di di a favourite number i - th cell cells make move order number move unlimited favourite number cell give also give a permutation number 1 n. determine whether game could move state first line contain positive integer n ( 1 ≤ n ≤ 100 ) — number cells array second line contain n distinct integers 1 n — permutation last line contain n integers 1 n — favourite number cells give state reachable describe game output yes otherwise,['dfs and similar'],1600.0
118/E,bertown n junctions m bidirectional roads know one get junction one exist roads cars city traffic jam start <unknown> real problems deal government decide make traffic one - directional roads thus <unknown> traffic task determine whether a way make traffic one - directional still possibility get junction one answer positive also find one possible ways orient roads first line contain two space - separated integers n m ( 2 ≤ n ≤ 105 n - 1 ≤ m ≤ 3·105 ) represent number junctions roads town correspondingly follow m line contain two number describe roads city road determine two integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) — number junctions connect guarantee one get junction one along exist bidirectional roads road connect different junctions one road pair junctions 's solution print single number 0 . otherwise print m line contain two integers pi qi — road 's orientation traffic flow move along a one - directional road junction pi junction qi print roads order several solutions problem print,['dfs and similar'],2000.0
34/D,n cities berland city index — integer number 1 n. capital index r1 roads berland two - way road system exactly one path capital city i.e road map look like a tree berland 's chronicle road map keep follow way : city i different capital keep number pi — index last city way capital i. king berland berl <unknown> decide move capital city r1 city r2 naturally old representation road map berland 's chronicle become incorrect please help king find a new representation road map way describe first line contain three space - separated integers n r1 r2 ( 2 ≤ n ≤ 5·104 1 ≤ r1 ≠ r2 ≤ n ) — amount cities berland index old capital index new one correspondingly follow line contain n - 1 space - separated integers — old representation road map city apart r1 give integer pi — index last city way capital city i. cities describe order increase index output n - 1 number — new representation road map format,['dfs and similar'],1600.0
60/B,"<unknown> guy 's friend serial guy like watch soap <unknown> <unknown> start n't wash plate yet decide least put tap fill water plate represent a parallelepiped k × n × m , k layer ( first layer upper one ) a rectangle n × m empty square ( ' . ' ) <unknown> ( ' # ' ) water present empty square tap position square ( x y ) first layer guarantee square empty every minute a cubical unit water fall plate find many minutes serial guy <unknown> soap <unknown> turn water overfill plate , find moment time plate absolutely full go overfill next moment note : water fill area within reach ( see sample 4 ) water flow 6 directions face 1 × 1 × 1 cub first line contain three number k n m ( 1 ≤ k n m ≤ 10 ) size plate follow k rectangles consist n line contain m character ' . ' ' # ' represent ` ` layer '' plate order top bottom rectangles separate empty line ( see sample ) last line contain x y ( 1 ≤ x ≤ n 1 ≤ y ≤ m ) tap 's coordinate x number line y number column line layer number leave right integers 1 n columns layer number top bottom integers 1 m. answer contain a single number show many minutes plate fill",['dfs and similar'],1400.0
62/D,"arnie worm finish eat apple house yet decide move make mind plan way room locate join corridors number room 1 n. corridors bidirectional arnie want new house look like previous one , exactly n room a corridor room i room j exist old house build new one know house construct process arnie start eat apple start room stop eat way corridors return start room also know arnie eat without stop , arnie finish construct house busy every moment time gnaw a new corridor arnie n't move along already build corridors however gnaw corridors one order time change a house a difficult activity 's arnie know order corridors locate previous house want gnaw corridors another order represent a list room order visit new list lexicographically smallest also strictly lexicographically greater previous one help worm first line contain two integers n m ( 3 ≤ n ≤ 100 3 ≤ m ≤ 2000 ) number room corridors arnie 's house correspondingly next line contain m + 1 positive integers exceed n. description arnie 's old path represent a list room visit gnaw guarantee last number list coincide first one first room describe list main entrance 's arnie begin gnaw may assume room connect one corridor pair room however possible find isolate room disconnect others print m + 1 positive integers exceed n. number description new path accord arnie gnaw new house impossible find new path print solution first number answer equal last one also equal main entrance",['dfs and similar'],2300.0
74/C,let 's imagine : a chess piece billiard ball movements resemble ones a <unknown> chess piece difference a billiard ball hit board 's border reflect continue move formally first one four diagonal directions choose billiard ball move direction reach square locate board 's edge billiard ball reflect ; change direction movement 90 degrees continue move specifically reach a corner square billiard ball reflect twice start move opposite way move billiard ball make infinite number reflections square trajectory billiard ball stop move consider complete consider one billiard ball a beat another billiard ball b a reach a point b locate suggest find maximal number billiard ball pairwise beat position a chessboard n × m size first line contain two integers n m ( 2 ≤ n m ≤ 106 ) print a single number maximum possible number billiard ball pairwise beat please use % lld specificator read write 64 - bit number c++ prefer use cin ( also may use % i64d specificator ),['dfs and similar'],2100.0
85/C,"one night a hard day work petya saw a nightmare a binary search tree dream actual tree scar petya <unknown> thing petya could n't search elements tree petya try many time choose key look tree time arrive a wrong place petya <unknown> brain long choose key many time result better moment petya would start <unknown> <unknown> : every time look key tree n't key occur exactly one mistake ` ` 's a problem ! ` ` think petya ` ` count expectation value element find i search key '' moment however petya suddenly wake thus give a binary search tree a tree contain number write node number call node key number children every node tree equal either 0 2 . nod 0 children call leave nod 2 children call inner inner node leave child child whose key less current node 's key right child whose key current node 's key also a key node strictly larger key leave subtree node strictly smaller key right subtree node also give a set search key distinct differ node key contain tree key set search tree <unknown> search arrange like : initially locate tree root key current node larger search key move leave child node otherwise go right child node process repeat guarantee search key contain tree search always finish leaf key lie leaf declare search result know sure search make a mistake compare exactly go wrong way wo n't make mistake later possible mistake <unknown> consider search exactly one mistake occur task find expectation ( average value ) search result every search key consider exactly one mistake occur search , a set paths contain exactly one mistake give key search count average value key contain leave paths first line contain odd integer n ( 3 ≤ n < 105 ) represent number tree nod next n line contain node descriptions ( i + 1 ) -th line contain two space - separated integers first number number parent i - st node second number key lie i - th node next line contain integer k ( 1 ≤ k ≤ 105 ) represent number key count average value search result contain one mistake next k line contain actual key one key per line node key search key positive integers exceed 109 . n + k key distinct nod number 1 n. tree root ` ` -1 '' ( without quote ) give instead parent 's node number guarantee correct binary search tree give node except root could determine accord key whether leave child right one print k real number <unknown> answer key specify input answer differ correct one measure absolute relative error exceed 10 - 9 . first sample search key 1 one error result two paths tree : ( 1 2 5 ) ( 1 3 6 ) parentheses list number nod root a leaf key leave paths equal 6 10 correspondingly 's answer equal 8",['dfs and similar'],2200.0
107/A,german university cairo ( guc ) dorm house number 1 n. underground water pip connect house together pipe certain direction ( water flow direction vice versa ) diameter ( characterize maximal amount water handle ) house one pipe go one pipe go new semester start guc student dorm resident lulu want install tank tap <unknown> every house outgo water pipe without incoming water pipe lulu install a water tank house every house incoming water pipe without outgo water pipe lulu install a water tap house tank house convey water house a sequence pip tank accordingly tap house receive water <unknown> tank house order avoid pip burst one week later ( like happen last semester ) lulu also consider diameter pip amount water tank convey exceed diameter pip connect a tank correspond tap lulu want find maximal amount water safely convey tank correspond tap first line contain two space - separated integers n p ( 1 ≤ n ≤ 1000 0 ≤ p ≤ n ) — number house number pip correspondingly p line follow — description p pip i - th line contain three integers ai bi di indicate a pipe diameter di go house ai house bi ( 1 ≤ ai bi ≤ n ai ≠ bi 1 ≤ di ≤ 106 ) guarantee house one pipe go one pipe go print integer t first line — number tank - tap pair house next t line print 3 integers per line separate space : tanki tapi diameteri tanki ≠ tapi ( 1 ≤ i ≤ t ) tanki tapi index tank tap house respectively diameteri maximum amount water convey t line order ( <unknown> ) tanki,['dfs and similar'],1400.0
128/A,"task anna maria play a game a unpleasant <unknown> anna maria opposite square a chessboard ( 8 × 8 ) : anna upper right corner maria lower leave one apart board several statues statue occupy exactly one square a square contain a statue anything anyone — neither statues anna maria anna present board a <unknown> ( stand still never move ) maria <unknown> involve game goal — come anna 's square maria statues move turn maria move first one move maria go adjacent side diagonal cell statue stay cell statues move must go one square simultaneously statues bottom row fall board longer appear moment one statues cell maria statues declare winners moment maria come cell anna wait maria declare winner obviously nothing depend statues depend maria determine win maria make a strategic error give 8 string whose length equal 8 describe initial position board first line represent top row board next one — second top , last line represent bottom row character string match a single cell board appropriate row character manner correspond cell cell empty correspond character ` ` . ` ` a cell maria represent character ` ` m '' a cell anna represent character ` ` a '' a cell a statue cell represent character ` ` s '' guarantee last character first row always ` ` a '' first character last line always ` ` m '' remain character ` ` . '' ` ` s '' maria win print string ` ` win '' statues win print string ` ` lose ''",['dfs and similar'],1500.0
97/E,a revolution berland new dictator face unexpected challenge : country somehow rule dictator a efficient manager yet ca n't personally give order every citizen 's decide pick set leaders would control leaders directly order citizens however leadership efficiency turn vary person person ( i.e person a make efficient leader person b may good ) 's dictator ask world - famous berland scientists help scientists suggest <unknown> technology — make leaders work pair a relationship graph undirected graph whose vertices correspond people a simple path a path repeat vertices long <unknown> expensive research show a pair people maximum leadership qualities a graph relationships a simple path odd number edge scientists decide call pair different people leader pair secret service provide scientists relationship graph task simple — learn tell dictator whether give pair leader pair help scientists cope task first line contain integers n m ( 1 ≤ n ≤ 105 0 ≤ m ≤ 105 ) — number vertices edge relationship graph correspondingly next m line contain pair integers a b mean edge a - th b - th vertices ( vertices number start 1 1 ≤ a b ≤ n ) guarantee graph loop multiple edge next line contain number q ( 1 ≤ q ≤ 105 ) — number pair scientists interest next q line contain pair ( format edge query repeat a query contain a pair identical vertices ) query print a single line ` ` yes '' 's a simple odd path pair people ; otherwise print ` ` '' note <unknown> ) vertices 1 2 2 different simple paths total : 1 - 3 - 2 1 - 4 - 2 . consist even number edge 2 ) vertices 1 3 connect edge 's a simple odd path 1 - <unknown> ) vertices 1 5 locate different connect components 's path,['dfs and similar'],2200.0
369/C,city valera live go hold elections city parliament city n district n - 1 bidirectional roads know district a path along roads district let 's enumerate district way integers 1 n inclusive furthermore road residents decide problem road a problem road a road need repair n candidates run elections let 's enumerate candidates way integers 1 n inclusive candidate number i elect city parliament perform exactly one promise — repair problem roads way i - th district district 1 city parliament locate help valera determine subset candidates candidates subset elect city parliament problem roads city repair several subsets choose subset consist minimum number candidates first line contain a single integer n ( 2 ≤ n ≤ 105 ) — number district city n - 1 line follow line contain description a city road three positive integers xi yi ti ( 1 ≤ xi yi ≤ n 1 ≤ ti ≤ 2 ) — district connect i - th bidirectional road road type ti equal one i - th road n't problem road ; ti equal two i - th road problem road 's guarantee graph structure city a tree first line print a single non - negative number k — minimum size require subset candidates second line print k space - separated integers a1 a2 ... ak — number candidates form require subset multiple solutions allow print,['dfs and similar'],1600.0
1334/G,give a permutation $$$ p $$$ consist exactly $$$ 26 $$$ integers $$$ 1 $$$ $$$ 26 $$$ ( since a permutation integer $$$ 1 $$$ $$$ 26 $$$ occur $$$ p $$$ exactly ) two string $$$ s $$$ $$$ t $$$ consist lowercase latin letter a substring $$$ t ' $$$ string $$$ t $$$ occurence string $$$ s $$$ follow condition meet : example $$$ p_1 = 2 $$$ $$$ p_2 = 3 $$$ $$$ p_3 = 1 $$$ $$$ s = \text { abc } $$$ $$$ t = \text { <unknown> } $$$ three substrings $$$ t $$$ occurences $$$ s $$$ ( $$$ t ' = \text { abc } $$$ $$$ t ' = \text { bca } $$$ $$$ t ' = \text { aba } $$$ ) substring $$$ t $$$ length equal $$$ |s| $$$ check occurence $$$ s $$$ first line contain $$$ 26 $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p _ { 26 } $$$ ( $$$ 1 \le p_i \le 26 $$$ integers pairwise distinct ) second line contain one string $$$ s $$$ third line contain one string $$$ t $$$ ( $$$ 2 \le |s| \le |t| \le 200000 $$$ ) consist lowercase latin letter print a string $$$ |t| - |s| + 1 $$$ character character either 0 1 . $$$ i $$$ -th character 1 substring $$$ t $$$ start $$$ i $$$ -th character end $$$ ( i + |s| - 1 ) $$$ -th character ( inclusive ) occurence $$$ s $$$,['brute force'],2900.0
1362/B,among johnny 's <unknown> <unknown> two <unknown> harmless ones : apply bitwise operations sneak dad 's office usually case small children johnny <unknown> combine two <unknown> get a lot trouble a set $$$ s $$$ contain important number dad 's desk minute johnny hear decide 's a good idea choose a positive integer $$$ k $$$ replace element $$$ s $$$ set $$$ s $$$ $$$ s \oplus k $$$ ( $$$ \oplus $$$ denote exclusive operation ) help choose $$$ k $$$ johnny 's dad see difference son do play ( i.e johnny get set play ) possible number exist also possible many a case output smallest one note order elements a set n't matter i.e set $$$ \ { 1 2 3\ } $$$ equal set $$$ \ { 2 1 3\ } $$$ formally find smallest positive integer $$$ k $$$ $$$ \ { s \oplus k | s \in s\ } = s $$$ report number example $$$ s = \ { 1 3 4\ } $$$ $$$ k = 2 $$$ new set equal $$$ \ { 3 1 6\ } $$$ $$$ s = \ { 0 1 2 3\ } $$$ $$$ k = 1 $$$ play set stay first line input a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1024 $$$ ) number test case next line $$$ t $$$ test case follow consist two line first line a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1024 $$$ ) denote number elements set $$$ s $$$ second line consist $$$ n $$$ distinct integers $$$ s_i $$$ ( $$$ 0 \leq s_i < 1024 $$$ ) elements $$$ s $$$ guarantee sum $$$ n $$$ test case exceed $$$ 1024 $$$ print $$$ t $$$ line ; $$$ i $$$ -th line contain answer $$$ i $$$ -th test case minimal positive integer $$$ k $$$ satisfy condition $$$ -1 $$$ $$$ k $$$ exist first test case answer $$$ 1 $$$ a minimum positive integer satisfy condition,['brute force'],1200.0
1257/F,let 's call two number similar binary representations contain number digits equal $$$ 1 $$$ example : give array $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ may choose a non - negative integer $$$ x $$$ get another array $$$ n $$$ integers $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_n $$$ $$$ b_i = a_i \oplus x $$$ ( $$$ \oplus $$$ denote bitwise xor ) possible obtain array $$$ b $$$ number similar ? first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 0 \le a_i \le 2^ { 30 } - 1 $$$ ) impossible choose $$$ x $$$ elements result array similar print one integer $$$ -1 $$$ otherwise print non - negative integer exceed $$$ 2^ { 30 } - 1 $$$ use $$$ x $$$ elements result array similar,['brute force'],2400.0
1185/F,a company $$$ n $$$ friends want order exactly two pizzas know total $$$ 9 $$$ pizza ingredients nature denote integers $$$ 1 $$$ $$$ 9 $$$ $$$ n $$$ friends one favorite ingredients : $$$ i $$$ -th friends number favorite ingredients equal $$$ f_i $$$ ( $$$ 1 \le f_i \le 9 $$$ ) favorite ingredients form sequence $$$ b _ { i1 } b _ { i2 } \dots b _ { if_i } $$$ ( $$$ 1 \le b _ { } \le 9 $$$ ) website <unknown> restaurant exactly $$$ m $$$ ( $$$ m \ge 2 $$$ ) pizzas pizza characterize a set $$$ r_j $$$ ingredients $$$ a _ { j1 } a _ { j2 } \dots a _ { jr_j } $$$ ( $$$ 1 \le r_j \le 9 $$$ $$$ 1 \le a _ { jt } \le 9 $$$ ) include price $$$ c_j $$$ help friends choose exactly two pizzas a way please maximum number people company know a person please choice his / her favorite ingredients least one order pizza several ways choose two pizzas please maximum number friends choose one minimize total price two pizzas first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100000 2 \le m \le 100000 $$$ ) — number friends company number pizzas respectively next $$$ n $$$ line contain descriptions favorite ingredients friends : $$$ i $$$ -th contain number favorite ingredients $$$ f_i $$$ ( $$$ 1 \le f_i \le 9 $$$ ) a sequence distinct integers $$$ b _ { i1 } b _ { i2 } \dots b _ { if_i } $$$ ( $$$ 1 \le b _ { } \le 9 $$$ ) next $$$ m $$$ line contain pizza descriptions : $$$ j $$$ -th contain integer price pizza $$$ c_j $$$ ( $$$ 1 \le c_j \le 1000000000 $$$ ) number ingredients $$$ r_j $$$ ( $$$ 1 \le r_j \le 9 $$$ ) ingredients a sequence distinct integers $$$ a _ { j1 } a _ { j2 } \dots a _ { jr_j } $$$ ( $$$ 1 \le a _ { jt } \le 9 $$$ ) output two integers $$$ j_1 $$$ $$$ j_2 $$$ ( $$$ 1 \le j_1 j_2 \le m $$$ $$$ j_1 \ne j_2 $$$ ) denote indices two pizzas require set several solutions output pizza indices print order,['brute force'],2100.0
1205/B,give $$$ n $$$ integer number $$$ a_1 a_2 \dots a_n $$$ consider graph $$$ n $$$ nod nod $$$ i $$$ $$$ j $$$ ( $$$ <unknown> j $$$ ) connect $$$ a_i $$$ $$$ <unknown> 0 $$$ denote bitwise operation find length shortest cycle graph determine n't cycle first line contain one integer $$$ n $$$ $$$ ( 1 \le n \le 100000 ) $$$ — number number second line contain $$$ n $$$ integer number $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 10^ { 18 } $$$ ) graph n't cycle output $$$ -1 $$$ else output length shortest cycle first example shortest cycle $$$ ( 9 3 6 28 ) $$$ second example shortest cycle $$$ ( 5 12 9 ) $$$ graph cycle third example,['brute force'],1900.0
1217/C,give a binary string $$$ s $$$ ( recall a string binary character either $$$ 0 $$$ $$$ 1 $$$ ) let $$$ f ( t ) $$$ decimal representation integer $$$ t $$$ write binary form ( possibly lead zero ) example $$$ f ( 011 ) = 3 f ( <unknown> ) = 5 f ( 00001 ) = 1 f ( 10 ) = 2 f ( 000 ) = 0 $$$ $$$ f ( <unknown> ) = 4 $$$ substring $$$ s _ { l } s _ { l+1 } \dots s _ { r } $$$ good $$$ r - l + 1 = f ( s_l \dots s_r ) $$$ example string $$$ s = <unknown> $$$ $$$ 5 $$$ good substrings : $$$ s_1 \dots s_1 = 1 $$$ $$$ s_3 \dots s_3 = 1 $$$ $$$ s_4 \dots s_4 = 1 $$$ $$$ s_1 \dots s_2 = 10 $$$ $$$ s_2 \dots s_4 = 011 $$$ task calculate number good substrings string $$$ s $$$ answer $$$ t $$$ independent query first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number query line query contain string $$$ s $$$ ( $$$ 1 \le |s| \le 200000 $$$ ) consist digits $$$ 0 $$$ $$$ 1 $$$ guarantee $$$ \sum\limits _ { i=1 } ^ { t } |s_i| \le 200000 $$$ query print one integer — number good substrings string $$$ s $$$,['brute force'],1700.0
1805/A,array $$$ a $$$ consist non - negative integers choose integer $$$ x $$$ denote $$$ b_i = a_i \oplus x $$$ $$$ 1 \le i \le n $$$ $$$ \oplus $$$ denote bitwise xor operation possible choose a number $$$ x $$$ value expression $$$ b_1 \oplus b_2 \oplus \ldots \oplus b_n $$$ equal $$$ 0 $$$ ? show a valid number $$$ x $$$ exist also exist $$$ x $$$ ( $$$ 0 \le x < 2 ^ 8 $$$ ) test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — length array $$$ a $$$ second line test case contain $$$ n $$$ integers — array $$$ a $$$ ( $$$ 0 \le a_i < 2 ^ 8 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 1000 $$$ set test case print integer $$$ x $$$ ( $$$ 0 \le x < 2 ^ 8 $$$ ) exist $$$ -1 $$$ otherwise first test case apply operation number $$$ 6 $$$ array $$$ b $$$ become $$$ [ 7 4 3 ] $$$ $$$ 7 \oplus 4 \oplus 3 = 0 $$$ answer third test case number $$$ 0 $$$,['brute force'],800.0
1688/A,cirno 's perfect <unknown> classroom start ! cirno give students a positive integer $$$ x $$$ assignment students need find minimum positive integer $$$ y $$$ satisfy follow two condition : $$$ $$$ x\ \texttt { } \ y > 0 $$$ $$$ $$$ $$$ x\ \texttt { xor } \ y > 0 $$$ $$$ $$$ \texttt { } $$$ bitwise operation $$$ \texttt { xor } $$$ bitwise xor operation among students <unknown> truly <unknown> new operators please help ! first line input contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number input test case test case line input contain one integer $$$ x $$$ ( $$$ 1 \leq x \leq 2^ { 30 } $$$ ) test case print a single integer — minimum number $$$ y $$$ test case 1 : $$$ 1\ ; \texttt { } \ ; 3=1 > 0 $$$ $$$ 1\ ; \texttt { xor } \ ; 3=2 > 0 $$$ test case 2 : $$$ 2\ ; \texttt { } \ ; 3=2 > 0 $$$ $$$ 2\ ; \texttt { xor } \ ; 3=1 > 0 $$$,['brute force'],800.0
1698/A,array $$$ a $$$ $$$ n-1 $$$ integers let $$$ x $$$ bitwise xor elements array number $$$ x $$$ add end array $$$ a $$$ ( length $$$ n $$$ ) elements shuffle give newly form array $$$ a $$$ $$$ x $$$ ? multiple possible value $$$ x $$$ output input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 2 \leq n \leq 100 $$$ ) — number integers result array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le <unknown> $$$ ) — elements newly form array $$$ a $$$ additional constraint input : array $$$ a $$$ make process describe statement ; value $$$ x $$$ exist test case output a single integer — value $$$ x $$$ describe statement multiple possible value $$$ x $$$ output first test case one possible array $$$ a $$$ $$$ a= [ 2 5 4 ] $$$ $$$ x = 2 \oplus 5 \oplus 4 = 3 $$$ ( $$$ \oplus $$$ denote bitwise xor ) new array $$$ [ 2 5 4 3 ] $$$ afterwards array shuffle form $$$ [ 4 3 2 5 ] $$$ second test case one possible array $$$ a $$$ $$$ a= [ 1 10 6 10 ] $$$ $$$ x = 1 \oplus 10 \oplus 6 \oplus 10 = 7 $$$ new array $$$ [ 1 10 6 10 7 ] $$$ afterwards array shuffle form $$$ [ 6 1 10 7 10 ] $$$ third test case elements array equal $$$ 6 $$$ $$$ <unknown> $$$ fourth test case one possible array $$$ a $$$ $$$ a= [ 100 100 ] $$$ $$$ x = 100 \oplus 100 = 0 $$$ new array $$$ [ 100 100 0 ] $$$ afterwards array shuffle form $$$ [ 100 100 0 ] $$$ ( note shuffle array remain . ),['brute force'],800.0
114/B,little petya grow enter university start take part асм contest later realize n't like асм contest organise : team could three members ( could n't take friends competitions distribute task team members <unknown> ) decide organize contest pfast inc . — petr friends solve task corporation pfast inc . rule allow a team unlimited number members make format contest popular organise tournament create team prepare contest organise pfast inc . rule choose several volunteer ( 16 people ) decide compile a team petya understand perfectly a team two people n't get well team perform <unknown> put together a team many players possible give players get well first line contain two integer number n ( 1 ≤ n ≤ 16 ) — number volunteer m ( ) — number pair get next n line contain volunteer ' name ( name a non - empty string consist 10 uppercase and/or lowercase latin letter ) next m line contain two name — name volunteer get name pair separate a single space pair volunteer get occur exactly string case - sensitive n name distinct first output line contain single number k — number people seek team next k line contain name seek team 's participants lexicographical order several variants solve problem print petya might a member seek team,['brute force'],1500.0
96/B,petya love lucky number everybody know positive integers lucky decimal representation n't contain digits 4 7 . example number 47 744 4 lucky 5 17 467 lucky number super lucky 's decimal representation contain equal amount digits 4 7 . example number 47 <unknown> <unknown> super lucky 4 744 467 one day petya come across a positive integer n. help find least super lucky number less n. line contain a positive integer n ( 1 ≤ n ≤ 109 ) number n't lead zero output least super lucky number equal n. please use % lld specificator read write 64 - bit integers c++ prefer use cin cout stream % i64d specificator,['brute force'],1300.0
293/B,a rectangular n × m - cell board cells already paint k color need paint uncolored cell one k color path upper leave square lower right one n't contain two cells color path go along side - adjacent cells go right print number possible paint modulo 1000000007 ( 109 + 7 ) first line contain three integers n m k ( 1 ≤ n m ≤ 1000 1 ≤ k ≤ 10 ) next n line contain m integers — board first contain m uppermost cells board leave right second one contain m cells second uppermost row a number a line equal 0 correspond cell n't paint otherwise number represent initial color board cell — integer 1 k. consider color number 1 k manner print number possible paint modulo 1000000007 ( 109 + 7 ),['brute force'],2700.0
528/D,"leonid work a small promise start - up work decode human genome duties include solve complex problems find certain pattern long string consist letter ' a ' ' t ' ' g ' ' c ' let 's consider follow scenario a fragment a human dna chain record a string s. analyze fragment need find occurrences string t a string s. however matter complicate fact original chain fragment could contain <unknown> mutations , however complicate task find a fragment leonid propose follow approach solve problem let 's write integer k ≥ 0 — error threshold say string t occur string s position i ( 1 ≤ i ≤ |s| - |t| + 1 ) put string t along position character string t correspond character value string s distance k. formally j ( 1 ≤ j ≤ |t| ) must exist p ( 1 ≤ p ≤ |s| ) | ( i + j - 1 ) - <unknown> ≤ k s [ p ] = t [ j ] example correspond give definition string ` ` <unknown> '' occur string ` ` <unknown> '' position 2 3 6 . note k = 0 give definition transform a simple definition occurrence a string a string help leonid calculate many position give string t occur give string s give error threshold first line contain three integers |s| |t| k ( 1 ≤ |t| ≤ |s| ≤ 200 000 0 ≤ k ≤ 200 000 ) — lengths string s t error threshold second line contain string s. third line contain string t. string consist uppercase letter ' a ' ' t ' ' g ' ' c ' print a single number — number occurrences t s error threshold k give definition happen know structure human genome a little author problem impress leonid 's original approach take everything describe <unknown>",['brute force'],2500.0
993/B,"two participants give a pair distinct number 1 9 's exactly one number present pair want figure number match use a communication channel access without reveal participants communicate a set pair number include pair give pair communicate set <unknown> two different number determine certainty deduce common number determine certainty participants know number first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 12 $$$ ) — number pair first participant communicate second vice versa second line contain $$$ n $$$ pair integers $$$ 1 $$$ $$$ 9 $$$ — pair number communicate first participant second third line contain $$$ m $$$ pair integers $$$ 1 $$$ $$$ 9 $$$ — pair number communicate second participant first pair within set distinct ( particular a pair $$$ ( 1,2 ) $$$ pair $$$ ( 2,1 ) $$$ within set ) pair contain number twice guarantee two set contradict statements word pair first set a pair second set share exactly one number deduce share number certainty print number certainty deduce participants know share number know print $$$ 0 $$$ otherwise print $$$ -1 $$$ first example first participant communicate pair $$$ ( 1,2 ) $$$ $$$ ( 3,4 ) $$$ second communicate $$$ ( 1,5 ) $$$ $$$ ( 3,4 ) $$$ since know actual pair receive share exactly one number ca n't $$$ ( 3,4 ) $$$ thus first participant $$$ ( 1,2 ) $$$ second $$$ ( 1,5 ) $$$ point already know share number $$$ 1 $$$ second example either first participant $$$ ( 1,2 ) $$$ second $$$ ( 1,5 ) $$$ first $$$ ( 3,4 ) $$$ second $$$ ( 6,4 ) $$$ first case know share number $$$ 1 $$$ second case know share number $$$ 4 $$$ n't enough information tell $$$ 1 $$$ $$$ 4 $$$ apart third case first participant give $$$ ( 1,2 ) $$$ n't know share number since <unknown> second participant might give either $$$ ( 1,3 ) $$$ case share number $$$ 1 $$$ $$$ ( 2,3 ) $$$ case share number $$$ 2 $$$ second participant know number certainty neither first participant output $$$ -1 $$$",['brute force'],1900.0
550/B,n problems estimate difficulty i - th one integer ci want prepare a problemset a contest use problems ' ve make a problemset contest must consist least two problems think total difficulty problems contest must least l r. also think difference difficulties easiest hardest choose problems must least x. find number ways choose a problemset contest first line contain four integers n l r x ( 1 ≤ n ≤ 15 1 ≤ l ≤ r ≤ 109 1 ≤ x ≤ 106 ) — number problems minimum maximum value total difficulty problemset minimum difference difficulty hardest problem pack easiest one respectively second line contain n integers c1 c2 ... cn ( 1 ≤ ci ≤ 106 ) — difficulty problem print number ways choose a suitable problemset contest first example two set suitable one consist second third problem another one consist three problems second example two set problems suitable — set problems difficulties 10 30 well set problems difficulties 20 30 . third example set consist one problem difficulty 10 one problem difficulty 20 suitable,['brute force'],1400.0
685/E,"gerda travel palace snow queen road network consist n intersections m bidirectional roads roads number 1 m. snow queen put a powerful spell roads change weather condition , gerda step road i moment time less equal i leave road exactly moment i. case step road i moment time greater i stay forever gerda start moment time l intersection number s go palace snow queen locate intersection number t. moreover moment r ( earlier ) arrival queen give description road network determine q query li ri si ti 's possible gerda get palace time first line input contain integers n m q ( 2 ≤ n ≤ 1000 1 ≤ m q ≤ 200 000 ) — number intersections road network snow queen 's kingdom number roads number query answer i - th follow m line contain description road number i. description consist two integers vi ui ( 1 ≤ vi ui ≤ n vi ≠ ui ) — indices intersections connect i - th road 's possible get vi ui ui vi use road pair intersection may appear several time mean several roads connect pair last q line contain query descriptions consist four integers li ri si ti ( 1 ≤ li ≤ ri ≤ m 1 ≤ si ti ≤ n si ≠ ti ) — moment time gerda start journey last moment time allow arrive palace index start intersection index intersection palace locate query print ` ` yes '' ( without quote ) gerda snow queen palace time ( later ri ) ` ` '' ( without quote ) otherwise",['brute force'],2800.0
769/D,vasya sequence consist n integers vasya consider pair integers x y k - interesting binary representation differ exactly k bits example k = 2 pair integers x = 5 y = 3 k - interesting binary representation <unknown> <unknown> differ exactly two bits vasya want know many pair index ( i j ) sequence i < j pair integers ai aj k - interesting task help vasya determine number first line contain two integers n k ( 2 ≤ n ≤ 105 0 ≤ k ≤ 14 ) — number integers vasya 's sequence number bits integers k - interesting pair differ second line contain sequence a1 a2 ... ( 0 ≤ ai ≤ 104 ) vasya print number pair ( i j ) i < j pair integers ai aj k - interesting first test 4 k - interesting pair : second test k = 0 . consequently integers k - interesting pair equal thus second test 6 k - interesting pair :,['brute force'],1700.0
1433/G,a mayor berlyatov $$$ n $$$ district $$$ m $$$ two - way roads $$$ i $$$ -th road connect district $$$ x_i $$$ $$$ y_i $$$ cost travel along road $$$ w_i $$$ path pair district city connect $$$ k $$$ delivery rout berlyatov $$$ i $$$ -th route go district $$$ a_i $$$ district $$$ b_i $$$ one courier route courier always choose cheapest ( minimum total cost ) path district $$$ a_i $$$ district $$$ b_i $$$ deliver products route go district couriers rout coincide ( count independently ) make one road cost zero ( i.e choose one road change cost $$$ 0 $$$ ) let $$$ d ( x y ) $$$ cheapest cost travel district $$$ x $$$ $$$ y $$$ task find minimum total courier rout cost achieve optimally select road change cost $$$ 0 $$$ word find minimum possible value $$$ \sum\limits _ { i = 1 } ^ { k } d ( a_i b_i ) $$$ apply operation describe optimally first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \le n \le 1000 $$$ ; $$$ n - 1 \le m \le min ( 1000 \frac { n ( n-1 ) } { 2 } ) $$$ ; $$$ 1 \le k \le 1000 $$$ ) — number district number roads number courier rout next $$$ m $$$ line describe roads $$$ i $$$ -th road give three integers $$$ x_i $$$ $$$ y_i $$$ $$$ w_i $$$ ( $$$ 1 \le x_i y_i \le n $$$ ; $$$ x_i \ne y_i $$$ ; $$$ 1 \le w_i \le 1000 $$$ ) $$$ x_i $$$ $$$ y_i $$$ district $$$ i $$$ -th road connect $$$ w_i $$$ cost guarantee path pair district city connect also guarantee one road pair district next $$$ k $$$ line describe courier rout $$$ i $$$ -th route give two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ ) — district $$$ i $$$ -th route route go district couriers rout coincide ( count independently ) print one integer — minimum total courier rout cost achieve ( i.e minimum value $$$ \sum\limits _ { i=1 } ^ { k } d ( a_i b_i ) $$$ $$$ d ( x y ) $$$ cheapest cost travel district $$$ x $$$ $$$ y $$$ ) make ( one ) road cost zero picture correspond first example : choose either road $$$ ( 2 4 ) $$$ road $$$ ( 4 6 ) $$$ options lead total cost $$$ 22 $$$ picture correspond second example : choose road $$$ ( 3 4 ) $$$ lead total cost $$$ 13 $$$,['brute force'],2100.0
425/A,usual sereja array a elements integers : a [ 1 ] a [ 2 ] ... a [ n ] let 's introduce notation : a swap operation follow sequence action : maximum value function m ( a ) sereja get allow perform k swap operations ? first line contain two integers n k ( 1 ≤ n ≤ 200 ; 1 ≤ k ≤ 10 ) next line contain n integers a [ 1 ] a [ 2 ] ... a [ n ] ( - 1000 ≤ a [ i ] ≤ 1000 ) a single line print maximum value m ( a ) sereja get allow perform k swap operations,['brute force'],1500.0
430/B,iahub train ioi a better way train play a <unknown> - like game ? n ball put a row ball color one k color initially row n't contain three contiguous ball color iahub a single ball color x. insert ball position row ( probably two ball ) moment three contiguous ball color row destroy immediately rule apply multiple time set 3 contiguous ball color example iahub row ball [ black black white white black black ] a white ball insert ball two white ball thus three white ball destroy four black ball become contiguous four ball destroy row contain ball end iahub destroy 6 ball iahub want destroy many ball possible give description row ball color iahub 's ball help iahub train ioi tell maximum number ball row destroy first line input contain three integers : n ( 1 ≤ n ≤ 100 ) k ( 1 ≤ k ≤ 100 ) x ( 1 ≤ x ≤ k ) next line contain n space - separated integers c1 c2 ... cn ( 1 ≤ ci ≤ k ) number ci mean i - th ball row color ci guarantee initial row ball never contain three contiguous ball color print a single integer — maximum number ball iahub destroy,['brute force'],1400.0
488/A,"giga tower <unknown> deepest build cyberland 17 777 777 777 floor number - 8 888 888 888 8 888 888 888 . particular floor 0 floor - 1 floor 1 . every day thousands tourists come place enjoy wonderful view cyberland believe number ` ` 8 '' a lucky number ( 's giga tower 8 888 888 888 floor grind ) , integer lucky decimal notation contain least one digit ` ` 8 '' example 8 - 180 <unknown> lucky 42 - 10 giga tower write code a floor lucky floor number good luck always ( well round # <unknown> also lucky <unknown> ? ) tourist <unknown> go tower seek good luck floor number a. want find minimum positive integer b , walk b floor higher arrive a floor a lucky number line input contain integer a ( - 109 ≤ a ≤ 109 ) print minimum b a line first sample arrive floor number 180 . second sample arrive 8 . note b positive answer third sample 10 0",['brute force'],1100.0
380/A,"sereja love number sequence much 's decide make a new one follow a certain algorithm sereja take a blank piece paper start write sequence m stag time either add a new number end sequence take l first elements current sequence add c time end formally represent current sequence a1 a2 ... , apply describe operation sequence transform a1 a2 ... [ a1 a2 ... al ] ( block square bracket must repeat c time ) a day pass sereja complete sequence wonder value elements help sereja first line contain integer m ( 1 ≤ m ≤ 105 ) — number stag build a sequence next m line contain description stag order follow first number line a type stage ( 1 2 ) type 1 mean add one number end sequence case line contain integer xi ( 1 ≤ xi ≤ 105 ) — number add type 2 mean copy a prefix length li end ci time case line contain two integers li ci ( 1 ≤ li ≤ 105 1 ≤ ci ≤ 104 ) li length prefix ci number copy guarantee length prefix li never larger current length sequence next line contain integer n ( 1 ≤ n ≤ 105 ) — number elements sereja interest next line contain number elements final sequence sereja interest number give strictly increase order guarantee number strictly larger zero exceed length result sequence consider elements final sequence number start 1 begin end sequence please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print elements sereja interest order number occur input",['brute force'],1600.0
508/A,"pasha love phone also put hair ... hair <unknown> pasha instal a new game phone goal game follow a rectangular field consist n row m pixels row initially pixels color white one move pasha choose pixel color black particular choose pixel already black boy 's move pixel change , remain black pasha lose game a 2 × 2 square consist black pixels form pasha make a plan k move accord paint pixels turn plan represent a pair number i j denote respectively row column pixel color current move determine whether pasha lose act accordance plan , move 2 × 2 square consist black pixels form first line input contain three integers n m k ( 1 ≤ n m ≤ 1000 1 ≤ k ≤ 105 ) — number row number columns number move pasha go perform next k line contain pasha 's move order make line contain two integers i j ( 1 ≤ i ≤ n 1 ≤ j ≤ m ) represent row number column number pixel paint a move pasha lose print number move 2 × 2 square consist black pixels form pasha n't lose , 2 × 2 square consist black pixels form give k move print 0",['brute force'],1100.0
665/B,ayush a cashier shop center recently department start a ` ` click collect '' service allow users shop online store contain k items n customers already use service user pay m items let aij denote j - th item i - th person 's order due space limitations items arrange one single row ayush receive i - th order find one one items aij ( 1 ≤ j ≤ m ) row let pos ( x ) denote position item x row moment collection ayush take time equal pos ( ai1 ) + pos ( ai2 ) + ... + pos ( aim ) i - th customer ayush access x - th element keep a new stock front row take away x - th element thus value update task calculate total time take ayush process order assume market endless stock first line contain three integers n m k ( 1 ≤ n k ≤ 100 1 ≤ m ≤ k ) — number users number items user want buy total number items market next line contain k distinct integers pl ( 1 ≤ pl ≤ k ) denote initial position items store items number integers 1 k. next n line contain m distinct integers aij ( 1 ≤ aij ≤ k ) — order i - th person print integer t — total time need ayush process order customer 1 want items 1 <unknown> ( 1 ) = 3 new position : [ 1 3 4 2 5 ] .pos ( 5 ) = 5 new position : [ 5 1 3 4 2 ] time take first customer 3 + 5 = 8 . customer 2 want items 3 <unknown> ( 3 ) = 3 new position : [ 3 5 1 4 2 ] .pos ( 1 ) = 3 new position : [ 1 3 5 4 2 ] time take second customer 3 + 3 = 6 . total time 8 + 6 = 14 . formally pos ( x ) index x current row,['brute force'],1400.0
1382/A,"give two array integers $$$ a_1 \ldots a_n $$$ $$$ b_1 \ldots b_m $$$ task find a non - empty array $$$ c_1 \ldots c_k $$$ a subsequence $$$ a_1 \ldots a_n $$$ also a subsequence $$$ b_1 \ldots b_m $$$ multiple answer find one smallest possible length still multiple smallest possible length find array report a sequence $$$ a $$$ a subsequence a sequence $$$ b $$$ $$$ a $$$ obtain $$$ b $$$ deletion several ( possibly zero ) elements example $$$ [ 3,1 ] $$$ a subsequence $$$ [ <unknown> ] $$$ $$$ [ <unknown> ] $$$ a subsequence $$$ [ <unknown> ] $$$ $$$ [ <unknown> ] $$$ first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 1000 $$$ ) — number test case next $$$ 3 t $$$ line contain descriptions test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1\le n m\le 1000 $$$ ) — lengths two array second line test case contain $$$ n $$$ integers $$$ a_1 \ldots a_n $$$ ( $$$ 1\le a_i\le 1000 $$$ ) — elements first array third line test case contain $$$ m $$$ integers $$$ b_1 \ldots b_m $$$ ( $$$ 1\le <unknown> 1000 $$$ ) — elements second array guarantee sum $$$ n $$$ sum $$$ m $$$ across test case exceed $$$ 1000 $$$ ( $$$ \sum\limits _ { i=1 } ^t n_i \sum\limits _ { i=1 } ^t <unknown> 1000 $$$ ) test case output ` ` yes '' a solution exist ` ` '' otherwise answer ` ` yes '' next line output integer $$$ k $$$ ( $$$ 1\le k\le 1000 $$$ ) — length array follow $$$ k $$$ integers $$$ c_1 \ldots c_k $$$ ( $$$ 1\le <unknown> 1000 $$$ ) — elements array multiple solutions smallest possible $$$ k $$$ output first test case $$$ [ 4 ] $$$ a subsequence $$$ [ 10 8 6 4 ] $$$ $$$ [ 1 2 3 4 5 ] $$$ array length $$$ 1 $$$ smallest possible length a subsequence $$$ a $$$ $$$ b $$$ third test case non - empty subsequences $$$ [ 3 ] $$$ $$$ [ 2 ] $$$ exist answer ` ` ''",['brute force'],800.0
681/B,kolya develop <unknown> <unknown> game favourite part development process in - game test entertain test much find game - coin score become equal 0 . kolya remember begin game game - coin score equal n buy house ( 1 234 567 game - coins ) cars ( 123 456 game - coins ) computers ( 1 234 game - coins ) kolya interest whether could spend initial n game - coins buy house cars computers a bug game formally a triple non - negative integers a b c a × 1 234 567 + b × 123 456 + c × 1 234 = n ? please help kolya answer question first line input contain a single integer n ( 1 ≤ n ≤ 109 ) — kolya 's initial game - coin score print ` ` yes '' ( without quote ) 's possible kolya spend initial n coin buy house cars computers otherwise print ` ` '' ( without quote ) first sample one possible solutions buy one house one car one computer spend 1 234 567 + 123 456 + 1234 = 1 <unknown> <unknown> game - coins total,['brute force'],1300.0
801/A,<unknown> a keyboard two letter ` ` v '' ` ` k '' one day type a string s two letter really like string ` ` vk '' appear wish change one letter string ( change ) maximize number occurrences string compute maximum number time ` ` vk '' appear a substring ( i. e. a letter ` ` k '' right a letter ` ` v '' ) result string first line contain a string s consist uppercase english letter ` ` v '' ` ` k '' length less 1 greater 100 . output a single integer maximum number time ` ` vk '' appear a substring give string change one character first case change letter ` ` vk '' appear maximum number time could appear second case change second character a ` ` v '' a ` ` k '' give us string ` ` vk '' one occurrence string ` ` vk '' a substring fourth case change fourth character a ` ` k '' a ` ` v '' give us string ` ` <unknown> '' three occurrences string ` ` vk '' a substring check move give us strictly occurrences,['brute force'],1100.0
838/A,"give image represent a 2 - d n m grid pixels pixel image either denote character ` ` 0 '' ` ` 1 '' respectively would like compress image want choose integer k > 1 split image k k block n m divisible k image pad zero right bottom divisible k. pixel individual block must value give image may compressible current state find minimum number pixels need toggle ( pad ) order image compressible k. specifically step first choose k image pad zero , toggle pixels compressible k. image must compressible state first line input contain two integers n m ( 2 ≤ n m ≤ 2 500 ) dimension image next n line input contain a binary string exactly m character represent image print a single integer minimum number pixels need toggle make image compressible first choose k = 2 . image pad follow : toggle image look follow : see image compressible k = 2",['brute force'],1400.0
842/A,kirill play a new computer game come potion store buy potion potion characterize two integers — amount experience cost efficiency a potion <unknown> amount experience cost efficiency may a non - integer number two integer number a b l ≤ a ≤ r x ≤ b ≤ y a potion experience a cost b store ( ( r - l + 1 ) · ( y - x + 1 ) <unknown> ) kirill want buy a potion efficiency k. able ? first string contain five integer number l r x y k ( 1 ≤ l ≤ r ≤ 107 1 ≤ x ≤ y ≤ 107 1 ≤ k ≤ 107 ) print ` ` yes '' without quote a potion efficiency exactly k buy store ` ` '' without quote otherwise output letter register,['brute force'],1200.0
629/B,famil door want celebrate birthday friends far far away n friends come party a specific range days year ai bi course famil door want many friends celebrate together possible far cars weird far far away citizens carry two people opposite <unknown> exactly one male one female however far far transportation may use get party famil door select day year invite friends available moment number male friends invite equal number female friends invite find maximum number friends may present party first line input contain a single integer n ( 1 ≤ n ≤ 5000 ) — number famil door 's friends follow n line describe friends line start a capital letter ' f ' female friends a capital letter ' m ' male friends follow two integers ai bi ( 1 ≤ ai ≤ bi ≤ <unknown> ) provide i - th friend come party day ai day bi inclusive print maximum number people may come famil door 's party first sample friends 3 4 come day range [ <unknown> 128 ] second sample friends indices 3 4 5 6 come day <unknown>,['brute force'],1100.0
886/A,a small proud high school decide win <unknown> icpc goal require compose many team three possible since 6 students wish participate decision build exactly two team practice competition participant number i get a score ai team score define sum score participants high school management interest 's possible build two team equal score task answer question single line contain six integers a1 ... <unknown> ( 0 ≤ ai ≤ 1000 ) — score <unknown> ` ` yes '' ( quote clarity ) possible build team equal score ` ` '' otherwise print character either <unknown> lowercase ( ` ` yes '' ` ` yes '' valid answer ` ` yes '' ) first sample first team compose 1st 2nd <unknown> participant second — 3rd 4th 5th : team score 1 + 3 + 1 = 2 + 1 + 2 = 5 . second sample score participant number 6 high : team score definitely greater,['brute force'],1000.0
378/A,two players play a game first write integer 1 6 a dice throw player whose write number get closer number dice win <unknown> difference 's a draw first player write number a second player write number b. many ways throw a dice first player win a draw second player win ? single line contain two integers a b ( 1 ≤ a b ≤ 6 ) — number write paper first second player correspondingly print three integers : number ways throw dice first player win game end a draw second player win correspondingly dice a standard cube - shaped six - sided object side contain a number 1 6 number side distinct assume number a closer number x number b |a - x| < |b - x|,['brute force'],800.0
364/C,"'ll call a set positive integers a beautiful follow condition fulfill : prime p , word one number set divisible prime p least half number set divisible p. task find beautiful set number elements equal k element n't exceed <unknown> first line contain integer k ( 10 ≤ k ≤ 5000 ) show many number require beautiful set first line print k space - separated integers a beautiful set multiple set allow print",['brute force'],2300.0
214/A,furik love math lessons much n't attend unlike <unknown> furik want get a good mark math <unknown> . <unknown> math teacher give a new task furik solve task immediately ? give a system equations : count many pair integers ( a b ) ( 0 ≤ a b ) satisfy system a single line contain two integers n m ( 1 ≤ n m ≤ 1000 ) — parameters system number line separate a space a single line print answer problem first sample suitable pair integers ( 3 0 ) second sample suitable pair integers ( 3 5 ) third sample suitable pair,['brute force'],800.0
229/A,give a table consist n row m columns cell table contain a number 0 1 . one move choose row table cyclically shift value either one cell leave one cell right cyclically shift a table row one cell right mean move value cell except last one right neighbor cell move value last cell first cell a <unknown> shift a row leave perform similarly direction example cyclically shift a row ` ` 00110 '' one cell right get a row ` ` <unknown> '' shift a row ` ` 00110 '' one cell leave get a row ` ` <unknown> '' determine minimum number move need make table column consist number 1 . first line contain two space - separated integers : n ( 1 ≤ n ≤ 100 ) — number row table m ( 1 ≤ m ≤ 104 ) — number columns table n line follow contain m character ` ` 0 '' ` ` 1 '' : j - th character i - th line describe content cell i - th row j - th column table guarantee description table contain character besides ` ` 0 '' ` ` 1 '' print a single number : minimum number move need get number 1 column table impossible print -1 . first sample one way achieve goal least number move follow : cyclically shift second row right shift third row leave twice table column last one contain 1s second sample one ca n't shift row get a column contain 1s,['brute force'],1500.0
245/G,"polycarpus work a programmer a start - up social network boss give a task develop a mechanism determine suggest friends polycarpus think much task come <unknown> conclusion let 's say friendship relationships a social network give m username pair ai bi ( ai ≠ bi ) pair ai bi mean users ai bi friends friendship symmetric , ai friends bi bi also friends ai user y a suggest friend user x follow condition meet : task help polycarpus implement a mechanism determine suggest friends first line contain a single integer m ( 1 ≤ m ≤ 5000 ) — number pair friends social network next m line contain pair name users friends i - th line contain two space - separated name ai bi ( ai ≠ bi ) users ' name non - empty consist 20 uppercase lowercase english letter guarantee pair friends occur input example input ca n't contain x y y x time guarantee distinct users distinct name guarantee social network user least one friend last thing guarantee username occur least input first line print a single integer n — number network users next n line print number suggest friends user i - th line print name user ci number suggest friends di a space print information users order first test case consider user david users mike tank one common friend ( gerald ) david user <unknown> common friends david 's david 's suggest friends users mike tank",['brute force'],2200.0
250/E,joe hurt internet storm around house destroy everything path joe 's house n floor floor a segment m cells cell either contain nothing ( empty cell ) a brick a concrete wall ( always something one three ) believe floor surround a concrete wall leave right joe n - th floor first cell count leave right moment time joe direction gaze right leave ( always one direction two ) initially joe look right joe move a particular algorithm every second make one follow action : joe calm soon reach cell first floor figure show example joe 's movements around house determine many second joe need calm first line contain two integers n m ( 2 ≤ n ≤ 100 1 ≤ m ≤ 104 ) next n line contain description joe 's house i - th line contain description ( n - i + 1 ) -th floor house — a line consist m character : ` ` . '' mean empty cell ` ` + '' mean bricks ` ` # '' mean a concrete wall guarantee first cell n - th floor empty print a single number — number second joe need reach first floor ; else print word ` ` never '' ( without quote ) never happen please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier,['brute force'],2000.0
252/B,little petya like array integers a lot recently mother present one array consist n elements petya wonder whether swap two distinct integers array array get unsorted please note petya swap equal integers even distinct position array also note petya must swap two integers even original array meet requirements array a ( array elements index 1 ) consist n elements call sort meet least one follow two condition : help petya find two require position swap else say exist first line contain a single integer n ( 1 ≤ n ≤ 105 ) second line contain n non - negative space - separated integers a1 a2 ... — elements array petya 's mother present integers input exceed 109 . a pair position make array unsorted swap print number position separate a space several pair position print pair exist print -1 . position array number integers 1 n. first two sample require pair obviously n't exist third sample swap first two elements array look like : 2 1 3 4 . array unsorted,['brute force'],1800.0
710/B,give n point a line coordinate xi find point x sum distance give point minimal first line contain integer n ( 1 ≤ n ≤ 3·105 ) — number point line second line contain n integers xi ( - 109 ≤ xi ≤ 109 ) — coordinate give n point print integer x — position optimal point line several optimal point print position leftmost one guarantee answer always integer,['brute force'],1400.0
253/D,vasya recently start learn english need remember write english letter n't sure decide train a little find a sheet square paper begin write arbitrary english letter end vasya write n line contain m character thus get a rectangular n × m table cell table contain english letter let 's number table row top bottom integers 1 n columns — leave right integers 1 m. vasya look result rectangular table wonder many subtables match follow condition : formally a subtable 's definition follow define four integers x1 y1 x2 y2 1 ≤ x1 < x2 ≤ n 1 ≤ y1 < y2 ≤ m. subtable contain cells ( x y ) ( x row number y column number ) follow inequality hold x1 ≤ x ≤ x2 y1 ≤ y ≤ y2 corner cells table cells ( x1 y1 ) ( x1 y2 ) ( x2 y1 ) ( x2 y2 ) vasya already tire 's write letter a piece paper 's ask count value interest first line contain three integers n m k ( 2 ≤ n m ≤ 400 ; 0 ≤ k ≤ n·m ) next n line contain m character — give table character table a lowercase english letter print a single integer — number require subtables two suitable subtables first sample : first one 's upper leave corner cell ( 2 2 ) lower right corner cell ( 3 3 ) second one 's upper leave corner cell ( 2 1 ) lower right corner cell ( 3 4 ),['brute force'],2000.0
371/C,polycarpus love hamburgers much especially adore hamburgers make hand polycarpus think three decent ingredients make hamburgers : a bread sausage cheese write recipe favorite ` ` le hamburger de polycarpus '' a string letter ' b ' ( bread ) 's ' ( sausage ) и ' c ' ( cheese ) ingredients recipe go bottom top example recipe ` ` <unknown> '' represent hamburger ingredients go bottom top bread sausage cheese bread sausage polycarpus nb piece bread ns piece sausage nc piece cheese kitchen besides shop nearby three ingredients price pb rubles a piece bread ps a piece sausage pc a piece cheese polycarpus r rubles ready shop maximum number hamburgers cook ? assume polycarpus break slice piece bread sausage cheese besides shop unlimited number piece ingredient first line input contain a non - empty string describe recipe ` ` le hamburger de polycarpus '' length string n't exceed 100 string contain letter ' b ' ( uppercase english b ) 's ' ( uppercase english s ) ' c ' ( uppercase english c ) second line contain three integers nb ns nc ( 1 ≤ nb ns nc ≤ 100 ) — number piece bread sausage cheese polycarpus ' kitchen third line contain three integers pb ps pc ( 1 ≤ pb ps pc ≤ 100 ) — price one piece bread sausage cheese shop finally fourth line contain integer r ( 1 ≤ r ≤ 1012 ) — number rubles polycarpus please write % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print maximum number hamburgers polycarpus make ca n't make hamburger print 0,['brute force'],1600.0
299/A,"<unknown> a beginner coder today start study array array a1 a2 ... , consist n positive integers university teacher give a task find number array array elements divisible help find number ! first line contain integer n ( 1 ≤ n ≤ 105 ) show many number array next line contain integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — array elements print a single integer — number array array elements divisible number n't exist print -1 . multiple answer allow print",['brute force'],1000.0
315/A,sereja friends go a <unknown> guy n <unknown> bottle sereja forget bottle <unknown> usual guy come another way open bottle sereja know i - th bottle brand ai besides use open bottle brand bi use one bottle open multiple bottle sereja open bottle open bottle close bottle know sereja want find number bottle ' ve get wo n't able open way help find number first line contain integer n ( 1 ≤ n ≤ 100 ) — number bottle next n line contain bottle ' description i - th line contain two integers ai bi ( 1 ≤ ai bi ≤ 1000 ) — description i - th bottle a single line print a single integer — answer problem,['brute force'],1400.0
317/A,let us call a pair integer number m - perfect least one number pair greater equal m. thus pair ( 3 3 ) ( 0 2 ) 2 - perfect pair ( -1 1 ) two integers x y write blackboard allow erase one replace sum number ( x + y ) minimum number operations one perform order make give pair integers m - perfect ? single line input contain three integers x y m ( - 1018 ≤ x y m ≤ 1018 ) please use % lld specifier read write 64 - bit integers c++ preffered use cin cout stream % i64d specifier print minimum number operations ` ` -1 '' ( without quote ) impossible transform give pair m - perfect one first sample follow sequence operations suitable : ( 1 2 ) ( 3 2 ) ( 5 2 ) second sample : ( -1 4 ) ( 3 4 ) ( 7 4 ) ( 11 4 ) ( 15 4 ) finally third sample x y make positive hence proper sequence operations,['brute force'],1600.0
337/E,"a divisor tree a root tree meet follow condition : manao n distinct integers a1 a2 ... , try build a divisor tree contain number , ai least one vertex tree contain ai manao love <unknown> style tree large help manao determine minimum possible number vertices divisor tree seek first line contain a single integer n ( 1 ≤ n ≤ 8 ) second line contain n distinct space - separated integers ai ( 2 ≤ ai ≤ 1012 ) print a single integer — minimum number vertices divisor tree contain number ai sample 1 . smallest divisor tree look way : sample 2 . case build follow divisor tree : sample 3 . note tree consist a single vertex",['brute force'],2200.0
271/A,seem like year 2013 come yesterday know a curious fact ? year 2013 first year old <unknown> distinct digits suggest solve follow problem : give a year number find minimum year number strictly larger give one distinct digits single line contain integer y ( 1000 ≤ y ≤ <unknown> ) — year number print a single integer — minimum year number strictly larger y 's digits distinct guarantee answer exist,['brute force'],800.0
897/B,"— i experience many great things . — give memories like dream ... i leave ... — one last request ... — help solve a codeforces problem ? — <unknown> — ? chtholly think a problem days : a number palindrome length decimal representation without lead zero even call a zcy number a number palindrome mean write decimal representation contain lead zero read forward backwards example 12321 1221 palindromes 123 <unknown> moreover 1221 zcy number 12321 give integers k p calculate sum k smallest zcy number output sum modulo p. unfortunately willem n't good solve kind problems ask help ! first line contain two integers k p ( 1 ≤ k ≤ 105 1 ≤ p ≤ 109 ) output single integer — answer problem first example smallest zcy number 11 second smallest zcy number 22 . second example ,",['brute force'],1300.0
922/B,imp a magic forest xorangles grow ( <unknown> ? ) a xorangle order n a non - degenerate triangle lengths side integers exceed n xor - sum lengths equal zero imp count number distinct xorangles order n get forest formally a give integer n find number triple ( a b c ) : line contain a single integer n ( 1 ≤ n ≤ 2500 ) print number xorangles order n. xorangle first sample ( 3 5 6 ),['brute force'],1300.0
922/C,"imp watch a <unknown> <unknown> paint number <unknown> <unknown> order immediately attract attention imp rapidly propose a guess remainder division a number n integers i 1 k. unfortunately many integers analyze imp imp want check whether remainder distinct formally want check , 1 ≤ i ≤ k distinct i. e. pair ( i j ) : line contain two integers n k ( 1 ≤ n k ≤ 1018 ) print ` ` yes '' remainder distinct ` ` '' otherwise print letter arbitrary case ( lower upper ) first sample remainder modulo 1 4 coincide",['brute force'],1600.0
1607/C,"yelisey array $$$ a $$$ $$$ n $$$ integers $$$ a $$$ length strictly greater $$$ 1 $$$ <unknown> apply operation call minimum extraction : thus operation length array reduce $$$ 1 $$$ example $$$ a = [ 1 6 -4 -2 -4 ] $$$ minimum element $$$ a_3 = -4 $$$ mean operation array equal $$$ a= [ 1 { - ( -4 ) } 6 { - ( -4 ) } -2 { - ( -4 ) } -4 { - ( -4 ) } ] = [ 5 10 2 0 ] $$$ since yelisey like big number want number array $$$ a $$$ big possible formally <unknown> want make minimum number array $$$ a $$$ maximal possible ( i.e want maximize a minimum ) , yelisey apply minimum extraction operation array many time want ( possibly zero ) note operation apply array length $$$ 1 $$$ help find maximal value minimal element array apply several ( possibly zero ) minimum extraction operations array first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case next $$$ 2 t $$$ line contain descriptions test case description test case first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — original length array $$$ a $$$ second line description list $$$ n $$$ space - separated integers $$$ a_i $$$ ( $$$ -1000000000 \leq a_i \leq 1000000000 $$$ ) — elements array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ print $$$ t $$$ line contain answer correspond test case answer test case a single integer — maximal possible minimum $$$ a $$$ obtain several applications describe operation first example test case original length array $$$ n = 1 $$$ therefore minimum extraction apply thus array remain unchanged answer $$$ a_1 = 10 $$$ second set input data array always consist zero third set array change follow : $$$ [ \color { blue } { -1 } 2 0 ] \to [ 3 \color { blue } { 1 } ] \to [ \color { blue } { 2 } ] $$$ minimum elements highlight $$$ \color { blue } { \text { blue } } $$$ maximal one $$$ 2 $$$ fourth set array modify $$$ [ 2 10 \color { blue } { 1 } 7 ] \to [ \color { blue } { 1 } 9 6 ] \to [ 8 \color { blue } { 5 } ] \to [ \color { blue } { 3 } ] $$$ similarly maximum minimum elements $$$ 5 $$$",['brute force'],1000.0
1633/A,give integer $$$ n $$$ change minimum number digits a way result number lead zero divisible $$$ 7 $$$ multiple ways print give number already divisible $$$ 7 $$$ leave unchanged first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le <unknown> $$$ ) — number test case test case follow test case consist one line contain one integer $$$ n $$$ ( $$$ 10 \le n \le 999 $$$ ) test case print one integer without lead zero — result change ( i. e. integer divisible $$$ 7 $$$ obtain change minimum possible number digits $$$ n $$$ ) multiple ways apply change print result number give number already divisible $$$ 7 $$$ print first test case example $$$ 42 $$$ already divisible $$$ 7 $$$ 's need change second test case example multiple answer — $$$ 28 $$$ $$$ 21 $$$ $$$ 63 $$$ third test case example possible answer $$$ 357 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ note print $$$ <unknown> $$$ $$$ <unknown> $$$,['brute force'],800.0
1637/A,array $$$ a $$$ length $$$ n $$$ exactly select integer $$$ len $$$ $$$ 1 $$$ $$$ n - 1 $$$ inclusively sort non - decreasing order prefix array length $$$ len $$$ suffix array length $$$ n - len $$$ independently example array $$$ a = [ 3 1 4 5 2 ] $$$ choose $$$ len = 2 $$$ array equal $$$ [ 1 3 2 4 5 ] $$$ could perform operation array sort non - decreasing order ? several test case input data first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case follow test case description first line test case contain one integer $$$ n $$$ ( $$$ 2 \leq n \leq 10000 $$$ ) — length array second line test case contain a sequence integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — array elements guarantee sum $$$ n $$$ test case exceed $$$ 10000 $$$ test case input data output ` ` yes '' ( without quote ) array may sort non - decreasing order output ` ` '' ( without quote ) otherwise output letter case ( uppercase lowercase ) first test case 's possible select $$$ len = 1 $$$ operation array sort non - decreasing order equal $$$ [ 2 1 2 ] $$$ second test case 's possible select $$$ len = 3 $$$ operation array sort non - decreasing order equal $$$ [ 1 2 3 1 ] $$$ third test case array sort non - decreasing order every possible $$$ len $$$,['brute force'],800.0
1676/H1,"difference two versions version $$$ n \leq 1000 $$$ sum $$$ n $$$ test case exceed $$$ 1000 $$$ a terminal a row $$$ n $$$ equal segment number $$$ 1 $$$ $$$ n $$$ order two terminals one give array $$$ a $$$ length $$$ n $$$ $$$ i = 1 2 \dots n $$$ a straight wire point segment $$$ i $$$ top terminal point segment $$$ a_i $$$ bottom terminal ca n't select endpoints a segment example follow picture show two possible wire $$$ n=7 $$$ $$$ a= [ 4,1,4,6,7,7,5 ] $$$ a cross occur two wire share a point common picture cross circle red maximum number cross place wire optimally ? first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — elements array sum $$$ n $$$ across test case exceed $$$ 1000 $$$ test case output a single integer — maximum number cross place wire optimally first test case show second picture statement second test case wire possible two wire cross answer $$$ 1 $$$ third test case wire possible one wire answer $$$ 0 $$$",['brute force'],1400.0
1320/F,"polycarp play a well - known computer game ( wo n't mention name ) every object game consist three - dimensional block — axis - aligned cub size $$$ 1 \times 1 \times 1 $$$ block unaffected gravity float air without support block place cells size $$$ 1 \times 1 \times 1 $$$ ; cell either contain exactly one block empty cell represent coordinate $$$ ( x y z ) $$$ ( cell coordinate a cube opposite corner $$$ ( x y z ) $$$ $$$ ( x + 1 y + 1 z + 1 ) $$$ ) content $$$ a _ { x y z } $$$ ; cell empty $$$ a _ { x y z } = 0 $$$ otherwise $$$ a _ { x y z } $$$ equal type block place ( type integers $$$ 1 $$$ $$$ 200000 $$$ ) polycarp build a large structure consist block structure enclose axis - aligned rectangular parallelepiped size $$$ n \times m \times k $$$ contain cells $$$ ( x y z ) $$$ $$$ x \in [ 1 n ] $$$ $$$ y \in [ 1 m ] $$$ $$$ z \in [ 1 k ] $$$ , polycarp instal $$$ 2 nm + <unknown> + <unknown> $$$ sensors around parallelepiped a sensor a special block send a ray direction show type first block hit ray ( except sensors ) sensors instal polycarp adjacent border parallelepiped ray send parallel one coordinate ax direct inside parallelepiped formally sensors divide $$$ 6 $$$ type : polycarp invite friend monocarp play course soon monocarp saw a large parallelepiped bound sensor block begin wonder inside polycarp n't want tell monocarp exact shape figure provide monocarp data sensors tell try guess content parallelepiped hours think monocarp clue 's inside sensor - <unknown> space want give decide ask help write a program analyze sensor data construct figure consistent ? first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n m k \le 200000 $$$ $$$ nmk \le 200000 $$$ ) — dimension parallelepiped sensor data follow sensor data either $$$ 0 $$$ ray <unknown> reach opposite sensor ( block ) integer $$$ 1 $$$ $$$ 200000 $$$ denote type first block hit ray data divide $$$ 6 $$$ section ( one type sensors ) consecutive pair section separate a blank line first section separate a blank line first line input first section consist $$$ m $$$ line contain $$$ k $$$ integers $$$ j $$$ -th integer $$$ i $$$ -th line data sensor instal $$$ ( 0 i j ) $$$ second section consist $$$ m $$$ line contain $$$ k $$$ integers $$$ j $$$ -th integer $$$ i $$$ -th line data sensor instal $$$ ( n + 1 i j ) $$$ third section consist $$$ n $$$ line contain $$$ k $$$ integers $$$ j $$$ -th integer $$$ i $$$ -th line data sensor instal $$$ ( i 0 j ) $$$ fourth section consist $$$ n $$$ line contain $$$ k $$$ integers $$$ j $$$ -th integer $$$ i $$$ -th line data sensor instal $$$ ( i m + 1 j ) $$$ fifth section consist $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th integer $$$ i $$$ -th line data sensor instal $$$ ( i j 0 ) $$$ finally sixth section consist $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th integer $$$ i $$$ -th line data sensor instal $$$ ( i j k + 1 ) $$$ information input inconsistent print one integer $$$ -1 $$$ otherwise print figure inside parallelepiped follow output consist $$$ nmk $$$ integers : $$$ a _ { 1 1 1 } $$$ $$$ a _ { 1 1 2 } $$$ ... $$$ a _ { 1 1 k } $$$ $$$ a _ { 1 2 1 } $$$ ... $$$ a _ { 1 2 k } $$$ ... $$$ a _ { 1 m k } $$$ $$$ a _ { 2 1 1 } $$$ ... $$$ a _ { n m k } $$$ $$$ a _ { i j k } $$$ type block $$$ ( i j k ) $$$ $$$ 0 $$$ block multiple figure consistent sensor data describe convenience sample output format follow : $$$ n $$$ separate section block $$$ x = 1 $$$ $$$ x = 2 $$$ ... $$$ x = n $$$ ; section consist $$$ m $$$ line contain $$$ k $$$ integers note type output acceptable may print integers format instead ( even integers line ) order matter",['brute force'],3500.0
1753/F,"little misha go program club solve nothing may seem strange find misha film a minecraft series everything fall place ... misha <unknown> manhattan build a city minecraft imagine a table size $$$ n \times m $$$ $$$ k $$$ students live a city $$$ i $$$ -th student live house locate intersection $$$ x_i $$$ -th row $$$ y_i $$$ -th column also student a degree aggressiveness $$$ w_i $$$ since city turn large misha decide <unknown> limit action series square $$$ s $$$ side parallel coordinate ax length side square integer $$$ 1 $$$ $$$ \min ( n m ) $$$ cells accord plot main hero come city accidentally fall square $$$ s $$$ possess a unique degree aggressiveness $$$ 0 $$$ able show leadership qualities assemble a team calm <unknown> <unknown> students order assemble team <unknown> close - <unknown> degrees aggressiveness students team must pairwise distinct must form a single segment consecutive integers formally exist students degrees aggressiveness $$$ l l+1 \ldots -1 1 \ldots r-1 r $$$ inside square $$$ s $$$ $$$ l \le 0 \le r $$$ main hero able form a team $$$ r - l+1 $$$ people ( course include team ) notice require take students square $$$ s $$$ team misha think team consist least $$$ t $$$ people interest many square table main hero able form a team least $$$ t $$$ people help calculate first line contain four integers $$$ n $$$ $$$ m $$$ $$$ k $$$ $$$ t $$$ ( $$$ 1 \le n m \le 40\,000 $$$ $$$ 1 \le n \cdot m \le 40\,000 $$$ $$$ 1 \le k \le 1000000 $$$ $$$ 1 \le t \le k + 1 $$$ ) — number row columns table number students live city respectively follow $$$ k $$$ line contain three integers $$$ x_i $$$ $$$ y_i $$$ $$$ w_i $$$ ( $$$ 1 \le x_i \le n $$$ $$$ 1 \le y_i \le m $$$ $$$ 1 \le <unknown> w_i <unknown> \le 1000000000 $$$ ) — number row column $$$ i $$$ -th student live degree aggressiveness print one integer — number ways choose square $$$ s $$$ way main hero able form a team least $$$ t $$$ people",['brute force'],3500.0
1769/D2,в этой версии задачи игроки <unknown> <unknown> не только на <unknown> но и на <unknown> <unknown> игры для них <unknown> <unknown> величины важности первого хода и нужно найти $$$ 13 $$$ раскладов с различными значениями этой величины алиса и боб решили сыграть в карточную игру « девятка » пожалуйста внимательно прочитайте условие задачи поскольку правила могут отличаться от известных вам для игры нужна стандартная колода из $$$ 36 $$$ карт — по девять карт ( от шестёрки до туза ) каждой из четырёх мастей ( трефы бубны пики и черви ) карты по достоинству от младшей к старшей идут следующим образом : шестёрка семёрка восьмёрка девятка десятка валет дама король туз перед игрой колода перемешивается и каждому игроку раздаётся по $$$ 18 $$$ карт карты нужно выкладывать из руки на стол по определённым правилам выигрывает игрок который первым выложит все карты из своей руки игроки ходят по очереди ход игрока имеет один из следующих видов : например девятку пик можно выложить на стол в любой момент для выкладывания семёрки треф необходимо наличие на столе восьмёрки треф а для выкладывания туза червей необходимо наличие на столе короля червей если игрок не может выложить на стол ни одну карту из своей руки то ход переходит к сопернику обратите внимание : нельзя пропустить ход просто так — всегда необходимо выложить карту на стол корректным образом если это возможно помимо того что каждый игрок стремится избавиться от карт в своей руке алиса и боб также хотят чтобы в конце игры в руке у их соперника карт осталось как можно больше а в их руке — как можно меньше напомним что игра заканчивается как только один из игроков выкладывает на стол последнюю карту из своей руки результатом игры назовём совокупность из информации о том кто из двух игроков выиграет при оптимальной игре а также о том сколько карт останется в руке у проигравшего пусть алиса и боб уже взяли в руки свои $$$ 18 $$$ карт каждый но ещё не решили кто из них будет ходить первым величиной важности первого хода для данного расклада назовём абсолютную разность между результатами игры в случае если первой будет ходить алиса и в случае если первым будет ходить боб например если в обоих случаях выиграет боб но в одном случае у алисы останется $$$ 6 $$$ карт в руке в конце игры а во втором — всего $$$ 2 $$$ то величина важности первого хода равна $$$ 4 $$$ если же в одном случае выиграет алиса и у боба останется $$$ 5 $$$ карт в руке а во втором случае выиграет боб и у алисы останется $$$ 3 $$$ карты в руке то величина важности первого хода равна $$$ 8 $$$ ребята хотят узнать насколько разной бывает величина важности первого хода для разных раскладов по заданному числу $$$ k \le 13 $$$ помогите им найти такие $$$ k $$$ раскладов что величины важности первого хода для всех них — различные целые числа в единственной строке задано целое число $$$ k $$$ ( $$$ 2 \le k \le 13 $$$ ) — число необходимых раскладов в задаче <unknown> теста в первом тесте $$$ k = 2 $$$ во втором тесте $$$ k = 13 $$$ выведите $$$ k $$$ пар строк каждая пара строк должна соответствовать некоторому раскладу величины важности первого хода для всех выведенных раскладов должны быть различными целыми числами в первой строке каждой пары выведите $$$ 18 $$$ строк длины $$$ 2 $$$ через пробел описывающих карты алисы в любом порядке первый символ строки должен обозначать достоинство карты — символ из набора 6 7 8 9 t j q k a обозначающий шестёрку семёрку восьмёрку девятку десятку валета даму короля и туза соответственно второй символ строки должен обозначать масть карты — символ из набора c d s h обозначающий трефы бубны пики и черви соответственно во второй строке выведите $$$ 18 $$$ строк длины $$$ 2 $$$ через пробел описывающих карты боба в том же формате каждая из $$$ 36 $$$ возможных карт должна находиться в руке одного из двух игроков в единственном экземпляре в первом выведенном раскладе все девятки находятся в руке у алисы даже если боб будет ходить первым ему всё равно придётся пропустить первый же свой ход следовательно первый ход при таком раскладе имеет важность $$$ 0 $$$ во втором выведенном раскладе вне зависимости от того чьим будет первый ход выиграет алиса однако если алиса будет ходить первой то у боба в конце игры в руке останется одна карта а если же она будет ходить второй то у боба останется пять карт соответственно величина важности первого хода при таком раскладе равна $$$ 4 $$$,['brute force'],2200.0
1779/H,"iron werewolf participate a chess olympiad want practice team build gather $$$ n $$$ players $$$ n $$$ a power $$$ 2 $$$ play sport iron werewolf among $$$ n $$$ people one sport tug war $$$ 1\leq i \leq n $$$ $$$ i $$$ -th player strength $$$ s_i $$$ <unknown> round hold one player remain — call player absolute winner round : iron already know player 's strength wonder become absolute winner ca n't may choose team form round well win team case equal strengths first line contain a single integer $$$ n $$$ ( $$$ 4 \leq n \leq 32 $$$ ) — number players participate tug war guarantee $$$ n $$$ a power $$$ 2 $$$ second line consist a sequence $$$ s_1 s_2 \ldots s_n $$$ integers ( $$$ 1 \leq s_i \leq 10^ { 15 } $$$ ) — strengths players a single line output a binary string $$$ s $$$ length $$$ n $$$ — $$$ i $$$ -th character $$$ s $$$ $$$ 1 $$$ $$$ i $$$ -th player become absolute winner $$$ 0 $$$ otherwise first example players $$$ 1 $$$ $$$ 4 $$$ respective strengths $$$ 60 $$$ $$$ <unknown> $$$ become absolute winners let 's describe process player $$$ 1 $$$ firstly divide players team $$$ [ 1,3 ] $$$ $$$ [ 2,4 ] $$$ strengths two team $$$ 60 + <unknown> $$$ $$$ 32 + <unknown> $$$ equal iron choose <unknown> two team let choice second team leave players $$$ 1 $$$ $$$ 3 $$$ since $$$ 1 $$$ greater strength ( $$$ 60 > 59 $$$ ) win declare absolute winner last remain player third example strengths remain players may look like $$$ [ <unknown> ] \rightarrow [ <unknown> ] \rightarrow [ <unknown> ] \rightarrow [ 8 ] $$$ person strength $$$ 8 $$$ become absolute winner prove others ca n't",['brute force'],3500.0
1786/B,a cake assembly line a bakery optimize $$$ n $$$ cake make a time ! last step $$$ n $$$ cake cover chocolate consider a side view conveyor belt let a number line $$$ i $$$ -th cake occupy segment $$$ [ a_i - w a_i + w ] $$$ line pair segment common point conveyor $$$ n $$$ dispensers a common button press chocolate $$$ i $$$ -th <unknown> cover conveyor segment $$$ [ b_i - h b_i + h ] $$$ pair segment also common point <unknown> conveyor belt part yet perform make determine 's possible shift conveyor cake chocolate chocolate outside cake assume <unknown> long enough cake never fall also note button press test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow first line test case contain three integers $$$ n $$$ $$$ w $$$ $$$ h $$$ ( $$$ 1 \le n \le 100000 $$$ ; $$$ 1 \le w h \le 100000 $$$ ; $$$ h \le w $$$ ) — number cake dispensers well <unknown> cake segment chocolate <unknown> second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — position cake center guarantee $$$ a_i + w < a _ { i + 1 } - w $$$ $$$ i $$$ third line contain $$$ n $$$ integers $$$ b_1 $$$ $$$ b_2 $$$ ... $$$ b_n $$$ ( $$$ 1 \le b_i \le 1000000000 $$$ ) — position dispensers guarantee $$$ b_i + h < b _ { i + 1 } - h $$$ $$$ i $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case output ` ` yes '' 's possible shift conveyor a way cake end chocolate chocolate outside cake ` ` '' otherwise output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses first example show figure statement second example move conveyor example center cake $$$ 4 9 14 19 24 $$$ third example ca n't move conveyor accordingly,['brute force'],1300.0
1832/B,give array $$$ a_1 a_2 \dots a_n $$$ elements different perform exactly $$$ k $$$ operations operation exactly one follow two action ( choose ) : calculate maximum possible sum elements result array first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist two line : additional constraint input : sum $$$ n $$$ exceed $$$ 200000 $$$ test case print one integer — maximum possible sum elements result array first testcase apply first operation produce follow outcome : $$$ 21 $$$ best answer second testcase 's optimal first erase two minimums a maximum,['brute force'],1100.0
1769/D3,в этой версии задачи нужно найти $$$ 26 $$$ раскладов с различными значениями важности первого хода алиса и боб решили сыграть в карточную игру « девятка » пожалуйста внимательно прочитайте условие задачи поскольку правила могут отличаться от известных вам для игры нужна стандартная колода из $$$ 36 $$$ карт — по девять карт ( от шестёрки до туза ) каждой из четырёх мастей ( трефы бубны пики и черви ) карты по достоинству от младшей к старшей идут следующим образом : шестёрка семёрка восьмёрка девятка десятка валет дама король туз перед игрой колода перемешивается и каждому игроку раздаётся по $$$ 18 $$$ карт карты нужно выкладывать из руки на стол по определённым правилам выигрывает игрок который первым выложит все карты из своей руки игроки ходят по очереди ход игрока имеет один из следующих видов : например девятку пик можно выложить на стол в любой момент для выкладывания семёрки треф необходимо наличие на столе восьмёрки треф а для выкладывания туза червей необходимо наличие на столе короля червей если игрок не может выложить на стол ни одну карту из своей руки то ход переходит к сопернику обратите внимание : нельзя пропустить ход просто так — всегда необходимо выложить карту на стол корректным образом если это возможно помимо того что каждый игрок стремится избавиться от карт в своей руке алиса и боб также хотят чтобы в конце игры в руке у их соперника карт осталось как можно больше а в их руке — как можно меньше напомним что игра заканчивается как только один из игроков выкладывает на стол последнюю карту из своей руки результатом игры назовём совокупность из информации о том кто из двух игроков выиграет при оптимальной игре а также о том сколько карт останется в руке у проигравшего пусть алиса и боб уже взяли в руки свои $$$ 18 $$$ карт каждый но ещё не решили кто из них будет ходить первым величиной важности первого хода для данного расклада назовём абсолютную разность между результатами игры в случае если первой будет ходить алиса и в случае если первым будет ходить боб например если в обоих случаях выиграет боб но в одном случае у алисы останется $$$ 6 $$$ карт в руке в конце игры а во втором — всего $$$ 2 $$$ то величина важности первого хода равна $$$ 4 $$$ если же в одном случае выиграет алиса и у боба останется $$$ 5 $$$ карт в руке а во втором случае выиграет боб и у алисы останется $$$ 3 $$$ карты в руке то величина важности первого хода равна $$$ 8 $$$ ребята хотят узнать насколько разной бывает величина важности первого хода для разных раскладов по заданному числу $$$ k \le 26 $$$ помогите им найти такие $$$ k $$$ раскладов что величины важности первого хода для всех них — различные целые числа в единственной строке задано целое число $$$ k $$$ ( $$$ 2 \le k \le 26 $$$ ) — число необходимых раскладов в задаче <unknown> теста в первом тесте $$$ k = 2 $$$ во втором тесте $$$ k = 13 $$$ в <unknown> тесте $$$ k = 26 $$$ выведите $$$ k $$$ пар строк каждая пара строк должна соответствовать некоторому раскладу величины важности первого хода для всех выведенных раскладов должны быть различными целыми числами в первой строке каждой пары выведите $$$ 18 $$$ строк длины $$$ 2 $$$ через пробел описывающих карты алисы в любом порядке первый символ строки должен обозначать достоинство карты — символ из набора 6 7 8 9 t j q k a обозначающий шестёрку семёрку восьмёрку девятку десятку валета даму короля и туза соответственно второй символ строки должен обозначать масть карты — символ из набора c d s h обозначающий трефы бубны пики и черви соответственно во второй строке выведите $$$ 18 $$$ строк длины $$$ 2 $$$ через пробел описывающих карты боба в том же формате каждая из $$$ 36 $$$ возможных карт должна находиться в руке одного из двух игроков в единственном экземпляре в первом выведенном раскладе все девятки находятся в руке у алисы даже если боб будет ходить первым ему всё равно придётся пропустить первый же свой ход следовательно первый ход при таком раскладе имеет важность $$$ 0 $$$ во втором выведенном раскладе вне зависимости от того чьим будет первый ход выиграет алиса однако если алиса будет ходить первой то у боба в конце игры в руке останется одна карта а если же она будет ходить второй то у боба останется пять карт соответственно величина важности первого хода при таком раскладе равна $$$ 4 $$$,['brute force'],2300.0
1411/B,call a positive integer number fair divisible nonzero digits example $$$ 102 $$$ fair ( divisible $$$ 1 $$$ $$$ 2 $$$ ) $$$ <unknown> $$$ n't divisible $$$ 8 $$$ give a positive integer $$$ n $$$ find minimum integer $$$ x $$$ $$$ n \leq x $$$ $$$ x $$$ fair first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) next $$$ t $$$ line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 10^ { 18 } $$$ ) $$$ t $$$ test case print a single integer — least fair number less $$$ n $$$ explanations test case :,['brute force'],1000.0
292/C,problem use a simplify <unknown> / ip address model please read statement carefully ip address a 32 - bit integer represent a group four decimal 8 - bit integers ( without lead zero ) separate commas example record <unknown> show a correct ip address record <unknown> <unknown> give problem arbitrary group four 8 - bit integers a correct ip address hero polycarpus still work a system administrator large corporation like beautiful ip address check ip address beautiful follow : let us remind a palindrome a string read right leave leave right example ip address <unknown> <unknown> beautiful ( string ` ` <unknown> '' ` ` <unknown> '' palindromes ) ip address <unknown> <unknown> polycarpus want find beautiful ip address give set digits digit set must occur ip address least ip address must contain digits help cope difficult task first line contain a single integer n ( 1 ≤ n ≤ 10 ) — number digits set second line contain set integers a1 a2 ... ( 0 ≤ ai ≤ 9 ) guarantee digits set distinct first line print a single integer k — number beautiful ip address contain give set digits follow k line print ip address one per line arbitrary order,['brute force'],2000.0
268/A,manao work a sport tv 's spend much time watch football game country a begin notice different pattern example team two set uniform : home uniform guest uniform a team play a game home players put home uniform a team play a guest somebody else 's stadium players put guest uniform exception rule : home uniform color host team match guests ' uniform host team put guest uniform well team color home guest uniform different n team take part national championship championship consist n · ( n - 1 ) game : team invite team stadium point manao wonder : many time championship a host team go put guest uniform ? note order game affect number know color home guest uniform team simplicity color number integers a way two distinct color number help manao find answer question first line contain integer n ( 2 ≤ n ≤ 30 ) follow n line contain a pair distinct space - separated integers hi ai ( 1 ≤ hi ai ≤ 100 ) — color i - th team 's home guest uniform respectively a single line print number game host team go play guest uniform first test case championship consist 6 game game event question game team 2 1 stadium team 2 . second test sample host team wear guest uniform game team : 1 2 2 1 2 3 3 4 4 2 ( host team write first ),['brute force'],800.0
1759/D,"<unknown> occur <unknown> store need change price goods current price good $$$ n $$$ give allow increase price good $$$ k $$$ time $$$ 1 \le k \le m $$$ k integer output roundest possible new price good , one maximum number zero end example number 481000 round number 1000010 ( three zero end 481000 one end 1000010 ) several possible variants output one new price maximal impossible get a <unknown> price output $$$ n \cdot m $$$ ( maximum possible price ) first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — the number test case test test case consist one line line contain two integers : $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 1000000000 $$$ ) $$$ n $$$ old price good number $$$ m $$$ mean increase price $$$ n $$$ $$$ m $$$ time test case output a separate line roundest integer form $$$ n \cdot k $$$ ( $$$ 1 \le k \le m $$$ $$$ k $$$ — integer ) several possible variants output one new price ( value $$$ n \cdot k $$$ ) maximal impossible get a round price output $$$ n \cdot m $$$ ( maximum possible price ) first case $$$ n = 6 $$$ $$$ m = 11 $$$ get a number two zero end need increase price $$$ 50 $$$ time $$$ 50 > m = 11 $$$ maximum price multiple $$$ 10 $$$ would $$$ 60 = 60 $$$ second case $$$ n = 5 $$$ $$$ m = <unknown> $$$ maximum price multiple $$$ 100 $$$ would $$$ 200 = 200 $$$ third case $$$ n = 13 $$$ $$$ m = 5 $$$ possible new price end $$$ 0 $$$ output $$$ n \cdot m = <unknown> $$$ fourth case increase price $$$ 15 $$$ time fifth case increase price $$$ <unknown> $$$ time",['brute force'],1400.0
949/E,never late play <unknown> ` ` binary card '' game ! infinite amount card positive negative rank use game absolute value card rank a power two i.e card a rank either 2k - 2k integer k ≥ 0 . infinite amount card valid rank begin game player form deck multiset ( possibly empty ) card allow pick number card rank small deck consider a skill indicator game consist n round i - th round jury tell player integer ai player <unknown> draw a subset deck sum rank choose card equal ai ( allow draw card case sum consider equal zero ) player fail lose game otherwise player take back card deck game proceed next round player consider a winner able draw suitable set card round somebody tell number ai jury go tell round want pick a deck consist minimum number card allow win ` ` binary card '' game first line input contain integer n ( 1 ≤ n ≤ 100 000 ) number round game second line input contain n integers a1 a2 ... ( - 100 000 ≤ ai ≤ 100 000 ) number jury go tell round first line print integer k ( 0 ≤ k ≤ 100 000 ) minimum number card pick deck order win ` ` binary card '' second line print k integers b1 b2 ... bk ( - 220 ≤ bi ≤ 220 |bi| a power two ) rank card deck may output rank order several optimum deck allow print guarantee exist a deck minimum size satisfy requirements first sample round game may simply draw card note sample test one satisfy first test group constraints second sample may draw card - 1 first round card 4 - 1 second round nothing third round card 4 fourth round whole deck fifth round,['brute force'],2700.0
958/C1,"rebel spy heidi obtain plan death star empire way safety try break encryption plan ( course encrypt – empire may evil stupid ! ) encryption several level security first one look heidi present a screen show a sequence integers a a positive integer p. know encryption code a single number s define follow : define score x sum elements x modulo p. heidi give a sequence a consist n integers also give integer p. need split a 2 part : output sum s encryption code first line input contain two space - separated integer n p ( 2 ≤ n ≤ 100 000 2 ≤ p ≤ 10 000 ) – number elements a modulo compute score respectively second line contain n space - separated integers elements a. integer interval [ 1 1 000 000 ] output number s describe problem statement first example score maximize input sequence split two part ( 3 4 ) ( 7 2 ) give total score second example score maximize first part consist first three elements second part consist rest , score",['brute force'],1200.0
1028/F,consider a set point $$$ a $$$ initially empty three type query : first line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query follow $$$ q $$$ line describe a query contain three integers $$$ t_i $$$ $$$ x_i $$$ $$$ y_i $$$ ( $$$ t_i \in \ { 1 2 3\ } $$$ $$$ 1 \le x_i y_i \le <unknown> $$$ ) — type query coordinate point type $$$ 1 $$$ addition point type $$$ 2 $$$ <unknown> point type $$$ 3 $$$ query compute minimum number point require make $$$ a $$$ symmetrical guarantee $$$ 100000 $$$ query type $$$ 3 $$$ $$$ 100000 $$$ query type $$$ 1 $$$ $$$ 2 $$$ query third type output a line a single integer — answer query first example show picture,['brute force'],2900.0
1057/B,get news ddos - <unknown> popular websites arseny admin think a website a ddos - attack total number request a period time exceed $$$ 100 \cdot t $$$ $$$ t $$$ — number second time segment arseny know statistics number request per second since server boot know sequence $$$ r_1 r_2 \dots r_n $$$ $$$ r_i $$$ — number request $$$ i $$$ -th second boot determine length longest continuous period time arseny consider a ddos - attack a seek time period go beyond boundaries segment $$$ [ 1 n ] $$$ first line contain $$$ n $$$ ( $$$ 1 \le n \le 5000 $$$ ) — number second since server boot second line contain sequence integers $$$ r_1 r_2 \dots r_n $$$ ( $$$ 0 \le r_i \le 5000 $$$ ) $$$ r_i $$$ — number request $$$ i $$$ -th second print integer number — length longest time period consider a ddos - attack arseny n't exist print 0,['brute force'],1400.0
1120/E,a positive integer $$$ a $$$ give baron <unknown> <unknown> know a positive integer $$$ n $$$ one multiply $$$ n $$$ $$$ a $$$ sum digits decrease $$$ a $$$ time word $$$ s ( ) = s ( n ) <unknown> $$$ $$$ s ( x ) $$$ denote sum digits number $$$ x $$$ find baron tell true line contain a single integer $$$ a $$$ ( $$$ 2 \le a \le 1000 $$$ ) number $$$ n $$$ print $$$ -1 $$$ otherwise print appropriate positive integer $$$ n $$$ number must consist $$$ 5\cdot100000 $$$ digits show give constraints either answer answer longer $$$ 5\cdot100000 $$$ digits,['brute force'],2600.0
1132/C,a long fence consist $$$ n $$$ section unfortunately paint decide hire $$$ q $$$ painters paint $$$ i $$$ -th painter paint section $$$ x $$$ $$$ l_i \le x \le r_i $$$ unfortunately a <unknown> budget may hire $$$ q - 2 $$$ painters obviously painters hire work want maximize number paint section choose $$$ q - 2 $$$ painters optimally a section consider paint least one painter paint first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 3 \le n q \le 5000 $$$ ) — number section number painters <unknown> hire respectively $$$ q $$$ line follow describe one painters : $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le n $$$ ) print one integer — maximum number paint section hire $$$ q - 2 $$$ painters,['brute force'],1700.0
1148/B,arkady buy air ticket a city a a city c. unfortunately direct flight a lot flight a a city b b c. $$$ n $$$ flight a b depart time moments $$$ a_1 $$$ $$$ a_2 $$$ $$$ a_3 $$$ ... $$$ a_n $$$ arrive b $$$ t_a $$$ moments later $$$ m $$$ flight b c depart time moments $$$ b_1 $$$ $$$ b_2 $$$ $$$ b_3 $$$ ... $$$ b_m $$$ arrive c $$$ t_b $$$ moments later connection time <unknown> one use $$$ i $$$ -th flight a b $$$ j $$$ -th flight b c $$$ b_j \ge a_i + t_a $$$ cancel $$$ k $$$ flight cancel a flight arkady use arkady want c early possible want c late possible find earliest time arkady arrive c optimally cancel $$$ k $$$ flight cancel $$$ k $$$ less flight a way possible reach c print $$$ -1 $$$ first line contain five integers $$$ n $$$ $$$ m $$$ $$$ t_a $$$ $$$ t_b $$$ $$$ k $$$ ( $$$ 1 \le n m \le 200000 $$$ $$$ 1 \le k \le n + m $$$ $$$ 1 \le t_a t_b \le 1000000000 $$$ ) — number flight a b number flight b c flight time a b flight time b c number flight cancel respectively second line contain $$$ n $$$ distinct integers increase order $$$ a_1 $$$ $$$ a_2 $$$ $$$ a_3 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_1 < a_2 < \ldots < a_n \le 1000000000 $$$ ) — time flight a b depart third line contain $$$ m $$$ distinct integers increase order $$$ b_1 $$$ $$$ b_2 $$$ $$$ b_3 $$$ ... $$$ b_m $$$ ( $$$ 1 \le b_1 < b_2 < \ldots < b_m \le 1000000000 $$$ ) — time flight b c depart cancel $$$ k $$$ less flight a way possible reach c print $$$ -1 $$$ otherwise print earliest time arkady arrive c cancel $$$ k $$$ flight a way maximize time consider first example flight a b depart time moments $$$ 1 $$$ $$$ 3 $$$ $$$ 5 $$$ $$$ 7 $$$ arrive b time moments $$$ 2 $$$ $$$ 4 $$$ $$$ 6 $$$ $$$ 8 $$$ respectively flight b c depart time moments $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 9 $$$ $$$ 10 $$$ arrive c time moments $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 10 $$$ $$$ 11 $$$ respectively cancel two flight optimal solution cancel first flight a b fourth flight b c. way arkady take second flight a b arrive b time moment $$$ 4 $$$ take last flight b c arrive c time moment $$$ 11 $$$ second example simply cancel flight a b 're do third example cancel one flight optimal solution cancel first flight a b. note still enough time catch last flight b c,['brute force'],1600.0
1168/B,"toad rash a binary string $$$ s $$$ a binary string consist zero ones let $$$ n $$$ length $$$ s $$$ rash need find number pair integers $$$ l $$$ $$$ r $$$ $$$ 1 \leq l \leq r \leq n $$$ least one pair integers $$$ x $$$ $$$ k $$$ $$$ 1 \leq x k \leq n $$$ $$$ l \leq x < x + 2k \leq r $$$ $$$ s_x = s _ { x+k } = s _ { x+2k } $$$ find number pair rash first line contain string $$$ s $$$ ( $$$ 1 \leq |s| \leq 300\,000 $$$ ) consist zero ones output one integer : number pair integers $$$ l $$$ $$$ r $$$ $$$ 1 \leq l \leq r \leq n $$$ least one pair integers $$$ x $$$ $$$ k $$$ $$$ 1 \leq x k \leq n $$$ $$$ l \leq x < x + 2k \leq r $$$ $$$ s_x = s _ { x+k } = s _ { x+2k } $$$ first example three $$$ l $$$ $$$ r $$$ pair need count : $$$ 1 $$$ $$$ 6 $$$ ; $$$ 2 $$$ $$$ 6 $$$ ; $$$ 1 $$$ $$$ 5 $$$ second example value $$$ x $$$ $$$ k $$$ initial string answer $$$ 0 $$$",['brute force'],1900.0
1184/A2,"learn polynomial hash heidi decide learn shift - xor hash particular come across interest problem give a bitstring $$$ y \in \ { 0,1\ } ^n $$$ find number different $$$ k $$$ ( $$$ 0 \leq k < n $$$ ) exist $$$ x \in \ { 0,1\ } ^n $$$ $$$ y = x \oplus \mbox { shift } ^k ( x ) $$$ $$$ \oplus $$$ xor operation $$$ \mbox { shift } ^k $$$ operation shift a bitstring cyclically right $$$ k $$$ time example $$$ <unknown> \oplus 111 = 110 $$$ $$$ \mbox { shift } <unknown> ( <unknown> ) = <unknown> $$$ first line contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) length bitstring $$$ y $$$ second line contain bitstring $$$ y $$$ output a single integer : number suitable value $$$ k $$$ first example : $$$ x $$$ $$$ x \oplus x = 1010 $$$ hence answer $$$ 3 $$$",['brute force'],2100.0
1191/A,"tokitsukaze one character game ` ` <unknown> collection '' game every character a common <unknown> — health point shorten hp general different value hp group $$$ 4 $$$ categories : <unknown> - <unknown> $$$ n $$$ integer $$$ 4 $$$ categories order highest lowest $$$ a > b > c > d $$$ mean category $$$ a $$$ highest category $$$ d $$$ lowest play game players increase hp character , tokitsukaze want increase hp $$$ 2 $$$ ( either $$$ 0 $$$ $$$ 1 $$$ $$$ 2 $$$ ) much increase hp highest possible category ? line contain a single integer $$$ x $$$ ( $$$ 30 \leq x \leq 100 $$$ ) — value tokitsukaze 's hp currently print integer $$$ a $$$ ( $$$ 0 \leq a \leq 2 $$$ ) uppercase letter $$$ b $$$ ( $$$ b \in <unknown> a b c d <unknown> $$$ ) represent best way increase hp $$$ a $$$ category become $$$ b $$$ note output character case - sensitive first example category tokitsukaze 's hp already $$$ a $$$ n't need enhance ability second example : therefore best way increase hp $$$ 1 $$$ category hp become $$$ b $$$",['brute force'],800.0
1210/A,anadi a set dominoes every domino two part part contain dot every $$$ a $$$ $$$ b $$$ $$$ 1 \leq a \leq b \leq 6 $$$ exactly one domino $$$ a $$$ dot one half $$$ b $$$ dot half set contain exactly $$$ 21 $$$ dominoes exact illustration set : also anadi undirected graph without self - loops multiple edge want choose dominoes place edge graph use one domino type edge fit one domino 's necessary place a domino edge graph place a domino edge also choose direction word one half place domino must direct toward one endpoints edge half must direct toward endpoint 's a catch : multiple halve dominoes direct toward vertex halve must contain number dot many dominoes anadi place edge graph ? first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 7 $$$ $$$ 0 \leq m \leq \frac { <unknown> ( n-1 ) } { 2 } $$$ ) — number vertices number edge graph next $$$ m $$$ line contain two integers integers $$$ i $$$ -th line $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a b \leq n $$$ $$$ a \neq b $$$ ) denote edge connect vertices $$$ a_i $$$ $$$ b_i $$$ graph might disconnect 's however guarantee graph n't contain self - loops one edge pair vertices output one integer denote maximum number dominoes anadi place edge graph illustration anadi 's graph first sample test : one ways place a domino edge : note vertex face halve dominoes number dot instance halve direct toward vertex $$$ 1 $$$ three dot,['brute force'],1700.0
1269/B,"give a positive integer $$$ m $$$ two integer sequence : $$$ a= [ a_1 a_2 \ldots a_n ] $$$ $$$ b= [ b_1 b_2 \ldots b_n ] $$$ sequence a length $$$ n $$$ permutation a sequence $$$ n $$$ different positive integers $$$ 1 $$$ $$$ n $$$ example sequence permutations : $$$ [ 1 ] $$$ $$$ [ 1,2 ] $$$ $$$ [ 2,1 ] $$$ $$$ [ <unknown> ] $$$ : $$$ [ 0 ] $$$ $$$ [ 1,1 ] $$$ $$$ [ 2,3 ] $$$ need find non - negative integer $$$ x $$$ increase elements $$$ a_i $$$ $$$ x $$$ modulo $$$ m $$$ ( i.e want change $$$ a_i $$$ $$$ ( a_i + x ) \bmod m $$$ ) would possible rearrange elements $$$ a $$$ make equal $$$ b $$$ among need find smallest possible $$$ x $$$ word need find smallest non - negative integer $$$ x $$$ possible find permutation $$$ p= [ p_1 p_2 \ldots p_n ] $$$ $$$ 1 \leq i \leq n $$$ $$$ ( a_i + x ) \bmod m = b _ { p_i } $$$ $$$ y \bmod m $$$ — remainder division $$$ y $$$ $$$ m $$$ example $$$ m=3 $$$ $$$ a = [ 0 0 2 1 ] b = [ 2 0 1 1 ] $$$ choose $$$ <unknown> $$$ $$$ a $$$ equal $$$ [ 1 1 0 2 ] $$$ rearrange make equal $$$ [ 2 0 1 1 ] $$$ equal $$$ b $$$ first line contain two integers $$$ n m $$$ ( $$$ 1 \leq n \leq 2000 1 \leq m \leq 1000000000 $$$ ) : number <unknown> array $$$ m $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i < m $$$ ) third line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 0 \leq b_i < m $$$ ) guarantee exist non - negative integer $$$ x $$$ would possible find permutation $$$ p_1 p_2 \ldots p_n $$$ $$$ ( a_i + x ) \bmod m = b _ { p_i } $$$ print one integer smallest non - negative integer $$$ x $$$ would possible find permutation $$$ p_1 p_2 \ldots p_n $$$ $$$ ( a_i + x ) \bmod m = b _ { p_i } $$$ $$$ 1 \leq i \leq n $$$",['brute force'],1500.0
1017/H,` ` man high castle '' world $$$ m $$$ different film end abendsen own a storage a shelf first $$$ n $$$ order film shelf $$$ i $$$ -th month : answer abendsen 's question let probability fraction $$$ p_i $$$ let 's say total number ways take $$$ n $$$ film storage $$$ i $$$ -th month $$$ a_i $$$ $$$ p_i \cdot a_i $$$ always integer print month $$$ p_i \cdot a_i \pmod { 998244353 } $$$ $$$ 998244353 $$$ a prime number equal $$$ 119 \cdot 2^ { 23 } + 1 $$$ guarantee $$$ 100 $$$ different $$$ k $$$ value first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \le n m q \le 100000 $$$ $$$ <unknown> 100000 $$$ ) — number film shelf initially number end number months second line contain $$$ n $$$ integers $$$ e_1 e_2 \ldots e_n $$$ ( $$$ 1\leq <unknown> m $$$ ) — end $$$ i $$$ -th film shelf next $$$ q $$$ line contain three integers $$$ l_i $$$ $$$ r_i $$$ $$$ k_i $$$ ( $$$ 1 \le l_i \le r_i \le n 0 \le k_i \le 100000 $$$ ) — $$$ i $$$ -th query guarantee $$$ 100 $$$ different $$$ k $$$ value print answer question a separate line first sample second query add $$$ 2 \cdot m $$$ film storage storage look like : $$$ \ { 1 1 1 2 2 2 3 3 3 4 4 4 4 4\ } $$$ $$$ 26730 $$$ total ways choose film $$$ <unknown> e _ { l+1 } \ldots <unknown> $$$ change example $$$ [ 1 2 3 2 2 ] $$$ $$$ [ 1 2 3 4 3 ] $$$ ways $$$ 2162160 $$$ total ways choose film 're ask print $$$ ( \frac { 26730 } { 2162160 } \cdot 2162160 ) \mod 998244353 = 26730 $$$,['brute force'],3300.0
1311/C,want perform combo opponent one popular fight game combo string $$$ s $$$ consist $$$ n $$$ lowercase latin letter perform combo press button order appear $$$ s $$$ i.e $$$ s= $$$ ` ` abca '' press ' a ' ' b ' ' c ' ' a ' know spend $$$ m $$$ wrong try perform combo $$$ i $$$ -th try make a mistake right $$$ p_i $$$ -th button ( $$$ 1 \le p_i < n $$$ ) ( i.e press first $$$ p_i $$$ button right start perform combo begin ) guarantee $$$ <unknown> $$$ -th try press button right finally perform combo i.e $$$ s= $$$ ` ` abca '' $$$ m=2 $$$ $$$ p = [ 1 3 ] $$$ sequence press button ' a ' ( 're make a mistake start perform combo begin ) ' a ' ' b ' ' c ' ( 're make a mistake start perform combo begin ) ' a ' ( note point perform combo mistake ) ' b ' ' c ' ' a ' task calculate button ( letter ) number time 'll press answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 1 \le m \le 200000 $$$ ) — length $$$ s $$$ number try correspondingly second line test case contain string $$$ s $$$ consist $$$ n $$$ lowercase latin letter third line test case contain $$$ m $$$ integers $$$ p_1 p_2 \dots p_m $$$ ( $$$ 1 \le p_i < n $$$ ) — number character press right $$$ i $$$ -th try guarantee sum $$$ n $$$ sum $$$ m $$$ exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ $$$ \sum m \le 200000 $$$ ) guarantee answer letter exceed $$$ 2000000000 $$$ test case print answer — $$$ 26 $$$ integers : number time press button ' a ' number time press button ' b ' $$$ \dots $$$ number time press button ' z ' first test case describe problem statement wrong try ` ` a '' ` ` abc '' final try ` ` abca '' number time press ' a ' $$$ 4 $$$ ' b ' $$$ 2 $$$ ' c ' $$$ 2 $$$ second test case five wrong try : ` ` co '' ` ` <unknown> '' ` ` cod '' ` ` co '' ` ` <unknown> '' final try ` ` codeforces '' number time press ' c ' $$$ 9 $$$ 'd ' $$$ 4 $$$ ' e ' $$$ 5 $$$ ' f ' $$$ 3 $$$ ' o ' $$$ 9 $$$ ' r ' $$$ 3 $$$ 's ' $$$ 1 $$$,['brute force'],1300.0
934/A,"nian a monster live deep <unknown> a year show land <unknown> <unknown> even people order keep monster away people fill villages red colour light crack <unknown> <unknown> monster come little tommy n lanterns big banban m lanterns tommy 's lanterns brightness a1 a2 ... , banban 's brightness b1 b2 ... bm respectively tommy intend hide one lanterns banban pick one tommy 's non - <unknown> lanterns one lanterns form a pair pair 's brightness product brightness two lanterns tommy want make product small possible banban try make large possible ask find brightness choose pair choose optimally first line contain two space - separated integers n m ( 2 ≤ n m ≤ 50 ) second line contain n space - separated integers a1 a2 ... , third line contain m space - separated integers b1 b2 ... bm integers range - 109 109 . print a single integer — brightness choose pair first example tommy hide 20 banban choose 18 tommy 14 second example tommy hide 3 banban choose 2 tommy 1",['brute force'],1400.0
1210/F1,"easier version problem version $$$ n \le 6 $$$ marek work hard create strong testcases new algorithmic problem want know ? nah 're tell however tell generate testcases marek choose integer $$$ n $$$ $$$ n^2 $$$ integers $$$ p _ { ij } $$$ ( $$$ 1 \le i \le n $$$ $$$ 1 \le j \le n $$$ ) generate a random bipartite graph $$$ 2n $$$ vertices $$$ n $$$ vertices leave side : $$$ \ell_1 \ell_2 \dots \ell_n $$$ $$$ n $$$ vertices right side : $$$ r_1 r_2 \dots r_n $$$ $$$ i $$$ $$$ j $$$ put edge vertices $$$ \ell_i $$$ $$$ r_j $$$ probability $$$ p _ { ij } $$$ percent turn test strong a perfect match exist generate graph probability occur ? show value represent $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ coprime integers $$$ q \not\equiv 0 \pmod { 1000000000 + 7 } $$$ let $$$ q^ { -1 } $$$ integer $$$ q \cdot q^ { -1 } \equiv 1 \pmod { 1000000000 + 7 } $$$ print value $$$ p \cdot q^ { -1 } $$$ modulo $$$ 1000000000 + 7 $$$ first line input contain a single integer $$$ n $$$ ( $$$ \mathbf { 1 \le n \le 6 } $$$ ) follow $$$ n $$$ line describe probabilities edge appear graph $$$ i $$$ -th line contain $$$ n $$$ integers $$$ p _ { i1 } p _ { i2 } \dots p _ { } $$$ ( $$$ 0 \le p _ { ij } \le 100 $$$ ) ; $$$ p _ { ij } $$$ denote probability percent edge appear $$$ \ell_i $$$ $$$ r_j $$$ print a single integer — probability perfect match exist bipartite graph write $$$ p \cdot q^ { -1 } \pmod { 1000000000 + 7 } $$$ $$$ p $$$ $$$ q $$$ define first sample test $$$ 16 $$$ graph equally probable , $$$ 7 $$$ a perfect match : therefore probability equal $$$ \frac { 7 } { 16 } $$$ $$$ 16 \cdot 562\,500\,004 = 1 \pmod { 1000000000 + 7 } $$$ answer testcase $$$ 7 \cdot 562\,500\,004 \mod { ( 1000000000 + 7 ) } = 937\,500\,007 $$$",['brute force'],3100.0
1210/F2,"a harder version problem version $$$ n \le 7 $$$ marek work hard create strong test case new algorithmic problem want know ? nah 're tell however tell generate test case marek choose integer $$$ n $$$ $$$ n^2 $$$ integers $$$ p _ { ij } $$$ ( $$$ 1 \le i \le n $$$ $$$ 1 \le j \le n $$$ ) generate a random bipartite graph $$$ 2n $$$ vertices $$$ n $$$ vertices leave side : $$$ \ell_1 \ell_2 \dots \ell_n $$$ $$$ n $$$ vertices right side : $$$ r_1 r_2 \dots r_n $$$ $$$ i $$$ $$$ j $$$ put edge vertices $$$ \ell_i $$$ $$$ r_j $$$ probability $$$ p _ { ij } $$$ percent turn test strong a perfect match exist generate graph probability occur ? show value represent $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ coprime integers $$$ q \not\equiv 0 \pmod { 1000000000 + 7 } $$$ let $$$ q^ { -1 } $$$ integer $$$ q \cdot q^ { -1 } \equiv 1 \pmod { 1000000000 + 7 } $$$ print value $$$ p \cdot q^ { -1 } $$$ modulo $$$ 1000000000 + 7 $$$ first line input contain a single integer $$$ n $$$ ( $$$ \mathbf { 1 \le n \le 7 } $$$ ) follow $$$ n $$$ line describe probabilities edge appear graph $$$ i $$$ -th line contain $$$ n $$$ integers $$$ p _ { i1 } p _ { i2 } \dots p _ { } $$$ ( $$$ 0 \le p _ { ij } \le 100 $$$ ) ; $$$ p _ { ij } $$$ denote probability percent edge appear $$$ \ell_i $$$ $$$ r_j $$$ print a single integer — probability perfect match exist bipartite graph write $$$ p \cdot q^ { -1 } \pmod { 1000000000 + 7 } $$$ $$$ p $$$ $$$ q $$$ define first sample test $$$ 16 $$$ graph equally probable , $$$ 7 $$$ a perfect match : therefore probability equal $$$ \frac { 7 } { 16 } $$$ $$$ 16 \cdot 562\,500\,004 = 1 \pmod { 1000000000 + 7 } $$$ answer testcase $$$ 7 \cdot 562\,500\,004 \mod { ( 1000000000 + 7 ) } = 937\,500\,007 $$$",['brute force'],3200.0
843/B,interactive problem give a sort increase order singly link list find minimum integer list greater equal x. formally a singly like list build array n elements element index i contain two integers : valuei integer value element nexti index next element singly link list ( -1 current element last ) list sort i.e nexti ≠ - 1 valuenexti > valuei give number elements list n index first element start integer x. make 2000 query follow two type : write a program solve problem first line contain three integers n start x ( 1 ≤ n ≤ 50000 1 ≤ start ≤ n 0 ≤ x ≤ 109 ) — number elements list index first element integer x. print answer problem print ! ans ans minimum integer list greater equal x -1 integer make a query first type print ? i ( 1 ≤ i ≤ n ) i index element want know information query type ? read two integers valuei nexti ( 0 ≤ valuei ≤ 109 - 1 ≤ nexti ≤ n nexti ≠ 0 ) guarantee nexti ≠ - 1 valuenexti > valuei array value give a valid singly link list start first element note ca n't ask <unknown> query type ? nexti = - 1 valuei = - 1 mean ask query allow ask invalid query program immediately terminate ( example call exit ( 0 ) ) receive ` ` wrong answer '' mean ask query allow ask invalid query ignore get verdicts since program continue read a close stream solution get ` ` idleness limit exceed '' n't print anything forget flush output include final answer flush use ( print a query line end ) : hack formatfor hack use follow format : first line print three integers n start x ( 1 ≤ n ≤ 50000 1 ≤ start ≤ n 0 ≤ x ≤ 109 ) next n line print description elements list : i - th line print two integers valuei nexti ( 0 ≤ valuei ≤ 109 - 1 ≤ nexti ≤ n nexti ≠ 0 ) print structure a valid singly link list particular possible reach elements start follow link nexti last element end -1 <unknown> read singly link list follow link : https : //en.wikipedia.org / wiki / <unknown> # <unknown> illustration first sample case start finish elements mark dark,['brute force'],2000.0
1153/E,"interactive problem serval a senior high school student <unknown> middle school however way school must go across a pond a dangerous snake pond represent a $$$ n \times n $$$ grid snake a head a tail different cells body a series adjacent cells connect head tail without self - intersecting serval hit head tail snake bite die luckily a special device answer follow question : pick a rectangle tell number time one need cross border rectangle walk cell cell along snake head tail picture show a possible snake a possible query get answer $$$ 4 $$$ today serval get late time make $$$ 2019 $$$ query best friend help find position head tail ? note two cells adjacent a common edge grid a snake a body length $$$ 0 $$$ mean adjacent head tail also note snake sleep wo n't move serval use device 's obvious snake position depend query first line contain a single integer $$$ n $$$ ( $$$ 2\leq n \leq 1000 $$$ ) — size grid ready answer print ! x1 y1 x2 y2 $$$ ( x_1 y_1 ) $$$ represent position head $$$ ( x_2 y_2 ) $$$ represent position tail print head tail order make a query print ? x1 y1 x2 y2 ( $$$ 1 \leq x_1 \leq x_2 \leq n $$$ $$$ 1\leq y_1 \leq y_2 \leq n $$$ ) represent a rectangle consist cells $$$ ( x y ) $$$ $$$ x_1 \leq x \leq x_2 $$$ $$$ y_1 \leq y \leq y_2 $$$ get a single integer answer print a query forget output end line flush output otherwise get idleness limit exceed , use : answer $$$ -1 $$$ instead a valid answer mean make invalid query exceed maximum number query exit immediately receive $$$ -1 $$$ see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream program find head tail snake correctly also get a wrong answer verdict hacksto make a hack print a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 1000 $$$ ) first line indicate size grid print integer $$$ k $$$ ( $$$ 2 \leq k \leq n^2 $$$ ) second line indicate length snake next $$$ k $$$ line print $$$ k $$$ pair integers $$$ x_i y_i $$$ ( $$$ 1 \leq x_i y_i \leq n $$$ ) pair a single line indicate $$$ i $$$ -th cell snake adjacent pair adjacent $$$ k $$$ pair distinct picture show query answer first example first make a query $$$ ( 1,1 ) $$$ get answer $$$ 1 $$$ find must connect exactly one cell make a query $$$ ( 1,2 ) $$$ get answer $$$ 0 $$$ know snake never enter cell connect $$$ ( 1,1 ) $$$ must $$$ ( 2,1 ) $$$ make a query $$$ ( 2,2 ) $$$ get answer $$$ 0 $$$ know never enter $$$ ( 2,2 ) $$$ well snake leave $$$ ( 2,1 ) $$$ imply answer $$$ ( 1,1 ) $$$ $$$ ( 2,1 ) $$$ picture show query answer second example make query $$$ ( 2,2 ) $$$ receive $$$ 2 $$$ find snake occupy $$$ ( 2,2 ) $$$ make query rectangle $$$ ( 2,1 ) $$$ $$$ ( 2,3 ) $$$ receive answer $$$ 0 $$$ know never go rectangle $$$ ( 2,1 ) $$$ $$$ ( 2,3 ) $$$ since first answer $$$ 2 $$$ $$$ ( 2,1 ) $$$ $$$ ( 2,3 ) $$$ must occupy none others answer $$$ ( 2,1 ) $$$ $$$ ( 2,3 ) $$$",['brute force'],2200.0
870/D,interactive problem jury hide a permutation p integers 0 n - 1 . know length n. remind permutation integers distinct let b inverse permutation p i.e <unknown> = i i. thing ask xor elements pi bj print two indices i j ( necessarily distinct ) a result query indices i j 'll get value denote xor operation find description xor operation note note permutations remain indistinguishable hide one even make possible n2 query compute number permutations indistinguishable hide one print one permutations make 2n query hide permutation depend query first line contain single integer n ( 1 ≤ n ≤ 5000 ) — length hide permutation read integer first program ready print answer print three line first line print ` ` ! ` ` second line print single integer <unknown> — number permutations indistinguishable hide one include hide one third line print n integers <unknown> p1 ... pn - 1 ( 0 ≤ pi < n pi distinct ) — one permutations indistinguishable hide one program terminate print answer ask xor two elements print a string ` ` ? i j '' i j — integers 0 n - 1 — index permutation element index inverse permutation element want know xor - sum print a line break make flush operation print query program read single integer — value a permutation length n program make 2n query xor - sum note print answer n't count a query note ca n't ask 2n question ask 2n question least one incorrect question solution get ` ` wrong answer '' moment program read -1 answer immediately exit ( example call exit ( 0 ) ) get ` ` wrong answer '' case mean ask 2n question ask invalid question ignore get verdicts since program continue read a close stream solution get ` ` idleness limit exceed '' n't print anything forget flush output include final answer flush use ( print line break ) : hackingfor hack use follow format : <unknown> p1 ... pn - <unknown> program able see <unknown> operation bitwise exclusive operation perform two integers i - th digit binary representation result equal 1 exactly one two integers i - th digit binary representation equal 1 . information see first example p = [ 0 1 2 ] thus b = [ 0 1 2 ] value correct give i j. permutations give answer give query answer query : second example p = [ 3 1 2 0 ] b = [ 3 1 2 0 ] value match pair i j. one suitable permutation p = [ 0 2 1 3 ] b = [ 0 2 1 3 ] match n2 possible query well permutations match even show query,['brute force'],2000.0
952/B,ever interact a cat probably notice quite particular pet <unknown> map a normal cat however cat wo n't <unknown> <unknown> humans a map a grumpy cat meet a cat figure whether 's normal grumpy ? interactive problem initially 're give information cat instead cat divide ten areas index 0 9 . one query choose area 'll pet print correspond index standard get cat 's response depict correspond map via standard simplicity responses write lowercase 're certain type cat 're deal output ` ` normal '' ` ` grumpy '' standard please make sure use stream flush operation query order leave part output <unknown>,['brute force'],1900.0
109/B,"petya love lucky number know lucky number positive integers whose decimal representations contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 petya friend vasya play interest game petya randomly choose integer p interval [ pl pr ] vasya choose integer v interval [ vl vr ] ( also randomly ) players choose integers equiprobably find probability interval [ min ( v p ) max ( v p ) ] contain exactly k lucky number single line contain five integers pl pr vl vr k ( 1 ≤ pl ≤ pr ≤ 109 1 ≤ vl ≤ vr ≤ 109 1 ≤ k ≤ 1000 ) single line print result absolute error 10 - 9 . consider [ a b ] denote interval integers ; interval include boundaries , first case 32 suitable pair : ( 1 7 ) ( 1 8 ) ( 1 9 ) ( 1 10 ) ( 2 7 ) ( 2 8 ) ( 2 9 ) ( 2 10 ) ( 3 7 ) ( 3 8 ) ( 3 9 ) ( 3 10 ) ( 4 7 ) ( 4 8 ) ( 4 9 ) ( 4 10 ) ( 7 1 ) ( 7 2 ) ( 7 3 ) ( 7 4 ) ( 8 1 ) ( 8 2 ) ( 8 3 ) ( 8 4 ) ( 9 1 ) ( 9 2 ) ( 9 3 ) ( 9 4 ) ( 10 1 ) ( 10 2 ) ( 10 3 ) ( 10 4 ) total number possible pair <unknown> = 100 answer 32 / 100 . second case petya always get number less vasya lucky 7 number always 1 lucky number",['brute force'],1900.0
632/F,'re give a matrix a size n × n. let 's call matrix nonnegative elements magic symmetric ( aij = aji ) aii = 0 aij ≤ max ( aik <unknown> ) triple i j k. note i j k need distinct determine matrix magic input / output reach huge size recommend use fast input / output methods : example prefer use scanf / printf instead cin / cout c++ prefer use bufferedreader / printwriter instead scanner / system.out java first line contain integer n ( 1 ≤ n ≤ 2500 ) — size matrix a. next n line contain n integers aij ( 0 ≤ aij < 109 ) — elements matrix a. note give matrix necessarily symmetric arbitrary print ` ` magic '' ( without quote ) give matrix a magic otherwise print ` ` magic '',['brute force'],2400.0
105/B,"dark assembly a govern body <unknown> sit senators take important decisions player example expand range shop improve certain characteristics character dark assembly 's approval need dark assembly consist n senators characterize level loyalty player level a positive integer reflect a senator 's strength loyalty probability a positive decision vote measure a percentage precision 10 % senators make decisions vote make a positive negative decision accordance loyalty strictly half senators take a positive decision player 's proposal approve player 's proposal approve vote player may appeal decision dark assembly , player need kill senators vote ( 's nothing wrong kill senators <unknown> later treat player even worse ) probability a player able kill a certain group senators equal a / ( a + b ) a sum level player 's character b sum level senators group player kill <unknown> senators proposal approve senators fond sweets <unknown> give candy receive candy a senator increase loyalty player 10 % 's worth mention loyalty exceed 100 % player take k sweets <unknown> candy give senators start vote determine probability dark assembly approve player 's proposal candy distribute among senators optimal way first line contain three integers n k a ( 1 ≤ n k ≤ 8 1 ≤ a ≤ 9999 ) n line follow i - th contain two number — bi li — i - th senator 's level loyalty level senators integers range 1 9999 ( inclusive ) <unknown> senators integers range 0 100 ( inclusive ) divisible 10 . print one real number precision 10 - 6 — maximal possible probability dark assembly approve player 's proposal best possible distribution candy among senators first sample best way candy ' distribution give first three senators ensure vote second sample player give three candy fifth senator",['brute force'],1800.0
1838/F,"interactive problem $$$ n $$$ $$$ n $$$ grid conveyor belt position $$$ ( 1 1 ) $$$ $$$ ( n n ) $$$ a coordinate plane every square plane empty conveyor belt configure move box ( ' ^ ' ) ( ' v ' ) leave ( ' < ' ) right ( ' > ' ) a box move onto empty square stop move however one $$$ n^2 $$$ belt stick always move box direction matter configure goal perform a series test determine conveyor belt stick direction send items achieve perform $$$ 25 $$$ test test assign a direction $$$ n^2 $$$ belt place a box top one turn conveyors conveyors move box around quickly see information receive a test whether box eventually stop move , coordinate final position begin interaction read a single integer $$$ n $$$ ( $$$ 2 \le n\le 100 $$$ ) — number row columns grid , make $$$ 25 $$$ query query begin a line form ? r c r c initial row column box respectively next $$$ n $$$ line query contain $$$ n $$$ character $$$ j $$$ th character $$$ i $$$ th row one ' ^ ' ' v ' ' < ' ' > ' indicate direction conveyor $$$ ( i j ) $$$ query query receive two integers $$$ x $$$ $$$ y $$$ $$$ x = y = -1 $$$ box enter infinite loop otherwise final position $$$ ( x y ) $$$ make many query make invalid query receive wrong answer verdict find stick conveyor direction print a single line ! r c dir r c row column stick conveyor respectively dir one ' ^ ' ' v ' ' < ' ' > ' indicate direction stick conveyor note print answer count towards total $$$ 25 $$$ query print line program terminate interactor non - adaptive mean location direction stick belt fix start interaction change query print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto make a hack use follow format first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number row columns grid next line contain two integers $$$ r $$$ $$$ c $$$ ( $$$ 1 \le r c \le n $$$ ) well a character $$$ \mathrm { dir } $$$ ( $$$ \mathrm { dir } $$$ one ' ^ ' ' v ' ' < ' ' > ' ) — position stick conveyor fix direction value separate space first query first sample input box start $$$ ( 2 2 ) $$$ enter infinite loop contain row $$$ 2 $$$ $$$ 3 $$$ stick conveyor row $$$ 1 $$$ affect outcome query second query first sample input conveyors configure way box start $$$ ( 1 1 ) $$$ stick conveyor would enter infinite loop $$$ ( 1 2 ) $$$ $$$ ( 1 3 ) $$$ however stick conveyor <unknown> $$$ ( 0 2 ) $$$ two query program able determine stick conveyor $$$ ( 1 2 ) $$$ direct items <unknown> query second sample input correspond picture ask query many possibilities stick conveyor program correctly guess $$$ ( 3 3 ) $$$ direct items right",['constructive algorithms'],3000.0
1479/C,"time ago homer live a beautiful city $$$ n $$$ block number $$$ 1 $$$ $$$ n $$$ $$$ m $$$ direct roads road a positive length road go block smaller index block larger index every two ( different ) block one road homer discover two number $$$ l $$$ $$$ r $$$ city $$$ ( l r ) $$$ -continuous city say $$$ ( l r ) $$$ -continuous a path block $$$ u $$$ block $$$ v $$$ a sequence $$$ u = x_0 \to x_1 \to x_2 \to \dots \to x_k = v $$$ a road block $$$ x _ { i-1 } $$$ block $$$ x _ { i } $$$ every $$$ 1 \leq i \leq k $$$ length a path sum lengths roads path two paths $$$ x_0 \to x_1 \to \dots \to x_k $$$ $$$ y_0 \to y_1 \to \dots \to y_l $$$ different $$$ k \neq l $$$ $$$ x_i \neq y_i $$$ $$$ 0 \leq i \leq <unknown> { k l\ } $$$ move another city homer remember two special number $$$ l $$$ $$$ r $$$ forget number $$$ n $$$ $$$ m $$$ block roads respectively block connect roads however believe number block larger $$$ 32 $$$ ( city small ) best friend homer please tell whether possible find a $$$ ( l r ) $$$ -continuous city single line contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l \leq r \leq 1000000 $$$ ) impossible find a $$$ ( l r ) $$$ -continuous city within $$$ 32 $$$ block print ` ` '' a single line otherwise print ` ` yes '' first line follow a description a $$$ ( l r ) $$$ -continuous city second line contain two integers $$$ n $$$ ( $$$ 2 \leq n \leq 32 $$$ ) $$$ m $$$ ( $$$ 1 \leq m \leq \frac { n ( n-1 ) } 2 $$$ ) $$$ n $$$ denote number block $$$ m $$$ denote number roads $$$ m $$$ line follow $$$ i $$$ -th $$$ m $$$ line contain three integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \leq a_i < b_i \leq n $$$ ) $$$ c_i $$$ ( $$$ 1 \leq c_i \leq 1000000 $$$ ) indicate a direct road block $$$ a_i $$$ block $$$ b_i $$$ length $$$ c_i $$$ require every two block 1 road connect , every $$$ 1 \leq i < j \leq m $$$ either $$$ a_i \neq a_j $$$ $$$ b_i \neq b_j $$$ first example one path block $$$ 1 $$$ block $$$ n = 2 $$$ length $$$ 1 $$$ second example three paths block $$$ 1 $$$ block $$$ n = 5 $$$ $$$ 1 \to 2 \to 5 $$$ length $$$ 4 $$$ $$$ 1 \to 3 \to 5 $$$ length $$$ 5 $$$ $$$ 1 \to 4 \to 5 $$$ length $$$ 6 $$$",['constructive algorithms'],2500.0
1583/F,"even leave fall piece , someone protect right ? find play teucer city liyue take <unknown> little kid around notice something interest structure city liyue represent a direct graph contain $$$ n $$$ nod nod label $$$ 1 $$$ $$$ n $$$ a direct edge node $$$ a $$$ node $$$ b $$$ $$$ a < b $$$ a path nod $$$ a $$$ $$$ b $$$ define a sequence edge start $$$ a $$$ travel along edge correspond direction end $$$ b $$$ length a path define number edge a rainbow path length $$$ x $$$ define a path graph exist least 2 distinct color among set $$$ x $$$ edge teucer 's favorite number $$$ k $$$ curious follow scenario : label edge a color minimum number color need ensure paths length $$$ k $$$ longer rainbow paths ? teucer want surprise older brother a map liyue also want know a valid color edge use minimum number color please help task ! line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \leq k < n \leq 1000 $$$ ) first line output $$$ c $$$ minimum color need satisfy requirements second line print a valid edge color array $$$ \frac { n ( n-1 ) } { 2 } $$$ integers range $$$ 1 $$$ $$$ c $$$ exactly $$$ c $$$ distinct color exist construction print edge increase order start node first second node example $$$ n=4 $$$ edge color correspond order edge : ( $$$ 1 $$$ $$$ 2 $$$ ) ( $$$ 1 $$$ $$$ 3 $$$ ) ( $$$ 1 $$$ $$$ 4 $$$ ) ( $$$ 2 $$$ $$$ 3 $$$ ) ( $$$ 2 $$$ $$$ 4 $$$ ) ( $$$ 3 $$$ $$$ 4 $$$ ) correspond construction first test case look like : correspond construction second test case look like :",['constructive algorithms'],2500.0
1148/F,give $$$ n $$$ object object two integer properties : $$$ val_i $$$ — price — $$$ mask_i $$$ guarantee sum price initially non - zero want select a positive integer $$$ s $$$ object modify $$$ i $$$ -th object modify use follow procedure : need find integer $$$ s $$$ modification do sum price change sign ( negative become positive vice - versa ; allow become zero ) absolute value sum arbitrary first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 300000 $$$ ) — number object $$$ i $$$ -th next $$$ n $$$ line contain integers $$$ val_i $$$ $$$ mask_i $$$ ( $$$ -1000000000 \leq val_i \leq 1000000000 $$$ $$$ 1 \le mask_i \le 2^ { 62 } - 1 $$$ ) — price object mask guarantee sum $$$ val_i $$$ initially non - zero print integer $$$ s $$$ ( $$$ 1 \le s \le 2^ { 62 } - 1 $$$ ) modify object describe sign sum $$$ val_i $$$ change sign multiple $$$ s $$$ print one show always least one valid $$$ s $$$ first test sample object change price except object mask $$$ <unknown> $$$ total sum change sign : initially $$$ 24 $$$ <unknown> — $$$ <unknown> $$$ second test sample object change price total sum change sign,['constructive algorithms'],2700.0
1174/D,give two integers $$$ n $$$ $$$ x $$$ construct array satisfy follow condition : a sequence $$$ b $$$ a subsegment a sequence $$$ a $$$ $$$ b $$$ obtain $$$ a $$$ deletion several ( possibly zero ) elements begin several ( possibly zero ) elements end line contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \le n \le 18 $$$ $$$ 1 \le x < 2^ { 18 } $$$ ) first line contain length array $$$ l $$$ $$$ l $$$ positive second line contain $$$ l $$$ space - separated integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \dots $$$ $$$ a_l $$$ ( $$$ 1 \le a_i < 2^n $$$ ) — elements array $$$ a $$$ multiple solutions print first example bitwise xor subsegments $$$ \ { <unknown> } $$$,['constructive algorithms'],1900.0
1364/E,"interactive problem ! ehab a hide permutation $$$ p $$$ length $$$ n $$$ consist elements $$$ 0 $$$ $$$ n-1 $$$ , reason want figure permutation , give ehab $$$ 2 $$$ different indices $$$ i $$$ $$$ j $$$ 'll reply $$$ ( p_i|p_j ) $$$ $$$ | $$$ bitwise - <unknown> operation ehab enough free time answer $$$ 4269 $$$ question 's ok answer many question 's lazy play silly game 'll fix permutation beforehand change depend query guess permutation ? line contain integer $$$ n $$$ $$$ ( 3 \le n \le 2048 ) $$$ — length permutation ask a question print ` ` ? $$$ i $$$ $$$ j $$$ ` ` ( without quote $$$ i \neq j $$$ ) read answer $$$ ( p_i|p_j ) $$$ answer $$$ -1 $$$ instead a valid answer mean exceed number query make invalid query exit immediately receive $$$ -1 $$$ see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream print answer print ` ` ! $$$ p_1 $$$ $$$ p_2 $$$ $$$ \ldots $$$ $$$ p_n $$$ ` ` ( without quote ) note answer n't count one $$$ 4269 $$$ query print a query print answer forget output end line flush output otherwise get idleness limit exceed , use : hack : first line contain integer $$$ n $$$ ( $$$ 3 \le n \le 2^ { 11 } $$$ ) — length permutation $$$ p $$$ second line contain $$$ n $$$ space - separated integers $$$ p_1 $$$ $$$ p_2 $$$ $$$ \ldots $$$ $$$ p_n $$$ ( $$$ 0 \le p_i < n $$$ ) — elements permutation $$$ p $$$ first sample permutation $$$ [ 1,0,2 ] $$$ start ask $$$ <unknown> $$$ ehab reply $$$ 1 $$$ ask $$$ <unknown> $$$ ehab reply $$$ 3 $$$ finally ask $$$ <unknown> $$$ ehab reply $$$ 2 $$$ guess permutation",['constructive algorithms'],2700.0
1790/E,vlad find two positive number $$$ a $$$ $$$ b $$$ ( $$$ a b > 0 $$$ ) discover $$$ a \oplus b = \frac { a + b } { 2 } $$$ $$$ \oplus $$$ mean bitwise exclusive division perform without round .. since easier remember one number two vlad remember $$$ <unknown> b $$$ let 's denote number $$$ x $$$ help find suitable $$$ a $$$ $$$ b $$$ tell exist first line input data contain single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test test case describe a single integer $$$ x $$$ ( $$$ 1 \le x \le 2^ { <unknown> } $$$ ) — number vlad remember output $$$ t $$$ line answer correspond test case answer output $$$ a $$$ $$$ b $$$ ( $$$ 0 < a b \le 2^ { 32 } $$$ ) $$$ x = a \oplus b = \frac { a + b } { 2 } $$$ several answer output match pair output -1,['constructive algorithms'],1400.0
1801/A,"kirill want weave beautiful blanket consist $$$ n \times m $$$ size square patch color match non - negative integer color thus problem blanket consider a $$$ b $$$ matrix size $$$ n \times m $$$ consist non - negative integers kirill consider blanket beautiful submatrix $$$ a $$$ size $$$ 4 \times 4 $$$ matrix $$$ b $$$ true : $$$ \oplus $$$ mean bitwise exclusive <unknown> ask help weave a beautiful blanket colorful possible ! give two integers $$$ n $$$ $$$ m $$$ task generate a matrix $$$ b $$$ size $$$ n \times m $$$ correspond a beautiful blanket number different number maximize first line input data contain one integer number $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case single line test case contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 4 \le n \ m \le 200 ) $$$ — size matrix $$$ b $$$ guarantee sum $$$ n \cdot m $$$ exceed $$$ 200000 $$$ test case first line output one integer $$$ cnt $$$ $$$ ( 1 \le cnt \le n \cdot m ) $$$ — maximum number different number matrix output matrix $$$ b $$$ $$$ ( 0 \le b _ { ij } < 2^ { 63 } ) $$$ size $$$ n \times m $$$ several correct matrices allow output one show exist a matrix optimal number distinct number exist among suitable matrices a $$$ b $$$ $$$ ( 0 \le b _ { ij } < 2^ { 63 } ) $$$ first test case 4 submatrix size $$$ 4 \times 4 $$$ consider a submatrix whose upper - left corner coincide upper - left corner matrix $$$ b $$$ : $$$ \left [ { \begin { array } { <unknown> } 9740 & 1549 & 9744 & 1553 \\ 1550 & 1551 & 1554 & 1555 \\ 10252 & 2061 & 10256 & 2065 \\ 2062 & 2063 & 2066 & 2067 \\ \end { array } } \right ] $$$ $$$ 9740 \oplus 1549 \oplus 1550 \oplus 1551 $$$ $$$ = $$$ $$$ 10256 \oplus 2065 \oplus 2066 \oplus 2067 $$$ $$$ = $$$ $$$ 8192 $$$ ; $$$ 10252 \oplus 2061 \oplus 2062 \oplus 2063 $$$ $$$ = $$$ $$$ 9744 \oplus 1553 \oplus 1554 \oplus 1555 $$$ $$$ = $$$ $$$ 8192 $$$ , choose submatrix fit condition similarly make sure three <unknown> also fit condition",['constructive algorithms'],1600.0
1780/D,"interactive problem kira a hide positive integer $$$ n $$$ hayato need guess initially kira give hayato value $$$ \mathrm { cnt } $$$ — number unit bits binary notation $$$ n $$$ guess $$$ n $$$ hayato operations one kind : choose integer $$$ x $$$ subtract $$$ n $$$ note operation number $$$ n $$$ change kira n't like bad request hayato try subtract a number $$$ x $$$ greater $$$ n $$$ lose kira operation kira give hayato update value $$$ \mathrm { cnt } $$$ — number unit bits binary notation update value $$$ n $$$ kira n't much <unknown> hayato must guess original value $$$ n $$$ $$$ 30 $$$ operations since hayato <unknown> school ask help write a program guess number $$$ n $$$ kira honest person choose initial number $$$ n $$$ operations change afterward input data contain several test case first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case description test case follow first line test case contain number $$$ \mathrm { cnt } $$$ — initial number unit bits binary notation $$$ n $$$ hide integer $$$ n $$$ satisfy follow constraint : $$$ 1 \le n \le 1000000000 $$$ guess $$$ n $$$ perform operation $$$ 30 $$$ time , print a line follow format : ` ` - x '' ( $$$ 1 \le x \le 1000000000 $$$ ) operation number $$$ x $$$ subtract $$$ n $$$ therefore $$$ n $$$ change number $$$ x $$$ greater current value $$$ n $$$ request consider invalid operation read a line contain a single non - negative integer $$$ \mathrm { cnt } $$$ — number unit bits binary notation current $$$ n $$$ operation know initial value $$$ n $$$ print one line follow format : ` ` ! n '' ( $$$ 1 \le n \le 1000000000 $$$ ) , move next test case terminate program none program perform $$$ 30 $$$ operations one test case subtract a number $$$ x $$$ greater $$$ n $$$ make incorrect request response request -1 receive response program must exit immediately receive wrong answer verdict otherwise get verdict print a query answer forget output end line flush output otherwise get idleness limit exceed , use : hacksto make a hack use follow format first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 500 $$$ ) test case contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000000000 $$$ ) a separate line example number unit bits number $$$ 6 $$$ $$$ 2 $$$ binary notation $$$ 6 $$$ $$$ 110 $$$ $$$ 13 $$$ number unit bits $$$ 3 $$$ $$$ 13 _ { 10 } = <unknown> $$$ first test case $$$ n = 1 $$$ input number $$$ 1 $$$ subtract one $$$ n $$$ become zero number unit bits $$$ 0 $$$ third test case $$$ n = 3 $$$ binary representation look like $$$ 3 _ { 10 } = 11_2 $$$ input number ones $$$ 2 $$$ subtract $$$ 2 $$$ $$$ n = 1 $$$ number unit bits $$$ 1 $$$ subtract one $$$ n $$$ become equal zero note blank line input output examples show clarity present actual interaction",['constructive algorithms'],1800.0
1775/B,"<unknown> <unknown> <unknown> array $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ want check two different subsequences $$$ a $$$ $$$ b $$$ original array $$$ f ( a ) = f ( b ) $$$ $$$ f ( x ) $$$ bitwise number sequence $$$ x $$$ a sequence $$$ q $$$ a subsequence $$$ p $$$ $$$ q $$$ obtain $$$ p $$$ delete several ( possibly none ) elements two subsequences consider different set index elements original sequence different , value elements consider compare subsequences test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — size array $$$ c $$$ description array $$$ c $$$ problem give <unknown> speed input $$$ ( i + 1 ) $$$ -st follow $$$ n $$$ line test case begin integer $$$ k_i $$$ ( $$$ 1 \le k_i \le 100000 $$$ ) — number set bits number $$$ c_i $$$ next follow $$$ k_i $$$ distinct integers $$$ p _ { i 1 } p _ { i 2 } \dots p _ { i k_i } $$$ ( $$$ 1 \le p_i \le 200000 $$$ ) — the number bits set one number $$$ c_i $$$ word $$$ c_i = 2^ { p _ { i 1 } } + 2^ { p _ { i 2 } } + \ldots + 2^ { p _ { i k_i } } $$$ guarantee total sum $$$ k_i $$$ test exceed $$$ 100000 $$$ set input print ` ` yes '' exist two different subsequences $$$ f ( a ) = f ( b ) $$$ ` ` '' otherwise output answer case ( upper lower ) example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize positive responses prove first test case two different subsequences $$$ a $$$ $$$ b $$$ $$$ f ( a ) = f ( b ) $$$ second test case one possible answer follow subsequences : subsequence $$$ a $$$ form element position $$$ 1 $$$ subsequence $$$ b $$$ form elements position $$$ 1 $$$ $$$ 2 $$$ third test case one possible answer follow subsequences : subsequence $$$ a $$$ form elements position $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ subsequence $$$ b $$$ form elements position $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$",['constructive algorithms'],1300.0
1748/F,"array $$$ a_0 a_1 \ldots a _ { n-1 } $$$ length $$$ n $$$ initially $$$ a_i = 2^i $$$ $$$ 0 \le i \lt n $$$ note array $$$ a $$$ zero - indexed want reverse array ( make $$$ a_i $$$ equal $$$ 2^ { n-1 - i } $$$ $$$ 0 \le i \lt n $$$ ) , perform follow operation $$$ 250\,000 $$$ time : $$$ \oplus $$$ denote bitwise xor operation task find sequence operations result array $$$ a $$$ reverse show give constraints a solution always exist first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 400 $$$ ) — length array $$$ a $$$ first line print one integer $$$ k $$$ ( $$$ 0 \le k \le 250\,000 $$$ ) — number operations perform second line print $$$ k $$$ integers $$$ i_1 i_2 \ldots i_k $$$ ( $$$ 0 \le i_j \lt n $$$ ) , $$$ i_j $$$ integer select $$$ j $$$ -th operation note n't need minimize number operations note elements operations perform color red first test case array $$$ a $$$ change follow way : $$$ [ 1 \color { red } { 2 } ] \rightarrow [ \color { red } { 1 } , 3 ] \rightarrow [ 2 \color { red } { 3 } ] \rightarrow [ 2,1 ] $$$ second test case array $$$ a $$$ change follow way : $$$ [ 1 \color { red } { 2 } , 4 ] \rightarrow [ \color { red } { 1 } , 6,4 ] \rightarrow [ 7 \color { red } { 6 } , 4 ] \rightarrow [ \color { red } { 7 } , 2,4 ] \rightarrow [ <unknown> \color { red } { 4 } ] \rightarrow [ 5 \color { red } { 2 } , 1 ] \rightarrow [ \color { red } { 5 } , 3,1 ] \rightarrow [ 6 \color { red } { 3 } , 1 ] \rightarrow [ \color { red } { 6 } , 2,1 ] \rightarrow [ <unknown> ] $$$",['constructive algorithms'],3000.0
1630/A,give a set $$$ n $$$ ( $$$ n $$$ always a power $$$ 2 $$$ ) elements contain integers $$$ 0 1 2 \ldots n-1 $$$ exactly find $$$ \frac { n } { 2 } $$$ pair elements : many solutions print solution print $$$ -1 $$$ instead input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 400 $$$ ) — number test case description test case follow test case consist a single line two integers $$$ n $$$ $$$ k $$$ ( $$$ 4 \leq n \leq 2^ { 16 } $$$ $$$ n $$$ a power $$$ 2 $$$ $$$ 0 \leq k \leq n-1 $$$ ) sum $$$ n $$$ test case exceed $$$ 2^ { 16 } $$$ test case individual input pairwise different test case solution print a single line integer $$$ -1 $$$ otherwise print $$$ \frac { n } { 2 } $$$ line $$$ i $$$ -th must contain $$$ a_i $$$ $$$ b_i $$$ elements $$$ i $$$ -th pair many solutions print print pair elements pair order first test $$$ ( 0\ & 3 ) + ( 1\ & 2 ) = 0 $$$ second test $$$ ( 0\ & 2 ) + ( 1\ & 3 ) = 1 $$$ third test $$$ ( 0\ & 1 ) + ( 2\ & 3 ) = 2 $$$ fourth test solution,['constructive algorithms'],1500.0
1632/B,finally decide build a roof football field school <unknown> . construction require place $$$ n $$$ consecutive vertical pillars furthermore <unknown> want heights pillars form a permutation $$$ p $$$ integers $$$ 0 $$$ $$$ n - 1 $$$ $$$ p_i $$$ height $$$ i $$$ -th pillar leave $$$ ( 1 \le i \le n ) $$$ chief know cost construction consecutive pillars equal maximum value bitwise xor heights pair adjacent pillars word cost construction equal $$$ \max\limits _ { 1 \le i \le n - 1 } { p_i \oplus p _ { i + 1 } } $$$ $$$ \oplus $$$ denote bitwise xor operation find sequence pillar heights $$$ p $$$ length $$$ n $$$ smallest construction cost problem a permutation array consist $$$ n $$$ distinct integers $$$ 0 $$$ $$$ n - 1 $$$ arbitrary order example $$$ [ <unknown> ] $$$ a permutation $$$ [ <unknown> ] $$$ a permutation ( $$$ 1 $$$ appear twice array ) $$$ [ <unknown> ] $$$ also a permutation ( $$$ n=3 $$$ $$$ 3 $$$ array ) test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) description test case follow line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number pillars construction roof guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case print $$$ n $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ $$$ \ldots $$$ $$$ p_n $$$ — sequence pillar heights smallest construction cost multiple answer print $$$ n = 2 $$$ $$$ 2 $$$ sequence pillar heights : $$$ n = 3 $$$ $$$ 6 $$$ sequence pillar heights :,['constructive algorithms'],1000.0
1682/B,give a permutation $$$ p $$$ integers $$$ 0 $$$ $$$ n-1 $$$ ( occur exactly ) initially permutation sort ( $$$ p_i > p _ { i+1 } $$$ least one $$$ 1 \le i \le n - 1 $$$ ) permutation call $$$ x $$$ -sortable non - negative integer $$$ x $$$ possible sort permutation perform operation finite number time : $$$ \ & $$$ denote bitwise operation find maximum value $$$ x $$$ $$$ p $$$ $$$ x $$$ -sortable show always exist value $$$ x $$$ $$$ p $$$ $$$ x $$$ -sortable input consist multiple test case first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 10000 ) $$$ — number test case description test case follow first line test case contain a single integer $$$ n $$$ $$$ ( 2 \le n \le 2 \cdot 100000 ) $$$ — length permutation second line test case contain $$$ n $$$ integers $$$ p_1 p_2 ... p_n $$$ ( $$$ 0 \le p_i \le n-1 $$$ $$$ p_i $$$ distinct ) — elements $$$ p $$$ guarantee $$$ p $$$ sort guarantee sum $$$ n $$$ case exceed $$$ 200000 $$$ test case output a single integer — maximum value $$$ x $$$ $$$ p $$$ $$$ x $$$ -sortable first test case $$$ x $$$ permutation $$$ x $$$ -sortable $$$ x = 0 $$$ $$$ x = 2 $$$ maximum $$$ 2 $$$ sort use $$$ x = 0 $$$ : sort use $$$ x = 2 $$$ : second test case must swap $$$ p_1 $$$ $$$ p_2 $$$ possible $$$ x = 0 $$$,['constructive algorithms'],1100.0
1705/F,"mark <unknown> online exam consist $$$ n $$$ true - false question however lose answer key need a way retrieve answer client get infuriate fortunately access grade system thus query input answer $$$ n $$$ question grade system output many correct n't much time use grade system $$$ <unknown> $$$ time help mark determine answer key note answer key fix advance change depend query first line input consist integer $$$ n $$$ ( $$$ 1\leq n\leq 1000 $$$ ) — number question read $$$ n $$$ start make query grade system query print a line contain a string $$$ s $$$ length $$$ n $$$ consist letter ' t ' ' f ' a successful query read integer $$$ k $$$ ( $$$ 0\leq k\leq n $$$ ) — number correct answer read $$$ n $$$ find answer program make query program read $$$ k = -1 $$$ instead number correct answer mean either make invalid query exceed query limit exit immediately receive $$$ -1 $$$ see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack use follow format : first line contain integer $$$ n $$$ ( $$$ 1\leq n\leq 1000 $$$ ) — number question second line contain a string $$$ s $$$ length $$$ n $$$ consist ' t ' ' f ' — answer key empty line example better understand interaction process 're require print first example $$$ 3 $$$ question answer question ' true ' ' true ' ' false ' respectively second example $$$ 4 $$$ question answer question ' true ' ' false ' ' true ' ' true ' respectively",['constructive algorithms'],2900.0
1699/B,give two even integers $$$ n $$$ $$$ m $$$ task find binary matrix $$$ a $$$ $$$ n $$$ row $$$ m $$$ columns every cell $$$ ( i j ) $$$ exactly two neighbour a different value $$$ a _ { i j } $$$ two cells matrix consider neighbour share a side formally neighbour cell $$$ ( x y ) $$$ : $$$ ( <unknown> y ) $$$ $$$ ( x y+1 ) $$$ $$$ ( x+1 y ) $$$ $$$ ( x <unknown> ) $$$ prove give constraints answer always exist test contain multiple test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case follow line contain descriptions test case line test case contain two even integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n m \le 50 $$$ ) — height width binary matrix respectively test case print $$$ n $$$ line contain $$$ m $$$ number equal $$$ 0 $$$ $$$ 1 $$$ — binary matrix satisfy constraints describe statement prove give constraints answer always exist white mean $$$ 0 $$$ black mean $$$ 1 $$$,['constructive algorithms'],900.0
484/A,let 's denote number bits set ( ' 1 ' bits ) binary representation non - negative integer x. give multiple query consist pair integers l r. query find x l ≤ x ≤ r maximum possible multiple number find smallest first line contain integer n — number query ( 1 ≤ n ≤ 10000 ) follow n line contain two integers li ri — arguments correspond query ( 0 ≤ li ≤ ri ≤ 1018 ) query print answer a separate line binary representations number 1 10 list <unknown> = <unknown> = <unknown> = <unknown> = <unknown> = <unknown> = <unknown> = <unknown> = <unknown> = <unknown> = 10102,['constructive algorithms'],1700.0
878/A,petya learn a new program language calpas a program language always take one non - negative integer return one non - negative integer well language three command : apply a bitwise operation xor a give constant current integer a program contain arbitrary sequence operations arbitrary constants 0 1023 . program run operations apply ( give order ) argument end result integer return petya write a program language turn long write a program calpas thing petya 's program consist 5 line program return integer petya 's program arguments 0 1023 . first line contain integer n ( 1 ≤ n ≤ 5·105 ) — number line next n line contain command a command consist a character represent operation ( ` ` & '' ` ` | '' ` ` ^ '' xor respectively ) constant xi 0 ≤ xi ≤ 1023 . output integer k ( 0 ≤ k ≤ 5 ) — length program next k line must contain command format input read bitwise operations https : //en.wikipedia.org / wiki / bitwise_operation second sample : let x input petya 's program 's output ( ( x & 1 ) & 3 ) & 5 = x & ( 1 & 3 & 5 ) = x & 1 two program always give output,['constructive algorithms'],1600.0
912/B,since grisha behave well last year new year 's eve visit ded moroz bring enormous bag gift ! bag contain n sweet candy good ol ' bakery label 1 n correspond tastiness two candy tastiness choice candy a direct effect grisha 's happiness one assume take <unknown> ones — holiday magic turn things upside xor - sum <unknown> matter ordinary sum ! a xor - sum a sequence integers a1 a2 ... define bitwise xor elements : denote bitwise xor operation ; bitwise xor find ded moroz <unknown> grisha house visit grisha take k candy bag help grisha determine largest xor - sum ( largest xor - sum mean maximum happiness ! ) obtain sole string contain two integers n k ( 1 ≤ k ≤ n ≤ 1018 ) output one number — largest possible xor - sum first sample case one optimal answer 1 2 4 give xor - sum 7 . second sample case one example take six candy obtain xor - sum 7,['constructive algorithms'],1300.0
566/E,archaeologists find information ancient land treeland know sure treeland consist n cities connect n - 1 road get city one along roads however information specific design roads treeland lose thing archaeologists use preserve information near cities two cities treeland call near possible move one city one move two roads also a city consider near recent excavations archaeologists find a set n note represent a list cities near n cities country however unfortunately none find record let understand order cities go list city list near cities list help archaeologists restore variant map treeland meet find information first line contain integer n ( 2 ≤ n ≤ 1000 ) — number cities country next n line describe find list near cities list start number k ( 1 ≤ k ≤ n ) represent number cities list follow k city number number list distinct guarantee give information determine least one possible road map print n - 1 pair number represent roads country i - th line must contain two integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) show a road cities ai bi answer print must satisfy description close cities input may print roads countries order cities connect a road may also print order multiple good answer may print,['constructive algorithms'],3200.0
1765/G,"interactive problem use flush operation right print line example c++ use function fflush ( stdout ) java <unknown> — system.out.flush ( ) python — sys.stdout.flush ( ) jury a string $$$ s $$$ consist character 0 and/or 1 . first character string 0 . length string $$$ n $$$ guess string let 's denote $$$ s [ l .. r ] $$$ substring $$$ s $$$ $$$ l $$$ $$$ r $$$ ( i. e. $$$ s [ l .. r ] $$$ string $$$ s_ls _ { l+1 } \dots s_r $$$ ) let prefix function string $$$ s $$$ array $$$ [ p_1 p_2 \dots p_n ] $$$ $$$ p_i $$$ greatest integer $$$ j \in [ 0 i-1 ] $$$ $$$ s [ 1 .. j ] = s [ i - j+1 .. i ] $$$ also let antiprefix function string $$$ s $$$ array $$$ [ q_1 q_2 \dots <unknown> ] $$$ $$$ q_i $$$ greatest integer $$$ j \in [ 0 i-1 ] $$$ $$$ s [ 1 .. j ] $$$ differ $$$ s [ i - j+1 .. i ] $$$ every position example string 011001 prefix function $$$ [ 0 0 0 1 1 2 ] $$$ antiprefix function $$$ [ 0 1 1 2 3 4 ] $$$ ask query two type guess string $$$ s $$$ : guess string ask $$$ <unknown> $$$ query note give answer count a query every test every test case string $$$ s $$$ fix beforehand initially jury program send one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case start test case jury program send one integer $$$ n $$$ ( $$$ 2 \le n \le 1000 $$$ ) — length string , program submit query jury program print one follow line ( forget flush output print a line ! ) : every query jury print one integer a separate line either : submit answer program send a line follow format ( forget flush output print a line ! ) : guess correct jury program print one integer $$$ 1 $$$ a separate line indicate may proceed next test case ( terminate program last test case ) number query ask reset correct jury program print one integer $$$ -1 $$$ a separate line program receive $$$ -1 $$$ answer immediately terminate lead submission receive verdict ` ` wrong answer '' program terminate verdict submission <unknown> example contain one possible way interaction a test $$$ t = 2 $$$ string guess jury 011001 00111 . note everything <unknown> sign a comment explain line mean interaction jury program wo n't print comment actual problem n't print empty line also add convenience jury program wo n't print solution print empty line",['constructive algorithms'],2600.0
916/C,jamie recently find undirected weight graph follow properties interest : familiar term statement find definitions note section help jamie construct graph give number vertices edge interest ! first line input contain 2 integers n m — require number vertices edge first line output 2 integers sp mstw ( 1 ≤ sp mstw ≤ <unknown> ) — length shortest path sum edge ' weight minimum span tree next m line output edge graph line output 3 integers u v w ( 1 ≤ u v ≤ n 1 ≤ w ≤ 109 ) describe edge connect u v weight <unknown> graph sample 1 : shortest path sequence : { 1 2 3 4 } mst edge mark asterisk ( * ) definition term use problem statement : a shortest path undirected graph a sequence vertices ( v1 v2 ... vk ) vi adjacent vi + 1 1 ≤ i < k sum weight minimize w ( i j ) edge weight i j ( https : //en.wikipedia.org / wiki / <unknown> ) a prime number a natural number greater 1 positive divisors 1 ( https : //en.wikipedia.org / wiki / <unknown> ) a minimum span tree ( mst ) a subset edge a connect edge - weighted undirected graph connect vertices together without cycle minimum possible total edge weight ( https : //en.wikipedia.org / wiki / <unknown> ) https : //en.wikipedia.org / wiki / <unknown>,['constructive algorithms'],1600.0
1521/C,"interactive problem ! nastia a hide permutation $$$ p $$$ length $$$ n $$$ consist integers $$$ 1 $$$ $$$ n $$$ , reason want figure permutation , give integer $$$ t $$$ ( $$$ 1 \le t \le 2 $$$ ) two different indices $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i j \le n $$$ $$$ i \neq j $$$ ) integer $$$ x $$$ ( $$$ 1 \le x \le n - 1 $$$ ) depend $$$ t $$$ answer : ask nastia $$$ \lfloor \frac { 3 \cdot n } { 2 } \rfloor + 30 $$$ time guarantee change permutation depend query guess permutation ? input consist several test case begin receive integer $$$ t $$$ ( $$$ 1 \le t \le 10\,000 $$$ ) — number test case begin test case receive integer $$$ n $$$ ( $$$ 3 \le n \le 10000 $$$ ) — length permutation $$$ p $$$ 's guarantee permutation fix beforehand sum $$$ n $$$ one test n't exceed $$$ 20000 $$$ ask a question print ` ` ? $$$ t $$$ $$$ i $$$ $$$ j $$$ $$$ x $$$ ` ` ( $$$ t = 1 $$$ $$$ t = 2 $$$ $$$ 1 \le i j \le n $$$ $$$ i \neq j $$$ $$$ 1 \le x \le n - 1 $$$ ) read answer answer $$$ −1 $$$ instead a valid answer mean exceed number query make invalid query exit immediately receive $$$ −1 $$$ see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream print answer print ` ` ! $$$ p_1 $$$ $$$ p_2 $$$ $$$ \ldots $$$ $$$ p _ { n } $$$ ( without quote ) note answer n't count one $$$ \lfloor \frac { 3 \cdot n } { 2 } \rfloor + 30 $$$ query print a query print answer forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack solution use follow test format first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10\,000 $$$ ) — number test case test case first line print a single integer $$$ n $$$ ( $$$ 3 \le n \le 10000 $$$ ) — length hide permutation $$$ p $$$ second line print $$$ n $$$ space - separated integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) $$$ p $$$ permutation note sum $$$ n $$$ test case exceed $$$ 20000 $$$ consider first test case hide permutation $$$ [ 3 1 4 2 ] $$$ print : ` ` ? $$$ 2 $$$ $$$ 4 $$$ $$$ 1 $$$ $$$ 3 $$$ ` ` get back $$$ \min { ( \max { ( 3 p_4 } ) \max { ( 4 p_1 ) } ) } = 3 $$$ print : ` ` ? $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$ $$$ 2 $$$ ` ` get back $$$ \max { ( \min { ( 2 p_2 ) } \min { ( 3 p_4 ) } ) } = 2 $$$ consider second test case hide permutation $$$ [ 2 5 3 4 1 ] $$$ print : ` ` ? $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 2 $$$ ` ` get back $$$ \min { ( \max { ( 2 p_3 } ) \max { ( 3 p_4 ) } ) } = 3 $$$",['constructive algorithms'],2000.0
1218/G,three planets $$$ x $$$ $$$ y $$$ $$$ z $$$ within alpha <unknown> system inhabit advance <unknown> spaceports planets connect <unknown> space shuttle flight <unknown> decide $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ return flight every exist space shuttle connection since residents alpha strong opponents symmetry a strict rule two spaceports connect a shuttle must a different number flight every pair connect spaceports goal propose a number $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ shuttle flight every two connect spaceports overall number flight differ may assume that:1 ) every planet least one spaceport 2 ) exist shuttle flight spaceports different planets 3 ) every two spaceports a series shuttle flight <unknown> travel <unknown> ) spaceports connect one <unknown> first row input integer number $$$ n $$$ $$$ ( 3 \leq n \leq 100 000 ) $$$ represent overall number spaceports second row integer number $$$ m $$$ $$$ ( 2 \leq m \leq 100 000 ) $$$ represent number shuttle flight connections third row contain $$$ n $$$ character set $$$ \ { x y <unknown> } $$$ letter $$$ <unknown> { th } $$$ position indicate planet situate spaceport $$$ i $$$ example ` ` <unknown> '' indicate spaceports $$$ 0 $$$ $$$ 3 $$$ locate planet $$$ x $$$ spaceports $$$ 1 $$$ $$$ 2 $$$ locate $$$ y $$$ spaceports $$$ 4 $$$ $$$ 5 $$$ $$$ z $$$ start fourth row every row contain two integer number separate a whitespace number natural number smaller $$$ n $$$ indicate number spaceports connect example ` ` $$$ <unknown> 15 $$$ ` ` indicate a shuttle flight spaceports $$$ 12 $$$ $$$ 15 $$$ representation shuttle flight separate row input also contain a third number set $$$ \ { 1 2 3\ } $$$ stand number shuttle flight spaceports,['constructive algorithms'],3000.0
755/E,"polandball undirected simple graph consist n vertices unfortunately edge graph sad polandball want make <unknown> add red edge , add white edge every remain place therefore final graph a clique two color : white red colorfulness graph a value min ( dr dw ) dr diameter red subgraph dw diameter white subgraph diameter a graph a largest value d shortest path pair vertices equal d. graph connect consider diameter -1 . polandball want final graph <unknown> possible want final colorfulness equal k. help find graph satisfy polandball 's request ? one input line contain two integers n k ( 2 ≤ n ≤ 1000 1 ≤ k ≤ 1000 ) represent graph 's size seek colorfulness 's impossible find a suitable graph print -1 . otherwise output graph fulfill polandball 's requirements first output m — number red edge graph , output m line contain two integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) mean undirected red edge vertices ai bi every red edge print exactly print edge vertices every edge arbitrary order remember polandball 's graph remain simple loop multiple edge allow first sample case graph fulfill polandball 's requirements second sample case red graph a path 1 5 . diameter 4 . however white graph diameter 2 consist edge 1 - 3 1 - 4 1 - 5 2 - 4 2 - 5 3 - 5",['constructive algorithms'],2400.0
1528/D,$$$ n $$$ cities shaazzzland number $$$ 0 $$$ $$$ n-1 $$$ ghaazzzland <unknown> enemy shaazzzland rule aaparsa head ghaazzzland 's intelligence agency aaparsa carry important spy mission ghaazzzland 's history shaazzzland aaparsa plant $$$ m $$$ transport cannon cities shaazzzland $$$ i $$$ -th cannon plant city $$$ a_i $$$ initially point city $$$ b_i $$$ guarantee $$$ n $$$ cities least one transport cannon plant inside two cannon city initially point city ( pair $$$ ( a_i b_i ) $$$ distinct ) aaparsa use advance technology build cannon cannon rotate every second word $$$ i $$$ -th cannon point towards city $$$ x $$$ second target city $$$ ( x + 1 ) \mod n $$$ next second name suggest transport cannon transportation specifically human transport use $$$ i $$$ -th cannon launch towards city 's currently point 'll airborne $$$ c_i $$$ second reach target destination still n't get use $$$ i $$$ -th cannon $$$ s $$$ -th second ( use possible currently city $$$ a_i $$$ ) shoot city $$$ ( b_i + s ) \mod n $$$ 'll land $$$ c_i $$$ second ( 'll $$$ ( s + c_i ) $$$ -th second ) also note cannon initially launch rotate every second obviously wo n't change direction airborne aaparsa want use cannon travel shaazzzland 's cities grand plan start travel second $$$ 0 $$$ fully <unknown> need know minimum number second require reach city $$$ u $$$ city $$$ v $$$ use cannon every pair cities $$$ ( u v ) $$$ note aaparsa stay a city long want first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 2 \le n \le 600 n \le m \le n^2 ) $$$ — number cities cannon correspondingly $$$ i $$$ -th line follow $$$ m $$$ line contain three integers $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ $$$ ( 0 \le a_i b_i \le n-1 1 \le c_i \le 1000000000 ) $$$ denote cannon city $$$ a_i $$$ initially point $$$ b_i $$$ travel take $$$ c_i $$$ second guarantee $$$ n $$$ cities least one transport cannon plant inside two cannon city initially point city ( pair $$$ ( a_i b_i ) $$$ distinct ) print $$$ n $$$ line line contain $$$ n $$$ integers $$$ j $$$ -th integer $$$ i $$$ -th line equal minimum time require reach city $$$ j $$$ city $$$ i $$$ first example one possible path go $$$ 0 $$$ $$$ 2 $$$ would :,['constructive algorithms'],2500.0
543/B,country exactly n cities m bidirectional roads connect cities cities number integers 1 n. cities a b connect a road hour go along road either city a city b city b city a. road network city get one move along roads want destroy largest possible number roads country remain roads would allow get city s1 city t1 l1 hours get city s2 city t2 l2 hours determine maximum number roads need destroy order meet condition plan impossible reach desire result print -1 . first line contain two integers n m ( 1 ≤ n ≤ 3000 ) — number cities roads country respectively next m line contain descriptions roads pair integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) guarantee roads give description transport city one guarantee pair cities one road last two line contain three integers s1 t1 l1 s2 t2 l2 respectively ( 1 ≤ si ti ≤ n 0 ≤ li ≤ n ) print a single number — answer problem impossible meet condition print -1,['constructive algorithms'],2100.0
715/B,"zs coder draw undirected graph n vertices number 0 n - 1 m edge edge graph weight weight a positive integer next day zs coder realize weight erase ! want <unknown> positive integer weight edge weight erase length shortest path vertices s t result graph exactly l. help ? first line contain five integers n m l s t ( 2 ≤ n ≤ 1000 1 ≤ m ≤ 10 000 1 ≤ l ≤ 109 0 ≤ s t ≤ n - 1 s ≠ t ) — number vertices number edge desire length shortest path start vertex end vertex respectively , m line describe edge graph follow i - th contain three integers ui vi wi ( 0 ≤ ui vi ≤ n - 1 ui ≠ vi 0 ≤ wi ≤ 109 ) ui vi denote endpoints edge wi denote weight wi equal 0 weight correspond edge erase guarantee one edge pair vertices print ` ` '' ( without quote ) line 's possible assign weight a require way otherwise print ` ` yes '' first line next m line contain edge result graph weight assign edge weight erase i - th contain three integers ui vi wi denote edge vertices ui vi weight wi edge new graph must coincide ones graph input weight erase must remain unchanged whereas new weight positive integer exceed 1018 . order edge output n't matter length shortest path s t must equal l. multiple solutions print 's graph first sample case look like : first sample case one miss edge weight place weight 8 give a shortest path 0 4 length 13 . second sample case a single edge clearly way replace miss weight <unknown> . last sample case weight assign length shortest path n't match require value answer ` ` ''",['constructive algorithms'],2300.0
1578/A,"let us consider game ` ` sticky tetris '' game a field $$$ n \times m $$$ square tile appear field player move tile tile a $$$ 4 $$$ <unknown> set $$$ 7 $$$ square new tile appear position fit inside field intersect tile top cell tile top row field player move tile leave right , moment tile must still entirely fit inside field must intersect tile player stop tile position time , move since ` ` sticky tetris '' tile fall stop give a final configuration a ` ` sticky tetris '' game need restore a sequence step lead configuration exist first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 50 $$$ ) — size play field next $$$ n $$$ line contain a string $$$ m $$$ character character could either a ' ' lowercase english letter connect components letter correspond a single tile tile consist $$$ 7 $$$ square solution print $$$ -1 $$$ otherwise print $$$ k $$$ — number different tile place field next $$$ k $$$ line print sequence step tile order place line consist a number $$$ x $$$ follow a string step $$$ x $$$ ( $$$ 1 \le x \le m $$$ ) start column leftmost square top row tile string consist character ' l ' ( leave ) ' r ' ( right ) 'd ' ( ) describe path tile end a single character 's ' ( stop ) final position tile determine tile place string step $$$ n \cdot m + 1 $$$ character",['constructive algorithms'],2800.0
1779/G,"time finally come <unknown> <unknown> host game century purpose build a village <unknown> participants village shape equilateral triangle <unknown> three roads length $$$ n $$$ cut $$$ n^2 $$$ smaller equilateral triangles side length $$$ 1 $$$ $$$ <unknown> $$$ additional roads run parallel side see figure $$$ n=3 $$$ $$$ 3n $$$ roads make multiple ( possibly $$$ 1 $$$ ) road segment length $$$ 1 $$$ connect adjacent intersections direction already choose $$$ 3n $$$ roads ( road direction assign road segment ) traffic go specify directions ( i. e. roads <unknown> ) task make <unknown> traffic plan intersection possible reach every intersection specifically invert traffic direction number road segment length $$$ 1 $$$ minimal number road segment need invert traffic direction ? test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 10\,000 $$$ ) description test case follow first line test case contain a positive integer $$$ n $$$ ( $$$ 1\leq n\leq 100000 $$$ ) — size triangular village 's side three line follow contain a binary string length $$$ n $$$ describe traffic directions roads $$$ i $$$ -th follow three line contain a binary string $$$ s_i $$$ length $$$ n $$$ represent direction road parallel road segment denote $$$ i $$$ picture particular $$$ j $$$ -th character $$$ s_i $$$ ` ` 1 '' $$$ j $$$ -th shortest road ( parallel road segment denote $$$ i $$$ picture ) direction road segment denote $$$ i $$$ picture ` ` 0 '' opposite direction first character $$$ s_i $$$ describe direction road contain $$$ 1 $$$ road segment last character describe direction road contain $$$ n $$$ road segment guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print minimum number road segment need invert traffic direction first example correspond picture statement exist multiple solutions invert traffic direction exactly $$$ 2 $$$ road segment invert $$$ 1 $$$ road segment never make possible reach every intersection one possible solutions show picture invert road segment highlight blue second example answer $$$ 0 $$$ since already possible reach every intersection",['constructive algorithms'],3000.0
1264/E,a football league recently begin beautiful land $$$ n $$$ team participate league let 's enumerate integers $$$ 1 $$$ $$$ n $$$ play exactly $$$ \frac { n ( n-1 ) } { 2 } $$$ match : team play team exactly match always a winner loser draw match play organizers count number beautiful triple let 's call a triple three team $$$ ( a b c ) $$$ beautiful a team $$$ a $$$ win a team $$$ b $$$ a team $$$ b $$$ win a team $$$ c $$$ a team $$$ c $$$ win a team $$$ a $$$ look a triple different team order team triple important beauty league number beautiful triple moment $$$ m $$$ match play result know maximum beauty league play remain match ? also find a possible result remain $$$ \frac { n ( n-1 ) } { 2 } - m $$$ match league maximum beauty first line contain two integers $$$ n m $$$ ( $$$ 3 \leq n \leq 50 0 \leq m \leq \frac { n ( n-1 ) } { 2 } $$$ ) — number team football league number match play $$$ m $$$ follow line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \leq u v \leq n $$$ $$$ u \neq v $$$ ) denote $$$ u $$$ -th team $$$ v $$$ -th team guarantee unordered pair team appear print $$$ n $$$ line line a string exactly $$$ n $$$ character character must either $$$ 0 $$$ $$$ 1 $$$ let $$$ a _ { ij } $$$ $$$ j $$$ -th number $$$ i $$$ -th line $$$ 1 \leq i \leq n $$$ true $$$ a _ { ii } = 0 $$$ pair team $$$ i \neq j $$$ number $$$ a _ { ij } $$$ indicate result match $$$ i $$$ -th team $$$ j $$$ -th team : also note result $$$ m $$$ match already play change league beauty league output maximum possible multiple possible answer maximum beauty print beauty league first test case equal $$$ 3 $$$ exist three beautiful triple : $$$ ( 1 2 3 ) $$$ $$$ ( 2 3 1 ) $$$ $$$ ( 3 1 2 ) $$$ beauty league second test equal $$$ 6 $$$ exist six beautiful triple : $$$ ( 1 2 4 ) $$$ $$$ ( 2 4 1 ) $$$ $$$ ( 4 1 2 ) $$$ $$$ ( 2 4 3 ) $$$ $$$ ( 4 3 2 ) $$$ $$$ ( 3 2 4 ) $$$,['constructive algorithms'],2700.0
1615/G,give array $$$ a $$$ consist $$$ n $$$ non - negative integers replace $$$ 0 $$$ $$$ a $$$ integer $$$ 1 $$$ $$$ n $$$ ( different elements equal $$$ 0 $$$ replace different integers ) value array obtain number integers $$$ k $$$ $$$ 1 $$$ $$$ n $$$ follow condition hold : exist a pair adjacent elements equal $$$ k $$$ ( i. e. exist $$$ i \in [ 1 n - 1 ] $$$ $$$ a_i = a _ { i + 1 } = k $$$ ) multiple pair integer $$$ k $$$ integer count value task obtain array maximum possible value first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 300000 $$$ ) — number elements array second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le \min ( n 600 ) $$$ ) — elements array print $$$ n $$$ integers less $$$ 1 $$$ greater $$$ n $$$ — array maximum possible value obtain multiple answer print,['constructive algorithms'],3300.0
1110/G,"<unknown> - <unknown> - <unknown> game start a tree $$$ n $$$ vertices vertices already color white remain uncolored two players — white black players make move alternatively white player start game turn a player must select one uncolored vertex paint color player win paint path three vertices color case vertices color neither player game end a draw could please find win game whether end a draw assume players play optimally ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 50\,000 $$$ ) — number test case descriptions $$$ t $$$ test case follow first line test contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) — number vertices tree follow $$$ n - 1 $$$ line contain integers $$$ v $$$ $$$ u $$$ ( $$$ 1 \le v u \le n $$$ ) denote edge tree connect vertices $$$ v $$$ $$$ u $$$ last line a test case contain a string letter ' w ' ( white ) ' n ' ( color ) length $$$ n $$$ denote already color vertices vertexes already color white denote ' w ' 's guarantee give edge form a tree least one uncolored vertex path three white vertices 's guarantee sum $$$ n $$$ among test case $$$ 500000 $$$ every test case print either ` ` white '' ` ` draw '' ` ` black '' depend result game first example vertex $$$ 4 $$$ already color white white player win color vertex $$$ 1 $$$ white first remain vertex second turn process illustrate picture second example show player enforce victory",['constructive algorithms'],3100.0
1762/D,"interactive problem a secret permutation $$$ p $$$ $$$ [ 0,1,2 \ldots n-1 ] $$$ task find $$$ 2 $$$ indices $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq x y \leq n $$$ possibly $$$ x = y $$$ ) $$$ p_x=0 $$$ $$$ p_y=0 $$$ order find allow ask $$$ 2n $$$ query one query give two integers $$$ i $$$ $$$ j $$$ ( $$$ 1 \leq i j \leq n $$$ $$$ i \neq j $$$ ) receive value $$$ \gcd ( p_i p_j ) ^\dagger $$$ note permutation $$$ p $$$ fix query make depend query $$$ ^\dagger $$$ $$$ \gcd ( x y ) $$$ denote greatest common divisor ( gcd ) integers $$$ x $$$ $$$ y $$$ note $$$ \gcd ( <unknown> ) = \gcd ( 0 x ) = x $$$ positive integers $$$ x $$$ test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 20000 $$$ ) read integer $$$ n $$$ test case begin interaction guarantee sum $$$ n $$$ test case exceed $$$ 20000 $$$ interaction test case begin read integer $$$ n $$$ make a query output ` ` ? $$$ i $$$ $$$ j $$$ ` ` ( $$$ 1 \leq i j \leq n $$$ $$$ i \neq j $$$ ) without quote afterwards read a single integer — answer query $$$ \gcd ( p_i p_j ) $$$ make $$$ 2n $$$ query test case want print answer output ` ` ! $$$ x $$$ $$$ y $$$ ` ` ( $$$ 1 \leq x y \leq n $$$ ) without quote , read $$$ 1 $$$ $$$ -1 $$$ $$$ p_x=0 $$$ $$$ p_y=0 $$$ 'll receive $$$ 1 $$$ otherwise 'll receive $$$ -1 $$$ receive $$$ -1 $$$ program must terminate immediately receive a wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream receive integer $$$ -1 $$$ instead answer a valid value $$$ n $$$ mean program make invalid query exceed limit query give incorrect answer previous test case program must terminate immediately receive a wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream print a query answer forget output end line flush output otherwise get idleness limit exceed , use : hacksto hack use follow format first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) first line test case contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 20000 $$$ ) second line test case contain $$$ n $$$ space separate integers $$$ p_1 p_2 \ldots p_n $$$ $$$ p $$$ a permutation $$$ [ 0,1,2 \ldots n-1 ] $$$ sum $$$ n $$$ exceed $$$ 20000 $$$ first test interaction proceed follow note empty line example input output sake clarity occur real interaction test case make sure read $$$ 1 $$$ $$$ -1 $$$",['constructive algorithms'],2100.0
1454/A,give one integer $$$ n $$$ ( $$$ n > 1 $$$ ) recall a permutation length $$$ n $$$ array consist $$$ n $$$ distinct integers $$$ 1 $$$ $$$ n $$$ arbitrary order example $$$ [ 2 3 1 5 4 ] $$$ a permutation length $$$ 5 $$$ $$$ [ 1 2 2 ] $$$ a permutation ( $$$ 2 $$$ appear twice array ) $$$ [ 1 3 4 ] $$$ also a permutation ( $$$ n = 3 $$$ $$$ 4 $$$ array ) task find a permutation $$$ p $$$ length $$$ n $$$ index $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) $$$ p_i = i $$$ ( $$$ i $$$ $$$ 1 $$$ $$$ n $$$ condition $$$ p_i \ne i $$$ satisfy ) answer $$$ t $$$ independent test case several answer print prove answer exist $$$ n > 1 $$$ first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case $$$ t $$$ test case follow line test case contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — length permutation find test case print $$$ n $$$ distinct integers $$$ p_1 p_2 \ldots p_n $$$ — a permutation index $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) $$$ p_i = i $$$ ( $$$ i $$$ $$$ 1 $$$ $$$ n $$$ condition $$$ p_i \ne i $$$ satisfy ) several answer print prove answer exist $$$ n > 1 $$$,['constructive algorithms'],800.0
1355/F,"interactive problem hide integer $$$ 1 \le x \le 10^ { 9 } $$$ n't guess number find number divisors number n't even find exact number : answer consider correct absolute error greater 7 relative error greater $$$ 0.5 $$$ formally let answer $$$ ans $$$ number divisors $$$ x $$$ $$$ d $$$ answer consider correct least one two follow condition true : make $$$ 22 $$$ query one query consist one integer $$$ 1 \le q \le 10^ { 18 } $$$ response get $$$ gcd ( x q ) $$$ — greatest common divisor $$$ x $$$ $$$ q $$$ number $$$ x $$$ fix query word interactor adaptive let 's call process guess number divisors number $$$ x $$$ a game one test play $$$ t $$$ independent game , guess number divisors $$$ t $$$ time $$$ t $$$ independent value $$$ x $$$ first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number game make a query print a line ` ` ? q '' ( $$$ 1 \le q \le 10^ { 18 } $$$ ) read one integer $$$ gcd ( x q ) $$$ make $$$ 22 $$$ query one game confident figure number divisors $$$ x $$$ enough precision print answer ` ` ! ans '' format $$$ ans $$$ integer last game terminate program otherwise start next game immediately note interactor n't print anything response print answer print a query forget output end line flush output , use : hacksto hack use follow format : first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number game next $$$ t $$$ line contain one integer $$$ x $$$ ( $$$ 1 \le x \le 10^ { 9 } $$$ ) — hide number example form limitation number query 22 exactly ? maybe problem author a <unknown> <unknown> fan let 's look example first game $$$ x = 998\,244\,353 $$$ hide would hard guess right ? number prime number divisors 2 . solution make several random query responses turn 1 ( strange things even one three random number divisible $$$ 998\,244\,353 $$$ ) 's <unknown> assume hide number n't many divisors solution answer 5 . answer consider correct since $$$ | 5 - 2 | = 3 \le 7 $$$ second game $$$ x = 4\,194\,304 = 2^ { 22 } $$$ hide 23 divisors solution make query $$$ 1024 = 2^ { 10 } $$$ $$$ 1\,048\,576 = 2^ { 20 } $$$ $$$ <unknown> = 2^ { 30 } $$$ get responses $$$ 1024 = 2^ { 10 } $$$ $$$ 1\,048\,576 = 2^ { 20 } $$$ $$$ 4\,194\,304 = 2^ { 22 } $$$ respectively solution get completely confuse answer answer <unknown> question life universe everything answer consider correct since $$$ \frac { 1 } { 2 } \le \frac { 42 } { 23 } \le 2 $$$",['constructive algorithms'],2600.0
1386/A,linda like change hair color time time would please <unknown> archie would notice difference previous new color archie always comment linda 's hair color notice a difference — linda always know whether archie spot difference a new hair dye series market available color number integers $$$ 1 $$$ $$$ n $$$ a smaller difference numerical value also mean less <unknown> difference linda assume series critical color difference $$$ c $$$ ( $$$ 1 \le c \le n $$$ ) archie notice color difference current color $$$ \mathrm { color } _ { \mathrm { new } } $$$ previous color $$$ \mathrm { color } _ { \mathrm { prev } } $$$ $$$ \left|\mathrm { color } _ { \mathrm { new } } - \mathrm { color } _ { \mathrm { prev } } \right| \ge c $$$ $$$ \left|\mathrm { color } _ { \mathrm { new } } - \mathrm { color } _ { \mathrm { prev } } \right| < c $$$ buy $$$ n $$$ set hair dye new series — one color $$$ 1 $$$ $$$ n $$$ ready set experiment linda change hair color a regular <unknown> observe archie 's reaction — whether notice color change since proper dye set use completely hair color obtain experiment linda use a dye a different series <unknown> new one <unknown> experiment archie 's reaction first use color <unknown> aim find precise value $$$ c $$$ a limit number dye write a program find value $$$ c $$$ experiment give $$$ n $$$ color observe archie 's reactions color change interactive task begin give a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) number case test test case input first contain a single integer — value $$$ n $$$ ( $$$ 1 < n \le 10^ { 18 } $$$ ) value $$$ c $$$ keep secret grade system program make query write output follow format : ` ` ? $$$ p $$$ ` ` $$$ p $$$ integer ( $$$ 1 \le p \le n $$$ ) denote next color use query grade system give answer next line input answer $$$ 1 $$$ archie notice color difference last two color $$$ 0 $$$ otherwise two query $$$ p $$$ value program determine $$$ c $$$ output value follow format : ` ` = $$$ c $$$ ` ` grade system respond output proceed next test case program may use 64 query ` ` ? '' test case find correct value $$$ c $$$ establish proper communication program grade system flush output stream query note <unknown> : : <unknown> write a newline flush stream possible receive ` ` output n't correct '' outcome even print a correct answer task constraints violate communication violate communication protocol may result ` ` execution kill '' outcome submit user test require specify input file testcase parameters format input file ` ` $$$ t $$$ ` ` first line ` ` $$$ n $$$ $$$ c $$$ ` ` a single line $$$ t $$$ case subtasks : comment example input line line :,['constructive algorithms'],2700.0
1503/B,"interactive problem alice bob play a game $$$ n\times n $$$ grid initially empty refer cell row $$$ i $$$ column $$$ j $$$ $$$ ( i j ) $$$ $$$ 1\le i j\le n $$$ infinite supply tokens come $$$ 3 $$$ color label $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ game proceed turn follow turn begin alice name one three color let 's call $$$ a $$$ , bob choose a color $$$ b\ne a $$$ choose empty cell place a token color $$$ b $$$ cell say a conflict exist two adjacent cells contain tokens color two cells consider adjacent share a common edge moment a conflict alice win otherwise $$$ n^2 $$$ turn complete ( grid become full ) without conflict bob win a proof bob a win strategy play game bob win interactor adaptive , alice 's color choices depend bob 's previous move interaction begin read a single integer $$$ n $$$ ( $$$ 2\le n\le 100 $$$ ) — size grid turn game follow begin turn read integer $$$ a $$$ ( $$$ 1\le a\le 3 $$$ ) — alice 's choose color must print three integers $$$ b i j $$$ ( $$$ 1\le b\le 3 b\ne a 1\le i j\le n $$$ ) — denote bob put a token color $$$ b $$$ cell $$$ ( i j ) $$$ cell $$$ ( i j ) $$$ must contain a token a previous turn move invalid lose game interaction terminate receive a wrong answer verdict $$$ n^2 $$$ turn complete make sure exit immediately avoid get unexpected verdicts print something forget output end line flush output otherwise get idleness limit exceed , use : hack formatto hack use follow format first line contain a single integer $$$ n $$$ ( $$$ 2\le n\le 100 $$$ ) second line contain $$$ n^2 $$$ integers $$$ a_1 \ldots a _ { n^2 } $$$ ( $$$ 1\le a_i\le 3 $$$ ) $$$ a_i $$$ denote alice 's color $$$ i $$$ -th turn interactor might <unknown> list color hack force bob lose final grid sample picture bob win two adjacent cells tokens color $$$ $$$ \begin { matrix } 2 & <unknown> & <unknown> { matrix } $$$ $$$ sample give demonstrate input output format guarantee represent optimal strategy bob real behavior interactor",['constructive algorithms'],1700.0
1526/F,"interactive problem a secret permutation $$$ p $$$ ( $$$ 1 $$$ -indexed ) number $$$ 1 $$$ $$$ n $$$ formally $$$ 1 \leq i \leq n $$$ $$$ 1 \leq p [ i ] \leq n $$$ $$$ 1 \leq i < j \leq n $$$ $$$ p [ i ] \neq p [ j ] $$$ know $$$ p [ 1 ] < p [ 2 ] $$$ $$$ 1 $$$ query give $$$ 3 $$$ distinct integers $$$ a b c $$$ ( $$$ 1 \leq a b c \leq n $$$ ) receive median $$$ \ { |p [ a ] -p [ b ] | |p [ b ] -p [ c ] | |p [ a ] -p [ c ] |\ } $$$ case median $$$ 2 $$$ -nd element ( $$$ 1 $$$ -indexed ) sequence sort non - decreasing order median $$$ \ { <unknown> } $$$ $$$ 4 $$$ median $$$ \ { <unknown> } $$$ $$$ 33 $$$ find secret permutation $$$ 2n+420 $$$ query ? note : <unknown> adaptive : permutation fix query make first line input contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000 ) $$$ — number testcases first line testcase consist a single integer $$$ n $$$ $$$ ( 20 \leq n \leq 100000 ) $$$ — length secret permutation guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ testcase begin interaction read $$$ n $$$ perform a query output ` ` ? a b c '' $$$ a b c $$$ $$$ 3 $$$ indices want use query number satisfy $$$ 1 \leq a b c \leq n $$$ $$$ a \neq b $$$ $$$ b \neq c $$$ $$$ a \neq c $$$ query receive a single integer $$$ x $$$ : median $$$ \ { |p [ a ] -p [ b ] | |p [ b ] -p [ c ] | |p [ a ] -p [ c ] |\ } $$$ case query invalid ask $$$ 2n+420 $$$ query interactor print ` ` −1 '' finish interaction receive wrong answer verdict make sure exit immediately avoid get verdicts determine secret permutation output ` ` ! p [ 1 ] p [ 2 ] ... p [ n ] '' secret permutation correct interactor print ` ` 1 '' otherwise interactor print ` ` -1 '' finish interaction receive wrong answer verdict make sure exit immediately avoid get verdicts print a query forget output end line flush output otherwise get idleness limit exceed verdict , use : hack : hack use follow format test : first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number testcases first line testcase contain a single integer $$$ n $$$ ( $$$ 20 \leq n \leq 100000 $$$ ) — length secret permutation follow line contain $$$ n $$$ integers $$$ p [ 1 ] p [ 2 ] p [ 3 ] \ldots p [ n ] $$$ $$$ p [ 1 ] < p [ 2 ] $$$ $$$ p $$$ must a permutation integers $$$ 1 $$$ $$$ n $$$ must ensure sum $$$ n $$$ testcases exceed $$$ 100000 $$$ secret permutation $$$ \ { 9,10,19,7,16,18,11,14,15,6,20,8,17,4,5,3,12,2,13,1\ } $$$ first query value $$$ ( a b c ) $$$ $$$ ( <unknown> ) $$$ since $$$ p [ 1 ] = 9 $$$ $$$ p [ 5 ] = 16 $$$ $$$ p [ 2 ] = 10 $$$ return value median $$$ \ { |9 - <unknown> <unknown> - 10| |9 - 10|\ } $$$ $$$ 6 $$$ second query value $$$ ( a b c ) $$$ $$$ ( <unknown> ) $$$ since $$$ p [ 20 ] = 1 $$$ $$$ p [ 19 ] = 13 $$$ $$$ p [ 2 ] = 10 $$$ return value median $$$ \ { |1 - <unknown> <unknown> - 10| |1 - 10|\ } $$$ $$$ 9 $$$ <unknown> figure secret permutation $$$ \ { 9,10,19,7,16,18,11,14,15,6,20,8,17,4,5,3,12,2,13,1\ } $$$ output receive $$$ 1 $$$ interactor mean guess secret permutation correctly",['constructive algorithms'],3000.0
1624/F,problem interactive decide play a game guess number $$$ x $$$ ( $$$ 1 \le x < n $$$ ) know number $$$ n $$$ make query like : win guess current number $$$ 10 $$$ query interaction begin read integer $$$ n $$$ ( $$$ 2 < n \le 1000 $$$ ) write input data line make $$$ 10 $$$ query make a query print a separate line : print answer like query a separate line answer n't count number query output use follow format : program exit use a flush operation right print line example c++ use function fflush ( stdout ) java — system.out.flush ( ) pascal — flush ( output ) python — sys.stdout.flush ( ) note interactor <unknown> make a hack use follow format : a single line must contain two number $$$ x $$$ $$$ n $$$ separate a space first sample initially $$$ x = 2 $$$ first query $$$ x = 3 $$$ $$$ \lfloor\frac { x } { n } \rfloor = 1 $$$ second sample also initially $$$ x = 2 $$$ first query $$$ x = 3 $$$ $$$ \lfloor\frac { x } { n } \rfloor = 0 $$$ second query $$$ x = 4 $$$ $$$ \lfloor\frac { x } { n } \rfloor = 0 $$$ third query $$$ <unknown> $$$ $$$ \lfloor\frac { x } { n } \rfloor = 1 $$$,['constructive algorithms'],2000.0
1697/D,"interactive problem remember flush output communicate test program may use fflush ( stdout ) c++ system.out.flush ( ) java stdout.flush ( ) python flush ( output ) pascal flush output use program language consult documentation may also refer guide interactive problems : https : //codeforces.com / blog / entry/45307 jury choose a string $$$ s $$$ consist $$$ n $$$ character ; character $$$ s $$$ a lowercase latin letter task guess string ; initially know length may ask query two type : allow ask $$$ 26 $$$ query first type $$$ 6000 $$$ query second type task restore string $$$ s $$$ test problem string $$$ s $$$ fix beforehand every submission initially jury program send one integer $$$ n $$$ a separate line — size $$$ s $$$ ( $$$ 1 \le n \le 1000 $$$ ) give answer print one line ! s a line break end $$$ s $$$ string pick jury , program flush output terminate gracefully ask a query send one line contain query one follow format : n't forget flush output send query line answer query give a separate line a query first type answer character $$$ s_i $$$ a query second type answer integer equal number different character among $$$ s_l s _ { l+1 } \dots s_r $$$ allow ask $$$ 26 $$$ query first type $$$ 6000 $$$ query second type case ask many query jury program fail recognize query format answer query one integer $$$ 0 $$$ receive $$$ 0 $$$ answer program terminate immediately — otherwise may receive verdict ` ` runtime error '' ` ` time limit exceed '' verdict instead ` ` wrong answer '' let 's analyze example interaction string choose jury guess initially jury send one integer $$$ 5 $$$ end answer submit ! guess deduce correctly",['constructive algorithms'],1900.0
1698/D,"interactive problem initially array $$$ a = [ 1 2 \ldots n ] $$$ $$$ n $$$ odd positive integer jury select $$$ \frac { n-1 } { 2 } $$$ disjoint pair elements elements pair swap example $$$ a= [ <unknown> ] $$$ pair $$$ 1 \leftrightarrow 4 $$$ $$$ 3 \leftrightarrow 5 $$$ swap result array $$$ [ 4 2 5 1 3 ] $$$ a result swap exactly one element change position need find element , ask several query query pick two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l \leq r \leq n $$$ ) return give elements subarray $$$ [ a_l a _ { l + 1 } \dots a_r ] $$$ sort increase order find element change position make $$$ \mathbf { 15 } $$$ query array $$$ a $$$ fix interaction change query recall array $$$ b $$$ a subarray array $$$ a $$$ $$$ b $$$ obtain $$$ a $$$ deletion several ( possibly zero ) elements begin several ( possibly zero ) elements end test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 500 $$$ ) — number test case description test case follow first line test case contain integer $$$ n $$$ ( $$$ 3 \leq n < 10000 $$$ ; $$$ n $$$ odd ) — length array $$$ a $$$ read first line test case begin interaction guarantee sum $$$ n $$$ test case exceed $$$ 10000 $$$ test case begin interaction read integer $$$ n $$$ make a query output ` ` $$$ \texttt { ? } \ ; l\ ; r $$$ ` ` ( $$$ 1 \leq l \leq r \leq n $$$ ) without quote afterwards read $$$ r - l+1 $$$ integers — integers $$$ a_l a _ { l + 1 } \dots a_r $$$ increase order make $$$ 15 $$$ query a single test case receive integer $$$ -1 $$$ instead answer integer $$$ n $$$ mean program make invalid query exceed limit query give incorrect answer previous test case program must terminate immediately receive a wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream ready give final answer output ` ` $$$ \texttt { ! } \ ; x $$$ ` ` ( $$$ 1 \leq x \leq n $$$ ) without quote — element change position give answer count towards limit $$$ 15 $$$ query afterwards program must continue solve remain test case exit test case solve print a query forget output end line flush output otherwise get idleness limit exceed , use : hacksto make a hack use follow format first line must contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 500 $$$ ) — number test case description test case follow first line test case must contain integer $$$ n $$$ ( $$$ 3 \leq n < 10000 $$$ ; $$$ n $$$ odd ) — length array $$$ a $$$ second line test case must contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — elements $$$ a $$$ array $$$ a $$$ result $$$ \frac { n-1 } { 2 } $$$ disjoint swap array $$$ [ 1,2 \dots n ] $$$ first test interaction proceed follow note line break example input output sake clarity occur real interaction",['constructive algorithms'],1600.0
1746/E1,"difference problem hard version maximum number question interactive problem a hide integer $$$ 1 \le x \le n $$$ find order find ask $$$ \mathbf { 82 } $$$ question question choose a non - empty integer set $$$ s $$$ ask $$$ x $$$ belong $$$ s $$$ question $$$ x $$$ belong $$$ s $$$ 'll receive ` ` yes '' otherwise ` ` '' problem answer necessarily true ( joke ) 's guarantee two consecutive question least one answer correctly additionally question make $$$ 2 $$$ guess answer $$$ x $$$ time make a guess guess $$$ x $$$ correctly receive ` ` : ) '' program terminate otherwise 'll receive ` ` : ( ` ` a part joke fix value $$$ x $$$ begin instead change throughout interaction long previous responses valid describe note answer guess always answer correctly ask a question a guess least one two question answer correctly normal line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) maximum possible value $$$ x $$$ question want ask a set $$$ s $$$ first print character ' ? ' print size $$$ s $$$ print elements $$$ s $$$ one one element integer $$$ 1 $$$ $$$ n $$$ elements must distinct question read a string ` ` yes '' ` ` '' explain statement make $$$ 82 $$$ question want guess $$$ x $$$ first print character ' ! ' print guess guess read ` ` : ) '' ` ` : ( ` ` guess $$$ x $$$ correctly answer ` ` : ) '' program terminate immediately otherwise 'll receive ` ` : ( ` ` make $$$ 2 $$$ guess print a query forget output end line flush output otherwise get idleness limit exceed , use : hack allow problem answer first question correct $$$ x $$$ would equal $$$ 6 $$$ see first guess $$$ 6 $$$ answer answer first question joke know answer least one two question correct since answer first question joke answer second question correct understand $$$ x $$$ equal $$$ 1 2 3 $$$ $$$ 4 $$$ also know $$$ x $$$ equal $$$ 6 $$$ either hence $$$ x $$$ equal $$$ 5 $$$",['constructive algorithms'],2500.0
1438/C,artem build a new robot a matrix $$$ a $$$ consist $$$ n $$$ row $$$ m $$$ columns cell locate $$$ i $$$ -th row top $$$ j $$$ -th column leave a value $$$ a _ { i j } $$$ write two adjacent cells contain value robot break a matrix call good two adjacent cells contain value two cells call adjacent share a side artem want increment value cells one make $$$ a $$$ good formally find a good matrix $$$ b $$$ satisfy follow condition — constraints problem show a matrix $$$ b $$$ always exist several table output please note minimize number <unknown> test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) description test case follow first line test case contain two integers $$$ n m $$$ ( $$$ 1 \le n \le 100 $$$ $$$ 1 \le m \le 100 $$$ ) — number row columns respectively follow $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th integer $$$ i $$$ -th line $$$ a _ { i j } $$$ ( $$$ 1 \leq a _ { i j } \leq 1000000000 $$$ ) case output $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th integer $$$ i $$$ -th line $$$ b _ { i j } $$$ case verify two adjacent cells value $$$ b $$$ $$$ a $$$ value <unknown> one,['constructive algorithms'],2000.0
1290/D,"hard version problem find easy version <unknown> 2 contest versions differ number time ask friend taste coffee interactive problem 're consider move another city one friends already live $$$ n $$$ <unknown> city $$$ n $$$ a power two $$$ i $$$ -th café produce a single variety coffee $$$ a_i $$$ 're a coffee - lover decide move want know number $$$ d $$$ distinct varieties <unknown> produce city n't know value $$$ a_1 \ldots a_n $$$ fortunately friend a memory size $$$ k $$$ $$$ k $$$ a power two per day ask taste a cup coffee produce café $$$ c $$$ tell taste a similar coffee last $$$ k $$$ days also ask take a <unknown> reset memory forget previous cup coffee taste reset memory $$$ 30\ 000 $$$ time formally memory friend a queue $$$ s $$$ a query café $$$ c $$$ : a reset request pop elements $$$ s $$$ friend taste $$$ \dfrac { 3n^2 } { 2k } $$$ cup coffee total find diversity $$$ d $$$ ( number distinct value array $$$ a $$$ ) note ask friend reset memory count towards number time ask friend taste a cup coffee test case behavior interactor adaptive mean array $$$ a $$$ may fix start interaction may depend query guarantee moment interaction least one array $$$ a $$$ consistent answer give far first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 1024 $$$ $$$ k $$$ $$$ n $$$ power two ) guarantee $$$ \dfrac { 3n^2 } { 2k } \le 15\ 000 $$$ begin interaction read $$$ n $$$ $$$ k $$$ ? $$$ c $$$ $$$ c $$$ must satisfy $$$ 1 \le c \le n $$$ n't forget flush get answer response receive a single letter y ( yes ) n ( ) tell variety $$$ <unknown> $$$ one last $$$ k $$$ varieties coffee memory . ! $$$ d $$$ case query invalid ask $$$ \frac { 3n^2 } { 2k } $$$ query type ? ask $$$ 30\ 000 $$$ query type r program print letter e finish interaction receive a wrong answer verdict make sure exit immediately avoid get verdicts print a query forget output end line flush output otherwise get idleness limit exceed , use : hack <unknown> first line contain word <unknown> second line contain two integers $$$ n $$$ $$$ k $$$ separate space ( $$$ 1 \le k \le n \le 1024 $$$ $$$ k $$$ $$$ n $$$ power two ) must hold $$$ \dfrac { 3n^2 } { 2k } \le 15\ 000 $$$ third line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ separate space ( $$$ 1 \le a_i \le n $$$ ) first example array $$$ a = [ 1 4 1 3 ] $$$ city produce $$$ 3 $$$ different varieties coffee ( $$$ 1 $$$ $$$ 3 $$$ $$$ 4 $$$ ) successive varieties coffee taste friend $$$ 1 4 \textbf { 1 } 3 3 1 4 $$$ ( bold answer correspond y answer ) note two ? 4 ask a reset memory request r answer second ? 4 ask n. reset memory request answer second ? 4 ask y. second example array $$$ a = [ 1 2 3 4 5 6 6 6 ] $$$ city produce $$$ 6 $$$ different varieties coffee successive varieties coffee taste friend $$$ 2 6 4 5 \textbf { 2 } \textbf { 5 } $$$",['constructive algorithms'],3000.0
1137/D,"interactive problem misha like play cooperative game <unknown> information today suggest ten friends play a cooperative game ` ` lake '' misha already come a field upcoming game field game a direct graph consist two part first part a road along coast lake a cycle $$$ c $$$ vertices second part a path home lake a chain $$$ t $$$ vertices edge last vertex chain vertex road along coast beautiful view lake also know finish vertex misha decide keep field secret nobody know neither $$$ t $$$ $$$ c $$$ note vertex field exactly one outgo edge vertices except home vertex finish vertex exactly one <unknown> edge home vertex incoming edge finish vertex two incoming edge begin game piece ten players index consecutive integers $$$ 0 $$$ $$$ 9 $$$ home vertex turn players ask misha simultaneously move piece along correspond edge misha answer $$$ q $$$ query move misha tell players whose piece vertices whose piece different vertices goal game move piece finish vertex misha 's friends idea win a game without knowledge $$$ c $$$ $$$ t $$$ $$$ q $$$ luckily friends help : coordinate action win game misha draw a field $$$ 1 \le t c $$$ $$$ ( t+c ) \leq 1000 $$$ $$$ q = 3 \cdot ( t+c ) $$$ input — go interaction part straight away friends gather finish vertex print ` ` do '' terminate program give a command move friends print ` ` next '' space - separated indices friends want move example give command move friends indices $$$ 0 $$$ $$$ 2 $$$ $$$ 5 $$$ $$$ 9 $$$ print ` ` next 0 2 5 9 '' turn must move least one friends answer first read integer $$$ k $$$ $$$ 10 $$$ digits divide $$$ k $$$ space - separated group friends correspond indices group vertex friends correspond indices different group different vertices indices group follow ascend order example answer ` ` 2 <unknown> <unknown> '' mean friends indices $$$ 0 $$$ $$$ 5 $$$ one vertex friends different vertex answer ` ` 4 01 567 234 <unknown> '' mean misha 's friends four different vertices : friends indices $$$ 0 $$$ $$$ 1 $$$ first friends indices $$$ 5 $$$ $$$ 6 $$$ $$$ 7 $$$ second friends indices $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ third friends indices $$$ 8 $$$ $$$ 9 $$$ fourth print a query forget output end line flush output otherwise get idleness limit exceed , use : answer ` ` stop '' instead a valid one mean make invalid query exit immediately receive ` ` stop '' see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream <unknown> order hack print two integers $$$ t $$$ $$$ c $$$ a single line ( $$$ 1 \le t c $$$ $$$ ( t+c ) \leq 1000 $$$ ) sample input output value align simplicity <unknown> chronologically real interaction ` ` extra '' line break appear example friends move follow :",['constructive algorithms'],2400.0
1527/B1,"difference easy hard versions give string $$$ s $$$ easy version initially a palindrome condition always true hard version a palindrome a string read leave right right leave example ` ` 101101 '' a palindrome ` ` 0101 '' alice bob play a game a string $$$ s $$$ ( initially a palindrome version ) length $$$ n $$$ consist character ' 0 ' ' 1 ' players take alternate turn alice go first turn player perform one follow operations : reverse a string mean reorder letter last first example ` ` 01001 '' become ` ` 10010 '' reverse game end every character string become ' 1 ' player spend minimum dollars till point win game a draw spend equal dollars players play optimally output whether alice win bob win a draw first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) second line test case contain string $$$ s $$$ length $$$ n $$$ consist character ' 0 ' ' 1 ' guarantee string $$$ s $$$ a palindrome contain least one ' 0 ' note limit sum $$$ n $$$ test case test case print a single word a new line : first test case example ,",['constructive algorithms'],1200.0
713/B,filya learn new geometry object — rectangle give a field consist n × n unit cells row number bottom top integer 1 n. columns number leave right integers 1 n. cell locate intersection row r column c denote ( r c ) filya paint two rectangles side parallel coordinate ax cell lie fully inside fully outside moreover cell lie rectangles later hedgehog filya become interest location rectangles unable find sheet paper paint take sonya want play a little game filya tell a query rectangle reply number initial rectangles lie fully inside give query rectangle query rectangle match condition initial rectangles rectangle lie fully inside query o cells lie inside query filya know sonya really well sure ask 200 question stop reply first line input contain integer n ( 2 ≤ n ≤ 216 ) — size field query integer 0 2 return — number initial rectangles lie fully inside query rectangle make a query print ` ` ? x1 y1 x2 y2 '' ( without quote ) ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ n ) ( x1 y1 ) stand position bottom leave cell query ( x2 y2 ) stand right cell query allow ask 200 query query perform ` ` flush '' operation read answer case suppose ' ve already determine location two rectangles ( run query ) print ` ` ! <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> <unknown> '' ( without quote ) first four integers describe bottom leave right cells first rectangle follow four describe correspond cells second rectangle print rectangles arbitrary order print answer print end line perform ` ` flush '' program terminate immediately print answer flush use ( print integer end - of - line ) : get wrong answer verdict ask 200 query print incorrect coordinate get idleness limit exceed verdict n't print anything ( ) forget flush output ( <unknown> ) hack first line contain integer n ( 2 ≤ n ≤ 216 ) second line contain four integers x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ n ) — description first rectangle third line contain description second rectangle similar way,['constructive algorithms'],2200.0
788/D,program contest roma decide try <unknown> home country uzhlyandia a cartesian plane want walk along main straight line uzhlyandia know line a straight line parallel one ax ( i.e describe equation x = a y = a a integer call coordinate line ) roma lose map find coordinate line first uncle anton agree help use follow rule : uncle anton a hurry <unknown> ( <unknown> olympiad informatics ) answer 3·105 question problem roma n't know find coordinate line write a program play roma 's role find coordinate input initially program make query get information guarantee number horizontal vertical line least 1 less equal 104 type make a query print a line ` ` 0 x y '' ( -108 ≤ x y ≤ 108 ) x y coordinate point query need print end - of - line make ` ` flush '' operation read answer query — minimum among distance <unknown> point main straight line uzhlyandia 3·105 query ready print answer print three line : print coordinate arbitrary order make ` ` flush '' use ( print a query / answer end - of - line ) : get wrong answer make query allow make invalid query get idleness limit exceed n't print anything forget flush output moment program read -1 answer immediately exit normally ( example call exit ( 0 ) ) get wrong answer case mean make query allow make invalid query ignore get verdicts since program continue read a close stream make test <unknown> first line contain two integers n m ( 1 ≤ n m ≤ 104 ) second line contain n distinct integers xi ( -108 ≤ xi ≤ 108 ) — coordinate vertical line third line contain m distinct integers yi ( -108 ≤ yi ≤ 108 ) — coordinate horizontal line write coordinate arbitrary order see example case note example test minimum distance :,['constructive algorithms'],3000.0
835/E,pay attention : problem interactive penguin <unknown> come a new game recently n icicles number 1 n. <unknown> a temperature — integer 1 109 . exactly two icicles special : temperature y a temperature others x ≠ y. find special icicles choose a non - empty subset icicles ask penguin bitwise exclusive ( xor ) temperatures icicles subset note ca n't ask 19 question find special icicles first line contain three integers n x y ( 2 ≤ n ≤ 1000 1 ≤ x y ≤ 109 x ≠ y ) — number icicles temperature non - special icicles temperature special icicles give answer penguin print character ` ` ! '' ( without quote ) print two integers p1 p2 ( p1 < p2 ) — index special icicles ascend order note ` ` ! '' p1 separate a space ; index separate a space give answer program terminate immediately ask a question print character ` ` ? '' ( without quote ) integer c ( 1 ≤ c ≤ n ) c distinct integers p1 p2 ... pc ( 1 ≤ pi ≤ n ) — index icicles want know note ` ` ? '' c separate a space ; index separate a space ask question read a single integer — answer note ca n't ask 19 question ask 19 question least one incorrect question solution get ` ` wrong answer '' moment program read - 1 answer immediately exit ( example call exit ( 0 ) ) get ` ` wrong answer '' case mean ask 19 question ask invalid question ignore get verdicts since program continue read a close stream solution get ` ` idleness limit exceed '' n't print anything forget flush output include final answer flush use ( print ) : hackingfor hack use follow format : n x y p1 <unknown> 1 ≤ p1 < p2 ≤ n index special icicles contestant program able see input answer first question answer second third question 1 therefore special icicles index 1 3 . read bitwise xor operation : https : //en.wikipedia.org / wiki / bitwise_operation # xor,['constructive algorithms'],2400.0
1023/E,"interactive problem bob live a square grid size $$$ n \times n $$$ row number $$$ 1 $$$ $$$ n $$$ top bottom columns number $$$ 1 $$$ $$$ n $$$ leave right every cell either allow block n't know exact description grid give integer $$$ n $$$ bob move allow cells limit directions bob allow cell grid move right adjacent cell allow ask $$$ 4 \cdot n $$$ query form ` ` ? $$$ r_1 $$$ $$$ c_1 $$$ $$$ r_2 $$$ $$$ c_2 $$$ ` ` ( $$$ 1 \le r_1 \le r_2 \le n $$$ $$$ 1 \le c_1 \le c_2 \le n $$$ ) answer ` ` yes '' bob get a cell $$$ ( r_1 c_1 ) $$$ a cell $$$ ( r_2 c_2 ) $$$ ` ` '' otherwise particular one two cells ( ) a block cell answer ` ` '' sure since bob n't like short trip ask query manhattan distance two cells least $$$ n - 1 $$$ i.e follow condition must satisfy : $$$ ( r_2 - r_1 ) + ( c_2 - c_1 ) \ge n - 1 $$$ 's guarantee bob get top - left corner $$$ ( 1 1 ) $$$ bottom - right corner $$$ ( n n ) $$$ task find a way print answer form ` ` ! s '' $$$ s $$$ a string length $$$ 2 \cdot n - 2 $$$ consist character 'd ' ' r ' denote move right respectively move increase first coordinate $$$ 1 $$$ right move increase second coordinate $$$ 1 $$$ multiple solutions accept terminate immediately print solution line input contain integer $$$ n $$$ ( $$$ 2 \le n \le 500 $$$ ) — size grid ready print answer print a single line contain ` ` ! s '' $$$ s $$$ a string length $$$ 2 \cdot n - 2 $$$ consist character 'd ' ' r ' denote move right respectively path a valid path go cell $$$ ( 1 1 ) $$$ cell $$$ ( n n ) $$$ pass allow cells ask $$$ 4 \cdot n $$$ query ask a query print a line contain ` ` ? $$$ r_1 $$$ $$$ c_1 $$$ $$$ r_2 $$$ $$$ c_2 $$$ ` ` ( $$$ 1 \le r_1 \le r_2 \le n $$$ $$$ 1 \le c_1 \le c_2 \le n $$$ ) read a single line contain ` ` yes '' ` ` '' depend answer query ` ` yes '' mean bob go cell $$$ ( r_1 c_1 ) $$$ cell $$$ ( r_2 c_2 ) $$$ ` ` '' mean opposite note grid fix start solution depend query print a query forget output end line flush output otherwise get idleness limit exceed negative verdict , use : answer ` ` bad '' instead ` ` yes '' ` ` '' mean make invalid query exit immediately receive ` ` bad '' see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream first example show picture hack use follow input format : first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 500 $$$ ) — size grid next $$$ n $$$ line contain a string $$$ n $$$ character ' # ' ' ' ' # ' denote a block cell ' . ' denote allow cell example follow text encode example show :",['constructive algorithms'],2100.0
1100/D,"interactive task dasha nn like play chess play a match decide normal chess n't interest enough invent a game describe $$$ 666 $$$ black rook $$$ 1 $$$ white king chess board size $$$ 999 \times 999 $$$ white king win get check rook , word move onto square share either a row column a black rook side take turn start white nn play a white king turn move a king one square adjacent current position either side diagonally , formally king square $$$ ( x y ) $$$ move square $$$ ( nx ny ) $$$ $$$ \max ( <unknown> - x| <unknown> - <unknown> ) = 1 $$$ $$$ 1 \leq nx ny \leq 999 $$$ nn also forbid move onto square occupy black rook however move onto row column a black rook dasha however neglect play chess rule instead move rook normally move one rook space <unknown> chess piece also possible rook would move onto square position would n't change however ca n't move rook row column king player make $$$ 2000 $$$ turn white king n't check a black rook turn black win nn n't like lose think task difficult ask write a program always win play white king note dasha see king play depend position begin program receive $$$ <unknown> $$$ line input line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq x y \leq 999 $$$ ) — piece 's coordinate first line contain coordinate king next $$$ 666 $$$ contain coordinate rook first coordinate denote number row piece locate second denote column guarantee initially king n't check piece occupy different square get king check program terminate immediately without print anything extra make a move king output two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq x y \leq 999 $$$ ) — square king would move king move onto square already occupy a rook guarantee king would always a valid move turn read rook 's turn follow format : a single line contain three integers $$$ k $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \leq k \leq 666 $$$ $$$ 1 \leq x_i y_i \leq 999 $$$ ) — number rook would move square would move guarantee rook would n't move a square already occupy another chess piece move onto square turn position would n't change guarantee move put king a check king get check three integers would equal $$$ -1 $$$ case program terminate immediately print turn forget output end line flush output otherwise get idleness limit exceed , use : answer ` ` 0 0 0 '' instead a correct answer mean make invalid query exit immediately receive ` ` 0 0 0 '' see wrong answer verdict otherwise get arbitrary verdict solution continue read a close stream hack allow problem example <unknown> full initial position rook first test available https : <unknown> / <unknown> guarantee behave example",['constructive algorithms'],2500.0
1103/B,"interactive problem vasya petya go play follow game : petya positive integer number $$$ a $$$ vasya guess number use follow question say a pair non - negative integer number $$$ ( x y ) $$$ petya answer : define $$$ ( x \bmod a ) $$$ a remainder division $$$ x $$$ $$$ a $$$ vasya guess number $$$ a $$$ use 60 question 's guarantee petya a number satisfy inequality $$$ 1 \leq a \leq 1000000000 $$$ help vasya play game write a program guess number $$$ a $$$ program play several game start game program read string : read string ` ` start '' ( without quote ) new game start begin program ask several question pair non - negative integer number $$$ ( x y ) $$$ ask number satisfy inequalities $$$ 0 \leq x y \leq 2000000000 $$$ ask a question print ` ` ? x y '' ( without quote ) answer read one symbol : program ask several question program print answer form ` ` ! a '' ( without quote ) print number $$$ a $$$ satisfy inequalities $$$ 1 \leq a \leq 1000000000 $$$ 's guarantee petya 's number $$$ a $$$ satisfy condition , current game finish recall program ca n't ask $$$ 60 $$$ question one game program n't terminate read ` ` mistake '' ( without quote ) ` ` end '' ( without quote ) ` ` e '' ( without quote ) get verdict continue read close input also program print answer question incorrect format get verdict , careful n't forget flush output print question answer flush output use : 's guarantee play least $$$ 1 $$$ $$$ 100 $$$ game hack : hack use one game hack a solution petya 's number $$$ a $$$ ( $$$ 1 \leq a \leq 1000000000 $$$ ) first line write a single number $$$ 1 $$$ second line write a single number $$$ a $$$ first test play $$$ 3 $$$ game petya 's number $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ first game petya answer ` ` x '' ( without quote ) question $$$ ( x \bmod 1 ) = 0 $$$ integer $$$ x $$$ second game ask pair $$$ ( 0 0 ) $$$ answer ` ` x '' ( without quote ) $$$ ( 0 \bmod 2 ) \geq ( 0 \bmod 2 ) $$$ ask pair $$$ ( 2 5 ) $$$ answer ` ` y '' ( without quote ) $$$ ( 2 \bmod 2 ) < ( 5 \bmod 2 ) $$$ $$$ ( 2 \bmod 2 ) = 0 $$$ $$$ ( 5 \bmod 2 ) = 1 $$$",['constructive algorithms'],2000.0
730/B,"interactive problem use flush operation right print line example c++ use function fflush ( stdout ) java — system.out.flush ( ) pascal — flush ( output ) python — sys.stdout.flush ( ) problem need find maximal minimal elements array could <unknown> ? imagine jury array initially know number n — array 's length array 's elements number 1 n. allow compare two elements array use indices i j. three possible responses query : ' < ' ( ai less aj ) ' = ' ( ai equal aj ) finally ' > ' ( ai greater aj ) 's know 's always possible find maximal minimal elements array use comparisons <unknown> <unknown> result round x write program find position minimum maximum jury 's array length n use f ( n ) comparisons test problem contain one array find position minimal maximal elements array first line input contain integer t ( 1 ≤ t ≤ 1000 ) — number array test thus begin program read number t solve problem t jury 's array one one input array go firstly program read number n ( 1 ≤ n ≤ 50 ) — length array provide next line input , program perform comparisons report answer find several possible responses a comparison : array length n program make comparisons note operation report answer ( « ! i j » ) include value f ( n ) answer report program solve problem next array terminate t array process",['constructive algorithms'],1800.0
1578/M,interactive problem problem need come a strategy a cooperative game game play two players player receive 5 card card a random integer 1 100 guarantee number card distinct goal game play a card a minimal number 10 card deal players card problem player see card communicate another player way game consist 5 turn turn players simultaneously make a move player either play smallest card nothing turn smallest card play card play turn players win two card play turn 5 turn card still play players lose players communicate a strategy game base 5 card player describe a strategy five number $$$ 0.0 \le p_i \le 1.0 \sum _ { i=1 } ^ { 5 } p_i \le 1 $$$ $$$ p_i $$$ — probability play player 's smallest card hand $$$ i $$$ -th turn know card deal players strategies players choose compute probability win a simple formula give $$$ <unknown> $$$ randomly generate hand 5 card need generate a strategy hand maximize probability win judge program receive $$$ n $$$ strategies generate possible valid pair hand ( pair number discard ) compute a probability win base two strategies provide program ensure answer different hand independent must output a strategy a hand flush standard output read information next hand average probability win a game <unknown> % valid pair hand test consider pass problem contain sample test $$$ 20 $$$ randomly generate test $$$ n = 1000 $$$ first line contain one integer $$$ n $$$ — number hand guarantee $$$ n = 1000 $$$ case except first sample case next $$$ n $$$ line contain 5 number $$$ a_i $$$ ( $$$ 1 \le a_i \le 100 a_i < a _ { i+1 } $$$ ) — card hand guarantee possible set 5 card equal probability choose $$$ n $$$ hand need output 5 number $$$ 0.0 \le p_i \le 1.0 \sum _ { i=1 } ^ { 5 } p_i \le 1 $$$ $$$ p_i $$$ — probability play smallest card $$$ i $$$ -th turn example test one valid pair hand win probability example output equal $$$ <unknown> + 0.2 \cdot ( 1 - 0.2 ) = <unknown> $$$ also note second player play a card probability <unknown>,['constructive algorithms'],2700.0
1534/D,"interactive problem little dormi face awkward problem <unknown> : guess edge unweighted tree $$$ n $$$ nod ! nod tree number $$$ 1 $$$ $$$ n $$$ game master allow ask one type question : additionally make game unfair challenge little dormi game master allow $$$ \lceil\frac { n } { 2 } \rceil $$$ question $$$ \lceil x \rceil $$$ denote smallest integer greater equal $$$ x $$$ face <unknown> - <unknown> possibility able guess tree little dormi need help devise a win strategy ! note game master create tree game start change game first line input contain integer $$$ n $$$ ( $$$ 2 \le n \le 2\,000 $$$ ) number nod tree begin interaction program find tree first output a line consist a single ` ` ! '' follow $$$ n-1 $$$ line two space separate integers $$$ a $$$ $$$ b $$$ denote edge connect nod $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le n $$$ ) do terminate program normally immediately flush output stream may output edge order edge $$$ ( a b ) $$$ consider edge $$$ ( b a ) $$$ answer consider a query take input may make $$$ \lceil\frac { n } { 2 } \rceil $$$ query query make format ` ` ? r '' $$$ r $$$ integer $$$ 1 \le r \le n $$$ denote node want pick query receive $$$ n $$$ space separate integers $$$ d_1 d_2 \ldots d_n $$$ $$$ d_i $$$ length shortest path node $$$ r $$$ $$$ i $$$ follow a newline print a query forget output end line flush output otherwise get idleness limit exceed , use : point make invalid query try make $$$ \lceil \frac { n } { 2 } \rceil $$$ query interaction terminate immediately receive a wrong answer verdict hacksto hack a solution use follow format first line contain integer $$$ n $$$ ( $$$ 2 \le n \le 2\,000 $$$ ) next $$$ <unknown> $$$ line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ ) denote edge $$$ u $$$ $$$ v $$$ ( $$$ u \neq v $$$ ) $$$ n-1 $$$ edge must form a tree tree first example notice edge output order additionally answer query every single node example $$$ 1 $$$ : tree second example interaction lastly answer query every single node example $$$ 2 $$$ :",['constructive algorithms'],1800.0
512/E,fox ciel design a puzzle game call ` ` polygon '' ! play use triangulations a regular n - edge polygon goal transform one triangulation another <unknown> rule triangulation n - edge <unknown> a set n - 3 diagonals satisfy condition two diagonals share a common internal point example initial state game may look like ( a ) figure goal may look like ( c ) step choose a diagonal inside polygon ( one edge polygon ) flip diagonal suppose go flip a diagonal a – b. always exist two triangles share a – b a side let 's denote a – b – c a – b – d. a result operation diagonal a – b replace a diagonal c – d. easily prove flip operation result set diagonals still a triangulation polygon order solve case may first flip diagonal 6 – 3 replace diagonal 2 – 4 . flip diagonal 6 – 4 get figure ( c ) result ciel prove start destination triangulations game a solution want solve 20 000 step puzzle satisfy n ≤ 1000 . first line contain integer n ( 4 ≤ n ≤ 1000 ) number edge regular polygon follow two group ( n - 3 ) line describe original triangulation goal triangulation description triangulation consist ( n - 3 ) line line contain 2 integers ai bi ( 1 ≤ ai bi ≤ n ) describe a diagonal ai – bi guarantee original goal triangulations correct ( i. e. two diagonals share a common internal point triangulations ) first output integer k ( 0 ≤ k ≤ 20 000 ) : number step output k line contain 2 integers ai bi : endpoints a diagonal go flip step i. may output ai bi order several possible solutions output sample test 2 discuss show picture,['constructive algorithms'],2900.0
1527/B2,"difference easy hard versions give string $$$ s $$$ easy version initially a palindrome condition always true hard version a palindrome a string read leave right right leave example ` ` 101101 '' a palindrome ` ` 0101 '' alice bob play a game a string $$$ s $$$ length $$$ n $$$ consist character ' 0 ' ' 1 ' players take alternate turn alice go first turn player perform one follow operations : reverse a string mean reorder letter last first example ` ` 01001 '' become ` ` 10010 '' reverse game end every character string become ' 1 ' player spend minimum dollars till point win game a draw spend equal dollars players play optimally output whether alice win bob win a draw first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) $$$ t $$$ test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) second line test case contain string $$$ s $$$ length $$$ n $$$ consist character ' 0 ' ' 1 ' guarantee string $$$ s $$$ contain least one ' 0 ' note limit sum $$$ n $$$ test case test case print a single word a new line : first test case example second test case example ,",['constructive algorithms'],1900.0
1451/F,"jeel ashish play a game $$$ n \times m $$$ matrix row number $$$ 1 $$$ $$$ n $$$ top bottom columns number $$$ 1 $$$ $$$ m $$$ leave right play turn turn ashish go first initially cell matrix contain a non - negative integer turn a player must perform follow action order start end cells per rule value cell decrease operations perform game end value become zero player unable make a move lose show game end a finite number move players play optimally give initial matrix players play optimally predict win ? first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 100 $$$ ) — dimension matrix next $$$ n $$$ line contain $$$ m $$$ space separate integers $$$ a _ { i j } $$$ ( $$$ 0 \leq a _ { i j } \leq 1000000 $$$ ) — value cell matrix test case ashish win game print ` ` ashish '' otherwise print ` ` jeel '' ( without quote ) first test case cell matrix 0 . move ashish make jeel winner second test case ashish choose $$$ ( r_1 c_1 ) = ( r_2 c_2 ) = ( 1,3 ) $$$ reduce cell $$$ 0 $$$ leave $$$ [ 0 0 0 ] $$$ jeel perform move ashish win",['constructive algorithms'],2700.0
97/B,a set point a plane call good two point least one three condition true : give a set consist n point a plane find good superset give set whose size would exceed 2·105 point first line contain integer n ( 1 ≤ n ≤ 104 ) — number point initial set next n line describe set 's point line contain two integers xi yi ( - 109 ≤ xi yi ≤ 109 ) — a correspond point 's coordinate guarantee point different print first line number point m ( n ≤ m ≤ 2·105 ) a good superset print next m line point absolute value point ' coordinate exceed 109 . note minimize m enough find good superset give set whose size exceed 2·105 point superset integer coordinate,['constructive algorithms'],2300.0
1841/A,alice bob play a game a blackboard ; initially $$$ n $$$ integers write integer equal $$$ 1 $$$ alice bob take turn ; alice go first turn player choose several ( least two ) equal integers board wipe write a new integer equal sum example board currently contain integers $$$ \ { 1 1 2 2 2 3\ } $$$ follow move possible : a player make a move ( integers board different ) player win game determine win players play optimally first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 99 $$$ ) — number test case test case consist one line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — number integers equal $$$ 1 $$$ board test case print alice alice win players play optimally otherwise print bob first test case $$$ n = 3 $$$ board initially contain integers $$$ \ { 1 1 1\ } $$$ show bob always win follow : two possible first move alice second test case $$$ n = 6 $$$ board initially contain integers $$$ \ { 1 1 1 1 1 1\ } $$$ alice win example choose two integers equal $$$ 1 $$$ wipe write $$$ 2 $$$ first turn board become $$$ \ { 1 1 1 1 2\ } $$$ three possible responses bob :,['constructive algorithms'],800.0
1408/F,give integer $$$ n $$$ find a list pair $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ ... $$$ ( x_q y_q ) $$$ ( $$$ 1 \leq x_i y_i \leq n $$$ ) satisfy follow condition let 's consider function $$$ f : \mathbb { n } \times \mathbb { n } \to \mathbb { n } $$$ ( define $$$ \mathbb { n } $$$ set positive integers ) word $$$ f $$$ a function return a positive integer a pair positive integers let 's make array $$$ a_1 a_2 \ldots a_n $$$ $$$ a_i = i $$$ initially perform $$$ q $$$ operations $$$ i $$$ -th : word need simultaneously change $$$ a _ { x_i } $$$ $$$ a _ { y_i } $$$ $$$ f ( a _ { x_i } a _ { y_i } ) $$$ note process $$$ f ( p q ) $$$ always a fix pair $$$ p $$$ $$$ q $$$ end two different number array $$$ a $$$ true function $$$ f $$$ find possible list pair number pair exceed $$$ 500000 $$$ single line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq <unknown> $$$ ) first line print $$$ q $$$ ( $$$ 0 \leq q \leq 500000 $$$ ) — number pair next $$$ q $$$ line print two integers $$$ i $$$ -th line print $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \leq x_i y_i \leq n $$$ ) condition describe statement satisfy exist multiple answer print first example perform operation array $$$ a $$$ $$$ [ f ( a_1 a_2 ) f ( a_1 a_2 ) a_3 ] $$$ always two different number second example perform two operations array $$$ a $$$ $$$ [ f ( a_1 a_2 ) f ( a_1 a_2 ) f ( a_3 a_4 ) f ( a_3 a_4 ) ] $$$ always two different number,['constructive algorithms'],2300.0
1375/H,"give a permutation $$$ a_1 a_2 \dots a_n $$$ number $$$ 1 $$$ $$$ n $$$ also $$$ n $$$ set $$$ s_1 s_2 \dots s_n $$$ $$$ <unknown> { <unknown> } $$$ lastly a variable $$$ cnt $$$ represent current number set initially $$$ cnt = n $$$ define two kinds function set : $$$ f ( s ) = \min\limits _ { u\in s } u $$$ ; $$$ g ( s ) = \max\limits _ { u\in s } u $$$ obtain a new set merge two set $$$ a $$$ $$$ b $$$ satisfy $$$ g ( a ) < f ( b ) $$$ ( notice old set disappear ) formally perform follow sequence operations : $$$ <unknown> <unknown> $$$ ; $$$ s _ { cnt } = <unknown> s_v $$$ free choose $$$ u $$$ $$$ v $$$ $$$ 1\le u v < cnt $$$ satisfy $$$ g ( s_u ) < f ( s_v ) $$$ require obtain specific set $$$ q $$$ requirements contain two integers $$$ l_i $$$ $$$ r_i $$$ mean must exist a set $$$ s _ { k_i } $$$ ( $$$ k_i $$$ i d set determine ) equal $$$ \ { <unknown> l_i\leq <unknown> <unknown> } $$$ , set consist $$$ a_i $$$ indices $$$ l_i $$$ $$$ r_i $$$ end must ensure $$$ <unknown> 2.2\times 1000000 $$$ note n't minimize $$$ cnt $$$ guarantee a solution give constraints exist first line contain two integers $$$ n q $$$ $$$ ( 1\leq n \leq 2^ { 12 } , 1 \leq q \leq 2^ { 16 } ) $$$ — length permutation number need set correspondently next line consist $$$ n $$$ integers $$$ a_1 a_2 \cdots a_n $$$ ( $$$ 1\leq <unknown> n $$$ $$$ a_i $$$ pairwise distinct ) — give permutation $$$ i $$$ -th next $$$ q $$$ line contain two integers $$$ l_i r_i $$$ $$$ ( 1\leq l_i\leq <unknown> n ) $$$ describe a requirement $$$ i $$$ -th set guarantee a solution give constraints exist first line contain one integer $$$ cnt_e $$$ $$$ ( n\leq <unknown> 2.2\times 1000000 ) $$$ represent number set operations $$$ cnt_e - n $$$ line must follow line contain two integers $$$ u $$$ $$$ v $$$ ( $$$ 1\leq u <unknown> cnt ' $$$ $$$ cnt ' $$$ value $$$ cnt $$$ operation ) mean choose $$$ s_u $$$ $$$ s_v $$$ perform a merge operation operation $$$ g ( s_u ) < f ( s_v ) $$$ must satisfy last line contain $$$ q $$$ integers $$$ k_1 k_2 \cdots <unknown> $$$ $$$ ( 1\leq k_i\leq cnt_e ) $$$ represent set $$$ s _ { k_i } $$$ $$$ i $$$ th require set please notice large amount output first sample : $$$ <unknown> { 1\ } <unknown> { 3\ } <unknown> { 2\ } $$$ initially first operation $$$ g ( s_3 ) = 2 < f ( s_2 ) =3 $$$ merge $$$ s_3 s_2 $$$ $$$ s_4=\ { 2,3\ } $$$ second operation $$$ g ( s_1 ) = 1 < f ( s_3 ) = 2 $$$ merge $$$ s_1 s_3 $$$ $$$ <unknown> { 1,2\ } $$$ third operation $$$ g ( s_5 ) = 2 < f ( s_2 ) =3 $$$ merge $$$ s_5 s_2 $$$ $$$ s_6=\ { 1,2,3\ } $$$ first requirement $$$ s_4=\ { 2,3\ } = \ { a_2 a_3\ } $$$ satisfy thus $$$ <unknown> $$$ second requirement $$$ s_6=\ { 1,2,3\ } = \ { a_1 a_2 a_3\ } $$$ satisfy thus $$$ <unknown> $$$ notice unused set identical set output set multiple time use set present initially allow",['constructive algorithms'],3300.0
873/D,"merge sort a well - known sort algorithm main function sort elements array a indices [ l r ) implement follow : array problem 0 - indexed sort whole array need call mergesort ( a 0 n ) number call function mergesort important ivan decide calculate sort array example a = { 1 2 3 4 } 1 call mergesort — mergesort ( 0 4 ) check array sort end a = { 2 1 3 } number call 3 : first call mergesort ( 0 3 ) set <unknown> = 1 call mergesort ( 0 1 ) mergesort ( 1 3 ) perform recursive call segment ( 0 1 ) ( 1 3 ) sort ivan implement program count number mergesort call need test , need find array a a a permutation size n ( number elements a n every integer number [ 1 n ] find array ) number mergesort call sort array exactly k. help ivan find array want ! first line contain two number n k ( 1 ≤ n ≤ 100000 1 ≤ k ≤ 200000 ) — size a desire permutation number mergesort call require sort a permutation size n exactly k call mergesort sort n't exist output - 1 . otherwise output n integer number a [ 0 ] a [ 1 ] ... a [ n - 1 ] — elements a permutation would meet require condition multiple answer print",['constructive algorithms'],1800.0
1250/M,"berland gardeners unite inc . hire project call ` ` smartgarden '' main feature project automatic garden water formally garden represent a square $$$ n \times n $$$ cells row number $$$ 1 $$$ $$$ n $$$ top bottom columns number $$$ 1 $$$ $$$ n $$$ leave right cell garden contain either a plant a slab 's know slabs locate main diagonal matrix represent garden cells main diagonal share a side least one cell main diagonal remain cells garden fill plant implementation project create a smart robot take a list command input process one one command contain : execute command robot water cells intersection specify row specify columns , specify $$$ r $$$ row $$$ c $$$ columns exactly $$$ r \cdot c $$$ cells water demo customer <unknown> robot a way water garden prepare a single command contain $$$ n $$$ row $$$ n $$$ columns unfortunately 5 hours demo customer turn <unknown> berland gardeners unite inc . go take part moreover probably stand a garden slab demo ! need create a list command robot water plant n't water cell contain a slab since 's a <unknown> version ` ` smartgarden '' total number command n't exceed $$$ 50 $$$ create a program a give size garden find a list $$$ 50 $$$ command allow robot water plant garden without water slabs allow water a plant several time first line input contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 5000 $$$ ) $$$ n $$$ size garden first line print total number command robot $$$ k $$$ ( $$$ 1 \le k \le 50 $$$ ) next $$$ 2 \cdot k $$$ line print command command specify $$$ 2 $$$ line first line command describe row command second line describe columns command $$$ 2 $$$ line follow format : multiple ways water garden print",['constructive algorithms'],2500.0
1336/D,"interactive problem yui a girl enjoy play <unknown> a mysterious set consist tile ( set empty ) tile integer value $$$ 1 $$$ $$$ n $$$ $$$ n $$$ tile set value set contain $$$ n^2 $$$ tile want figure value tile yui <unknown> prefer play a guess game let 's call a set consist three tile triplet value example $$$ \ { 2 \,2 <unknown> } $$$ a triplet $$$ \ { 2 \,3 \,3\ } $$$ let 's call a set consist three tile straight value consecutive integers example $$$ \ { 2 \,3 <unknown> } $$$ a straight $$$ \ { 1 \,3 <unknown> } $$$ first yui give number triplet subsets straight subsets initial set respectively , insert a tile integer value $$$ 1 $$$ $$$ n $$$ set $$$ n $$$ time every time insert a tile get number triplet subsets straight subsets current set well note two tile value treat different word set $$$ \ { 1 <unknown> \,2 \,2 \,3\ } $$$ find $$$ 4 $$$ subsets $$$ \ { 1 \,2 \,3\ } $$$ try guess number tile initial set value $$$ i $$$ integers $$$ i $$$ $$$ 1 $$$ $$$ n $$$ first line contain a single integer $$$ n $$$ ( $$$ 4 \le n \le 100 $$$ ) second line contain two integers represent number triplet subsets straight subsets initial set respectively ready answer print a single line form ` ` ! $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a_n $$$ ` ` ( $$$ 0 \le a_i \le n $$$ ) $$$ a_i $$$ equal number tile initial set value $$$ i $$$ insert a tile print a single line form ` ` + $$$ x $$$ ` ` ( $$$ 1 \le x \le n $$$ ) $$$ x $$$ value tile insert read two integers represent number triplet subsets straight subsets current set respectively print a line forget flush output otherwise get idleness limit exceed , use : get wrong answer insert $$$ n $$$ tile hacksto make a hack provide a test format : first line contain a single integer $$$ n $$$ ( $$$ 4 \le n \le 100 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le n $$$ ) — $$$ a_i $$$ equal number tile value $$$ i $$$ set first test initial set tile $$$ \ { 1 1 2 3 3 3 5 5\ } $$$ one triplet subset $$$ \ { 3 3 3\ } $$$ six straight subsets equal $$$ \ { 1 2 3\ } $$$ insert a tile value $$$ 1 $$$ set tile $$$ \ { 1 1 1 2 3 3 3 5 5\ } $$$ two triplet subsets $$$ \ { 1 1 1\ } $$$ $$$ \ { 3 3 3\ } $$$ nine straight subsets equal $$$ \ { 1 2 3\ } $$$",['constructive algorithms'],3200.0
317/E,"princess vlada enjoy <unknown> <unknown> walk forest one day — wonderful <unknown> day — walk princess find <unknown> shadow miss ! ` ` <unknown> ! ` ` — think start search shadow forest normally shadow lazy simply sleep princess <unknown> hot summer day get bore a <unknown> life decide play vlada forest character entertain may represent a set integer cells plane shadow princess move , leave right 1 . cells ( happen decent forest ) occupy tree shadow princess allow enter a cell occupy a tree unfortunately hard time forest tree grow ... first princess walk within cell ( vx vy ) shadow hide princess cell ( sx sy ) princess shadow tree locate different cells shadow play princess soon princess move 1 direction shadow simultaneously fly 1 direction possible ( cell fly occupy tree ) ; otherwise shadow n't move shadow <unknown> character interfere say shadow catch princess move locate cell vlada manage catch shadow ! ? first line input contain coordinate character vx vy sx sy number tree m ( 0 ≤ m ≤ 400 ) follow m line contain coordinate tree coordinate integers <unknown> 100 inclusive princess shadow tree locate different cells impossible princess catch shadow print ` ` -1 '' ( without quote ) otherwise print a sequence character ` ` l '' ` ` r '' ` ` d '' ` ` u '' correspond princess 's move follow able catch shadow turn ( l — move leave r — right u — d — ; axis x direct right y — ) number character ( number move ) must exceed 106 . princess 's move correct must lead cell a tree grow allow princess shadow occupy cell last turn picture sample give ( princess shadow tree color pink gray black correspondingly ; blue dot mark lattice center ) first case princess may make two leave step one step upwards one right step : follow case princess catch shadow : last sample princess may make two leave step one step ( order ) :",['constructive algorithms'],3100.0
1148/C,"give a permutation $$$ p $$$ integers $$$ 1 $$$ $$$ n $$$ $$$ n $$$ even number goal sort permutation , perform zero operations follow type : need minimize number operations however use $$$ 5 \cdot n $$$ operations one show always possible first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 300000 $$$ $$$ n $$$ even ) — length permutation second line contain $$$ n $$$ distinct integers $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) — give permutation first line print $$$ m $$$ ( $$$ 0 \le m \le 5 \cdot n $$$ ) — number swap perform follow $$$ m $$$ line contain integers $$$ a_i b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ $$$ |a_i - b_i| \ge \frac { n } { 2 } $$$ ) — indices swap correspond swap note need minimize number operations show answer always exist first example one swap elements position $$$ 1 $$$ $$$ 2 $$$ array become sort second example pay attention need minimize number swap third example swap elements position $$$ 1 $$$ $$$ 5 $$$ array become : $$$ [ 4 5 3 1 2 6 ] $$$ swap elements position $$$ 2 $$$ $$$ 5 $$$ array become $$$ [ 4 2 3 1 5 6 ] $$$ finally swap elements position $$$ 1 $$$ $$$ 4 $$$ array become sort : $$$ [ 1 2 3 4 5 6 ] $$$",['constructive algorithms'],1700.0
1136/C,nastya come informatics lesson teacher way a little bite famous give follow task two matrices $$$ a $$$ $$$ b $$$ give size $$$ n \times m $$$ nastya perform follow operation matrix $$$ a $$$ unlimited number time : nastya 's task check whether possible transform matrix $$$ a $$$ matrix $$$ b $$$ may require a lot operations ask answer question nastya a square submatrix matrix $$$ m $$$ a matrix consist elements come one row indeces $$$ x x+1 \dots <unknown> $$$ matrix $$$ m $$$ come one columns indeces $$$ y y+1 \dots <unknown> $$$ matrix $$$ m $$$ $$$ k $$$ size square submatrix word square submatrix set elements source matrix form a solid square ( i.e without hole ) first line contain two integers $$$ n $$$ $$$ m $$$ separate space ( $$$ 1 \leq n m \leq 500 $$$ ) — number row columns $$$ a $$$ $$$ b $$$ respectively next $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th number $$$ i $$$ -th line denote $$$ j $$$ -th element $$$ i $$$ -th row matrix $$$ a $$$ ( $$$ 1 \leq a _ { ij } \leq 10^ { 9 } $$$ ) next $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th number $$$ i $$$ -th line denote $$$ j $$$ -th element $$$ i $$$ -th row matrix $$$ b $$$ ( $$$ 1 \leq b _ { ij } \leq 10^ { 9 } $$$ ) print ` ` yes '' ( without quote ) possible transform $$$ a $$$ $$$ b $$$ ` ` '' ( without quote ) otherwise print letter case ( upper lower ) consider third example matrix $$$ a $$$ initially look follow $$$ $$$ \begin { bmatrix } 1 & 2 & <unknown> 4 & 5 & 6\\ 7 & 8 & 9 \end { bmatrix } $$$ $$$ choose whole matrix transpose submatrix become $$$ $$$ \begin { bmatrix } 1 & 4 & 7\\ 2 & 5 & <unknown> 3 & 6 & 9 \end { bmatrix } $$$ $$$ transpose submatrix corner cells $$$ ( 2 2 ) $$$ $$$ ( 3 3 ) $$$ $$$ $$$ \begin { bmatrix } 1 & 4 & 7\\ 2 & \textbf { 5 } & \textbf { 8 } \\ 3 & \textbf { 6 } & \textbf { 9 } \end { bmatrix } $$$ $$$ matrix become $$$ $$$ \begin { bmatrix } 1 & 4 & 7\\ 2 & 5 & 6\\ 3 & 8 & 9 \end { bmatrix } $$$ $$$ $$$ b $$$,['constructive algorithms'],1500.0
1144/C,two integer sequence exist initially — one strictly increase one — strictly decrease strictly increase sequence a sequence integers $$$ [ x_1 < x_2 < \dots < x_k ] $$$ strictly decrease sequence a sequence integers $$$ [ y_1 > y_2 > \dots > y_l ] $$$ note empty sequence sequence consist one element consider increase decrease merge one sequence $$$ a $$$ sequence $$$ a $$$ get shuffle example possible result sequence $$$ a $$$ increase sequence $$$ [ 1 3 4 ] $$$ a decrease sequence $$$ [ 10 4 2 ] $$$ sequence $$$ [ 1 2 3 4 4 10 ] $$$ $$$ [ 4 2 1 10 4 3 ] $$$ shuffle sequence $$$ a $$$ give input task find two suitable initial sequence one strictly increase one — strictly decrease note empty sequence sequence consist one element consider increase decrease a contradiction input impossible split give sequence $$$ a $$$ increase decrease sequence print ` ` '' first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number elements $$$ a $$$ second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 200000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ a contradiction input impossible split give sequence $$$ a $$$ increase decrease sequence print ` ` '' first line otherwise print ` ` yes '' first line two suitable sequence note empty sequence sequence consist one element consider increase decrease second line print $$$ n_i $$$ — number elements strictly increase sequence $$$ n_i $$$ zero case increase sequence empty third line print $$$ n_i $$$ integers $$$ inc_1 inc_2 \dots inc _ { n_i } $$$ increase order value ( $$$ inc_1 < inc_2 < \dots < inc _ { n_i } $$$ ) — strictly increase sequence keep line empty $$$ n_i = 0 $$$ ( print empty line ) fourth line print $$$ n_d $$$ — number elements strictly decrease sequence $$$ n_d $$$ zero case decrease sequence empty fifth line print $$$ n_d $$$ integers $$$ dec_1 dec_2 \dots dec _ { n_d } $$$ decrease order value ( $$$ dec_1 > dec_2 > \dots > dec _ { n_d } $$$ ) — strictly decrease sequence keep line empty $$$ n_d = 0 $$$ ( print empty line ) $$$ n_i + n_d $$$ equal $$$ n $$$ union print sequence a permutation give sequence ( case ` ` yes '' answer ),['constructive algorithms'],1000.0
1450/A,a string $$$ b $$$ a subsequence a string $$$ a $$$ $$$ b $$$ obtain $$$ a $$$ deletion several ( possibly zero ) character example ` ` xy '' a subsequence ` ` <unknown> '' ` ` xy '' ` ` <unknown> '' give a string $$$ a $$$ task reorder character $$$ a $$$ ` ` trygub '' a subsequence result string word find a string $$$ b $$$ a permutation symbols string $$$ a $$$ ` ` trygub '' a subsequence $$$ b $$$ a truly <unknown> proof string arrange contain ` ` trygub '' a subsequence problem statement short contain first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 100 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1\le n\le 200 $$$ ) — length $$$ a $$$ next line contain string $$$ a $$$ length $$$ n $$$ consist lowercase english letter test case output a string $$$ b $$$ length $$$ n $$$ a permutation character string $$$ a $$$ ` ` trygub '' a subsequence exist multiple possible string $$$ b $$$ print first test case ` ` <unknown> '' contain ` ` trygub '' a subsequence contain letter ` ` trygub '' correct order a subsequence second test case change order character need third test case ` ` <unknown> '' contain ` ` <unknown> '' a subsequence ` ` trygub '',['constructive algorithms'],800.0
1526/A,give array $$$ a $$$ $$$ 2n $$$ distinct integers want arrange elements array a circle element equal arithmetic mean $$$ 2 $$$ neighbour formally find array $$$ b $$$ : $$$ b $$$ a permutation $$$ a $$$ every $$$ i $$$ $$$ 1 $$$ $$$ 2n $$$ $$$ b_i \neq \frac { b _ { i-1 } + b _ { i+1 } } { 2 } $$$ $$$ b_0 = b _ { 2n } $$$ $$$ b _ { <unknown> } = b_1 $$$ prove constraints problem array $$$ b $$$ always exist first line input contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000 ) $$$ — number testcases description testcases follow first line testcase contain a single integer $$$ n $$$ $$$ ( 1 \leq n \leq 25 ) $$$ second line testcase contain $$$ 2n $$$ integers $$$ a_1 a_2 \ldots a _ { 2n } $$$ $$$ ( 1 \leq a_i \leq 1000000000 ) $$$ — elements array note limit sum $$$ n $$$ testcases testcase output $$$ 2n $$$ integers $$$ b_1 b_2 \ldots b _ { 2n } $$$ condition statement satisfy first testcase array $$$ [ 3 1 4 2 5 6 ] $$$ work 's a permutation $$$ [ 1 2 3 4 5 6 ] $$$ $$$ \frac { 3 + 4 } { 2 } \neq 1 $$$ $$$ \frac { 1 + 2 } { 2 } \neq 4 $$$ $$$ \frac { 4 + 5 } { 2 } \neq 2 $$$ $$$ \frac { 2 + 6 } { 2 } \neq 5 $$$ $$$ \frac { 5 + 3 } { 2 } \neq 6 $$$ $$$ \frac { 6 + 1 } { 2 } \neq 3 $$$,['constructive algorithms'],800.0
1312/B,give array $$$ a_1 a_2 \dots a_n $$$ array good pair index $$$ i < j $$$ condition $$$ j - a_j \ne i - a_i $$$ hold shuffle array become good ? shuffle array mean reorder elements arbitrarily ( leave initial order also option ) example $$$ a = [ 1 1 3 5 ] $$$ shuffle array $$$ [ 1 3 5 1 ] $$$ $$$ [ 3 5 1 1 ] $$$ $$$ [ 5 3 1 1 ] $$$ good shuffle array $$$ [ 3 1 5 1 ] $$$ $$$ [ 1 1 3 5 ] $$$ $$$ [ 1 1 5 3 ] $$$ n't 's guarantee 's always possible shuffle array meet condition first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — length array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100 $$$ ) test case print shuffle version array $$$ a $$$ good,['constructive algorithms'],1000.0
1339/B,array $$$ n $$$ number $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ rearrange number satisfy $$$ |a _ { 1 } - a _ { 2 } | \le |a _ { 2 } - a _ { 3 } | \le \ldots \le |a _ { n-1 } - a _ { n } | $$$ $$$ |x| $$$ denote absolute value $$$ x $$$ 's always possible find rearrangement note number $$$ a $$$ necessarily different word number $$$ a $$$ may answer independent $$$ t $$$ test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10^ { 4 } $$$ ) — number test case first line test case contain single integer $$$ n $$$ ( $$$ 3 \le n \le 10^ { 5 } $$$ ) — length array $$$ a $$$ guarantee sum value $$$ n $$$ test case input exceed $$$ 10^ { 5 } $$$ second line test case contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ ( $$$ <unknown> { 9 } \le a _ { i } \le 10^ { 9 } $$$ ) test case print rearrange version array $$$ a $$$ satisfy give condition multiple valid rearrangements print first test case give rearrangement $$$ |a _ { 1 } - a _ { 2 } | = 0 \le |a _ { 2 } - a _ { 3 } | = 1 \le |a _ { 3 } - a _ { 4 } | = 2 \le |a _ { 4 } - a _ { 5 } | = 2 \le |a _ { 5 } - a _ { 6 } | = 10 $$$ possible answer like ` ` 5 4 5 6 -2 8 '' second test case give rearrangement $$$ |a _ { 1 } - a _ { 2 } | = 1 \le |a _ { 2 } - a _ { 3 } | = 2 \le |a _ { 3 } - a _ { 4 } | = 4 $$$ possible answer like ` ` 2 4 8 1 '',['constructive algorithms'],1200.0
254/A,petya get 2n card card contain integer number card let 's index card consecutive integers 1 2n 'll denote number write a card number i ai order play one entertain game friends petya need split card pair pair equal number card help petya first line contain integer n ( 1 ≤ n ≤ 3·105 ) second line contain sequence 2n positive integers a1 a2 ... <unknown> ( 1 ≤ ai ≤ 5000 ) — number write card number line separate single space impossible divide card pair card pair number print a single line integer -1 . require partition exist print n pair integers a pair per line — indices card form pair separate number line space print pair number pair order multiple solutions print,['constructive algorithms'],1200.0
23/C,2n - 1 box apples oranges task choose n box contain less half apples less half oranges first input line contain one number t — amount test description test start a natural number n — amount box follow 2n - 1 line contain number ai oi — amount apples oranges i - th box ( 0 ≤ ai oi ≤ 109 ) sum n test input n't exceed 105 . input number integer test output two line first line output yes 's possible choose n box otherwise answer positive output second line n number — index choose box box number 1 input order otherwise leave second line empty separate number one space,['constructive algorithms'],2500.0
109/D,petya love lucky number know lucky number positive integers whose decimal representations contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 petya get array consist n number gift birthday want sort non - decreasing order however a usual sort bore perform 's petya invent follow limitation : one swap two number least one lucky task sort array accord specify limitation find possible sequence swap ( number operations sequence exceed 2n ) first line contain integer n ( 1 ≤ n ≤ 105 ) — number elements array second line contain n positive integers exceed 109 — array need sort non - decreasing order first line print number k ( 0 ≤ k ≤ 2n ) — number swap sort follow k line print one pair distinct number ( a pair per line ) — index elements swap number array number start 1 . impossible sort give sequence print single number -1 . several solutions output note n't minimize k. sort 2n swap accept,['constructive algorithms'],2000.0
659/B,"soon berland hold a school team program olympiad m berland regions a team two people invite participate olympiad qualify contest form team hold attend n berland students least two <unknown> participate m regions berland result participants qualify competition integer score 0 800 inclusive team region form two members qualify competition region none replace a schoolboy region include team receive a greater number point may a situation a team region form uniquely , one school team meet properties describe case region need <unknown> additional contest two team region consider different least one schoolboy include one team include team guarantee region least two <unknown> participate qualify contest task give result qualify competition identify team region announce region <unknown> require additional contest first line input contain two integers n m ( 2 ≤ n ≤ 100 000 1 ≤ m ≤ 10 000 n ≥ 2 m ) — number participants qualify contest number regions berland next n line contain description participants qualify contest follow format : <unknown> ( a string length 1 10 character consist large small english letter ) region number ( integer 1 m ) number point score participant ( integer 0 800 inclusive ) guarantee surnames participants distinct least two people participate m regions surnames differ letter case consider distinct print m line i - th line print team i - th region — surnames two team members arbitrary order a single character ` ` ? '' ( without quote ) need spend qualify contest region first sample region team uniquely determine second sample team region 2 uniquely determine team region 1 three team : ` ` petrov '' - '' sidorov '' ` ` ivanov '' - '' sidorov '' ` ` ivanov '' - '' petrov '' impossible determine a team uniquely",['constructive algorithms'],1300.0
768/A,` ` night gather watch begin shall end death i shall take <unknown> hold land father children i shall wear crown win <unknown> i shall live die post i sword <unknown> i <unknown> wall i <unknown> guard <unknown> men i <unknown> life honor night 's watch night nights come . '' — night 's watch <unknown> begin watch jon snow assign task support stewards time n stewards provide support steward strength jon snow like support a steward exist least one steward strength strictly less least one steward strength strictly greater find many stewards jon support ? first line consist a single integer n ( 1 ≤ n ≤ 105 ) — number stewards jon snow second line consist n space separate integers a1 a2 ... ( 0 ≤ ai ≤ 109 ) represent value assign stewards output a single integer represent number stewards jon fee first sample jon snow support steward strength 1 steward strength less 1 support steward strength 5 steward strength greater 5 . second sample jon snow support steward strength 2 stewards strength less 2 greater 2,['constructive algorithms'],900.0
798/D,mike always think <unknown> social inequality 's <unknown> sometimes even affect solve problems moment mike two sequence positive integers a = [ a1 a2 ... ] b = [ b1 b2 ... bn ] length n use ask people quite peculiar question test good spot inequality life want find ` ` unfair '' subset original sequence precise want select k number p = [ p1 p2 ... pk ] 1 ≤ pi ≤ n 1 ≤ i ≤ k elements p distinct sequence p represent indices elements 'll select sequence call a subset p ` ` unfair '' follow condition satisfy : 2 · ( ap1 + ... + <unknown> ) greater sum elements sequence a 2 · ( <unknown> + ... + <unknown> ) greater sum elements sequence b. also k smaller equal easy find sequence p allow select many elements ! mike guarantee a solution always exist give condition describe please help satisfy curiosity ! first line contain integer n ( 1 ≤ n ≤ 105 ) — number elements sequence second line n space - separated integers a1 ... ( 1 ≤ ai ≤ 109 ) — elements sequence a. third line also n space - separated integers b1 ... bn ( 1 ≤ bi ≤ 109 ) — elements sequence b. first line output integer k represent size find subset k less equal next line print k integers p1 p2 ... pk ( 1 ≤ pi ≤ n ) — elements sequence p. print number order want elements sequence p distinct,['constructive algorithms'],2400.0
430/A,iahub n't well prepare geometry problems hear year a lot geometry problems ioi selection camp scar iahub lock basement start think new problems kind one follow iahub want draw n distinct point m segment ox axis draw point either red blue draw good follow requirement meet : segment [ li ri ] consider red point belong ( ri point ) blue point belong ( bi point ) ; segment i satisfy inequality <unknown> - <unknown> ≤ 1 . iahub think point x belong segment [ l r ] inequality l ≤ x ≤ r hold iahub give coordinate point segment please help find good draw first line input contain two integers : n ( 1 ≤ n ≤ 100 ) m ( 1 ≤ m ≤ 100 ) next line contain n space - separated integers x1 x2 ... xn ( 0 ≤ xi ≤ 100 ) — coordinate point follow m line contain descriptions m segment line contain two integers li ri ( 0 ≤ li ≤ ri ≤ 100 ) — border i - th segment 's guarantee point distinct good draw a give test output a single integer -1 . otherwise output n integers integer must 0 1 . i - th number denote color i - th point ( 0 red 1 blue ) multiple good draw output,['constructive algorithms'],1600.0
1614/B,company ` ` divan 's sofas '' plan build $$$ n + 1 $$$ different build a coordinate line : let $$$ x_i $$$ coordinate $$$ i $$$ -th build get build $$$ i $$$ build $$$ j $$$ divan spend $$$ |x_i - <unknown> $$$ minutes $$$ |y| $$$ absolute value $$$ y $$$ build divan go build number $$$ 0 $$$ $$$ n $$$ businessman live build $$$ 0 $$$ new headquarter ` ` divan 's sofas '' first ten years construction divan visit $$$ i $$$ -th build $$$ a_i $$$ time time spend $$$ 2 \cdot <unknown> - x_i| $$$ minutes walk divan ask choose coordinate $$$ n + 1 $$$ build next ten years businessman spend little time walk possible test contain several test case first line contain one integer number $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line case contain integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number build ` ` divan 's sofas '' go build apart headquarter second line contain sequence $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000 $$$ ) $$$ a_i $$$ number visit $$$ i $$$ -th build guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ test case first line print number $$$ t $$$ — minimum time divan spend walk second line print sequence $$$ x_0 x_1 \ldots x_n $$$ $$$ n + 1 $$$ integers $$$ x_i $$$ ( $$$ -1000000 \le x_i \le 1000000 $$$ ) select coordinate $$$ i $$$ -th build show optimal answer exist coordinate exceed $$$ 1000000 $$$ multiple answer print let 's look first example divan visit first build $$$ a_1 = 1 $$$ time second $$$ a_2 = 2 $$$ time third $$$ a_3 = 3 $$$ time one optimal solution follow : total divan spend $$$ 4 + 4 + 6 = 14 $$$ minutes show impossible arrange build businessman spend less time among others $$$ x = [ 1 3 2 0 ] $$$ $$$ x = [ <unknown> -3 -6 -4 ] $$$ also correct answer first example,['constructive algorithms'],1000.0
1626/A,"give a string $$$ s $$$ consist lowercase latin letter every letter appear twice task rearrange letter string a way pair letter appear exactly twice distance letter pair allow add remove letter show answer always exist multiple answer print first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases testcase consist a non - empty string $$$ s $$$ consist lowercase latin letter every letter appear string twice length string n't exceed $$$ 52 $$$ testcase print a single string every letter appear number time appear string $$$ s $$$ pair letter appear exactly twice distance letter pair multiple answer print first testcase example letter appear exactly twice letter ' l ' rearrange letter arbitrarily since distance compare second testcase example letter appear exactly twice ' a ' ' b ' ' c ' initially letter ' a ' distance $$$ 6 $$$ apart letter ' b ' distance $$$ 4 $$$ apart letter ' c ' distance $$$ 2 $$$ apart , rearrange letter rearrangement letter ' a ' distance $$$ 2 $$$ apart letter ' b ' distance $$$ 2 $$$ apart letter ' c ' distance $$$ 2 $$$ apart , answer valid third testcase example letter appear exactly twice thus rearrangement valid include change string",['constructive algorithms'],800.0
989/C,` ` i ' ve '' mino <unknown> <unknown> ` ` 's <unknown> <unknown> ` ` ` ` like ? ` ` ` ` look kanno ' ve get <unknown> i ' ve get word a try shall ? '' four kinds flower wood amaranths begonias centaureas dianthuses wood represent a rectangular grid $$$ n $$$ row $$$ m $$$ columns cell grid exactly one type flower accord mino number connect components form kind flower $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ respectively two cells consider connect component a path exist move cells share common edge pass cells contain flower help kanno depict a grid flower $$$ n $$$ $$$ m $$$ arbitrarily choose constraints give show least one solution exist constraints problem note choose arbitrary $$$ n $$$ $$$ m $$$ constraints give input first line input contain four space - separated integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ d $$$ ( $$$ 1 \leq a b c d \leq 100 $$$ ) — require number connect components amaranths begonias centaureas dianthuses respectively first line output two space - separated integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 50 $$$ ) — number row number columns grid respectively output $$$ n $$$ line consist $$$ m $$$ consecutive english letter represent one row grid letter among ' a ' ' b ' ' c ' 'd ' represent amaranths begonias centaureas dianthuses respectively case multiple solutions print output letter either case ( upper lower ) first example cell amaranths begonias centaureas form a connect component dianthuses form one,['constructive algorithms'],1800.0
1003/E,give three integers $$$ n $$$ $$$ d $$$ $$$ k $$$ task construct undirected tree $$$ n $$$ vertices diameter $$$ d $$$ degree vertex $$$ k $$$ say impossible undirected tree a connect undirected graph $$$ n - 1 $$$ edge diameter a tree maximum length a simple path ( a path vertex appear ) pair vertices tree degree a vertex number edge incident vertex ( i.e a vertex $$$ u $$$ number edge $$$ ( u v ) $$$ belong tree $$$ v $$$ vertex a tree ) first line input contain three integers $$$ n $$$ $$$ d $$$ $$$ k $$$ ( $$$ 1 \le n d k \le 400000 $$$ ) tree satisfy condition print one word ` ` '' ( without quote ) otherwise first line print ` ` yes '' ( without quote ) print $$$ n - 1 $$$ line describe edge a tree satisfy condition vertices tree must number $$$ 1 $$$ $$$ n $$$ print edge vertices connect edge order multiple answer print <unknown>,['constructive algorithms'],2100.0
1019/C,"sergey turn five years old ! one year old parent give a number ; two years old parent give array integers third birthday receive a string four mother wake a <unknown> <unknown> wish a good boy give a root tree today celebrate birthday ! find a direct graph without loop a present parent since sergey a curious boy immediately come a thing decide find a set $$$ q $$$ vertices graph two vertices $$$ x y \in q $$$ connect edge possible reach vertex $$$ z \notin q $$$ vertex $$$ q $$$ two move a little think sergey able solve task solve ? a vertex $$$ y $$$ reachable a vertex $$$ x $$$ two move either a direct edge $$$ ( x y ) $$$ exist two direct edge $$$ ( x z ) $$$ $$$ ( z y ) $$$ vertex $$$ z $$$ first line input contain two positive integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 1\,000\,000 $$$ $$$ 1 \le m \le 1\,000\,000 $$$ ) — number vertices number edge direct graph follow $$$ m $$$ line describe a correspond edge one contain two integers $$$ a_i $$$ $$$ b_i $$$ ( $$$ 1 \le a_i b_i \le n $$$ $$$ a_i \ne b_i $$$ ) — begin end $$$ i $$$ -th edge graph may contain multiple edge pair vertices first print number $$$ k $$$ — number select vertices print $$$ k $$$ distinct integers — indices select vertices multiple answer exist output particular n't minimize number vertices set guarantee always least one valid set first sample vertices $$$ 1 3 4 5 $$$ connect vertex $$$ 2 $$$ reachable vertex $$$ 1 $$$ one edge second sample possible reach vertex $$$ 1 $$$ one move vertex $$$ 2 $$$ two move follow picture illustrate sample test answer",['constructive algorithms'],3000.0
1065/B,vasya get undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge graph n't contain self - loops multiple edge self - loop edge connect a vertex multiple edge a pair edge connect pair vertices since graph undirected pair edge $$$ ( 1 2 ) $$$ $$$ ( 2 1 ) $$$ consider multiple edge isolate vertex graph a vertex edge connect vertex vertex vasya want know minimum maximum possible number isolate vertices undirected graph consist $$$ n $$$ vertices $$$ m $$$ edge line contain two integers $$$ n $$$ $$$ <unknown> ( 1 \le n \le 100000 0 \le m \le \frac { n ( n - 1 ) } { 2 } ) $$$ guarantee exist a graph without self - loops multiple edge number vertices edge line print two number $$$ min $$$ $$$ max $$$ — minimum maximum number isolate vertices respectively first example possible construct a graph $$$ 0 $$$ isolate vertices : example contain edge $$$ ( 1 2 ) $$$ $$$ ( 3 4 ) $$$ get one isolate vertex may construct a graph edge $$$ ( 1 2 ) $$$ $$$ ( 1 3 ) $$$ second example graph always contain exactly one isolate vertex,['constructive algorithms'],1300.0
1242/E,"ujan finally clean house want decorate interior decide place a beautiful carpet would really tie guest room together interest carpet make polygonal patch side a patch either a side another ( different ) patch exterior side whole carpet word carpet represent a planar graph patch correspond a face graph face a simple polygon perimeter carpet number exterior side ujan consider a carpet beautiful consist $$$ f $$$ patch $$$ i $$$ -th patch exactly $$$ a_i $$$ side perimeter smallest possible find example a carpet ujan order ! first line input contain a single integer $$$ f $$$ ( $$$ 1 \leq f \leq 100000 $$$ ) number patch carpet next line contain $$$ f $$$ integers $$$ a_1 \ldots a_f $$$ ( $$$ 3 \leq a_i \leq 3\cdot 100000 $$$ ) number side patch total number side patch $$$ a_1 + \ldots + a_f $$$ exceed $$$ 3\cdot100000 $$$ output description carpet a graph first output a single integer $$$ n $$$ ( $$$ 3 \leq n \leq 300000 $$$ ) total number vertices graph ( vertices must number $$$ 1 $$$ $$$ n $$$ ) output $$$ f $$$ line contain description face $$$ i $$$ -th line describe $$$ i $$$ -th face contain $$$ a_i $$$ distinct integers $$$ v _ { i,1 } \ldots v _ { i a_i } $$$ ( $$$ 1 \leq v _ { i j } \leq n $$$ ) mean vertices $$$ v _ { i j } $$$ $$$ v _ { i ( j \bmod { a_i } ) +1 } $$$ connect edge $$$ 1 \leq j \leq a_i $$$ graph planar satisfy restrictions describe problem statement perimeter smallest possible double edge self - loops graph graph connect note a solution always exist ; multiple solutions output first sample two triangular face connect a single edge result minimum perimeter $$$ 4 $$$ figure show one possible configuration second sample minimum perimeter case $$$ 3 $$$",['constructive algorithms'],3200.0
923/F,n cities bob 's country connect roads pair cities connect public transport two compete transport company — boblines operate bus bobrail run train travel a b a passenger always first select mode transport ( either bus train ) <unknown> a journey every pair cities exactly two ways travel without visit city — one use bus rout second use train rout furthermore pair cities directly connect a bus route a train route obtain plan network unfortunately company use different name cities precisely bus company number cities use integers 1 n train company use integers n + 1 2n find one possible map two number scheme pair cities connect directly a bus route a train route note map map different cities different cities first line contain integer n ( 2 ≤ n ≤ 10000 ) number cities n - 1 line follow represent network plan boblines contain two integers u v ( 1 ≤ u v ≤ n ) mean a bus route cities u v. n - 1 line follow represent network plan bobrail contain two integers u v ( n + 1 ≤ u v ≤ 2n ) mean a train route cities u v. solution output a single line word ` ` '' a solution exist output two line first line word ` ` yes '' second line n integers p1 p2 ... pn ( n + 1 ≤ pi ≤ 2n ) — map two number scheme precisely i ≠ j pi ≠ pj every direct bus route ( i j ) direct train route ( pi pj ) multiple solutions may print first sample ( bus line red rail line blue ) :,['constructive algorithms'],3200.0
1068/C,ivan a <unknown> painter $$$ n $$$ dye different color also know exactly $$$ m $$$ pair color harmonize ivan also enjoy play chess $$$ 5000 $$$ rook want take $$$ k $$$ rook paint one $$$ n $$$ color place $$$ k $$$ rook a chessboard size $$$ 10^ { 9 } \times 10^ { 9 } $$$ let 's call set rook board connect rook get rook set move cells rook set assume rook jump rook word a rook go cell share vertical cell share horizontal ivan want arrangement rook follow properties : please help ivan find arrangement first line input contain $$$ 2 $$$ integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100 $$$ $$$ 0 \le m \le min ( 1000 \ \ \frac { n ( n-1 ) } { 2 } ) $$$ ) — number color number pair color harmonize next $$$ m $$$ line pair color harmonize list color number $$$ 1 $$$ $$$ n $$$ guarantee pair occur twice list print $$$ n $$$ block $$$ i $$$ -th describe rook $$$ i $$$ -th color first line block print one number $$$ a _ { i } $$$ ( $$$ 1 \le a _ { i } \le 5000 $$$ ) — number rook color $$$ i $$$ next $$$ a _ { i } $$$ line print two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x \ \ y \le 10^ { 9 } $$$ ) — coordinate next rook rook must different cells total number rook must exceed $$$ 5000 $$$ guarantee solution exist rook arrangements three examples ( red color $$$ 1 $$$ green color $$$ 2 $$$ blue color $$$ 3 $$$ ),['constructive algorithms'],1700.0
746/G,n cities berland a unique i d — integer 1 n capital one i d 1 . a serious problem berland roads — roads a decision build n - 1 roads exactly one simple path pair cities construction plan t integers a1 a2 ... state t equal distance capital distant city concern new roads ai equal number cities distance i capital distance two cities number roads one pass way one city another also decide among cities except capital exactly k cities exactly one road go cities dead - ends ca n't <unknown> <unknown> calculation cities capital take consideration regardless number roads task offer a plan road 's construction satisfy describe condition inform impossible first line contain three positive number n t k ( 2 ≤ n ≤ 2·105 1 ≤ t k < n ) — distance distant city capital number cities dead - ends ( capital number take consideration ) second line contain a sequence t integers a1 a2 ... ( 1 ≤ ai < n ) i - th number number cities distance i capital guarantee sum value ai equal n - 1 . impossible build roads satisfy condition print -1 . otherwise first line print one integer n — number cities berland next n - 1 line print two integers — ids cities connect a road road print exactly print roads cities connect a road order multiple answer print remember capital i d 1,['constructive algorithms'],2100.0
1517/G,"foot <unknown> mountain $$$ n $$$ tent carefully arrange provide <unknown> will experience joy approach nature <unknown> night bright <unknown> sky $$$ i $$$ -th tent locate point $$$ ( x_i y_i ) $$$ a weight $$$ w_i $$$ a tent important $$$ x_i $$$ $$$ y_i $$$ even need remove tent remain important tent $$$ ( x y ) $$$ exist $$$ 3 $$$ tent $$$ ( <unknown> <unknown> ) $$$ $$$ ( <unknown> <unknown> ) $$$ $$$ ( <unknown> <unknown> ) $$$ condition true : please maximize sum weight tent remove print maximum value first line contain a single integer $$$ n $$$ ( $$$ 1\leq n\leq 1\,000 $$$ ) represent number tent next $$$ n $$$ line contain three integers $$$ x_i $$$ $$$ y_i $$$ $$$ w_i $$$ ( $$$ <unknown> x_i y_i \leq 1000000000 $$$ $$$ 1\leq <unknown> 1000000000 $$$ ) represent coordinate $$$ i $$$ -th tent weight two tent locate point a single integer — maximum sum weight remain tent illustration second example black triangles indicate important tent example also indicate $$$ 8 $$$ forbid pattern",['constructive algorithms'],3300.0
819/E,order fly moon mister b need solve follow problem a complete <unknown> graph n vertices need cover several simple cycle length 3 4 edge exactly 2 cycle sure mister b solve problem soon fly moon ? line contain single integer n ( 3 ≤ n ≤ 300 ) answer print -1 . otherwise first line print k ( 1 ≤ k ≤ n2 ) — number cycle solution next k line print description one cycle follow format : first print integer m ( 3 ≤ m ≤ 4 ) — length cycle print m integers v1 v2 ... <unknown> ( 1 ≤ vi ≤ n ) — vertices cycle traverse order edge exactly two cycle,['constructive algorithms'],2800.0
1559/C,city mocha live call <unknown> $$$ n+1 $$$ villages $$$ <unknown> $$$ direct roads city two kinds roads : mocha plan go hike <unknown> weekend avoid trip bore plan go every village exactly start finish villages help draw a plan ? test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 20 $$$ ) — number test case test case consist two line first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 10000 $$$ ) — indicate number villages $$$ n+1 $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1 $$$ ) $$$ a_i=0 $$$ mean a road village $$$ i $$$ village $$$ n+1 $$$ $$$ <unknown> $$$ mean a road village $$$ n+1 $$$ village $$$ i $$$ guarantee sum $$$ n $$$ test case exceed $$$ 10000 $$$ test case print a line $$$ n+1 $$$ integers $$$ i $$$ -th number $$$ i $$$ -th village go answer n't exist print $$$ -1 $$$ multiple correct answer print one first test case city look like follow graph : possible answer $$$ ( 1 \to 4 \to 2 \to 3 ) $$$ $$$ ( 1 \to 2 \to 3 \to 4 ) $$$ second test case city look like follow graph : possible answer $$$ ( 4 \to 1 \to 2 \to 3 ) $$$ $$$ ( 1 \to 2 \to 3 \to 4 ) $$$ $$$ ( 3 \to 4 \to 1 \to 2 ) $$$ $$$ ( 2 \to 3 \to 4 \to 1 ) $$$,['constructive algorithms'],1200.0
1656/I,give undirected graph $$$ g $$$ say a neighbour order order list neighbour a vertex vertices $$$ g $$$ consider a give neighbour order $$$ g $$$ three vertices $$$ u $$$ $$$ v $$$ $$$ w $$$ $$$ v $$$ a neighbor $$$ u $$$ $$$ w $$$ write $$$ u < _ { v } w $$$ $$$ u $$$ come $$$ w $$$ $$$ v $$$ 's neighbor list a neighbour order say good simple cycle $$$ v_1 v_2 \ldots <unknown> $$$ graph one follow satisfy : give a graph $$$ g $$$ determine whether exist a good neighbour order construct one input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 300000 $$$ $$$ 1 \leq m \leq 300000 $$$ ) number vertices number edge graph next $$$ m $$$ line contain two integers $$$ u v $$$ ( $$$ 0 \leq u v < n $$$ ) denote edge connect vertices $$$ u $$$ $$$ v $$$ guarantee graph connect loop multiple edge vertices sum $$$ n $$$ sum $$$ m $$$ test case $$$ 300000 $$$ test case output one line yes a good neighbour order otherwise output one line print letter case ( upper lower ) answer yes additionally output $$$ n $$$ line describe a good neighbour order $$$ i $$$ -th line output neighbour vertex $$$ i $$$ order multiple good <unknown> order print,['constructive algorithms'],3500.0
1495/C,"many sunflowers garden sun garden sun a rectangular table $$$ n $$$ row $$$ m $$$ columns cells table <unknown> cells grow a sunflower unfortunately one night lightning stroke ( possibly zero ) cells sunflowers cells <unknown> <unknown> word cells strike lightning become empty magically two empty cells common point ( neither edge corner ) owner want remove ( possibly zero ) sunflowers reach follow two goals : walk empty cell another share a common edge could please give owner a solution meet requirements ? note allow plant sunflowers n't need minimize number sunflowers remove show answer always exist input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 10000 $$$ ) — number test case description test case follow first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 500 $$$ ) — number row columns next $$$ n $$$ line contain $$$ m $$$ character character either ' x ' ' ' represent empty cell a cell grow a sunflower respectively guarantee sum $$$ n \cdot m $$$ test case exceed $$$ 250\,000 $$$ test case print $$$ n $$$ line contain $$$ m $$$ character represent one row table character either ' x ' ' ' represent empty cell a cell a sunflower respectively multiple answer print show answer always exist let 's use $$$ ( x y ) $$$ describe cell $$$ x $$$ -th row $$$ y $$$ -th column follow picture white yellow blue cells stand cells grow a sunflower cells lightning stroke cells sunflower remove respectively first test case one possible solution remove sunflowers $$$ ( 1,2 ) $$$ $$$ ( 2,3 ) $$$ $$$ ( 3 , 2 ) $$$ another acceptable solution remove sunflowers $$$ ( 1,2 ) $$$ $$$ ( 2,2 ) $$$ $$$ ( 3,2 ) $$$ output consider wrong 2 simple paths pair cells ( a cycle ) example 2 simple paths $$$ ( 1,1 ) $$$ $$$ ( 3,3 ) $$$ output consider wrong ca n't walk $$$ ( 1,1 ) $$$ $$$ ( 3,3 ) $$$",['constructive algorithms'],2300.0
690/F2,heidi get tire <unknown> <unknown> hide tree life decide go back headquarter rest a little try course <unknown> tree take make a draw tree a piece paper second think make identical draw n total ( n number vertices tree life ) – know might happen ? indeed way back heidi <unknown> a group zombies manage <unknown> damage draw a peculiar way : i - th copy vertex number i remove along adjacent edge picture zombies also erase vertex number <unknown> remain n - 1 vertices arbitrarily use number 1 n ( fortunately vertex still a distinct number ) 's draw arbitrarily <unknown> / <unknown> heidi want recover tree life descriptions draw ( list edge ) first line input contain z ≤ 20 – number test case z descriptions single test case follow test case first line input contain number n ( 2 ≤ n ≤ 100 ) k ( k number draw ; k = n ) follow line descriptions k draw give description i - th draw a line contain mi – number edge draw follow mi line describe edge contain two space - separated integers – - number two vertices connect edge heidi 's draw possibly come a single tree output word otherwise output one line contain word yes n - 1 line describe tree heidi 's draw could come every edge output number vertices connect separate a single space many solutions print,['constructive algorithms'],2700.0
1713/B,"consider array $$$ a $$$ $$$ n $$$ positive integers may perform follow operation : let 's call $$$ f ( a ) $$$ minimum number operations need change array $$$ a $$$ array $$$ n $$$ zero determine permutations $$$ ^\dagger $$$ $$$ b $$$ $$$ a $$$ $$$ f ( a ) \leq f ( b ) $$$ true $$$ ^\dagger $$$ array $$$ b $$$ a permutation array $$$ a $$$ $$$ b $$$ consist elements $$$ a $$$ arbitrary order example $$$ [ <unknown> ] $$$ a permutation $$$ [ <unknown> ] $$$ $$$ [ <unknown> ] $$$ a permutation $$$ [ 1,2,3 ] $$$ first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — description array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print ` ` yes '' ( without quote ) permutations $$$ b $$$ $$$ a $$$ $$$ f ( a ) \leq f ( b ) $$$ true ` ` '' ( without quote ) otherwise output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first test case change elements $$$ 0 $$$ $$$ 5 $$$ operations show permutation $$$ [ 2 3 5 4 ] $$$ require less $$$ 5 $$$ operations change elements $$$ 0 $$$ third test case need $$$ 5 $$$ operations change elements $$$ 0 $$$ $$$ [ 2 3 3 1 ] $$$ need $$$ 3 $$$ operations",['constructive algorithms'],1000.0
1733/C,give array $$$ a $$$ $$$ n $$$ non - negative integers apply follow operation find sequence $$$ n $$$ operations make $$$ a $$$ non - decreasing prove always possible note minimize number operations array $$$ a_1 a_2 \ldots a_n $$$ non - decreasing $$$ a_1 \le a_2 \le \ldots \le a_n $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case test case consist two line first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) — array guarantee sum $$$ n $$$ test case n't exceed $$$ 100000 $$$ test case print one integer $$$ m $$$ ( $$$ 0 \le m \le n $$$ ) number operations first line print $$$ m $$$ line line must contain two integers $$$ l_i r_i $$$ indices choose $$$ i $$$ -th operation ( $$$ 1 \le l_i < r_i \le n $$$ ) multiple solutions print second test case $$$ a $$$ change like : first third test case $$$ a $$$ already non - decreasing,['constructive algorithms'],1300.0
1740/G,"pak chanek $$$ n \times m $$$ grid portals portal $$$ i $$$ -th row $$$ j $$$ -th column denote portal $$$ ( i j ) $$$ portals $$$ ( 1,1 ) $$$ $$$ ( n m ) $$$ north - west south - east corner grid respectively portal $$$ ( i j ) $$$ two settings : a laser enter face $$$ k $$$ portal $$$ ( i j ) $$$ speed $$$ x_\text { } $$$ leave portal go face $$$ ( <unknown> _ { i j } ) \bmod 4 $$$ speed $$$ x_\text { } = \max ( x_\text { } s _ { i j } ) $$$ portal also consume $$$ x_\text { } - x_\text { } $$$ units energy pak chanek bore today shoot $$$ 4 nm $$$ lasers initial speed $$$ 1 $$$ one face portal laser travel throughout grid portals move outside grid pass $$$ 10^ { 100 } $$$ portals end pak chanek think a portal good total energy consume portal modulo $$$ 2 $$$ equal type give strength settings portals find a way assign type settings portal number good portals <unknown> first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 1000 $$$ ) — number row columns grid $$$ i $$$ -th next $$$ n $$$ line contain $$$ m $$$ integers $$$ j $$$ -th integer $$$ s _ { i j } $$$ ( $$$ 1 \leq s _ { i j } \leq 1000000000 $$$ ) — strength portal $$$ ( i j ) $$$ print $$$ n $$$ line line contain a string length $$$ m $$$ consist character $$$ 0 $$$ $$$ 1 $$$ represent type settings $$$ j $$$ -th character $$$ i $$$ -th string type set portal $$$ ( i j ) $$$ multiple solutions output first example let 's consider laser pak chanek shoot face $$$ 1 $$$ portal $$$ ( 2 2 ) $$$ laser travel follow : illustration travel laser follow example consider portal $$$ ( 2 3 ) $$$ calculate total energy consume portal end $$$ 32 $$$ since $$$ 32 \bmod 2 = 0 $$$ $$$ t _ { 2,3 } = 0 $$$ a good portal",['constructive algorithms'],3100.0
1762/G,"give array $$$ a $$$ consist $$$ n $$$ positive integers find permutation $$$ p $$$ $$$ [ 1,2 \dots n ] $$$ : report permutation exist test contain multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100000 $$$ ) — number test case description test case follow first line test case contain a single integer $$$ n $$$ ( $$$ 3 \leq n \leq 300000 $$$ ) — length array $$$ a $$$ second line test case contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — represent array $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 300000 $$$ test case output ` ` '' permutation exist otherwise output ` ` yes '' first line print permutation $$$ p $$$ next line case multiple permutations print one output ` ` yes '' ` ` '' case ( example string ` ` yes '' ` ` yes '' ` ` yes '' ` ` yes '' recognize a positive response ) first test case $$$ p= [ 1,2,3 ] $$$ permutation $$$ [ 1,2,3 ] $$$ satisfy give constraints second test case $$$ [ <unknown> ] $$$ $$$ [ <unknown> ] $$$ permutations also acceptable third test case prove exist permutation $$$ [ 1,2,3 ] $$$ satisfy give constraints",['constructive algorithms'],3100.0
323/B,"problem build tournament graph consist n vertices , orient pair vertices ( v u ) ( v ≠ u ) exist a path vertex v vertex u consist two edge a direct graph without self - loops a tournament exactly one edge two distinct vertices ( one two possible directions ) first line contain integer n ( 3 ≤ n ≤ 1000 ) number graph 's vertices print -1 graph satisfy describe condition otherwise print n line n integers number separate space adjacency matrix a find tournament consider graph vertices number integers 1 n. av u = 0 edge v u av u = 1 one output graph a tournament follow <unknown> must satisfy :",['constructive algorithms'],2200.0
272/E,dima come horse land n horse live land horse horse land several enemies ( <unknown> a symmetric relationship ) horse land n't hostile number enemies horse 3 . right horse land go election campaign horse trust dima split two part horse want follow condition hold : a horse n't one enemy party help dima split horse party note one party turn empty first line contain two integers n m — number horse horse land number enemy pair next m line define enemy pair i - th line contain integers ai bi ( 1 ≤ ai bi ≤ n ; ai ≠ bi ) mean horse ai enemy horse bi consider horse index way 1 n. guarantee horse three enemies pair enemies occur input print a line consist n character : i - th character line must equal ` ` 0 '' horse number i need go first party otherwise character equal ` ` 1 '' n't a way divide horse require print -1,['constructive algorithms'],2200.0
1401/F,give array $$$ a $$$ length $$$ 2^n $$$ process $$$ q $$$ query query one follow $$$ 4 $$$ type : write a program quickly process give query first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 0 \le n \le 18 $$$ ; $$$ 1 \le q \le 100000 $$$ ) — length array $$$ a $$$ number query second line contain $$$ 2^n $$$ integers $$$ a_1 a_2 \ldots a _ { 2^n } $$$ ( $$$ 0 \le a_i \le 1000000000 $$$ ) next $$$ q $$$ line contain query — one per line query one $$$ 4 $$$ type : guarantee least one $$$ sum $$$ query print answer $$$ sum $$$ query first sample initially array $$$ a $$$ equal $$$ \ { <unknown> } $$$ process first query array $$$ a $$$ become $$$ \ { <unknown> } $$$ process second query array $$$ a_i $$$ become $$$ \ { <unknown> } $$$ therefore answer third query $$$ 9 + 7 + <unknown> $$$ second sample initially array $$$ a $$$ equal $$$ \ { <unknown> } $$$ happen next :,['data structures'],2400.0
1556/G,mention previously william really like play video game one favorite game player character a universe every planet designate a binary number $$$ 0 $$$ $$$ 2^n - 1 $$$ planet <unknown> allow player move planet $$$ i $$$ planet $$$ j $$$ binary representations $$$ i $$$ $$$ j $$$ differ exactly one bite william want test see handle process follow query game universe : first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 50 $$$ $$$ 1 \leq m \leq 50000 $$$ ) number bits binary representation planets ' <unknown> number query respectively next $$$ m $$$ line contain a query two type : block l r — query destruction planets number $$$ l $$$ $$$ r $$$ inclusively ( $$$ 0 \le l \le r < 2^n $$$ ) 's guarantee planet destroy <unknown> a b — query reachability planets $$$ a $$$ $$$ b $$$ ( $$$ 0 \le a b < 2^n $$$ ) 's guarantee planets $$$ a $$$ $$$ b $$$ n't destroy yet query type ask must output ` ` 1 '' a new line possible reach planet $$$ b $$$ planet $$$ a $$$ ` ` 0 '' otherwise ( without quotation mark ) first example test <unknown> follow way : response a query ask 0 7 positive next query block 3 6 graph look follow way ( destroy vertices highlight ) : response a query ask 0 7 negative since path vertex $$$ 0 $$$ vertex $$$ 7 $$$ must go one destroy vertices,['data structures'],3300.0
1439/E,"let 's consider a $$$ ( 1000000000 + 1 ) \times ( 1000000000 + 1 ) $$$ field row number integers $$$ 0 $$$ $$$ 1000000000 $$$ columns number integers $$$ 0 $$$ $$$ 1000000000 $$$ let 's define $$$ ( x y ) $$$ cell locate $$$ x $$$ -th row $$$ y $$$ -th column let 's call a cell $$$ ( x y ) $$$ good $$$ x \ & y = 0 $$$ $$$ \ & $$$ bitwise operation let 's build a graph vertices good cells field make edge pair adjacent side good cells prove graph a tree — connect graph without cycle let 's hang tree vertex $$$ ( 0 0 ) $$$ a root tree root $$$ ( 0 0 ) $$$ two players play game initially good cells black others white player turn choose a black good cell a subset ancestors ( possibly empty ) invert color ( white black vice versa ) player ca n't move ( good cells white ) lose prove game always finite initially cells white give $$$ m $$$ pair cells pair color cells a simple path black note invert color paint black sohrab mashtali go play game sohrab first player mashtali second mashtali want win decide cheat make follow operation multiple time game start : choose a cell invert color vertices path root tree <unknown> watch wonder : ` ` minimum number operations mashtali a win strategy ? ` ` find answer question initial paint tree prove least one possible way cheat always exist first line contain one integer $$$ m $$$ ( $$$ 1 \leq m \leq 100000 $$$ ) next $$$ m $$$ line contain four integers $$$ x _ { 1 } $$$ $$$ y _ { 1 } $$$ $$$ x _ { 2 } $$$ $$$ y _ { 2 } $$$ ( $$$ 0 \leq x_i y_i \leq 1000000000 $$$ $$$ x_i \ & y_i = 0 $$$ ) color cells path vertices $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ black print a single integer — minimum number cheat operations second player first test make one cheat operation root tree , second player win use a symmetric strategy second test make cheat operations cells $$$ ( 0 2 ) ( 0 0 ) ( 3 4 ) $$$ third test second player already win strategy n't need make cheat operations",['data structures'],3500.0
1214/G,"recently <unknown> come a fascinate conclusion find a chameleon mood consider chameleon body a rectangular table $$$ n \times m $$$ cell may green blue may change two color denote $$$ ( x y ) $$$ ( $$$ 1 \leq x \leq n $$$ $$$ 1 \leq y \leq m $$$ ) cell row $$$ x $$$ column $$$ y $$$ let us define a chameleon good mood certificate four cells corner subrectangle table color opposite cells among four similar time four cell color similar formally a group four cells $$$ ( x_1 y_1 ) $$$ $$$ ( x_1 y_2 ) $$$ $$$ ( x_2 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ $$$ 1 \leq x_1 < x_2 \leq n $$$ $$$ 1 \leq y_1 < y_2 \leq m $$$ color $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ coincide color $$$ ( x_1 y_2 ) $$$ $$$ ( x_2 y_1 ) $$$ coincide four cells share color find whenever four cells present chameleon good mood vice versa : four cells chameleon bad mood ask help scientists write a program determine mood chameleon let us consider initially cells chameleon green chameleon color may change several time one change color contiguous segment table row replace opposite formally color change define three integers $$$ a $$$ $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq a \leq n $$$ $$$ 1 \leq l \leq r \leq m $$$ ) change color cells $$$ ( a b ) $$$ $$$ l \leq b \leq r $$$ replace opposite write a program report mood chameleon change additionally chameleon mood good program find four number $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ four cells $$$ ( x_1 y_1 ) $$$ $$$ ( x_1 y_2 ) $$$ $$$ ( x_2 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ good mood certificate first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \leq n m \leq 2000 $$$ $$$ 1 \leq q \leq 500\,000 $$$ ) size table number change respectively follow $$$ q $$$ line contain 3 integers $$$ a_i $$$ $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \leq a_i \leq n $$$ $$$ 1 \leq l_i \leq r_i \leq m $$$ ) describe $$$ i $$$ -th color change print $$$ q $$$ line $$$ i $$$ -th line report chameleon mood first $$$ i $$$ color change $$$ 1 \leq i \leq q $$$ chameleon bad mood print integer $$$ -1 $$$ otherwise print four integers $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \leq x_1 < x_2 \leq n $$$ $$$ 1 \leq y_1 < y_2 \leq m $$$ ) four cells $$$ ( x_1 y_1 ) $$$ $$$ ( x_1 y_2 ) $$$ $$$ ( x_2 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ good mood certificate several ways choose four integers print valid one",['data structures'],3200.0
1725/F,"pak chanek travel <unknown> turn osn ( <unknown> national scientific olympiad ) 2019 hold contestants osn 2019 currently line a field photograph field shape like a grid size $$$ n \times 10^ { 100 } $$$ $$$ n $$$ row $$$ 10^ { 100 } $$$ columns row number $$$ 1 $$$ $$$ n $$$ north south columns number $$$ 1 $$$ $$$ 10^ { 100 } $$$ west east tile row $$$ r $$$ column $$$ c $$$ denote $$$ ( r c ) $$$ $$$ n $$$ provinces participate osn 2019 . initially contestant represent province $$$ i $$$ stand tile $$$ ( i p ) $$$ $$$ p $$$ satisfy $$$ l_i \leq p \leq r_i $$$ , see $$$ r_i - <unknown> $$$ contestants represent province $$$ i $$$ pak chanek a variable $$$ z $$$ initially equal $$$ 0 $$$ one operation pak chanek choose a row $$$ i $$$ a positive integer $$$ k $$$ , pak chanek one two follow possibilities : operation value $$$ z $$$ change $$$ z \text { } k $$$ $$$ \text { } $$$ bitwise operation note pak chanek operations row also note pak chanek allow move contestants grid $$$ q $$$ question $$$ j $$$ -th question give a positive integer $$$ w_j $$$ pak chanek must zero operations final value $$$ z $$$ exactly $$$ w_j $$$ define $$$ m $$$ biggest number operations least one column contain exactly $$$ m $$$ contestants question must find biggest possible $$$ m $$$ sequence operations do pak chanek note operations do pak chanek one question carry question first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — number row grid also number provinces participate osn 2019 . $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \leq l_i \leq r_i \leq 1000000000 $$$ ) describe position contestants represent province $$$ i $$$ next line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 100000 $$$ ) — number question $$$ j $$$ -th next $$$ q $$$ line contain a single integer $$$ w_j $$$ ( $$$ 1 \leq w_j \leq 1000000000 $$$ ) — require final value $$$ z $$$ $$$ j $$$ -th question output $$$ q $$$ line $$$ j $$$ -th line contain integer answer $$$ j $$$ -th question $$$ 1 $$$ -st question pak chanek follow operations get $$$ m=2 $$$ : columns $$$ 14 $$$ $$$ 15 $$$ contain exactly $$$ 2 $$$ contestants $$$ 2 $$$ -nd question pak chanek follow operations get $$$ m=3 $$$ : column $$$ 11 $$$ contain exactly $$$ 3 $$$ contestants follow illustration example operations $$$ 2 $$$ -nd question",['data structures'],2100.0
242/E,"' ve get array a consist n integers a1 a2 ... , allow perform two operations array : expression mean apply bitwise xor operation number x y. give operation exist modern program languages example language c++ java mark ` ` ^ '' pascal — ` ` xor '' ' ve get a list m operations indicate type task perform give operations sum query print result get first line contain integer n ( 1 ≤ n ≤ 105 ) — size array second line contain space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 106 ) — original array third line contain integer m ( 1 ≤ m ≤ 5·104 ) — number operations array i - th follow m line first contain integer ti ( 1 ≤ ti ≤ 2 ) — type i - th query ti = 1 query sum ti = 2 query change array elements i - th operation type 1 next follow two integers li ri ( 1 ≤ li ≤ ri ≤ n ) i - th operation type 2 next follow three integers li ri xi ( 1 ≤ li ≤ ri ≤ n 1 ≤ xi ≤ 106 ) number line separate single space query type 1 print a single line sum number give segment print answer query order query go input please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier",['data structures'],2000.0
400/E,inna feed joke female logic start use binary logic instead inna array n elements a1 [ 1 ] a1 [ 2 ] ... a1 [ n ] girl like train binary logic exercise consist n stag : first stage inna write number array a1 i - th ( i ≥ 2 ) stage girl write elements array ai consist n - i + 1 integers ; k - th integer array ai define follow : ai [ k ] = ai - 1 [ k ] ai - 1 [ k + 1 ] bit - wise binary logical operation dima decide check inna 's skill ask inna change array perform exercise say sum elements write current exercise help inna answer question ! first line contain two integers n m ( 1 ≤ n m ≤ 105 ) — size array a1 number dima 's question next line contain n integers a1 [ 1 ] a1 [ 2 ] ... a1 [ n ] ( 0 ≤ ai ≤ 105 ) — initial array elements next m line contain two integers — dima 's question description question consist two integers pi vi ( 1 ≤ pi ≤ n ; 0 ≤ vi ≤ 105 ) question inna make a1 [ pi ] equal vi perform exercise please note change save question question question print inna 's answer a single line,['data structures'],2100.0
472/G,a simple way create hard task : take one simple problem query try find algorithm solve faster <unknown> kind task usually appear oi contest usually involve data structure let 's try create a task example take ` ` ham distance problem '' : two binary string s t length ham distance number position correspond symbols different example ham distance ` ` 00111 '' ` ` 10101 '' 2 ( different symbols mark bold ) use ham distance problem a query follow way : give two string a b several query query : ham distance two string <unknown> + 1 ... ap1 + len - 1 <unknown> + 1 ... <unknown> + len - 1 ? note problem string zero - based s = <unknown> ... s|s| - 1 . first line contain a string a ( 1 ≤ |a| ≤ 200000 ) second line contain a string b ( 1 ≤ |b| ≤ 200000 ) character string either ` ` 0 '' ` ` 1 '' third line contain integer q ( 1 ≤ q ≤ 400000 ) — number query follow q line contain three integers : p1 p2 len ( 0 ≤ p1 ≤ |a| - len ; 0 ≤ p2 ≤ |b| - len ) number denote parameters current query output q integers — answer query,['data structures'],2800.0
282/E,bitlandians quite weird people problems solutions <unknown> <unknown> value <unknown> dish sausages ! bitland a sausage array integers ! a sausage 's deliciousness equal bitwise exclude ( xor operation ) integers sausage one day mr . bitkoch ( local cook ) go close <unknown> bithaval bitaryo famous citizens bitland enter restaurant order a sausage mr . bitkoch one sausage leave decide cut a prefix ( several may zero first array elements ) sausage give bithaval a <unknown> ( several may zero last array elements ) sausage give bitaryo note one piece sausage empty course cut piece must n't intersect ( array element occur piece ) pleasure bithaval bitaryo equal bitwise xor sausages ' deliciousness empty sausage 's deliciousness equal zero find a way cut a piece sausage bithaval bitaryo maximize pleasure worthy citizens first line contain integer n ( 1 ≤ n ≤ 105 ) next line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 1012 ) — mr . bitkoch 's sausage please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print a single integer — maximum pleasure bithaval bitaryo get dinner,['data structures'],2200.0
1386/C,"joker return gotham city execute another evil plan gotham city $$$ n $$$ street junctions ( number $$$ 1 $$$ $$$ n $$$ ) $$$ m $$$ streets ( number $$$ 1 $$$ $$$ m $$$ ) street connect two distinct junctions two junctions connect one street evil plan joker need use odd number streets together form a cycle , a junction $$$ s $$$ even positive integer $$$ k $$$ a sequence junctions $$$ s s_1 \ldots s_k s $$$ streets connect ( a ) $$$ s $$$ $$$ s_1 $$$ ( b ) $$$ s_k $$$ $$$ s $$$ ( c ) $$$ s _ { i-1 } $$$ $$$ s_i $$$ $$$ i = 2 \ldots k $$$ however police control streets gotham city day $$$ i $$$ monitor a different subset streets consecutive number $$$ j $$$ : $$$ l_i \leq j \leq r_i $$$ monitor streets a part joker 's plan course unfortunately police joker spy within gotham city police department ; tell streets monitor day joker want find give number days whether execute evil plan a day must a cycle streets consist odd number streets monitor day first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \leq n m q \leq 200\,000 $$$ ) : number junctions number streets number days investigate follow $$$ m $$$ line describe streets $$$ j $$$ -th line ( $$$ 1 \le j \le m $$$ ) contain two junction number $$$ u $$$ $$$ v $$$ ( $$$ u \neq v $$$ ) say street $$$ j $$$ connect two junctions guarantee two junctions connect one street follow $$$ q $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ say streets $$$ j $$$ $$$ l_i \leq j \leq r_i $$$ check police day $$$ i $$$ ( $$$ 1 \leq i \leq q $$$ ) output contain $$$ q $$$ line line $$$ i $$$ ( $$$ 1 \leq i \leq q $$$ ) contain ` ` yes '' joker execute plan day $$$ i $$$ ` ` '' otherwise subtasks : graph example test :",['data structures'],2800.0
1093/G,give array $$$ a $$$ $$$ n $$$ point $$$ k $$$ <unknown> space let distance two point $$$ a_x $$$ $$$ a_y $$$ $$$ \sum \limits _ { i = 1 } ^ { k } |a _ { x i } - a _ { y i } | $$$ ( also know manhattan distance ) process $$$ q $$$ query follow two type : first line contain two number $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le k \le 5 $$$ ) — number elements $$$ a $$$ number dimension space respectively $$$ n $$$ line follow contain $$$ k $$$ integers $$$ a _ { i 1 } $$$ $$$ a _ { i 2 } $$$ ... $$$ a _ { i k } $$$ ( $$$ -1000000 \le a _ { i j } \le 1000000 $$$ ) — coordinate $$$ i $$$ -th point next line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query $$$ q $$$ line follow denote a query two type query : least one query second type print answer query second type,['data structures'],2300.0
877/E,danil decide earn money find a part - time job interview go well a light <unknown> danil work a root tree ( undirected connect acyclic graph ) n vertices vertex 1 root tree a room vertex light switch room danil 's duties include switch light room subtree vertex mean light switch room subtree switch otherwise switch unfortunately ( fortunately ) danil lazy know boss go personally check work instead send danil task use <unknown> personal message two type task : a subtree vertex v a set vertices shortest path root pass v. particular vertex v subtree v. danil go perform duties ask write a program answer boss instead first line contain a single integer n ( 1 ≤ n ≤ 200 000 ) — number vertices tree second line contain n - 1 space - separated integers p2 p3 ... pn ( 1 ≤ pi < i ) pi ancestor vertex i. third line contain n space - separated integers t1 t2 ... tn ( 0 ≤ ti ≤ 1 ) ti 1 light turn vertex i 0 otherwise fourth line contain a single integer q ( 1 ≤ q ≤ 200 000 ) — number task next q line get v pow v ( 1 ≤ v ≤ n ) — task describe task get v print number room subtree v light turn tree task pow 1,['data structures'],2000.0
914/E,give a tree ( a connect acyclic undirected graph ) n vertices vertices number 1 n vertex assign a character a t. a path tree say palindromic least one permutation label path a palindrome vertex output number palindromic paths pass note : path vertex u vertex v consider path vertex v vertex u path count vertices pass first line contain integer n ( 2 ≤ n ≤ 2·105 ) — number vertices tree next n - 1 line contain two integers u v ( 1 ≤ u v ≤ n u ≠ v ) denote edge connect vertex u vertex v. guarantee give graph a tree next line contain a string consist n lowercase character a t i - th ( 1 ≤ i ≤ n ) character label vertex i tree print n integers a single line i - th number palindromic paths pass vertex i tree first sample case follow paths <unknown> - 3 - 42 - 3 - 54 - 3 - <unknown> paths contain one vertex palindromic list a paths first sample <unknown> - 2 - 31 - 2 - 3 - <unknown> - 2 - 3 - 5,['data structures'],2400.0
875/D,<unknown> : lot <unknown> <unknown> russian version statement one reason learn russian : ) rick morty like go ridge high cry cry <unknown> — extraordinary <unknown> recently discover interest <unknown> <unknown> ridge : rick morty begin cry simultaneously different mountains cry would hear mountains height equal bitwise mountains ' ve climb mountains bitwise a binary operation determine follow way consider representation number x y binary numeric system ( probably lead zero ) x = xk ... <unknown> y = yk ... <unknown> z = x | y define follow way : z = <unknown> ... <unknown> zi = 1 xi = 1 yi = 1 zi = 0 otherwise word digit bitwise two number equal zero digits correspond position number equal zero example bitwise number 10 = 10102 9 = <unknown> equal 11 = <unknown> . program languages c / <unknown> / python operation define « | » pascal « » help rick morty calculate number ways select two mountains a way start cry mountains cry hear mountains mountains formally find number pair l r ( 1 ≤ l < r ≤ n ) bitwise heights mountains l r ( inclusive ) larger height mountain interval first line contain integer n ( 1 ≤ n ≤ 200 000 ) number mountains ridge second line contain n integers ai ( 0 ≤ ai ≤ 109 ) heights mountains order locate ridge print integer number ways choose two different mountains first test case ways pair mountains number ( number one ) : second test case pair pair mountains height cry 3 height equal height mountain,['data structures'],2200.0
938/G,give undirected connect graph weight edge length path two vertices bitwise xor weight edge belong path ( edge traverse include bitwise xor number time ) three type query process : print answer query type 3 . first line contain two number n m ( 1 ≤ n m ≤ 200000 ) — number vertices number edge graph respectively m line follow denote edge graph line contain three integers x y d ( 1 ≤ x < y ≤ n 0 ≤ d ≤ 230 - 1 ) pair ( x y ) list initial graph connect one line follow contain integer q ( 1 ≤ q ≤ 200000 ) — number query process q line follow denote query follow form : guarantee least one query type 3 . print answer query type 3 order appear input,['data structures'],2900.0
1004/F,sonya array $$$ a_1 a_2 \ldots a_n $$$ consist $$$ n $$$ integers also one non - negative integer $$$ x $$$ perform $$$ m $$$ query two type : help sonya perform query ? bitwise a binary operation a pair non - negative integers calculate bitwise two number need write number binary notation result a number binary contain a one digit a one binary notation least one two number example $$$ 10 $$$ $$$ 19 $$$ = $$$ 1010_2 $$$ $$$ <unknown> $$$ = $$$ <unknown> $$$ = $$$ 27 $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ x $$$ ( $$$ 1\leq n m\leq 100000 $$$ $$$ 0\leq x < 2^ { 20 } $$$ ) — number number number query constant query second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0\leq a_i < 2^ { 20 } $$$ ) — number array follow $$$ m $$$ line describe query a line one follow format : query type 2 print number subarrays bitwise number range least $$$ x $$$ first example array [ $$$ 0 $$$ $$$ 3 $$$ $$$ 6 $$$ $$$ 1 $$$ ] query : second example array [ $$$ 6 $$$ $$$ 0 $$$ $$$ 3 $$$ $$$ 15 $$$ $$$ 2 $$$ ] query :,['data structures'],2600.0
620/E,new year holiday <unknown> n't want throw away new year tree invite best friends <unknown> <unknown> help <unknown> new year tree new year tree undirected tree n vertices root vertex 1 . process query two type : first line contain two integers n m ( 1 ≤ n m ≤ 4·105 ) — number vertices tree number query second line contain n integers ci ( 1 ≤ ci ≤ 60 ) — colour i - th vertex next n - 1 line contain two integers xj yj ( 1 ≤ xj yj ≤ n ) — vertices j - th edge guarantee give correct undirected tree last m line contain description query description start integer tk ( 1 ≤ tk ≤ 2 ) — type k - th query query first type follow two integers vk ck ( 1 ≤ vk ≤ n 1 ≤ ck ≤ 60 ) — number vertex whose subtree <unknown> colour ck query second type follow integer vk ( 1 ≤ vk ≤ n ) — number vertex subtree find number different colour query second type print integer a — number different colour subtree vertex give query number print a separate line order query appear input,['data structures'],2100.0
706/D,"author go <unknown> vasiliy a formal task description give q query a multiset a initially contain integer 0 . three type query : multiset a set equal elements allow first line input contain a single integer q ( 1 ≤ q ≤ 200 000 ) — number query vasiliy perform follow q line input contain one three character ' + ' ' - ' ' ? ' integer xi ( 1 ≤ xi ≤ 109 ) 's guarantee least one query third type note integer 0 always present set a. query type ' ? ' print one integer — maximum value bitwise exclusive ( xor ) integer xi integer multiset a. first five operations multiset a contain integers 0 8 9 11 6 1 . answer sixth query integer — maximum among integers , ,",['data structures'],1800.0
817/E,"might remember previous round vova currently play a strategic game know <unknown> <unknown> vova manage build a large army forget main person army - commander try hire a commander want choose person respect warriors warrior represent personality — integer number pi commander two characteristics — personality pj leadership lj ( integer number ) warrior i respect commander j ( bitwise exclude x y ) initially vova 's army empty three different type events happen army : event third type vova want know many warriors ( count join army n't leave yet ) respect commander try hire first line contain one integer q ( 1 ≤ q ≤ 100000 ) — number events q line follow line describe event : event third type print one integer — number warriors respect commander vova try hire event example army consist two warriors <unknown> 3 4 first two events vova try hire a commander personality 6 leadership 3 one warrior respect ( 2 < 3 , 5 ≥ 3 ) warrior personality 4 leave vova try hire commander warriors respect",['data structures'],2000.0
786/B,rick co - workers make a new <unknown> formula a lot bad guy rick want give <unknown> morty bad guy catch n planets universe number 1 n. rick planet number s ( earth ) n't know morty know rick own a portal gun gun open one - way portal a planet planet ( include planet ) limit gun 's still use free <unknown> default open portal gun q plan website sell gun every time purchase a plan use purchase want use plan website three type : rick n't know morty <unknown> go inform want prepare find start journey immediately planet ( include earth ) want know minimum amount money need get earth planet first line input contain three integers n q s ( 1 ≤ n q ≤ 105 1 ≤ s ≤ n ) — number planets number plan index earth respectively next q line contain plan line start a number t type plan ( 1 ≤ t ≤ 3 ) t = 1 follow three integers v u w w cost plan ( 1 ≤ v u ≤ n 1 ≤ w ≤ 109 ) otherwise follow four integers v l r w w cost plan ( 1 ≤ v ≤ n 1 ≤ l ≤ r ≤ n 1 ≤ w ≤ 109 ) first line output print n integers separate space i - th minimum money get earth i - th planet - 1 's impossible get planet first sample testcase rick purchase 4th plan 2nd plan order get get planet number 2,['data structures'],2300.0
938/D,"<unknown> a popular band ` ` flayer '' announce go ` ` make exit '' a world tour course visit berland well n cities berland people travel cities use two - directional train rout ; exactly m rout i - th route use go city vi city ui ( ui vi ) cost wi coin use route city visit ` ` flayer '' cost concert ticket i - th city ai coin friends every city berland , know program skills ask calculate minimum possible number coin pay visit concert every city i compute minimum number coin a person city i spend travel city j ( possibly stay city i ) attend a concert return city i ( j ≠ i ) formally every calculate d ( i j ) minimum number coin spend travel city i city j. way reach city j city i consider d ( i j ) infinitely large first line contain two integers n m ( 2 ≤ n ≤ 2·105 1 ≤ m ≤ 2·105 ) m line follow i - th contain three integers vi ui wi ( 1 ≤ vi ui ≤ n vi ≠ ui 1 ≤ wi ≤ 1012 ) denote i - th train route multiple train rout connect pair cities , ( v u ) neither extra ( v u ) ( u v ) present input next line contain n integers a1 a2 ... ak ( 1 ≤ ai ≤ 1012 ) — price attend concert i - th city print n integers i - th must equal minimum number coin a person city i spend travel city j ( possibly stay city i ) attend a concert return city i ( j ≠ i )",['data structures'],2000.0
1163/F,"city capypaland kuro shiro reside $$$ n $$$ towns number $$$ 1 $$$ $$$ n $$$ $$$ m $$$ bidirectional roads number $$$ 1 $$$ $$$ m $$$ connect $$$ i $$$ -th road connect towns $$$ u_i $$$ $$$ v_i $$$ since travel towns quite difficult taxi <unknown> really popular survive harsh competition taxi company find a <unknown> trait customers kuro owner a taxi company decide introduce a new fee model taxi brand fee ride calculate base trip length sum price roads travel price $$$ m $$$ roads decide kuro , price road $$$ i $$$ $$$ w_i $$$ hence fee a taxi ride travel roads $$$ e_1 e_2 \ldots <unknown> $$$ $$$ \sum _ { i=1 } ^k w _ { e_i } $$$ however kuro <unknown> person draft $$$ q $$$ plan change road price plan base original price $$$ w_i $$$ except a single road $$$ t_j $$$ price change $$$ x_j $$$ note plan independent shiro a regular customer kuro 's taxi brand since use taxi travel town $$$ 1 $$$ town $$$ n $$$ every day since 's a regular customer kuro decide show $$$ q $$$ plan publish public , shiro want know lowest fee must pay travel town $$$ 1 $$$ town $$$ n $$$ kuro 's plan first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 2 \le n \le 200000 $$$ $$$ 1 \le m q \le 200000 $$$ ) — number towns number roads number plan kuro draft respectively $$$ i $$$ -th next $$$ m $$$ contain three integers $$$ u_i $$$ $$$ v_i $$$ $$$ w_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ 1 \le w_i \le 1000000000 $$$ $$$ u_i \ne v_i $$$ ) — two endpoints original price $$$ i $$$ -th road guarantee least one way travel town $$$ 1 $$$ town $$$ n $$$ use $$$ m $$$ bidirectional roads next $$$ q $$$ line contain two integers $$$ t_j $$$ $$$ x_j $$$ ( $$$ 1 \leq t_j \leq m 1 \leq x_j \leq 1000000000 $$$ ) — index road kuro plan change new price respectively print $$$ q $$$ integers — lowest fee shiro must pay get town $$$ 1 $$$ town $$$ n $$$ $$$ q $$$ plan first example original overview capypaland look like number next road denote original price roads overview first plan lowest fee shiro must pay plan $$$ 4 $$$ correspond path $$$ 1 \rightarrow 4 $$$ overview second plan lowest fee shiro must pay plan $$$ 2 $$$ correspond path $$$ 1 \rightarrow 3 \rightarrow 4 $$$ overview third plan lowest fee shiro must pay plan $$$ 5 $$$ correspond path $$$ 1 \rightarrow 2 \rightarrow 4 $$$",['data structures'],3000.0
763/D,"little timofey a big tree — undirected connect graph n vertices simple cycle like walk along tree flat walk along see entirely quite naturally stand a vertex see tree a root tree root vertex timofey assume non - isomorphic subtrees tree beautiful tree a subtree a vertex a subgraph contain vertex <unknown> tell timofey vertex stand see beautiful root tree subtrees vertices u v isomorphic number children u equal number children v children arrange a way subtree first son u isomorphic subtree first son v subtree second son u isomorphic subtree second son v , particular subtrees consist single vertex isomorphic first line contain single integer n ( 1 ≤ n ≤ 105 ) — number vertices tree next n - 1 line contain two integers ui vi ( 1 ≤ ui vi ≤ 105 ui ≠ vi ) denote vertices i - th edge connect guarantee give graph a tree print single integer — index vertex timofey stand many answer print first example stand vertex 1 vertex 3 every subtree non - isomorphic stand vertex 2 subtrees vertices 1 3 isomorphic second example stand vertex 1 subtrees vertices 4 5 isomorphic third example stand vertex 1 subtrees vertices 2 3 4 6 7 8 isomorphic stand vertex 2 subtrees vertices 3 4 6 7 8 isomorphic stand vertex 5 subtrees vertices 2 3 4 6 7 8 isomorphic subtrees vertices 1 9 isomorphic well :",['data structures'],2900.0
229/B,"<unknown> apophis capture jack <unknown> 's team ! jack able escape time apophis 's ship already jump hyperspace jack know planet apophis land order save friends jack must repeatedly go stargates get planet overall galaxy n planets index number 1 n. jack planet index 1 apophis land planet index n. jack move pair planets stargates ( move directions ) ; transfer take a positive , perhaps different pair planets <unknown> number second jack begin journey time 0 . travellers arrive planet jack currently locate case jack wait exactly 1 second use stargate , time t another traveller arrive planet jack pass stargate time t + 1 unless travellers arrive time t + 1 planet know information travel time planets time jack would able use stargate particular planets determine minimum time get planet index n. first line contain two space - separated integers : n ( 2 ≤ n ≤ 105 ) number planets galaxy m ( 0 ≤ m ≤ 105 ) — number pair planets jack travel use stargates m line follow contain three integers : i - th line contain number planets ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) connect stargates integer transfer time ( second ) ci ( 1 ≤ ci ≤ 104 ) planets guarantee pair planets one stargate connection n line follow : i - th line contain integer ki ( 0 ≤ ki ≤ 105 ) denote number moments time travellers arrive planet index i. ki distinct space - separated integers tij ( 0 ≤ tij < 109 ) follow sort ascend order integer tij mean time tij ( second ) another traveller arrive planet i. guarantee sum ki exceed 105 . print a single number — least amount time jack need get planet 1 planet n. jack ca n't get planet n amount time print number -1 . first sample jack three ways go planet 1 . move planet 4 spend 8 second transfer planet 3 spend 3 second travellers arrive planet 3 time 3 4 travel planet 4 time 5 thus spend 8 second total jack move planet 2 — planet 4 spend a total 2 + 5 = 7 second second sample one ca n't get planet 1 planet 3 move stargates",['data structures'],1700.0
757/F,"'s turn year bash want send present friends n cities himalayan region connect m bidirectional roads bash live city s. bash exactly one friend cities since bash want surprise friends decide send a pikachu since may cities reachable bash 's city send a pikachu friends live a city reachable city also want send soon possible find minimum time <unknown> reach destination city since a perfectionist inform friends time gift reach a pikachu travel a speed 1 meter per second friends excite hear would unhappy present get delay unfortunately team rocket <unknown> come know bash 's plan want maximize number friends unhappy bash destroy exactly one n - 1 cities imply friend reside city die unhappy well note a city destroy roads directly connect city also destroy pikachu may force take a longer alternate route please also note friends wait a gift count unhappy even die since bash already a legend help team rocket time find maximum number bash 's friends make unhappy destroy exactly one city first line contain three space separate integers n m s ( 2 ≤ n ≤ 2·105 , 1 ≤ s ≤ n ) — number cities number roads himalayan region city bash live next m line contain three space - separated integers u v w ( 1 ≤ u v ≤ n u ≠ v 1 ≤ w ≤ 109 ) denote exist a road city u city v length w meter guarantee road connect a city two roads connect pair cities print a single integer answer problem first sample destroy city 2 length shortest distance pair cities ( 3 2 ) ( 3 4 ) change hence answer 2",['data structures'],2800.0
464/E,give a weight undirected graph n vertices m edge find shortest path vertex s vertex t else state path n't exist first line input contain two space - separated integers — n m ( 1 ≤ n ≤ 105 ; 0 ≤ m ≤ 105 ) next m line contain description graph edge i - th line contain three space - separated integers — ui vi xi ( 1 ≤ ui vi ≤ n ; 0 ≤ xi ≤ 105 ) mean vertices number ui vi connect edge length <unknown> ( 2 power xi ) last line contain two space - separated integers — number vertices s t. vertices number 1 n. graph contain multiple edge self - loops first line print remainder divide length shortest path 1000000007 ( 109 + 7 ) path exist -1 path n't exist path exist print second line integer k — number vertices shortest path vertex s vertex t ; third line print k space - separated integers — vertices shortest path visit order first vertex vertex s last vertex vertex t. multiple shortest paths print a path vertex s vertex t a sequence v0 ... vk v0 = s vk = t i 0 k - 1 vertices vi vi + 1 connect edge length path sum weight edge vi vi + 1 i 0 k - 1 . shortest path s t path length minimum among possible paths s t,['data structures'],3000.0
494/E,last 24 hours ham malek spend time play ` ` sharti '' exhaust finish last round ask help determine winner round ` ` sharti '' play a n × n board cells color white others color black row board number top bottom use number 1 n. also columns board number leave right use number 1 n. cell locate intersection i - th row j - th column denote ( i j ) players alternatively take turn turn player must choose a square side - length k lower - right cell paint white color cells square <unknown> ( white cells become black vice - versa ) player perform a move turn lose know ham malek clever would play best move turn know fact ham take first turn give initial board describe input must determine one winner problem initial board specify a set m rectangles cells lie inside least one rectangles color white rest color black first line input three space - <unknown> integers n m k ( 1 ≤ k ≤ n ≤ 109 1 ≤ m ≤ 5·104 ) follow denote size board number rectangles maximum size turn square game respectively i - th line next m line four space - <unknown> integers ai bi ci di ( 1 ≤ ai ≤ ci ≤ n 1 ≤ bi ≤ di ≤ n ) give mean i - th rectangle determine initial board a rectangle upper - left cell ( ai bi ) lower - right cell ( ci di ) ham win print ` ` ham '' otherwise print ` ` malek '' ( without quote ),['data structures'],3200.0
1045/A,"year <unknown> 1000 years pass moon land <unknown> humanity <unknown> hyperspace ™ live <unknown> realize alone far away earth <unknown> <unknown> alien ' spaceships prepare attack earth first time a humanity real danger crisis panic everywhere scientists around solar system meet discuss possible solutions however progress make earth 's last hope ! fortunately earth equip powerful defense systems make <unknown> $$$ n $$$ alien ' spaceships form line defense system consist three type weapons : task make a plan attack destroy largest possible number spaceships every destroy spaceship destroy exactly one weapon first line contain two integers : number weapons $$$ n $$$ $$$ ( 1\leq n\leq 5000 ) $$$ number spaceships $$$ m $$$ $$$ ( 1\leq m\leq 5000 ) $$$ next $$$ n $$$ line line start one integer represent type ( either 0 1 2 ) type 0 weapon sql rocket rest line contain strictly positive number $$$ k $$$ $$$ ( \sum { k } \leq 100 000 ) $$$ array $$$ k_i $$$ $$$ ( 1\leq k_i\leq m ) $$$ $$$ k $$$ integers type 1 weapon cognition beam rest line contain integers $$$ l $$$ $$$ r $$$ $$$ ( 1\leq l\leq r\leq m ) $$$ type 2 weapon omg bazooka rest line contain distinct number $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ ( 1 \leq a b c \leq m ) $$$ first line contain maximum number destroy spaceships — $$$ x $$$ next $$$ x $$$ line every line contain two number $$$ a $$$ $$$ b $$$ $$$ a $$$ index weapon $$$ b $$$ index spaceship destroy weapon $$$ a $$$ sql rocket destroy 4th spaceship omg bazooka destroy two 1st 4th 5th spaceship cognition beam destroy spaceship interval $$$ [ 1,4 ] $$$ maximum number destroy spaceship 4 one possible plan sql rocket destroy 4th spaceship omg bazooka destroy 1st 5th spaceship cognition beam destroy 2nd spaceship",['data structures'],2500.0
1264/C,"creatnx $$$ n $$$ mirror number $$$ 1 $$$ $$$ n $$$ every day creatnx ask exactly one mirror ` ` i beautiful ? ` ` $$$ i $$$ -th mirror tell creatnx beautiful probability $$$ \frac { p_i } { 100 } $$$ $$$ 1 \le i \le n $$$ mirror call checkpoints initially $$$ 1 $$$ st mirror a checkpoint remain a checkpoint time creatnx ask mirror one one start $$$ 1 $$$ -st mirror every day ask $$$ i $$$ -th mirror two possibilities : change occur time : mirror become new checkpoints mirror longer checkpoints give $$$ q $$$ query query represent integer $$$ u $$$ : $$$ u $$$ -th mirror n't a checkpoint set a checkpoint otherwise $$$ u $$$ -th mirror longer a checkpoint query need calculate expect number days creatnx become happy number find modulo $$$ 998244353 $$$ formally let $$$ m = 998244353 $$$ show answer express irreducible fraction $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ integers $$$ q \not \equiv 0 \pmod { m } $$$ output integer equal $$$ p \cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \le x < m $$$ $$$ x \cdot q \equiv p \pmod { m } $$$ first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \leq n q \le 200000 $$$ ) — number mirror query second line contain $$$ n $$$ integers : $$$ p_1 p_2 \ldots p_n $$$ ( $$$ 1 \leq p_i \leq 100 $$$ ) $$$ q $$$ follow line contain a single integer $$$ u $$$ ( $$$ 2 \leq u \leq n $$$ ) — next query print $$$ q $$$ number – answer query modulo $$$ 998244353 $$$ first test first query first second mirror checkpoints creatnx ask first mirror say beautiful ask second mirror say beautiful second mirror a checkpoint , become happy probabilities mirror say beautiful equal $$$ \frac { 1 } { 2 } $$$ , expect number days one mirror say beautiful equal $$$ 2 $$$ answer equal $$$ 4 = 2 + 2 $$$",['data structures'],2400.0
1316/F,"$$$ n $$$ officer army byteland officer power associate power $$$ i $$$ -th officer denote $$$ p _ { i } $$$ war fast approach general would like know strength army strength army calculate a strange way byteland general select a random subset officer $$$ n $$$ officer call subset a battalion ( $$$ 2^n $$$ subsets $$$ n $$$ officer choose equally likely include empty subset subset officer ) strength a battalion calculate follow way : let power choose officer $$$ a _ { 1 } a _ { 2 } \ldots a _ { k } $$$ $$$ a_1 \le a_2 \le \dots \le a_k $$$ strength battalion equal $$$ <unknown> + <unknown> + \dots + a _ { k-1 } a_k $$$ ( size battalion $$$ \leq 1 $$$ strength battalion $$$ 0 $$$ ) strength army equal expect value strength battalion war really long power officer may change precisely $$$ q $$$ change one form $$$ i $$$ $$$ x $$$ indicate $$$ p _ { i } $$$ change $$$ x $$$ need find strength army initially $$$ q $$$ update note change <unknown> strength find modulo $$$ 10^ { 9 } +7 $$$ formally let $$$ <unknown> { 9 } +7 $$$ show answer express irreducible fraction $$$ p / q $$$ $$$ p $$$ $$$ q $$$ integers $$$ q\not\equiv 0 \bmod m $$$ ) output integer equal $$$ p\cdot q^ { -1 } \bmod m $$$ word output integer $$$ x $$$ $$$ 0 \leq x < m $$$ $$$ x <unknown> q \equiv p \bmod m $$$ ) first line input contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 3⋅10^ { 5 } $$$ ) — number officer byteland 's army second line contain $$$ n $$$ integers $$$ p _ { 1 } p _ { 2 } \ldots p _ { n } $$$ ( $$$ 1 \leq p _ { i } \leq 10^ { 9 } $$$ ) third line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 3⋅10^ { 5 } $$$ ) — number update next $$$ q $$$ line contain two integers $$$ i $$$ $$$ x $$$ ( $$$ 1 \leq i \leq n $$$ $$$ 1 \leq x \leq 10^ { 9 } $$$ ) indicate $$$ p _ { i } $$$ update $$$ x $$$ first line output initial strength army $$$ i $$$ -th next $$$ q $$$ line output strength army $$$ i $$$ -th update first testcase initially four possible <unknown> change $$$ p _ { 1 } $$$ $$$ 2 $$$ strength <unknown> { $$$ 1,2 $$$ } change $$$ 4 $$$ strength army become $$$ 1 $$$ change $$$ p _ { 2 } $$$ $$$ 1 $$$ strength battalion { $$$ 1,2 $$$ } become $$$ 2 $$$ strength army become $$$ \frac { 1 } { 2 } $$$",['data structures'],2800.0
1746/F,array $$$ a $$$ consist $$$ n $$$ positive integers handle $$$ q $$$ query follow type : first line input contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n q \le 300000 $$$ ) length $$$ a $$$ number query next line contain $$$ n $$$ integers $$$ a _ { 1 } a _ { 2 } \ldots a _ { n } $$$ ( $$$ 1 \le a _ { i } \le 1000000000 $$$ ) — elements $$$ a $$$ next $$$ q $$$ line describe a query one follow form query second type answer query yes print ` ` yes '' otherwise print ` ` '' first query request subarray $$$ [ 1234 2 3 3 2 1 ] $$$ 's obvious number occurrence $$$ 1 $$$ n't divisible $$$ k = 2 $$$ answer ` ` '' third query request subarray $$$ [ 1 2 3 3 2 1 ] $$$ see number occurrence every integer sub array divisible $$$ k = 2 $$$ answer ` ` yes '' sixth query request subarray $$$ [ 1 2 3 3 2 1 1 2 3 ] $$$ see number occurrence every integer sub array divisible $$$ k = 3 $$$ answer ` ` yes '',['data structures'],2800.0
895/E,vasya petya tire study decide play a game game begin vasya look array a consist n integers soon remember elements a game begin vasya close eye petya q action one two <unknown> ) petya say 4 integers l1 r1 l2 r2 — boundaries two non - intersecting segment swap one random element [ l1 r1 ] segment another random element [ l2 r2 ] <unknown> ) petya ask vasya sum elements a [ l r ] segment vasya a mathematician answer petya mathematical expectation sum elements segment task write a program answer second type question vasya would word program print mathematical expectation sum elements a [ l r ] segment every second type query first line contain two integers n q ( 2 ≤ n ≤ 105 1 ≤ q ≤ 105 ) — number elements array number query need handle second line contain n integers ai ( 1 ≤ ai ≤ 109 ) — elements array next q line contain petya 's action type 1 2 . a type 1 action line contain 5 integers 1 l1 r1 l2 r2 ( 1 ≤ l1 ≤ r1 ≤ n 1 ≤ l2 ≤ r2 ≤ n ) a type 2 query line contain 3 integers 2 l r ( 1 ≤ l ≤ r ≤ n ) guarantee least one type 2 query segment [ l1 r1 ] [ l2 r2 ] n't common elements type 2 query print one real number — mathematical expectation sum elements segment answer consider correct absolute relative error n't exceed 10 - 4 — formally answer correct x jury 's answer y,['data structures'],2300.0
896/C,— willem ... — 's matter ? — seem 's something wrong seniorious ... — i 'll a look ... seniorious make link special <unknown> particular order 500 years <unknown> bad condition willem decide examine <unknown> seniorious n piece <unknown> willem put a line i - th integer ai order maintain willem need perform m operations four type operations : line contain four integers n m seed vmax ( 1 ≤ n m ≤ 105 0 ≤ seed < 109 + 7 1 ≤ vmax ≤ 109 ) initial value operations generate use follow pseudo code : op type operation mention legend operation type 3 4 output a line contain answer first example initial array { 8 9 7 2 3 1 5 6 4 8 } operations :,['data structures'],2600.0
138/C,one day natalia walk woods meet a little mushroom gnome gnome tell follow story : everybody know mushroom gnomes ' power lie magic mushroom grow <unknown> woods gnomes n tree m magic mushroom woods : i - th tree grow a point a straight line coordinate ai height hi j - th mushroom grow point coordinate bj magical power zj one day <unknown> <unknown> <unknown> enemies mushroom gnomes <unknown> a terrible storm home forest a result tree begin fall <unknown> magic mushroom supreme oracle mushroom gnomes calculate advance probability tree fall leave right stand tree coordinate x height h fall leave mushroom belong right - open interval [ x - h x ) destroy a tree fall right mushroom belong left - open interval ( x x + h ] destroy mushroom hit a single tree survive know tree fall independently ( i.e. events <unknown> independent besides tree interfere tree fall arbitrary direction ) supreme oracle also able quickly calculate would expectation total power mushroom survive storm calculations ultimately save mushroom gnomes <unknown> death natalia a good olympiad programmer get interest story decide come a way quickly calculate expectation sum survive mushroom ' power first line contain two integers n m ( 1 ≤ n ≤ 105 1 ≤ m ≤ 104 ) — number tree mushroom respectively next n line contain four integers — ai hi li ri ( |ai| ≤ 109 1 ≤ hi ≤ 109 0 ≤ li ri li + ri ≤ 100 ) represent coordinate i - th tree height percentage probabilities tree fall leave right respectively ( remain percentage probability tree stand ) next m line contain two integers bj zj ( <unknown> ≤ 109 1 ≤ zj ≤ 103 ) represent coordinate magical power j - th mushroom respectively arbitrary number tree mushroom grow one point print a real number — expectation total magical power survive mushroom result accept relative absolute accuracy 10 - 4 . believe mushroom coordinate x belong right - open interval [ l r ) l ≤ x < r. similarly mushroom coordinate x belong left - open interval ( l r ] l < x ≤ r. first test mushroom survive probability 50 % depend single tree fall second test mushroom survive neither two tree fall occur probability 50 % × 50 % = 25 % pretest № 12 large test 105 tree one mushroom,['data structures'],2200.0
1403/A,"upon a time land shamans everyone live sky - high <unknown> shaman a unique identify number $$$ i $$$ $$$ 0 $$$ $$$ n-1 $$$ altitude value $$$ <unknown> $$$ represent high live grind level distance two <unknown> absolute value difference shamans live together peace one steal formula world - famous potion great power cover his / her track thief put a curse land : inhabitants could longer trust ... despite difficult circumstances order good <unknown> gain follow information curse : believe thief whisper formula evil shaman avoid detection visit home one ( respective ) trust friends visit thief whisper formula evil shaman window ( note : trust friend home time fact 's even possible visit 's house – shamans weird ) fortunately whisper travel short distance order know two trust friends visit ( thief evil shaman ) must live close ask help <unknown> would like test <unknown> : thief $$$ x $$$ evil shaman $$$ y $$$ formula whisper day $$$ v $$$ ? smallest distance whisper formula travel ? , minimum distance <unknown> shamans $$$ x ' $$$ $$$ y ' $$$ ( i.e $$$ <unknown> ( <unknown> _ { x ' } - h _ { y ' } <unknown> ) $$$ ) $$$ x ' $$$ a trust friend $$$ x $$$ $$$ y ' $$$ a trust friend $$$ y $$$ day $$$ v $$$ ? share information ask a number question need answer question immediately receive next one interaction begin a line contain $$$ n $$$ $$$ d $$$ $$$ u $$$ $$$ q $$$ $$$ ( 2 \leq n \leq 100000 $$$ $$$ 1 \leq d \leq 500 $$$ $$$ 0 \leq u \leq 200000 $$$ $$$ 1 \leq q \leq 50000 ) $$$ – number shamans maximum number trust friends a shaman give point number days number question next line $$$ n $$$ space separate integers follow $$$ i $$$ th $$$ ( 1\leq i \leq n ) $$$ $$$ h _ { i-1 } $$$ $$$ ( 0\leq h _ { i-1 } \leq 1000000000 ) $$$ altitude shaman $$$ i-1 $$$ next $$$ u $$$ line two integers $$$ i $$$ th ( $$$ 1 \leq i \leq u $$$ ) $$$ a_i $$$ $$$ b_i $$$ $$$ ( 0 \leq a_i b_i < n $$$ $$$ a_i \neq b_i ) $$$ represent a pair shamans start stop trust end day $$$ i-1 $$$ , $$$ a_i $$$ $$$ b_i $$$ trust day $$$ i-1 $$$ trust day $$$ i $$$ vice versa read integers interactor ask $$$ q $$$ question follow interaction happen $$$ q $$$ time : print line forget output end line flush output otherwise get idleness limit exceed , use : example query : evolution <unknown> :",['data structures'],2400.0
749/E,"give a permutation integers 1 n. exactly apply follow operation permutation : pick a random segment shuffle elements formally : inversion a pair elements ( necessary neighbour ) wrong relative order word number inversion equal number pair ( i j ) i < j ai > aj find expect number inversions apply exactly one operation mention first line contain a single integer n ( 1 ≤ n ≤ 100 000 ) — length permutation second line contain n distinct integers 1 n — elements permutation print one real value — expect number inversions answer consider correct absolute relative error exceed 10 - 9 . namely : let 's assume answer a answer jury b. checker program consider answer correct ,",['data structures'],2400.0
840/D,", leha find leave pocket array consist n integers right pocket q query form l r k. query must answer answer query minimal x x occur interval l r strictly time - 1 number help leha a difficult task first line input data contain two integers n q ( 1 ≤ n q ≤ 3·105 ) — number elements array number query respectively next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ n ) — leha 's array next q line contain three integers l r k ( 1 ≤ l ≤ r ≤ n 2 ≤ k ≤ 5 ) — description query output answer query new line",['data structures'],2500.0
1633/F,give a tree consist $$$ n $$$ vertices ( number $$$ 1 $$$ $$$ n $$$ ) $$$ n-1 $$$ edge ( number $$$ 1 $$$ $$$ n-1 $$$ ) initially vertices except vertex $$$ 1 $$$ inactive process query three type : note solve problem online mode mean ca n't read whole input read query write answer last query use function fflush c++ <unknown> java languages write program first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number vertices tree $$$ n-1 $$$ line follow $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ ; $$$ u_i \ne v_i $$$ ) — endpoints $$$ i $$$ -th edge edge form a tree query follow format describe statement one line per query least $$$ 2 $$$ $$$ <unknown> $$$ query last query ( last one ) type $$$ 3 $$$ note read $$$ i $$$ -th query already give answer query $$$ i-1 $$$ ( except $$$ i = 1 $$$ ) answer one query incorrect judge program recognize instead next query may receive integer $$$ 0 $$$ a separate line receive program terminate gracefully receive ` ` wrong answer '' verdict program n't terminate solution may receive verdict like ` ` time limit exceed '' ` ` idleness limit exceed '' etc note fact solution n't receive integer $$$ 0 $$$ mean answer correct check program terminate query type $$$ 1 $$$ $$$ 2 $$$ print answer a separate line describe statement n't forget flush output,['data structures'],2800.0
1575/C,"denote a cyclic sequence size $$$ n $$$ array $$$ s $$$ $$$ s_n $$$ adjacent $$$ s_1 $$$ segment $$$ s [ r l ] $$$ $$$ l < r $$$ concatenation $$$ s [ r n ] $$$ $$$ s [ 1 l ] $$$ give array $$$ a $$$ consist $$$ n $$$ integers define $$$ b $$$ cyclic sequence obtain concatenate $$$ m $$$ copy $$$ a $$$ note $$$ b $$$ size $$$ n \cdot m $$$ give integer $$$ k $$$ $$$ k = 1 $$$ $$$ k $$$ a prime number find number different segment $$$ b $$$ sum elements segment divisible $$$ k $$$ two segment consider different set indices segment different example $$$ n = 3 $$$ $$$ m = 2 $$$ set indices segment $$$ s [ 2 5 ] $$$ $$$ \ { 2 3 4 5\ } $$$ segment $$$ s [ 5 2 ] $$$ $$$ \ { 5 6 1 2\ } $$$ particular segment $$$ s [ 1 6 ] s [ 2,1 ] \ldots s [ 6 5 ] $$$ consider segment output answer modulo $$$ 1000000000 + 7 $$$ first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \leq n m k \leq 200000 $$$ $$$ k = 1 $$$ $$$ k $$$ a prime number ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 200000 $$$ ) output integer denote number different segment $$$ b $$$ sum elements segment divisible $$$ k $$$ modulo $$$ 1000000000 + 7 $$$ first example valid segment $$$ [ 1,4 ] $$$ $$$ [ 2 3 ] $$$ $$$ [ 3 5 ] $$$ $$$ [ 4 2 ] $$$ second example one valid segment $$$ [ 1 5 ] $$$",['data structures'],3000.0
1080/F,"a important day <unknown> a test a program class always give interest problem solve fast solve problem ? give $$$ n $$$ order segment set segment represent a pair two integers $$$ [ l r ] $$$ $$$ l\leq r $$$ set contain arbitrary number segment ( even $$$ 0 $$$ ) possible segment equal also give $$$ m $$$ query represent four number : $$$ a b x y $$$ segment find whether true set $$$ p $$$ ( $$$ a\leq p\leq b $$$ ) contain least one segment $$$ [ l r ] $$$ lie entirely segment $$$ [ x y ] $$$ $$$ x\leq l\leq r\leq y $$$ find answer query note need solve problem online , get a new query print answer previous query first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ $$$ ( 1\leq n m\leq 100000 1\leq k\leq 3\cdot100000 ) $$$ — number set query segment respectively next $$$ k $$$ line contain three integers $$$ l $$$ $$$ r $$$ $$$ p $$$ $$$ ( 1\leq l\leq r\leq 1000000000 1\leq p\leq n ) $$$ — limit segment index a set segment belong next $$$ m $$$ line contain four integers $$$ a b x y $$$ $$$ ( 1\leq a\leq <unknown> n 1\leq x\leq <unknown> 1000000000 ) $$$ — description query query print ` ` yes '' ` ` '' a new line print a query forget output end line flush output otherwise get idleness limit exceed , use : first query answer negative since second set contain a segment lie segment $$$ [ 2 3 ] $$$ second query first set contain $$$ [ 2 3 ] $$$ second set contain $$$ [ 2 4 ] $$$ third query first set contain $$$ [ 2 3 ] $$$ second set contain $$$ [ 2 4 ] $$$ third set contain $$$ [ 2 5 ] $$$ fourth query second set contain a segment lie segment $$$ [ 3 6 ] $$$ fifth query second set contain $$$ [ 2 4 ] $$$ third set contain $$$ [ 2 5 ] $$$ fourth contain $$$ [ 7 9 ] $$$",['data structures'],2400.0
916/D,i finish many assignments ? ? ? jamie get busy school life start forget assignments decide write things a to - do list assign a value priority assignment ( lower value mean important ) decide need spend time a days jamie find list large ca n't even manage list ! a good friend jamie help write a program support follow operations to - do list : day 0 to - do list empty follow q days jamie exactly one four operations operation a query output result query proceed next day poor jamie make appropriate decisions first line consist a single integer q ( 1 ≤ q ≤ 105 ) — number operations follow q line consist description operations i - th line consist operation jamie do i - th day query follow format : first word line indicate type operation must one follow four : set remove query <unknown> assignment name ai consist lowercase english letter a length 1 ≤ |ai| ≤ 15 . guarantee last operation a query operation query operation output a single integer — number assignments a priority lower assignment ai - 1 ai to - do list operation a query output result query flush output stream proceed next operation otherwise may get verdict idleness limit exceed flush output stream please refer documentation choose program language flush function common program languages list :,['data structures'],2200.0
413/E,"last product r2 company 2d game ' field a new revolutionary algorithm search shortest path a 2 × n maze imagine a maze look like a 2 × n rectangle divide unit square unit square either empty cell obstacle one unit time a person move empty cell maze side - adjacent empty cell shortest path problem formulate follow give two free maze cells need determine minimum time require go one cell unfortunately develop algorithm work well one request find shortest path practice request occur quite often , chief r2 programmer commission optimize algorithm find shortest path write a program <unknown> respond multiple request find shortest path a 2 × n maze first line contain two integers n m ( 1 ≤ n ≤ 2·105 ; 1 ≤ m ≤ 2·105 ) — width maze number query correspondingly next two line contain maze line contain n character character equal either ' . ' ( empty cell ) ' x ' ( obstacle ) next m line contain two integers vi ui ( 1 ≤ vi ui ≤ 2n ) — description i - th request number vi ui mean need print value shortest path cell maze number vi cell number ui assume cells first line maze number 1 n leave right cells second line number n + 1 2n leave right guarantee give cells empty print m line i - th line print answer i - th request — either size shortest path -1 ca n't reach second cell first one",['data structures'],2200.0
459/D,"parmida a clever girl want participate <unknown> year course want <unknown> clever ( although 's ) ! parmida prepare follow test problem pashmak a sequence a consist n integers a1 a2 ... , let 's denote f ( l r x ) number indices k : l ≤ k ≤ r ak = x. task calculate number pair <unknown> i j ( 1 ≤ i < j ≤ n ) f ( 1 i ai ) > f ( j n aj ) help pashmak test first line input contain integer n ( 1 ≤ n ≤ 106 ) second line contain n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) print a single integer — answer problem",['data structures'],1800.0
150/E,winter ... well ' ve get idea : - ) nvodsk road system represent n junctions connect n - 1 bidirectional roads a path two junctions organizers event want choose a place accommodate participants ( junction v ) place set contest ( junction u ) besides one hand want participants walk city see <unknown> ( 's distance v u less l ) hand n't want participants <unknown> ( distance v u r ) besides every street know beauty — integer 0 109 . task choose path fit length limit largest average beauty shall define average beauty a median sequence beauties roads along path put formally like : let a path length k. let ai a non - decreasing sequence contain exactly k elements number occur exactly number time a road beauty occur along path represent path median number <unknown> / <unknown> assume <unknown> start zero use <unknown> — number <unknown> round nearest integer example a = { 0 5 12 } median equal 5 a = { 0 5 7 12 } median number 7 . guarantee least one path suitable quantity roads first line contain three integers n l r ( 1 ≤ l ≤ r < n ≤ 105 ) next n - 1 line contain descriptions roads nvodsk line contain three integers ai bi ci ( 1 ≤ ai bi ≤ n 0 ≤ ci ≤ 109 ai ≠ bi ) — junctions ai bi connect a street whose beauty equal ci print two integers — number junctions accommodate participants set contest correspondingly multiple optimal variants print first sample roads beauty mean paths positive length median thus path length 3 4 inclusive valid us second sample city look like : 1 - 2 - 3 - 4 - 5 - 6 . two last roads <unknown> choose path contain suitable length either path 2 6 path 3 6,['data structures'],3000.0
536/E,tavas live tavaspolis tavaspolis n cities number 1 n connect n - 1 bidirectional roads exist a path two cities also road a length tavas ' favorite string binary string ( contain 0 1 ) binary string like s = s1s2 ... sk t ( s ) goodness t ( s ) calculate follow : consider exactly m block 1s string ( a block 1s s a maximal consecutive substring s contain 1 ) lengths x1 x2 ... <unknown> define f a give sequence ( m = 0 t ( s ) = 0 ) tavas love query ask answer q query query give number v u l print follow number : consider roads path city v city u : e1 <unknown> ... <unknown> build binary string b length x : bi = 1 l ≤ w ( ei ) w ( e ) length road e. print t ( b ) query first line input contain integers n q ( 2 ≤ n ≤ 105 1 ≤ q ≤ 105 ) next line contain n - 1 space separate integers f1 f2 ... fn - 1 ( |fi| ≤ 1000 ) next n - 1 line contain detail roads line contain integers v u w mean 's a road cities v u length w ( 1 ≤ v u ≤ n 1 ≤ w ≤ 109 ) next q line contain detail query line contain integers v u l ( 1 ≤ v u ≤ n v ≠ u 1 ≤ l ≤ 109 ) print answer query a single line,['data structures'],3100.0
549/F,"yura a team k developers a list n task number 1 n. yura go choose task do week due strange <unknown> habit number choose task a segment consecutive integers contain less 2 number i. e. a sequence form l l + 1 ... r 1 ≤ l < r ≤ n. every task i integer number ai associate denote many man - hours require complete i - th task developers self - confident actually afraid difficult task know yura decide pick a hardest task ( one take biggest number man - hours complete among several hardest task difficulty level choose arbitrary one ) complete , task number [ l r ] choose developers leave r - l task do every developer spend integer amount hours task do whole assignment exactly ai man - hours spend i - th task last least problem developers one get angry work another developer a set task [ l r ] consider good possible find a distribution work allow complete task every developer work amount time ( amount work perform yura n't matter workers well ) example let 's suppose yura choose task follow difficulties : a = [ 1 2 3 4 ] three developers disposal take hardest fourth task finish developers leave task difficulties [ 1 2 3 ] first one spend hour first task hour third one second developer spend two hours second task third developer spend two hours third task do since every developer work exactly two hours every task work require amount time another example first task require two hours instead one complete would impossible assign task a way describe besides work yura fond problem solve wonder many pair ( l r ) ( 1 ≤ l < r ≤ n ) exist a segment [ l r ] good ? yura already solve problem time write code please help yura implement solution problem first line input contain two positive integers : n k ( 1 ≤ n ≤ 300 000 1 ≤ k ≤ 1 000 000 ) number task list number developers yura 's disposal second line contain n integers ai ( 1 ≤ ai ≤ 109 ) output a single integer — number pair ( l r ) satisfy condition statement first sample three good segment :",['data structures'],2800.0
757/G,<unknown> ! a great job help team rocket manage capture pokemons send bash meowth part team rocket already master human language want become a master program well agree free pokemons bash answer question initially meowth give bash a weight tree contain n nod a sequence a1 a2 ... a permutation 1 2 ... n. <unknown> make q query one follow form : help bash answer question ! first line contain two integers n q ( 1 ≤ n ≤ 2·105 1 ≤ q ≤ 2·105 ) — number nod tree number query respectively next line contain n space - separated integers — sequence a1 a2 ... a permutation 1 2 ... n. next n - 1 line contain three space - separated integers u v w denote exist undirected edge node u node v weight w ( 1 ≤ u v ≤ n u ≠ v 1 ≤ w ≤ 106 ) guarantee give graph a tree query consist two line first line contain single integer t indicate type query next line contain description query : ansi answer i - th query assume <unknown> = 0 . i - th query type 2 ansi = ansi - 1 . guarantee : operation mean bitwise exclusive query type 1 output a single integer a separate line denote answer query sample actual query follow :,['data structures'],3400.0
763/E,birthday party timofey go favorite tree alley a park want fee favorite bird — crow 's widely know tree occupy a single crow family tree alley form a row number 1 n. families friends reason two families friends live far precisely k - 1 tree pair friend families formally family u - th tree family v - th tree friends |u - v| ≤ k hold one friendship feature family learn timofey feed crow somewhere <unknown> friend families thus timofey start fee crow tree families friends family live tree well friends fly feed place course family live tree also come feed place today timofey come alley notice families live tree number strictly less l strictly greater r fly away thus possible pass information feed moreover need fee help timofey learn minimum number tree fee crow families remain get information feed give several situations describe integers l r need calculate answer first line contain integers n k ( 1 ≤ n ≤ 105 1 ≤ k ≤ 5 ) n number tree k maximum possible distance friend families next line contain single integer m ( 0 ≤ m ≤ n·k ) — number pair friend families next m line contain two integers u v ( 1 ≤ u v ≤ 105 ) mean families tree u v friends guarantee u ≠ v |u - v| ≤ k. give pair distinct next line contain single integer q ( 1 ≤ q ≤ 105 ) — number situations need calculate answer next q line contain two integers l r ( 1 ≤ l ≤ r ≤ 105 ) mean situation families fly away live tree x either x < l x > r. print q line line i contain single integer — answer i - th situation first example follow family pair friends : ( 1 3 ) ( 2 3 ) ( 4 5 ),['data structures'],2900.0
526/F,problem meet simplify model game pudding monsters important process develop game create level a game field pudding monsters n × n rectangular grid n cells contain monsters cells contain game object <unknown> move monsters around field two monsters touch glue together a single big one ( pudding remember ? ) statistics show interest map appear initially row column contain exactly one monster rest map <unknown> set correct position game object a technique 's widely use make development process efficient <unknown> available resources example a large n × n map choose a smaller k × k square part contain exactly k monsters suggest a simplify version original map wonder many ways choose initial map a k × k ( 1 ≤ k ≤ n ) square fragment contain exactly k pudding monsters calculate number first line contain a single integer n ( 1 ≤ n ≤ 3 × 105 ) — size initial field next n line contain coordinate cells initially contain monsters i - th next line contain two number ri ci ( 1 ≤ ri ci ≤ n ) — row number column number cell initially contain i - th monster guarantee ri distinct number ci distinct number print number distinct square fragment original field form a new map,['data structures'],3000.0
1346/H,"alice bob play a game ( yet ) two sequence segment coordinate axis : a sequence $$$ n $$$ initial segment : $$$ [ l_1 r_1 ] $$$ $$$ [ l_2 r_2 ] $$$ ... $$$ [ l_n r_n ] $$$ a sequence $$$ m $$$ terminal segment : $$$ [ l_1 r_1 ] $$$ $$$ [ l_2 r_2 ] $$$ ... $$$ [ <unknown> <unknown> ] $$$ begin game choose one initial segment set current segment alice bob make alternate move : alice make first move bob make second move alice make third one , move current player must <unknown> current segment either increase leave endpoint $$$ 1 $$$ decrease right endpoint $$$ 1 $$$ , current segment $$$ [ c_l c_r ] $$$ become either $$$ [ c_l + 1 c_r ] $$$ $$$ [ c_l c_r - 1 ] $$$ begin game bob 's move current segment coincide one terminal segment bob win current segment become degenerate ( $$$ c_l = c_r $$$ ) bob n't yet alice win current segment coincide one terminal segment alice 's move nothing happen — game continue players play optimally — win always use a strategy lead victory minimum number turn win try <unknown> game use strategy allow make maximum possible number move defeat initial segment determine win game segment choose current segment begin game bob win also calculate number move alice make defeat first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200000 $$$ ) — number initial segment terminal segment respectively $$$ n $$$ line follow $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i < r_i \le 1000000 $$$ ) — endpoints $$$ i $$$ -th initial segment $$$ m $$$ line follow $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i < r_i \le 1000000 $$$ ) — endpoints $$$ i $$$ -th terminal segment note segment give input may coincide print $$$ n $$$ integers $$$ i $$$ -th describe result game $$$ i $$$ -th initial segment choose begin game :",['data structures'],2700.0
1458/E,"<unknown> mobile game ` ` nim '' blow decide make a <unknown> call ` ` nim 2 '' game expand trust nim game formula add much <unknown> second heap ! game two heap contain a non - negative number stone two players make move turn turn a player take positive number stone either one heap a player unable move lose game make game easier <unknown> ' ve introduce developer shortcuts $$$ n $$$ shortcut position $$$ ( x_1 y_1 ) \ldots ( x_n y_n ) $$$ change game follow : suppose a player 's turn first second heap contain $$$ x $$$ $$$ y $$$ stone respectively pair $$$ ( x y ) $$$ equal one pair $$$ ( x_i y_i ) $$$ player move lose instantly otherwise able make move normal note explanation two heap pair order , $$$ x $$$ must refer size first heap $$$ y $$$ must refer size second heap game release follow much celebration next thing know developer shortcuts make way next official update game ! players <unknown> ai opponent become <unknown> certain stag game write a program figure give initial position start player assume players act optimally first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 100000 $$$ ) — number shortcut position number initial position need evaluate follow $$$ n $$$ line describe shortcut position $$$ i $$$ -th line contain two integers $$$ x_i y_i $$$ ( $$$ 0 \leq x_i y_i \leq 1000000000 $$$ ) guarantee shortcut position distinct follow $$$ m $$$ line describe initial position $$$ i $$$ -th line contain two integers $$$ a_i b_i $$$ ( $$$ 0 \leq a_i b_i \leq 1000000000 $$$ ) — number stone first second heap respectively guarantee initial position distinct however initial position necessarily distinct shortcut position initial position a separate line print ` ` win '' start player able win position ` ` lose '' otherwise",['data structures'],3100.0
293/E,' ve get a weight tree consist n vertices edge a non - negative weight length path two vertices tree number edge path weight path total weight edge contain two vertices close exist a path length l a path weight w count number pair vertices v u ( v < u ) vertices v u close first line contain three integers n l w ( 1 ≤ n ≤ 105 1 ≤ l ≤ n 0 ≤ w ≤ 109 ) next n - 1 line contain descriptions tree edge i - th line contain two integers pi wi ( 1 ≤ pi < ( i + 1 ) 0 ≤ wi ≤ 104 ) mean i - th edge connect vertex ( i + 1 ) pi weight wi consider tree vertices index 1 n way print a single integer — number close pair please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier,['data structures'],2700.0
786/C,rick morty want find mr . <unknown> ca n't alone need mr . meeseeks generate n mr . meeseeks stand a line number 1 n. color i - th mr . meeseeks ' color ai rick morty gather army want divide mr . meeseeks squads n't want squads colorful squad mr . meeseeks k different color also squad a continuous subarray mr . meeseeks line mean 1 ≤ i ≤ e ≤ j ≤ n mr . meeseeks number i mr . meeseeks number j squad mr . meeseeks number e squad also squad need presidio build a presidio need money want total number squads minimize rick morty n't <unknown> exact value k order choose k 1 n ( inclusive ) need know minimum number presidios need first line input contain a single integer n ( 1 ≤ n ≤ 105 ) — number mr . meeseeks second line contain n integers a1 a2 ... separate space ( 1 ≤ ai ≤ n ) — color mr . meeseeks order stand a line first line input print n integers separate space i - th integer minimum number presidios need value k i. first sample testcase optimal ways divide army squads k : second testcase optimal ways divide army squads k :,['data structures'],2400.0
793/G,oleg bank client solve interest chess problem : place n × n chessboard maximum number rook n't beat course two rook share cell remind a rook stand cell ( a b ) beat a rook stand cell ( x y ) a = x b = y. unfortunately ( fortunately ? ) oleg answer problem always n task bore oleg soon decide make difficult remove cells board a cell delete oleg ca n't put a rook rook beat ` ` '' delete cells oleg delete cells group namely repeatedly choose a rectangle side parallel board side delete cells inside rectangle formally choose a rectangle lower leave cell coordinate ( x1 y1 ) upper right cell coordinate ( x2 y2 ) delete cells coordinate ( x y ) x1 ≤ x ≤ x2 y1 ≤ y ≤ y2 guarantee cell delete twice i.e choose rectangles intersect version problem oleg ca n't solve friend igor busy a conference ca n't help oleg last hope oleg ! help : give size board delete rectangles find maximum possible number rook could place board two rook beat first line contain single integer n ( 1 ≤ n ≤ 10000 ) — size board second line contain single integer q ( 0 ≤ q ≤ 10000 ) — number delete rectangles next q line contain information delete rectangles line contain four integers x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ n ) — coordinate lower leave upper right cells a delete rectangle guarantee rectangles intersect line print maximum number rook oleg place board two rook beat board example rook placement first example :,['data structures'],3400.0
817/D,give array a consist n elements imbalance value subsegment array difference maximum minimum element segment imbalance value array sum imbalance value subsegments array example imbalance value array [ 1 4 1 ] 9 6 different subsegments array : determine imbalance value array a. first line contain one integer n ( 1 ≤ n ≤ 106 ) — size array a. second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 106 ) — elements array print one integer — imbalance value a,['data structures'],1900.0
1523/G,william own a flat central <unknown> decide rent flat next $$$ n $$$ days earn money since flat center city instantly get $$$ m $$$ offer form $$$ ( l_i r_i ) $$$ mean someone want book flat day $$$ l_i $$$ day $$$ r_i $$$ inclusive avoid spend a lot time figure whether 's profitable accept offer william decide develop algorithm algorithm process offer arrive accept offer $$$ i $$$ follow two condition satisfy : william n't sure value $$$ x $$$ ask help $$$ x $$$ $$$ 1 $$$ $$$ n $$$ want calculate total number days flat would occupy correspond value assign $$$ x $$$ first line contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 1 \le n \le 5 \cdot 10000 1 \le m \le 100000 ) $$$ number days number offer respectively next $$$ m $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ $$$ ( 1 \le l_i \le r_i \le n ) $$$ describe $$$ i $$$ -th rent offer offer give chronological order print $$$ n $$$ integers number $$$ i $$$ -th line must equal number days flat would occupy algorithm use value $$$ x $$$ equal $$$ i $$$ description segment first sample test $$$ x $$$ :,['data structures'],3200.0
1583/H,"omkar host tour country omkarland ! $$$ n $$$ cities omkarland , rather <unknown> exactly $$$ n-1 $$$ bidirectional roads connect cities guarantee reach city city road network every city enjoyment value $$$ e $$$ road a capacity $$$ c $$$ denote maximum number vehicles associate toll $$$ t $$$ however toll system omkarland interest <unknown> : a vehicle travel multiple roads a single journey pay highest toll single road travel ( word pay $$$ \max t $$$ roads travel . ) a vehicle traverse roads pay $$$ 0 $$$ toll omkar decide host $$$ q $$$ tour group tour group consist $$$ v $$$ vehicles start city $$$ x $$$ ( keep mind a tour group $$$ v $$$ vehicles travel roads capacity $$$ \geq v $$$ . ) tour <unknown> omkar want group much fun possibly also must reimburse group toll pay thus tour group omkar want know two things : first enjoyment value city $$$ y $$$ maximum enjoyment value tour group reach start city second much per vehicle omkar pay reimburse entire group trip $$$ x $$$ $$$ y $$$ ? ( trip $$$ x $$$ $$$ y $$$ always shortest path $$$ x $$$ $$$ y $$$ ) case multiple reachable cities maximum enjoyment value omkar let tour group choose one want go therefore prepare possible scenarios want know amount money per vehicle need guarantee reimburse group regardless city choose first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \leq n \leq 200000 $$$ $$$ 1 \leq q \leq 200000 $$$ ) represent number cities number group respectively next line contain $$$ n $$$ integers $$$ e_1 e_2 \ldots e_n $$$ ( $$$ 1 \leq e_i \leq 1000000000 $$$ ) $$$ e_i $$$ represent enjoyment value city $$$ i $$$ next $$$ n-1 $$$ line contain four integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ t $$$ ( $$$ 1 \leq a b \leq n $$$ $$$ 1 \leq c \leq 1000000000 $$$ $$$ 1 \leq t \leq 1000000000 $$$ ) represent road city $$$ a $$$ city $$$ b $$$ capacity $$$ c $$$ toll $$$ t $$$ next $$$ q $$$ line contain two integers $$$ v $$$ $$$ x $$$ ( $$$ 1 \leq v \leq 1000000000 $$$ $$$ 1 \leq x \leq n $$$ ) represent number vehicles tour group start city respectively output $$$ q $$$ line $$$ i $$$ -th line contain two integers : highest possible enjoyment value a city reachable $$$ i $$$ -th tour group amount money per vehicle omkar need guarantee reimburse $$$ i $$$ -th tour group a map first sample show nod unbolded number represent indices bolded number represent enjoyment value edge unbolded number represent <unknown> bolded number represent toll first query a tour group size $$$ 1 $$$ start city $$$ 3 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ thus largest enjoyment value reach $$$ 3 $$$ tour group choose go city $$$ 4 $$$ omkar pay $$$ 8 $$$ per vehicle maximum second query a tour group size $$$ 9 $$$ start city $$$ 5 $$$ reach city $$$ 5 $$$ thus largest reachable enjoyment value still $$$ 3 $$$ omkar pay $$$ 0 $$$ per vehicle third query a tour group size $$$ 6 $$$ start city $$$ 2 $$$ reach cities $$$ 2 $$$ $$$ 4 $$$ largest reachable enjoyment value $$$ 3 $$$ tour group choose go city $$$ 4 $$$ omkar pay $$$ 2 $$$ per vehicle maximum a map second sample show : first query a tour group size $$$ 5 $$$ start city $$$ 1 $$$ reach city $$$ 1 $$$ thus maximum enjoyment value $$$ 1 $$$ cost omkar pay $$$ 0 $$$ per vehicle second query a tour group size $$$ 4 $$$ start city $$$ 1 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ thus maximum enjoyment value $$$ 2 $$$ omkar pay $$$ 1 $$$ per vehicle third query a tour group size $$$ 3 $$$ start city $$$ 1 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ thus maximum enjoyment value $$$ 3 $$$ omkar pay $$$ 1 $$$ per vehicle fourth query a tour group size $$$ 2 $$$ start city $$$ 1 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ thus maximum enjoyment value $$$ 4 $$$ omkar pay $$$ 1 $$$ per vehicle fifth query a tour group size $$$ 1 $$$ start city $$$ 1 $$$ reach cities $$$ 1 $$$ $$$ 2 $$$ $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ thus maximum enjoyment value $$$ 5 $$$ omkar pay $$$ 1 $$$ per vehicle",['data structures'],3300.0
1609/F,william array non - negative number $$$ a_1 a_2 \dots a_n $$$ want find many segment $$$ l \le r $$$ pass check check perform follow manner : first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) size array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 10^ { 18 } $$$ ) content array $$$ a $$$ output a single number — total number segment pass check,['data structures'],2800.0
1019/E,"year 3018 summer informatics school <unknown> grow hotel « <unknown> » choose a location school camp consist $$$ n $$$ house $$$ n-1 $$$ pathways possible reach every house use pathways everything perfect rain start weather <unknown> promise rain continue $$$ m $$$ days a special squad teachers able measure $$$ i $$$ -th pathway connect house $$$ u_i $$$ $$$ v_i $$$ rain could pass $$$ b_i $$$ second unfortunately rain <unknown> roads every day time pass road increase $$$ a_i $$$ second word $$$ t $$$ -th ( zero ) day start rain take $$$ a_i \cdot t + b_i $$$ second pass road unfortunately despite <unknown> teachers even year 3018 students house midnight midnight students go bed important find maximal time pair house day every student would know time run house find maximal time paths every pair house $$$ t=0 $$$ $$$ t=1 $$$ ... $$$ t = m-1 $$$ days first line give two integers $$$ n $$$ $$$ m $$$ — number house camp number rain days ( $$$ 1 \le n \le 100\,000 $$$ ; $$$ 1 \le m \le 1\,000\,000 $$$ ) next $$$ n-1 $$$ line give integers $$$ u_i $$$ $$$ v_i $$$ $$$ a_i $$$ $$$ b_i $$$ — description pathways ( $$$ 1 \le u_i v_i \le n $$$ ; $$$ 0 \le a_i \le 100000 $$$ ; $$$ 0 \le b_i \le 1000000000 $$$ ) $$$ i $$$ -th pathway connect house $$$ u_i $$$ $$$ v_i $$$ day $$$ t $$$ require $$$ a_i \cdot t + b_i $$$ second pass guarantee every two house connect a sequence pathways print $$$ m $$$ integers — lengths longest path camp a $$$ t=0 t=1 \ldots t = m-1 $$$ days start rain let 's consider first example first three days ( $$$ 0 \le t \le 2 $$$ ) longest path 2nd 3rd house length equal $$$ 100 + <unknown> $$$ second third day ( $$$ t=2 $$$ ) road house 1 4 length $$$ 100 $$$ keep increase , days $$$ t=2 3 4 5 $$$ longest path vertices 4 ( 1 2 ) length $$$ 180 + 10 t $$$ notice day $$$ t=2 $$$ three pathways length 100 three maximal paths equal length sixth day ( $$$ t=5 $$$ ) pathway first fifth house get length 100 . every day $$$ t=5 $$$ longest path house 4 5 length $$$ 80 + 30 t $$$",['data structures'],3200.0
1418/G,give array $$$ a $$$ consist $$$ n $$$ integers denote subarray $$$ a [ l .. r ] $$$ array $$$ [ a_l a _ { l + 1 } \dots a_r ] $$$ ( $$$ 1 \le l \le r \le n $$$ ) a subarray consider good every integer occur subarray occur exactly <unknown> example array $$$ [ 1 2 2 2 1 1 2 2 2 ] $$$ three good subarrays : calculate number good subarrays give array $$$ a $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) print one integer — number good subarrays array $$$ a $$$,['data structures'],2500.0
1730/E,give array $$$ a_1 a_2 \ldots a_n $$$ positive integers find number pair indices $$$ ( l r ) $$$ $$$ 1 \le l \le r \le n $$$ pass check check perform follow manner : first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) — number test case test case follow test case consist two line first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) — size array second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 500000 $$$ test case print a single integer — number pair indices pass check $$$ x \mid y $$$ denote $$$ y $$$ divisible $$$ x $$$ first test case one pair $$$ ( 1 1 ) $$$ maximum pair $$$ 1 $$$ minimum also $$$ 1 $$$ $$$ 1 \mid 1 $$$ check pass answer $$$ 1 $$$ second test case $$$ 3 $$$ segment : third test case $$$ 3 $$$ segment :,['data structures'],2700.0
1379/F2,"note difference easy hard versions hard version unavailable cells become available easy version ca n't make hack versions solve ildar ivan tire chess really like chessboard invent a new game field a chessboard $$$ 2n \times 2 m $$$ : $$$ 2n $$$ row $$$ 2 m $$$ columns cell row $$$ i $$$ column $$$ j $$$ color white $$$ <unknown> $$$ even color black otherwise game proceed follow : ildar mark white cells chessboard unavailable ask ivan place $$$ n \times m $$$ kings remain white cells way kings attack a king attack another king locate adjacent cells share edge a corner ildar would like <unknown> different combinations cells initially cells mark available $$$ q $$$ query query either mark a cell unavailable mark previously unavailable cell available query would like know whether possible place kings available cells a desire way please help ! first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \leq n m q \leq 200\,000 $$$ ) — size board number query $$$ q $$$ line follow contain a description a query : two integers $$$ i $$$ $$$ j $$$ denote a white cell board ( $$$ 1 \leq i \leq 2n $$$ $$$ 1 \leq j \leq 2 m $$$ $$$ i + j $$$ even ) cell $$$ ( i j ) $$$ available query become unavailable otherwise cell unavailable become available output $$$ q $$$ line $$$ i $$$ -th line contain answer a board $$$ i $$$ query ildar line contain ` ` yes '' possible place kings available cells desire way ` ` '' otherwise first example case second query cells $$$ ( 1 1 ) $$$ $$$ ( 1 5 ) $$$ unavailable ivan place three kings cells $$$ ( 2 2 ) $$$ $$$ ( 2 4 ) $$$ $$$ ( 2 6 ) $$$ third query three cells $$$ ( 1 1 ) $$$ $$$ ( 1 5 ) $$$ $$$ ( 2 4 ) $$$ unavailable remain 3 available cells : $$$ ( 2 2 ) $$$ $$$ ( 1 3 ) $$$ $$$ ( 2 6 ) $$$ ivan put 3 kings cells kings cells $$$ ( 2 2 ) $$$ $$$ ( 1 3 ) $$$ attack since cells share a corner",['data structures'],2800.0
848/C,i wo n't feel lonely i <unknown> ... everything <unknown> a string n bead leave message leave bead number 1 n leave right a shape number integers 1 n inclusive bead may shape memory a shape x a certain subsegment bead define difference last position first position shape x appear segment memory a subsegment sum memories shape occur time time shape bead change well memories sometimes past <unknown> subsegments recall find memory first line input contain two space - separated integers n m ( 1 ≤ n m ≤ 100 000 ) — number bead string total number change query respectively second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ n ) — initial shape bead 1 2 ... n respectively follow m line describe either a change bead a query subsegment a line one follow format : query print one line integer — memory recall subsegment initial string bead shape ( 1 2 3 1 3 2 1 ) consider change query order :,['data structures'],2600.0
1676/H2,"difference two versions version $$$ n \leq 200000 $$$ sum $$$ n $$$ test case exceed $$$ 200000 $$$ a terminal a row $$$ n $$$ equal segment number $$$ 1 $$$ $$$ n $$$ order two terminals one give array $$$ a $$$ length $$$ n $$$ $$$ i = 1 2 \dots n $$$ a straight wire point segment $$$ i $$$ top terminal point segment $$$ a_i $$$ bottom terminal ca n't select endpoints a segment example follow picture show two possible wire $$$ n=7 $$$ $$$ a= [ 4,1,4,6,7,7,5 ] $$$ a cross occur two wire share a point common picture cross circle red maximum number cross place wire optimally ? first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case first line test case contain integer $$$ n $$$ ( $$$ 1 \leq n \leq 200000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — elements array sum $$$ n $$$ across test case exceed $$$ 200000 $$$ test case output a single integer — maximum number cross place wire optimally first test case show second picture statement second test case wire possible two wire cross answer $$$ 1 $$$ third test case wire possible one wire answer $$$ 0 $$$",['data structures'],1500.0
1801/E,"one gas station city berland gas station special price gas station a fix range price ready sell gasoline a gas station city number $$$ i $$$ ready sell gasoline price $$$ l_i $$$ $$$ r_i $$$ inclusive king berland — <unknown> family man $$$ m $$$ years two sons bear every year king 's children involve public <unknown> since early <unknown> end year check <unknown> gasoline price birth king 's children bear year $$$ i $$$ responsible check gasoline price ways city $$$ a_i $$$ city $$$ b_i $$$ city $$$ c_i $$$ city $$$ d_i $$$ respectively check follow : children simultaneously start journey cities $$$ a_i $$$ $$$ c_i $$$ respectively first son king bear year $$$ i $$$ move along path city $$$ a_i $$$ city $$$ b_i $$$ second — city $$$ c_i $$$ city $$$ d_i $$$ children check price gasoline city $$$ a_i $$$ coincide price gasoline city $$$ c_i $$$ next check price gasoline second city way $$$ a_i $$$ $$$ b_i $$$ coincide price second city way $$$ c_i $$$ $$$ d_i $$$ repeat thing a couple third cities paths end check price gasoline city $$$ b_i $$$ coincide price gasoline city $$$ d_i $$$ guarantee length path city $$$ a_i $$$ city $$$ b_i $$$ coincide length path city $$$ c_i $$$ city $$$ d_i $$$ gas station must strictly obey laws therefore check gasoline price reveal violations help berland gas station find many ways set gasoline price $$$ m $$$ years word $$$ i $$$ $$$ 1 $$$ $$$ m $$$ calculate many ways set gasoline price gas station birth first $$$ i $$$ pair king 's children check reveal violations gas station price acceptable price range since number methods large calculate answer modulo $$$ 1000000000 + 7 $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 200\,000 $$$ ) — number cities berland second line contain $$$ ( n - 1 ) $$$ number $$$ p_2 \ p_3 \ p_4 \ \ldots \ p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) $$$ p_i $$$ denote number next city way city $$$ i $$$ city $$$ 1 $$$ follow line two integers give $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i < 1000000000 + 7 $$$ ) specify acceptable range price gas station number $$$ i $$$ follow line contain a single integer $$$ m $$$ ( $$$ 1 \le m \le 200\,000 $$$ ) — number years two sons bear king follow $$$ m $$$ line four integers give $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ $$$ d_i $$$ ( $$$ 1 \le a_i b_i c_i d_i \le n $$$ ) specify two paths king 's children check gasoline price bear year $$$ i $$$ guarantee length path cities $$$ a_i $$$ $$$ b_i $$$ equal length path cities $$$ c_i $$$ $$$ d_i $$$ $$$ m $$$ line print one number number $$$ i $$$ line equal number ways set gasoline price cities king 's children bear years include $$$ i $$$ reveal violations <unknown> output number modulo $$$ 1000000000 + 7 $$$ consider first example birth first two sons price cities $$$ 1 $$$ $$$ 2 $$$ equal total 2 ways choose gasoline price cities $$$ 1 $$$ $$$ 2 $$$ fall within acceptable price range cities , ways set gasoline price : $$$ 6 \cdot 3 = 18 $$$ second pair sons check price paths $$$ 1 - 2 $$$ $$$ 2 - 1 $$$ mean gasoline price cities $$$ 1 $$$ $$$ 2 $$$ must match already do therefore birth second pair sons answer change way third pair sons check price track $$$ 3 - 1 - 2 - 4 $$$ $$$ 4 - 2 - 1 - 3 $$$ price non - gasoline city $$$ 3 $$$ equal price city $$$ 4 $$$ price city $$$ 1 $$$ equal price city $$$ 2 $$$ price cities $$$ 1 $$$ $$$ 2 $$$ already cities $$$ 3 $$$ $$$ 4 $$$ 2 ways choose price gasoline fall within acceptable price range cities , ways set gasoline price : $$$ 4 \cdot 1 = 4 $$$ fourth pair sons check price track $$$ 3 - 1 - 2 - 4 $$$ $$$ 3 - 1 - 2 - 5 $$$ mean price cities $$$ 4 $$$ $$$ 5 $$$ equal since price cities $$$ 3 $$$ $$$ 4 $$$ already coincide cities $$$ 3 $$$ $$$ 4 $$$ $$$ 5 $$$ price gasoline price gasoline city $$$ 3 $$$ 3 price gasoline city $$$ 5 $$$ less 4 . birth fourth pair sons ways set gasoline price check carry price require range",['data structures'],3000.0
342/E,xenia programmer a tree consist n nod consider tree nod index 1 n. also consider first node initially paint red nod — paint blue distance two tree nod v u number edge shortest path v u. xenia need learn quickly execute query two type : task write a program execute describe query first line contain two integers n m ( 2 ≤ n ≤ 105 1 ≤ m ≤ 105 ) — number nod tree number query next n - 1 line contain tree edge i - th line contain a pair integers ai bi ( 1 ≤ ai bi ≤ n ai ≠ bi ) — edge tree next m line contain query query specify a pair integers ti vi ( 1 ≤ ti ≤ 2 1 ≤ vi ≤ n ) ti = 1 a reply query need paint a blue node vi red ti = 2 reply query print shortest distance red node node vi guarantee give graph a tree query correct second type query print reply a single line,['data structures'],2400.0
1000/F,give array $$$ a $$$ consist $$$ n $$$ integers $$$ q $$$ query $$$ i $$$ -th query denote two integers $$$ l_i $$$ $$$ r_i $$$ query find integer occur exactly subarray $$$ a $$$ index $$$ l_i $$$ index $$$ r_i $$$ ( a subarray a contiguous subsegment array ) example $$$ a = [ 1 1 2 3 2 4 ] $$$ query $$$ ( l_i = 2 r_i = 6 ) $$$ subarray interest $$$ [ 1 2 3 2 4 ] $$$ possible answer $$$ 1 $$$ $$$ 3 $$$ $$$ 4 $$$ ; query $$$ ( l_i = 1 r_i = 2 ) $$$ subarray interest $$$ [ 1 1 ] $$$ element occur exactly answer query ? first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 500000 $$$ ) third line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 500000 $$$ ) $$$ q $$$ line follow $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ represent $$$ i $$$ -th query ( $$$ 1 \le l_i \le r_i \le n $$$ ) answer query follow : integer occur subarray index $$$ l_i $$$ index $$$ r_i $$$ exactly print $$$ 0 $$$ otherwise print integer,['data structures'],2400.0
1140/F,"a give set two - dimensional point $$$ s $$$ let 's denote <unknown> $$$ e ( s ) $$$ result follow algorithm : create another set two - dimensional point $$$ r $$$ initially equal $$$ s $$$ , exist four number $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ $$$ ( x_1 y_1 ) \in r $$$ $$$ ( x_1 y_2 ) \in r $$$ $$$ ( x_2 y_1 ) \in r $$$ $$$ ( x_2 y_2 ) \notin r $$$ add $$$ ( x_2 y_2 ) $$$ $$$ r $$$ impossible find four integers let $$$ r $$$ result algorithm problem give a set two - dimensional point $$$ s $$$ initially empty process two type query : add point $$$ s $$$ remove point query compute size $$$ e ( s ) $$$ first line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 300000 $$$ ) — number query $$$ q $$$ line follow contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \le x_i y_i \le 300000 $$$ ) denote $$$ i $$$ -th query follow : $$$ ( x_i y_i ) \in s $$$ erase $$$ s $$$ otherwise insert $$$ ( x_i y_i ) $$$ $$$ s $$$ print $$$ q $$$ integers $$$ i $$$ -th integer equal size $$$ e ( s ) $$$ process first $$$ i $$$ query",['data structures'],2600.0
1140/G,"give a special undirected graph consist $$$ 2n $$$ vertices number $$$ 1 $$$ $$$ 2n $$$ follow properties hold graph : graph represent two tree structure $$$ n $$$ edge connect vertex first tree correspond vertex second tree edge graph weight length simple path graph sum weight traverse edge give $$$ q $$$ query graph ; query ask compute length shortest path pair vertices graph answer query ? first line input contain one integer $$$ n $$$ ( $$$ 2 \le n \le 300000 $$$ ) second line contain $$$ n $$$ integers $$$ w _ { 1 2 } $$$ $$$ w _ { 3,4 } $$$ ... $$$ w _ { 2n - 1 2n } $$$ ( $$$ 1 \le w _ { i i + 1 } \le 10^ { 12 } $$$ ) integers describe weight edge connect odd vertices even ones $$$ n-1 $$$ line follow $$$ i $$$ -th line contain four integers $$$ x_i $$$ $$$ y_i $$$ $$$ w _ { i 1 } $$$ $$$ w _ { i 2 } $$$ ( $$$ 1 \le x_i y_i \le n $$$ $$$ x_i \ne y_i $$$ $$$ 1 \le w _ { i j } \le 10^ { 12 } $$$ ) ; describe two edge : one connect $$$ 2x_i - 1 $$$ $$$ 2y_i - 1 $$$ weight $$$ w _ { i 1 } $$$ ; another connect $$$ 2x_i $$$ $$$ 2y_i $$$ weight $$$ w _ { i 2 } $$$ next line contain one integer $$$ q $$$ ( $$$ 1 \le q \le <unknown> $$$ ) — number query $$$ q $$$ line follow $$$ i $$$ -th line contain two integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \le u_i v_i \le 2n $$$ $$$ u_i \ne v_i $$$ ) describe a query ` ` compute length shortest path vertices $$$ u_i $$$ $$$ v_i $$$ ` ` print $$$ q $$$ integers $$$ i $$$ -th integer equal answer $$$ i $$$ -th query graph first test look like :",['data structures'],2700.0
1156/E,give a permutation $$$ p $$$ $$$ n $$$ integers $$$ 1 $$$ $$$ 2 $$$ ... $$$ n $$$ ( a permutation array element $$$ 1 $$$ $$$ n $$$ occur exactly ) let 's call subsegment $$$ p [ l r ] $$$ permutation special $$$ <unknown> + <unknown> = \max \limits _ { i = l } ^ { r } p_i $$$ please calculate number special subsegments first line contain one integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) second line contain $$$ n $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) integers pairwise distinct print number special subsegments give permutation special subsegments first example $$$ [ 1 5 ] $$$ $$$ [ 1 3 ] $$$ special subsegment second example $$$ [ 1 3 ] $$$,['data structures'],2200.0
1190/D,$$$ n $$$ point plane $$$ i $$$ -th $$$ ( x_i y_i ) $$$ tokitsukaze want draw a strange rectangular area pick point area strange area enclose three line $$$ x = l $$$ $$$ y = a $$$ $$$ x = r $$$ leave side bottom side right side respectively $$$ l $$$ $$$ r $$$ $$$ a $$$ real number satisfy $$$ l < r $$$ upper side area <unknown> regard a line parallel $$$ x $$$ -axis infinity follow figure show a strange rectangular area a point $$$ ( x_i y_i ) $$$ strange rectangular area $$$ l < x_i < r $$$ $$$ y_i > a $$$ example figure $$$ p_1 $$$ area $$$ p_2 $$$ tokitsukaze want know many different non - empty set obtain pick point a strange rectangular area think two set different exist least one point one set first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 2 \times 100000 $$$ ) — number point plane $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \leq x_i y_i \leq 1000000000 $$$ ) — coordinate $$$ i $$$ -th point point distinct print a single integer — number different non - empty set point obtain first example exactly one set $$$ k $$$ point $$$ k = 1 2 3 $$$ total number $$$ 3 $$$ second example number set $$$ k $$$ point $$$ k = 1 2 3 $$$ $$$ 3 $$$ $$$ 2 $$$ $$$ 1 $$$ respectively sum $$$ 6 $$$ third example follow figure show <unknown> number different non - empty set example $$$ 2 + 3 + 0 + 1 = 6 $$$,['data structures'],2000.0
1217/F,give undirected graph $$$ n $$$ vertices number $$$ 1 $$$ $$$ n $$$ initially edge ask perform query graph let $$$ last $$$ answer latest query second type set $$$ 0 $$$ first query query follow : good luck ! first line contain two integer number $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n m \le 200000 $$$ ) — number vertices number query respectively follow $$$ m $$$ line contain a query one two aforementioned type guarantee least one query second type print a string consist character ' 0 ' ' 1 ' $$$ i $$$ -th character answer $$$ i $$$ -th query second type therefore length string equal number query second type convert query first example : convert query second example :,['data structures'],2600.0
1295/E,"give a permutation $$$ p_1 p_2 \dots p_n $$$ ( array integer $$$ 1 $$$ $$$ n $$$ appear exactly ) weight $$$ i $$$ -th element permutation $$$ a_i $$$ first separate permutation two non - empty set — prefix suffix formally first set contain elements $$$ p_1 p_2 \dots p_k $$$ second — $$$ p _ { k+1 } p _ { <unknown> } \dots p_n $$$ $$$ 1 \le k < n $$$ , may move elements set operation allow choose element first set move second set vice versa ( move second set first ) pay $$$ a_i $$$ dollars move element $$$ p_i $$$ goal make element first set less element second set note one set empty condition meet example $$$ p = [ 3 1 2 ] $$$ $$$ a = [ 7 1 4 ] $$$ optimal strategy : separate $$$ p $$$ two part $$$ [ 3 1 ] $$$ $$$ [ 2 ] $$$ move $$$ 2 $$$ -element first set ( cost $$$ 4 $$$ ) $$$ p = [ 3 5 1 6 2 4 ] $$$ $$$ a = [ 9 1 9 9 1 9 ] $$$ optimal strategy : separate $$$ p $$$ two part $$$ [ 3 5 1 ] $$$ $$$ [ 6 2 4 ] $$$ move $$$ 2 $$$ -element first set ( cost $$$ 1 $$$ ) $$$ 5 $$$ -element second set ( also cost $$$ 1 $$$ ) calculate minimum number dollars spend first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — length permutation second line contain $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1 \le p_i \le n $$$ ) 's guarantee sequence contain element $$$ 1 $$$ $$$ n $$$ exactly third line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) print one integer — minimum number dollars spend",['data structures'],2200.0
1139/F,$$$ m $$$ people live a city $$$ n $$$ dish sell city dish $$$ i $$$ a price $$$ p_i $$$ a standard $$$ s_i $$$ a beauty $$$ b_i $$$ person $$$ j $$$ income $$$ inc_j $$$ a prefer beauty $$$ pref_j $$$ a person would never buy a dish whose standard less person 's income also a person ca n't <unknown> a dish a price greater income person word a person $$$ j $$$ buy a dish $$$ i $$$ $$$ p_i \leq inc_j \leq s_i $$$ also a person $$$ j $$$ buy a dish $$$ i $$$ $$$ <unknown> - <unknown> \leq ( inc_j - p_i ) $$$ word price dish less person 's income $$$ k $$$ person allow absolute difference $$$ k $$$ beauty dish his / her prefer beauty print number dish buy person city first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ 1 \leq m \leq 100000 $$$ ) number dish available city number people live city second line contain $$$ n $$$ integers $$$ p_i $$$ ( $$$ 1 \leq p_i \leq 1000000000 $$$ ) price dish third line contain $$$ n $$$ integers $$$ s_i $$$ ( $$$ 1 \leq s_i \leq 1000000000 $$$ ) standard dish fourth line contain $$$ n $$$ integers $$$ b_i $$$ ( $$$ 1 \leq b_i \leq 1000000000 $$$ ) beauty dish fifth line contain $$$ m $$$ integers $$$ inc_j $$$ ( $$$ 1 \leq inc_j \leq 1000000000 $$$ ) income every person sixth line contain $$$ m $$$ integers $$$ pref_j $$$ ( $$$ 1 \leq pref_j \leq 1000000000 $$$ ) prefer beauty every person guarantee integers $$$ i $$$ $$$ 1 $$$ $$$ n $$$ follow condition hold : $$$ p_i \leq s_i $$$ print $$$ m $$$ integers number dish buy every person live city first example first person buy dish $$$ 2 $$$ second person buy dish $$$ 1 $$$ $$$ 2 $$$ third person buy dish second example first person buy dish second person buy dish $$$ 1 $$$ $$$ 4 $$$ third person buy dish $$$ 1 $$$ $$$ 2 $$$ $$$ 4 $$$,['data structures'],2500.0
1042/D,"petya array $$$ a $$$ consist $$$ n $$$ integers learn <unknown> sum recently calculate sum elements segment array really fast segment a non - empty sequence elements stand one next another array wonder number segment array sum less $$$ t $$$ help petya calculate number formally require calculate number pair $$$ l r $$$ ( $$$ l \le r $$$ ) $$$ a_l + a _ { l+1 } + \dots + a _ { r-1 } + a_r < t $$$ first line contain two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 200\,000 |t| \le 2\cdot10^ { 14 } $$$ ) second line contain a sequence integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ |a _ { i } | \le 10^ { 9 } $$$ ) — description petya 's array note might negative zero positive elements print number segment petya 's array sum elements less $$$ t $$$ first example follow segment sum less $$$ 4 $$$ :",['data structures'],1800.0
1621/I,consider array integers $$$ c = [ c_1 c_2 \ldots c_n ] $$$ length $$$ n $$$ let 's build sequence array $$$ <unknown> d_1 d_2 \ldots d _ { n } $$$ length $$$ n+1 $$$ follow way : array $$$ x $$$ subarray array $$$ y $$$ $$$ x $$$ obtain deletion several ( possibly zero ) elements begin $$$ y $$$ several ( possibly zero ) elements end $$$ y $$$ array $$$ c $$$ let 's denote array $$$ d_n $$$ $$$ op ( c ) $$$ alice array integers $$$ a = [ a_1 a_2 \ldots a_n ] $$$ length $$$ n $$$ build sequence array $$$ b_0 b_1 \ldots b_n $$$ length $$$ n+1 $$$ follow way : ask $$$ q $$$ query elements sequence array $$$ b_0 b_1 \ldots b_n $$$ query consist two integers $$$ i $$$ $$$ j $$$ answer query value $$$ j $$$ -th element array $$$ b_i $$$ first line contain single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100000 $$$ ) — length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq n $$$ ) — array $$$ a $$$ third line contain single integer $$$ q $$$ ( $$$ 1 \leq q \leq 1000000 $$$ ) — number query next $$$ q $$$ line contain two integers $$$ i $$$ $$$ j $$$ ( $$$ 1 \leq i j \leq n $$$ ) — parameters query output $$$ q $$$ integers : value $$$ b _ { i j } $$$ require $$$ i $$$ $$$ j $$$ first test case $$$ b_0 = a = [ 2 1 3 1 ] $$$ $$$ b_1 $$$ construct follow way :,['data structures'],3500.0
666/E,country <unknown> <unknown> berland recently <unknown> berland <unknown> a reberlandian spy try bring leaflets intend <unknown> <unknown> berland <unknown> leaflets contain substrings absolutely inadmissible swearword maybe even whole word berland <unknown> system use difficult algorithm order determine <unknown> spy main part algorithm follow procedure m leaflets bring spy number 1 m. 's need get answer q query follow kind : ` ` leaflet segment number [ l r ] substring absolutely inadmissible swearword [ pl pr ] occur often ? ` ` expert want <unknown> procedure time texts leaflets long help ! first line contain string s ( 1 ≤ |s| ≤ 5·105 ) — absolutely inadmissible swearword string s consist lowercase english letter second line contain integer m ( 1 ≤ m ≤ 5·104 ) — number texts leaflets expertise next m line contain string ti — text i - th leaflet sum lengths leaflet texts n't exceed 5·104 text leaflets consist lowercase english letter next line contain integer q ( 1 ≤ q ≤ 5·105 ) — number query expertise finally last q line contain four integers l r pl pr ( 1 ≤ l ≤ r ≤ m 1 ≤ pl ≤ pr ≤ |s| ) |s| length absolutely inadmissible swearword print q line i - th contain two integers — number text occurences number occurences substring [ pl pr ] string s. several text number print smallest one,['data structures'],3100.0
741/E,us know girls arpa ’ s land ... ok ’ get idea : <unknown> know arpa n't a normal man ... well <unknown> i ca n't explain mehrdad interest reason ask sipa one best biology scientists arpa 's land help sipa a dna editor sipa put arpa dna editor dna editor show arpa 's dna a string s consist n lowercase english letter also sipa another dna t consist lowercase english letter belong a normal man ( n + 1 ) options change arpa 's dna number 0 n. i - th put t i - th ( i + 1 ) -th character s ( 0 ≤ i ≤ n ) i = 0 t put s i = n put s. mehrdad want choose interest option arpa 's dna among n + 1 options dna a interest b a lexicographically smaller b. mehrdad ask sipa q question : give integers l r k x y interest option consider options i l ≤ i ≤ r ? several interest options mehrdad want know one smallest number i. since sipa a biology scientist a programmer help first line contain string s t integer q ( 1 ≤ |s| |t| q ≤ 105 ) — arpa 's dna dna a normal man number mehrdad 's question string s t consist small english letter next q line describe mehrdad 's question line contain five integers l r k x y ( 0 ≤ l ≤ r ≤ n 1 ≤ k ≤ n 0 ≤ x ≤ y < k ) print q integers j - th number i interest option among satisfy condition j - th question option i satisfy condition question print -1 . explanation first sample case : first question sipa two options : <unknown> ( i = 0 ) abdc ( i = 2 ) latter ( abcd ) better abdc answer 2 . last question i 0 ≤ i ≤ 1,['data structures'],3400.0
1037/H,program website establish a secure communication protocol security reason want choose several less random string initially a string $$$ s $$$ consist lowercase english letter want choose $$$ q $$$ string use follow step help string $$$ a $$$ lexicographically less string $$$ b $$$ either $$$ a $$$ a prefix $$$ b $$$ $$$ a \ne b $$$ exist a position $$$ i $$$ ( $$$ 1 \le i \le min ( |a| |b| ) $$$ ) $$$ a_i < b_i $$$ $$$ j $$$ ( $$$ 1 \le j < i $$$ ) $$$ a_j = b_j $$$ $$$ |a| $$$ denote length string $$$ a $$$ first line input contain a non - empty string $$$ s $$$ ( $$$ 1 \leq |s| \leq 10^ { 5 } $$$ ) consist lowercase english letter second line contain integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number string select next $$$ q $$$ line contain two integers $$$ l $$$ $$$ r $$$ ( $$$ 1 \leq l \leq r \leq |s| $$$ ) a non - empty string $$$ x $$$ consist lowercase english letter total length string $$$ x $$$ query exceed $$$ 2 \cdot 10^ { 5 } $$$ output $$$ q $$$ line contain desire string $$$ -1 $$$ string consider first example string $$$ s $$$ ` ` baa '' query follow,['data structures'],3200.0
1073/G,let $$$ \text { lcp } ( s t ) $$$ length longest common prefix string $$$ s $$$ $$$ t $$$ also let $$$ s [ x \dots y ] $$$ substring $$$ s $$$ index $$$ x $$$ index $$$ y $$$ ( inclusive ) example $$$ s = $$$ ` ` abcde '' $$$ s [ 1 \dots 3 ] = $$$ ` ` abc '' $$$ s [ 2 \dots 5 ] = $$$ ` ` <unknown> '' give a string $$$ s $$$ length $$$ n $$$ $$$ q $$$ query query a pair integer set $$$ a_1 a_2 \dots a_k $$$ $$$ b_1 b_2 \dots <unknown> $$$ calculate $$$ \sum\limits _ { i = 1 } ^ { i = k } \sum\limits _ { j = 1 } ^ { j = l } { \text { lcp } ( s [ a_i \dots n ] s [ b_j \dots n ] ) } $$$ query first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n q \le 200000 $$$ ) — length string $$$ s $$$ number query respectively second line contain a string $$$ s $$$ consist lowercase latin letter ( $$$ |s| = n $$$ ) next $$$ <unknown> $$$ line contain descriptions query — three line per query first line query contain two integers $$$ k_i $$$ $$$ l_i $$$ ( $$$ 1 \le k_i l_i \le n $$$ ) — size set $$$ a $$$ $$$ b $$$ respectively second line query contain $$$ k_i $$$ integers $$$ a_1 a_2 \dots a _ { k_i } $$$ ( $$$ 1 \le a_1 < a_2 < \dots < a _ { k_i } \le n $$$ ) — set $$$ a $$$ third line query contain $$$ l_i $$$ integers $$$ b_1 b_2 \dots b _ { l_i } $$$ ( $$$ 1 \le b_1 < b_2 < \dots < b _ { l_i } \le n $$$ ) — set $$$ b $$$ guarantee $$$ \sum\limits _ { i = 1 } ^ { i = q } { k_i } \le 200000 $$$ $$$ \sum\limits _ { i = 1 } ^ { i = q } { l_i } \le 200000 $$$ print $$$ q $$$ integers — answer query order query give input description query :,['data structures'],2600.0
356/A,"<unknown> ! berl ii king berland make a knight tournament king already send message knight kingdom turn agree participate grand event , 're a simple <unknown> 's surprise sleep morning late tournament ( a weekend ) really curious result tournament time tournament berland go follow : fish information fight friends knight want know name knight conquer think knight number b conquer knight number a a fight knight present winner knight number a. write code calculate knight name knight beat first line contain two integers n m ( 2 ≤ n ≤ 3·105 ; 1 ≤ m ≤ 3·105 ) — number knight number fight follow m line contain three integers li ri xi ( 1 ≤ li < ri ≤ n ; li ≤ xi ≤ ri ) — description i - th fight guarantee input correct match problem statement guarantee least two knight take part battle print n integers i - th knight lose i - th number equal number knight beat knight number i. i - th knight winner i - th number must equal 0 . consider first test case knight 1 2 fight first fight knight 1 knight 1 3 fight second fight knight 3 last fight knight 3 4 knight 4",['data structures'],1500.0
566/D,"even successful company go a crisis period make a hard decision — <unknown> discard merge departments fire employees unpleasant stuff let 's consider follow model a company n people work large software company person belong department initially person work project department ( thus company initially consist n departments one person ) however harsh time come company management hire a crisis manager would rebuild work process order boost efficiency let 's use team ( person ) represent a team person person work a crisis manager make decisions two type : crisis manager sometimes wonder whether employees x y ( 1 ≤ x y ≤ n ) work department help crisis manager answer query first line input contain two integers n q ( 1 ≤ n ≤ 200 000 1 ≤ q ≤ 500 000 ) — number employees company number query crisis manager next q line contain query crisis manager query look like type x y , type = 1 type = 2 query represent decision a crisis manager merge departments first second type respectively type = 3 task determine whether employees x y work department note x equal y query type question type 3 print ` ` yes '' ` ` '' ( without quote ) depend whether correspond people work department",['data structures'],1900.0
722/C,"give array consist n non - negative integers a1 a2 ... , go destroy integers array one one thus give permutation integers 1 n define order elements array destroy element destroy find segment array contain destroy elements sum elements maximum possible sum elements empty segment consider 0 . first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — length array second line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 109 ) third line contain a permutation integers 1 n — order use destroy elements print n line i - th line contain a single integer — maximum possible sum elements segment contain destroy elements first i operations perform consider first sample :",['data structures'],1600.0
896/E,— i ... i <unknown> . — <unknown> home chtholly . — i keep promise ... — i make ... i really make ! several days fight chtholly <unknown> seniorious <unknown> return <unknown> battle promise willem bake butter cake however although willem <unknown> make <unknown> <unknown> bake butter cake time willem make a big mistake — accidentally break <unknown> ! fortunately chtholly decide help willem put n cake a roll cake number 1 n i - th cake need ai second bake willem need chtholly m operations bake cake operation 1 : 1 l r xwillem ask chtholly check cake range [ l r ] cake need bake x second would bake x second put back place precisely every i range [ l r ] ai strictly x ai become equal ai - x. operation 2 : 2 l r xwillem ask chtholly count number cake range [ l r ] need cook exactly x second formally find number i range [ l r ] ai = x. first line contain two integers n m ( 1 ≤ n m ≤ 105 ) second line contain n integers i - th ai ( 1 ≤ ai ≤ 105 ) next m line m operations describe guarantee 1 ≤ l ≤ r ≤ n 1 ≤ x ≤ 105 . operation second type print answer,['data structures'],3100.0
1044/D,"array $$$ a $$$ $$$ 2^ { 30 } $$$ integers index $$$ 0 $$$ $$$ 2^ { 30 } -1 $$$ initially know $$$ 0 \leq a_i < 2^ { 30 } $$$ ( $$$ 0 \leq i < 2^ { 30 } $$$ ) know value task process query two type : note query encode , need write online solution first line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 200000 $$$ ) — number query next $$$ q $$$ line describe a query contain one integer $$$ t $$$ ( $$$ 1 \leq t \leq 2 $$$ ) — type query give query encode follow way : let $$$ last $$$ answer last query second type answer ( initially $$$ last = 0 $$$ ) last answer $$$ -1 $$$ set $$$ last = 1 $$$ .and $$$ l > r $$$ swap $$$ l $$$ $$$ r $$$ mean get update bitwise xor subarray $$$ [ l r ] $$$ equal $$$ x $$$ ( notice need ignore update contradict previous update ) .and $$$ l > r $$$ swap $$$ l $$$ $$$ r $$$ give query need print bitwise xor subarray $$$ [ l r ] $$$ impossible know print $$$ -1 $$$ n't forget change value $$$ last $$$ guarantee least one query second type every query second type output bitwise xor give subarray $$$ -1 $$$ still impossible know first example real query ( without encode ) : second example notice first two update already know $$$ <unknown> \oplus <unknown> = 12 $$$ third update contradict ignore",['data structures'],2400.0
1725/K,pak chanek visit a kingdom earn a <unknown> ` ` kingdom criticism '' often residents criticise aspect kingdom one aspect often criticise heights build kingdom $$$ n $$$ build initially build $$$ i $$$ a height $$$ a_i $$$ units point time residents give a new criticism namely currently like build heights $$$ l $$$ $$$ r $$$ units inclusive two integers $$$ l $$$ $$$ r $$$ know $$$ r - l $$$ always odd $$$ 1 $$$ minute kingdom 's construction team increase decrease height build $$$ 1 $$$ unit long height still become a positive number time receive current criticism residents kingdom 's construction team make build heights $$$ l $$$ $$$ r $$$ units inclusive minimum time possible obtain one way note construction team care current criticism residents previous <unknown> forget $$$ q $$$ query must solve query one three follow possibilities : note change height still <unknown> next query first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 400000 $$$ ) — number build kingdom second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — initial heights build next line contain a single integer $$$ q $$$ ( $$$ 1 \leq q \leq 400000 $$$ ) — number query $$$ j $$$ -th next $$$ q $$$ line contain $$$ j $$$ -th query describe least one query type $$$ 2 $$$ query type $$$ 2 $$$ output a line contain integer represent height build ask $$$ 1 $$$ -st query height build $$$ 2 6 5 6 10 $$$ $$$ 3 $$$ -rd query height build $$$ 3 6 5 6 10 $$$ $$$ 4 $$$ -th query height build $$$ 2 7 7 7 10 $$$ $$$ 5 $$$ -th query height build $$$ 2 7 7 7 10 $$$ $$$ 6 $$$ -th query height build $$$ 2 9 7 7 10 $$$,['data structures'],2500.0
471/E,polar bear menshykov uslada zoo st . petersburg elephant horace zoo kiev decide paint try create first masterpiece make a draft a piece paper draft consist n segment segment either horizontal vertical friends want simplify draft delete segment part segment final masterpiece meet three condition : part draft already beautiful friends decide delete part draft sum lengths remain segment large possible task count maximum sum lengths remain extra segment remove first line input contain integer n ( 1 ≤ n ≤ 2·105 ) — number segment draft next n line contain four integers : x1 y1 x2 y2 ( - 109 ≤ x1 ≤ x2 ≤ 109 ; - 109 ≤ y1 ≤ y2 ≤ 109 ) — two <unknown> two endpoint coordinate a segment segment non - <unknown> either strictly horizontal strictly vertical two horizontal segment share common point two vertical segment share common point print a single integer — maximum sum lengths remain segment shape get two give sample : first sample need delete segment two segment together form a single connect shape second sample initial segment form a cycle four ways break cycle : delete first second fourth segment <unknown> delete middle third segment last way show picture,['data structures'],2700.0
1578/B,"$$$ n $$$ villages lie <unknown> a circle middle a <unknown> impassable forest ancient time impossible move one village another technical progress change a lot , a technology build passable trail forest build process consist $$$ m $$$ events event either build a trail query two villages connect trail build straight line connect two villages a trail build anybody walk along trail one village another moreover two trail cross anybody turn intersection trail leave a village reach also use walk along , example villages number $$$ 1 $$$ $$$ 6 $$$ order around circle trail $$$ 1 $$$ $$$ 3 $$$ $$$ 2 $$$ $$$ 4 $$$ $$$ 4 $$$ $$$ 6 $$$ villages except $$$ 5 $$$ -th reachable $$$ 1 $$$ -st village give a list $$$ m $$$ events query find two give villages reachable moment first line contain two integers $$$ n $$$ ( $$$ 2 \le n \le 2\cdot 100000 $$$ ) $$$ m $$$ ( $$$ 1 \le m \le 3\cdot 100000 $$$ ) — number villages number events respectively next $$$ m $$$ line contain events event description consist three integers $$$ e $$$ ( $$$ e $$$ $$$ 1 $$$ $$$ 2 $$$ ) $$$ v $$$ ( $$$ 1 \le v \le n $$$ ) $$$ u $$$ ( $$$ 1 \le u \le n $$$ $$$ u \ne v $$$ ) $$$ e = 1 $$$ event build a trail villages $$$ v $$$ $$$ u $$$ $$$ e = 2 $$$ event a query villages $$$ v $$$ $$$ u $$$ connect guarantee trail build villages number $$$ 1 $$$ $$$ n $$$ clockwise order around circle query print one character ' 0 ' villages reachable ' 1 ' villages reachable print answer query a single string one line",['data structures'],2800.0
13/E,"little petya like play a lot like play a game « hole » a game one person follow rule : n hole locate a single row number leave right number 1 n. hole 's power ( hole number i power ai ) throw a ball hole i immediately jump hole i + ai jump hole number ball jump row m move player perform one two action : petya good math , already guess perform <unknown> first line contain two integers n m ( 1 ≤ n ≤ 105 1 ≤ m ≤ 105 ) — number hole a row number move second line contain n positive integers exceed n — initial value hole power follow m line describe move make petya line one two type : move type 1 output two space - separated number a separate line — number last hole ball visit leave row number jump make",['data structures'],2700.0
61/E,romans attack time much <unknown> shapur ready defeat say : ` ` a <unknown> never afraid a <unknown> <unknown> '' nevertheless shapur find <unknown> roman army defeat give army a weakness number shapur 's <unknown> weakness army equal number triplets i j k i < j < k ai > aj > ak ax power man stand position x. roman army one special trait — power people distinct help shapur find weak romans first line input contain a single number n ( 3 ≤ n ≤ 106 ) — number men roman army next line contain n different positive integers ai ( 1 ≤ i ≤ n 1 ≤ ai ≤ 109 ) — power men roman army a single integer number weakness roman army please use % lld specificator read write 64 - bit integers c++ preffered use cout ( also may use % i64d ),['data structures'],1900.0
165/D,"let 's define a non - oriented connect graph n vertices n - 1 edge a beard vertices except perhaps one degree 2 1 ( exist one vertex whose degree two ) let us remind degree a vertex number edge connect let edge either black white initially edge black give description beard graph task analyze request follow type : vertices number integers 1 n edge number integers 1 n - 1 . first line input contain integer n ( 2 ≤ n ≤ 105 ) — number vertices graph next n - 1 line contain edge describe number vertices vi ui ( 1 ≤ vi ui ≤ n vi ≠ ui ) connect edge guarantee give graph connect form a beard graph self - loops multiple edge next line contain integer m ( 1 ≤ m ≤ 3·105 ) — number request next m line contain request follow form : first a line contain integer type take value <unknown> 1 3 represent request type type = 1 current request a request paint edge black case addition number type line contain integer i d ( 1 ≤ i d ≤ n - 1 ) represent number edge paint type = 2 current request a request paint edge white form similar previous request type = 3 current request a request find distance case addition type line contain two integers a b ( 1 ≤ a b ≤ n a equal b ) — number vertices distance must find number line separate exactly one space edge number order give input request ` ` find distance vertices a b '' print result path go along black edge vertices a b print ` ` -1 '' ( without quote ) print result order receive request separate number space line break first sample vertices 1 2 connect edge number 1 vertices 2 3 connect edge number 2 . repaint edge number 2 vertex reachable one along black edge specifically shortest path 1 3 go along edge paint edge number 2 white vertex 3 end cut vertices , path exist vertex along black edge",['data structures'],2100.0
217/E,"professor bajtocy conduct experiment alien dna discover subject <unknown> mutations — mutation happen way : continuous subsequence alien dna become active copy copy get mangle insert right original subsequence mangle copy activate continuous subsequence form first join elements even position subsequence join elements odd ones end , activate subsequence consist 11 elements represent s1s2 ... <unknown> mangle copy <unknown> example original sequence ` ` <unknown> '' mutation happen segment [ 2 4 ] ( activate subsequence ` ` <unknown> '' ) mutate dna : ` ` <unknown> '' mangle copy activate subsequence mark bold <unknown> professor bajtocy write original dna sequence mutations sequentially happen ask recover first k elements dna sequence mutations first line input contain original dna sequence consist letter ` ` a '' ` ` c '' ` ` t '' ` ` g '' exceed 3·106 length second line contain a single integer k ( 1 ≤ k ≤ 3·106 ) third line contain a single integer n ( 0 ≤ n ≤ 5000 ) — number mutations next n line describe mutations chronological order — mutation describe two number li ri ( 1 ≤ li ≤ ri ≤ 109 ) mean continuous subsequence [ li ri ] become active <unknown> join mangle copy guarantee input data correct , mutation act non - <unknown> elements dna sequence result dna sequence least k elements assume dna elements index start 1 notation [ l r ] mean continuous subsequence dna sequence consist r - l + 1 elements start l - th dna sequence element end r - th dna sequence element output a single line contain first k letter mutate dna sequence second example first mutation sequence ` ` <unknown> '' second mutation 's ` ` <unknown> ''",['data structures'],2800.0
226/E,berland feudal own exactly one castle castle belong exactly one feudal feudal except one ( king ) subordinate another feudal a feudal number <unknown> ( subordinate ) castle connect roads allow move along roads ways two castle a road owner one castle a direct subordinate owner year exactly one two events may happen berland let 's consider second event detail journey a b short knight might want stop a castle encounter way rest however ca n't stop castle : <unknown> n't let stay castle desecrate enemy 's <unknown> a castle desecrate attack year y. knight choose k - th castle encounter start a ( castle a b n't take consideration ) n't attack years y + 1 till current year knight n't remember castle attack years ask <unknown> <unknown> <unknown> help ' ve get a sequence events berland history tell knight city stop else deliver sad news — path city a city b less k cities meet requirements knight wo n't able rest first input line contain integer n ( 2 ≤ n ≤ 105 ) — number feudals next line contain n space - separated integers : i - th integer show either number i - th feudal 's master a 0 i - th feudal king third line contain integer m ( 1 ≤ m ≤ 105 ) — number query follow m line describe events i - th line ( line index start 1 ) contain description event occur year i. event characterise type ti ( 1 ≤ ti ≤ 2 ) description first type event look two space - separated integers ti ci ( ti = 1 ; 1 ≤ ci ≤ n ) ci number castle attack <unknown> i - th year description second type contain five space - separated integers : ti ai bi ki yi ( ti = 2 ; 1 ≤ ai bi ki ≤ n ; ai ≠ bi ; 0 ≤ yi < i ) ai number castle knight set bi number castle knight go ki yi k y second event 's description consider feudals index 1 n. guarantee one king among feudals guarantee first type events value ci different second type event print integer — number castle knight must stay rest -1 cover distance ai bi without a rest separate answer whitespaces print answer order second type events give input first sample castle 2 knight 's way castle 1 castle 3 . knight cover path 1 - 3 first time castle 2 wo n't desecrate enemy knight stay second year castle 2 become desecrate knight wo n't anywhere stay next two years ( find a castle n't desecrate years 1 2 correspondingly important ) fifth year knight wo n't consider castle 2 desecrate stay,['data structures'],2900.0
482/E,a root tree contain n vertexes let 's number tree vertexes integers 1 n. tree root vertex 1 . vertex ( except <unknown> tree root ) v a direct ancestor <unknown> also vertex v integer value <unknown> task perform follow query : task follow start perform query query calculate expect value write lowest common ancestor two equiprobably select vertices i j. lowest common ancestor i j deepest vertex lie path root vertex i path root vertex j. please note vertices i j ( case lowest common ancestor coincide ) first line input contain integer n ( 2 ≤ n ≤ 5·104 ) — number tree vertexes second line contain n - 1 integer p2 p3 ... pn ( 1 ≤ pi ≤ n ) — description tree edge guarantee number form a tree third line contain n integers — s1 s2 ... sn ( 0 ≤ si ≤ 106 ) — value write vertex tree next line contain integer q ( 1 ≤ q ≤ 5·104 ) — number query follow q line contain description query format describe statement guarantee query arguments u v lie 1 n. guarantee argument t query type v meet limit 0 ≤ t ≤ 106 . print q + 1 number — correspond expect value answer consider correct absolute relative error n't exceed 10 - 9 . note query p v u u lie subtree v must perform assignment <unknown> = v. example case last query sample,['data structures'],3200.0
587/C,recently duff a soldier army malek commander country andarz gu n cities ( number 1 n ) n - 1 bidirectional roads road connect two different cities exist a unique path two cities also m people live andarz gu ( number 1 m ) person i d number i d number i - th person i he / she live city number ci note may one person a city also may people live city malek love order 's ask duff answer q query query give number v u a. answer a query : assume x people live cities lie path city v city u. assume people 's ids p1 p2 ... px increase order k = min ( x a ) duff tell malek number k p1 p2 ... pk order word malek want know a minimums path ( less less a people ) duff busy moment ask help answer query first line input contain three integers n m q ( 1 ≤ n m q ≤ 105 ) next n - 1 line contain roads line contain two integers v u endpoints a road ( 1 ≤ v u ≤ n v ≠ u ) next line contain m integers c1 c2 ... cm separate space ( 1 ≤ ci ≤ n 1 ≤ i ≤ m ) next q line contain query contain three integers v u a ( 1 ≤ v u ≤ n 1 ≤ a ≤ 10 ) query print number k p1 p2 ... pk separate space one line graph andarz gu sample case follow ( i d people city write next ) :,['data structures'],2200.0
1234/F,give a string $$$ s $$$ consist first $$$ 20 $$$ lowercase latin letter ( ' a ' ' b ' ... ' t ' ) recall substring $$$ s [ l ; r ] $$$ string $$$ s $$$ string $$$ s_l s _ { l + 1 } \dots s_r $$$ example substrings ` ` codeforces '' ` ` code '' ` ` force '' ` ` f '' ` ` '' ` ` coder '' ` ` top '' perform follow operation : choose substring $$$ s [ l ; r ] $$$ reverse ( i.e string $$$ s_l s _ { l + 1 } \dots s_r $$$ become $$$ s_r s _ { r - 1 } \dots s_l $$$ ) goal maximize length maximum substring $$$ s $$$ consist distinct ( i.e unique ) character string consist distinct character character string appear example string ` ` abcde '' ` ` <unknown> '' ` ` minecraft '' consist distinct character string ` ` codeforces '' ` ` abacaba '' consist distinct character line input contain one string $$$ s $$$ consist $$$ 1000000 $$$ character ' a ' ' b ' ... ' t ' ( first $$$ 20 $$$ lowercase latin letter ) print one integer — maximum possible length maximum substring $$$ s $$$ consist distinct character reverse one substring,['dp'],2200.0
1322/D,a popular reality show recruit a new cast third season ! $$$ n $$$ candidates number $$$ 1 $$$ $$$ n $$$ interview candidate $$$ i $$$ aggressiveness level $$$ l_i $$$ recruit candidate cost show $$$ s_i $$$ roubles show host <unknown> applications candidates $$$ i=1 $$$ $$$ i = n $$$ increase indices decide whether recruit candidate aggressiveness level candidate $$$ i $$$ strictly higher already accept candidates candidate $$$ i $$$ definitely reject otherwise host may accept reject candidate <unknown> host want choose cast maximize total profit show make revenue follow aggressiveness level $$$ v $$$ a correspond profitability value $$$ <unknown> $$$ specify positive well negative recruit participants enter stage one one increase indices participant $$$ i $$$ enter stage events proceed follow : allow select empty set participants ( choose neither candidates ) host want recruit cast total profit maximize profit calculate total revenue events stage less total expense recruit accept participants ( total $$$ s_i $$$ ) help host make show profitable possible first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 2000 $$$ ) — number candidates upper bind initial aggressiveness level second line contain $$$ n $$$ integers $$$ l_i $$$ ( $$$ 1 \le l_i \le m $$$ ) — initial aggressiveness level candidates third line contain $$$ n $$$ integers $$$ s_i $$$ ( $$$ 0 \le s_i \le 5000 $$$ ) — cost ( roubles ) recruit candidates fourth line contain $$$ n + m $$$ integers $$$ c_i $$$ ( $$$ <unknown> \le 5000 $$$ ) — profitability <unknown> level guarantee aggressiveness level participant never exceed $$$ n + m $$$ give condition print a single integer — largest profit show first sample case optimal recruit candidates $$$ 1 2 3 5 $$$ show pay $$$ 1 + 2 + 1 + 1 = 5 $$$ roubles <unknown> events stage proceed follow : total revenue show $$$ 4 + 3 + 1 + 1 + <unknown> $$$ roubles profit $$$ 11 - 5 = 6 $$$ roubles second sample case impossible recruit candidates since second one higher aggressiveness thus better recruit candidate $$$ 1 $$$,['dp'],2800.0
1450/G,please pay attention unusual memory limit problem a parallel universe <unknown> call ` ` trygub '' reason letter <unknown> delete alphabet ancient time government $$$ n $$$ workers stand a row number integers $$$ 1 $$$ $$$ n $$$ leave right job categories represent a string $$$ s $$$ length $$$ n $$$ character $$$ s_i $$$ represent job category $$$ i $$$ -th worker a new law approve increase <unknown> workers government decide make everyone job category perform follow operation number time ( possibly zero ) a fix rational parameter $$$ <unknown> ab $$$ describe easy convince public use determine success operation operation government first select a job category $$$ x $$$ least one worker current moment suppose $$$ i_1 \ldots i_m $$$ ( $$$ i_1 < \ldots < i_m $$$ ) position workers job category $$$ x $$$ $$$ <unknown> ( i_m - i_1 + 1 ) \le m $$$ government able choose job category $$$ y $$$ least one worker current moment change job category workers job category $$$ x $$$ job category $$$ y $$$ possible make workers job category $$$ x $$$ say $$$ x $$$ obtainable tell government set obtainable job categories ? first line contain three integers $$$ n a b $$$ ( $$$ 1 \le n \le 5000 $$$ $$$ 1\le a\le b\le 100000 $$$ ) — number workers <unknown> <unknown> parameter $$$ k $$$ respectively second line contain a string $$$ s $$$ length $$$ n $$$ consist lowercase english character — job categories worker character ' t ' ' r ' ' y ' ' g ' ' u ' ' b ' appear string $$$ s $$$ print integer $$$ c $$$ equal number obtainable job categories follow $$$ c $$$ space - separated character — obtainable job categories sort lexicographical order first operation must select job category ' i ' job categories satisfy condition therefore ' i ' obtainable show obtain ' c ' ' m ' ' o ' square bracket denote segment contain workers select category red color denote category blue color denote new category change,['dp'],3500.0
1497/D,please note non - standard memory limit $$$ n $$$ problems number integers $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th problem complexity $$$ c_i = 2^i $$$ tag $$$ tag_i $$$ score $$$ s_i $$$ solve problem $$$ i $$$ 's allow solve problem $$$ j $$$ $$$ \text { iq } < |c_i - c_j| $$$ $$$ tag_i \neq <unknown> $$$ solve $$$ \text { iq } $$$ change become $$$ \text { iq } = |c_i - c_j| $$$ gain $$$ <unknown> - <unknown> $$$ point problem first solve problems order many time want initially $$$ \text { iq } = 0 $$$ find maximum number point earn first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 100 ) $$$ — number test case first line test case contain integer $$$ n $$$ $$$ ( 1 \le n \le 5000 ) $$$ — number problems second line test case contain $$$ n $$$ integers $$$ <unknown> <unknown> \ldots <unknown> $$$ $$$ ( 1 \le tag_i \le n ) $$$ — tag problems third line test case contain $$$ n $$$ integers $$$ s_1 s_2 \ldots s_n $$$ $$$ ( 1 \le s_i \le 1000000000 ) $$$ — score problems 's guarantee sum $$$ n $$$ test case exceed $$$ 5000 $$$ test case print a single integer — maximum number point earn first test case optimal sequence solve problems follow : second test case optimal sequence solve problems follow : third test case optimal sequence solve problems follow :,['dp'],2500.0
1523/F,"william do work day enjoy play favorite video game game happen a 2d world start turn $$$ 0 $$$ william pick cell game world <unknown> , turn william may remain current location move current location ( x y ) one follow locations : ( x + 1 y ) ( x - 1 y ) ( x y + 1 ) ( x y - 1 ) accelerate movement game $$$ n $$$ fast travel tower $$$ i $$$ -th tower locate location ( $$$ xa_i ya_i $$$ ) able instantly travel tower location game world must first activate <unknown> tower $$$ i $$$ happen moment player cell ( $$$ xa_i ya_i $$$ ) tower remain active throughout entire game william also know game $$$ m $$$ quest $$$ i $$$ -th quest complete instantly location ( $$$ xb_i yb_i $$$ ) turn $$$ t_i $$$ william want find maximal number quest able complete optimally traverse game world first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 0 \le n \le 14 1 \le m \le 100 $$$ ) number tower number quest respectively next $$$ n $$$ line contain two integers $$$ xa_i ya_i $$$ ( $$$ 1 \le xa_i ya_i \le 1000000 $$$ ) coordinate fast travel tower next $$$ m $$$ line contain two integers $$$ xb_i $$$ $$$ yb_i $$$ $$$ t_i $$$ ( $$$ 1 \le xb_i yb_i \le 1000000 $$$ $$$ 1 \le t_i \le 1000000000 $$$ ) coordinate quest turn may complete guarantee locations a test different print a single number — maximal number quest william able complete first sample test one possible sequence william 's action follow :",['dp'],3300.0
1292/F,back time seven - year - old nora use play lot game creation <unknown> fun enhance <unknown> one day nora 's <unknown> father <unknown> <unknown> bring nora $$$ n $$$ box toy <unknown> nora decide make a fun game robo label $$$ n $$$ box $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ask robo follow action several ( possibly zero ) time : amuse nine different try game nora ask robo calculate number possible different pile largest amount box two pile consider different exist a position two pile different box since robo still <unknown> stag nora still young <unknown> a long time fell asleep find final answer help ? number pile large print answer modulo $$$ 1000000000 + 7 $$$ first line contain integer $$$ n $$$ ( $$$ 3 \le n \le 60 $$$ ) denote number box second line contain $$$ n $$$ distinct integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 60 $$$ ) $$$ a_i $$$ label $$$ i $$$ -th box print number distinct pile maximum number box <unknown> modulo $$$ 1000000000 + 7 $$$ let 's illustrate box pile a sequence $$$ b $$$ pile 's <unknown> box leftmost position first example $$$ 2 $$$ distinct pile possible : second example $$$ 4 $$$ distinct pile possible : third sequence robo nothing therefore $$$ 1 $$$ valid pile pile empty,['dp'],3500.0
1238/E,a password often type — a string $$$ s $$$ length $$$ n $$$ every character string one first $$$ m $$$ lowercase latin letter since spend a lot time type want buy a new keyboard a keyboard a permutation first $$$ m $$$ latin letter example $$$ m = 3 $$$ six possible keyboards : abc acb bac bca <unknown> cba since type password one finger need spend time move finger one password character next time move character $$$ s_i $$$ character $$$ s _ { i+1 } $$$ equal distance character keyboard total time spend type password a keyboard call slowness keyboard <unknown> slowness keyboard equal $$$ \sum\limits _ { i=2 } ^ { n } <unknown> _ { s _ { i-1 } } - pos _ { s_i } | $$$ $$$ <unknown> $$$ position letter $$$ x $$$ keyboard example $$$ s $$$ <unknown> keyboard bac total time type password $$$ |pos_a - pos_a| + |pos_a - pos_c| + <unknown> - pos_a| + |pos_a - <unknown> + <unknown> - pos_c| $$$ = $$$ |2 - 2| + |2 - 3| + |3 - 2| + |2 - 1| + |1 - 3| $$$ = $$$ 0 + 1 + 1 + 1 + 2 = 5 $$$ buy a new keyboard want know minimum possible slowness keyboard first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100000 1 \le m \le 20 $$$ ) second line contain string $$$ s $$$ consist $$$ n $$$ character character one first $$$ m $$$ latin letter ( lowercase ) print one integer – minimum slowness a keyboard first test case consider statement second test case slowness keyboard $$$ 0 $$$ third test case one suitable keyboards <unknown>,['dp'],2200.0
1152/F2,problem previous one larger constraints aki play a new video game video game control neko giant cat fly planets catniverse $$$ n $$$ planets catniverse number $$$ 1 $$$ $$$ n $$$ begin game aki choose planet neko initially locate aki perform $$$ k - 1 $$$ move move neko move current planet $$$ x $$$ planet $$$ y $$$ : way neko visit exactly $$$ k $$$ different planets two ways visit planets call different index $$$ i $$$ $$$ i $$$ -th planet visit first way different $$$ i $$$ -th planet visit second way total number ways visit $$$ k $$$ planets way ? since answer quite large print modulo $$$ 1000000000 + 7 $$$ line contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \le n \le 1000000000 $$$ $$$ 1 \le k \le \min ( n 12 ) $$$ $$$ 1 \le m \le 4 $$$ ) — number planets catniverse number planets neko need visit say constant $$$ m $$$ print exactly one integer — number different ways neko visit exactly $$$ k $$$ planets since answer quite large print modulo $$$ 1000000000 + 7 $$$ first example $$$ 4 $$$ ways neko visit planets : second example $$$ 9 $$$ ways neko visit exactly $$$ 2 $$$ planets : third example $$$ m = 4 $$$ neko visit planets order $$$ 5 ! = 120 $$$ ways neko visit planets fourth example neko visit exactly $$$ 1 $$$ planet ( also planet initially locate ) $$$ 100 $$$ ways choose start planet neko,['dp'],3000.0
1168/C,"toad <unknown> array integers $$$ a_1 a_2 \ldots a_n $$$ say $$$ y $$$ reachable $$$ x $$$ $$$ x < y $$$ exist integer array $$$ p $$$ $$$ x = p_1 < p_2 < \ldots < p_k = y $$$ $$$ a _ { p_i } \ \ & \ a _ { p _ { i+1 } } > 0 $$$ integers $$$ i $$$ $$$ 1 \leq i < k $$$ $$$ \ & $$$ denote bitwise operation give $$$ q $$$ pair indices check reachability first line contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 2 \leq n \leq 300\,000 $$$ $$$ 1 \leq q \leq 300\,000 $$$ ) — number integers array number query need answer second line contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 300\,000 $$$ ) — give array next $$$ q $$$ line contain two integers $$$ i $$$ -th contain two space - separated integers $$$ x_i $$$ $$$ y_i $$$ ( $$$ 1 \leq x_i < y_i \leq n $$$ ) need check $$$ y_i $$$ reachable $$$ x_i $$$ output $$$ q $$$ line $$$ i $$$ -th print ` ` <unknown> '' $$$ y_i $$$ reachable $$$ x_i $$$ otherwise print ` ` <unknown> '' first example $$$ a_3 = 0 $$$ ca n't reach always zero $$$ <unknown> \ & \ a_4 > 0 $$$ $$$ 4 $$$ reachable $$$ 2 $$$ go $$$ 1 $$$ $$$ 4 $$$ use $$$ p = [ 1 2 4 ] $$$",['dp'],2200.0
1288/D,"give $$$ n $$$ array $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ; array consist exactly $$$ m $$$ integers denote $$$ y $$$ -th element $$$ x $$$ -th array $$$ a _ { x y } $$$ choose two array $$$ a_i $$$ $$$ a_j $$$ ( $$$ 1 \le i j \le n $$$ possible $$$ i = j $$$ ) , obtain a new array $$$ b $$$ consist $$$ m $$$ integers every $$$ k \in [ 1 m ] $$$ $$$ b_k = \max ( a _ { i k } a _ { j k } ) $$$ goal choose $$$ i $$$ $$$ j $$$ value $$$ \min \limits _ { k = 1 } ^ { m } b_k $$$ maximum possible first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 300000 $$$ $$$ 1 \le m \le 8 $$$ ) — number array number elements array respectively $$$ n $$$ line follow $$$ x $$$ -th line contain array $$$ a_x $$$ represent $$$ m $$$ integers $$$ a _ { x 1 } $$$ $$$ a _ { x 2 } $$$ ... $$$ a _ { x m } $$$ ( $$$ 0 \le a _ { x y } \le 1000000000 $$$ ) print two integers $$$ i $$$ $$$ j $$$ ( $$$ 1 \le i j \le n $$$ possible $$$ i = j $$$ ) — indices two array choose value $$$ \min \limits _ { k = 1 } ^ { m } b_k $$$ maximum possible multiple answer print",['dp'],2000.0
1185/G1,difference easy hard versions constraints polycarp love listen music never leave player even way home university polycarp <unknown> distance university house exactly $$$ t $$$ minutes player polycarp store $$$ n $$$ songs characterize two parameters : $$$ t_i $$$ $$$ g_i $$$ $$$ t_i $$$ length song minutes ( $$$ 1 \le t_i \le 15 $$$ ) $$$ g_i $$$ genre ( $$$ 1 \le g_i \le 3 $$$ ) polycarp want create a playlist listen music time way university home time arrival home playlist polycarp never interrupt songs always listen begin end thus start listen $$$ i $$$ -th song would spend exactly $$$ t_i $$$ minutes listen polycarp also like two songs genre play a row ( i.e successively / <unknown> ) songs playlist repeat help polycarpus count number different sequence songs ( order matter ) total duration exactly $$$ t $$$ two consecutive songs genre songs playlist different first line input contain two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 15 1 \le t \le <unknown> $$$ ) — number songs player require total duration respectively next $$$ n $$$ line contain descriptions songs : $$$ i $$$ -th line contain two integers $$$ t_i $$$ $$$ g_i $$$ ( $$$ 1 \le t_i \le 15 1 \le g_i \le 3 $$$ ) — duration $$$ i $$$ -th song genre respectively output one integer — number different sequence songs total length exactly $$$ t $$$ two consecutive songs genre songs playlist different since answer may huge output modulo $$$ 1000000000 + 7 $$$ ( remainder divide quantity $$$ 1000000000 + 7 $$$ ) first example polycarp make $$$ 6 $$$ possible playlist rearrange available songs : $$$ [ 1 2 3 ] $$$ $$$ [ 1 3 2 ] $$$ $$$ [ 2 1 3 ] $$$ $$$ [ 2 3 1 ] $$$ $$$ [ 3 1 2 ] $$$ $$$ [ 3 2 1 ] $$$ ( indices songs give ) second example first second songs go succession ( since genre ) thus polycarp create a playlist one $$$ 2 $$$ possible ways : $$$ [ 1 3 2 ] $$$ $$$ [ 2 3 1 ] $$$ ( indices songs give ) third example polycarp make follow <unknown> : $$$ [ 1 2 3 ] $$$ $$$ [ 1 3 2 ] $$$ $$$ [ 2 1 3 ] $$$ $$$ [ 2 3 1 ] $$$ $$$ [ 3 1 2 ] $$$ $$$ [ 3 2 1 ] $$$ $$$ [ 1 4 ] $$$ $$$ [ 4 1 ] $$$ $$$ [ 2 3 4 ] $$$ $$$ [ 4 3 2 ] $$$ ( indices songs give ),['dp'],2100.0
1215/E,monocarp arrange $$$ n $$$ color marble a row color $$$ i $$$ -th marble $$$ a_i $$$ monocarp like order things want rearrange marble a way marble color form a <unknown> segment ( one segment color ) word monocarp want rearrange marble every color $$$ j $$$ leftmost marble color $$$ j $$$ $$$ l $$$ -th row rightmost marble color position $$$ r $$$ row every marble $$$ l $$$ $$$ r $$$ color $$$ j $$$ achieve goal monocarp follow operation number time : choose two neighbour marble swap calculate minimum number operations monocarp perform rearrange marble note order segment marble equal color matter require every color marble color form exactly one contiguous segment first line contain one integer $$$ n $$$ $$$ ( 2 \le n \le 4 \cdot 100000 ) $$$ — number marble second line contain integer sequence $$$ a_1 a_2 \dots a_n $$$ $$$ ( 1 \le a_i \le 20 ) $$$ $$$ a_i $$$ color $$$ i $$$ -th marble print minimum number operations monocarp perform achieve goal first example three operations enough firstly monocarp swap third fourth marble sequence color $$$ [ 3 4 3 2 4 2 2 ] $$$ monocarp swap second third marble sequence $$$ [ 3 3 4 2 4 2 2 ] $$$ finally monocarp swap fourth fifth marble sequence $$$ [ 3 3 4 4 2 2 2 ] $$$ second example 's need perform operations,['dp'],2200.0
1383/C,note difference string transformation 1 string transformation 2 move koa version letter $$$ y $$$ koa select letter first $$$ 20 $$$ lowercase letter english alphabet ( read statement better understand ) make hack problems independently koa <unknown> two string $$$ a $$$ $$$ b $$$ length $$$ n $$$ ( $$$ <unknown> $$$ ) consist first $$$ 20 $$$ lowercase english alphabet letter ( ie a t ) one move koa : note modify letter string $$$ a $$$ koa want know smallest number move make string equal ( $$$ a = b $$$ ) determine way make equal help ! test contain multiple test case first line contain $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) — number test case description test case follow first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length string $$$ a $$$ $$$ b $$$ second line test case contain string $$$ a $$$ ( $$$ <unknown> $$$ ) third line test case contain string $$$ b $$$ ( $$$ <unknown> $$$ ) string consist first $$$ 20 $$$ lowercase english alphabet letter ( ie a t ) guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case : print a single line smallest number move make string equal ( $$$ a = b $$$ ) $$$ -1 $$$ way make equal,['dp'],3100.0
1152/F1,problem next one smaller constraints aki play a new video game video game control neko giant cat fly planets catniverse $$$ n $$$ planets catniverse number $$$ 1 $$$ $$$ n $$$ begin game aki choose planet neko initially locate aki perform $$$ k - 1 $$$ move move neko move current planet $$$ x $$$ planet $$$ y $$$ : way neko visit exactly $$$ k $$$ different planets two ways visit planets call different index $$$ i $$$ $$$ i $$$ -th planet visit first way different $$$ i $$$ -th planet visit second way total number ways visit $$$ k $$$ planets way ? since answer quite large print modulo $$$ 1000000000 + 7 $$$ line contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 1 \le k \le \min ( n 12 ) $$$ $$$ 1 \le m \le 4 $$$ ) — number planets catniverse number planets neko need visit say constant $$$ m $$$ print exactly one integer — number different ways neko visit exactly $$$ k $$$ planets since answer quite large print modulo $$$ 1000000000 + 7 $$$ first example $$$ 4 $$$ ways neko visit planets : second example $$$ 9 $$$ ways neko visit exactly $$$ 2 $$$ planets : third example $$$ m = 4 $$$ neko visit planets order $$$ 5 ! = 120 $$$ ways neko visit planets fourth example neko visit exactly $$$ 1 $$$ planet ( also planet initially locate ) $$$ 100 $$$ ways choose start planet neko,['dp'],2800.0
1620/G,a sequence string $$$ [ t_1 t_2 \dots t_m ] $$$ let 's define function $$$ f ( [ t_1 t_2 \dots t_m ] ) $$$ number different string ( include empty string ) subsequences least one string $$$ t_i $$$ $$$ f ( [ ] ) = 0 $$$ ( i. e. number string empty sequence $$$ 0 $$$ ) give a sequence string $$$ [ s_1 s_2 \dots s_n ] $$$ every string sequence consist lowercase latin letter sort ( i. e. string begin several ( maybe zero ) character a several ( maybe zero ) character b ... end several ( maybe zero ) character z ) $$$ 2^n $$$ subsequences $$$ [ s_1 s_2 \dots s_n ] $$$ calculate value function $$$ f $$$ modulo $$$ 998244353 $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 23 $$$ ) — number string $$$ n $$$ line follow $$$ i $$$ -th line contain string $$$ s_i $$$ ( $$$ 1 \le |s_i| \le 20000 $$$ ) consist lowercase latin letter string $$$ s_i $$$ sort since print $$$ 2^ { 23 } $$$ integers would really slow follow : $$$ 2^n $$$ subsequences ( denote $$$ [ s _ { i_1 } s _ { i_2 } \dots s _ { i_k } ] $$$ ) calculate $$$ f ( [ s _ { i_1 } s _ { i_2 } \dots s _ { i_k } ] ) $$$ take modulo $$$ 998244353 $$$ multiply $$$ k \cdot ( i_1 + i_2 + \dots + i_k ) $$$ print xor $$$ 2^n $$$ integers get indices $$$ i_1 i_2 \dots i_k $$$ description subsequences $$$ 1 $$$ -indexed ( i. e. $$$ 1 $$$ $$$ n $$$ ),['dp'],2400.0
1804/H,"lara a safe lock a circle - shaped code lock consist a rotate arrow a <unknown> circumference around arrow input screen input button circumference lock split $$$ k $$$ equal section number $$$ 1 $$$ $$$ k $$$ clockwise order arrow always point one section section mark one first $$$ k $$$ letter english alphabet two section mark letter due lock limitations safe 's password a string length $$$ n $$$ consist first $$$ k $$$ letter english alphabet lara enter password rotate lock 's arrow press input button initially lock 's arrow point section $$$ 1 $$$ input screen empty one second one follow action lara recently find safe re - <unknown> take first $$$ k $$$ letter english alphabet assign sectors order like want re - arrange letter a way minimize number second take input password compute minimum number second number ways assign letter minimum number second achieve two ways assign letter sectors consider distinct exist least one sector $$$ i $$$ assign different letter first line input contain two integers $$$ k $$$ $$$ n $$$ ( $$$ 2 \leq k \leq 16 $$$ $$$ 2 \leq n \leq 100\,000 $$$ ) — number sectors lock 's circumference length lara 's password respectively second line input contain a string length $$$ n $$$ consist first $$$ k $$$ lowercase letter english alphabet string password first line print minimum possible number second take lara enter password open safe assign letter sectors optimally second line print number ways assign letter optimally initial state optimal arrangements first example show figure initial state optimal arrangements second example show figure initial state optimal arrangements third example show figure",['dp'],3300.0
115/D,let 's define unambiguous arithmetic expression ( <unknown> ) follow give a string consist digits ( ` ` 0 '' - ` ` 9 '' ) character ` ` - '' ` ` + '' ` ` * '' ` ` / '' task compute number different possible unambiguous arithmetic expressions bracket ( character ` ` ( ` ` ` ` ) '' ) unambiguous arithmetic expression remove become input string since answer may large print modulo 1000003 ( 106 + 3 ) first line a non - empty string consist digits ( ' <unknown> ' 9 ' ) character ' - ' ' + ' ' * ' and/or ' / ' length exceed 2000 . line n't contain space print a single integer represent number different unambiguous arithmetic expressions modulo 1000003 ( 106 + 3 ) bracket remove become equal input string ( character - <unknown> - character ) first example two possible unambiguous arithmetic expressions : second example three possible unambiguous arithmetic expressions :,['dp'],2600.0
217/C,<unknown> institute <unknown> research ( <unknown> ) investigate properties two species bacteria name simply 0 1 . even a <unknown> bacteria two species difficult distinguish fact thing scientists possess able <unknown> a plant call formurosa scientists place a sample colonies bacteria formurosa 's leave activate a complicate nutrition process process color formurosa change reflect result a — possibly complicate — logical formula species bacteria involve constants operators | ( ) & ( ) ^ ( xor ) 0 plant turn red otherwise — turn blue example nutrition process formurosa describe formula : ( ( ( ? ^ ? ) | ? ) & ( <unknown> ? ) ) ; formurosa four leave ( ` ` ? '' sign denote leave ) place 0 1 0 0 respective leave result nutrition process ( ( ( 0 ^ 1 ) |0 ) & ( 1 ^ 0 ) ) = 1 therefore plant turn blue scientists n colonies bacteria know type ; thing know sure colonies type want attempt determine bacteria 's species repeat <unknown> formurosa evaluation must place exactly one sample every leaf plant however may use multiple sample one colony a single evaluation ; even cover whole plant bacteria one colony ! possible always determine species colony matter ( assume ) ? first line input contain a single integer n ( 2 ≤ n ≤ 106 ) — number colonies bacteria second line contain formula describe nutrition process formurosa line contain character « 0 » « 1 » « ? » « | » « & » « ^ » « ( » « ) » <unknown> follow grammar : formula consist 106 character always possible determine species colony output ` ` yes '' ( without quote ) otherwise output ` ` '' ( without quote ),['dp'],2600.0
1670/F,train icpc competitions team ` ` <unknown> see '' stumble upon a basic count problem many ` ` wrong answer '' verdicts finally decide give destroy turn - <unknown> pc want help up - <unknown> problem give 4 integers $$$ n $$$ $$$ l $$$ $$$ r $$$ $$$ z $$$ count number array $$$ a $$$ length $$$ n $$$ contain non - negative integers : since answer large print modulo $$$ 1000000000 + 7 $$$ line contain four integers $$$ n $$$ $$$ l $$$ $$$ r $$$ $$$ z $$$ ( $$$ 1 \le n \le 1000 $$$ $$$ 1\le <unknown> <unknown> 10^ { 18 } $$$ $$$ 1\le <unknown> 10^ { 18 } $$$ ) print number array $$$ a $$$ satisfy requirements modulo $$$ 1000000000 + 7 $$$ follow array satisfy condition first sample : follow array satisfy condition second sample :,['dp'],2400.0
582/E,problem consider boolean function four variables a b c d. variables a b c d logical take value 0 1 . define a function use follow grammar : < expression > : : = < variable > | ( < expression > ) < operator > ( < expression > ) < variable > : : = ' a ' | ' b ' | ' c ' | 'd ' | ' a ' | ' b ' | ' c ' | 'd ' < operator > : : = ' & ' | ' <unknown> large letter a b c d represent variables small letter represent <unknown> example a = 1 character ' a ' correspond value 1 value character ' a ' correspond value 0 . character ' & ' correspond operation logical character ' | ' correspond operation logical give expression s define function f operations variables miss also know value function f ( a b c d ) n distinct set variable value count number ways restore elements miss expression result expression correspond give information function f give variable set value result rather large print remainder modulo 109 + 7 . first line contain expression s ( 1 ≤ |s| ≤ 500 ) character operators and/or variables replace character ' ? ' second line contain number n ( 0 ≤ n ≤ 24 ) — number integers set know value function f ( a b c d ) next n line contain descriptions set : i - th contain five integers ai bi ci di ei ( 0 ≤ ai bi ci di ei ≤ 1 ) separate space mean f ( ai bi ci di ) = ei guarantee tuples ( ai bi ci di ) distinct a single line print answer problem first sample two valid expressions ' c ' 'd ' second sample expressions look follow : ' ( a ) & ( a ) ' ' ( a ) & ( b ) ' ' ( a ) & ( c ) ' ' ( a ) & ( d ) ',['dp'],3000.0
1739/E,"consider a hallway represent matrix $$$ 2 $$$ row $$$ n $$$ columns let 's denote cell intersection $$$ i $$$ -th row $$$ j $$$ -th column $$$ ( i j ) $$$ distance cells $$$ ( i_1 j_1 ) $$$ $$$ ( i_2 j_2 ) $$$ $$$ |i_1 - <unknown> + <unknown> - <unknown> $$$ a clean robot cell $$$ ( 1 1 ) $$$ cells hallway clean cells dirty ( cell robot clean ) want clean hallway go launch robot robot launch work follow least one cell dirty robot choose closest ( current cell ) cell among dirty move clean ( cell longer dirty ) clean a cell robot find closest dirty cell current cell , process repeat whole hallway clean however a critical bug robot 's program moment multiple closest ( robot 's current position ) dirty cells robot malfunction want clean hallway a way robot n't malfunction launch robot clean ( possibly zero ) dirty cells however n't want much dirty work nice smart ( yet <unknown> ) robot note make a clean cell dirty calculate maximum possible number cells leave dirty launch robot n't malfunction first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number columns hallway two line follow denote $$$ 1 $$$ -st $$$ 2 $$$ -nd row hallway line contain $$$ n $$$ character 0 denote a clean cell 1 denote a dirty cell start cell robot $$$ ( 1 1 ) $$$ clean print one integer — maximum possible number cells leave dirty launch robot n't malfunction first example clean cell $$$ ( 1 2 ) $$$ path robot $$$ ( 1 1 ) \rightarrow ( 2 1 ) \rightarrow ( 2 2 ) $$$ second example leave hallway path robot $$$ ( 1 1 ) \rightarrow ( 1 2 ) \rightarrow ( 2 2 ) $$$ third example clean cell $$$ ( 1 2 ) $$$ path robot $$$ ( 1 1 ) \rightarrow ( 2 1 ) \rightarrow ( 2 3 ) \rightarrow ( 2 4 ) \rightarrow ( 1 4 ) $$$ fourth example hallway already clean maybe launch robot earlier ?",['dp'],2400.0
1117/F,give a string length $$$ n $$$ character one first $$$ p $$$ lowercase latin letter also give a matrix $$$ a $$$ binary value size $$$ p \times p $$$ matrix symmetric ( $$$ a _ { ij } = a _ { ji } $$$ ) $$$ a _ { ij } = 1 $$$ mean string $$$ i $$$ -th $$$ j $$$ -th letter latin alphabet adjacent let 's call string crisp adjacent character adjacent ( 1 correspond cell matrix $$$ a $$$ ) allow follow move choose letter remove occurrences join remain part string without change order example remove letter ' a ' ` ` abacaba '' yield ` ` bcb '' string give crisp string remain crisp every move make allow arbitrary number move ( possible zero ) shortest result string obtain ? first line contain two integers $$$ n $$$ $$$ p $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 1 \le p \le 17 $$$ ) — length initial string length allow prefix latin alphabet second line contain initial string guarantee contain first $$$ p $$$ lowercase latin letter crisp $$$ p $$$ first latin letter might present string next $$$ p $$$ line contain $$$ p $$$ integer number — matrix $$$ a $$$ ( $$$ 0 \le a _ { ij } \le 1 $$$ $$$ a _ { ij } = a _ { ji } $$$ ) $$$ a _ { ij } = 1 $$$ mean string $$$ i $$$ -th $$$ j $$$ -th letter latin alphabet adjacent print a single integer — length shortest string make arbitrary number move ( possible zero ) first example letter remove initial string second example remove letter order : ' b ' ' c ' ' a ' string intermediate step : ` ` abacaba '' $$$ \rightarrow $$$ ` ` <unknown> '' $$$ \rightarrow $$$ ` ` aaaa '' $$$ \rightarrow $$$ ` ` '' third example remove letter ' b ' 's fourth example remove letter order ' c ' ' b ' order ' b ' ' c ' two letter ' c ' ca n't adjacent,['dp'],2500.0
1103/D,"cardbluff popular sport game <unknown> cardbluff player ever dream entrance professional layer $$$ n $$$ judge layer try pass entrance exam a number $$$ k $$$ — skill cardbluff judge a number $$$ a_i $$$ — indicator uncertainty entrance professional layer a number $$$ e_i $$$ — experience play cardbluff pass exam need convince judge play play one game judge a result a particular game divide uncertainty $$$ i $$$ -th judge natural divisor $$$ a_i $$$ $$$ k $$$ gcd <unknown> equal $$$ 1 $$$ enter professional layer become a judge also want minimize total amount spend time , play $$$ x $$$ judge total experience $$$ y $$$ spend $$$ x \cdot y $$$ second print minimal time enter professional layer $$$ -1 $$$ 's impossible two number first line $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 1000000 $$$ $$$ 1 \leq k \leq 10^ { 12 } $$$ ) — number judge skill cardbluff second line contain $$$ n $$$ integers $$$ i $$$ -th number $$$ a_i $$$ ( $$$ 1 \leq a_i \leq 10^ { 12 } $$$ ) — uncertainty $$$ i $$$ -th <unknown> third line contain $$$ n $$$ integers format ( $$$ 1 \leq e_i \leq 1000000000 $$$ ) $$$ e_i $$$ — experience $$$ i $$$ -th judge print single integer — minimal number second pass exam $$$ -1 $$$ 's impossible",['dp'],3100.0
111/C,little petya love train spiders petya a board n × m size cell board initially a spider sit one second petya choose a certain action spider <unknown> perform command 5 possible command : stay idle move current cell four side - <unknown> cells ( one command four possible directions ) petya give command spider leave field allow spiders pass crawl towards opposite directions spiders crawl simultaneously several spiders may end one cell petya want know maximum possible number spider - free cells one second first line contain two space - separated integers n m ( 1 ≤ n m ≤ 40 n·m ≤ 40 ) — board size first line print maximum number cells without spiders first sample possible answer : sin second sample one possible solutions : s denote command ` ` stay idle '' l r d u denote command ` ` crawl leave '' ` ` crawl right '' ` ` crawl '' ` ` crawl '' correspondingly,['dp'],2100.0
232/E,john <unknown> a field a rectangular table size n × m. assume field row number 1 n top bottom field columns number 1 m leave right cell field intersection x - th row y - th column coordinate ( x ; y ) know cells john 's field paint white paint black also john a tortoise move along white cells field tortoise get a white cell coordinate ( x ; y ) cell ( x + 1 ; y ) ( x ; y + 1 ) correspond cell paint white word turtle move along white cells field right turtle go bound field addition john q query characterize four number x1 y1 x2 y2 ( x1 ≤ x2 y1 ≤ y2 ) query john want know whether tortoise start point coordinate ( x1 ; y1 ) reach point coordinate ( x2 ; y2 ) move along white square field first line contain two space - separated integers n m ( 1 ≤ n m ≤ 500 ) — field size next n line contain m character ` ` # '' ` ` ` ` : j - th character i - th line equal ` ` # '' cell ( i ; j ) paint black ` ` ` ` paint white next line contain integer q ( 1 ≤ q ≤ <unknown> ) — number query next q line contain four space - separated integers x1 y1 x2 y2 ( 1 ≤ x1 ≤ x2 ≤ n 1 ≤ y1 ≤ y2 ≤ m ) — coordinate start finish cells guarantee cells ( x1 ; y1 ) ( x2 ; y2 ) white q query print a single line ` ` yes '' a way cell ( x1 ; y1 ) cell ( x2 ; y2 ) meet requirements ` ` '' otherwise print answer query order query give input,['dp'],3000.0
279/D,"' ve get a positive integer sequence a1 a2 ... , number sequence distinct let 's fix set variables b1 b2 ... bm initially variable bi ( 1 ≤ i ≤ m ) contain value zero consider follow sequence consist n operations first operation assign value a1 variable bx ( 1 ≤ x ≤ m ) follow n - 1 operations assign variable value equal sum value store variables bi bj ( 1 ≤ i j y ≤ m ) , value assign t - th operation must equal operation number y i j choose anew task find minimum number variables m variables help perform describe sequence operations first line contain integer n ( 1 ≤ n ≤ 23 ) second line contain n space - separated integers a1 a2 ... ( 1 ≤ ak ≤ 109 ) guarantee number sequence distinct a single line print a single number — minimum number variables m variables help perform describe sequence operations perform sequence operations m print -1 . first sample use two variables b1 b2 perform follow sequence operations",['dp'],2200.0
377/C,kostya a <unknown> <unknown> <unknown> dota 2 . <unknown> corporation developer game recently release a new patch turn balance game upside kostya captain team realize greatest <unknown> lie want resort <unknown> <unknown> patch mathematical point view choose best heroes team every game a dota 2 match involve two team must choose heroes players team go play forbid choose hero several time even different team large electronic sport competitions kostya 's team go participate match hold captain mode mode captain select heroes make one two possible action a certain <unknown> order : pick ban team captain may miss a pick a ban miss a pick a random hero add team available moment miss a ban hero ban ban kostya already identify strength heroes base new patch fix course kostya know order pick ban strength a team sum strengths team 's heroes team participate match seek maximize difference strengths <unknown> help kostya determine team first one second one advantage match large advantage first line contain a single integer n ( 2 ≤ n ≤ 100 ) — number heroes dota 2 . second line contain n integers s1 s2 ... sn ( 1 ≤ si ≤ 106 ) — strengths heroes third line contain a single integer m ( 2 ≤ m ≤ min ( n 20 ) ) — number action captain team must perform next m line look like ` ` action team '' action need action : a pick ( represent a ` ` p '' ) a ban ( represent a ` ` b '' ) team number team need perform action ( number 1 2 ) guarantee team make least one pick besides team number pick number ban print a single integer — difference strength first team strength second team captain team act optimally well,['dp'],2200.0
413/D,programmers r2 company love play 2048 . one day decide invent simplify version game — 2k a stripe imagine infinite one direction stripe consist unit square ( side square equal height stripe ) square either empty contain number initially square empty infinity one unit square number 2 4 appear player press a button appear number begin move towards begin stripe let 's assume number x move begin stripe stop : final stop number move process infinity get a new number 2 4 process repeat read note test sample better understand move strategy i guess ' ve understand game progress fully depend order number 2 4 appear let 's look sequence number 2 4 game assume sequence win result least one square get number greater equal 2k goal game make a win sequence n number everything simple number sequence identify beforehand give a sequence consist number 0 2 4 . count many ways replace 0 sequence 2 4 get a win sequence first line contain two integers n k ( 1 ≤ n ≤ 2000 ; 3 ≤ k ≤ 11 ) next line contain sequence n integers either 0 2 4 . print a single integer — number ways replace zero number 2 4 get a win sequence number rather large print modulo 1000000007 ( 109 + 7 ) consider first example begin strip look follow : 2 → 4 → 8 → 8 2 → 8 4 → 8 4 2 → 16 . better understand game see original game http : <unknown> please note game describe strip slightly different original game ( two number add original game keep move ) careful game <unknown> n't much time contest !,['dp'],2000.0
449/D,"jzzhu n non - negative integers a1 a2 ... , call a sequence index i1 i2 ... ik ( 1 ≤ i1 < i2 < ... < ik ≤ n ) a group size k. jzzhu wonder many group exist ai1 & ai2 & ... & aik = 0 ( 1 ≤ k ≤ n ) ? help print number modulo 1000000007 ( 109 + 7 ) operation x & y denote bitwise operation two number first line contain a single integer n ( 1 ≤ n ≤ 106 ) second line contain n integers a1 a2 ... ( 0 ≤ ai ≤ 106 ) output a single integer represent number require group modulo 1000000007 ( 109 + 7 )",['dp'],2400.0
482/C,play game friend description game list friend create n distinct string length m tell string randomly choose one choose string equiprobably i.e probability choose n string equal want guess string choose friend order guess string friend choose allow ask question question follow form : « character stand position pos string choose ? » a string consider guess answer give question uniquely identify string string guess stop ask question a particular strategy question equiprobably ask a position n't yet mention task determine expect number question need guess string choose friend first line contain a single integer n ( 1 ≤ n ≤ 50 ) — number string friend come next n line contain string friend create guarantee string distinct consist large small english letter besides lengths string 1 20 inclusive print single number — expect value answer consider correct absolute relative error n't exceed 10 - 9 . first sample string differ character third position follow situations possible : thus expect value equal second sample need two question pair question uniquely identify string expect number question third sample whatever position ask first question immediately identify string,['dp'],2600.0
53/E,life bertown become hard city many roads government spend much maintain n junctions m two way roads one get junction one mayor want close roads number roads leave total n - 1 roads still possible get junction one besides mayor concern number dead end junctions one road go n't many junctions discuss problem mayor <unknown> decide roads close road map contain exactly k dead end task count number different ways close roads follow condition meet : two ways consider different a road close first way open second one first line contain three integers n m k ( 3 ≤ n ≤ 10 n - 1 ≤ m ≤ n · ( n - 1 ) / 2 2 ≤ k ≤ n - 1 ) represent number junctions roads dead end correspondingly follow m line contain two different integers v1 v2 ( 1 ≤ v1 v2 ≤ n v1 ≠ v2 ) represent number junctions connect another road one road every pair junctions junctions number integers 1 n. guarantee possible get junction one along original roads print a single number — require number ways,['dp'],2500.0
107/C,year 2500 <unknown> graduation ceremony german university cairo ( guc ) run smoothly almost 500 years far important part ceremony relate arrangement professors ceremonial hall <unknown> guc n professors professor seniority level <unknown> different let 's enumerate professors 1 n 1 senior professor n junior professor ceremonial hall n seat one seat professor place hall mean senior professors others specifically m pair seat ` ` senior - junior '' relation tradition require m pair seat ( ai bi ) professor seat ` ` senior '' position ai senior professor seat ` ` junior '' position bi guc strict traditions carefully observe start year 2001 . tradition require : arrangement professors list n integers first integer seniority professor seat position number one second integer seniority professor seat position number two etc give n number professors y current year m pair restrictions output arrangement professors year first line contain three integers n y m ( 1 ≤ n ≤ 16 2001 ≤ y ≤ 1018 0 ≤ m ≤ 100 ) — number professors year arrangement compute number pair seat seniority relation keep respectively next m line contain one pair integers ` ` ai bi '' indicate professor ai - th seat senior professor bi - th seat ( 1 ≤ ai bi ≤ n ai ≠ bi ) pair may list please use % lld specificator read write 64 - bit integers с++ prefer use cin stream ( may also use % i64d specificator ) print order professors seat request year year guc would run arrangements give ` ` senior - junior '' relation contradictory print ` ` time change '' ( without quote ) first example lexicographically first order seat 1 2 3 . third example guc run arrangements year <unknown> . fourth example valid arrangements seat lexicographical comparison arrangements perform < operator modern program languages arrangement a lexicographically less arrangement b exist i ( 1 ≤ i ≤ n ) ai < bi j ( 1 ≤ j < i ) aj = bj,['dp'],2400.0
71/E,follow puzzle popular among <unknown> <unknown> a <unknown> contain a set n atoms chemical elements shall understand phrase ` ` atomic number '' number atom 's element periodic table chemical elements allow take two different atoms fuse a new one result a new atom whose number equal sum number original atoms fusion operation perform several time aim get a new <unknown> set k atoms puzzle 's difficulty allow fuse two atoms one allow split atom several atoms suggest try solve puzzle first line contain two integers n k ( 1 ≤ k ≤ n ≤ 17 ) second line contain space - separated symbols elements n atoms available start third line contain space - separated symbols elements k atoms need result fusion symbols elements coincide symbols periodic table chemical elements atomic number exceed 100 ( elements possess larger number highly unstable ) atoms identical number ( several atoms element ) sum number initial atoms equal sum number atoms need synthesize impossible synthesize require atoms print ` ` '' without quote otherwise print first line « yes » next k line print way synthesize k atoms equations equation follow form : ` ` <unknown> + ... + <unknown> > yi '' xj symbol element atom original set yi symbol element atom result set atom input data occur output data exactly one time order summands equations well output order matter several solutions print a better understand output format see sample reactions first example possess follow form ( atomic number write leave element ) : find a periodic table chemical elements may use favorite search <unknown> pretest set contain first 100 elements periodic table least use information check <unknown>,['dp'],2200.0
8/C,girl lena like everything order look order everywhere get ready university notice room a mess — object handbag throw room course want put back handbag problem girl carry two object a time move handbag also take object put anywhere except handbag — <unknown> sense order let give coordinate handbag coordinate object <unknown> coordinate system know girl cover distance two object time equal square length segment point object also know initially coordinate girl handbag ask find order action girl put object back handbag a minimum time period first line input file contain handbag 's coordinate <unknown> <unknown> second line contain number n ( 1 ≤ n ≤ 24 ) — amount object girl follow n line contain object ' coordinate coordinate exceed 100 absolute value give position different number integer first line output number — minimum time girl need put object handbag second line output possible optimum way lena object input describe index number ( 1 n ) handbag 's point describe number 0 . path start end handbag 's point several optimal paths print,['dp'],2000.0
11/D,give a simple graph output number simple cycle a simple cycle a cycle repeat vertices edge first line input contain two integers n m ( 1 ≤ n ≤ 19 0 ≤ m ) – respectively number vertices edge graph subsequent m line contain two integers a b ( 1 ≤ a b ≤ n a ≠ b ) indicate vertices a b connect undirected edge one edge connect pair vertices output number cycle give graph example graph a clique contain four cycle length 3 three cycle length 4,['dp'],2200.0
16/E,n fish number 1 n live a lake every day right one pair fish meet probability pair meet two fish index i j meet first eat second probability aij second eat first probability aji = 1 - aij describe process go least two fish lake fish find probability survive last lake first line contain integer n ( 1 ≤ n ≤ 18 ) — amount fish lake follow n line n real number — matrix a. aij ( 0 ≤ aij ≤ 1 ) — probability fish index i eat fish index j. 's guarantee main diagonal contain zero elements follow true : aij = 1 - aji real number give 6 character decimal point output n space - separated real number accurate less 6 decimal place number index i equal probability fish index i survive last lake,['dp'],1900.0
903/F,give a matrix f 4 row n columns element matrix either asterisk ( * ) a dot ( . ) may perform follow operation arbitrary number time : choose a square submatrix f size k × k ( 1 ≤ k ≤ 4 ) replace element choose submatrix a dot choose a submatrix size k × k cost ak coin minimum number coin pay replace asterisk dot ? first line contain one integer n ( 4 ≤ n ≤ 1000 ) — number columns f. second line contain 4 integers a1 a2 a3 a4 ( 1 ≤ ai ≤ 1000 ) — cost replace square submatrix size 1 × 1 2 × 2 3 × 3 4 × 4 respectively four line follow contain n character denote a row matrix f. character either a dot asterisk print one integer — minimum number coin replace asterisk dot first example spend 8 coin replace submatrix 3 × 3 top - left corner 1 coin replace 1 × 1 submatrix bottom - right corner second example best option replace 4 × 4 submatrix contain columns 2 – 5 2 × 2 submatrix consist row 2 – 3 columns 6 – 7 . third example select submatrix 3 × 3 top - left corner submatrix 3 × 3 consist row 2 – 4 columns 2 – 4,['dp'],2200.0
913/E,"give a boolean function three variables define truth table need find expression minimum length equal function expression may consist : one expression minimum length exist find lexicographically smallest one operations standard priority highest priority go lowest priority expression satisfy follow grammar : e : : = e ' | ' t | <unknown> : : = t ' & ' f | <unknown> : : = ' ! ' f | ' ( ' e ' ) ' | ' x ' | ' y ' | ' <unknown> first line contain one integer n — number function input ( 1 ≤ n ≤ 10 000 ) follow n line contain descriptions function i - th contain a string length 8 consist digits 0 1 — truth table i - th function digit position j ( 0 ≤ j < 8 ) equal value function case , output n line i - th line contain expression minimum length equal i - th function one expression output lexicographically smallest expressions satisfy give grammar n't contain white space truth table second function :",['dp'],2400.0
1030/E,"vasya a sequence $$$ a $$$ consist $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ vasya may <unknown> follow operation : choose number sequence swap pair bits binary representation example vasya transform number $$$ 6 $$$ $$$ ( \dots <unknown> ) $$$ $$$ 3 $$$ $$$ ( \dots <unknown> ) $$$ $$$ 12 $$$ $$$ ( \dots <unknown> ) $$$ $$$ <unknown> $$$ $$$ ( \dots <unknown> ) $$$ many others vasya use operation ( possibly zero ) number time number sequence vasya name a sequence good one , use operation mention obtain sequence bitwise exclusive elements equal $$$ 0 $$$ give sequence $$$ a_1 a_2 \ldots a_n $$$ vasya 'd like calculate number integer pair $$$ ( l r ) $$$ $$$ 1 \le l \le r \le n $$$ sequence $$$ a_l a _ { l + 1 } \dots a_r $$$ good first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) — length sequence second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 10^ { 18 } $$$ ) — sequence $$$ a $$$ print one integer — number pair $$$ ( l r ) $$$ $$$ 1 \le l \le r \le n $$$ sequence $$$ a_l a _ { l + 1 } \dots a_r $$$ good first example pair $$$ ( 2 3 ) $$$ $$$ ( 1 3 ) $$$ valid pair $$$ ( 2 3 ) $$$ valid since $$$ a_2 = 7 \rightarrow 11 $$$ $$$ a_3 = 14 \rightarrow 11 $$$ $$$ 11 \oplus 11 = 0 $$$ $$$ \oplus $$$ — bitwise exclusive pair $$$ ( 1 3 ) $$$ valid since $$$ a_1 = 6 \rightarrow 3 $$$ $$$ a_2 = 7 \rightarrow 13 $$$ $$$ a_3 = 14 \rightarrow 14 $$$ $$$ 3 \oplus 13 \oplus 14 = 0 $$$ second example pair $$$ ( 1 2 ) $$$ $$$ ( 2 3 ) $$$ $$$ ( 3 4 ) $$$ $$$ ( 1 4 ) $$$ valid",['dp'],2000.0
1051/D,give a grid consist $$$ 2 $$$ row $$$ n $$$ columns cell grid color either black white two cells consider neighbour a common border share color two cells $$$ a $$$ $$$ b $$$ belong component neighbour a neighbour $$$ a $$$ belong component $$$ b $$$ let 's call <unknown> beautiful exactly $$$ k $$$ components count number beautiful bicolorings number big enough print answer modulo $$$ 998244353 $$$ line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 1000 $$$ $$$ 1 \le k \le 2n $$$ ) — number columns a grid number components require print a single integer — number beautiful bicolorings modulo $$$ 998244353 $$$ one possible bicolorings sample $$$ 1 $$$ :,['dp'],1700.0
845/F,polycarp own a shop capital berland recently criminal activity capital increase polycarp think establish better security storehouse shop storehouse represent a matrix n row m columns element matrix either ( empty space ) x ( a wall ) polycarp want hire guard ( possibly zero ) watch storehouse guard cell matrix protect every cell right cell every cell bottom cell nearest wall formally guard stand cell ( x0 y0 ) protect cell ( x1 y1 ) condition meet : guard place empty cells ( protect empty cells ) plan place guard set cells guard place ( course two plan different exist least one cell include first plan include second plan vice versa ) polycarp call a plan suitable one empty cell protect polycarp want know number suitable plan since large output modulo 109 + 7 . first line contain two number n m — length width storehouse ( 1 ≤ n m ≤ 250 1 ≤ nm ≤ 250 ) n line follow ith line contain a string consist m character — ith row matrix represent storehouse character either x. output number suitable plan modulo 109 + 7 . first example put least one guard three possible arrangements : one guard cell ( 1 1 ) one guard cell ( 1 3 ) two guard cells,['dp'],2500.0
543/C,multiset n string length consist lowercase english letter say string easy remember string position i letter c english alphabet string string multiset letter c position i. example a multiset string { ` ` abc '' ` ` aba '' ` ` <unknown> '' ` ` ada '' } easy remember multiset { ` ` abc '' ` ` ada '' ` ` <unknown> '' } easy remember : want change multiset a little easy remember aij coin change character j - th position i - th string lowercase letter english alphabet find minimum sum pay order make multiset string easy remember first line contain two integers n m ( 1 ≤ n m ≤ 20 ) — number string multiset length string respectively next n line contain string multiset consist lowercase english letter string 's length m. next n line contain m integers i - th contain integers ai1 ai2 ... aim ( 0 ≤ aij ≤ 106 ) print a single number — answer problem,['dp'],2500.0
580/D,"kefa come restaurant sit a table <unknown> immediately bring menu n dish kefa know need exactly m dish , n't want order dish twice taste many dish possible kefa know i - th dish give ai units satisfaction dish go well together dish go well together kefa set k rule eat food follow type — eat dish x exactly dish y ( dish x y ) satisfaction level raise c. course <unknown> want get maximal possible satisfaction go restaurant help hard task ! first line input contain three space - separated number n m k ( 1 ≤ m ≤ n ≤ 18 0 ≤ k ≤ n * ( n - 1 ) ) — number dish menu number portion kefa need eat get full number eat rule second line contain n space - separated number ai ( 0 ≤ ai ≤ 109 ) — satisfaction get i - th dish next k line contain rule i - th rule describe three number xi yi ci ( 1 ≤ xi yi ≤ n 0 ≤ ci ≤ 109 ) mean eat dish xi right dish yi kefa 's satisfaction increase ci guarantee pair index i j ( 1 ≤ i < j ≤ k ) xi = xj yi = yj single line output print maximum satisfaction kefa get go restaurant first sample best first eat second dish first one get one unit satisfaction dish plus one rule second test fit sequence choice 4 2 1 2 1 4 . case get satisfaction 7 dish also fulfill rule 1 get additional satisfaction 5",['dp'],1800.0
599/E,root tree a connect graph without simple cycle one vertex select a root problem vertex number 1 always serve a root lowest common ancestor two vertices u v farthest root vertex lie path u root path v root denote lca ( u v ) sandy a root tree consist n vertices use store <unknown> unfortunately <unknown> storm break tree n't remember 's edge manage restore m edge initial tree q triple ai bi ci suppose lca ( ai bi ) = ci help sandy count number tree size n vertex 1 a root match information remember make a mess tree print 0 . two root tree consider distinct exist edge occur one n't occur one first line input contain three integers n m q ( 1 ≤ n ≤ 13 0 ≤ m < n 0 ≤ q ≤ 100 ) — number vertices number edge lca triple remember sandy respectively next m line contain two integers ui vi ( 1 ≤ ui vi ≤ n ui ≠ vi ) — number vertices connect i - th edge 's guarantee set edge a subset edge tree last q line contain triplets number ai bi ci ( 1 ≤ ai bi ci ≤ n ) triple define lca ( ai bi ) = ci 's guarantee exist a tree satisfy give lca condition print a single integer — number tree size n satisfy condition second sample correct answer look like : third sample two possible tree : fourth sample answer 0 information lca inconsistent,['dp'],2600.0
757/D,"gym leaders fascinate <unknown> take place <unknown> camp , curious know secret behind evolve pokemon organizers camp give gym leaders a pokeblock a sequence n ingredients ingredient type 0 1 . organizers tell gym leaders evolve a pokemon type k ( k ≥ 2 ) need make a valid set k cut pokeblock get smaller block suppose give pokeblock sequence <unknown> ... bn - 1 . a choice make cut n + 1 place i.e. b0 b0 b1 b1 b2 ... bn - 2 bn - 1 bn - 1 . n + 1 choices make cut follow ( a | denote a possible cut ) : consider a sequence k cut pair consecutive cut contain a binary string form ingredient type ingredients first cut last cut waste say consider exactly k - 1 binary substrings every substring read a binary number let m maximum number obtain number obtain number positive set obtain number contain integers 1 m set cut say a valid set cut example suppose give pokeblock sequence <unknown> make 5 cut follow way : 4 binary substrings obtain : 11 010 01 1 correspond number 3 2 1 1 respectively m = 3 maximum value among obtain number obtain number positive obtain integers 1 m. hence set cut a valid set 5 cut a pokemon type k evolve pokeblock cut use a valid set k cut many valid set size two valid set k cut consider different a cut one set set let f ( k ) denote number valid set k cut find value since value s large output s modulo 109 + 7 . input consist two line first line consist integer n ( 1 ≤ n ≤ <unknown> ) — length pokeblock next line contain pokeblock a binary string length n. output a single integer contain answer problem i.e. value s modulo 109 + 7 . first sample set valid cut : size 2 : <unknown> <unknown> <unknown> <unknown> size 3 : <unknown> <unknown> <unknown> <unknown> size 4 : <unknown> <unknown> hence f ( 2 ) = 4 f ( 3 ) = 4 f ( 4 ) = 2 . value s = 10 . second sample set valid cut : size 2 : <unknown> hence f ( 2 ) = 1 f ( 3 ) = 0 . value s = 1",['dp'],2200.0
768/E,sam <unknown> jon game stone <unknown> mind help devise a strategy fight white <unknown> rule game quite simple : jon believe ready battle sam think prove argument sam suggest play a modify version game modify version move make a pile example 4 stone remove a pile 4 stone remove pile sam set game make first move jon believe sam try prevent go battle jon want know win play optimally first line consist a single integer n ( 1 ≤ n ≤ 106 ) — number pile next n line contain integer si ( 1 ≤ si ≤ 60 ) — number stone i - th pile print a single line contain ` ` yes '' ( without quote ) jon win otherwise print ` ` '' ( without quote ) first case sam remove stone jon lose second case follow move possible sam : case last move make jon win game follow :,['dp'],2100.0
855/E,harry come know dumbledore <unknown> slytherin 's locket a <unknown> locket present earlier 12 <unknown> place home <unknown> black 's mother steal present ministry magic office <unknown> umbridge harry 's former defense dark arts teacher harry <unknown> <unknown> <unknown> ministry upon reach umbridge 's office observe a code lock a puzzle ask calculate count magic number two integers l r ( inclusive ) harry remember <unknown> time umbridge define a magic number a number convert a give base b digits 0 b - 1 appear even number time representation without lead zero answer q query unlock office query three integers bi li ri base range find count magic number first line input contain q ( 1 ≤ q ≤ 105 ) — number query next q line contain three space separate integers bi li ri ( 2 ≤ bi ≤ 10 1 ≤ li ≤ ri ≤ 1018 ) output q line contain a single integer answer correspond query sample test case 1 first query convert number 4 9 base 2 get : base 2 representation 9 even number 1 0 . thus answer 1,['dp'],2200.0
534/F,task write a program deal <unknown> field larger 5 × 20 . simplify <unknown> a task build field ( cell either white black ) satisfy give information row columns row column number contiguous black segment specify example size field n = 3 m = 5 <unknown> number contiguous black segment row : [ 2 3 2 ] columns : [ 1 0 1 2 1 ] solution may look like : guarantee test <unknown> exist least one solution first line follow two integers n m ( 1 ≤ n ≤ 5 1 ≤ m ≤ 20 ) — number row number columns respectively second line contain n integers a1 a2 ... ai number contiguous black segment i - th row field similarly third line contain m integers b1 b2 ... bm bi number contiguous black segment i - th column field guarantee exist least one solution output possible solution output consist n line contain m character denote white cell ` ` . '' black cell ` ` * '',['dp'],2400.0
780/F,"a couple friends axel marston travel across country bitland n towns bitland pair towns connect one - directional roads road bitland either a pedestrian road a bike road multiple roads pair towns may even a road a town however pair roads share start destination towns along type simultaneously friends locate town 1 plan travel route axel enjoy walk marston prefer bike order choose a route <unknown> equally interest friends agree upon follow procedure choose road type travel : first step route look follow : p pb <unknown> <unknown> <unknown> , friends start travel town 1 via <unknown> roads choose next road accord next character route type time impossible choose next road friends terminate travel fly home instead help friends find longest possible route travel along roads bitland accord road type choose procedure describe a route 1018 roads print -1 instead first line contain two integers n m ( 1 ≤ n ≤ 500 0 ≤ m ≤ <unknown> ) — number towns roads bitland respectively next m line describe roads i - th line contain three integers vi ui ti ( 1 ≤ vi ui ≤ n 0 ≤ ti ≤ 1 ) vi ui denote start destination towns indices i - th road ti <unknown> type i - th road ( 0 a pedestrian road 1 a bike road ) guarantee pair distinct indices i j 1 ≤ i j ≤ m either vi ≠ vj ui ≠ uj ti ≠ tj hold possible find a route length strictly greater 1018 print -1 . otherwise print maximum length a suitable path first sample obtain a route length 3 travel along road 1 town 1 town 2 follow road 2 twice town 2 second sample obtain arbitrarily long route travel road 1 first choose road 2 3 depend necessary type",['dp'],2400.0
86/C,` ` <unknown> space completely style days unlike <unknown> problems '' — think <unknown> woll change subject study bioinformatics <unknown> result sequence face follow problem concern dna sequence think a dna sequence arbitrary string uppercase letter ` ` a '' ` ` c '' ` ` g '' ` ` t '' ( course a simplify <unknown> ) let w a long dna sequence s1 s2 ... sm — collection short dna sequence let us say collection filter w iff w cover sequence collection certainly substrings correspond different position string may intersect even cover formally : denote |w| length w let symbols w number 1 |w| position i w exist pair indices l r ( 1 ≤ l ≤ i ≤ r ≤ |w| ) substring w [ l ... r ] equal one elements s1 s2 ... sm collection woll want calculate number dna sequence a give length filter a give collection n't know deal help ! task find number different dna sequence length n filter collection { si } answer may appear large output modulo 1000000009 . first line contain two integer number n m ( 1 ≤ n ≤ 1000 1 ≤ m ≤ 10 ) — length string number sequence collection correspondently next m line contain collection sequence si one per line si a nonempty string length greater 10 . string consist uppercase letter ` ` a '' ` ` c '' ` ` g '' ` ` t '' collection may contain identical string output contain a single integer — number string filter collection modulo 1000000009 ( 109 + 9 ) first sample a string filter ` ` a '' clearly one string : ` ` aa '' second sample exist exactly two different string satisfy condition ( see picture ),['dp'],2500.0
1746/E2,"difference problem hard version maximum number question interactive problem a hide integer $$$ 1 \le x \le n $$$ find order find ask $$$ \mathbf { 53 } $$$ question question choose a non - empty integer set $$$ s $$$ ask $$$ x $$$ belong $$$ s $$$ question $$$ x $$$ belong $$$ s $$$ 'll receive ` ` yes '' otherwise ` ` '' problem answer necessarily true ( joke ) 's guarantee two consecutive question least one answer correctly additionally question make $$$ 2 $$$ guess answer $$$ x $$$ time make a guess guess $$$ x $$$ correctly receive ` ` : ) '' program terminate otherwise 'll receive ` ` : ( ` ` a part joke fix value $$$ x $$$ begin instead change throughout interaction long previous responses valid describe note answer guess always answer correctly ask a question a guess least one two question answer correctly normal line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) maximum possible value $$$ x $$$ question want ask a set $$$ s $$$ first print character ' ? ' print size $$$ s $$$ print elements $$$ s $$$ one one element integer $$$ 1 $$$ $$$ n $$$ elements must distinct question read a string ` ` yes '' ` ` '' explain statement make $$$ 53 $$$ question want guess $$$ x $$$ first print character ' ! ' print guess guess read ` ` : ) '' ` ` : ( ` ` guess $$$ x $$$ correctly answer ` ` : ) '' program terminate immediately otherwise 'll receive ` ` : ( ` ` make $$$ 2 $$$ guess print a query forget output end line flush output otherwise get idleness limit exceed , use : hack allow problem answer first question correct $$$ x $$$ would equal $$$ 6 $$$ see first guess $$$ 6 $$$ answer answer first question joke know answer least one two question correct since answer first question joke answer second question correct understand $$$ x $$$ equal $$$ 1 2 3 $$$ $$$ 4 $$$ also know $$$ x $$$ equal $$$ 6 $$$ either hence $$$ x $$$ equal $$$ 5 $$$",['dp'],3200.0
793/D,bankopolis <unknown> city n crossroads locate a straight line number 1 n along crossroad a bank office crossroads connect m orient bicycle lanes ( i - th lane go crossroad ui crossroad vi ) difficulty lanes know oleg bank client want gift happiness joy bank employees want visit exactly k offices want gift present employees problem oleg n't want see reaction gift ca n't use a bicycle lane pass near office already present gift ( formally i - th lane pass near office x - th crossroad min ( ui vi ) < x < max ( ui vi ) ) ) course offices oleg present gift exactly oleg go use exactly k - 1 bicycle lane move offices oleg start path office finish office oleg want choose a path among possible ones total difficulty lanes use minimum possible find minimum possible total difficulty first line contain two integers n k ( 1 ≤ n k ≤ 80 ) — number crossroads ( offices ) number offices oleg want visit second line contain single integer m ( 0 ≤ m ≤ 2000 ) — number bicycle lanes bankopolis next m line contain information lanes i - th line contain three integers ui vi ci ( 1 ≤ ui vi ≤ n 1 ≤ ci ≤ 1000 ) denote crossroads connect i - th road difficulty line print minimum possible total difficulty lanes a valid path -1 valid paths first example oleg visit bank path 1 → 6 → 2 → 4 . path 1 → 6 → 2 → 7 smaller <unknown> incorrect crossroad 2 → 7 pass near already visit office crossroad 6 . second example oleg visit bank path 4 → 1 → 3,['dp'],2100.0
814/E,"<unknown> return home a long journey affect oddity snail lose way <unknown> oddity 's <unknown> would n't like happen 's nothing a <unknown> figure , would like know enormous number possibilities face someone get lose n towns region number 1 n. town number 1 call capital traffic network form bidirectional roads connect pair towns two roads connect pair towns road connect a town time need travel roads lose travelers able find towns connect residents help provide follow facts : count number different ways towns connect give answer modulo 109 + 7 . two ways connect towns consider different a pair ( u v ) ( 1 ≤ u v ≤ n ) exist a road towns u v one first line input contain a positive integer n ( 3 ≤ n ≤ 50 ) — number towns second line contain n space - separated integers d1 d2 ... <unknown> ( 2 ≤ di ≤ 3 ) — number roads connect towns 1 2 ... n respectively guarantee sum di i even output one integer — total number different possible ways towns connect modulo 109 + 7 . first example follow structure one satisfy constraints distance towns 2 3 4 capital 1 . second example follow two structure satisfy constraints",['dp'],2600.0
772/D,"give n integers a1 a2 ... , denote list integers t. let f ( l ) a function take a non - empty list integers l. function output another integer follow : example f ( 10 9 ) = 0 f ( 123 321 ) = 121 f ( <unknown> <unknown> 81 ) = 30 . define function word g ( x ) sum square sum elements nonempty subsequences t evaluate x plug f modulo 1 000 000 <unknown> multiply x. last multiplication <unknown> would like compute g ( 0 ) g ( 1 ) ... g ( 999 999 ) reduce output size print value denote bitwise xor operator first line contain integer n ( 1 ≤ n ≤ 1 000 000 ) — size list t. next line contain n space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 999 999 ) — elements list output a single integer answer problem first sample nonzero value g g ( 121 ) = <unknown> <unknown> <unknown> g ( 123 ) = <unknown> <unknown> 999 g ( 321 ) = <unknown> <unknown> <unknown> g ( 555 ) = <unknown> <unknown> <unknown> . bitwise xor number equal <unknown> <unknown> <unknown> . example , since subsequences [ 123 ] [ 123 555 ] evaluate 123 plug f. second sample last sample , <unknown> coefficient",['dp'],2700.0
776/G,"sherlock find a piece encrypt data think useful catch moriarty encrypt data consist two integer l r. notice integers hexadecimal form take integers l r perform follow operations : one example : integer 1e sum sum = 21 + <unknown> . letter a b c d e f denote hexadecimal digits 10 11 12 13 14 15 <unknown> sherlock want count number range l r ( inclusive ) decrease application four step want answer q query different l r. first line contain integer q ( 1 ≤ q ≤ 10000 ) next q line contain two hexadecimal integers l r ( 0 ≤ l ≤ r < <unknown> ) hexadecimal integers write use digits 0 9 and/or lowercase english letter a b c d e f. hexadecimal integers contain extra lead zero output q line i - th line contain answer i - th query ( decimal notation ) second <unknown> = <unknown> = 21 + 24 = 18 thus reduce , verify number range 1 1e reduce",['dp'],2900.0
773/D,country never n cities a well - <unknown> road system exactly one bidirectional road every pair cities thus many roads ! two roads intersect road pass intermediate cities art build <unknown> bridge master neverians independent committee evaluate road never a positive integer call perishability road lower road 's perishability <unknown> drive road 's year transport never decide build a museum transport one cities set a single signpost direct city ( necessarily one museum ) cities signpost must satisfy follow important condition : neverian live a city without museum start travel city follow directions signpost person eventually arrive city museum neverians <unknown> positive - <unknown> a neverian travel a route consist several roads consider perishability route equal smallest perishability roads route government never yet decide build museum consider n possible options important sum perishabilities rout museum city cities never travelers strictly follow directions signpost government never care citizens want set signpost a way minimize sum help determine minimum possible sum n possible options city museum build first line contain a single integer n ( 2 ≤ n ≤ 2000 ) — number cities never follow n - 1 line contain description road network i - th line contain n - i integers j - th integer i - th line denote perishability road cities i i + j. road perishabilities 1 109 inclusive city order 1 n output minimum possible sum perishabilities rout city cities never signpost set a way minimize sum first example explain picture leave right initial road network optimal directions signpost case museum build city 1 2 3 respectively museum city represent a blue circle directions signpost represent green arrows instance museum build city 3 signpost city 1 must direct city 3 signpost city 2 must direct city 1 . route city 1 city 3 perishability 2 route city 2 city 3 perishability 1 . sum perishabilities rout 3,['dp'],2700.0
1249/E,plan buy apartment a $$$ n $$$ <unknown> build floor number $$$ 1 $$$ $$$ n $$$ bottom top first floor want know minimum total time reach first ( bottom ) floor let : one move go floor stay $$$ x $$$ floor $$$ y $$$ ( $$$ x \ne y $$$ ) two different ways : perform many move want ( possibly zero ) task $$$ i $$$ determine minimum total time take reach $$$ i $$$ -th floor $$$ 1 $$$ -st ( bottom ) floor first line input contain two integers $$$ n $$$ $$$ c $$$ ( $$$ 2 \le n \le 2 \cdot 100000 1 \le c \le 1000 $$$ ) — number floor build time <unknown> elevator rid second line input contain $$$ n - 1 $$$ integers $$$ a_1 a_2 \dots a _ { n-1 } $$$ ( $$$ 1 \le a_i \le 1000 $$$ ) $$$ a_i $$$ time require go $$$ i $$$ -th floor $$$ ( i+1 ) $$$ -th one ( $$$ ( i+1 ) $$$ -th $$$ i $$$ -th well ) use stairs third line input contain $$$ n - 1 $$$ integers $$$ b_1 b_2 \dots b _ { n-1 } $$$ ( $$$ 1 \le b_i \le 1000 $$$ ) $$$ b_i $$$ time require go $$$ i $$$ -th floor $$$ ( i+1 ) $$$ -th one ( $$$ ( i+1 ) $$$ -th $$$ i $$$ -th well ) use elevator print $$$ n $$$ integers $$$ t_1 t_2 \dots t_n $$$ $$$ t_i $$$ minimum total time reach $$$ i $$$ -th floor first floor perform many move want,['dp'],1700.0
238/E,urpal live a big city plan meet lover <unknown> city n junctions number 1 n. junctions connect m direct streets roads equal length urpal live junction a date plan a restaurant junction b. want use public transportation get junction b. k bus transportation company begin every second a bus i - th company choose a random shortest path junction si junction ti pass might path si ti case bus leave si ti a bus pass a junction urpal stand get bus also get <unknown> bus junction along path urpal want know 's possible go date use public transportation a finite amount time ( time travel sum length travel roads ) minimum number bus take worst case moment urpal know position place date get bus know index company bus course urpal know city map pair ( si ti ) company note urpal n't know bus velocity first line input contain four integers n m a b ( 2 ≤ n ≤ 100 ; 0 ≤ m ≤ n · ( n - 1 ) ; 1 ≤ a b ≤ n ; a ≠ b ) next m line contain two integers ui vi ( 1 ≤ ui vi ≤ n ; ui ≠ vi ) describe a direct road junction ui junction vi roads input distinct next line contain integer k ( 0 ≤ k ≤ 100 ) k line contain two integers si ti ( 1 ≤ si ti ≤ n ; si ≠ ti ) say a bus route start si end ti please note might path si ti case describe problem statement line output print minimum number bus urpal get way worst case 's possible reach destination worst case print -1,['dp'],2600.0
295/B,greg a weigh direct graph consist n vertices graph pair distinct vertices edge directions greg love play graph invent a new game : help greg print value require sum step first line contain integer n ( 1 ≤ n ≤ 500 ) — number vertices graph next n line contain n integers — graph adjacency matrix : j - th number i - th line aij ( 1 ≤ aij ≤ 105 aii = 0 ) represent weight edge go vertex i vertex j. next line contain n distinct integers : x1 x2 ... xn ( 1 ≤ xi ≤ n ) — vertices greg delete print n integers — i - th number equal require sum i - th step please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier,['dp'],1700.0
346/D,boss company robot a <unknown> man <unknown> ` ` move forward die ! ` ` exactly company 's product look behavior company 's robot walk direct graph behavior call ` ` three laws <unknown> '' : imagine a robot behave like ? 's sell a low price short money include mzry1992 course mzry1992 a robot want move vertex s vertex t a direct graph safely without self - destruction luckily send robot special order vertex a special order show robot way move multiple ways move ( prevent random move robot accord law 3 ) robot reach vertex t mzry1992 take graph immediately see long exist a path s t always find a way reach goal ( whatever vertex t <unknown> zero ) however send order expensive task find minimum number order mzry1992 need send worst case please note mzry1992 give order robot walk graph look first sample clarify part problem first line contain two integers n ( 1 ≤ n ≤ 106 ) — number vertices graph m ( 1 ≤ m ≤ 106 ) — number edge m line follow two integers ui vi ( 1 ≤ ui vi ≤ n ; vi ≠ ui ) integers denote a direct edge vertex ui vertex vi last line contain two integers s t ( 1 ≤ s t ≤ n ) guarantee multiple edge self - loops a way reach a goal print require minimum number order worst case otherwise print -1 . consider first test sample initially robot vertex 1 . first step robot go vertex 2 3 . matter vertex robot choose mzry1992 must give order robot order go vertex 4 . mzry1992 n't give order robot vertex 2 3 robot choose ` ` bad '' outgo edge ( return vertex 1 ) accord law 3 . answer one,['dp'],2600.0
416/E,good old berland n cities m roads road connect a pair distinct cities bidirectional pair cities one road road know length also know president soon ride along berland roads city s city t. naturally choose one shortest paths s t nobody say sure path choose <unknown> transport really afraid president might get upset state roads country reason plan repair roads possible president 's path make budget event easy task possible distinct pair s t ( s < t ) find number roads lie least one shortest path s t. first line input contain integers n m ( 2 ≤ n ≤ 500 0 ≤ m ≤ n · ( n - 1 ) / 2 ) — number cities roads correspondingly m line follow contain road descriptions one description per line description contain three integers xi yi li ( 1 ≤ xi yi ≤ n xi ≠ yi 1 ≤ li ≤ 106 ) xi yi number cities connect i - th road li length print sequence integers <unknown> <unknown> ... <unknown> <unknown> <unknown> ... <unknown> ... cn - 1 n cst number roads lie shortest path s t. print elements sequence c describe order pair cities s t n't a path cst = 0,['dp'],2500.0
208/C,"berland road network consist n cities m bidirectional roads cities number 1 n main capital city number n culture capital — number 1 . road network set possible reach city one roads move road direction take time residents berland lazy people want get city v city u always choose one shortest paths ( matter one ) berland government want make country 's road network <unknown> , go put a police station one city police station a rather strange property : a citizen berland drive along road a police station one end citizen drive carefully roads consider safe roads end differ city police station dangerous government wonder put police station average number safe roads shortest paths cultural capital main capital would take maximum value first input line contain two integers n m ( 2 ≤ n ≤ 100 ) — number cities number roads berland correspondingly next m line contain pair integers vi ui ( 1 ≤ vi ui ≤ n vi ≠ ui ) — number cities connect i - th road number a line separate a space guarantee pair cities connect one road possible get city one along berland roads print maximum possible value average number safe roads among shortest paths culture capital main one answer consider valid absolute relative <unknown> exceed 10 - 6 . first sample put a police station one <unknown> path exactly one safe road place station capital average number safe roads also make second sample obtain maximum seek value put station city 4 6 paths 2 safe roads one path 0 safe roads answer equal",['dp'],1900.0
295/C,one day greg friends walk forest overall n people walk include greg soon find front a river guy immediately decide get across river luckily a boat river bank guy stand know boat hold people total weight k kilograms greg immediately take a piece paper list weight people group ( include ) turn person weight either 50 100 kilograms greg want know minimum number time boat need cross river transport whole group bank boat need least one person navigate one bank boat cross river non - zero number passengers long total weight n't exceed k. also greg wonder many ways transport everybody side minimum number boat rid two ways consider distinct ride distinct set people boat help greg problem first line contain two integers n k ( 1 ≤ n ≤ 50 1 ≤ k ≤ 5000 ) — number people include greg boat 's weight limit next line contain n integers — people 's weight a person 's weight either 50 kilos 100 kilos consider greg friends index way first line print integer — minimum number rid transport everyone bank impossible print integer -1 . second line print remainder divide number ways transport people minimum number rid number 1000000007 ( 109 + 7 ) transport everyone bank impossible print integer 0 . first test greg walk alone consequently need one ride across river second test follow plan : total 5 rid depend person choose step 2 get two distinct ways,['dp'],2100.0
850/C,mojtaba arpa play a game a list n number game a player 's turn choose a number pk ( p a prime number k a positive integer ) pk divide least one number list number list divisible pk call x player delete x add list player make a valid choice p k lose mojtaba start game players alternatively make move determine one players winner players play optimally first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number elements list second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — elements list mojtaba win print ` ` mojtaba '' otherwise print ` ` arpa '' ( without quote ) print letter case ( upper lower ) first sample test mojtaba ca n't move second sample test mojtaba choose p = 17 k = 1 list change [ 1 1 1 1 ] third sample test mojtaba choose p = 17 k = 1 arpa choose p = 17 k = 1 win mojtaba choose p = 17 k = 2 arpa choose p = 17 k = 1 win,['dp'],2200.0
282/D,"since contestants read part i repeat bitlandians quite weird job work method live sausages game ! since curious bitland i 'll give chance <unknown> one game bitlgm bitaryo play yet another crazy - looking genius - <unknown> <unknown> game ' ve get a sequence n non - negative integers a1 a2 ... , players make move turn bitlgm move first player must one two follow action turn : player make a move lose 're give initial sequence a1 a2 ... , determine win players play optimally well bitlgm bitaryo start play describe game sequence first line contain integer n ( 1 ≤ n ≤ 3 ) next line contain n integers a1 a2 ... ( 0 ≤ ai < 300 ) write name winner ( provide players play optimally well ) either ` ` bitlgm '' ` ` bitaryo '' ( without quote )",['dp'],2100.0
138/D,recently roma become happy owner a new game world darkraft game combine elements <unknown> know genres one later stag game roma face difficulties solve a puzzle part roma fight a cunning enemy magician battle take place a rectangular field <unknown> n × m. cell contain one magical character : l r x. initially square field ` ` active '' players roma enemy magician take turn roma make first move a move a player select one active cells depend image character cell one follow action take place : next player make a move ( i.e. cells inactive ) lose roma try defeat computer opponent three days keep lose ask help determine whether guarantee beat opponent hack game first line contain two space - separated integers n m ( 1 ≤ n m ≤ 20 ) next n line contain m character describe play field : j - th character i - th line equal magical character correspond field square first line print ` ` win '' roma win ` ` lose '' impossible win consider opponent pay optimally first test move make one diagonal line square inactive thus guarantee roma lose two move three variants make a move second test : ` ` finish '' main diagonal line square leave mean three move game stop roma win,['dp'],2500.0
317/D,vasya petya write integers 1 n play ` ` power '' game ( n quite large ; however vasya petya confuse fact ) players choose number turn ( vasya choose first ) number x choose current turn forbid choose x positive integer power ( x2 x3 ... ) next turn instance number 9 choose first turn one choose 9 81 later still allow choose 3 27 . one make a move lose win vasya petya play optimally ? input contain single integer n ( 1 ≤ n ≤ 109 ) print name winner — ` ` vasya '' ` ` petya '' ( without quote ) first sample vasya choose 1 win immediately second sample matter number vasya choose first turn petya choose remain number win,['dp'],2300.0
273/E,dima anya love play different game dima imagine a new game want play anya dima write n pair integers a piece paper ( li ri ) ( 1 ≤ li < ri ≤ p ) players take turn turn player follow action : player ca n't make a move lose course dima want anya move first win 's dima write n pair integers ( li ri ) ( 1 ≤ li < ri ≤ p ) players play optimally well first one win count number ways dima print remainder divide answer number 1000000007 ( 109 + 7 ) two ways consider distinct order sequence write pair distinct first line contain two integers n p ( 1 ≤ n ≤ 1000 1 ≤ p ≤ 109 ) number separate a single space a single line print remainder divide answer problem number 1000000007 ( 109 + 7 ),['dp'],2600.0
536/D,tavas live kansas kansas n cities number 1 n connect m bidirectional roads travel city city via roads kansas strange tavas may a road a city one road two cities tavas invent a game call ` ` dashti '' want play dashti <unknown> nafas game assign arbitrary integer value city kansas value i - th city equal pi game tavas city s nafas city t. play turn tavas go first a player his / her turn must choose a non - negative integer x his / her score increase sum value cities ( shortest ) distance x his / her city city may use word first time a player get score a city city score become zero additional rule : player must choose x he / she get point least one city use note city may initially value 0 city n't consider use begin game i. e. player may use <unknown> rule game end nobody make a move a player 's score sum point he / she earn game winner player greater score a draw players score value players start game zero point tavas win 'll break girlfriend 's heart nafas win tavas cry score equal 'll happy tavas give nafas flower 're <unknown> 'll play optimally task tell tavas 's go happen game end first line input contain two integers n m ( 2 ≤ n ≤ 2000 n - 1 ≤ m ≤ 105 ) second line input contain two integers s t ( 1 ≤ s t ≤ n s ≠ t ) next line contain n integers p1 p2 ... pn separate space ( |pi| ≤ 109 ) next m line contain roads line contain three integers v u w mean 's road length w cities v u ( 1 ≤ u v ≤ n 0 ≤ w ≤ 109 ) road may lead city may several roads pair cities tavas win print ` ` break a heart '' nafas win print ` ` cry '' nobody win ( i. e. game end draw ) print ` ` flower '',['dp'],2900.0
731/E,upon a time petya gena gather another program competition decide play game consider modern game bore always try invent game stickers <unknown> wo n't stop game come follow rule initially n stickers wall arrange a row sticker number write alternate turn petya move first one move happen follow let say m ≥ 2 stickers wall player make current move pick integer k 2 m take k leftmost stickers ( remove wall ) make new sticker put leave end row write new integer equal sum stickers take move game end one sticker leave wall score player equal sum integers write stickers take move goal player maximize difference score score opponent give integer n initial sequence stickers wall define result game i.e difference petya 's gena 's score players play optimally first line input contain a single integer n ( 2 ≤ n ≤ 200 000 ) — number stickers initially locate wall second line contain n integers a1 a2 ... ( - 10 000 ≤ ai ≤ 10 000 ) — number stickers order leave right print one integer — difference petya 's score gena 's score end game players play optimally first sample optimal move petya take stickers a result score equal 14 gena 's score equal 0 . second sample optimal sequence move follow first move petya take first three sticker put new sticker value - 8 . second move gena take remain two stickers petya 's score 1 + ( - 7 ) + ( - 2 ) = - 8 gena 's score ( - 8 ) + 3 = - 5 i.e score difference - 3,['dp'],2200.0
838/C,alice bob play a game a string character alice go first string consist n character one first k letter alphabet a player ’ s turn either arbitrarily permute character word delete exactly one character word ( least one character ) addition result word appear throughout entire game player unable make a valid move lose game give n k p find number word exactly n character consist first k letter alphabet alice win alice bob play optimally return number modulo prime number p. first line input contain three integers n k p ( 1 ≤ n ≤ 250 000 1 ≤ k ≤ 26 108 ≤ p ≤ 109 + 100 p prime ) print a single integer number win word alice modulo p. 14 string alice win example string ` ` bbaa '' ` ` <unknown> '' alice lose string like ` ` aaaa '' ` ` <unknown> '',['dp'],2800.0
859/C,may hear pie rule state two people wish fairly share a slice pie one person cut slice half person choose get slice alice bob many slice pie rather cut slice half individual slice eat one person way alice bob decide eat slice follow first order pies hand decide a special token call ` ` decider '' token initially hold bob pie hand <unknown> decider token give next slice pie one participants decider token participant continue slice pie leave slice excellent quality participant obviously want maximize total amount pie get eat assume players make decisions optimally much pie participant receive ? input begin integer n ( 1 ≤ n ≤ 50 ) number slice pie follow a line n integers indicate size slice ( 1 100000 inclusive ) order must hand print two integers first sum size slice eat alice sum size slice eat bob assume players make decisions optimally first example bob take size <unknown> slice give decider token alice alice give size <unknown> slice bob keep decider token give size <unknown> slice,['dp'],1500.0
1070/A,give two positive integers $$$ d $$$ $$$ s $$$ find minimal positive integer $$$ n $$$ divisible $$$ d $$$ sum digits equal $$$ s $$$ first line contain two positive integers $$$ d $$$ $$$ s $$$ ( $$$ 1 \le d \le 500 1 \le s \le 5000 $$$ ) separate space print require number -1 n't exist,['dp'],2200.0
69/D,anton dasha like play different game break checker paper <unknown> grade manage play game type ask vova programmer come a new game vova suggest play a game code name ` ` dot '' follow rule : help determine winner first line input file contain 4 integers x y n d ( - 200 ≤ x y ≤ 200 1 ≤ d ≤ 200 1 ≤ n ≤ 20 ) — initial coordinate dot distance d number vectors guarantee initial dot distance less d origin coordinate follow n line contain two non - negative number xi yi ( 0 ≤ xi yi ≤ 200 ) — coordinate i - th vector guarantee vectors nonzero different print ` ` anton '' winner anton case players play game optimally ` ` dasha '' otherwise first test anton go vector ( 1 ; 2 ) dasha lose second test dasha first move shift dot coordinate ( 2 ; 3 ) anton lose possible move — reflect relatively line y = x. dasha respond move return dot position ( 2 ; 3 ),['dp'],1900.0
1725/M,pak chanek play one favourite board game game a direct graph $$$ n $$$ vertices $$$ m $$$ edge graph edge $$$ i $$$ connect two different vertices $$$ u_i $$$ $$$ v_i $$$ a length $$$ w_i $$$ use $$$ i $$$ -th edge something move $$$ u_i $$$ $$$ v_i $$$ $$$ v_i $$$ $$$ u_i $$$ play game initially pak chanek must place hand onto two different vertices one move move one hand another vertex use edge move a hand vertex $$$ u_i $$$ vertex $$$ v_i $$$ pak chanek need a time $$$ w_i $$$ second note pak chanek move one hand a time game end pak chanek 's hand vertex pak chanek several question $$$ p $$$ satisfy $$$ 2 \leq p \leq n $$$ need find minimum time second need pak chanek end game initially pak chanek 's leave hand right hand place vertex $$$ 1 $$$ vertex $$$ p $$$ report impossible first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \leq 100000 $$$ $$$ 0 \leq m \leq 200000 $$$ ) — number vertices edge graph $$$ i $$$ -th next $$$ m $$$ line contain three integers $$$ u_i $$$ $$$ v_i $$$ $$$ w_i $$$ ( $$$ 1 \le u_i v_i \le n $$$ $$$ u_i \neq v_i $$$ $$$ 1 \le w_i \le 1000000000 $$$ ) — a direct edge connect two different vertices $$$ u_i $$$ $$$ v_i $$$ a length $$$ w_i $$$ pair different edge $$$ i $$$ $$$ j $$$ $$$ u_i = u_j $$$ $$$ v_i = <unknown> $$$ output a line contain $$$ n-1 $$$ integers $$$ j $$$ -th integer represent minimum time second need pak chanek end game initially pak chanek 's leave hand right hand place vertex $$$ 1 $$$ vertex $$$ j+1 $$$ $$$ -1 $$$ impossible initially pak chanek 's leave hand vertex $$$ 1 $$$ right hand vertex $$$ 5 $$$ pak chanek follow move : total need $$$ 1 + 2 + <unknown> $$$ second prove way faster,['dp'],1800.0
78/C,two beaver timur marsel play follow game n log exactly m meter length beaver move turn move a beaver choose a log gnaw number ( one ) equal part length one express integer less k meter result part also a log gnaw future beaver beaver ca n't make a move lose thus beaver win timur make first move players play optimal way determine winner first line contain three integers n m k ( 1 ≤ n m k ≤ 109 ) print ` ` timur '' timur win ` ` marsel '' marsel win print everything without quote first sample beaver one log 15 meter length timur move first move split log 3 part 5 meter length marsel move ca n't split result log k = 4 . thus winner timur second example beaver 4 log 9 meter length timur ca n't split result part possess length less 5 meter 's lose instantly,['dp'],2000.0
1517/D,"wander explorer space <unknown> conference explorer space view undirected weight grid graph size $$$ n\times m $$$ set vertices $$$ \ { ( i j ) <unknown> i\le n 1\le j\le <unknown> } $$$ two vertices $$$ ( i_1 j_1 ) $$$ $$$ ( i_2 j_2 ) $$$ connect edge $$$ |i_1 - <unknown> - <unknown> $$$ step walk vertex connect edge current vertex edge number exhibit since already know exhibit whenever go edge contain $$$ x $$$ exhibit boredness increase $$$ x $$$ start vertex $$$ ( i j ) $$$ please answer follow question : minimum possible boredness walk $$$ ( i j ) $$$ go back exactly $$$ k $$$ step ? use edge multiple time boredness edge also count multiple time step stay current vertex also change direction go edge go back start vertex $$$ ( i j ) $$$ $$$ k $$$ step visit $$$ ( i j ) $$$ ( ) freely first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2\leq n m\leq 500 1\leq k\leq 20 $$$ ) $$$ j $$$ -th number ( $$$ 1\le j \le m - 1 $$$ ) $$$ i $$$ -th line follow $$$ n $$$ line number exibits edge vertex $$$ ( i j ) $$$ vertex $$$ ( i j+1 ) $$$ $$$ j $$$ -th number ( $$$ 1\le j\le m $$$ ) $$$ i $$$ -th line follow $$$ n-1 $$$ line number exibits edge vertex $$$ ( i j ) $$$ vertex $$$ ( i+1 j ) $$$ number exhibit edge integer $$$ 1 $$$ $$$ 1000000 $$$ output $$$ n $$$ line $$$ m $$$ number $$$ j $$$ -th number $$$ i $$$ -th line $$$ answer _ { ij } $$$ minimum possible boredness walk $$$ ( i j ) $$$ go back exactly $$$ k $$$ step go back vertex $$$ ( i j ) $$$ exactly $$$ k $$$ step $$$ answer _ { ij } $$$ $$$ -1 $$$ first example answer always $$$ 10 $$$ matter walk second example $$$ answer _ { 21 } = 10 $$$ path $$$ ( 2,1 ) \to ( 1,1 ) \to ( 1,2 ) \to ( 2,2 ) \to ( 2,1 ) $$$ boredness $$$ 4 + 1 + 2 + 3 = 10 $$$",['dp'],1800.0
48/E,upon a time a kingdom far far away <unknown> okay let ’ s start point ivan fool meet gorynych dragon ivan take magic sword battle begin first gorynych h head t tail strike sword ivan either cut several head ( 1 n gorynych moment ) several tail ( 1 m gorynych moment ) time horrible though seem gorynych dragon also grow new head tail number grow head tail determine uniquely number head tail cut current strike total number head tail exceed r gorynych dragon strike final blow destroy ivan fool ’ s ivan aim cut dragon ’ s head tail quickly possible win events also develop a third way : neither opponents win one continue fight forever <unknown> go like ; easy say hard task write a program determine battle ’ s outcome consider ivan strike consecutively blow gorynych grow a number new head tail depend number cut ones gorynych dragon defeat blow lose head tail ’ t grow new ones ivan fight optimal way ( fool lucky ) i.e first line contain three integers h t r ( 0 ≤ h t r ≤ 200 0 < h + t ≤ r ) represent initial number gorynych ’ s head tail largest total number head tail gorynych dragon yet attack next line contain integer n ( 1 ≤ n ≤ 200 ) next n contain pair non - negative number ` ` hi ti '' represent number head number tail correspondingly grow gorynych i head ( 1 ≤ i ≤ n ) cut next line contain integer m ( 1 ≤ m ≤ 200 ) — description gorynych ’ s behavior tail cut format identical one describe number input file exceed 200 . print ` ` ivan '' ( without quote ) first line ivan win ` ` <unknown> '' ( mean a dragon russian ) gorynych dragon win second line print a single integer represent number blow ivan make battle continue forever print first line ` ` draw '',['dp'],2100.0
187/B,pmp get a warrior practice a lot result acceptable yet time instead program contest decide compete a car race increase spirit victory decide choose a competition also exhibit algorithmic feature <unknown> a special league car race different team compete a country n cities cities number 1 n. every two distinct cities country connect one bidirectional road compete team introduce one driver a set cars competition hold r round i - th round drivers start city si finish city ti drivers allow change cars ki time change cars take place city time one car use multiple time one round total number change exceed ki drivers freely choose path destination pmp prepare m type purpose - <unknown> cars <unknown> pmp ’ s drive skills depend properties car road a car traverse road direction different time pmp warriors want devise best strategies choose car roads round maximize chance win cup round want find minimum time require finish first line contain three space - separated integers n m r ( 2 ≤ n ≤ 60 1 ≤ m ≤ 60 1 ≤ r ≤ 105 ) — number cities number different type cars number round competition correspondingly next m set n × n matrices integers 0 106 ( inclusive ) follow — describe time one car require traverse different roads k - th integer j - th line i - th set time i - th car require traverse road j - th city k - th city matrices necessarily symmetric diagonal always zero next r line contain description round i - th line contain space - separated integers si ti ki ( 1 ≤ si ti ≤ n si ≠ ti 0 ≤ ki ≤ 1000 ) — number start city finish city number possible car change i - th round correspondingly round print minimum require time complete round a single line first sample round pmp go city # 1 city # 2 city # 3 finally city # 4 . sequence type cars use ( 1 2 1 ) first round ( 1 2 2 ) second round third round although change car three time use strategy first round need two car change,['dp'],1800.0
1765/C,"consider a deck card card one $$$ 4 $$$ suit exactly $$$ n $$$ card suit — total number card deck $$$ 4n $$$ deck shuffle randomly $$$ ( 4n ) ! $$$ possible order card deck probability result shuffle let $$$ c_i $$$ $$$ i $$$ -th card deck ( top bottom ) monocarp start draw card deck one one draw a card try guess suit monocarp remember suit $$$ k $$$ last card guess suit appear least often among last $$$ k $$$ card draw , draw $$$ i $$$ -th card monocarp guess suit suit appear minimum number time among card $$$ c _ { i - k } c _ { i - k+1 } \dots c _ { i-1 } $$$ ( $$$ i \le k $$$ monocarp consider previously draw card , card $$$ c_1 c_2 \dots c _ { i-1 } $$$ ) multiple suit appear minimum number time among previous card monocarp remember choose a random suit guess ( suit appear minimum number time probability choose ) make a guess monocarp draw a card compare suit guess match guess correct ; otherwise incorrect task calculate expect number correct guess monocarp make draw $$$ 4n $$$ card deck first ( ) line contain two integers $$$ n $$$ ( $$$ 1 \le n \le 500 $$$ ) $$$ k $$$ ( $$$ 1 \le k \le 4 \cdot n $$$ ) let expect value calculate irreducible fraction $$$ \dfrac { x } { y } $$$ print one integer — value $$$ x \cdot y^ { -1 } \bmod 998244353 $$$ $$$ y^ { -1 } $$$ inverse $$$ y $$$ ( i. e. integer $$$ y \cdot y^ { -1 } \bmod 998244353 = 1 $$$ )",['dp'],2600.0
1245/E,hyakugoku <unknown> resident deity south black snail temple order <unknown> dream become a <unknown> spend six months temple play ` ` cat 's <unknown> '' want try a different game — ` ` snake ladder '' unfortunately already kill snake ladder leave game play a $$$ 10 \times 10 $$$ board follow : please note : hyakugoku want finish game soon possible thus turn choose whether climb ladder optimally help determine minimum expect number turn game take input consist ten line $$$ i $$$ -th line contain 10 non - negative integers $$$ h _ { i1 } h _ { i2 } \dots h _ { <unknown> } $$$ $$$ h _ { ij } $$$ $$$ 0 $$$ tile $$$ i $$$ -th row $$$ j $$$ -th column ladder otherwise ladder tile a height $$$ h _ { ij } $$$ i.e climb lead tile $$$ h _ { ij } $$$ row directly guarantee $$$ 0 \leq h _ { ij } < i $$$ also first number first line first number last line always contain $$$ 0 $$$ i.e goal start tile never ladder print one line contain a single floating - point number — minimum expect number turn hyakugoku take finish game answer consider correct absolute relative error exceed $$$ 10^ { -6 } $$$ a <unknown> path board example 2 follow : tile 's ' start tile tile ' e ' goal first example ladder second example board look like one right part image ( ladder color clarity ) possible ladder overlap case red yellow ladder green blue ladder also possible ladder go straight top case black blue ladder however possible ladder go higher ( outside board ) also possible two ladder lead tile case red yellow ladder also notice red yellow ladder lead tile orange ladder player choose climb either red yellow ladder able climb orange ladder finally notice green ladder pass start tile blue ladder player transfer green ladder blue ladder middle climb green ladder,['dp'],2300.0
1264/D1,easy version problem difference limit $$$ n $$$ - length input string version $$$ 1 \leq n \leq 2000 $$$ hard version challenge offer round second division let 's define a correct bracket sequence depth follow : a ( necessarily correct ) bracket sequence $$$ s $$$ define depth maximum depth correct bracket sequence induce remove character $$$ s $$$ ( possibly zero ) example : bracket sequence $$$ s = $$$ ` ` ( ) ) ( ( ) ) '' depth $$$ 2 $$$ remove third character obtain a correct bracket sequence ` ` ( ) ( ( ) ) '' depth $$$ 2 $$$ give a string $$$ a $$$ consist character ' ( ' ' ) ' ' ? ' consider ( necessarily correct ) bracket sequence obtain replace character ' ? ' $$$ a $$$ either ' ( ' ' ) ' calculate sum depths bracket sequence number large find modulo $$$ 998244353 $$$ hack problem first division do easy hard versions problem solve line contain a non - empty string consist ' ( ' ' ) ' ' ? ' length string $$$ 2000 $$$ print answer modulo $$$ 998244353 $$$ a single line first test case obtain $$$ 4 $$$ bracket sequence replace character ' ? ' either ' ( ' ' ) ' : answer $$$ 1 = 0 + 0 + 0 + 1 $$$ second test case obtain $$$ 4 $$$ bracket sequence replace character ' ? ' either ' ( ' ' ) ' : answer $$$ 9 = 2 + 2 + 3 + 2 $$$,['dp'],2600.0
1295/F,online contest soon hold forcecoders a large competitive program platform author prepare $$$ n $$$ problems ; since platform popular $$$ 998244351 $$$ coder world go solve problem author estimate number people would solve : $$$ i $$$ -th problem number accept solutions $$$ l_i $$$ $$$ r_i $$$ inclusive creator forcecoders use different criteria determine contest good bad one criteria number inversions problem order inversion a pair problems $$$ ( x y ) $$$ $$$ x $$$ locate earlier contest ( $$$ x < y $$$ ) number accept solutions $$$ y $$$ strictly greater obviously creator forcecoders author contest want contest good want calculate probability inversions problem order assume problem $$$ i $$$ integral number accept solutions ( $$$ l_i $$$ $$$ r_i $$$ ) equally probable number independent first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 50 $$$ ) — number problems contest $$$ n $$$ line follow $$$ i $$$ -th line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 0 \le l_i \le r_i \le 998244351 $$$ ) — minimum maximum number accept solutions $$$ i $$$ -th problem respectively probability inversions contest express irreducible fraction $$$ \frac { x } { y } $$$ $$$ y $$$ coprime $$$ 998244353 $$$ print one integer — value $$$ <unknown> { -1 } $$$ take modulo $$$ 998244353 $$$ $$$ y^ { -1 } $$$ integer $$$ <unknown> { -1 } \equiv 1 $$$ $$$ ( mod $$$ $$$ 998244353 ) $$$ real answer first test $$$ \frac { 1 } { 2 } $$$,['dp'],2700.0
914/H,ember storm play a game first ember pick a label tree t n vertices degree every vertex d. storm pick two distinct vertices u v tree write label vertices path u v a sequence a1 a2 ... ak finally ember pick index i ( 1 ≤ i < k ) array perform one follow two operations exactly : ember win array <unknown> increase decrease otherwise storm win game describe tuple ( t u v i op ) op « flip » « <unknown> » depend action ember choose last turn find number tuples occur ember storm play optimally play optimally multiple move guarantee win may play win move otherwise someone lose matter play may play possible move report answer modulo m. input consist a single line contain three integers n d m ( 2 ≤ n ≤ 200 1 ≤ d < n 1 ≤ m ≤ 2·109 ) print a single number — number possible tuples ember storm play describe modulo m. first sample case one possible tree two possible paths 1 2 2 1 . paths i 1 op take possibilities therefore answer 4 . second sample possible tree third sample three possible tree,['dp'],3400.0
39/E,know <unknown> principle point n box less n + 1 items lead existence a box least two items hear principle master technique logical think 8 year <unknown> stas masha invent a game a different box b different items turn a player either add a new box a new item player whose turn number ways put b items a box become less a certain give number n lose box items consider different box may remain empty lose players play optimally stas 's turn first ? input line three integers a b n ( 1 ≤ a ≤ 10000 1 ≤ b ≤ 30 2 ≤ n ≤ 109 ) — initial number box number items number constrain number ways respectively guarantee initial number ways strictly less n. output ` ` stas '' masha win output ` ` masha '' stas win case a draw output ` ` miss '' second example initial number ways equal <unknown>,['dp'],2000.0
1107/F,vasya want buy a nice new car unfortunately lack money currently exactly 0 burl however local bank $$$ n $$$ credit offer offer describe three number $$$ a_i $$$ $$$ b_i $$$ $$$ k_i $$$ offer number $$$ 1 $$$ $$$ n $$$ vasya take $$$ i $$$ -th offer bank give $$$ a_i $$$ burl begin month vasya pay bank $$$ b_i $$$ burl end month next $$$ k_i $$$ months ( include month activate offer ) vasya take offer order want month vasya take one credit offer also credit offer use several credit active time imply vasya pay bank sum $$$ b_i $$$ $$$ i $$$ active credit end month vasya want buy a car middle month take money currently buy car exact price vasya n't really care 'll pay bank back buy a car go country car bank ca n't find <unknown> maximum price car ? first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 500 $$$ ) — number credit offer next $$$ n $$$ line contain three integers $$$ a_i $$$ $$$ b_i $$$ $$$ k_i $$$ ( $$$ 1 \le a_i b_i k_i \le 1000000000 $$$ ) print one integer — maximum price car first example follow sequence offer take optimal : 4 $$$ \rightarrow $$$ 3 . amount burl vasya change follow way : 5 $$$ \rightarrow $$$ 32 $$$ \rightarrow $$$ <unknown> $$$ \rightarrow $$$ <unknown> take money middle second month ( 32 burl ) buy car negative amount money mean vasya pay bank amount burl second example follow sequence offer take optimal : 3 $$$ \rightarrow $$$ 1 $$$ \rightarrow $$$ 2 . amount burl vasya change follow way : 0 $$$ \rightarrow $$$ 300 $$$ \rightarrow $$$ <unknown> $$$ \rightarrow $$$ <unknown> $$$ \rightarrow $$$ <unknown> $$$ \rightarrow $$$ <unknown> $$$ \rightarrow $$$ ..,['dp'],2600.0
1096/G,bus ticket berland number a number consist $$$ n $$$ digits ( $$$ n $$$ even ) $$$ k $$$ decimal digits $$$ d_1 d_2 \dots d_k $$$ use form ticket number $$$ 0 $$$ among digits number may lead zero example $$$ n = 4 $$$ digits $$$ 0 $$$ $$$ 4 $$$ use $$$ 0000 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ valid ticket number $$$ <unknown> $$$ $$$ 00 $$$ $$$ <unknown> $$$ a ticket lucky sum first $$$ n / 2 $$$ digits equal sum remain $$$ n / 2 $$$ digits calculate number different lucky ticket berland since answer may big print modulo $$$ 998244353 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ $$$ ( 2 \le n \le 2 \cdot 100000 1 \le k \le 10 ) $$$ — number digits ticket number number different decimal digits may use $$$ n $$$ even second line contain a sequence pairwise distinct integers $$$ d_1 d_2 \dots d_k $$$ $$$ ( 0 \le d_i \le 9 ) $$$ — digits may use ticket number digits give arbitrary order print number lucky ticket number take modulo $$$ 998244353 $$$ first example $$$ 6 $$$ lucky ticket number : $$$ 1111 $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ one ticket number second example consist $$$ 20 $$$ digits $$$ 6 $$$ ticket number lucky answer $$$ 1 $$$,['dp'],2400.0
1194/F,"today adilbek take probability theory test unfortunately adilbek arrive university already a long queue students want take test adilbek estimate able start test $$$ t $$$ second come fortunately adilbek spend time without <unknown> bore <unknown> <unknown> app <unknown> contain $$$ n $$$ <unknown> crosswords solve adilbek decide solve one one order list app without skip crossword crossword a number $$$ t_i $$$ give represent time take average crossword expert solve crossword ( time give second ) adilbek a true crossword expert , unfortunately sometimes unlucky choose way solve crossword , take either $$$ t_i $$$ second $$$ t_i + 1 $$$ second solve $$$ i $$$ -th crossword equiprobably ( probability $$$ \frac { 1 } { 2 } $$$ solve crossword exactly $$$ t_i $$$ second probability $$$ \frac { 1 } { 2 } $$$ spend additional second finish crossword ) events independent $$$ t $$$ second pass ( solve last crossword manage less $$$ t $$$ second ) adilbek close app ( finish crossword moment crossword consider solve ; otherwise adilbek finish solve current crossword ) think would interest probability theory problem calculate $$$ e $$$ — expect number crosswords able solve completely calculate ? recall expect value a discrete random variable probability - weighted average possible value — problem mean expect value number solve crosswords calculate $$$ e = \sum \limits _ { i = 0 } ^ { n } i p_i $$$ $$$ p_i $$$ probability adilbek solve exactly $$$ i $$$ crosswords represent $$$ e $$$ rational fraction $$$ \frac { p } { q } $$$ $$$ q > 0 $$$ give answer print $$$ p \cdot q^ { -1 } \bmod ( 1000000000 + 7 ) $$$ first line contain two integers $$$ n $$$ $$$ t $$$ ( $$$ 1 \le n \le 200000 $$$ $$$ 1 \le t \le 2 \cdot 10^ { 14 } $$$ ) — number crosswords time adilbek spend respectively second line contain $$$ n $$$ integers $$$ t_1 t_2 \dots t_n $$$ ( $$$ 1 \le t_i \le 1000000000 $$$ ) $$$ t_i $$$ time take a crossword expert solve $$$ i $$$ -th crossword note adilbek solve crosswords order give input without skip print one integer — expect value number crosswords adilbek solve $$$ t $$$ second express form $$$ p \cdot q^ { -1 } \bmod ( 1000000000 + 7 ) $$$ answer first sample equal $$$ \frac { 14 } { 8 } $$$ answer second sample equal $$$ \frac { 17 } { 8 } $$$",['dp'],2400.0
1172/C1,"difference easy hard versions constraints nauuo a girl love random picture websites one day make a random picture website include $$$ n $$$ picture nauuo visit website see exactly one picture website display picture equal probability $$$ i $$$ -th picture a non - negative weight $$$ w_i $$$ probability $$$ i $$$ -th picture display $$$ \frac { w_i } { \sum _ { j=1 } ^nw_j } $$$ say probability a picture display proportional weight however nauuo discover picture like display often solve problem come a great idea : saw a picture like would add $$$ 1 $$$ weight ; otherwise would subtract $$$ 1 $$$ weight nauuo visit website $$$ m $$$ time want know expect weight picture $$$ m $$$ visit modulo $$$ 998244353 $$$ help ? expect weight $$$ i $$$ -th picture denote $$$ \frac { q_i } { p_i } $$$ $$$ \gcd ( p_i q_i ) = 1 $$$ need print integer $$$ r_i $$$ satisfy $$$ 0\le r_i < 998244353 $$$ $$$ r_i\cdot p_i\equiv q_i\pmod { 998244353 } $$$ prove $$$ r_i $$$ exist unique first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1\le n\le 50 $$$ $$$ 1\le m\le 50 $$$ ) — number picture number visit website second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ a_i $$$ either $$$ 0 $$$ $$$ 1 $$$ ) — $$$ a_i=0 $$$ nauuo like $$$ i $$$ -th picture ; otherwise nauuo like $$$ i $$$ -th picture guarantee least one picture nauuo like third line contain $$$ n $$$ integers $$$ w_1 w_2 \ldots w_n $$$ ( $$$ 1\le <unknown> $$$ ) — initial weight picture output contain $$$ n $$$ integers $$$ r_1 r_2 \ldots r_n $$$ — expect weight modulo $$$ 998244353 $$$ first example visit show first picture a probability $$$ \frac 2 3 $$$ final weight $$$ ( 1,1 ) $$$ ; visit show second picture a probability $$$ \frac1 3 $$$ final weight $$$ ( 2,2 ) $$$ , expect weight $$$ \frac2 3\cdot 1+\frac 1 3\cdot 2=\frac4 3 $$$ $$$ 332748119\cdot 3\equiv 4\pmod { 998244353 } $$$ need print $$$ 332748119 $$$ instead $$$ \frac4 3 $$$ $$$ 1.3333333333 $$$ second example one picture nauuo like every time nauuo visit website $$$ w_1 $$$ increase $$$ 1 $$$ , expect weight $$$ 1 + 2=3 $$$ nauuo naughty n't give hint third example",['dp'],2300.0
277/D,many must familiar google code jam round rule let us remind key moments crucial solve problem round participants suggest solve several problems divide two <unknown> : easy one small limit ( small input ) a hard one large limit ( large input ) submit a solution large input ' ve solve small input problem restrictions order solve input particular participant first solve small input switch another problem return large input solve input give participant number point ( usually different problem ) take account complete solutions work correctly test input participant get test result a small input right submit test result a large input round 's final result table participants sort non - increasing receive point point equal participants sort ascend time penalty google code jam rule time penalty time last correct solution submit vasya decide check a new tactics another round soon round begin boy quickly read problems <unknown> evaluate time take solve specifically one n problems vasya know five value : a round last t minutes time read problems submit solutions consider equal zero vasya allow submit a solution exactly moment round end vasya want choose a set input order solution make expectation total receive point maximum possible multiple ways need minimize expectation time penalty help vasya cope problem first line contain two integers n t ( 1 ≤ n ≤ 1000 1 ≤ t ≤ 1560 ) follow n line contain 5 number : scoresmalli scorelargei timesmalli timelargei probfaili ( 1 ≤ scoresmalli scorelargei ≤ 109 1 ≤ timesmalli timelargei ≤ 1560 0 ≤ probfaili ≤ 1 ) <unknown> real number give 6 digits decimal point number input integers print two real number — maximum expectation total point correspond minimum possible time penalty expectation answer consider correct absolute relative error n't exceed 10 - 9 . first sample one optimal order solve problems : note solve small input second problem instead two input third one total score expectation time penalty expectation worse ( 38 ),['dp'],2800.0
351/B,jeff become friends furik two go play one quite amuse game begin game jeff take a piece paper write a permutation consist n number : p1 p2 ... pn guy take turn make move jeff move first move jeff choose two adjacent permutation elements boy swap move <unknown> toss a coin coin show ` ` head '' choose a random pair adjacent elements index i i + 1 inequality pi > pi + 1 hold swap coin show ` ` tail '' furik choose a random pair adjacent elements index i i + 1 inequality pi < pi + 1 hold swap coin show ` ` head '' ` ` tail '' furik multiple ways adjacent pair take uniformly take one pair furik n't pair take toss a coin one time game end permutation sort increase order jeff want game finish quickly possible ( want players make move possible ) help jeff find minimum mathematical expectation number move game move optimally well consider coin show head ( tail ) probability 50 percent first line contain integer n ( 1 ≤ n ≤ 3000 ) next line contain n distinct integers p1 p2 ... pn ( 1 ≤ pi ≤ n ) — permutation p. number separate space a single line print a single real value — answer problem answer consider correct absolute relative error n't exceed 10 - 6 . first test sequence already sort answer 0,['dp'],1900.0
464/D,roma find a new character game ` ` world darkraft - 2 '' game character fight monsters find advance stuff let fight stronger monsters character equip k distinct type items power item depend level ( positive integer number ) initially character one 1 - level item k type victory monster character find exactly one new randomly generate item generation process look follow firstly type item define ; k type probability level new item define let 's assume level player 's item choose type equal t moment level new item choose uniformly among integers segment [ 1 ; t + 1 ] new item current player 's item type roma choose best one ( i.e one greater level ) equip ( level roma <unknown> ) remain item sell coin roma sell item level x type x coin help roma determine expect number earn coin victory n monsters first line contain two integers n k ( 1 ≤ n ≤ 105 ; 1 ≤ k ≤ 100 ) print a real number — expect number earn coin victory n monsters answer consider correct relative absolute error n't exceed 10 - 9,['dp'],2700.0
494/C,malek a rich man also <unknown> 's decide split money poor people a charity institute know n poor people number 1 n. institute give malek q recommendations a recommendation a segment people like [ l r ] mean institute recommend malek give one <unknown> every person whose number segment however charity odd rule recommendations rule recommendations give a way every two recommendation [ a b ] [ c d ] one follow condition hold : goodness a charity value maximum money a person malek finish give money institute know recommendation probability malek accept want know expect value goodness charity ask help give list recommendations recommendation probability accept malek also give much money person initially must find expect value goodness first line two space - separated integers n q ( 1 ≤ n ≤ 105 1 ≤ q ≤ 5000 ) give second line n space - separated integers a1 a2 ... ( 0 ≤ ai ≤ 109 ) give mean person number i initially ai dollars next q line contain three space - separated number li ri pi ( 1 ≤ li ≤ ri ≤ n 0 ≤ p ≤ 1 ) li ri two integers describe segment recommendation pi a real number give exactly three digits decimal point equal probability malek accept recommendation note a segment may appear several time recommendations output seek value answer consider correct absolute relative error less 10 - 6,['dp'],2600.0
498/B,"turn a great fan rock band ac / pe peter learn start follow game : play first song list n songs group find name song tell song name peter immediately play follow song order , i - th song ac / pe recognizability pi mean song yet recognize listen exactly one second probability pi percent recognize tell 's name otherwise continue listen note try guess integer number second moment song start play ac / pe songs first word chorus title ' ve hear first ti second i - th song chorus start immediately guess name sure example song highway red chorus sound pretty late song high recognizability song back blue hand word title sound close begin song 's hard name hear word name songs a first second determine expect number songs recognize game last exactly t second ( i. e. make last guess second t game stop ) songs recognize faster t second game stop last song recognize first line input contain number n t ( 1 ≤ n ≤ 5000 1 ≤ t ≤ 5000 ) separate a space next n line contain pair number pi ti ( 0 ≤ pi ≤ 100 1 ≤ ti ≤ t ) songs give order petya 's list output a single number — expect number number songs recognize t second answer consider correct absolute relative error exceed 10 - 6",['dp'],2400.0
1172/C2,"difference easy hard versions constraints nauuo a girl love random picture websites one day make a random picture website include $$$ n $$$ picture nauuo visit website see exactly one picture website display picture equal probability $$$ i $$$ -th picture a non - negative weight $$$ w_i $$$ probability $$$ i $$$ -th picture display $$$ \frac { w_i } { \sum _ { j=1 } ^nw_j } $$$ say probability a picture display proportional weight however nauuo discover picture like display often solve problem come a great idea : saw a picture like would add $$$ 1 $$$ weight ; otherwise would subtract $$$ 1 $$$ weight nauuo visit website $$$ m $$$ time want know expect weight picture $$$ m $$$ visit modulo $$$ 998244353 $$$ help ? expect weight $$$ i $$$ -th picture denote $$$ \frac { q_i } { p_i } $$$ $$$ \gcd ( p_i q_i ) = 1 $$$ need print integer $$$ r_i $$$ satisfy $$$ 0\le r_i < 998244353 $$$ $$$ r_i\cdot p_i\equiv q_i\pmod { 998244353 } $$$ prove $$$ r_i $$$ exist unique first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1\le n\le 2\cdot 100000 $$$ $$$ 1\le m\le 3000 $$$ ) — number picture number visit website second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ a_i $$$ either $$$ 0 $$$ $$$ 1 $$$ ) — $$$ a_i=0 $$$ nauuo like $$$ i $$$ -th picture ; otherwise nauuo like $$$ i $$$ -th picture guarantee least one picture nauuo like third line contain $$$ n $$$ positive integers $$$ w_1 w_2 \ldots w_n $$$ ( $$$ w_i \geq 1 $$$ ) — initial weight picture guarantee sum initial weight exceed $$$ <unknown> - m $$$ output contain $$$ n $$$ integers $$$ r_1 r_2 \ldots r_n $$$ — expect weight modulo $$$ 998244353 $$$ first example visit show first picture a probability $$$ \frac 2 3 $$$ final weight $$$ ( 1,1 ) $$$ ; visit show second picture a probability $$$ \frac1 3 $$$ final weight $$$ ( 2,2 ) $$$ , expect weight $$$ \frac2 3\cdot 1+\frac 1 3\cdot 2=\frac4 3 $$$ $$$ 332748119\cdot 3\equiv 4\pmod { 998244353 } $$$ need print $$$ 332748119 $$$ instead $$$ \frac4 3 $$$ $$$ 1.3333333333 $$$ second example one picture nauuo like every time nauuo visit website $$$ w_1 $$$ increase $$$ 1 $$$ , expect weight $$$ 1 + 2=3 $$$ nauuo naughty n't give hint third example",['dp'],2600.0
1776/C,"alessia bernardo discover world competitive program book university library library consist $$$ m $$$ section number $$$ 1 $$$ $$$ m $$$ section contain book dedicate a particular subject different section correspond different subject order prevent students wander library university establish a system pass pass a length $$$ y $$$ associate allow access interval $$$ y $$$ consecutive section library a visit student must choose exactly one book one section leave library pass use moment alessia bernardo $$$ n $$$ pass lengths $$$ x_1 \ x_2 \ \dots \ x_n $$$ different opinions best way improve : alessia think important study many different topics bernardo believe important study deeply least one topic , alessia want use $$$ n $$$ pass get $$$ n $$$ book distinct topics bernardo would like get least two book topic reach follow agreement : follow $$$ n $$$ days alessia choose a pass length $$$ y $$$ among still available interval $$$ y $$$ section library bernardo go library take exactly one book one section bernardo manage get least two book subject alessia able avoid ? decide whether want alessia bernardo fulfill goal choose character judge impersonate character note even moment bernardo already take two book subject interaction go end $$$ n $$$ days first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100 $$$ $$$ n \le m \le 5000 $$$ ) — number pass number section second line contain $$$ n $$$ integers $$$ x_1 \ x_2 \ \dots \ x_n $$$ ( $$$ 1 \le x_i \le m $$$ ) — lengths pass available first print a line contain either string $$$ \texttt { alessia } $$$ string $$$ \texttt { bernardo } $$$ — character want impersonate , $$$ n $$$ turn : one <unknown> <unknown> interactor terminate immediately program receive verdict $$$ \texttt { wrong - answer } $$$ otherwise receive verdict accord game 's criteria describe print a line forget end line flush output otherwise get verdict $$$ \texttt { <unknown> } $$$ flush output use : first sample show alessia accomplish goal example interaction ( read input ) follow : $$$ $$$ \begin { array } { |c|c|c| } \hline \textbf { contestant } & \textbf { judge } & \textbf { explanation } \\ \hline \texttt { alessia } & & \text { program act alessia } \\ \hline 3 \quad 11 & & \text { choose $ y = 3 $ $ a = 11 $ } \\ \hline & 13 & \text { judge select $ b = 13 $ } \\ \hline 10 \quad 2 & & \text { choose $ y = 10 $ $ a = 2 $ } \\ \hline & 9 & \text { judge select $ b = 9 $ } \\ \hline 7 \quad 1 & & \text { choose $ y = 7 $ $ a = 1 $ } \\ \hline & 4 & \text { judge select $ b = 4 $ } \\ \hline 2 \quad 10 & & \text { choose $ y = 2 $ $ a = 10 $ } \\ \hline & 10 & \text { judge select $ b = 10 $ } \\ \hline 3 \quad 6 & & \text { choose $ y = 3 $ $ a = 6 $ } \\ \hline & 7 & \text { judge select $ b = 7 $ } \\ \hline \end { array } $$$ $$$ program contestant win book choose bernardo <unknown> different topics action perform contestant judge example interaction may non - optimal second sample show bernardo manage fulfil goal example interaction ( read input ) follow : $$$ $$$ \begin { array } { |c|c|c| } \hline \textbf { contestant } & \textbf { judge } & \textbf { explanation } \\ \hline \texttt { bernardo } & & \text { program act bernardo } \\ \hline & 4 \quad 1 & \text { judge choose $ y = 4 $ $ a = 1 $ } \\ \hline 4 & & \text { select $ b = 4 $ } \\ \hline & 1 \quad 10 & \text { judge choose $ y = 1 $ $ a = 10 $ } \\ \hline 10 & & \text { select $ b = 10 $ } \\ \hline & 6 \quad 3 & \text { judge choose $ y = 6 $ $ a = 3 $ } \\ \hline 4 & & \text { select $ b = 4 $ } \\ \hline & 4 \quad 5 & \text { judge choose $ y = 4 $ $ a = 5 $ } \\ \hline 8 & & \text { select $ b = 8 $ } \\ \hline \end { array } $$$ $$$ program contestant win bernardo select two book topic number $$$ 4 $$$ action perform contestant judge example interaction may non - optimal",['greedy'],2500.0
1303/D,a bag size $$$ n $$$ also $$$ m $$$ box size $$$ i $$$ -th box $$$ a_i $$$ $$$ a_i $$$ integer non - negative power two divide box two part equal size goal fill bag completely example $$$ n = 10 $$$ $$$ a = [ 1 1 32 ] $$$ divide box size $$$ 32 $$$ two part size $$$ 16 $$$ divide box size $$$ 16 $$$ fill bag box size $$$ 1 $$$ $$$ 1 $$$ $$$ 8 $$$ calculate minimum number divisions require fill bag size $$$ n $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 10^ { 18 } 1 \le m \le 100000 $$$ ) — size bag number box respectively second line test case contain $$$ m $$$ integers $$$ a_1 a_2 \dots <unknown> $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — size box guarantee $$$ a_i $$$ a power two also guarantee sum $$$ m $$$ test case exceed $$$ 100000 $$$ test case print one integer — minimum number divisions require fill bag size $$$ n $$$ ( $$$ -1 $$$ impossible ),['greedy'],1900.0
1567/B,alice give bob two integers $$$ a $$$ $$$ b $$$ ( $$$ a > 0 $$$ $$$ b \ge 0 $$$ ) a curious boy bob write array non - negative integers $$$ \operatorname { mex } $$$ value elements equal $$$ a $$$ $$$ \operatorname { xor } $$$ value elements equal $$$ b $$$ shortest possible length array bob write ? recall $$$ \operatorname { mex } $$$ ( minimum exclude ) array minimum non - negative integer belong array $$$ \operatorname { xor } $$$ array bitwise xor elements array input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 50000 $$$ ) — number test case description test case follow line test case contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \leq a \leq 300000 $$$ ; $$$ 0 \leq b \leq 300000 $$$ ) — $$$ \operatorname { mex } $$$ $$$ \operatorname { xor } $$$ array respectively test case output one ( positive ) integer — length shortest array $$$ \operatorname { mex } $$$ $$$ a $$$ $$$ \operatorname { xor } $$$ $$$ b $$$ show array always exist first test case one shortest array $$$ \operatorname { mex } $$$ $$$ 1 $$$ $$$ \operatorname { xor } $$$ $$$ 1 $$$ $$$ [ 0 <unknown> <unknown> ] $$$ second test case one shortest array $$$ \operatorname { mex } $$$ $$$ 2 $$$ $$$ \operatorname { xor } $$$ $$$ 1 $$$ $$$ [ 0 1 ] $$$ show array shortest array possible,['greedy'],1000.0
1202/A,"give two binary string $$$ x $$$ $$$ y $$$ binary representations two integers ( let 's denote integers $$$ f ( x ) $$$ $$$ f ( y ) $$$ ) choose integer $$$ k \ge 0 $$$ calculate expression $$$ s_k = f ( x ) + f ( y ) \cdot 2^k $$$ write binary representation $$$ s_k $$$ reverse order ( let 's denote $$$ rev_k $$$ ) example let $$$ x = 1010 $$$ $$$ y = 11 $$$ ; ' ve choose $$$ k = 1 $$$ since $$$ 2 ^ 1 = 10_2 $$$ $$$ s_k = 1010_2 + 11_2 \cdot 10_2 = <unknown> $$$ $$$ rev_k = 00001 $$$ give $$$ x $$$ $$$ y $$$ need choose $$$ k $$$ $$$ rev_k $$$ lexicographically minimal ( read note n't know ` ` lexicographically '' mean ) 's guarantee give constraints $$$ k $$$ exist finite first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number query next $$$ 2 t $$$ line contain a description query : two line per query first line contain one binary string $$$ x $$$ consist $$$ 100000 $$$ character character either 0 1 . second line contain one binary string $$$ y $$$ consist $$$ 100000 $$$ character character either 0 1 . 's guarantee $$$ 1 \le f ( y ) \le f ( x ) $$$ ( $$$ f ( x ) $$$ integer represent $$$ x $$$ $$$ f ( y ) $$$ integer represent $$$ y $$$ ) representations n't lead zero total length $$$ x $$$ query n't exceed $$$ 100000 $$$ total length $$$ y $$$ query n't exceed $$$ 100000 $$$ print $$$ t $$$ integers ( one per query ) query print $$$ k $$$ $$$ rev_k $$$ lexicographically minimal first query describe legend second query 's optimal choose $$$ k = 3 $$$ $$$ 2 ^ 3 = 1000_2 $$$ $$$ s_3 = <unknown> + <unknown> \cdot 1000_2 = 10001 + <unknown> = 1000001 $$$ $$$ rev_3 = 1000001 $$$ example $$$ k = 0 $$$ $$$ s_0 = 10111 $$$ $$$ rev_0 = 11101 $$$ $$$ rev_3 = 1000001 $$$ lexicographically smaller $$$ rev_0 = 11101 $$$ third query $$$ s_0 = 10 $$$ $$$ rev_0 = 01 $$$ example $$$ s_2 = 101 $$$ $$$ <unknown> = 101 $$$ $$$ 01 $$$ lexicographically smaller $$$ 101 $$$ quote wikipedia : ` ` determine two string character come arrange lexicographical order first letter compare differ string whose first letter come earlier alphabet come string first letter second letter compare , a position reach one string letter compare first ( shorter ) string <unknown> come first alphabetical order . ''",['greedy'],1100.0
1715/D,<unknown> integer array $$$ a $$$ length $$$ n $$$ tell size $$$ n $$$ $$$ q $$$ statements three integers $$$ i j x $$$ mean $$$ a_i \mid a_j = x $$$ $$$ | $$$ denote bitwise operation find lexicographically smallest array $$$ a $$$ satisfy statements array $$$ a $$$ lexicographically smaller array $$$ b $$$ length follow hold : first line give two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 0 \le q \le 200000 $$$ ) next $$$ q $$$ line give three integers $$$ i $$$ $$$ j $$$ $$$ x $$$ ( $$$ 1 \le i j \le n $$$ $$$ 0 \le x < 2^ { 30 } $$$ ) — statements guarantee $$$ q $$$ statements hold least one array a single line print $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i < 2^ { 30 } $$$ ) — array $$$ a $$$ first sample array satisfy statements :,['greedy'],1900.0
1696/A,nit <unknown> new town ! thousands people line <unknown> keep <unknown> entertain nit decide let solve follow problem relate $$$ \operatorname { } z $$$ solve problem ? give a 1 - indexed array $$$ n $$$ integers $$$ a $$$ integer $$$ z $$$ follow operation number ( possibly zero ) time : $$$ \operatorname { } $$$ $$$ \operatorname { } $$$ denote bitwise operations respectively find maximum possible value maximum value $$$ a $$$ number ( possibly zero ) operations test contain multiple test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) description test case follow first line test case contain two integers $$$ n $$$ $$$ z $$$ ( $$$ 1\le n\le 2000 $$$ $$$ 0\le z < 2^ { 30 } $$$ ) second line test case contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a_n $$$ ( $$$ 0\le a_i < 2^ { 30 } $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 10000 $$$ test case print one integer — answer problem first test case sample one optimal sequence operations : operations sequence $$$ a $$$ become $$$ [ <unknown> ] $$$ maximum value $$$ 7 $$$ prove maximum value $$$ a $$$ never exceed $$$ 7 $$$ answer $$$ 7 $$$ fourth test case sample one optimal sequence operations :,['greedy'],800.0
19/C,bob saw a string contain many different letter letter mark number time letter could meet string 10 time bob n't like string contain repeat : a repeat length x a substring length <unknown> first half coincide character character second half bob start delete repeat string follow : 's possible bob take shortest repeat unique take leftmost one delete leave half everything leave repeat 're give string see bob find look like bob delete repeat way describe first input line contain integer n ( 1 ≤ n ≤ 105 ) — length string follow line contain n space - separated integer number 0 109 inclusive — number stand letter string 's guarantee letter meet string 10 time first line output length string 's part leave bob 's <unknown> second line output letter ( separate a space ) string leave bob delete repeat describe way,['greedy'],2200.0
39/A,"c * + + language quite similar c++ similarity <unknown> fact program write c * + + sometimes behave <unknown> lead absolutely unexpected effect example let 's imagine arithmetic expression c * + + look like ( expression main term ) : example ` ` 5 * <unknown> * + + <unknown> '' a valid expression c * + + thus a sum consist several summands divide sign ` ` + '' ` ` - '' every summand expression ` ` a++ '' ` ` + + a '' multiply integer coefficient coefficient omit suggest equal 1 . calculation sum c * + + go follow way first summands calculate one another sum usual arithmetic rule summand contain ` ` a++ '' calculation first value ` ` a '' variable multiply coefficient value ` ` a '' increase 1 . summand contain ` ` + + a '' action perform reverse order : first ` ` a '' increase 1 — multiply coefficient summands may calculate order 's sometimes result calculation completely <unknown> ! task find largest possible value first input line contain integer a ( - 1000 ≤ a ≤ 1000 ) — initial value variable ` ` a '' next line contain expression c * + + language describe type number summands expression exceed 1000 . guarantee line describe expression contain space <unknown> output a single number — maximal possible value expression consider second example initially a = 3 . suppose first first summand calculate second one first summand get equal 3 value a increase 1 . calculation second summand a increase ( get equal 5 ) value second summand 5 together give 8 . calculate second summand first first summand later summands equal 4 result 8 ,",['greedy'],2000.0
1635/A,give array $$$ a $$$ size $$$ n $$$ perform follow operation array : please output minimum sum array get use operation number time test contain multiple test case first line contain number test case $$$ t $$$ $$$ ( 1 \leq t \leq 1000 ) $$$ description test case follow first line test case contain integer $$$ n $$$ $$$ ( 2 \leq n \leq 100 ) $$$ — size array $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 0 \leq a_i < 2^ { 30 } ) $$$ test case print one number a line — minimum possible sum array first example perform follow operations obtain array $$$ [ 1 0 2 ] $$$ <unknown> . choose $$$ i = 1 j = 2 $$$ change $$$ a_1 = 1 $$$ $$$ a_2 = 2 $$$ 's valid since $$$ 1 | 3 = 1 | 2 $$$ array become $$$ [ 1 2 2 ] $$$ .2 . choose $$$ i = 2 j = 3 $$$ change $$$ a_2 = 0 $$$ $$$ a_3 = 2 $$$ 's valid since $$$ 2 | 2 = 0 | 2 $$$ array become $$$ [ 1 0 2 ] $$$ prove minimum sum $$$ 1 + 0 + 2 = 3 $$$ second example n't need operations,['greedy'],800.0
1732/C1,"easy version problem difference version $$$ q = 1 $$$ give array integers $$$ a_1 a_2 \ldots a_n $$$ cost a subsegment array $$$ [ l r ] $$$ $$$ 1 \leq l \leq r \leq n $$$ value $$$ f ( l r ) = \operatorname { sum } ( l r ) - \operatorname { xor } ( l r ) $$$ $$$ \operatorname { sum } ( l r ) = a_l + a _ { l+1 } + \ldots + a_r $$$ $$$ \operatorname { xor } ( l r ) = a_l \oplus a _ { l+1 } \oplus \ldots \oplus a_r $$$ ( $$$ \oplus $$$ stand bitwise xor ) $$$ q = 1 $$$ query query give a pair number $$$ l_i $$$ $$$ r_i $$$ $$$ 1 \leq l_i \leq r_i \leq n $$$ need find subsegment $$$ [ l r ] $$$ $$$ l_i \leq l \leq r \leq r_i $$$ maximum value $$$ f ( l r ) $$$ several answer among need find a subsegment minimum length , minimum value $$$ r - l + 1 $$$ test consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 10000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ q = 1 $$$ ) — length array number query second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) — array elements $$$ i $$$ -th next $$$ q $$$ line test case contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \leq l_i \leq r_i \leq n $$$ ) — boundaries need find segment guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ guarantee $$$ l_1 = 1 $$$ $$$ r_1 = n $$$ test case print $$$ q $$$ pair number $$$ l_i \leq l \leq r \leq r_i $$$ value $$$ f ( l r ) $$$ maximum among length $$$ r - l + 1 $$$ minimum several correct answer print first test case $$$ f ( 1 1 ) = 0 - 0 = 0 $$$ second test case $$$ f ( 1 1 ) = 5 - 5 = 0 $$$ $$$ f ( 2 2 ) = 10 - 10 = 0 $$$ note $$$ f ( 1 2 ) = ( 10 + 5 ) - ( 10 \oplus 5 ) = 0 $$$ need find a subsegment minimum length among maximum value $$$ f ( l r ) $$$ , segment $$$ [ 1 1 ] $$$ $$$ [ 2 2 ] $$$ correct answer fourth test case $$$ f ( 2 3 ) = ( 12 + 8 ) - ( 12 \oplus 8 ) = 16 $$$ two correct answer fifth test case since $$$ f ( 2 3 ) = f ( 3 4 ) $$$ lengths equal",['greedy'],1800.0
1095/C,"a positive integer $$$ x $$$ call a power two represent $$$ x = <unknown> $$$ $$$ y $$$ a non - negative integer , power two $$$ 1 2 4 8 16 \dots $$$ give two positive integers $$$ n $$$ $$$ k $$$ task represent $$$ n $$$ sum exactly $$$ k $$$ power two line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 1000000000 $$$ $$$ 1 \le k \le 200000 $$$ ) impossible represent $$$ n $$$ sum $$$ k $$$ power two print otherwise print yes print $$$ k $$$ positive integers $$$ b_1 b_2 \dots b_k $$$ $$$ b_i $$$ a power two $$$ \sum \limits _ { i = 1 } ^ { k } b_i = n $$$ multiple answer may print",['greedy'],1400.0
309/C,get work turn computer start cod give little think ram role whole process problem task solve one problems encounter computer routine 'll consider ram a sequence cells contain data cells already contain data empty empty cells form so - <unknown> memory cluster thus a memory cluster a sequence consecutive empty memory cells exactly n memory cluster i - th cluster consist ai cells need find memory m array program j - th array take <unknown> consecutive memory cells possibly n't enough memory m array task determine maximum number array locate available memory cluster course array divide memory cluster also cell belong two array first line input contain two integers n m ( 1 ≤ n m ≤ 106 ) next line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) next line contain m integers b1 b2 ... bm ( 1 ≤ <unknown> ≤ 109 ) print a single integer — answer problem first example give memory cluster size 8 4 3 2 2 array size 8 4 4 . ways obtain answer equal 2 : locate array size 8 cluster size 8 one array size 4 cluster size 4 . another way locate two array size 4 one cluster size 8 . second example give 10 memory cluster size 1 6 array size 1 . choose 6 cluster locate give array,['greedy'],1900.0
425/B,"sereja n × m rectangular table a cell table contain a zero a number one sereja want table meet follow requirement : connect component value form a rectangle side parallel side table rectangles fill cells , a component form a rectangle size h × w component must contain exactly <unknown> cells a connect component value a set cells table meet follow condition : sereja change value k cells table table meet describe requirement ? minimum number table cells change case ? first line contain integers n m k ( 1 ≤ n m ≤ 100 ; 1 ≤ k ≤ 10 ) next n line describe table a : i - th contain m integers ai1 ai2 ... aim ( 0 ≤ ai j ≤ 1 ) — value cells i - th row print -1 impossible meet requirement otherwise print minimum number cells change",['greedy'],2200.0
1009/G,polycarp launch new startup idea <unknown> pretty free key vector development sound really promise easily find investors ready <unknown> company however yet name startup ! actually polycarp already come name <unknown> never hurt want swap letter position obtain better name n't necessary letter adjacent addition investors choose index name select a set letter go indices choose different investors pairwise distinct indices n't choose <unknown> letter go finally polycarp sure smallest lexicographically name best ( like think google decide become alphabet ? ) formally give a string consist lowercase latin letter ` ` a '' ` ` f '' swap letter position arbitrary number time ( zero swap also possible ) smallest lexicographically name obtain letter every position among allow letter ? polycarp ca n't produce valid name print ` ` impossible '' first line string $$$ s $$$ ( $$$ 1 \le |s| \le 100000 $$$ ) — name polycarp come string consist lowercase latin letter ` ` a '' ` ` f '' second line contain a single integer $$$ m $$$ ( $$$ 0 \le m \le |s| $$$ ) — number investors $$$ i $$$ -th next $$$ m $$$ line contain integer number $$$ pos_i $$$ a non - empty string allow character $$$ pos_i $$$ ( $$$ 1 \le pos_i \le |s| $$$ ) string contain pairwise distinct letter ` ` a '' ` ` f '' $$$ <unknown> <unknown> \dots <unknown> $$$ pairwise distinct position string n't appear investors demand letter go position polycarp ca n't produce valid name print ` ` impossible '' otherwise print smallest lexicographically name polycarp obtain swap letter string $$$ s $$$ letter every position among allow ones,['greedy'],2400.0
986/A,company go hold a fair byteland $$$ n $$$ towns byteland $$$ m $$$ two - way roads towns course reach town town use roads $$$ k $$$ type goods produce byteland every town produce one type hold a fair bring least $$$ s $$$ different type goods cost $$$ d ( u v ) $$$ coin bring goods town $$$ u $$$ town $$$ v $$$ $$$ d ( u v ) $$$ length shortest path $$$ u $$$ $$$ v $$$ length a path number roads path organizers cover travel expense choose towns bring goods want calculate minimum expense hold a fair $$$ n $$$ towns $$$ 4 $$$ integers $$$ n $$$ $$$ m $$$ $$$ k $$$ $$$ s $$$ first line input ( $$$ 1 \le n \le 10^ { 5 } $$$ $$$ 0 \le m \le 10^ { 5 } $$$ $$$ 1 \le s \le k \le min ( n 100 ) $$$ ) — number towns number roads number different type goods number different type goods necessary hold a fair next line $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a _ { i } \le k $$$ ) $$$ a_i $$$ type goods produce $$$ i $$$ -th town guarantee integers $$$ 1 $$$ $$$ k $$$ occur least among integers $$$ a _ { i } $$$ next $$$ m $$$ line roads describe road describe two integers $$$ u $$$ $$$ v $$$ ( $$$ 1 \le u v \le n $$$ $$$ u \ne v $$$ ) — towns connect road guarantee one road every two towns guarantee go town town via roads print $$$ n $$$ number $$$ i $$$ -th minimum number coin need spend travel expense hold a fair town $$$ i $$$ separate number space let 's look first sample hold a fair town $$$ 1 $$$ bring goods towns $$$ 1 $$$ ( $$$ 0 $$$ coin ) $$$ 2 $$$ ( $$$ 1 $$$ coin ) $$$ 4 $$$ ( $$$ 1 $$$ coin ) total number coin $$$ 2 $$$ town $$$ 2 $$$ : goods towns $$$ 2 $$$ ( $$$ 0 $$$ ) $$$ 1 $$$ ( $$$ 1 $$$ ) $$$ 3 $$$ ( $$$ 1 $$$ ) sum equal $$$ 2 $$$ town $$$ 3 $$$ : goods towns $$$ 3 $$$ ( $$$ 0 $$$ ) $$$ 2 $$$ ( $$$ 1 $$$ ) $$$ 4 $$$ ( $$$ 1 $$$ ) sum equal $$$ 2 $$$ town $$$ 4 $$$ : goods towns $$$ 4 $$$ ( $$$ 0 $$$ ) $$$ 1 $$$ ( $$$ 1 $$$ ) $$$ 5 $$$ ( $$$ 1 $$$ ) sum equal $$$ 2 $$$ town $$$ 5 $$$ : goods towns $$$ 5 $$$ ( $$$ 0 $$$ ) $$$ 4 $$$ ( $$$ 1 $$$ ) $$$ 3 $$$ ( $$$ 2 $$$ ) sum equal $$$ 3 $$$,['greedy'],1600.0
1245/D,"shichikuji new resident deity south black snail temple first job follow : $$$ n $$$ new cities locate <unknown> x. cities number $$$ 1 $$$ $$$ n $$$ city $$$ i $$$ locate $$$ x_i $$$ km north shrine $$$ y_i $$$ km east shrine possible $$$ ( x_i y_i ) = ( x_j y_j ) $$$ even $$$ i \ne j $$$ shichikuji must provide electricity city either build a power station city make a connection city another one already electricity city electricity a power station connect a city electricity a direct connection via a chain connections shichikuji want job spend little money possible since accord n't really anything else world money however die fifth grade smart enough thus new resident deity ask help , provide shichikuji follow information : minimum amount yen need provide electricity cities cities power station build connections make multiple ways choose cities connections obtain construction minimum price print first line input contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 2000 $$$ ) — number cities , $$$ n $$$ line follow $$$ i $$$ -th line contain two space - separated integers $$$ x_i $$$ ( $$$ 1 \leq x_i \leq 1000000 $$$ ) $$$ y_i $$$ ( $$$ 1 \leq y_i \leq 1000000 $$$ ) — coordinate $$$ i $$$ -th city next line contain $$$ n $$$ space - separated integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \leq c_i \leq 1000000000 $$$ ) — cost build a power station $$$ i $$$ -th city last line contain $$$ n $$$ space - separated integers $$$ k_1 k_2 \dots <unknown> $$$ ( $$$ 1 \leq k_i \leq 1000000000 $$$ ) first line print a single integer denote minimum amount yen need , print integer $$$ v $$$ — number power station build next print $$$ v $$$ space - separated integers denote indices cities a power station build number $$$ 1 $$$ $$$ n $$$ number pairwise distinct print number arbitrary order , print integer $$$ e $$$ — number connections make finally print $$$ e $$$ pair integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le n $$$ $$$ a \ne b $$$ ) denote a connection city $$$ a $$$ city $$$ b $$$ make unordered pair cities include ( $$$ ( a b ) $$$ $$$ ( a b ) $$$ $$$ ( b a ) $$$ pair ) print pair arbitrary order multiple ways choose cities connections obtain construction minimum price print answer give sample refer follow <unknown> ( cities power station color green cities color blue wire color red ) : first example cost build power station cities $$$ 3 + 2 + 3 = 8 $$$ show configuration cost less 8 yen second example cost build a power station city 2 2 . cost connect city 1 city 2 $$$ 2 \cdot ( 3 + 2 ) = 10 $$$ cost connect city 2 city 3 $$$ 3 \cdot ( 2 + 3 ) = 15 $$$ thus total cost $$$ 2 + 10 + 15 = 27 $$$ show configuration cost less 27 yen",['greedy'],1900.0
1283/D,$$$ n $$$ christmas tree infinite number line $$$ i $$$ -th tree grow position $$$ x_i $$$ $$$ x_i $$$ guarantee distinct integer point either occupy christmas tree human occupy non - integer point occupy anything $$$ m $$$ people want celebrate christmas let $$$ y_1 y_2 \dots y_m $$$ position people ( note value $$$ x_1 x_2 \dots x_n y_1 y_2 \dots y_m $$$ distinct $$$ y_j $$$ integer ) want find arrangement people value $$$ \sum\limits _ { j=1 } ^ { m } \min\limits _ { i=1 } ^ { n } |x_i - y_j| $$$ minimum possible ( word sum distance nearest christmas tree people minimize ) word let $$$ d_j $$$ distance $$$ j $$$ -th human nearest christmas tree ( $$$ d_j = \min\limits _ { i=1 } ^ { n } <unknown> - x_i| $$$ ) need choose position $$$ y_1 y_2 \dots y_m $$$ $$$ \sum\limits _ { j=1 } ^ { m } d_j $$$ minimum possible first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 200000 $$$ ) — number christmas tree number people second line input contain $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ -1000000000 \le x_i \le 1000000000 $$$ ) $$$ x_i $$$ position $$$ i $$$ -th christmas tree guarantee $$$ x_i $$$ distinct first line print one integer $$$ res $$$ — minimum possible value $$$ \sum\limits _ { j=1 } ^ { m } \min\limits _ { i=1 } ^ { n } |x_i - y_j| $$$ ( word sum distance nearest christmas tree people ) second line print $$$ m $$$ integers $$$ y_1 y_2 \dots y_m $$$ ( $$$ -2 \cdot 1000000000 \le y_j \le 2000000000 $$$ ) $$$ y_j $$$ position $$$ j $$$ -th human $$$ y_j $$$ distinct value $$$ x_1 x_2 \dots x_n y_1 y_2 \dots y_m $$$ distinct multiple answer print,['greedy'],1800.0
1076/D,give undirected connect weight graph consist $$$ n $$$ vertices $$$ m $$$ edge let 's denote length shortest path vertex $$$ 1 $$$ vertex $$$ i $$$ $$$ d_i $$$ erase edge graph $$$ k $$$ edge remain let 's call a vertex $$$ i $$$ good still exist a path $$$ 1 $$$ $$$ i $$$ length $$$ d_i $$$ erase edge goal erase edge a way number good vertices maximize first line contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 2 \le n \le 300000 $$$ $$$ 1 \le m \le 300000 $$$ $$$ n - 1 \le m $$$ $$$ 0 \le k \le m $$$ ) — number vertices edge graph maximum number edge <unknown> graph respectively $$$ m $$$ line follow contain three integers $$$ x $$$ $$$ y $$$ $$$ w $$$ ( $$$ 1 \le x y \le n $$$ $$$ x \ne y $$$ $$$ 1 \le w \le 1000000000 $$$ ) denote edge connect vertices $$$ x $$$ $$$ y $$$ weight $$$ w $$$ give graph connect ( vertex reach vertex ) simple ( self - loops unordered pair vertices exist one edge connect vertices ) first line print $$$ e $$$ — number edge remain graph ( $$$ 0 \le e \le k $$$ ) second line print $$$ e $$$ distinct integers $$$ 1 $$$ $$$ m $$$ — indices edge remain graph edge number order give input number good vertices large possible,['greedy'],1800.0
1437/D,monocarp a tree consist $$$ n $$$ vertices root vertex $$$ 1 $$$ decide study bfs ( <unknown> - first search ) run bfs tree start root bfs describe follow pseudocode : monocarp fascinate bfs much end lose tree fortunately still a sequence vertices order vertices visit bfs algorithm ( array a pseudocode ) monocarp know vertex visit exactly ( since put take queue exactly ) also know children vertex view ascend order monocarp know many tree ( general case ) visit order $$$ a $$$ n't hope restore tree monocarp okay tree minimum height height a tree maximum depth tree 's vertices depth a vertex number edge path root example depth vertex $$$ 1 $$$ $$$ 0 $$$ since 's root depth root 's children $$$ 1 $$$ help monocarp find tree give visit order $$$ a $$$ minimum height first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number vertices tree second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ; $$$ a_i \neq a_j $$$ ; $$$ a_1 = 1 $$$ ) — order vertices visit bfs algorithm 's guarantee total sum $$$ n $$$ test case n't exceed $$$ 200000 $$$ test case print minimum possible height a tree give visit order $$$ a $$$ first test case one tree give visit order : second test case one tree give visit order well : third test case optimal tree give visit order show :,['greedy'],1600.0
276/B,little girl love problems game much 's one two players get a string s consist lowercase english letter play a game describe follow rule : determine player win provide side play optimally well — one move first one move second input contain a single line contain string s ( 1 ≤ |s| ≤ 103 ) string s consist lowercase english letter a single line print word ` ` first '' first player win ( provide players play optimally well ) otherwise print word ` ` second '' print word without quote,['greedy'],1300.0
360/E,"levko love sport <unknown> competitions city much order boost performance levko spend <unknown> time practice practice a game city consist n intersections connect m + k direct roads two roads connect pair intersections besides roads lead intersection levko zenyk play a game first levko stand intersection s1 zenyk stand intersection s2 want get intersection f. person <unknown> win get time game end a draw agreement players start simultaneously move speed levko want win much know lengths roads city also know change lengths roads ( k roads ) pay government , government change length i - th road integer value segment [ li ri ] ( border inclusive ) levko wonder <unknown> roads win game whether hope draw win consider players play optimally well guarantee get intersections s1 s2 intersection f. first line contain three integers n m k ( 1 ≤ n m ≤ 104 1 ≤ k ≤ 100 ) second line contain three integers s1 s2 f ( 1 ≤ s1 s2 f ≤ n ) next m line contain descriptions roads change levko line contain three integers ai bi ci ( 1 ≤ ai bi ≤ n 1 ≤ ci ≤ 109 ) represent a road intersection ai intersection bi length ci next k line contain descriptions roads change levko line contain four integers ai bi li ri ( 1 ≤ ai bi ≤ n 1 ≤ li ≤ ri ≤ 109 ) represent a road intersection ai intersection bi levko set road 's length within limit [ li ri ] consider intersections number 1 n. guarantee get intersections s1 s2 intersection f. first line print string ` ` win '' ( without quote ) levko win game string ` ` draw '' ( without quote ) levko end game a draw ` ` lose '' ( without quote ) lose sure answer ` ` win '' ` ` draw '' print second line k space - separated integers — length roads levko set order occur input",['greedy'],2800.0
449/B,jzzhu president country a. n cities number 1 n country city 1 capital a. also m roads connect cities one go city ui vi ( vise versa ) use i - th road length road xi finally k train rout country one use i - th train route go capital country city si ( vise versa ) length route yi jzzhu n't want waste money country go close train rout please tell jzzhu maximum number train rout close follow condition : length shortest path every city capital must n't change first line contain three integers n m k ( 2 ≤ n ≤ 105 ; 1 ≤ m ≤ 3·105 ; 1 ≤ k ≤ 105 ) next m line contain three integers ui vi xi ( 1 ≤ ui vi ≤ n ; ui ≠ vi ; 1 ≤ xi ≤ 109 ) next k line contain two integers si yi ( 2 ≤ si ≤ n ; 1 ≤ yi ≤ 109 ) guarantee least one way every city capital note multiple roads two cities also multiple rout go city capital output a single integer represent maximum number train rout close,['greedy'],2000.0
545/E,"little girl <unknown> accidentally find <unknown> brother 's notebook many things important solve problems find problem interest want know solution decide ask , problem statement follow let 's assume give a connect weight undirected graph g = ( v e ) ( v set vertices e set edge ) shortest - path tree vertex u graph g1 = ( v e1 ) a tree set edge e1 subset set edge initial graph e lengths shortest paths u vertex g g1 give a connect weight undirected graph g vertex u. task find shortest - path tree give graph vertex u total weight whose edge minimum possible first line contain two number n m ( 1 ≤ n ≤ 3·105 0 ≤ m ≤ 3·105 ) — number vertices edge graph respectively next m line contain three integers represent edge — ui vi wi — number vertices connect edge weight edge ( ui ≠ vi 1 ≤ wi ≤ 109 ) guarantee graph connect one edge pair vertices last line input contain integer u ( 1 ≤ u ≤ n ) — number start vertex first line print minimum total weight edge tree next line print indices edge include tree separate space edge number start 1 order follow input may print number edge order multiple answer print first sample two possible shortest path tree : example a tree edge 1 – 2 1 – 3 wo n't a shortest path tree vertex 3 distance vertex 3 vertex 2 tree equal 3 original graph 1",['greedy'],2000.0
388/C,fox ciel play a card game friend fox jiro n pile card table a positive integer card players take turn ciel take first turn ciel 's turn take a card top non - empty pile jiro 's turn take a card bottom non - empty pile player want maximize total sum card take game end pile become empty suppose ciel jiro play optimally score game ? first line contain integer n ( 1 ≤ n ≤ 100 ) next n line contain a description pile : first integer line si ( 1 ≤ si ≤ 100 ) — number card i - th pile ; follow si positive integers c1 c2 ... ck ... <unknown> ( 1 ≤ ck ≤ 1000 ) — sequence number card list top current pile bottom pile print two integers : sum ciel 's card sum jiro 's card play optimally first example ciel take card number 100 1 jiro take card number 10 . second example ciel take card number 2 8 6 5 9 jiro take card number 4 7 1 3,['greedy'],2000.0
725/F,"alice bonnie sisters n't like much old family photos find <unknown> start argue receive photos end decide would take turn pick photos alice go first n stack photos stack contain exactly two photos turn a player may take a photo top one stack photo describe two non - negative integers a b indicate worth a units happiness alice b units happiness bonnie value a b might differ different photos 's allow pass instead take a photo game end photos take players pass consecutively players n't act maximize happiness instead player act maximize amount happiness exceed sister 's assume players play optimal find difference alice 's bonnie 's happiness , 's a perfectly - <unknown> game alice x happiness bonnie y happiness end print x - y. first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number two - photo stack follow n line describe one stack a stack describe four space - separated non - negative integers a1 b1 a2 b2 exceed 109 . a1 b1 describe top photo stack a2 b2 describe bottom photo stack output a single integer : difference alice 's bonnie 's happiness play optimally",['greedy'],2900.0
794/C,oleg client igor <unknown> good friends however sometimes argue little things recently start a new company trouble find a name company settle problem ' ve decide play a game company name consist n letter oleg igor a set n letter ( might contain multiple copy letter set different ) initially company name denote n question mark oleg igor take turn play game oleg move first turn a player choose one letter c set replace question mark c. a copy letter c remove set game end question mark replace letter example suppose oleg set letter { i o i } igor set letter { i m o } one possible game follow : initially company name ? ? ? oleg replace second question mark ' i ' company name become ? i ? set letter oleg { i o } igor replace third question mark ' o ' company name become ? io set letter igor { i m } finally oleg replace first question mark ' o ' company name become oio set letter oleg { i } end company name oio oleg want company name lexicographically small possible igor want company name lexicographically large possible company name oleg igor always play optimally ? a string s = s1s2 ... sm call lexicographically smaller a string t = t1t2 ... <unknown> ( s ≠ t ) si < ti i smallest index si ≠ ti ( sj = tj j < i ) first line input contain a string s length n ( 1 ≤ n ≤ 3·105 ) character string lowercase english letter string denote set letter oleg initially second line input contain a string t length n. character string lowercase english letter string denote set letter igor initially output contain a string n lowercase english letter denote company name oleg igor play optimally one way play optimally first sample follow : second sample matter play company name always <unknown>,['greedy'],1800.0
819/A,sometimes mister b free even n't know fortunately mister b find a new game player play alien character game lowercase english letter two players : mister b competitor initially players a string s consist first a english letter alphabetical order ( example a = 5 s equal ` ` abcde '' ) players take turn append letter string s. mister b move first mister b must append exactly b letter move arbitrary choose letter opponent add exactly a letter move mister b quickly understand opponent a computer use a simple algorithm computer turn consider suffix string s length a generate a string t length a letter string t distinct n't appear consider suffix multiple variants t lexicographically minimal choose ( a = 4 suffix ` ` <unknown> '' computer choose string t equal ` ` <unknown> '' ) choose string t append end s. mister b soon find game bore come follow question : minimum possible number different letter string s segment position l r inclusive letter string s numerate start 1 . first line contain four space - separated integers : a b l r ( 1 ≤ a b ≤ 12 1 ≤ l ≤ r ≤ 109 ) — number letter player append bound segment print one integer — minimum possible number different letter segment position l position r inclusive string s. first sample test one optimal strategies generate string s = ` ` <unknown> ... '' 's answer 2 . second sample test string s = ` ` <unknown> ... '' obtain choose segment look like ` ` <unknown> '' 's answer 3 . third sample test string s = ` ` <unknown> ... '' obtain choose segment look like ` ` <unknown> '' 's answer 1,['greedy'],2200.0
616/B,jack decide invite emma a dinner jack a <unknown> student n't want go expensive restaurant emma a girl high taste prefer <unknown> place munhattan consist n streets m avenues exactly one restaurant intersection street avenue streets number integers 1 n avenues number integers 1 m. cost dinner restaurant intersection i - th street j - th avenue cij jack emma decide choose restaurant follow way firstly emma choose street dinner jack choose avenue emma jack make choice optimally : emma want maximize cost dinner jack want minimize emma take account jack want minimize cost dinner find cost dinner couple love first line contain two integers n m ( 1 ≤ n m ≤ 100 ) — number streets avenues munhattan next n line contain m integers cij ( 1 ≤ cij ≤ 109 ) — cost dinner restaurant intersection i - th street j - th avenue print integer a — cost dinner jack emma first example emma choose first third streets jack choose avenue cost dinner 1 . choose second street jack choose avenue cost dinner 2 . second example regardless emma 's choice jack choose a restaurant cost dinner 1,['greedy'],1000.0
293/A,"yaroslav andrey roman play cub hours hours game three roman n't show yaroslav andrey play another game roman leave a word word consist 2·n binary character ` ` 0 '' ` ` 1 '' players start move turn yaroslav move first a move a player must choose integer 1 2·n n't choose anybody moment player take a piece paper write correspond character string let 's represent yaroslav 's word s = s1s2 ... <unknown> similarly let 's represent andrey 's word t = t1t2 ... <unknown> , yaroslav choose number k move go write character sk piece paper similarly andrey choose number r move go write character <unknown> piece paper game finish player make a move game yaroslav make integer character write piece paper ( yaroslav arrange character want ) andrey result number contain lead zero person largest number win number equal game end a draw give two string s t. determine outcome game provide yaroslav andrey play optimally well first line contain integer n ( 1 ≤ n ≤ 106 ) second line contain string s — yaroslav 's word third line contain string t — andrey 's word guarantee word consist 2·n character ` ` 0 '' ` ` 1 '' print ` ` first '' players play optimally well yaroslav win andrey win print ` ` second '' game end a draw print ` ` draw '' print word without quote",['greedy'],1500.0
1693/C,amshz travel italy <unknown> <unknown> <unknown> concert $$$ n $$$ cities italy index $$$ 1 $$$ $$$ n $$$ $$$ m $$$ direct roads index $$$ 1 $$$ $$$ m $$$ initially keshi locate city $$$ 1 $$$ want go amshz 's house city $$$ n $$$ since keshi n't know map italy amshz help see soon possible begin day amshz send one follow two message keshi : note amshz always know keshi 's current location amshz keshi want find smallest possible integer $$$ d $$$ make sure see $$$ d $$$ days help find $$$ d $$$ first line input contain two integers $$$ n $$$ $$$ m $$$ $$$ ( 2 \le n \le 2 \cdot 100000 1 \le m \le 2 \cdot 100000 ) $$$ — number cities roads correspondingly $$$ i $$$ -th line follow $$$ m $$$ line contain two integers $$$ v_i $$$ $$$ u_i $$$ $$$ ( 1 \le v_i u_i \le n v_i \neq u_i ) $$$ denote a direct road go city $$$ v_i $$$ city $$$ u_i $$$ guarantee least one route city $$$ 1 $$$ city $$$ n $$$ note may one road a pair cities direction output smallest possible integer $$$ d $$$ make sure amshz keshi see $$$ d $$$ days first sample 's enough amshz send second type message second sample first day amshz block first road reachable city city $$$ 1 $$$ city $$$ 4 $$$ hence second day amshz tell keshi move keshi arrive amshz 's house 's also possible amshz tell keshi move two days,['greedy'],2300.0
737/E,tanya five friends gather together celebrate birthday n children celebration include tanya celebration close end last plan attraction game machine m machine hall number 1 m. children a list machine want play moreover machine know exact time want play every machine one child play machine time even already every <unknown> want go home speed process additionally rent second copy machine rent second copy j - th machine pay pj burl rent a machine use long want long take make every child play accord plan a budget b burl rent additional machine ? one copy machine 's impossible rent a third machine type children interrupt game moment continue later i - th child want play j - th machine allow rent copy j - th machine child would play part time j - th machine part time copy ( part could empty ) <unknown> change take time perform integer moment time course a child ca n't play one machine time remember need save money ( one save money expense children happiness ! ) need minimize latest moment time child end game first line contain three integers n m b ( 1 ≤ n ≤ 40 1 ≤ m ≤ 10 0 ≤ b ≤ 106 ) — number children number game machine budget rent additional machine second line contain m integers p1 p2 ... <unknown> ( 1 ≤ pj ≤ 106 ) pj rent price second copy j - th <unknown> line follow i - th describe wish i - th child line start integer ki ( 0 ≤ ki ≤ m ) — number machine i - th child want play ki pair line y - th xiy tiy mean i - th child want play tiy ( 1 ≤ tiy ≤ 2500 ) minutes xiy - th ( 1 ≤ xiy ≤ m ) machine n line value xiy distinct first line print minimum time children finish game second line print a string length m consist zero ones j - th character ' 1 ' copy j - th machine rat ' 0 ' otherwise third line print integer g ( 0 ≤ g ≤ 106 ) — total number time segment continuous play children g line print segment four integers i j s d mean i - th child play j - th machine copy time moment s ( s ≥ 0 ) d minutes ( d ≥ 1 ) print line arbitrary order multiple answer print,['greedy'],3300.0
981/F,'s marriage season ringland ! ringland a form a circle 's boundary length $$$ l $$$ $$$ n $$$ bridegrooms $$$ n $$$ brides bridegrooms decide marry brides course bridegroom choose exactly one bride bride choose exactly one bridegroom object ringland locate boundary circle include capital bridegrooms ' castle brides ' palaces castle $$$ i $$$ -th bridegroom locate distance $$$ a_i $$$ capital clockwise direction palace $$$ i $$$ -th bride locate distance $$$ b_i $$$ capital clockwise direction let 's define inconvenience a marriage maximum distance bride walk along circle palace bridegroom 's castle shortest direction ( clockwise counter - clockwise direction ) help bridegrooms ringland choose brides a way inconvenience marriage smallest possible first line contain two integers $$$ n $$$ $$$ l $$$ ( $$$ 1 \leq n \leq 2 \cdot 10^ { 5 } $$$ $$$ 1 \leq l \leq 10^ { 9 } $$$ ) — number bridegrooms brides length ringland next line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i < l $$$ ) — distance capital castle bridegrooms clockwise direction next line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n $$$ ( $$$ 0 \leq b_i < l $$$ ) — distance capital palaces brides clockwise direction line print smallest possible inconvenience <unknown> d inconvenience largest distance travel a bride first example first bridegroom marry second bride second bridegroom marry first bride way second bride walk distance $$$ 1 $$$ first bride also walk distance thus inconvenience equal $$$ 1 $$$ second example let $$$ p_i $$$ bride $$$ i $$$ -th bridegroom marry one optimal $$$ p $$$ follow : $$$ ( <unknown> ) $$$,['greedy'],2500.0
1572/D,currently $$$ n $$$ hot topics number $$$ 0 $$$ $$$ n-1 $$$ local bridge club $$$ 2^n $$$ players number $$$ 0 $$$ $$$ 2^n-1 $$$ player hold a different set view $$$ n $$$ topics specifically $$$ i $$$ -th player hold a positive view $$$ j $$$ -th topic $$$ <unknown> \ & \ <unknown> > 0 $$$ a negative view otherwise $$$ \ & $$$ denote bitwise operation go organize a bridge tournament <unknown> accommodate $$$ k $$$ pair players ( bridge play team two people ) select team arbitrarily player one team one catch : two players pair disagree $$$ 2 $$$ $$$ n $$$ topics would argue much play know $$$ i $$$ -th player pay $$$ a_i $$$ dollars play tournament compute maximum amount money earn pair players club optimally first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 20 $$$ $$$ 1 \le k \le 200 $$$ ) — number hot topics number pair players tournament accommodate second line contain $$$ 2^n $$$ integers $$$ a_0 a_1 \dots a _ { 2^n-1 } $$$ ( $$$ 0 \le a_i \le 1000000 $$$ ) — amount money players pay play tournament print one integer : maximum amount money earn pair players club optimally condition first example best pair together $$$ 0 $$$ -th player $$$ 2 $$$ -nd player result earn $$$ 8 + 5 = 13 $$$ dollars although pair $$$ 0 $$$ -th player $$$ 5 $$$ -th player would give us $$$ 8 + 10 = 18 $$$ dollars two players disagree $$$ 2 $$$ $$$ 3 $$$ hot topics second example pair $$$ 0 $$$ -th player $$$ 1 $$$ -st player pair $$$ 2 $$$ -nd player $$$ 3 $$$ -rd player result earn $$$ 7 + 4 + 5 + 7 = 23 $$$ dollars,['greedy'],2800.0
1728/F,$$$ n $$$ fishermen return a fish trip $$$ i $$$ -th fisherman catch a fish size $$$ a_i $$$ fishermen choose order go tell size fish catch ( order a permutation size $$$ n $$$ ) however entirely honest may ` ` increase '' size fish catch formally suppose choose order fishermen $$$ [ p_1 p_2 p_3 \dots p_n ] $$$ let $$$ b_i $$$ value $$$ i $$$ -th fisherman order tell fishermen value $$$ b_i $$$ choose follow : example let $$$ n = 7 $$$ $$$ a = [ 1 8 2 3 2 2 3 ] $$$ choose order $$$ p = [ 1 6 7 5 3 2 4 ] $$$ : choose order fishermen a way yield minimum possible $$$ \sum\limits _ { i=1 } ^ { n } b_i $$$ first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — number fishermen second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) print one integer — minimum possible value $$$ \sum\limits _ { i=1 } ^ { n } b_i $$$ obtain choose order fishermen optimally,['greedy'],3100.0
83/C,"already know valery 's favorite sport <unknown> due help learn shoot without miss skills <unknown> shoot range a smaller task perform learn complete path <unknown> track 's map represent a rectangle n × m size divide square square mark a lowercase latin letter ( mean type plot ) exception start square ( mark a capital latin letter s ) terminate square ( mark a capital latin letter t ) time movement one square another equal 1 minute time movement within cell neglect move cell side - adjacent ones forbid go beyond map edge also follow restriction <unknown> path : allow visit k different type square ( square one type visit infinite number time ) square mark s t type count s must visit exactly — begin t must visit exactly — end task find path square s square t take minimum time among shortest paths choose lexicographically minimal one compare paths lexicographically represent a sequence character , plot type first input line contain three integers n m k ( 1 ≤ n m ≤ 50 n·m ≥ 2 1 ≤ k ≤ 4 ) n line contain map line length exactly m character consist lowercase latin letter character s t. guarantee map contain exactly one character s exactly one character t. pretest 12 one maximal test problem a path satisfy condition print a sequence letter — plot type otherwise print ` ` -1 '' ( without quote ) n't print character s begin t end note sequence may empty case present pretests print nothing print one ` ` end line '' <unknown> accept",['greedy'],2400.0
3/A,king leave alone chessboard <unknown> <unknown> n't lose heart business national importance example pay official visit square t. king habit waste time want get current position s square t least number move help one move king get square a common side a common vertex square king currently ( generally 8 different square move ) first line contain chessboard coordinate square s second line — square t. chessboard coordinate consist two character first one a lowercase latin letter ( a h ) second one a digit 1 8 . first line print n — minimum number king 's move n line print move move describe one 8 : l r u d <unknown> <unknown> <unknown> rd l r u d stand respectively move leave right ( accord picture ) 2 - letter combinations stand diagonal move answer unique print,['greedy'],1000.0
37/E,<unknown> berland dictionary scientists manage read note <unknown> time example learn chief ancient berland tribe choose soon enough <unknown> pick follow test take place among : chief tribe take a slab divide horizontal vertical strip identical square ( slab consist n line m columns ) paint every square black white every pretender give a slab size paint entirely white within a day a pretender could paint side - linked set square slab color set call link two square belong set a path belong set two neighbor square share a side aim pretender paint slab exactly way chief ’ s slab paint one paint a slab like first become new chief scientists find slab paint ancient berland tribe chief help determine minimal amount days need find a new chief paint slab give way first line contain two integers n m ( 1 ≤ n m ≤ 50 ) — number line columns slab next n line contain m symbols — final coloration slab w stand square paint white b — square paint black single line output minimal number repaint side - linked areas need get require coloration slab,['greedy'],2600.0
1198/F,give array $$$ n $$$ integers need split integers two group gcd integers first group equal one gcd integers second group equal one gcd a group integers largest non - negative integer divide integers group group non - empty first line contain a single integer $$$ n $$$ ( $$$ 2 \leq n \leq 100000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ $$$ \ldots $$$ $$$ a_n $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — elements array first line print ` ` yes '' ( without quote ) possible split integers two group require ` ` '' ( without quote ) otherwise possible split integers second line print $$$ n $$$ integers $$$ i $$$ -th integer equal $$$ 1 $$$ integer $$$ a_i $$$ first group $$$ 2 $$$ otherwise multiple solutions print,['greedy'],2900.0
1398/B,"alice bob play a game a binary string $$$ s $$$ ( a string character either $$$ 0 $$$ $$$ 1 $$$ ) alice move first bob alice , move player choose number ( less one ) consecutive equal character $$$ s $$$ delete example string $$$ <unknown> $$$ $$$ 6 $$$ possible move ( delete character bold ) : character remove character leave right remove block become adjacent i. e. follow sequence move valid : $$$ <unknown> { 11 } 0 \to <unknown> { 00 } \to 1 $$$ game end string become empty score player number $$$ 1 $$$ -characters delete player want maximize score calculate result score alice first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 500 $$$ ) — number test case test case contain exactly one line contain a binary string $$$ s $$$ ( $$$ 1 \le |s| \le 100 $$$ ) test case print one integer — result score alice ( number $$$ 1 $$$ -characters delete ) question optimal strategy ignore",['greedy'],800.0
1425/A,<unknown> mr . chanek frequently play game <unknown> greed name imply game 's goal find <unknown> crown king <unknown> game play two people take turn mr . chanek take first turn initially a treasure chest contain $$$ n $$$ gold coin game end gold coin chest turn players make one follow move : players try maximize number coin mr . chanek ask help find maximum number coin get end game opponent play optimally first line contain a single integer $$$ t $$$ $$$ ( 1 \le t \le 100000 ) $$$ denote number test case next $$$ t $$$ line contain a single integer $$$ n $$$ $$$ ( 1 \le n \le 10^ { 18 } ) $$$ $$$ t $$$ line line answer request mr . chanek first case game follow : second case game follow :,['greedy'],1400.0
1600/E,alice bob play a game give array $$$ a $$$ length $$$ n $$$ array consist integers build a sequence together begin sequence empty one turn a player remove a number leave right side array append sequence rule sequence build must strictly increase winner player make last move alice play first give start array assumption play optimally win game ? first line contain one integer $$$ n $$$ ( $$$ 1 \leq n \leq 2 * 100000 $$$ ) - length array $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) first line output consist one string name winner alice print ` ` alice '' otherwise print ` ` bob '',['greedy'],1900.0
1495/B,"a weekend qingshan suggest friend daniel go hike unfortunately busy high school students go hike <unknown> paper a permutation $$$ p $$$ write leave right paper first qingshan choose integer index $$$ x $$$ ( $$$ 1\le x\le n $$$ ) tell daniel , daniel choose another integer index $$$ y $$$ ( $$$ 1\le <unknown> n $$$ $$$ y \ne x $$$ ) game progress turn turn usual qingshan move first rule follow : person ca n't make move lose win , qingshan 's fan ask calculate number possible $$$ x $$$ make qingshan win case players play optimally first line contain a single integer $$$ n $$$ ( $$$ 2\le n\le 100000 $$$ ) — length permutation second line contain $$$ n $$$ distinct integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 1\le <unknown> n $$$ ) — permutation print number possible value $$$ x $$$ qingshan choose make win first test case qingshan choose $$$ x=3 $$$ win answer $$$ 1 $$$ second test case qingshan choose $$$ x=4 $$$ daniel choose $$$ <unknown> $$$ first turn ( qingshan 's ) qingshan choose $$$ <unknown> $$$ change $$$ x $$$ $$$ 3 $$$ second turn ( daniel 's ) daniel choose $$$ <unknown> $$$ change $$$ y $$$ $$$ 2 $$$ qingshan ca n't choose $$$ <unknown> $$$ $$$ <unknown> $$$ time qingshan lose",['greedy'],1900.0
1627/B,rahul tina look forward start new year <unknown> enter new classroom observe seat students arrange a $$$ n \times m $$$ grid seat row $$$ r $$$ column $$$ c $$$ denote $$$ ( r c ) $$$ distance two seat $$$ ( a b ) $$$ $$$ ( c d ) $$$ $$$ |a - <unknown> + |b - <unknown> $$$ class president tina access exactly $$$ k $$$ bucket pink paint follow process occur rahul want choose a seat sit close tina possible however tina want sit far away rahul possible due complicate relationship history could n't fit statement ! rahul wonder $$$ k = 0 1 \dots n \cdot m - 1 $$$ tina $$$ k $$$ bucket paint close rahul sit tina rahul tina aware 's <unknown> act <unknown> possible ? please help satisfy rahul 's curiosity ! input consist multiple test case first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 50000 $$$ ) — number test case description test case follow first line test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \leq n \cdot m \leq 100000 $$$ ) — number row columns seat classroom sum $$$ n \cdot m $$$ across test case exceed $$$ 100000 $$$ test case output $$$ n \cdot m $$$ order integers — distance rahul tina act optimally every $$$ k \in [ 0 n \cdot m - 1 ] $$$ one possible sequence choices first testcase tina $$$ k=3 $$$ bucket paint follow tina paint seat position $$$ ( 1 2 ) $$$ $$$ ( 2 2 ) $$$ $$$ ( 3 2 ) $$$ pink paint rahul choose seat $$$ ( 3 1 ) $$$ tina choose sit $$$ ( 1 3 ) $$$ therefore distance tina rahul $$$ |3 - 1| + |1 - 3| = 4 $$$ prove indeed minimum possible distance give constraints may choices seat lead answer well $$$ k=0 $$$ first test case rahul decide sit $$$ ( 2 2 ) $$$ tina decide sit $$$ ( 4 3 ) $$$ distance would $$$ |2 - <unknown> + |2 - 3| = 3 $$$ <unknown> representations $$$ k=3 $$$ $$$ k=0 $$$ case first test case,['greedy'],1300.0
980/C,professor ibrahim prepare final homework algorithm ’ s class ask students implement posterization image filter algorithm test array integers $$$ i $$$ -th integer represent color $$$ i $$$ -th pixel image image black white therefore color pixel integer 0 255 ( inclusive ) implement filter students require divide black white color range [ 0 255 ] group consecutive color select one color group group ’ s key order preserve image detail size a group must greater $$$ k $$$ color belong exactly one group finally students replace color pixel array color ’ s assign group key better understand effect image a <unknown> turtle posterization filter apply increase $$$ k $$$ right make process check final answer easier professor ibrahim want students divide group assign key a way produce lexicographically smallest possible array first line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \leq n \leq 100000 $$$ $$$ 1 \leq k \leq 256 $$$ ) number pixels image maximum size a group respectively second line contain $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ ( $$$ 0 \leq p_i \leq 255 $$$ ) $$$ p_i $$$ color $$$ i $$$ -th pixel print $$$ n $$$ space - separated integers ; lexicographically smallest possible array represent image apply posterization filter one possible way group color assign key first sample : color $$$ 2 $$$ belong group $$$ [ <unknown> ] $$$ group key $$$ 0 $$$ color $$$ 14 $$$ belong group $$$ [ <unknown> ] $$$ group key $$$ 12 $$$ color $$$ 3 $$$ $$$ 4 $$$ belong group $$$ [ 3 5 ] $$$ group key $$$ 3 $$$ group wo n't affect result list,['greedy'],1700.0
169/B,give integer a consist n digits also give a sequence digits s length m. digit position j ( 1 ≤ j ≤ m ) sequence s mean choose arbitrary position i ( 1 ≤ i ≤ n ) a replace digit choose position i sj element sequence s participate one replace operation task perform sequence replacements give number a get maximum value allow use elements s. first line contain positive integer a. length n positive n't exceed 105 . second line contain sequence digits s. length m positive n't exceed 105 . digits sequence s write consecutively without separators give number a n't contain lead zero print maximum value obtain a a series replacements allow use elements s. print number n't contain lead zero,['greedy'],1100.0
138/B,andrey 's favourite number n. andrey 's friends give two identical number n a new year present hang a wall watch <unknown> andrey get bore look number start swap digits first one number first number ( arbitrary number change could make number ) point turn sum result number number zero sum end would maximum among possible variants digit permutations number give number n find two digit permutations property ? first line contain a positive integer n — original number number digits number exceed 105 . number write without lead zero print two permutations digits number n sum number end maximum number zero permutations lead zero ( present print ) permutations different several answer print,['greedy'],1900.0
245/C,two <unknown> polycarpus vasily play a interest game n chests coin chests number integers 1 n. chest number i ai coin polycarpus vasily move turn polycarpus move first a move a player allow choose a positive integer x ( 2·x + 1 ≤ n ) take a coin chest number x 2·x 2·x + 1 . may turn chest coin case player n't take a coin chest game finish chests get empty polycarpus n't a greedy scrooge <unknown> a lazy <unknown> wonder minimum number move game finish help polycarpus determine minimum number move game finish note polycarpus count move also count vasily 's move first line contain a single integer n ( 1 ≤ n ≤ 100 ) — number chests coin second line contain a sequence space - separated integers : a1 a2 ... ( 1 ≤ ai ≤ 1000 ) ai number coin chest number i begin game print a single integer — minimum number move need finish game sequence turn lead finish game print -1 . first test case n't a single move make 's players wo n't able empty chests second sample one possible move x = 1 . move repeat least 3 time empty third chest,['greedy'],1700.0
250/A,"polycarpus work <unknown> department ` ` f. r. a. u. d. '' company much n days right task make a series report company 's performance last n days know main information a day report value ai company 's profit i - th day ai negative company suffer losses i - th day polycarpus sort daily report folders folder include data company 's performance several consecutive days course information n days exactly one folder thus polycarpus put information first days first folder information several follow days go second folder , know boss read one daily report folder per day one folder three report days company suffer losses ( ai < 0 ) lose <unknown> wrath terrible therefore polycarpus want prepare folders none contain information three days loss number folders minimal write a program give sequence ai print minimum number folders first line contain integer n ( 1 ≤ n ≤ 100 ) n number days second line contain a sequence integers a1 a2 ... ( |ai| ≤ 100 ) ai mean company profit i - th day possible company days negative ai print integer k — require minimum number folders second line print a sequence integers b1 b2 ... bk bj number day report j - th folder multiple ways sort report k days print go a way sort report first sample three folders : second sample put five report one folder",['greedy'],1000.0
250/C,a film festival come city n. festival last exactly n days day a <unknown> exactly one film film a genre — integer 1 k. i - th day festival show a movie genre ai know a movie k genres occur festival programme least word integer 1 k occur sequence a1 a2 ... least valentine a movie <unknown> want watch movies festival describe <unknown> site <unknown> person valentine <unknown> watch movie a certain genre valentine form mood preserve watch next movie genre next movie change valentine 's mood genres different valentine 's mood change accord new genre valentine a stress valentine ca n't watch n movies decide exclude to - watch list movies one genres word valentine go choose exactly one k genres skip movies genre sure visit movies valentine want choose genre x ( 1 ≤ x ≤ k ) total number <unknown> - movie stress ( movies genre x exclude ) minimum first line input contain two integers n k ( 2 ≤ k ≤ n ≤ 105 ) n number movies k number genres second line input contain a sequence n positive integers a1 a2 ... ( 1 ≤ ai ≤ k ) ai genre i - th movie guarantee number 1 k occur least sequence print a single number — number genre ( 1 k ) exclude film multiple answer print genre minimum number first sample exclude movies 1st genre genres 2 3 2 3 3 3 remain 3 stress ; exclude movies 2nd genre genres 1 1 3 3 3 1 1 3 remain 3 stress ; exclude movies 3rd genre genres 1 1 2 2 1 1 remain 2 stress second sample whatever genre valentine exclude exactly 3 stress,['greedy'],1600.0
253/A,n boys m girls study class stand a line boys girls alternate much possible let 's assume position line index leave right number 1 n + m. number integers i ( 1 ≤ i < n + m ) position index i i + 1 contain children different <unknown> ( position i a girl position i + 1 a boy vice versa ) must large possible help children tell form line single line input contain two integers n m ( 1 ≤ n m ≤ 100 ) separate a space print a line n + m character print i - th position line character ` ` b '' i - th position arrangement a boy ` ` g '' a girl course number character ` ` b '' equal n number character ` ` g '' equal m. multiple optimal solutions print first sample another possible answer <unknown> second sample answer <unknown> also optimal,['greedy'],1100.0
216/C,"a new berland businessman vitaly go open a <unknown> <unknown> ' store 's get hire <unknown> store work seven days a week around clock every day least k people must work store berland a law determine order work days non - <unknown> days namely employee must work exactly n consecutive days rest exactly m days work n days rest m , vitaly n't want break law fortunately a <unknown> : law come force day employee hire example employee hire day x work days [ x x + 1 ... x + n - 1 ] [ x + m + n x + m + n + 1 ... x + m + 2n - 1 ] , day x choose arbitrarily vitaly one thing : key store berland law prohibit make copy key one key vitaly plan <unknown> key store employees time day key must employee work day — otherwise day one get inside store day key <unknown> give key another employee also work day key hand first hire employee first work day employee pay <unknown> therefore vitaly want hire employees possible provide store operate normally day 1 infinity word day index 1 infinity store must least k work employees one work employees key store help vitaly determine minimum require number employees well days hire first line contain three integers n m k ( 1 ≤ m ≤ n ≤ 1000 n ≠ 1 1 ≤ k ≤ 1000 ) first line print a single integer z — minimum require number employees second line print z positive integers separate space : i - th integer ai ( 1 ≤ ai ≤ 104 ) represent number day vitaly hire i - th employee multiple answer print",['greedy'],1800.0
262/B,roma work a company sell <unknown> prepare a report last year roma get a list company 's <unknown> list a sequence consist n integers total income company sum integers sequence roma decide perform exactly k change sign several number sequence also change sign a number one two time operation change a number 's sign operation multiply number -1 . help roma perform change make total income company ( sum number result sequence ) maximum note roma perform exactly k change first line contain two integers n k ( 1 ≤ n k ≤ 105 ) show many number sequence many swap make second line contain a non - decreasing sequence consist n integers ai ( |ai| ≤ 104 ) number line separate single space please note give sequence sort non - decreasing order single line print answer problem — maximum total income obtain exactly k change first sample get sequence [ 1 1 1 ] thus total income equal 3 . second test optimal strategy get sequence [ -1 1 1 ] thus total income equal 1,['greedy'],1200.0
291/D,polycarpus a computer n processors also computer n memory cells 'll consider processors number integers 1 n memory cells consecutively number integers 1 n. polycarpus need come a parallel program model memory cell number i program must record value n - i cell word cell ' ve get find distance cell n. let 's denote value write i - th cell ai initially ai = 1 ( 1 ≤ i < n ) = 0 . consider <unknown> i write value memory cell number i. processors read information cell ( several processors read information cell simultaneously ) parallel program execute several step step execute parallel version increment operation execute parallel version increment operation go follow : help polycarpus come parallel program model execute exactly k step calculate operations need execute note k step i 's value ai must equal n - i. first line contain two space - separated integers n k ( 1 ≤ n ≤ 104 1 ≤ k ≤ 20 ) guarantee give n k require sequence operations exist print exactly n·k integers k line first line print number c1 c2 ... cn ( 1 ≤ ci ≤ n ) first increment operation second line print number second increment operation k - th line print number k - th increment operation a result print operations i value ai must equal n - i,['greedy'],1600.0
322/A,fox ciel friends a dance room n boys m girls never dance songs song must exactly one boy one girl dance besides a special rule : help fox ciel make a schedule dance many songs possible first line contain two integers n m ( 1 ≤ n m ≤ 100 ) — number boys girls dance room first line print k — number songs dance follow k line print index boys girls dance songs chronologically assume boys index 1 n girls index 1 m. test case 1 2 boys 1 girl 2 dance : 1st boy 1st girl ( first song ) 2nd boy 1st girl ( second song ) test case 2 2 boys 2 girls answer 3,['greedy'],1000.0
328/B,remember <unknown> construct word ` ` <unknown> '' use piece ice components ? little sheldon play piece ice piece exactly one digit 0 9 . want construct favourite number t. realize digits 6 9 similar rotate piece ice 6 use 9 ( vice versa ) <unknown> 2 5 work pair digits similar effect call effect ` ` digital <unknown> '' sheldon favourite number t. want many instance t possible many instance construct use give sequence ice piece use piece first line contain integer t ( 1 ≤ t ≤ 10000 ) second line contain sequence digits piece length line equal number piece 1 200 inclusive contain digits 0 9 . print require number instance problem contain weak pretests,['greedy'],1500.0
333/A,"gerald sell state secrets <unknown> secrets cost : n mark state secrets gerald sell paper money coin coin positive integer denominations power three : 1 mark 3 mark 9 mark 27 mark coin denominations course gerald like get money without change <unknown> respect try give desire sum without change possible always happen one day unlucky buyer come desire sum without change take coin try give gerald a larger necessary sum coin possible maximum number coin could get ? formal explanation previous <unknown> : consider possible combinations coin buyer give gerald sum n mark without change combination calculate minimum number coin bring buyer least n mark among combinations choose maximum minimum number coin number want single line contain a single integer n ( 1 ≤ n ≤ <unknown> ) please use % lld specifier read write 64 bite integers с++ prefer use cin cout stream % i64d specifier a single line print integer : maximum number coin unlucky buyer could pay first test case a buyer exactly one coin least 3 mark , give gerald one mark give coin sample customer a coin one mark case able give money gerald without change second test case buyer exactly three coin 3 mark , give gerald 4 mark give two coin buyer give three coin want minimize number coin give",['greedy'],1600.0
351/E,jeff 's friends know full well boy like get sequence array birthday thus jeff get sequence p1 p2 ... pn birthday jeff hat inversions sequence inversion sequence a1 a2 ... a pair index i j ( 1 ≤ i < j ≤ n ) inequality ai > aj hold jeff multiply number sequence p -1 . want number inversions sequence minimum help jeff find minimum number inversions manage get first line contain integer n ( 1 ≤ n ≤ 2000 ) next line contain n integers — sequence p1 p2 ... pn ( |pi| ≤ 105 ) number separate space a single line print answer problem — minimum number inversions jeff get,['greedy'],2200.0
374/B,inna love digit 9 much 's ask dima write a small number consist nines dima must <unknown> write a large number a consist digits 1 9 . inna want slightly alter number dima write end number contain many digits nine possible one move inna choose two adjacent digits a number sum equal 9 replace a single digit 9 . instance inna alter number 14545181 like : 14545181 → <unknown> → <unknown> → 19919 . also use method transform number 14545181 number 19991 . inna transform <unknown> get number 19919 19991 contain digits nine dima a programmer want find many distinct number contain many digits nine possible inna get write number help challenge task first line input contain integer a ( 1 ≤ a ≤ 10100000 ) number a n't zero a single line print a single integer — answer problem guarantee answer problem n't exceed <unknown> - 1 . please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier note <unknown> first sample inna get follow number : 369727 → 99727 → <unknown> 369727 → 99727 → <unknown> . second sample inna act like : <unknown> → <unknown> → <unknown>,['greedy'],1500.0
241/A,n cities country old peykan live cities locate a straight line 'll denote leave right c1 c2 ... cn old peykan want travel city c1 cn use roads ( n - 1 ) one way roads i - th road go city ci city ci + 1 di kilometers long old peykan travel 1 kilometer 1 hour consume 1 liter fuel time city ci ( except last city cn ) a supply si liters fuel immediately transfer old peykan pass city stay supply refresh instantly k hours transfer old peykan stay a city a fill fuel tank many time initially ( time zero ) old peykan city c1 s1 liters fuel transfer 's empty tank c1 's supply old peykan 's fuel tank capacity unlimited old peykan continue travel tank empty strictly two cities find minimum time old peykan need reach city cn first line input contain two space - separated integers m k ( 1 ≤ m k ≤ 1000 ) value m specify number roads cities equal n - 1 . next line contain m space - separated integers d1 d2 ... dm ( 1 ≤ di ≤ 1000 ) follow line contain m space - separated integers s1 s2 ... sm ( 1 ≤ si ≤ 1000 ) line output print a single integer — minimum time require old peykan reach city cn city c1 second sample old peykan stay c1 3 hours,['greedy'],1300.0
226/B,n pile stone size a1 a2 ... lie table front one move take one pile add add pile i pile j size pile j increase current size pile i pile i stop exist cost add operation equal size add pile task determine minimum cost gather stone one pile add challenge stone pile build <unknown> decide pile let add k time ( add another pile ) moreover pile decide puzzle completely tell q variants ( necessarily distinct ) k might equal task find minimum cost q variants first line contain integer n ( 1 ≤ n ≤ 105 ) — number stone pile second line contain n space - separated integers : a1 a2 ... ( 1 ≤ ai ≤ 109 ) — initial size stone pile third line contain integer q ( 1 ≤ q ≤ 105 ) — number query last line contain q space - separated integers k1 k2 ... <unknown> ( 1 ≤ ki ≤ 105 ) — value number k distinct query note number ki repeat print q whitespace - separated integers — answer query order query give input please use % lld specifier read write 64 - bit integers c++ prefer use cin cout stream % i64d specifier first sample one way get optimal answer go like : add turn 4 - th 5 - th pile 2 - nd one ; add 1 - st pile 3 - rd one ; add 2 - nd pile 3 - rd one first two operations cost 1 ; third one cost 2 fourth one cost 5 ( size 2 - nd pile first two operations 3 already 5 ) second sample add 2 - nd pile 3 - rd one ( operations cost 3 ) ; 1 - st one 3 - th one ( cost 2 ) ; 5 - th one 4 - th one ( cost 1 ) ; last 4 - th one 3 - rd one ( cost 2 ),['greedy'],1900.0
288/A,little penguin polo adore string adore string length n. one day want find a string meet follow condition : help find string state string n't exist string x = x1x2 ... xp lexicographically less string y = y1y2 ... yq either p < q x1 = y1 x2 = y2 ... xp = yp number r ( r < p r < q ) x1 = y1 x2 = y2 ... xr = yr xr + 1 < yr + 1 . character string compare ascii cod a single line contain two positive integers n k ( 1 ≤ n ≤ 106 1 ≤ k ≤ 26 ) — string 's length number distinct letter a single line print require string n't string print ` ` -1 '' ( without quote ),['greedy'],1300.0
191/B,"capital city berland bertown <unknown> recent election king berland berland opposition lead mr . <unknown> believe elections fair enough want organize a demonstration one square bertown n square number 1 n number order increase distance city center , square number 1 central square number n farthest center naturally opposition want hold a meet close city center possible ( want square minimum number ) exactly k ( k < n ) days leave demonstration square free bertown city administration never sleep approval application demonstration threaten become a complex process process approval last several days every day follow procedure take place : order organize event square i administration need spend ai bourles crisis administration b bourles confront opposition best square opposition take administration keep try occupy square question time ? note administration 's action always depend action opposition first line contain two integers n k — number square days leave meet correspondingly ( 1 ≤ k < n ≤ 105 ) second line contain a single integer b — number bourles administration ( 1 ≤ b ≤ 1018 ) third line contain n space - separated integers ai — sum money need organise event square i ( 1 ≤ ai ≤ 109 ) please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print a single number — minimum number square opposition organize demonstration first sample opposition act like day one apply square 3 . administration organize event end 3 bourles second day opposition apply square 2 administration wo n't money <unknown> second sample opposition chance last square first move occupy one first four square administration leave least 4 bourles mean next day use next move move opposition square last one third sample administration a lot money opposition occupy last square",['greedy'],1700.0
45/F,vasya need transport m goats m wolves <unknown> quickly possible boat hold n animals vasya addition permit put less n animals boat one place ( one bank boat ) wolves happen strictly <unknown> goats wolves eat goats vasya get upset vasya <unknown> boat one shore must take least one animal <unknown> otherwise get bore yet feel upset boat reach bank first animals get simultaneously animals choose vasya simultaneously get boat mean moment animals arrive already get animals go leave n't yet get somebody might eat someone vasya need transport animals one river bank nobody eat anyone vasya n't get upset minimal number time cross river ? first line contain two space - separated number m n ( 1 ≤ m n ≤ 105 ) — number animals boat 's capacity impossible transport animals one get upset goats survive print -1 . otherwise print single number — many time vasya cross river first sample match well - known problem children,['greedy'],2500.0
45/I,vasya get interest program contest tcmcf+++ rule contest n problems suggest every problem a cost — a certain integral number point ( perhaps negative even equal zero ) accord tcmcf+++ rule accept problems earn point overall number point a contestant equal product cost problems he / she complete a person n't solve anything he / she n't even appear final stand n't consider participant vasya understand get maximal number point always useful solve problems unfortunately understand contest finish ask help : find problems solve earn maximal number point first line contain integer n ( 1 ≤ n ≤ 100 ) — number suggest problems next line contain n space - separated integers ci ( - 100 ≤ ci ≤ 100 ) — cost i - th task task ' cost may <unknown> print space - separated cost problems need solve get maximal possible number point forget please necessary solve least one problem several solutions problem print,['greedy'],1400.0
67/B,let a = { a1 a2 ... } permutation first n natural number { 1 2 ... n } give a positive integer k another sequence b = { b1 b2 ... bn } bi number elements aj a leave element = i aj ≥ ( i + k ) example n = 5 a possible a { 5 1 4 2 3 } k = 2 b give { 1 2 1 0 0 } k = 3 b = { 1 1 0 0 0 } two sequence x = { x1 x2 ... xn } y = { y1 y2 ... yn } let i - th elements first elements xi ≠ yi xi < yi x lexicographically smaller y xi > yi x lexicographically greater y. give n k b need determine lexicographically smallest a. first line contain two space separate integers n k ( 1 ≤ n ≤ 1000 1 ≤ k ≤ n ) second line n integers specify value b = { b1 b2 ... bn } print a single line n integers a = { a1 a2 ... } a lexicographically minimal guarantee solution exist,['greedy'],1800.0
79/A,fox ciel <unknown> round a program contest take a bus return castle fee bus 220 yen meet rabbit hanako bus decide play follow game get bore bus determine winner game first line contain two integers x ( 0 ≤ x ≤ 106 ) y ( 0 ≤ y ≤ 106 ) separate a single space ciel win print ` ` ciel '' otherwise print ` ` hanako '' first turn ( ciel 's turn ) choose 2 100 - yen coin 2 10 - yen coin second turn ( hanako 's turn ) choose 1 100 - yen coin 12 10 - yen coin third turn ( ciel 's turn ) ca n't pay exactly 220 yen ciel lose,['greedy'],1200.0
89/A,<unknown> joe <unknown> get country 's main bank 's safe safe n cells position a row contain amount diamonds let 's make problem <unknown> work mark cells positive number 1 n leave right unfortunately joe n't switch last security system plus side know way work every minute security system calculate total amount diamonds two adjacent cells ( cells whose number difference equal 1 ) a result check get n - 1 sum least one sum differ correspond sum receive previous check security system trigger joe move diamonds one cell another security system 's check manage move m time two check one three follow operations regard move a diamond : move a diamond cell one move a diamond cell joe 's pocket move a diamond joe 's pocket cell initially joe 's pocket empty carry unlimited amount diamonds consider joe 's action system perform least one check morning bank employees come joe leave bank moment joe k minutes leave morning k minutes perform m operations remain joe 's pocket consider <unknown> calculate largest amount diamonds joe carry n't forget security system n't trigger ( even joe leave bank ) joe leave morning first line contain integers n m k ( 1 ≤ n ≤ 104 1 ≤ m k ≤ 109 ) next line contain n number i - th number equal amount diamonds i - th cell — integer 0 105 . print a single number — maximum number diamonds joe steal second sample joe act like : diamonds ' initial position 4 1 3 . first period time joe move a diamond 1 - th cell 2 - th one a diamond 3 - th cell pocket end first period diamonds ' position 3 2 2 . check find difference security system n't go second period joe move a diamond 3 - rd cell 2 - nd one put a diamond 1 - st cell pocket end second period diamonds ' position 2 3 1 . check find difference security system n't go joe leave 2 diamonds pocket,['greedy'],1800.0
89/E,fire lord attack frost kingdom already get ice fortress snow queen <unknown> arrange army a segment n length far city wall frost magician solomon save frost kingdom n - long segment locate a distance equal exactly 1 castle wall <unknown> divide unit segment unit segment fire demons locate — one demon per position demon characterise strength - positive integer regard fire demons idle initially solomon position fortress wall perform follow action several time a row : solomon spend exactly a second action result solomon 's action ice block ' segment fall ice block fall a fire demon block <unknown> demon 's strength reduce 1 . demons ' strength equal 0 fire demon vanish picture show happen ice block fall position demon break lot tiny piece vanish without hurt anybody help solomon destroy fire lord 's army minimum time first line contain integer n ( 1 ≤ n ≤ 1000 ) next line contain n number i - th represent strength fire demon stand i - th position integer 1 100 . 's demon i - th position i - th number equal 0 . guarantee input data least one fire demon print a string minimum length contain character ` ` l '' ` ` r '' ` ` a '' — succession action lead require result several possible answer print,['greedy'],2900.0
207/A3,smart beaver abbyy surprise us ! develop a new calculate device call ` ` beaver 's <unknown> 1.0 '' peculiar plan use a variety scientific problems test smart beaver invite n scientists number 1 n. i - th scientist bring ki calculate problems device develop smart beaver abbyy problems i - th scientist number 1 ki must calculate sequentially describe order since calculate problem heavily depend result calculate previous ones problem n scientists describe one integer ai j i ( 1 ≤ i ≤ n ) number scientist j ( 1 ≤ j ≤ ki ) number problem ai j number resource units calculate device need solve problem calculate device develop smart beaver pretty unusual solve problems sequentially one another problem solve next one consider calculate device allocate free resources expensive operation calculate device free resources work much <unknown> allocate therefore <unknown> next problem calculate device require less resources previous one give information problems scientists offer test need arrange problems order number adjacent ` ` bad '' pair problems list minimum possible call two consecutive problems list a ` ` bad pair '' problem perform first require resources one go forget problems scientist must solve a fix order first line contain integer n — number scientists <unknown> size input next n line contain five integers ki ai 1 xi yi mi ( 0 ≤ ai 1 < mi ≤ 109 1 ≤ xi yi ≤ 109 ) — number problems i - th scientist resources first problem require three parameters generate subsequent value ai j. j 2 ki inclusive calculate value ai j formula ai j = ( ai j - 1 * xi + yi ) mod mi a mod b operation take remainder division number a number b. get full point first group test sufficient solve problem n = 2 1 ≤ ki ≤ 2000 . get full point second group test sufficient solve problem n = 2 1 ≤ ki ≤ 200000 . get full point third group test sufficient solve problem 1 ≤ n ≤ 5000 1 ≤ ki ≤ 5000 . first line print a single number — number ` ` bad '' pair optimal order total number problems exceed 200000 also print line — optimal order problems line print two integers separate a single space — require number resources problem number scientist offer problem respectively scientists number 1 n order input first sample n = 2 k1 = 2 a1 1 = 1 a1 2 = 2 k2 = 2 a2 1 = 3 a2 2 = 4 . ' ve get two scientists two calculate problems problems first scientist require 1 2 resource units problems second one require 3 4 resource units let 's list possible variants calculate order ( problem characterize number resource units require ) : ( 1 2 3 4 ) ( 1 3 2 4 ) ( 3 1 2 4 ) ( 1 3 4 2 ) ( 3 4 1 2 ) ( 3 1 4 2 ) sequence problems ( 1 3 2 4 ) one ` ` bad '' pair ( 3 2 ) ( 3 1 4 2 ) two ` ` bad '' pair ( 3 1 4 2 ) ( 1 2 3 4 ) ` ` bad '' pair,['greedy'],2000.0
92/B,little <unknown> fangy love math much 's bore play a number perform operations fangy take positive integer x want get a number one x equal 1 fangy repeat follow action : x odd add 1 otherwise divide x 2 . fangy know positive integer number process end finite time many action fangy perform get a number one number x ? first line contain a positive integer x a binary system guarantee first digit x different a zero number digits exceed 106 . print require number action let 's consider third sample number <unknown> even mean divide 2 . divide fangy get odd number 10111 add one number <unknown> divide 2 three time a row get number 11 . 's leave increase number one ( get 100 ) divide 2 two time a row a result get 1,['greedy'],1300.0
111/A,"little petya love <unknown> help find n positive integers a1 a2 ... , follow two condition satisfy : first line contain three space - separated integers n x y ( 1 ≤ n ≤ 105 1 ≤ x ≤ 1012 1 ≤ y ≤ 106 ) please use % lld specificator read write 64 - bit integers с++ recommend use cin cout stream % i64d specificator print n positive integers satisfy condition one integer per line number exist print a single number ` ` -1 '' several solutions print",['greedy'],1400.0
120/I,vasya collect transport ticket quite a collection contain several thousands tram <unknown> bus ticket vasya already feed traditional definition a lucky ticket thus 's look new <unknown> besides vasya understand ticket divide lucky unlucky ones think ticket lucky different degrees give matter think vasya work definition a ticket 's degree luckiness let a ticket consist 2n digits let 's regard digit write show picture : see digits electronic clock : seven segment use show digits segment either color color segment form a digit vasya regard digits write way take right half ticket put one leave one first digit coincide n + 1 - th one second digit coincide n + 2 - th one ... n - th digit coincide 2n - th one pair digits put one another count number segment color digits <unknown> result number result value call degree luckiness a ticket example degree luckiness ticket <unknown> equal four degree luckiness ticket <unknown> equal six give number a ticket contain 2n digits task find among ticket whose number exceed number ticket also consist 2n digits ticket whose degree luckiness exceed degrees luckiness give ticket moreover several ticket choose one smallest number first line contain number ticket consist k character ( k = 2n 1 ≤ n ≤ 105 ) print number seek ticket ` ` -1 '' ( without quote ) ticket exist,['greedy'],2200.0
215/D,"official capital cultural capital berland connect a single road run n regions region a unique climate i - th ( 1 ≤ i ≤ n ) region a stable temperature ti degrees summer summer a group m schoolchildren want get official capital cultural capital visit <unknown> <unknown> trip organizers transport children cities bus sometimes hot specifically bus drive i - th region k schoolchildren temperature inside bus ti + k degrees course nobody like bus hot , bus drive i - th region ti degrees inside <unknown> bus demand compensation <unknown> condition compensation large xi rubles charge region temperature bus exceed limit save money organizers trip may arbitrarily add remove extra bus begin trip regions ( course need least one bus pass region ) organizers also arbitrarily sort children bus however bus i - th region cost organizers costi rubles please note sort children bus take money task find minimum number rubles organizers spend transport schoolchildren first input line contain two integers n m ( 1 ≤ n ≤ 105 ; 1 ≤ m ≤ 106 ) — number regions way number schoolchildren group correspondingly next n line contain four integers : i - th line contain ti ti xi costi ( 1 ≤ ti ti xi costi ≤ 106 ) number line separate single space print integer — minimum number roubles organizers spend transport schoolchildren please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first sample organizers use one bus travel first region however temperature bus equal 30 + 10 = 40 degrees 10 schoolchildren ask compensation one bus transport group second region temperature inside wo n't exceed limit overall organizers spend 100 + 10 + 10 = 120 rubles",['greedy'],1900.0
178/A3,smart beaver abbyy begin develop a new <unknown> game children rule game fairly simple describe play field a sequence n non - negative integers ai number 1 n. goal game make number a1 a2 ... ak ( i.e prefix sequence ) equal zero fix k ( k < n ) do smallest possible number move one move choose integer i ( 1 ≤ i ≤ n ) ai > 0 integer t ( t ≥ 0 ) i + 2 t ≤ n. value i t select value ai decrease 1 value ai + 2 t increase 1 . example let n = 4 a = ( 1 0 1 2 ) possible make move i = 3 t = 0 get a = ( 1 0 0 3 ) make move i = 1 t = 1 get a = ( 0 0 2 2 ) ( possible move i = 1 t = 0 ) give n initial sequence ai task calculate minimum number move need make first k elements original sequence equal zero possible k ( 1 ≤ k < n ) first input line contain a single integer n. second line contain n integers ai ( 0 ≤ ai ≤ 104 ) separate single space input limitations get 20 point : input limitations get 50 point : input limitations get 100 point : print exactly n - 1 line : k - th output line must contain minimum number move need make first k elements original sequence ai equal zero please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier,['greedy'],1100.0
183/E,"prestigious codeforces kindergarten consist n kid number 1 n. give allowance rubles parent today go famous candy shop town shop sell candy package : i 1 m inclusive sell a package contain exactly i candy a candy cost one ruble a package contain x candy cost x rubles kid purchase candy turn start kid 1 . a single turn kid i purchase one candy package due highly competitive nature codeforces kindergarten a turn number candy contain package purchase kid always strictly greater number candy contain package purchase kid precede turn ( exception first turn : first kid may purchase package ) , turn proceed kid i + 1 kid 1 kid n 's turn process end time end purchase process kid must number candy package course amount spend kid candy exceed allowance work candy shop would like prepare candy kid print maximum number candy sell candy shop kid kid purchase candy ( due <unknown> allowance ) print 0 . first line contain two space - separated integers n m ( 2 ≤ n ≤ 2·105 2 ≤ m ≤ 5·106 n ≤ m ) denote number kid maximum number candy a package sell candy shop respectively n line follow line contain a single positive integer exceed denote allowance a kid rubles allowance give order kid 1 kid n. please use % lld specificator read write 64 - bit integers c++ recommend use cin cout stream ( also may use % i64d specificator ) print a single integer denote maximum number candy sell candy shop first example one scenarios result 13 purchase candy follow",['greedy'],2900.0
435/B,pasha a positive integer a without lead zero today decide number small make larger unfortunately operation pasha swap two adjacent decimal digits integer help pasha count maximum number get time make k swap single line contain two integers a k ( 1 ≤ a ≤ 1018 ; 0 ≤ k ≤ 100 ) print maximum number pasha get make k swap,['greedy'],1400.0
457/B,piegirl ask implement two table join operation distribute database system minimize network traffic suppose want join two table a b. certain number row distribute different number partition table a distribute first cluster consist m partition partition index i ai row a. similarly second cluster contain table b n partition i - th one bi row b. one network operation copy one row partition partition end row a row b a partition row determine minimal number network operations achieve first line contain two integer number m n ( 1 ≤ m n ≤ 105 ) second line contain description first cluster m space separate integers ai ( 1 ≤ ai ≤ 109 ) similarly third line describe second cluster n space separate integers bi ( 1 ≤ bi ≤ 109 ) print one integer — minimal number copy operations first example make sense move row second partition second cluster achieve 2 + 6 + 3 = 11 <unknown> second example piegirl copy row b partition first cluster need <unknown> = 6 copy operations,['greedy'],1900.0
802/A,"search heidi – finally find a library <unknown> a human fact spend much time run place ! job buy book keep library people borrow read n different book number 1 n. look library 's operation n consecutive days heidi know advance i - th day ( 1 ≤ i ≤ n ) precisely one person come library request borrow book ai read a hours return book later day heidi <unknown> want please guests make sure always book ai available library i - th day night i - th day option go <unknown> ( operate nights avoid competition library ) buy book price 1 chf course already a book library need buy initially library contain book a problem though capacity library k – mean time k book library buy a new book would cause heidi k book must first get rid book already order make room new book later need a book get rid need buy book give k sequence request book a1 a2 ... , minimum cost ( chf ) buy new book satisfy request ? first line input contain two integers n k ( 1 ≤ n k ≤ 80 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ n ) – sequence book request a single line print minimum cost buy book store satisfy request first test case heidi able keep book forever therefore need buy book 1 first day book 2 second day second test case keep one book a time therefore need buy new book first second fourth day third test case buy book 3 third day must decide book 1 2 get rid course keep book 1 request fourth day",['greedy'],1800.0
835/B,natural number write board sum digits less k. distract a bite someone change number n replace digits others 's know length number n't change find minimum number digits two number differ first line contain integer k ( 1 ≤ k ≤ 109 ) second line contain integer n ( 1 ≤ n < 10100000 ) lead zero n. 's guarantee situation possible print minimum number digits initial number n differ first example initial number could 12 . second example sum digits n less k. initial number could equal n,['greedy'],1100.0
847/H,polycarp plan conduct a load test new project fakebook already agree friends certain point time send request fakebook load test last n minutes i - th minute friends send ai request polycarp plan test fakebook a special kind load case information fakebook get mass media polycarp hop a monotone increase load follow a monotone decrease interest service polycarp want test form load task determine many request polycarp must add moment load server strictly increase moment strictly decrease increase part decrease part empty ( i. e. absent ) decrease immediately follow increase particular load two equal <unknown> value <unknown> example load describe one array [ 1 2 8 4 3 ] [ 1 3 5 ] [ 10 ] load satisfy polycarp ( case increase part immediately follow a decrease part ) load describe one array [ 1 2 2 1 ] [ 2 1 2 ] [ 10 10 ] load satisfy polycarp help polycarp make minimum number additional request result load satisfy polycarp make number additional request minute 1 n. first line contain a single integer n ( 1 ≤ n ≤ 100 000 ) — duration load test second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) ai number request friends i - th minute load test print minimum number additional request polycarp would make load strictly increase begin strictly decrease afterwards first example polycarp must make two additional request third minute four additional request fourth minute result load look like : [ 1 4 5 6 5 ] total polycarp make 6 additional request second example enough make one additional request third minute answer 1 . third example load already satisfy condition describe statement answer 0,['greedy'],1600.0
853/A,helen work metropolis airport responsible create a departure schedule n flight must depart today i - th plan depart i - th minute day metropolis airport main transport <unknown> <unknown> difficult keep schedule <unknown> exactly case today : technical issue flight able depart first k minutes day new departure schedule must create n schedule flight must depart different minutes ( k + 1 ) -th ( k + n ) -th inclusive however 's <unknown> flight depart order initially schedule — order new schedule different one restriction : flight allow depart earlier suppose depart initial schedule helen know minute delay i - th flight cost airport ci burl help find order flight depart new schedule minimize total cost airport first line contain two integers n k ( 1 ≤ k ≤ n ≤ 300 000 ) n number flight k number minutes begin day flight depart second line contain n integers c1 c2 ... cn ( 1 ≤ ci ≤ 107 ) ci cost delay i - th flight one minute first line must contain minimum possible total cost delay flight second line must contain n different integers t1 t2 ... tn ( k + 1 ≤ ti ≤ k + n ) ti minute i - th flight must depart several optimal schedule print let us consider sample test helen move flight 2 minutes later preserve order total cost delay flight would ( 3 - 1 ) · 4 + ( 4 - 2 ) · 2 + ( 5 - 3 ) · 1 + ( 6 - 4 ) · 10 + ( 7 - 5 ) · 2 = 38 burl however better schedule show sample answer cost ( 3 - 1 ) · 4 + ( 6 - 2 ) · 2 + ( 7 - 3 ) · 1 + ( 4 - 4 ) · 10 + ( 5 - 5 ) · 2 = 20 burl,['greedy'],1500.0
856/F,vasya petya play online game online game hero progress system allow players gain experience make heroes stronger course vasya would like get many experience point possible careful study experience point <unknown> find play game alone get one experience point second however two players play together current experience value differ c point boost progress get 2 experience point second since vasya petya middle school students parent n't allow play day around friends schedule : vasya play intervals [ a1 ; b1 ] [ a2 ; b2 ] ... [ ; bn ] petya play intervals [ c1 ; d1 ] [ c2 ; d2 ] ... [ cm ; dm ] time periods give second current moment vasya good math notice sometimes profitable play alone experience difference could become big progress would boost even play together would like create schedule play vasya 's final experience greatest possible current players experience petya concern experience ready <unknown> play need maximize vasya 's experience first line input data contain integers n m c — number intervals vasya play number intervals petya play maximal difference experience level play together still give a progress boost ( 1 ≤ n m ≤ 2·105 0 ≤ c ≤ 1018 ) follow n line contain two integers : ai bi — intervals vasya play ( 0 ≤ ai < bi ≤ 1018 bi < ai + 1 ) follow m line contain two integers : ci di — intervals petya play ( 0 ≤ ci < di ≤ 1018 di < ci + 1 ) output one integer — maximal experience vasya end players try maximize value,['greedy'],3000.0
859/F,'s another start [ c ] mean t - shirts order order make sure t - shirts ship soon possible ' ve decide year 're go order necessary t - shirts actual competition top c contestants go award t - shirts obviously n't know contestants plan get t - shirt size contestants actual competition order enough t - shirts matter top c 'll t - shirts available order award order get t - shirt size contestants send a survey survey allow contestants either specify a single desire t - shirt size two adjacent t - shirt size a contestant specify two size mean award either size probably tell plan could require order a lot <unknown> t - shirts 'd like help determine minimum number t - shirts 'll need order ensure 'll able award t - shirts matter outcome competition input begin two integers n c ( 1 ≤ n ≤ 2·105 1 ≤ c ) number t - shirt size number t - shirts award respectively follow a line 2·n - 1 integers s1 <unknown> - 1 ( 0 ≤ si ≤ 108 ) odd i si indicate number contestants desire t - shirt size ( ( i + 1 ) / 2 ) even i si indicate number contestants okay receive either t - shirt size ( i / 2 ) ( i / 2 + 1 ) c exceed total number contestants print minimum number t - shirts need buy first example buy 100 size,['greedy'],2800.0
767/E,student arseny like plan life n days ahead visit a canteen every day already decide order follow n days price canteen change mean arseny spend ci rubles i - th day 1 - ruble coin 100 - ruble note <unknown> moment arseny m coin a sufficiently large amount note ( assume infinite amount ) arseny love modern technologies use credit card everywhere except canteen pay cash canteen accept card cashier always ask student pay change - free however 's always possible arseny try minimize dissatisfaction cashier cashier 's dissatisfaction days determine total amount note coin change precise cashier give arseny x note coin i - th day dissatisfaction day equal <unknown> cashier always give change use little coin note possible always enough able arseny want pay a way total dissatisfaction cashier n days would small possible help find need pay n days ! note arseny always enough money pay infinite amount note arseny use note coin receive change follow days first line contain two integers n m ( 1 ≤ n ≤ 105 0 ≤ m ≤ 109 ) — amount days arseny plan action amount coin currently second line contain a sequence integers c1 c2 ... cn ( 1 ≤ ci ≤ 105 ) — amount money rubles arseny go spend follow days third line contain a sequence integers <unknown> <unknown> ... <unknown> ( 1 ≤ wi ≤ 105 ) — cashier 's dissatisfaction coefficients follow days first line print one integer — minimum possible total dissatisfaction cashier print n line i - th contain two number — amount note amount coin arseny use pay canteen i - th day course total amount money arseny give <unknown> days less amount money plan spend also n't exceed 106 rubles : arseny never carry large sum money multiple answer print,['greedy'],2400.0
870/B,give array a1 a2 ... consist n integers integer k. split array exactly k non - empty subsegments 'll compute minimum integer subsegment take maximum integer k obtain minimums maximum possible integer get ? definitions subsegment array split give note first line contain two integers n k ( 1 ≤ k ≤ n ≤ 105 ) — size array a number subsegments split array second line contain n integers a1 a2 ... ( - 109 ≤ ai ≤ 109 ) print single integer — maximum possible integer get split array k non - empty subsegments take maximum minimums subsegments a subsegment [ l r ] ( l ≤ r ) array a sequence al al + 1 ... ar split array a n elements k subsegments [ l1 r1 ] [ l2 r2 ] ... [ <unknown> rk ] ( l1 = 1 rk = n li = ri - 1 + 1 i > 1 ) k sequence ( <unknown> ... <unknown> ) ... ( <unknown> ... <unknown> ) first example split array subsegments [ 1 4 ] [ 5 5 ] result sequence ( 1 2 3 4 ) ( 5 ) minimums min ( 1 2 3 4 ) = 1 min ( 5 ) = 5 . result maximum max ( 1 5 ) = 5 . obvious ca n't reach greater result second example option split array one subsegment [ 1 5 ] result one sequence ( - 4 - 5 - 3 - 2 - 1 ) minimum min ( - 4 - 5 - 3 - 2 - 1 ) = - 5 . result maximum - 5,['greedy'],1200.0
522/C,"polycarp fly <unknown> finally favorite time — <unknown> <unknown> company stewardess give food consecutively passengers 1 - th one last one polycarp sit seat m mean m - th person get food flight menu k dish total polycarp board flight time count number portion dish board thus know value a1 a2 ... ak ai number portion i - th dish stewardess already give food m - 1 passengers give polycarp a polite smile ask would prefer 's polycarp realize might run dish moment m - 1 passengers ahead notice dish give besides 's hear strange <unknown> m - 1 passengers ahead similar phrase ' i ' m disappoint ' happen a passenger ask dish stewardess give a polite smile say run dish case passenger need choose dish available polycarp hear sound a passenger mean passenger choose dish first try help polycarp find dish : whether could run dish moment <unknown> serve dish definitely available test problem consist one input set first go a string contain a single integer t ( 1 ≤ t ≤ 100 000 ) — number input data set test set follow set precede empty line first line set input contain integers m k ( 2 ≤ m ≤ 100 000 1 ≤ k ≤ 100 000 ) — number polycarp 's seat number dish respectively second line contain a sequence k integers a1 a2 ... ak ( 1 ≤ ai ≤ 100 000 ) ai initial number portion i - th dish m - 1 line follow line contain description polycarp 's <unknown> give food a passenger sit front : j - th line contain a pair integers tj rj ( 0 ≤ tj ≤ k 0 ≤ rj ≤ 1 ) tj number dish give j - th passenger ( 0 polycarp n't notice dish give passenger ) rj — a 1 a 0 depend whether j - th passenger n't disappoint respectively know sum ai equal least m , polycarp definitely get dish even last thing want guarantee data consistent sum m input set n't exceed 100 000 . sum k input set n't exceed 100 000 . input set print answer a single line print a string k letter ` ` y '' ` ` n '' letter ` ` y '' position i print could run i - th dish time stewardess start serve polycarp first input set depend choice second passenger situation could develop different ways : thus answer ` ` <unknown> '' second input set example follow possible scenario first first passenger take third dish second passenger take second dish , third passenger ask third dish available make disappoint <unknown> end second dish fourth passenger take fourth dish polycarp end choice first fourth fifth dish <unknown> another possible scenario time stewardess come polycarp run either first fifth dish ( happen one dish take second passenger ) easy see enough fourth dish polycarp always count thus answer ` ` <unknown> ''",['greedy'],2100.0
946/A,give a sequence a consist n integers may partition sequence two sequence b c a way every element belong exactly one sequence let b sum elements belong b c sum elements belong c ( sequence empty sum 0 ) maximum possible value b - c ? first line contain one integer n ( 1 ≤ n ≤ 100 ) — number elements a. second line contain n integers a1 a2 ... ( - 100 ≤ ai ≤ 100 ) — elements sequence a. print maximum possible value b - c b sum elements sequence b c sum elements sequence c. first example may choose b = { 1 0 } c = { - 2 } b = 1 c = - 2 b - c = 3 . second example choose b = { 16 23 16 15 42 8 } c = { } ( empty sequence ) b = 120 c = 0 b - c = 120,['greedy'],800.0
985/C,m = n·k wooden stave i - th stave length ai assemble n barrel consist k stave use k stave construct a barrel stave must belong exactly one barrel let volume vj barrel j equal length minimal stave want assemble exactly n barrel maximal total sum volumes make equal enough a difference volumes pair result barrel must exceed l i.e |vx - vy| ≤ l 1 ≤ x ≤ n 1 ≤ y ≤ n. print maximal total sum volumes equal enough barrel 0 's impossible satisfy condition first line contain three space - separated integers n k l ( 1 ≤ n k ≤ 105 1 ≤ n·k ≤ 105 0 ≤ l ≤ 109 ) second line contain m = n·k space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) — lengths stave print single integer — maximal total sum volumes barrel 0 's impossible construct exactly n barrel satisfy condition |vx - vy| ≤ l 1 ≤ x ≤ n 1 ≤ y ≤ n. first example form follow barrel : [ 1 2 ] [ 2 2 ] [ 2 3 ] [ 2 3 ] second example form follow barrel : [ 10 ] [ 10 ] third example form follow barrel : [ 2 5 ] fourth example difference volumes barrel partition least 2 impossible make barrel equal enough,['greedy'],1500.0
1000/B,recently buy a brand new smart lamp program feature first set a schedule lamp every day turn power moment $$$ 0 $$$ turn power moment $$$ m $$$ moreover lamp allow set a program switch state ( state ` ` light '' ` ` light '' ) unfortunately program already instal lamp lamp allow good program good program represent a non - empty array $$$ a $$$ $$$ 0 < a_1 < a_2 < \dots < a _ { |a| } < m $$$ $$$ a_i $$$ must integers course preinstalled program a good program lamp follow program $$$ a $$$ next manner : moment $$$ 0 $$$ turn power light moment $$$ a_i $$$ lamp flip state opposite ( light turn vice versa ) state lamp flip instantly : example turn light moment $$$ 1 $$$ nothing total time lamp light $$$ 1 $$$ finally moment $$$ m $$$ lamp turn power regardless state since among people read instructions n't understand language 's write realize ( test ) possible way alter preinstalled program insert one element program $$$ a $$$ still a good program <unknown> <unknown> do pair consecutive elements $$$ a $$$ even begin end $$$ a $$$ find a way alter program total time lamp light maximum possible maybe leave program untouched lamp light $$$ x $$$ till moment $$$ y $$$ light $$$ y - x $$$ units time segment time lamp light sum first line contain two space separate integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100000 $$$ $$$ 2 \le m \le 1000000000 $$$ ) — length program $$$ a $$$ moment power turn second line contain $$$ n $$$ space separate integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 < a_1 < a_2 < \dots < a_n < m $$$ ) — initially instal program $$$ a $$$ print integer — maximum possible total time lamp light first example one possible optimal solutions insert value $$$ x = 3 $$$ $$$ a_1 $$$ program $$$ [ 3 4 6 7 ] $$$ time lamp light equal $$$ ( 3 - 0 ) + ( 6 - 4 ) + ( 10 - 7 ) = 8 $$$ possible solution insert $$$ x = 5 $$$ appropriate place second example one optimal solution : insert $$$ x = 2 $$$ $$$ a_1 $$$ $$$ a_2 $$$ program become $$$ [ 1 2 10 ] $$$ answer $$$ ( 1 - 0 ) + ( 10 - 2 ) = 9 $$$ third example optimal answer leave program untouched answer $$$ ( 3 - 0 ) + ( 7 - 4 ) = 6 $$$,['greedy'],1500.0
1003/D,polycarp $$$ n $$$ coin value $$$ i $$$ -th coin $$$ a_i $$$ guarantee value integer power $$$ 2 $$$ ( i.e $$$ a_i = 2^d $$$ non - negative integer number $$$ d $$$ ) polycarp want know answer $$$ q $$$ query $$$ j $$$ -th query describe integer number $$$ b_j $$$ answer query minimum number coin necessary obtain value $$$ b_j $$$ use subset coin ( polycarp use coin ) polycarp ca n't obtain value $$$ b_j $$$ answer $$$ j $$$ -th query -1 . query independent ( answer query n't affect polycarp 's coin ) first line input contain two integers $$$ n $$$ $$$ q $$$ ( $$$ 1 \le n q \le 200000 $$$ ) — number coin number query second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ — value coin ( $$$ 1 \le a_i \le 2000000000 $$$ ) guarantee $$$ a_i $$$ integer power $$$ 2 $$$ ( i.e $$$ a_i = 2^d $$$ non - negative integer number $$$ d $$$ ) next $$$ q $$$ line contain one integer $$$ j $$$ -th line contain one integer $$$ b_j $$$ — value $$$ j $$$ -th query ( $$$ 1 \le b_j \le 1000000000 $$$ ) print $$$ q $$$ integers $$$ <unknown> $$$ $$$ j $$$ -th integer must equal answer $$$ j $$$ -th query polycarp ca n't obtain value $$$ b_j $$$ answer $$$ j $$$ -th query -1,['greedy'],1600.0
1013/B,array n elements a1 a2 ... number x. one operation select i ( 1 ≤ i ≤ n ) replace element ai ai & x & denote bitwise operation want array least two equal elements apply operations ( possibly none ) word least two distinct indices i ≠ j ai = aj determine whether possible achieve possible minimal number operations apply first line contain integers n x ( 2 ≤ n ≤ 100 000 1 ≤ x ≤ 100 000 ) number elements array number second line contain n integers ai ( 1 ≤ ai ≤ 100 000 ) elements array print a single integer denote minimal number operations -1 impossible first example one apply operation last element array replace 7 3 achieve goal one move second example array already two equal elements third example apply operation wo n't change array impossible make pair elements equal,['greedy'],1200.0
888/B,ivan a robot situate infinite grid initially robot stand start cell ( 0 0 ) robot process command four type command perform : ivan enter a sequence n command robot process sequence robot end start cell ( 0 0 ) ivan doubt sequence perform correctly robot end cell think command ignore robot <unknown> whether robot <unknown> bug need calculate maximum possible number command perform correctly help ivan calculations ! first line contain one number n — length sequence command enter ivan ( 1 ≤ n ≤ 100 ) second line contain sequence — a string consist n character character u d l r. print maximum possible number command sequence robot could perform end start cell,['greedy'],1000.0
436/A,hero cut rope game a little monster name om nom love candy a <unknown> ! also hero today 's problem one day om nom visit friend evan evan n candy two type ( fruit drop caramel drop ) i - th candy hang height hi centimeters floor house mass mi om nom want eat many candy possible begin om nom make x <unknown> high jump om nom eat a candy mass y get stronger height jump increase y centimeters maximum number candy om nom eat never eat two candy type a row ( om nom find bore ) ? first line contain two integers n x ( 1 ≤ n x ≤ 2000 ) — number sweets evan initial height om nom 's jump follow n line contain three integers ti hi mi ( 0 ≤ ti ≤ 1 ; 1 ≤ hi mi ≤ 2000 ) — type height mass i - th candy number ti equal 0 current candy a caramel drop otherwise a fruit drop print a single integer — maximum number candy om nom eat one possible ways eat 4 candy eat order : 1 5 3 2 . let 's assume follow scenario :,['greedy'],1500.0
723/C,"polycarp a music editor radio station receive a playlist tomorrow represent a sequence a1 a2 ... , ai a band perform i - th song polycarp like band number 1 m n't really like others define bj number songs group j go perform tomorrow polycarp want change playlist a way minimum among number b1 b2 ... bm large possible find maximum possible value minimum among bj ( 1 ≤ j ≤ m ) minimum number change playlist polycarp need make achieve one change playlist a replacement performer i - th song group first line input contain two integers n m ( 1 ≤ m ≤ n ≤ 2000 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 109 ) ai performer i - th song first line print two integers : maximum possible value minimum among bj ( 1 ≤ j ≤ m ) bj number songs change playlist perform j - th band minimum number change playlist polycarp need make second line print change playlist multiple answer print first sample polycarp 's change first band perform two songs ( b1 = 2 ) second band also perform two songs ( b2 = 2 ) thus minimum value equal 2 . impossible achieve a higher minimum value change playlist second sample polycarp 's change first band perform two songs ( b1 = 2 ) second band perform three songs ( b2 = 3 ) third band also perform two songs ( b3 = 2 ) thus best minimum value 2",['greedy'],1600.0
719/B,anatoly live university dorm many students know cockroaches also live together students cockroaches might two color : black red n cockroaches live anatoly 's room anatoly make cockroaches form a single line a perfectionist would like color cockroaches line alternate a black paint a red paint one turn either swap two cockroaches take single cockroach change 's color help anatoly find minimum number turn need make color cockroaches line alternate first line input contain a single integer n ( 1 ≤ n ≤ 100 000 ) — number cockroaches second line contain a string length n consist character ' b ' ' r ' denote black cockroach red cockroach respectively print one integer — minimum number move anatoly perform order make color cockroaches line alternate first sample anatoly swap third fourth cockroaches need 1 turn second sample optimum answer paint second fourth cockroaches red require 2 turn third sample color cockroaches line alternate already thus answer 0,['greedy'],1400.0
462/B,appleman n card card uppercase letter write toastman must choose k card appleman 's card appleman give toastman coin depend choose card formally toastman 's card i calculate much toastman 's card letter equal letter ith sum <unknown> a number coin appleman give toastman give description appleman 's card maximum number coin toastman get ? first line contain two integers n k ( 1 ≤ k ≤ n ≤ 105 ) next line contain n uppercase letter without space — i - th letter describe i - th card appleman print a single integer – answer problem first test example toastman choose nine card letter d one additional card letter card d get 9 coin additional card get 1 coin,['greedy'],1300.0
472/C,a way make a new task make nondeterministic probabilistic example hard task <unknown> <unknown> <unknown> <unknown> probabilistic version a convex <unknown> let 's try make a new task firstly use follow task n people sort name ordinary sort problem make interest add nondeterministic element n people person use either his / her first name last name a handle lexicographical order handle exactly equal give permutation p ? formally denote handle i - th person hi follow condition must hold : first line contain integer n ( 1 ≤ n ≤ 105 ) — number people next n line contain two string i - th line contain string fi si ( 1 ≤ |fi| <unknown> ≤ 50 ) — first name last name i - th person string consist lowercase english letter give 2n string distinct next line contain n distinct integers : p1 p2 ... pn ( 1 ≤ pi ≤ n ) possible output ` ` yes '' otherwise output ` ` '' example 1 2 3 people : tourist petr ( <unknown> ) see whatever handle choose i must first tourist petr must last example 3 copernicus use ` ` copernicus '' handle everything <unknown>,['greedy'],1400.0
478/C,r red g green b blue balloon decorate a single table <unknown> need exactly three balloon three balloon attach table n't color maximum number t table decorate know number balloon color ? task write a program give value r g b find maximum number t table decorate require manner single line contain three integers r g b ( 0 ≤ r g b ≤ 2·109 ) — number red green blue <unknown> respectively number separate exactly one space print a single integer t — maximum number table decorate require manner first sample decorate table follow balloon set : ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` r '' ` ` g '' ` ` b '' represent red green blue ball respectively,['greedy'],1800.0
689/C,bad news come mike 's village thieve steal a bunch chocolates local <unknown> ! horrible ! <unknown> love sweet things thieve area know greedy a thief take number chocolates next thief take exactly k time previous one value k ( k > 1 ) a secret integer know also know thief 's bag carry n chocolates ( intend take deal cancel ) exactly four thieve involve <unknown> thieve know value n rumour say number ways could take chocolates ( a fix n fix k ) m. two ways consider different one thieve ( number order take chocolates ) take different number chocolates mike want track thieve want know bag value n help please find smallest possible value n tell rumor false n. single line input contain integer m ( 1 ≤ m ≤ <unknown> ) — number ways thieve might steal chocolates rumour say print integer n — maximum amount chocolates thieve ' bag carry one n satisfy rumor print smallest one n a false - <unknown> m print - 1 . first sample case smallest n lead exactly one way steal chocolates n = 8 whereas amount steal chocolates ( 1 2 4 8 ) ( number chocolates steal thieve ) second sample case smallest n lead exactly 8 ways n = 54 possibilities : ( 1 2 4 8 ) ( 1 3 9 27 ) ( 2 4 8 16 ) ( 2 6 18 54 ) ( 3 6 12 24 ) ( 4 8 16 32 ) ( 5 10 20 40 ) ( 6 12 24 <unknown> ) n lead exactly 10 ways steal chocolates third sample case,['math'],1700.0
44/D,a far away galaxy n inhabit planets number number 1 n. locate large distance 's communication difficult planet number 1 a hyperdrive invent soon significant event take place n - 1 spaceships build planet number 1 ship send planets inform revolutionary invention <unknown> think may hyperspace represent simple three - dimensional euclidean space inhabit planets may consider fix point two point coincide three point lie straight line movement a ship a hyperdrive two planets perform along a straight line constant speed ship 's distance hyperspace measure hyperyears ( a ship a hyperdrive cover a distance s hyperyears s years ) ship reach inhabit planet inhabitants planet dissemble make n - 2 identical ship a hyperdrive send n - 2 planets ( except one ship arrive ) time make a new ship compare time move one planet another small <unknown> new ship absolutely identical ones send initially : move constant speed along a straight line trajectory reach a planet perform mission i.e dissemble build new n - 2 ship send planets except one ship arrive thus process spread important news around galaxy continue however hyperdrive creators hurry spread news invention much n't study completely go two ship collide hyperspace two move ship find one point <unknown> <unknown> <unknown> power lead destruction galaxy ! task find time galaxy continue exist moment ship ' launch first planet first line contain a number n ( 3 ≤ n ≤ 5000 ) — number inhabit planets galaxy next n line contain integer coordinate planets format ` ` xi yi zi '' ( - 104 ≤ xi yi zi ≤ 104 ) print single number — solution task absolute relative error exceed 10 - 6,['math'],1800.0
1359/C,two infinite source water : perform follow procedure alternate move : note always start cup hot water barrel initially empty pour least one cup barrel water temperature barrel average temperatures pour cup want achieve a temperature close possible $$$ t $$$ temperature barrel $$$ t_b $$$ absolute difference $$$ t_b $$$ $$$ t $$$ ( $$$ <unknown> - <unknown> $$$ ) small possible many cup pour barrel temperature close possible $$$ t $$$ ? multiple answer minimum absolute difference print smallest first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le <unknown> $$$ ) — number testcases next $$$ t $$$ line contain three integers $$$ h $$$ $$$ c $$$ $$$ t $$$ ( $$$ 1 \le c < h \le 1000000 $$$ ; $$$ c \le t \le h $$$ ) — temperature hot water temperature cold water desire temperature barrel testcase print a single positive integer — minimum number cup require pour barrel achieve closest temperature $$$ t $$$ first testcase temperature $$$ 2 $$$ pour cup : $$$ 1 $$$ hot $$$ 1 $$$ cold exactly $$$ 20 $$$ closest achieve second testcase temperature $$$ 7 $$$ pour cup : $$$ 4 $$$ hot $$$ 3 $$$ cold $$$ <unknown> $$$ pour water wo n't get us closer $$$ t $$$ third testcase temperature $$$ 1 $$$ pour cup : $$$ 1 $$$ hot $$$ 18 $$$ 's exactly equal $$$ t $$$,['math'],1700.0
1350/A,"orac study number theory interest properties divisors two positive integers $$$ a $$$ $$$ b $$$ $$$ a $$$ a divisor $$$ b $$$ exist integer $$$ c $$$ $$$ <unknown> c = b $$$ $$$ n \ge 2 $$$ denote $$$ f ( n ) $$$ smallest positive divisor $$$ n $$$ except $$$ 1 $$$ example $$$ f ( 7 ) = 7 f ( 10 ) = 2 f ( <unknown> ) = 5 $$$ fix integer $$$ n $$$ orac decide add $$$ f ( n ) $$$ $$$ n $$$ example integer $$$ n=5 $$$ new value $$$ n $$$ equal $$$ 10 $$$ integer $$$ n=6 $$$ $$$ n $$$ change $$$ 8 $$$ orac love much decide repeat operation several time , two positive integers $$$ n $$$ $$$ k $$$ orac ask add $$$ f ( n ) $$$ $$$ n $$$ exactly $$$ k $$$ time ( note $$$ n $$$ change operation $$$ f ( n ) $$$ may change ) tell final value $$$ n $$$ example orac give $$$ n=5 $$$ $$$ k=2 $$$ first add $$$ f ( 5 ) = 5 $$$ $$$ n=5 $$$ new value $$$ n $$$ equal $$$ n=10 $$$ , add $$$ f ( 10 ) = 2 $$$ $$$ 10 $$$ new ( final ! ) value $$$ n $$$ equal $$$ 12 $$$ orac may ask query many time first line input a single integer $$$ <unknown> ( 1\le t\le 100 ) $$$ : number time orac ask next $$$ t $$$ line contain two positive integers $$$ n <unknown> ( 2\le n\le 1000000 1\le k\le 1000000000 ) $$$ correspond a query orac guarantee total sum $$$ n $$$ $$$ 1000000 $$$ print $$$ t $$$ line $$$ i $$$ -th contain final value $$$ n $$$ $$$ i $$$ -th query orac first query $$$ n=5 $$$ $$$ <unknown> $$$ divisors $$$ 5 $$$ $$$ 1 $$$ $$$ 5 $$$ smallest one except $$$ 1 $$$ $$$ 5 $$$ therefore operation add $$$ f ( 5 ) = 5 $$$ $$$ 5 $$$ result $$$ 10 $$$ second query $$$ n=8 $$$ $$$ k=2 $$$ divisors $$$ 8 $$$ $$$ <unknown> $$$ smallest one except $$$ 1 $$$ $$$ 2 $$$ one operation $$$ 8 $$$ turn $$$ 8 + ( f ( 8 ) = 2 ) = 10 $$$ divisors $$$ 10 $$$ $$$ <unknown> $$$ smallest one except $$$ 1 $$$ $$$ 2 $$$ therefore answer $$$ 10 + ( f ( 10 ) = 2 ) = 12 $$$ third query $$$ n $$$ change follow : $$$ 3 \to 6 \to 8 \to 10 \to 12 $$$",['math'],900.0
1352/C,give two positive integers $$$ n $$$ $$$ k $$$ print $$$ k $$$ -th positive integer divisible $$$ n $$$ example $$$ n=3 $$$ $$$ k=7 $$$ number divisible $$$ 3 $$$ : $$$ 1 2 4 5 7 8 10 11 13 \dots $$$ $$$ 7 $$$ -th number among $$$ 10 $$$ first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case input next $$$ t $$$ test case give one per line test case two positive integers $$$ n $$$ ( $$$ 2 \le n \le 1000000000 $$$ ) $$$ k $$$ ( $$$ 1 \le k \le 1000000000 $$$ ) test case print $$$ k $$$ -th positive integer divisible $$$ n $$$,['math'],1200.0
1353/C,give a board size $$$ n \times n $$$ $$$ n $$$ odd ( divisible $$$ 2 $$$ ) initially cell board contain one figure one move select exactly one figure present cell move one cells share a side a corner current cell i.e cell $$$ ( i j ) $$$ move figure cells : course move figure cells board allow a move several figure one cell task find minimum number move need get figure one cell ( i.e $$$ n^2 - 1 $$$ cells contain $$$ 0 $$$ figure one cell contain $$$ n^2 $$$ figure ) answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 200 $$$ ) — number test case $$$ t $$$ test case follow line test case contain one integer $$$ n $$$ ( $$$ 1 \le n < 500000 $$$ ) — size board guarantee $$$ n $$$ odd ( divisible $$$ 2 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 500000 $$$ ( $$$ \sum n \le 500000 $$$ ) test case print answer — minimum number move need get figure one cell,['math'],1000.0
1354/A,polycarp spend entire day prepare problems sleep least $$$ a $$$ minutes feel refresh polycarp wake hear sound alarm fall asleep first alarm go $$$ b $$$ minutes every time polycarp wake decide want sleep time 's sleep less $$$ a $$$ minutes total set alarm go $$$ c $$$ minutes reset spend $$$ d $$$ minutes fall asleep otherwise get bed proceed day alarm go polycarp fall asleep reset alarm go another $$$ c $$$ minutes try fall asleep $$$ d $$$ minutes want find polycarp get bed report never happen please check note explanations example first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases line testcase contain four integers $$$ a b c d $$$ ( $$$ 1 \le a b c d \le 1000000000 $$$ ) — time polycarp sleep feel refresh time first alarm go time every succeed alarm go time polycarp spend fall asleep test case print one integer polycarp never get bed print -1 . otherwise print time take polycarp get bed first testcase polycarp wake $$$ 3 $$$ minutes rest $$$ 3 $$$ minutes $$$ 10 $$$ minutes need set alarm go $$$ 6 $$$ minutes spend $$$ 4 $$$ minutes fall asleep thus rest $$$ 2 $$$ minutes total $$$ 3 + 2=5 $$$ minutes sleep repeat procedure three time end $$$ 11 $$$ minutes sleep finally get bed spend $$$ 3 $$$ minutes first alarm reset alarm four time answer $$$ 3 + 4 \cdot 6 = 27 $$$ second example almost like first one polycarp need $$$ 11 $$$ minutes sleep instead $$$ 10 $$$ however change nothing get $$$ 11 $$$ minutes alarm parameters anyway third testcase polycarp wake rest enough first alarm thus answer $$$ <unknown> $$$ fourth testcase polycarp wake $$$ 5 $$$ minutes unfortunately keep reset alarm infinitely unable rest even a single minute : (,['math'],900.0
1346/A,<unknown> long since last color revolution ? 5 years ? ! 's <unknown> time make a new one ! general idea follow division $$$ 1 $$$ $$$ n_1 $$$ participants division $$$ 2 $$$ $$$ n_2 $$$ exactly $$$ k $$$ time bigger division $$$ 1 $$$ ( $$$ n_2 = k \cdot n_1 $$$ ) division $$$ 3 $$$ $$$ n_3 = k \cdot n_2 $$$ participants finally division $$$ 4 $$$ $$$ n_4 = k \cdot n_3 $$$ participants $$$ n $$$ participants codeforces total $$$ n_1 + n_2 + n_3 + n_4 $$$ exactly equal $$$ n $$$ know value $$$ n $$$ $$$ k $$$ also know $$$ n $$$ $$$ k $$$ choose a way exist value $$$ n_1 n_2 n_3 $$$ $$$ n_4 $$$ condition satisfy number participants division ( $$$ n_1 n_2 n_3 $$$ $$$ n_4 $$$ ) revolution ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases next $$$ t $$$ line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 4 \le n \le 1000000000 $$$ ; $$$ 1 \le k \le 500 $$$ ) — total number participants codeforces size <unknown> correspond testcase testcase $$$ n $$$ $$$ k $$$ choose a way answer exist testcase print four integers $$$ n_1 n_2 n_3 $$$ $$$ n_4 $$$ $$$ n_2 = k \cdot n_1 $$$ $$$ n_3 = k \cdot n_2 $$$ $$$ n_4 = k \cdot n_3 $$$ $$$ n_1 + n_2 + n_3 + n_4 = n $$$,['math'],1000.0
1358/C,<unknown> <unknown> free time create new function ` ` celex-2021 '' developers make a new function gaz - giz infinitely fill infinite table right upper leave corner follow : developers sum function n't sleep either <unknown> team developers <unknown> function add ability calculate sum arbitrary path one cell another move right formally cell $$$ ( x y ) $$$ one step move cell $$$ ( x+1 y ) $$$ $$$ ( x y+1 ) $$$ another <unknown> update <unknown> start study ` ` celex-2021 '' ( want accountant ! ) fill table gaz - giz function ask calculate quantity possible different amount path a give cell $$$ ( x_1 y_1 ) $$$ another give cell $$$ ( x_2 y_2 $$$ ) move one cell right formally consider paths cell $$$ ( x_1 y_1 ) $$$ cell $$$ ( x_2 y_2 ) $$$ next cell path locate either right previous one calculate number different sum elements paths first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le <unknown> $$$ ) — number test case follow $$$ t $$$ line contain four natural number $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \le x_1 \le x_2 \le 1000000000 $$$ $$$ 1 \le y_1 \le y_2 \le 1000000000 $$$ ) — coordinate start end cells test case a separate line print number possible different sum way start cell end cell first test case two possible sum : $$$ 1 + 2 + <unknown> $$$ $$$ 1 + 3 + <unknown> $$$,['math'],1600.0
1359/E,define $$$ x \bmod y $$$ remainder division $$$ x $$$ $$$ y $$$ ( $$$ \ % $$$ operator c++ java mod operator pascal ) let 's call array positive integers $$$ [ a_1 a_2 \dots a_k ] $$$ stable every permutation $$$ p $$$ integers $$$ 1 $$$ $$$ k $$$ every non - negative integer $$$ x $$$ follow condition meet : non - negative integer $$$ x $$$ value $$$ ( ( ( x \bmod a_1 ) \bmod a_2 ) \dots \bmod a _ { k - 1 } ) \bmod a_k $$$ change reorder elements array $$$ a $$$ two give integers $$$ n $$$ $$$ k $$$ calculate number stable array $$$ [ a_1 a_2 \dots a_k ] $$$ $$$ 1 \le a_1 < a_2 < \dots < a_k \le n $$$ line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 500000 $$$ ) print one integer — number stable array $$$ [ a_1 a_2 \dots a_k ] $$$ $$$ 1 \le a_1 < a_2 < \dots < a_k \le n $$$ since answer may large print modulo $$$ 998244353 $$$,['math'],2000.0
1360/D,"polycarp want buy exactly $$$ n $$$ shovel shop sell package shovel store $$$ k $$$ type package : package $$$ i $$$ -th type consist exactly $$$ i $$$ shovel ( $$$ 1 \le i \le k $$$ ) store infinite number package type polycarp want choose one type package buy several ( one ) package type smallest number package polycarp buy get exactly $$$ n $$$ shovel ? example $$$ n=8 $$$ $$$ k=7 $$$ polycarp buy $$$ 2 $$$ package $$$ 4 $$$ shovel help polycarp find minimum number package need buy give : first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case input , $$$ t $$$ test case follow one per line test case consist two positive integers $$$ n $$$ ( $$$ 1 \le n \le 1000000000 $$$ ) $$$ k $$$ ( $$$ 1 \le k \le 1000000000 $$$ ) — number shovel number type package print $$$ t $$$ answer test case answer a positive integer — minimum number package answer first test case explain statement second test case one way buy $$$ 8 $$$ shovel — $$$ 8 $$$ package one shovel third test case need buy a $$$ 1 $$$ package $$$ 6 $$$ shovel",['math'],1300.0
1371/A,"a penguin <unknown> $$$ n $$$ stick exactly one stick length $$$ i $$$ $$$ 1 \le i \le n $$$ connect stick connect two stick lengths $$$ a $$$ $$$ b $$$ get one stick length $$$ a + b $$$ two stick use operation disappear set new connect stick appear set use next connections want create maximum number stick length necessary make stick length stick length many stick equal length create ? input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next $$$ t $$$ line contain descriptions test case test case line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 10^ { 9 } $$$ ) test case print a single integer — answer problem third case connect two stick lengths $$$ 1 $$$ $$$ 2 $$$ get one stick length $$$ 3 $$$ , two stick lengths $$$ 3 $$$ fourth case connect two stick lengths $$$ 1 $$$ $$$ 3 $$$ get one stick length $$$ 4 $$$ , three stick lengths $$$ \ { 2 4 4\ } $$$ two stick length one stick length",['math'],800.0
1371/B,"a competitive <unknown> alice schedule practice eat contest a magical calendar calendar unusual a week contain necessarily $$$ 7 $$$ days ! detail choose integer $$$ k $$$ satisfy $$$ 1 \leq k \leq r $$$ set $$$ k $$$ days number days a week alice go paint $$$ n $$$ consecutive days calendar calendar date write leave cell right cell a week a date reach last day a week next day 's cell leftmost cell next ( ) row want make paint cells connect side mean two paint cells exist least one sequence paint cells start one cells end another two consecutive cells sequence connect side alice consider shape paint cells two shape exist a way make exactly overlap use parallel move parallel calendar 's side example picture a week $$$ 4 $$$ days alice paint $$$ 5 $$$ consecutive days [ 1 ] [ 2 ] different shape [ 1 ] [ 3 ] equal shape alice want know many possible shape exist set many days a week choose consecutive $$$ n $$$ days paint calendar start one days week say consider shape cells connect side input consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case next $$$ t $$$ line contain descriptions test case test case line contain two integers $$$ n $$$ $$$ r $$$ ( $$$ 1 \le n \le 1000000000 1 \le r \le 1000000000 $$$ ) test case print a single integer — answer problem please note answer test case wo n't fit $$$ 32 $$$ -bit integer type use least $$$ 64 $$$ -bit integer type program language first test case alice set $$$ 1,2,3 $$$ $$$ 4 $$$ days number days a week $$$ 6 $$$ possible paint show picture $$$ 4 $$$ different shape , answer $$$ 4 $$$ notice last example picture invalid paint cells connect side last test case careful <unknown> issue describe output format",['math'],1200.0
1373/C,give a string $$$ s $$$ consist character + - perform process string process describe follow pseudocode : note $$$ <unknown> $$$ denote infinity character string number $$$ 1 $$$ $$$ |s| $$$ calculate value $$$ res $$$ process end first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case line test case contain string $$$ s $$$ ( $$$ 1 \le |s| \le 1000000 $$$ ) consist character + - 's guarantee sum $$$ |s| $$$ test case n't exceed $$$ 1000000 $$$ test case print one integer — value $$$ res $$$ process end,['math'],1300.0
1346/G,two ip cameras model camera take photos start moment time a fix period freely choose start moment choose period one $$$ k $$$ value $$$ p_1 p_2 \dots p_k $$$ choose camera 's <unknown> $$$ n $$$ moments interest $$$ x_1 x_2 \dots x_n $$$ 'd like configure cameras a way least one camera take a photo moments configure camera mean set moment take first photo gap two consecutive photos ( one value $$$ p_1 p_2 \dots p_k $$$ ) 's a problem cameras take photos moments time — care moments interest first line contain two integers $$$ k $$$ $$$ n $$$ ( $$$ 1 \le k \le 100000 $$$ ; $$$ 2 \le n \le 100000 $$$ ) — number periods choose number moments interest second line contain $$$ k $$$ integers $$$ p_1 p_2 \dots p_k $$$ ( $$$ 1 \le p_1 < p_2 < \dots < p_k \le 1000000 $$$ ) — periods choose ascend order third line contain $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ 1 \le x_1 < x_2 < \dots < x_n \le 1000000 $$$ ) — moments interest ascend order print yes ( case insensitive ) first line a way configure cameras second line print two integers $$$ s_1 $$$ $$$ cp_1 $$$ ( $$$ 1 \le s_1 \le 1000000 $$$ ; $$$ 1 \le cp_1 \le 1000000 $$$ ; $$$ cp_1 \in \ { p_1 \dots p_k\ } $$$ ) — start moment period first camera period one give periods third line print two integers $$$ s_2 $$$ $$$ cp_2 $$$ ( $$$ 1 \le s_2 \le 1000000 $$$ ; $$$ 1 \le cp_2 \le 1000000 $$$ ; $$$ cp_2 \in \ { p_1 \dots p_k\ } $$$ ) — start moment period second camera period one give periods way configure cameras print ( case insensitive ) multiple ways may print,['math'],2300.0
1349/D,"slime $$$ n $$$ friends a party slime design a game friends play begin game $$$ i $$$ -th player $$$ a_i $$$ biscuits second slime choose a biscuit randomly uniformly among $$$ a_1 + a_2 + \ldots + a_n $$$ biscuits owner biscuit give a random uniform player among $$$ n-1 $$$ players except game stop one person biscuits host party slime want know expect value time game last hold next activity time convenience answer represent a rational number $$$ \frac { p } { q } $$$ coprime $$$ p $$$ $$$ q $$$ need find value $$$ ( p \cdot q^ { -1 } ) \mod 998\,244\,353 $$$ prove $$$ <unknown> 998\,244\,353 \neq 0 $$$ first line contain one integer $$$ n\ ( 2\le n\le 100\,000 ) $$$ : number people play game second line contain $$$ n $$$ non - negative integers $$$ a_1 a_2 \dots <unknown> ( 1\le <unknown> 300\,000 ) $$$ $$$ a_i $$$ represent number biscuits $$$ i $$$ -th person begin print one integer : expect value time game last modulo $$$ 998\,244\,353 $$$ first example first second probability player $$$ 1 $$$ give player $$$ 2 $$$ a biscuit $$$ \frac { 1 } { 2 } $$$ probability player $$$ 2 $$$ give player $$$ 1 $$$ a biscuit $$$ \frac { 1 } { 2 } $$$ anyway game stop exactly $$$ 1 $$$ second one player occupy biscuits $$$ 1 $$$ second answer $$$ 1 $$$",['math'],3200.0
1238/A,give two integers $$$ x $$$ $$$ y $$$ ( guarantee $$$ x > y $$$ ) may choose prime integer $$$ p $$$ subtract number time $$$ x $$$ possible make $$$ x $$$ equal $$$ y $$$ ? recall a prime number a positive integer exactly two positive divisors : $$$ 1 $$$ integer sequence prime number start $$$ 2 $$$ $$$ 3 $$$ $$$ 5 $$$ $$$ 7 $$$ $$$ 11 $$$ program solve $$$ t $$$ independent test case first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case $$$ t $$$ line follow describe a test case line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 1 \le y < x \le 10^ { 18 } $$$ ) test case print yes possible choose a prime number $$$ p $$$ subtract number time $$$ x $$$ $$$ x $$$ become equal $$$ y $$$ otherwise print may print every letter case want ( example string yes yes yes yes recognize positive answer ) first test example may choose $$$ p = 2 $$$ subtract second test example may choose $$$ p = 5 $$$ subtract twice note choose $$$ p = 7 $$$ subtract choose $$$ p = 3 $$$ subtract third test example may choose $$$ p = 3 $$$ subtract $$$ <unknown> $$$ time,['math'],900.0
1374/A,give three integers $$$ x y $$$ $$$ n $$$ task find maximum integer $$$ k $$$ $$$ 0 \le k \le n $$$ $$$ k \bmod x = y $$$ $$$ \bmod $$$ modulo operation many program languages use percent operator % implement word give $$$ x y $$$ $$$ n $$$ need find maximum possible integer $$$ 0 $$$ $$$ n $$$ remainder $$$ y $$$ modulo $$$ x $$$ answer $$$ t $$$ independent test case guarantee $$$ k $$$ exist test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 50000 $$$ ) — number test case next $$$ t $$$ line contain test case line test case contain three integers $$$ x y $$$ $$$ n $$$ ( $$$ 2 \le x \le 1000000000 ; ~ 0 \le y < x ; ~ y \le n \le 1000000000 $$$ ) show $$$ k $$$ always exist give constraints test case print answer — maximum non - negative integer $$$ k $$$ $$$ 0 \le k \le n $$$ $$$ k \bmod x = y $$$ guarantee answer always exist first test case example answer $$$ 12339 = <unknown> + 5 $$$ ( thus $$$ 12339 \bmod 7 = 5 $$$ ) obvious greater integer exceed $$$ <unknown> $$$ remainder $$$ 5 $$$ modulo $$$ 7 $$$,['math'],800.0
1236/B,"alice get many present days decide pack box send friends $$$ n $$$ kinds present present one kind identical ( i.e way distinguish two gift kind ) present different kinds different ( i.e , two gift different kinds distinguishable ) number present kind alice big consider alice infinite number gift kind also $$$ m $$$ box different people pairwise distinct ( consider name $$$ m $$$ friends write box ) example put first kind present first box second box different put first kind present second box first box alice want pack present follow rule : alice want know many different ways pack present exist please help calculate number since answer huge output modulo $$$ 1000000000 + 7 $$$ see examples note clarification first line contain two integers $$$ n $$$ $$$ m $$$ separate space ( $$$ 1 \leq n m \leq 1000000000 $$$ ) — number kinds present number box alice print one integer — number ways pack present alice 's rule calculate modulo $$$ 1000000000 + 7 $$$ first example seven ways pack present : $$$ \ { 1\ } \ { \ } \ { \ } $$$ $$$ \ { \ } \ { 1\ } \ { \ } $$$ $$$ \ { \ } \ { \ } \ { 1\ } $$$ $$$ \ { 1\ } \ { 1\ } \ { \ } $$$ $$$ \ { \ } \ { 1\ } \ { 1\ } $$$ $$$ \ { 1\ } \ { \ } \ { 1\ } $$$ $$$ \ { 1\ } \ { 1\ } \ { 1\ } $$$ second example nine ways pack present : $$$ \ { \ } \ { 1,2\ } $$$ $$$ \ { 1\ } \ { 2\ } $$$ $$$ \ { 1\ } \ { 1,2\ } $$$ $$$ \ { 2\ } \ { 1\ } $$$ $$$ \ { 2\ } \ { 1,2\ } $$$ $$$ \ { 1,2\ } \ { \ } $$$ $$$ \ { 1,2\ } \ { 1\ } $$$ $$$ \ { 1,2\ } \ { 2\ } $$$ $$$ \ { 1,2\ } \ { 1,2\ } $$$ example way $$$ \ { 2\ } \ { 2\ } $$$ wrong present first kind use least one box",['math'],1500.0
1303/B,company <unknown> lay new asphalt highway length $$$ n $$$ know every day either repair one unit highway ( lay new asphalt one unit highway ) skip repair skip repair necessary climate climate region <unknown> : $$$ g $$$ days weather good lay new asphalt days become high - quality pavement ; weather next $$$ b $$$ days bad lay new asphalt days become low - quality pavement ; $$$ g $$$ good days $$$ b $$$ bad days sure start repair start a good season word days $$$ 1 2 \dots g $$$ good n't really care quality highway want make sure least half highway high - quality pavement example $$$ n = 5 $$$ least $$$ 3 $$$ units highway high quality ; $$$ n = 4 $$$ least $$$ 2 $$$ units high quality minimum number days need finish repair whole highway ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case next $$$ t $$$ line contain test case — one per line line contain three integers $$$ n $$$ $$$ g $$$ $$$ b $$$ ( $$$ 1 \le n g b \le 1000000000 $$$ ) — length highway number good bad days respectively print $$$ t $$$ integers — one per test case test case print minimum number days require repair whole highway least half high quality first test case lay new asphalt day since days $$$ 1 3 5 $$$ good second test case also lay new asphalt day since days $$$ 1 $$$ - $$$ 8 $$$ good,['math'],1400.0
1304/A,"tire participate many codeforces round gildong decide take rest a park sit a bench soon find two rabbit hop around one rabbit taller notice two rabbit hop towards position two rabbit represent integer coordinate a horizontal line taller rabbit currently position $$$ x $$$ shorter rabbit currently position $$$ y $$$ ( $$$ x \lt y $$$ ) every second rabbit hop another position taller rabbit hop positive direction $$$ a $$$ shorter rabbit hop negative direction $$$ b $$$ example let 's say $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ 1 $$$ -st second rabbit position $$$ 2 $$$ $$$ 7 $$$ $$$ 2 $$$ -nd second rabbit position $$$ 4 $$$ gildong wonder : two rabbit position moment ? , long take ? let 's find a moment time ( second ) rabbit point test contain one test case first line contain number test case $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) test case contain exactly one line line consist four integers $$$ x $$$ $$$ y $$$ $$$ a $$$ $$$ b $$$ ( $$$ 0 \le x \lt y \le 1000000000 $$$ $$$ 1 \le a b \le 1000000000 $$$ ) — current position taller rabbit current position shorter rabbit hop distance taller rabbit hop distance shorter rabbit respectively test case print single integer : number second two rabbit take position two rabbit never position simultaneously print $$$ -1 $$$ first case explain description second case rabbit position $$$ 3 $$$ $$$ 7 $$$ respectively $$$ 1 $$$ -st second $$$ 2 $$$ -nd second $$$ 6 $$$ $$$ 4 $$$ respectively see never position since distance two rabbit increase afterward",['math'],800.0
1305/F,kuroni angry setters use a <unknown> ! a punishment force solve follow problem : array $$$ a $$$ consist $$$ n $$$ positive integers operation consist choose element either add $$$ 1 $$$ subtract $$$ 1 $$$ element remain positive say array good greatest common divisor elements $$$ 1 $$$ find minimum number operations need make array good unable match kuroni 's intellect setters fail solve problem help escape kuroni 's punishment ! first line contain integer $$$ n $$$ ( $$$ 2 \le n \le 200000 $$$ ) — number elements array second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 10^ { 12 } $$$ ) — elements array print a single integer — minimum number operations require make array good first example first array already good since greatest common divisor elements $$$ 2 $$$ second example may apply follow operations : greatest common divisor elements equal $$$ 3 $$$ array good show sequence three less operations make array good,['math'],2500.0
1310/F,modern <unknown> much tie algorithmic complexity solve several problems one problems a discrete logarithm problem formulate follow : likely modern <unknown> solve problem discrete logarithm a sufficiently large field size example a field <unknown> modulo prime number <unknown> 1024 2048 bits consider safe however calculations large number place a significant load servers perform <unknown> operations reason instead a simple <unknown> residue field complex field often use field fast algorithms use a field structure know smaller field use operations properly optimize developer <unknown> trust generally accept methods want invent recently read a strange field — nimbers think 's a great fit purpose field nimbers define a set integers 0 $$$ 2^ { 2^k } - 1 $$$ positive integer $$$ k $$$ bitwise exclusive ( $$$ \oplus $$$ ) operation use addition one ways define multiplication operation ( $$$ \odot $$$ ) follow properties : example : formally algorithm describe follow pseudo - code show operations really form a field moreover make sense game theory operations 's relate problem much help appropriate <unknown> group operations possible calculate product quickly enough important improve speed <unknown> formal definitions well additional properties clarify wikipedia <unknown> link author task hope properties list statement enough solution power <unknown> define way formally $$$ a^ { \odot k } = <unknown> { a \odot a \odot \cdots \odot a } _ { <unknown> { time } } $$$ need analyze propose scheme strength pair number $$$ a $$$ $$$ b $$$ need find $$$ x $$$ $$$ a^ { \odot x } = b $$$ determine n't exist first line input single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number pair need find discrete logarithm next $$$ t $$$ line a pair integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b < 2^ { 64 } $$$ ) pair print one integer $$$ x $$$ ( $$$ 0 \le x < 2^ { 64 } $$$ ) $$$ a^ { \odot x } = b $$$ -1 x exist show $$$ x $$$ exist one inside give bound several good value output,['math'],3400.0
1312/D,task calculate number array : first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le m \le 200000 $$$ ) print one integer — number array meet aforementioned condition take modulo $$$ 998244353 $$$ array first example :,['math'],1700.0
1344/A,"hilbert 's hotel a unusual hotel since number room infinite ! fact exactly one room every integer include zero negative integers even stranger hotel currently full capacity mean exactly one guest every room hotel 's manager david hilbert decide want shuffle guests around think create a <unknown> ( a room without a guest ) integer $$$ k $$$ positive integer $$$ n $$$ let $$$ k\bmod n $$$ denote remainder $$$ k $$$ divide $$$ n $$$ formally $$$ r = k\bmod n $$$ smallest non - negative integer $$$ k - r $$$ divisible $$$ n $$$ always hold $$$ 0\le k\bmod n\le n-1 $$$ example $$$ <unknown> <unknown> $$$ $$$ ( <unknown> ) \bmod 3=1 $$$ shuffle work follow array $$$ n $$$ integers $$$ a_0 a_1 \ldots a _ { n-1 } $$$ integer $$$ k $$$ guest room $$$ k $$$ move room number $$$ <unknown> _ { k\bmod n } $$$ shuffle process determine still exactly one guest assign room , <unknown> room multiple guests test consist multiple test case first line contain a single integer $$$ t $$$ ( $$$ 1\le t\le 10000 $$$ ) — number test case next $$$ 2 t $$$ line contain descriptions test case first line test case contain a single integer $$$ n $$$ ( $$$ 1\le n\le 2\cdot 100000 $$$ ) — length array second line test case contain $$$ n $$$ integers $$$ a_0 a_1 \ldots a _ { n-1 } $$$ ( $$$ <unknown> a_i\le 1000000000 $$$ ) guarantee sum $$$ n $$$ test case exceed $$$ 2\cdot 100000 $$$ test case output a single line contain ` ` yes '' exactly one guest assign room shuffle process ` ` '' otherwise print letter case ( upper lower ) first test case every guest shift $$$ 14 $$$ room assignment still unique second test case even guests move right $$$ 1 $$$ room odd guests move leave $$$ 1 $$$ room show assignment still unique third test case every fourth guest move right $$$ 1 $$$ room guests move right $$$ 5 $$$ room show assignment still unique fourth test case guests $$$ 0 $$$ $$$ 1 $$$ assign room $$$ 3 $$$ fifth test case guests $$$ 1 $$$ $$$ 2 $$$ assign room $$$ 2 $$$",['math'],1600.0
1322/C,"wu get hungry <unknown> train <unknown> come a nearby store buy favourite instant <unknown> wu pay purchase cashier give interest task give a bipartite graph positive integers vertices right half a subset $$$ s $$$ vertices leave half define $$$ n ( s ) $$$ set vertices right half adjacent least one vertex $$$ s $$$ $$$ f ( s ) $$$ sum number vertices $$$ n ( s ) $$$ find greatest common divisor $$$ f ( s ) $$$ possible non - empty subsets $$$ s $$$ ( assume gcd empty set $$$ 0 $$$ ) wu tire train solve problem help ! first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 500\,000 $$$ ) — number test case give test set test case descriptions follow first line case description contain two integers $$$ n $$$ $$$ m $$$ ( $$$ <unknown> ~ n <unknown> $$$ ) — number vertices either half graph number edge respectively second line contain $$$ n $$$ integers $$$ c_i $$$ ( $$$ 1 \leq c_i \leq 10^ { 12 } $$$ ) $$$ i $$$ -th number describe integer vertex $$$ i $$$ right half graph follow $$$ m $$$ line contain a pair integers $$$ u_i $$$ $$$ v_i $$$ ( $$$ 1 \leq u_i v_i \leq n $$$ ) describe edge vertex $$$ u_i $$$ leave half vertex $$$ v_i $$$ right half guarantee graph contain multiple edge test case descriptions separate empty line total value $$$ n $$$ across test case exceed $$$ 500\,000 $$$ total value $$$ m $$$ across test case exceed $$$ 500\,000 $$$ well test case print a single integer — require greatest common divisor greatest common divisor a set integers largest integer $$$ g $$$ elements set divisible $$$ g $$$ first sample case vertices leave half vertices right half pairwise connect $$$ f ( s ) $$$ non - empty subset $$$ 2 $$$ thus greatest common divisor value also equal $$$ 2 $$$ second sample case subset $$$ \ { 1\ } $$$ leave half connect vertices $$$ \ { 1 2\ } $$$ right half sum number equal $$$ 2 $$$ subset $$$ \ { 1 2\ } $$$ leave half connect vertices $$$ \ { 1 2 3\ } $$$ right half sum number equal $$$ 3 $$$ thus $$$ f ( \ { 1\ } ) = 2 $$$ $$$ f ( \ { 1 2\ } ) = 3 $$$ mean greatest common divisor value $$$ f ( s ) $$$ $$$ 1 $$$",['math'],2300.0
1328/A,give two positive integers $$$ a $$$ $$$ b $$$ one move increase $$$ a $$$ $$$ 1 $$$ ( replace $$$ a $$$ $$$ <unknown> $$$ ) task find minimum number move need order make $$$ a $$$ divisible $$$ b $$$ possible make $$$ 0 $$$ move $$$ a $$$ already divisible $$$ b $$$ answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow line test case contain two integers $$$ a $$$ $$$ b $$$ ( $$$ 1 \le a b \le 1000000000 $$$ ) test case print answer — minimum number move need order make $$$ a $$$ divisible $$$ b $$$,['math'],800.0
1329/B,<unknown> like sequence much create a problem sequence ca n't find <unknown> : give two integers $$$ d m $$$ find number array $$$ a $$$ satisfy follow constraints : since number possible array may large need find answer modulo $$$ m $$$ first line contain integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) denote number test case input next $$$ t $$$ line contain two integers $$$ d m $$$ ( $$$ 1 \leq d m \leq 1000000000 $$$ ) note $$$ m $$$ necessary prime ! test case print number array $$$ a $$$ satisfy give constrain modulo $$$ m $$$,['math'],1700.0
1195/D2,"problem differ previous one <unknown> constraint equal length number $$$ a_1 a_2 \dots a_n $$$ a team sis students go make a trip a submarine target ancient treasure a sink ship lie bottom great rybinsk sea unfortunately students n't know coordinate ship ask meshanya ( a hereditary mage ) help agree help solve problem let 's denote a function alternate digits two number $$$ f ( a_1 a_2 \dots a _ { p - 1 } a_p b_1 b_2 \dots b _ { q - 1 } b_q ) $$$ $$$ a_1 \dots a_p $$$ $$$ b_1 \dots b_q $$$ digits two integers write decimal notation without lead zero word function $$$ f ( x y ) $$$ alternately shuffle digits number $$$ x $$$ $$$ y $$$ write lowest digits older ones start number $$$ y $$$ result function also build right leave ( lower digits older ones ) digits one arguments end remain digits argument write familiarize examples formal definitions function example : $$$ $$$ f ( 1111 2222 ) = 12121212 $$$ $$$ $$$ $$$ f ( 7777 888 ) = 7787878 $$$ $$$ $$$ $$$ f ( 33 44444 ) = 4443434 $$$ $$$ $$$ $$$ f ( 555 6 ) = 5556 $$$ $$$ $$$ $$$ f ( 111 2222 ) = 2121212 $$$ $$$ formally mishanya give array consist $$$ n $$$ integers $$$ a_i $$$ task help students calculate $$$ \sum _ { i = 1 } ^ { n } \sum _ { j = 1 } ^ { n } f ( a_i a_j ) $$$ modulo $$$ 998\,244\,353 $$$ first line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100\,000 $$$ ) — number elements array second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements array print answer modulo $$$ 998\,244\,353 $$$",['math'],1800.0
1335/A,two sisters alice <unknown> $$$ n $$$ candy want distribute $$$ n $$$ candy two sisters a way : task calculate number ways distribute exactly $$$ n $$$ candy sisters a way describe candy indistinguishable formally find number ways represent $$$ n $$$ sum $$$ n = a+b $$$ $$$ a $$$ $$$ b $$$ positive integers $$$ a > b $$$ answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow line a test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 2000000000 $$$ ) — number candy test case print answer — number ways distribute exactly $$$ n $$$ candy two sisters a way describe problem statement way satisfy condition print $$$ 0 $$$ test case example $$$ 3 $$$ possible ways distribute candy :,['math'],800.0
1342/C,give two integers $$$ a $$$ $$$ b $$$ $$$ q $$$ query $$$ i $$$ -th query consist two number $$$ l_i $$$ $$$ r_i $$$ answer number integers $$$ x $$$ $$$ l_i \le x \le r_i $$$ $$$ ( ( x \bmod a ) \bmod b ) \ne ( ( x \bmod b ) \bmod a ) $$$ calculate answer query recall $$$ y \bmod z $$$ remainder division $$$ y $$$ $$$ z $$$ example $$$ 5 \bmod 3 = 2 $$$ $$$ 7 \bmod 8 = 7 $$$ $$$ 9 \bmod 4 = 1 $$$ $$$ 9 \bmod 9 = 0 $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case test case follow first line test case contain three integers $$$ a $$$ $$$ b $$$ $$$ q $$$ ( $$$ 1 \le a b \le 200 $$$ ; $$$ 1 \le q \le 500 $$$ ) $$$ q $$$ line follow contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le 10^ { 18 } $$$ ) correspond query test case print $$$ q $$$ integers — answer query test case order appear,['math'],1600.0
1327/A,give two integers $$$ n $$$ $$$ k $$$ task find $$$ n $$$ represent a sum $$$ k $$$ distinct positive odd ( divisible $$$ 2 $$$ ) integers answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case next $$$ t $$$ line describe test case line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n k \le 10000000 $$$ ) test case print answer — ` ` yes '' ( without quote ) $$$ n $$$ represent a sum $$$ k $$$ distinct positive odd ( divisible $$$ 2 $$$ ) integers ` ` '' otherwise first test case represent $$$ 3 $$$ $$$ 3 $$$ second test case way represent $$$ 4 $$$ $$$ 1 + 3 $$$ third test case represent $$$ 10 $$$ sum three distinct positive odd integers fourth test case represent $$$ 10 $$$ $$$ 3 + 7 $$$ example fifth test case represent $$$ 16 $$$ $$$ 1 + 3 + 5 + 7 $$$ sixth test case represent $$$ 16 $$$ sum five distinct positive odd integers,['math'],1100.0
1296/B,mishka want buy food nearby shop initially $$$ s $$$ burl card mishka perform follow operation number time ( possibly zero ) : choose positive integer number $$$ 1 \le x \le s $$$ buy food cost exactly $$$ x $$$ burl obtain $$$ \lfloor\frac { x } { 10 } \rfloor $$$ burl a cashback ( word mishka spend $$$ x $$$ burl obtain $$$ \lfloor\frac { x } { 10 } \rfloor $$$ back ) operation $$$ \lfloor\frac { a } { b } \rfloor $$$ mean $$$ a $$$ divide $$$ b $$$ round guarantee always buy food cost $$$ x $$$ possible value $$$ x $$$ task say maximum number burl mishka spend buy food optimally example mishka $$$ <unknown> $$$ burl maximum number burl spend $$$ 21 $$$ firstly spend $$$ x=10 $$$ burl obtain $$$ 1 $$$ burle a cashback $$$ <unknown> $$$ burl spend $$$ x=10 $$$ burl obtain $$$ 1 $$$ burle a cashback spend answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case next $$$ t $$$ line describe test case test case give a separate line consist one integer $$$ s $$$ ( $$$ 1 \le s \le 1000000000 $$$ ) — number burl mishka initially test case print answer — maximum number burl mishka spend buy food optimally,['math'],900.0
1374/D,give array $$$ a $$$ consist $$$ n $$$ positive integers initially integer $$$ x = 0 $$$ one move one follow two operations : first operation apply $$$ i $$$ $$$ 1 $$$ $$$ n $$$ task find minimum number move require obtain array element divisible $$$ k $$$ ( value $$$ k $$$ give ) answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 2 \cdot 100000 ; 1 \le k \le 1000000000 $$$ ) — length $$$ a $$$ require <unknown> second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ guarantee sum $$$ n $$$ exceed $$$ 200000 $$$ ( $$$ \sum n \le 200000 $$$ ) test case print answer — minimum number move require obtain array element divisible $$$ k $$$ consider first test case example : note ca n't add $$$ x $$$ element,['math'],1400.0
1389/E,berland year consist $$$ m $$$ months $$$ d $$$ days months number $$$ 1 $$$ $$$ m $$$ berland week consist $$$ w $$$ days first day year also first day week note last week year might shorter $$$ w $$$ days a pair $$$ ( x y ) $$$ $$$ x < y $$$ ambiguous day $$$ x $$$ month $$$ y $$$ day week day $$$ y $$$ month $$$ x $$$ count number ambiguous pair first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number testcases next $$$ t $$$ line contain three integers $$$ m $$$ $$$ d $$$ $$$ w $$$ ( $$$ 1 \le m d w \le 1000000000 $$$ ) — number months a year number days a month number days a week print $$$ t $$$ integers — testcase output number pair $$$ ( x y ) $$$ $$$ x < y $$$ day $$$ x $$$ month $$$ y $$$ day week day $$$ y $$$ month $$$ x $$$ pair first test case :,['math'],2200.0
1458/A,give two positive integer sequence $$$ a_1 \ldots a_n $$$ $$$ b_1 \ldots b_m $$$ $$$ j = 1 \ldots m $$$ find greatest common divisor $$$ a_1 + b_j \ldots a_n + b_j $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 200000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 10^ { 18 } ) $$$ third line contain $$$ m $$$ integers $$$ b_1 \ldots b_m $$$ ( $$$ 1 \leq b_j \leq 10^ { 18 } ) $$$ print $$$ m $$$ integers $$$ j $$$ -th equal gcd $$$ ( a_1 + b_j \ldots a_n + b_j ) $$$,['math'],1600.0
1458/C,give a square matrix size $$$ n $$$ every row every column matrix a permutation $$$ 1 $$$ $$$ 2 $$$ $$$ \ldots $$$ $$$ n $$$ let $$$ a _ { i j } $$$ element intersection $$$ i $$$ -th row $$$ j $$$ -th column every $$$ 1 \leq i j \leq n $$$ row number $$$ 1 \ldots n $$$ top bottom columns number $$$ 1 \ldots n $$$ leave right six type operations : one see sequence operations every row every column matrix still a permutation $$$ 1 2 \ldots n $$$ give initial matrix description process $$$ m $$$ operations output final matrix first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 1000 $$$ ) — number test case $$$ t $$$ test case descriptions follow first line test case description contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n \leq 1000 1 \leq m \leq 100000 $$$ ) — size matrix number operations next $$$ n $$$ line contain $$$ n $$$ integers separate single space — description matrix $$$ a $$$ ( $$$ 1 \leq a _ { i j } \leq n $$$ ) last line description contain a string $$$ m $$$ character describe operations order accord format sum $$$ n $$$ exceed $$$ 1000 $$$ sum $$$ m $$$ exceed $$$ 100000 $$$ test case print $$$ n $$$ line $$$ n $$$ integers — final matrix $$$ m $$$ operations line break sample test case answer clarity n't print,['math'],2700.0
1459/A,$$$ n $$$ card number $$$ 1 \ldots n $$$ card $$$ i $$$ a red digit $$$ r_i $$$ a blue digit $$$ b_i $$$ write arrange $$$ n $$$ card random order leave right permutations $$$ 1 \ldots n $$$ probability read red digits card leave right obtain integer $$$ r $$$ way read blue digits obtain integer $$$ b $$$ read a number lead zero ignore digits a number zero number equal $$$ 0 $$$ illustration a possible rearrangement three card $$$ r $$$ $$$ b $$$ find two players red blue involve a bet red bet shuffle $$$ r > b $$$ blue bet $$$ r < b $$$ end $$$ r = b $$$ bet result a draw neither player win determine two players likely ( higher probability ) win bet chance equal refer note section a formal discussion compare probabilities first line contain a single integer $$$ t $$$ ( $$$ 1 \leq t \leq 100 $$$ ) — number test case descriptions $$$ t $$$ test case follow test case description start a line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 1000 $$$ ) — number card follow line contain a string $$$ n $$$ digits $$$ r_1 \ldots r_n $$$ — red digits card $$$ 1 \ldots n $$$ respectively follow line contain a string $$$ n $$$ digits $$$ b_1 \ldots b_n $$$ — blue digits card $$$ 1 \ldots n $$$ respectively note digits line separate <unknown> print $$$ t $$$ answer test case order one per line red a strictly higher change win print ` ` red '' blue a strictly higher change win print ` ` blue '' players equally likely win print ` ` equal '' note answer case - sensitive formally let $$$ n_r $$$ number permutations card $$$ 1 \ldots n $$$ result number $$$ r $$$ $$$ b $$$ satisfy $$$ r > b $$$ similarly let $$$ n_b $$$ number permutations $$$ r < b $$$ $$$ n_r > n_b $$$ print ` ` red '' $$$ n_r < n_b $$$ print ` ` blue '' $$$ n_r = n_b $$$ print ` ` equal '' first sample case $$$ r = 777 $$$ $$$ b = 111 $$$ regardless card order thus red always win second sample case two card order red win four card order blue win : since $$$ r < b $$$ <unknown> answer ` ` blue '' third sample case $$$ r = b $$$ regardless card order thus bet always a draw red blue zero chance win,['math'],800.0
1462/E1,easy version problem difference easy hard versions constraints $$$ k $$$ $$$ m $$$ ( version $$$ k=2 $$$ $$$ m=3 $$$ ) also version problem n't need output answer modulo give a sequence $$$ a $$$ length $$$ n $$$ consist integers $$$ 1 $$$ $$$ n $$$ sequence may contain duplicate ( i.e elements equal ) find number tuples $$$ m = 3 $$$ elements maximum number tuple differ minimum $$$ k = 2 $$$ formally need find number triple indices $$$ i < j < z $$$ $$$ $$$ \max ( a_i a_j a_z ) - \min ( a_i a_j a_z ) \le 2 $$$ $$$ example $$$ n=4 $$$ $$$ a= [ <unknown> ] $$$ two triple ( $$$ i=1 <unknown> z=4 $$$ $$$ i=2 <unknown> z=4 $$$ ) $$$ n=4 $$$ $$$ a= [ <unknown> ] $$$ four possible triple suitable first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 200000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — length sequence $$$ a $$$ next line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — sequence $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 200000 $$$ output $$$ t $$$ answer give test case answer require number triple elements maximum value triple differ minimum $$$ 2 $$$ note difference hard version problem n't need output answer modulo must output exact value answer,['math'],1500.0
1463/A,play a new computer game fight monsters a dungeon try clear meet three monsters ; first $$$ a $$$ health point second $$$ b $$$ health point third $$$ c $$$ kill monsters use a cannon fire deal $$$ 1 $$$ damage select monster every $$$ 7 $$$ -th ( i. e. shots number $$$ 7 $$$ $$$ 14 $$$ $$$ 21 $$$ etc . ) cannon shoot enhance deal $$$ 1 $$$ damage monsters one monster 's current amount health point $$$ 0 $$$ ca n't target a regular shoot receive damage enhance shoot want pass dungeon <unknown> i. e. kill monsters enhance shoot ( i. e. enhance shoot health point monsters become equal $$$ 0 $$$ first time ) shoot must hit a monster i. e. shoot deal damage least one monster first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case test case consist a single line contain three integers $$$ a $$$ $$$ b $$$ $$$ c $$$ ( $$$ 1 \le a b c \le 100000000 $$$ ) — number health point monster test case print yes kill monsters enhance shoot otherwise print may print letter case ( example yes yes yes yes recognize positive answer ) first test case follow : $$$ 1 $$$ -th shoot first monster $$$ 2 $$$ -th shoot second monster $$$ 3 $$$ -th shoot third monster $$$ 4 $$$ -th shoot first monster $$$ 5 $$$ -th shoot third monster $$$ 6 $$$ -th shoot third monster $$$ 7 $$$ -th enhance shoot kill monsters second test case ca n't kill monsters enhance shoot total number health point monsters $$$ 3 $$$ kill first 3 shots,['math'],1100.0
1470/B,let us call two integers $$$ x $$$ $$$ y $$$ adjacent $$$ \frac { lcm ( x y ) } { gcd ( x y ) } $$$ a perfect square example $$$ 3 $$$ $$$ 12 $$$ adjacent $$$ 6 $$$ $$$ 9 $$$ $$$ gcd ( x y ) $$$ denote greatest common divisor ( gcd ) integers $$$ x $$$ $$$ y $$$ $$$ lcm ( x y ) $$$ denote least common multiple ( lcm ) integers $$$ x $$$ $$$ y $$$ give array $$$ a $$$ length $$$ n $$$ second follow happen : element $$$ a_i $$$ array replace product elements array ( include ) adjacent current value let $$$ d_i $$$ number adjacent elements $$$ a_i $$$ ( include $$$ a_i $$$ ) beauty array define $$$ \max _ { 1 \le i \le n } d_i $$$ give $$$ q $$$ query : query describe integer $$$ w $$$ output beauty array $$$ w $$$ second first input line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100000 ) $$$ — number test case first line test case contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 300000 $$$ ) — length array follow line contain $$$ n $$$ integers $$$ a_1 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) — array elements next line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 300000 $$$ ) — number query follow $$$ q $$$ line contain a single integer $$$ w $$$ ( $$$ 0 \le w \le 10^ { 18 } $$$ ) — query guarantee sum value $$$ n $$$ test case exceed $$$ 300000 $$$ sum value $$$ q $$$ test case exceed $$$ 300000 $$$ query output a single integer — beauty array correspond moment first test case initial array contain elements $$$ [ 6 8 4 2 ] $$$ element $$$ a_4=2 $$$ array adjacent $$$ a_4=2 $$$ ( since $$$ \frac { lcm ( 2 2 ) } { gcd ( 2 2 ) } = \frac { 2 } { 2 } = <unknown> ^ 2 $$$ ) $$$ <unknown> $$$ ( since $$$ \frac { lcm ( <unknown> ) } { gcd ( 8 2 ) } = \frac { 8 } { 2 } = <unknown> ^ 2 $$$ ) hence $$$ <unknown> $$$ maximal possible value $$$ d_i $$$ array second test case initial array contain elements $$$ [ 12 3 20 5 80 1 ] $$$ elements adjacent $$$ 12 $$$ $$$ \ { 12 3\ } $$$ elements adjacent $$$ 3 $$$ $$$ \ { 12 3\ } $$$ elements adjacent $$$ 20 $$$ $$$ \ { 20 5 80\ } $$$ elements adjacent $$$ 5 $$$ $$$ \ { 20 5 80\ } $$$ elements adjacent $$$ 80 $$$ $$$ \ { 20 5 80\ } $$$ elements adjacent $$$ 1 $$$ $$$ \ { 1\ } $$$ one second array transform $$$ [ 36 36 8000 8000 8000 1 ] $$$,['math'],1900.0
1455/A,let 's define a function $$$ f ( x ) $$$ ( $$$ x $$$ a positive integer ) follow : write digits decimal representation $$$ x $$$ backwards get rid lead zero example $$$ f ( 321 ) = 123 $$$ $$$ f ( 120 ) = 21 $$$ $$$ f ( 1000000 ) = 1 $$$ $$$ f ( 111 ) = 111 $$$ let 's define another function $$$ g ( x ) = \dfrac { x } { f ( f ( x ) ) } $$$ ( $$$ x $$$ a positive integer well ) task follow : give positive integer $$$ n $$$ calculate number different value $$$ g ( x ) $$$ among number $$$ x $$$ $$$ 1 \le x \le n $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number test case test case consist one line contain one integer $$$ n $$$ ( $$$ 1 \le n < 10^ { 100 } $$$ ) integer give without lead zero test case print one integer — number different value function $$$ g ( x ) $$$ $$$ x $$$ integer $$$ [ 1 n ] $$$ explanations two first test case example :,['math'],800.0
1341/A,nastya make a huge mistake drop a whole package rice floor mom come soon see nastya <unknown> total nastya drop $$$ n $$$ grain nastya read grain weigh integer number grams $$$ a - b $$$ $$$ a + b $$$ inclusive ( number $$$ a $$$ $$$ b $$$ know ) whole package $$$ n $$$ grain weigh $$$ c - d $$$ $$$ c + d $$$ grams inclusive ( number $$$ c $$$ $$$ d $$$ know ) weight package sum weight $$$ n $$$ grain help nastya understand information correct word check whether grain a mass $$$ i $$$ -th grain weigh integer number $$$ x_i $$$ $$$ ( a - b \leq x_i \leq a + b ) $$$ total weigh $$$ c - d $$$ $$$ c + d $$$ inclusive ( $$$ c - d \leq \sum\limits _ { i=1 } ^ { n } { x_i } \leq c + d $$$ ) input consist multiple test case first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000 ) $$$ — number test case next $$$ t $$$ line contain descriptions test case line contain $$$ 5 $$$ integers : $$$ n $$$ $$$ ( 1 \leq n \leq 1000 ) $$$ — number grain nastya count $$$ a b c d $$$ $$$ ( 0 \leq b < a \leq 1000 0 \leq d < c \leq 1000 ) $$$ — number determine possible weight one grain rice ( $$$ a - b $$$ $$$ a + b $$$ ) possible total weight package ( $$$ c - d $$$ $$$ c + d $$$ ) test case give input print ` ` yes '' information weight inconsistent print ` ` '' $$$ n $$$ grain mass $$$ a - b $$$ $$$ a + b $$$ make a package a total mass $$$ c - d $$$ $$$ c + d $$$ first test case example assume grain weigh $$$ 17 $$$ grams a pack $$$ 119 $$$ grams really nastya could collect whole pack third test case example assume grain weigh $$$ 16 $$$ grams a pack $$$ 128 $$$ grams really nastya could collect whole pack fifth test case example assume $$$ 3 $$$ grain rice weigh $$$ 2 $$$ $$$ 2 $$$ $$$ 3 $$$ grams a pack $$$ 7 $$$ grams really nastya could collect whole pack second fourth test case example prove impossible determine correct weight grain rice weight pack weight pack equal total weight collect grain,['math'],900.0
1299/E,"problem interactive hide a permutation $$$ p_1 p_2 \dots p_n $$$ number $$$ 1 $$$ $$$ n $$$ $$$ n $$$ even try guess use follow query : $$$ ? $$$ $$$ k $$$ $$$ a_1 $$$ $$$ a_2 $$$ $$$ \dots $$$ $$$ a_k $$$ response learn average elements index $$$ a_1 a_2 \dots a_k $$$ integer word receive $$$ 1 $$$ $$$ \frac { p _ { a_1 } + p _ { a_2 } + \dots + p _ { a_k } } { k } $$$ integer $$$ 0 $$$ otherwise guess permutation ask $$$ 18n $$$ query note permutations $$$ [ p_1 p_2 \dots p_k ] $$$ $$$ [ n + 1 - p_1 n + 1 - p_2 \dots n + 1 - p_k ] $$$ indistinguishable therefore guarantee $$$ p_1 \le \frac { n } { 2 } $$$ note permutation $$$ p $$$ fix start interaction n't depend query word interactor adaptive note n't minimize number query first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 800 $$$ $$$ n $$$ even ) begin interaction read $$$ n $$$ ask a question elements position $$$ a_1 a_2 \dots a_k $$$ a separate line output $$$ ? $$$ $$$ k $$$ $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a_k $$$ number query satisfy $$$ 1 \le a_i \le n $$$ $$$ a_i $$$ different n't forget ' flush ' get answer response receive $$$ 1 $$$ $$$ \frac { p _ { a_1 } + p _ { a_2 } + \dots + p _ { a_k } } { k } $$$ integer $$$ 0 $$$ otherwise case query invalid ask $$$ 18n $$$ query program print $$$ -1 $$$ finish interaction receive a wrong answer verdict make sure exit immediately avoid get verdicts determine permutation output $$$ ! $$$ $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_n $$$ print a query forget output end line flush output otherwise get idleness limit exceed , use : hack formatfor hack use follow format : first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 800 $$$ $$$ n $$$ even ) next line output $$$ n $$$ integers $$$ p_1 p_2 \dots p_n $$$ — valid permutation number $$$ 1 $$$ $$$ n $$$ $$$ p_1 \le \frac { n } { 2 } $$$ must hold",['math'],3400.0
1342/E,calculate number ways place $$$ n $$$ rook $$$ n \times n $$$ chessboard follow condition meet : empty cell attack least one rook row least one rook column two rook attack share row column rook example two pair rook attack follow picture : two ways place rook consider different exist least one cell empty one ways contain a rook another way answer might large print modulo $$$ 998244353 $$$ line input contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200000 $$$ ; $$$ 0 \le k \le \frac { n ( n - 1 ) } { 2 } $$$ ) print one integer — number ways place rook take modulo $$$ 998244353 $$$,['math'],2300.0
1473/F,"note memory limit unusual give integer $$$ n $$$ two sequence $$$ a_1 a_2 \dots a_n $$$ $$$ b_1 b_2 \dots b_n $$$ let 's call a set integers $$$ s $$$ $$$ s <unknown> \ { 1 2 3 \dots n\ } $$$ strange , every element $$$ i $$$ $$$ s $$$ follow condition meet : every $$$ j \in [ 1 i - 1 ] $$$ $$$ a_j $$$ divide $$$ a_i $$$ $$$ j $$$ also include $$$ s $$$ empty set always strange cost set $$$ s $$$ $$$ \sum\limits _ { i \in s } b_i $$$ calculate maximum possible cost a strange set first line contain one integer $$$ n $$$ ( $$$ 1 \le n \le 3000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100 $$$ ) third line contain $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ ( $$$ -100000 \le b_i \le 100000 $$$ ) print one integer — maximum cost a strange set strange set maximum cost first example $$$ \ { 1 2 4 8 <unknown> } $$$ strange set maximum cost second example empty",['math'],2700.0
1475/C,school vasya study <unknown> <unknown> graduation ceremony one plan <unknown> a ball attend pair boys girls class must present two couple ball vasya 's class $$$ a $$$ boys $$$ b $$$ girls wish participate boys girls ready dance pair formally know $$$ k $$$ possible one - boy - one - girl pair need choose two pair person one pair example $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ k=4 $$$ couple $$$ ( 1 2 ) $$$ $$$ ( 1 3 ) $$$ $$$ ( 2 2 ) $$$ $$$ ( 3 4 ) $$$ ready dance together ( pair boy 's number come first girl 's number ) follow combinations two pair possible ( possible options list ) : follow combinations possible : find number ways select two pair match condition two ways consider different consist different pair first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain three integers $$$ a $$$ $$$ b $$$ $$$ k $$$ ( $$$ 1 \le a b k \le 200000 $$$ ) — number boys girls class number couple ready dance together second line test case contain $$$ k $$$ integers $$$ a_1 a_2 \ldots a_k $$$ ( $$$ 1 \le a_i \le a $$$ ) $$$ a_i $$$ number boy pair number $$$ i $$$ third line test case contain $$$ k $$$ integers $$$ b_1 b_2 \ldots b_k $$$ ( $$$ 1 \le b_i \le b $$$ ) $$$ b_i $$$ number girl pair number $$$ i $$$ guarantee sum $$$ a $$$ $$$ b $$$ $$$ k $$$ test case exceed $$$ 200000 $$$ guarantee pair specify one test case test case a separate line print one integer — number ways choose two pair match condition first test case follow combinations pair fit : one pair second test case third test case follow combinations pair fit :,['math'],1400.0
1487/B,suppose live two cat : a b. $$$ n $$$ nap spot cat usually sleep cat like sleep also like spot change nap spot hour cyclically : cat b much younger a strict <unknown> : a b n't lie together word cat 'd like go spot $$$ x $$$ a take place b move next place order ( $$$ x < n $$$ $$$ x + 1 $$$ $$$ x = n $$$ $$$ 1 $$$ ) cat b follow order wo n't return skip spot $$$ x $$$ a free move spot $$$ x + 2 $$$ calculate cat b hour $$$ k $$$ ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \le n \le 1000000000 $$$ ; $$$ 1 \le k \le 1000000000 $$$ ) — number spot hour $$$ k $$$ test case print one integer — index spot cat b sleep hour $$$ k $$$ first second test case $$$ n = 2 $$$ : sixth test case :,['math'],1200.0
1488/A,give two positive ( greater zero ) integers $$$ x $$$ $$$ y $$$ a variable $$$ k $$$ initially set $$$ 0 $$$ perform follow two type operations : find minimum number operations describe set value $$$ k $$$ $$$ y $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case test case consist one line contain two integer $$$ x $$$ $$$ y $$$ ( $$$ 1 \le x y \le 1000000000 $$$ ) test case print one integer — minimum number operations set value $$$ k $$$ $$$ y $$$ first test case use follow sequence operations : second test case use follow sequence operations :,['math'],900.0
1475/A,give integer $$$ n $$$ check $$$ n $$$ odd divisor greater one ( exist a number $$$ x $$$ ( $$$ x > 1 $$$ ) $$$ n $$$ divisible $$$ x $$$ $$$ x $$$ odd ) example $$$ n=6 $$$ $$$ x=3 $$$ $$$ n=4 $$$ a number exist first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case $$$ t $$$ test case follow test case contain one integer $$$ n $$$ ( $$$ 2 \le n \le 10^ { 14 } $$$ ) please note input test case wo n't fit $$$ 32 $$$ -bit integer type use least $$$ 64 $$$ -bit integer type program language test case output a separate line : output ` ` yes '' ` ` '' case ( example string yes yes yes yes recognize positive ),['math'],900.0
1385/A,give three positive ( i.e strictly greater zero ) integers $$$ x $$$ $$$ y $$$ $$$ z $$$ task find positive integers $$$ a $$$ $$$ b $$$ $$$ c $$$ $$$ x = \max ( a b ) $$$ $$$ y = \max ( a c ) $$$ $$$ z = \max ( b c ) $$$ determine impossible find $$$ a $$$ $$$ b $$$ $$$ c $$$ answer $$$ t $$$ independent test case print require $$$ a $$$ $$$ b $$$ $$$ c $$$ ( arbitrary ) order first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow line test case contain three integers $$$ x $$$ $$$ y $$$ $$$ z $$$ ( $$$ 1 \le x y z \le 1000000000 $$$ ) test case print answer :,['math'],800.0
1452/A,infinite 2 - dimensional grid robot stand cell $$$ ( 0 0 ) $$$ want reach cell $$$ ( x y ) $$$ a list possible command robot execute : robot want reach cell $$$ ( x y ) $$$ command possible however ca n't execute command two time a row minimum number command require reach $$$ ( x y ) $$$ $$$ ( 0 0 ) $$$ ? first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number testcases next $$$ t $$$ line contain two integers $$$ x $$$ $$$ y $$$ ( $$$ 0 \le x y \le 10000 $$$ ) — destination coordinate robot testcase print a single integer — minimum number command require robot reach $$$ ( x y ) $$$ $$$ ( 0 0 ) $$$ command allow execute two time a row explanations example test : use character n e s w 0 denote go north go east go south go west stay current cell respectively first test case robot use follow sequence : <unknown> second test case robot use follow sequence : <unknown> third test case robot use follow sequence : <unknown> fourth test case robot n't need go anywhere fifth test case robot use follow sequence : <unknown>,['math'],800.0
1444/B,give array $$$ a $$$ length $$$ 2n $$$ consider a partition array $$$ a $$$ two subsequences $$$ p $$$ $$$ q $$$ length $$$ n $$$ ( element array $$$ a $$$ exactly one subsequence : either $$$ p $$$ $$$ q $$$ ) let 's sort $$$ p $$$ non - decreasing order $$$ q $$$ non - increasing order denote sort versions $$$ x $$$ $$$ y $$$ respectively cost a partition define $$$ f ( p q ) = \sum _ { i = 1 } ^n |x_i - <unknown> $$$ find sum $$$ f ( p q ) $$$ correct partition array $$$ a $$$ since answer might big print remainder modulo $$$ 998244353 $$$ first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq <unknown> $$$ ) second line contain $$$ 2n $$$ integers $$$ a_1 a_2 \ldots a _ { 2n } $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) — elements array $$$ a $$$ print one integer — answer problem modulo $$$ 998244353 $$$ two partition array consider different set indices elements include subsequence $$$ p $$$ different first example two correct partition array $$$ a $$$ : second example six valid partition array $$$ a $$$ :,['math'],1900.0
1392/I,kevin bigman 's house suddenly a trap send onto a grid $$$ n $$$ row $$$ m $$$ columns bigman 's trap configure two array : array $$$ a_1 a_2 \ldots a_n $$$ array $$$ b_1 b_2 \ldots b_m $$$ $$$ i $$$ -th row a heater heat row $$$ a_i $$$ degrees $$$ j $$$ -th column a heater heat column $$$ b_j $$$ degrees temperature cell $$$ ( i j ) $$$ $$$ <unknown> $$$ fortunately kevin a suit one parameter $$$ x $$$ two modes : kevin land a cell suit automatically turn cold resistance mode cell temperature less $$$ x $$$ heat resistance mode otherwise change say two cells adjacent share edge let a path a sequence $$$ c_1 c_2 \ldots c_k $$$ cells $$$ c_i $$$ $$$ c _ { i+1 } $$$ adjacent $$$ 1 \leq i \leq k-1 $$$ say two cells connect a path two cells consist cells kevin step a connect component a maximal set pairwise connect cells say a connect component good kevin escape grid start — contain least one border cell grid 's bad otherwise evaluate situation kevin give a score $$$ 1 $$$ good component a score $$$ 2 $$$ bad component final score difference total score components temperatures bigger equal $$$ x $$$ score components temperatures smaller $$$ x $$$ $$$ q $$$ possible value $$$ x $$$ kevin use kevin want know final score help kevin defeat bigman ! first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \leq n m q \leq 100000 $$$ ) – number row columns number possible value $$$ x $$$ respectively second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \leq a_i \leq 100000 $$$ ) third line contain $$$ m $$$ integers $$$ b_1 b_2 \dots b_m $$$ ( $$$ 1 \leq b_i \leq 100000 $$$ ) next $$$ q $$$ line contain one integer $$$ x $$$ ( $$$ 1 \leq x \leq 200000 $$$ ) output $$$ q $$$ line $$$ i $$$ -th line output answer $$$ i $$$ -th possible value $$$ x $$$ input first example score components temperature smaller $$$ 5 $$$ $$$ 1 + 2 $$$ score components temperature least $$$ 5 $$$ $$$ 2 $$$ thus final score $$$ 2 - <unknown> $$$,['math'],3300.0
1398/G,a run competition go hold soon stadium competition hold represent several segment coordinate plane : example a picture stadium $$$ x = 10 $$$ $$$ y = 5 $$$ $$$ n = 3 $$$ $$$ a = [ 0 3 5 10 ] $$$ : a lap a route go along segment start finish point never intersect ( two point a lap coincide start point end point ) length a lap a total distance travel around example red route picture represent stadium a lap length $$$ 24 $$$ competition hold $$$ q $$$ stag $$$ i $$$ -th stage length $$$ l_i $$$ organizers want choose a lap stage length lap a divisor $$$ l_i $$$ organizers n't want choose short lap stag stage want find maximum possible length a suitable lap help organizers calculate maximum possible lengths lap stag ! word every $$$ l_i $$$ find maximum possible integer $$$ l $$$ $$$ l_i \bmod l = 0 $$$ exist a lap length exactly $$$ l $$$ impossible choose a lap print $$$ -1 $$$ first line contain three integers $$$ n $$$ $$$ x $$$ $$$ y $$$ ( $$$ 1 \le n x y \le 200000 $$$ $$$ n \le x $$$ ) second line contain $$$ n + 1 $$$ integers $$$ a_0 $$$ $$$ a_1 $$$ ... $$$ a_n $$$ ( $$$ 0 = a_0 < a_1 < a_2 < \dots < a _ { n - 1 } < a_n = x $$$ ) third line contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number stag fourth line contain $$$ q $$$ even integers $$$ l_1 $$$ $$$ l_2 $$$ ... $$$ <unknown> $$$ ( $$$ 4 \le l_i \le 1000000 $$$ ) — lengths stag print $$$ q $$$ number $$$ i $$$ -th number equal maximum possible length a suitable lap $$$ i $$$ -th stage $$$ -1 $$$ impossible choose a lap stage,['math'],2600.0
1406/E,interactive problem unknown integer $$$ x $$$ ( $$$ 1\le x\le n $$$ ) want find $$$ x $$$ first a set integers $$$ \ { 1 2 \ldots n\ } $$$ perform follow operations $$$ 10000 $$$ time : remember operation type b $$$ a > 1 $$$ must hold write a program find value $$$ x $$$ first line contain one integer $$$ n $$$ ( $$$ 1\le n\le 100000 $$$ ) remain part input give throughout interaction process round program need print a line contain one uppercase letter a b c integer $$$ a $$$ ( $$$ 1\le a\le n $$$ operations a c $$$ 2\le a\le n $$$ operation b ) line <unknown> operation make operation type c program terminate immediately else program read one line contain a single integer answer operation output line n't forget flush output use : guarantee number $$$ x $$$ fix wo n't change interaction process hack : make a hack use input format : line contain two integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \leq x \leq n \leq 100000 $$$ ) note make sample clear add extra empty line n't print extra empty line interaction process first test $$$ n=10 $$$ $$$ x=4 $$$ initially set : $$$ \ { <unknown> } $$$ first operation ask many number multiples $$$ 4 $$$ delete answer $$$ 2 $$$ two number divisible $$$ 4 $$$ : $$$ \ { <unknown> } $$$ $$$ 8 $$$ delete $$$ 4 $$$ wo n't number $$$ x $$$ never delete set $$$ \ { <unknown> } $$$ second operation ask many number multiples $$$ 2 $$$ answer $$$ 4 $$$ four number divisible $$$ 2 $$$ : $$$ \ { <unknown> } $$$ third operation ask many number multiples $$$ 8 $$$ answer $$$ 0 $$$ n't number divisible $$$ 8 $$$ current set fourth operation know $$$ x=4 $$$ right answer,['math'],2600.0
1411/G,"let 's consider follow game alice bob a direct acyclic graph vertex may contain arbitrary number chip alice bob make turn alternate alice go first one turn player move exactly one chip along edge outgo vertex contain chip end edge one make a turn lose players play optimally consider follow process take place every second a give graph $$$ n $$$ vertices : find probability alice win game show answer represent $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ coprime integers $$$ q \not\equiv 0 \pmod { 998\,244\,353 } $$$ print value $$$ p \cdot q^ { -1 } \bmod 998\,244\,353 $$$ first line contain two integers $$$ n $$$ $$$ m $$$ — number vertices edge graph ( $$$ 1 \leq n \leq 100000 $$$ $$$ 0 \leq m \leq 100000 $$$ ) follow $$$ m $$$ line contain edge description $$$ i $$$ -th contain two integers $$$ u_i $$$ $$$ v_i $$$ — begin end vertices $$$ i $$$ -th edge ( $$$ 1 \leq u_i v_i \leq n $$$ ) 's guarantee graph acyclic output a single integer — probability alice victory modulo $$$ 998\,244\,353 $$$",['math'],2700.0
1418/A,play a popular game call <unknown> initially one stick want craft $$$ k $$$ torch one torch craft use one stick one coal hopefully ' ve meet a <unknown> wander <unknown> two trade offer : one trade use one two trade offer use trade offer number time want order task find minimum number trade need craft least $$$ k $$$ torch answer always exist give constraints answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 20000 $$$ ) — number test case $$$ t $$$ test case follow line test case contain three integers $$$ x $$$ $$$ y $$$ $$$ k $$$ ( $$$ 2 \le x \le 1000000000 $$$ ; $$$ 1 \le y k \le 1000000000 $$$ ) — number stick buy one stick number stick require buy one coal number torch need respectively test case print answer : minimum number trade need craft least $$$ k $$$ torch answer always exist give constraints,['math'],1000.0
1420/A,oh 's funny ? oh 's funny ? ' ve <unknown> hours n't solve either i n't know 're <unknown> ' ve get one hour ! solve ! wheatley decide try make a test chamber make a nice test chamber one detail absent — cub complete chamber wheatley need $$$ n $$$ cub $$$ i $$$ -th cube a volume $$$ a_i $$$ wheatley place cub a way would sort a non - decreasing order volume formally $$$ i > 1 $$$ $$$ a _ { i-1 } \le a_i $$$ must hold achieve goal wheatley exchange two neighbour cub mean $$$ i > 1 $$$ exchange cub position $$$ i-1 $$$ $$$ i $$$ a problem : wheatley impatient wheatley need $$$ \frac { n \cdot ( n-1 ) } { 2 } -1 $$$ exchange operations wo n't bore work <unknown> want know : cub sort condition ? test contain multiple test case first line contain one positive integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) denote number test case description test case follow first line test case contain one positive integer $$$ n $$$ ( $$$ 2 \le n \le 50000 $$$ ) — number cub second line contain $$$ n $$$ positive integers $$$ a_i $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — volumes cub guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ test case print a word a single line : ` ` yes '' ( without quotation mark ) cub sort ` ` '' ( without quotation mark ) otherwise first test case possible sort cub $$$ 7 $$$ exchange second test case cub already sort third test case make $$$ 0 $$$ exchange cub sort yet answer ` ` '',['math'],900.0
1200/C,"amugae a large round corridor corridor consist two areas inner area equally divide $$$ n $$$ sectors outer area equally divide $$$ m $$$ sectors a wall exist pair sectors area ( inner outer ) wall inner area outer area a wall always exist 12 <unknown> position inner area 's sectors denote $$$ ( 1,1 ) ( 1,2 ) \dots ( 1 n ) $$$ clockwise direction outer area 's sectors denote $$$ ( 2,1 ) ( 2,2 ) \dots ( 2 m ) $$$ manner a clear understand see example image amugae want know move one sector another sector $$$ q $$$ question question check move two give sectors first line contain three integers $$$ n $$$ $$$ m $$$ $$$ q $$$ ( $$$ 1 \le n m \le 10^ { 18 } $$$ $$$ 1 \le q \le 10000 $$$ ) — number sectors inner area number sectors outer area number question next $$$ q $$$ line contain four integers $$$ s_x $$$ $$$ s_y $$$ $$$ e_x $$$ $$$ e_y $$$ ( $$$ 1 \le s_x e_x \le 2 $$$ ; $$$ s_x = 1 $$$ $$$ 1 \le s_y \le n $$$ otherwise $$$ 1 \le s_y \le m $$$ ; constraints $$$ e_y $$$ similar ) <unknown> want know possible move sector $$$ ( s_x s_y ) $$$ sector $$$ ( e_x e_y ) $$$ question print ` ` yes '' amugae move $$$ ( s_x s_y ) $$$ $$$ ( e_x e_y ) $$$ ` ` '' otherwise print letter case ( upper lower ) example show picture statement",['math'],1400.0
1450/H1,difference two versions problem update easy version $$$ n $$$ spool thread place rim a circular table spool come two type thread : first thread black second thread white two spool color attach a thread color a straight line segment define a match a way attach spool together spool attach exactly one spool color assignment color ( white black ) spool a color call valid least one match number black spool number white spool even give a match find number time white thread intersect black thread compute number pair differently color thread intersect instead number intersection point one intersection point may count multiple time different pair thread intersect point $$$ c $$$ a valid color let $$$ f ( c ) $$$ denote minimum number intersections possible match give a string $$$ s $$$ represent unfinished color black white uncolored spool a color $$$ c $$$ call $$$ s $$$ -reachable achieve assign color uncolored spool $$$ s $$$ without change others a color $$$ c $$$ choose uniformly random among valid $$$ s $$$ -reachable color compute expect value $$$ f ( c ) $$$ find modulo $$$ 998244353 $$$ show answer write form $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ relatively prime integers $$$ q\not\equiv <unknown> { 998244353 } $$$ answer modulo $$$ 998244353 $$$ equal $$$ ( p\cdot q^ { -1 } ) $$$ modulo $$$ 998244353 $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2\le n\le 2\cdot 100000 $$$ $$$ n $$$ even $$$ <unknown> $$$ ) — number spool update respectively update easy version always $$$ 0 $$$ second line contain a string $$$ s $$$ length $$$ n $$$ — unfinished color spool $$$ i $$$ -th character ' w ' ' b ' ' ? ' describe $$$ i $$$ -th spool white black uncolored respectively guarantee exist least one uncolored spool print expect value $$$ f ( c ) $$$ modulo $$$ 998244353 $$$ first test correspond <unknown> image color ' ? ' ' w ' create a valid color number black spool odd reachable valid color ' bwbbbwww ' $$$ f ( \text { bwbbbwww } ) = 1 $$$ expect value $$$ 1 $$$ show expect value second test $$$ \frac { 9 } { 16 } $$$,['math'],2900.0
1425/C,mr . chanek national chess tournament get a huge chessboard size $$$ n \times m $$$ bore play <unknown> chess mr . chanek define a function $$$ f ( x y ) $$$ denote minimum number move move a knight square $$$ ( 1 1 ) $$$ square $$$ ( x y ) $$$ turn find $$$ f ( x y ) $$$ simple mr . chanek define : $$$ g ( x y ) = \sum _ { i = x } ^ { n } \sum _ { j = y } ^ { m } f ( i j ) $$$ give x y task find $$$ g ( x y ) $$$ a knight move square $$$ ( a b ) $$$ square $$$ ( a ' b ' ) $$$ $$$ |a - a'| > 0 $$$ $$$ |b - b'| > 0 $$$ $$$ |a - a'| + |b - b'| = 3 $$$ course knight leave chessboard first line contain integer $$$ t $$$ $$$ ( 1 \le t \le 100 ) $$$ number test case test case contain a line four integers $$$ x $$$ $$$ y $$$ $$$ n $$$ $$$ m $$$ $$$ ( 3 \leq x \leq n \leq 1000000000 3 \leq y \leq m \leq 1000000000 ) $$$ test case print a line value $$$ g ( x y ) $$$ modulo $$$ 1000000000 + 7 $$$,['math'],3100.0
1427/A,"give array $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ create array $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ : example $$$ a= [ 1 <unknown> ] $$$ $$$ b= [ <unknown> ] $$$ $$$ b= [ <unknown> <unknown> ] $$$ rearrangements $$$ a $$$ $$$ b= [ 1 -1 <unknown> ] $$$ $$$ b= [ 1,0,2 -3 ] $$$ rearrangements $$$ a $$$ array $$$ b_1 b_2 \dots b_n $$$ require properties exist print test contain multiple test case first line contain integer $$$ t $$$ ( $$$ 1\le t \le 1000 $$$ ) — number test case description test case follow first line testcase contain one integer $$$ n $$$ ( $$$ 1\le n\le 50 $$$ ) — length array $$$ a $$$ second line testcase contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ <unknown> a_i\le 50 $$$ ) — elements $$$ a $$$ testcase array $$$ b_1 b_2 \dots b_n $$$ require properties print a single line word otherwise print a line word yes follow a line $$$ n $$$ integers $$$ b_1 b_2 \dots b_n $$$ one array $$$ b_1 b_2 \dots b_n $$$ satisfy require properties print explanation first testcase : array desire properties $$$ b= [ 1 <unknown> -4 ] $$$ array hold : explanation second testcase : since value $$$ a $$$ $$$ 0 $$$ rearrangement $$$ b $$$ $$$ a $$$ elements equal $$$ 0 $$$ therefore clearly satisfy second property describe statement ( example $$$ <unknown> $$$ ) hence case answer explanation third testcase : array desire properties $$$ b= [ 1 1 -1 1 -1 ] $$$ array hold : explanation fourth testcase : array desire properties $$$ b= [ <unknown> -9 <unknown> ] $$$ array hold :",['math'],900.0
1428/A,"wabbit try move a box contain food rest zoo coordinate plane point $$$ ( x_1 y_1 ) $$$ point $$$ ( x_2 y_2 ) $$$ a rope use pull box pull box stand exactly $$$ 1 $$$ unit away box direction one two coordinate ax pull box stand move way direction $$$ 1 $$$ unit example box point $$$ ( 1,2 ) $$$ wabbit stand point $$$ ( 2,2 ) $$$ pull box right $$$ 1 $$$ unit box end point $$$ ( 2,2 ) $$$ wabbit end point $$$ ( 3,2 ) $$$ also wabbit move $$$ 1 $$$ unit right leave , without pull box case necessary exactly $$$ 1 $$$ unit away box want pull box must return a point next box also wabbit ca n't move point box locate wabbit start point take $$$ 1 $$$ second travel $$$ 1 $$$ unit right leave , regardless whether pull box move determine minimum amount time need move box $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ note point wabbit end matter test contain multiple test case first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000 ) $$$ : number test case description test case follow next $$$ t $$$ line contain four space - separated integers $$$ x_1 y_1 x_2 y_2 $$$ $$$ ( 1 \leq x_1 y_1 x_2 y_2 \leq 1000000000 ) $$$ describe next test case test case print a single integer : minimum time second wabbit need bring box $$$ ( x_1 y_1 ) $$$ $$$ ( x_2 y_2 ) $$$ first test case start end point box $$$ ( 1,2 ) $$$ $$$ ( 2,2 ) $$$ respectively picture statement wabbit need $$$ 1 $$$ second move show picture statement second test case wabbit start point $$$ ( 2,1 ) $$$ pull box $$$ ( 2,1 ) $$$ move $$$ ( 3,1 ) $$$ move $$$ ( 3,2 ) $$$ $$$ ( 2,2 ) $$$ without pull box , pull box $$$ ( 2,2 ) $$$ move $$$ ( 2,3 ) $$$ take $$$ 4 $$$ second",['math'],800.0
1433/E,one day $$$ n $$$ people ( $$$ n $$$ even number ) meet a <unknown> make two round dance round dance consist exactly $$$ \frac { n } { 2 } $$$ people task find number ways $$$ n $$$ people make two round dance round dance consist exactly $$$ \frac { n } { 2 } $$$ people person belong exactly one two round dance round dance a dance circle consist $$$ 1 $$$ people two round dance indistinguishable ( equal ) one transform another choose first participant example round dance $$$ [ 1 3 4 2 ] $$$ $$$ [ 4 2 1 3 ] $$$ $$$ [ 2 1 3 4 ] $$$ indistinguishable example $$$ <unknown> $$$ number ways $$$ 1 $$$ : one round dance consist first person second one second person example $$$ n=4 $$$ number ways $$$ 3 $$$ possible options : task find number ways $$$ n $$$ people make two round dance round dance consist exactly $$$ \frac { n } { 2 } $$$ people input contain one integer $$$ n $$$ ( $$$ 2 \le n \le 20 $$$ ) $$$ n $$$ even number print one integer — number ways make two round dance guarantee answer fit $$$ 64 $$$ -bit integer data type,['math'],1300.0
1436/A,a give array $$$ a $$$ consist $$$ n $$$ integers a give integer $$$ m $$$ find possible reorder elements array $$$ a $$$ a way $$$ \sum _ { i=1 } ^ { n } { \sum _ { j = i } ^ { n } { \frac { a_j } { j } } } $$$ equal $$$ m $$$ ? forbid delete elements well insert new elements please note round occur division example $$$ \frac { 5 } { 2 } = 2.5 $$$ first line contain a single integer $$$ t $$$ — number test case ( $$$ 1 \le t \le 100 $$$ ) test case follow two line first line a test case contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n \le 100 $$$ $$$ 0 \le m \le 1000000 $$$ ) second line contain integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \le a_i \le 1000000 $$$ ) — elements array test case print ` ` yes '' possible reorder elements array a way give formula give give value ` ` '' otherwise first test case one reorder could $$$ [ 1 2 5 ] $$$ sum equal $$$ ( \frac { 1 } { 1 } + \frac { 2 } { 2 } + \frac { 5 } { 3 } ) + ( \frac { 2 } { 2 } + \frac { 5 } { 3 } ) + ( \frac { 5 } { 3 } ) = 8 $$$ bracket denote inner sum $$$ \sum _ { j = i } ^ { n } { \frac { a_j } { j } } $$$ <unknown> bracket correspond sum $$$ i $$$,['math'],800.0
1436/F,"give a multiset $$$ s $$$ pair subsets $$$ a $$$ $$$ b $$$ : find sum $$$ \sum _ { x \in a } { x } \cdot \sum _ { x \in b } { x } $$$ modulo $$$ 998\,244\,353 $$$ first line contain one integer $$$ m $$$ ( $$$ 1 \le m \le 100000 $$$ ) : number different value multiset $$$ s $$$ next $$$ m $$$ line contain two integers $$$ a_i $$$ $$$ freq_i $$$ ( $$$ 1 \le a_i \le 100000 1 \le freq_i \le 1000000000 $$$ ) element $$$ a_i $$$ appear multiset $$$ s $$$ $$$ freq_i $$$ time $$$ a_i $$$ different print require sum modulo $$$ 998\,244\,353 $$$ a multiset a set elements allow coincide $$$ |x| $$$ <unknown> a set $$$ x $$$ number elements $$$ a <unknown> b $$$ : set $$$ a $$$ a subset a set $$$ b $$$ first example $$$ b=\ { 1\ } a=\ { 1,2\ } $$$ $$$ b=\ { 2\ } a=\ { 1 2\ } $$$ a product equal $$$ <unknown> + <unknown> $$$ pair $$$ a $$$ $$$ b $$$ n't satisfy give constraints",['math'],2800.0
1423/K,number world two different number friends a lot common also one unique <unknown> precisely two different number $$$ a $$$ $$$ b $$$ friends $$$ gcd ( a b ) $$$ $$$ \frac { a } { gcd ( a b ) } $$$ $$$ \frac { b } { gcd ( a b ) } $$$ form side a triangle three number $$$ a $$$ $$$ b $$$ $$$ c $$$ form side a triangle $$$ a + b > c $$$ $$$ b + c > a $$$ $$$ c + a > b $$$ a group number a number lonely n't friends group give a group number contain number $$$ 1 2 3 ... n $$$ many number group lonely ? first line contain a single integer $$$ t $$$ $$$ ( 1 \leq t \leq 1000000 ) $$$ - number test case next line $$$ t $$$ number $$$ n_i $$$ $$$ ( 1 \leq n_i \leq 1000000 ) $$$ - mean case $$$ i $$$ solve number $$$ 1 2 3 ... n_i $$$ test case print answer separate line : number lonely number group $$$ 1 2 3 ... n_i $$$ first test case $$$ 1 $$$ number therefore lonely second test case $$$ n=5 $$$ number $$$ 1 $$$ $$$ 3 $$$ $$$ 5 $$$ lonely third test case $$$ n=10 $$$ number $$$ 1 $$$ $$$ 5 $$$ $$$ 7 $$$ lonely,['math'],1600.0
1296/A,give array $$$ a $$$ consist $$$ n $$$ integers one move choose two indices $$$ 1 \le i j \le n $$$ $$$ i \ne j $$$ set $$$ a_i : = a_j $$$ perform move number time ( possibly zero ) choose different indices different operations operation : = operation assignment ( i.e choose $$$ i $$$ $$$ j $$$ replace $$$ a_i $$$ $$$ a_j $$$ ) task say possible obtain array odd ( divisible $$$ 2 $$$ ) sum elements answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 2000 $$$ ) — number test case next $$$ 2 t $$$ line describe test case first line test case contain one integer $$$ n $$$ ( $$$ 1 \le n \le 2000 $$$ ) — number elements $$$ a $$$ second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 2000 $$$ ) $$$ a_i $$$ $$$ i $$$ -th element $$$ a $$$ guarantee sum $$$ n $$$ test case exceed $$$ 2000 $$$ ( $$$ \sum n \le 2000 $$$ ) test case print answer — ` ` yes '' ( without quote ) possible obtain array odd sum elements ` ` '' otherwise,['math'],800.0
1295/D,give two integers $$$ a $$$ $$$ m $$$ calculate number integers $$$ x $$$ $$$ 0 \le x < m $$$ $$$ \gcd ( a m ) = \gcd ( a + x m ) $$$ note : $$$ \gcd ( a b ) $$$ greatest common divisor $$$ a $$$ $$$ b $$$ first line contain single integer $$$ t $$$ ( $$$ 1 \le t \le 50 $$$ ) — number test case next $$$ t $$$ line contain test case — one per line line contain two integers $$$ a $$$ $$$ m $$$ ( $$$ 1 \le a < m \le 10^ { 10 } $$$ ) print $$$ t $$$ integers — one per test case test case print number appropriate $$$ x $$$ -s . first test case appropriate $$$ x $$$ -s $$$ [ 0 1 3 4 6 7 ] $$$ second test case appropriate $$$ x $$$ $$$ 0 $$$,['math'],1800.0
1294/A,polycarp three sisters : alice barbara cerene 're collect coin currently alice $$$ a $$$ coin barbara $$$ b $$$ coin cerene $$$ c $$$ coin recently polycarp return trip around world bring $$$ n $$$ coin want distribute $$$ n $$$ coin sisters a way number coin alice equal number coin barbara equal number coin cerene word polycarp give $$$ a $$$ coin alice $$$ b $$$ coin barbara $$$ c $$$ coin cerene ( $$$ a+b+c = n $$$ ) $$$ a + a = b + b = c + c $$$ note a b c ( number coin polycarp give alice barbara cerene correspondingly ) 0 . task find possible distribute $$$ n $$$ coin sisters a way describe answer $$$ t $$$ independent test case first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 10000 $$$ ) — number test case next $$$ t $$$ line describe test case test case give a new line consist four space - separated integers $$$ a b c $$$ $$$ n $$$ ( $$$ 1 \le a b c n \le 100000000 $$$ ) — number coin alice number coin barbara number coin cerene number coin polycarp test case print ` ` yes '' polycarp distribute $$$ n $$$ coin sisters ` ` '' otherwise,['math'],800.0
1477/F,"nezzar buy favorite snack — $$$ n $$$ chocolate bar lengths $$$ l_1 l_2 \ldots l_n $$$ however chocolate bar might long store properly ! order solve problem nezzar design interest process divide small piece firstly nezzar put chocolate bar a black box , perform follow operation repeatedly maximum length chocolate bar exceed $$$ k $$$ nezzar wonder expect number operations perform divide chocolate bar small piece show answer represent $$$ \frac { p } { q } $$$ $$$ p $$$ $$$ q $$$ coprime integers $$$ q \not \equiv 0 $$$ ( $$$ \bmod 998\,244\,353 $$$ ) print value $$$ p\cdot q^ { -1 } \mod 998\,244\,353 $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 50 1 \le k \le 2000 $$$ ) second line contain $$$ n $$$ integers $$$ l_1 l_2 \ldots l_n $$$ ( $$$ 1 \le l_i $$$ $$$ \sum _ { i=1 } ^ { n } l_i \le 2000 $$$ ) print a single integer — expect number operations nezzar perform divide chocolate bar small piece modulo $$$ 998\,244\,353 $$$",['math'],3500.0
1475/E,masha work advertise agency order <unknown> new brand want <unknown> contract bloggers total masha connections $$$ n $$$ different bloggers blogger number $$$ i $$$ $$$ a_i $$$ followers since masha a limit budget sign a contract $$$ k $$$ different bloggers course masha want <unknown> see many people possible therefore must hire bloggers maximum total number followers help find number ways select $$$ k $$$ bloggers total number followers maximum possible two ways consider different least one blogger first way second way masha believe bloggers different followers ( <unknown> would follow two different bloggers ) example $$$ n=4 $$$ $$$ k=3 $$$ $$$ a= [ 1 3 1 2 ] $$$ masha two ways select $$$ 3 $$$ bloggers maximum total number followers : since answer quite large output modulo $$$ 1000000000 + 7 $$$ first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case $$$ t $$$ test case follow first line test case contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 1000 $$$ ) — number bloggers many sign a contract second line test case contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le n $$$ ) — number followers blogger guarantee sum $$$ n $$$ test case exceed $$$ 1000 $$$ test case a separate line output one integer — number ways select $$$ k $$$ bloggers total number followers maximum possible test case explain statements second test case follow ways valid : third test case follow ways valid :,['math'],1600.0
1420/B,"must block <unknown> a rock i give rock . '' danik <unknown> need rock lever ! obviously easiest way get things ask hermit lizard hermit lizard agree give danik lever get a stone danik need solve follow task give a positive integer $$$ n $$$ array $$$ a $$$ positive integers task calculate number pair $$$ ( i j ) $$$ $$$ i < j $$$ $$$ a_i $$$ $$$ \ & $$$ $$$ a_j \ge a_i \oplus a_j $$$ $$$ \ & $$$ denote bitwise operation $$$ \oplus $$$ denote bitwise xor operation danik solve task solve ? test contain multiple test case first line contain one positive integer $$$ t $$$ ( $$$ 1 \le t \le 10 $$$ ) denote number test case description test case follow first line test case contain one positive integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — length array second line contain $$$ n $$$ positive integers $$$ a_i $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements array guarantee sum $$$ n $$$ test case exceed $$$ 100000 $$$ every test case print one non - negative integer — answer problem first test case one pair : $$$ ( <unknown> ) $$$ : $$$ 4 $$$ $$$ \ & $$$ $$$ 7 = 4 $$$ $$$ 4 \oplus 7 = 3 $$$ second test case pair good third test case two pair : $$$ ( <unknown> ) $$$ $$$ ( 2,3 ) $$$ fourth test case good pair",['math'],1200.0
1204/A,city saint petersburg a day last $$$ 2^ { 100 } $$$ minutes main station saint petersburg a train depart $$$ 1 $$$ minute $$$ 4 $$$ minutes $$$ 16 $$$ minutes ; word train depart time $$$ <unknown> $$$ integer $$$ k \geq 0 $$$ team <unknown> arrive station time $$$ s $$$ try count many train miss ; word number train depart strictly time $$$ s $$$ example $$$ s = 20 $$$ miss train depart $$$ 1 $$$ $$$ 4 $$$ $$$ 16 $$$ one know time help ! note number $$$ s $$$ give a binary representation without lead zero first line contain a single binary number $$$ s $$$ ( $$$ 0 \leq s < 2^ { 100 } $$$ ) without lead zero output a single number — number train depart strictly time $$$ s $$$ first example $$$ <unknown> = 256 _ { 10 } $$$ miss train depart $$$ 1 $$$ $$$ 4 $$$ $$$ 16 $$$ $$$ 64 $$$ second example $$$ <unknown> = 5 _ { 10 } $$$ train depart $$$ 1 $$$ $$$ 4 $$$ third example explain statements,['math'],1000.0
1206/A,give array $$$ a $$$ consist $$$ n $$$ positive integers $$$ a_1 a_2 \dots a_n $$$ array $$$ b $$$ consist $$$ m $$$ positive integers $$$ b_1 b_2 \dots b_m $$$ choose element $$$ a $$$ $$$ a $$$ element $$$ b $$$ $$$ b $$$ $$$ a+b $$$ n't belong $$$ a $$$ n't belong $$$ b $$$ example $$$ a = [ 2 1 7 ] $$$ $$$ b = [ 1 3 4 ] $$$ choose $$$ 1 $$$ $$$ a $$$ $$$ 4 $$$ $$$ b $$$ number $$$ 5 = 1 + 4 $$$ n't belong $$$ a $$$ n't belong $$$ b $$$ however ca n't choose $$$ 2 $$$ $$$ a $$$ $$$ 1 $$$ $$$ b $$$ $$$ 3 = 2 + 1 $$$ belong $$$ b $$$ show a pair exist multiple answer print choose print two number first line contain one integer $$$ n $$$ ( $$$ 1\le n \le 100 $$$ ) — number elements $$$ a $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 200 $$$ ) — elements $$$ a $$$ third line contain one integer $$$ m $$$ ( $$$ 1\le m \le 100 $$$ ) — number elements $$$ b $$$ fourth line contain $$$ m $$$ different integers $$$ b_1 b_2 \dots b_m $$$ ( $$$ 1 \le b_i \le 200 $$$ ) — elements $$$ b $$$ show answer always exist output two number $$$ a $$$ $$$ b $$$ $$$ a $$$ belong $$$ a $$$ $$$ b $$$ belong $$$ b $$$ $$$ a+b $$$ n't belong $$$ a $$$ neither $$$ b $$$ multiple answer print first example choose $$$ 20 $$$ array $$$ [ 20 ] $$$ $$$ 20 $$$ array $$$ [ 10 20 ] $$$ number $$$ 40 = 20 + 20 $$$ n't belong array however possible choose $$$ 10 $$$ second array second example choose $$$ 3 $$$ array $$$ [ 3 2 2 ] $$$ $$$ 1 $$$ array $$$ [ 1 5 7 7 9 ] $$$ number $$$ 4 = 3 + 1 $$$ n't belong array third example choose $$$ 1 $$$ array $$$ [ 1 3 5 7 ] $$$ $$$ 1 $$$ array $$$ [ 7 5 3 1 ] $$$ number $$$ 2 = 1 + 1 $$$ n't belong array,['math'],800.0
1223/G,suppose stick a desert island way save craft a wooden raft go sea fortunately a hand - <unknown> saw a forest nearby moreover ' ve already cut several tree prepare point $$$ n $$$ log $$$ i $$$ -th log length $$$ a_i $$$ wooden raft 'd like build follow structure : $$$ 2 $$$ log length $$$ x $$$ $$$ x $$$ log length $$$ y $$$ raft would area equal $$$ x \cdot y $$$ $$$ x $$$ $$$ y $$$ must integers since 's way measure lengths a desert island $$$ x $$$ $$$ y $$$ must least $$$ 2 $$$ since raft one log <unknown> unstable cut log piece ca n't merge two log one maximum area raft craft ? first line contain integer $$$ n $$$ ( $$$ 1 \le n \le 500000 $$$ ) — number log second line contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 2 \le a_i \le 500000 $$$ ) — correspond lengths log 's guarantee always craft least $$$ 2 \times 2 $$$ raft print integer — maximum area raft craft first example cut log length $$$ 9 $$$ $$$ 5 $$$ part : $$$ 2 + 2 + 2 + 2 + 1 $$$ build $$$ 2 \times 2 $$$ raft use $$$ 2 $$$ log length $$$ x = 2 $$$ $$$ x = 2 $$$ log length $$$ y = 2 $$$ second example cut $$$ a_4 = 18 $$$ two piece $$$ 9 + 9 $$$ $$$ <unknown> = 28 $$$ three piece $$$ 10 + 9 + 9 $$$ make $$$ 10 \times 9 $$$ raft use $$$ 2 $$$ log length $$$ 10 $$$ $$$ 10 $$$ log length $$$ 9 $$$,['math'],3200.0
1208/A,<unknown> recently learn fibonacci number study different algorithms find get bore read come new type number name <unknown> number define follow : give three integers $$$ a $$$ $$$ b $$$ $$$ n $$$ calculate $$$ f ( n ) $$$ answer $$$ t $$$ independent test case input contain one independent test case first line input contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) number test case $$$ t $$$ follow line contain three space - separated integers $$$ a $$$ $$$ b $$$ $$$ n $$$ ( $$$ 0 \le a b n \le 1000000000 $$$ ) respectively test case output $$$ f ( n ) $$$ first example $$$ f ( 2 ) = f ( 0 ) \oplus f ( 1 ) = 3 \oplus 4 = 7 $$$,['math'],900.0
1195/D1,"problem differ next one presence constraint equal length number $$$ a_1 a_2 \dots a_n $$$ actually problem a subtask problem d2 contest solution d2 solve subtask a team sis students go make a trip a submarine target ancient treasure a sink ship lie bottom great rybinsk sea unfortunately students n't know coordinate ship ask meshanya ( a hereditary mage ) help agree help solve problem let 's denote a function alternate digits two number $$$ f ( a_1 a_2 \dots a _ { p - 1 } a_p b_1 b_2 \dots b _ { q - 1 } b_q ) $$$ $$$ a_1 \dots a_p $$$ $$$ b_1 \dots b_q $$$ digits two integers write decimal notation without lead zero word function $$$ f ( x y ) $$$ alternately shuffle digits number $$$ x $$$ $$$ y $$$ write lowest digits older ones start number $$$ y $$$ result function also build right leave ( lower digits older ones ) digits one arguments end remain digits argument write familiarize examples formal definitions function example : $$$ $$$ f ( 1111 2222 ) = 12121212 $$$ $$$ $$$ $$$ f ( 7777 888 ) = 7787878 $$$ $$$ $$$ $$$ f ( 33 44444 ) = 4443434 $$$ $$$ $$$ $$$ f ( 555 6 ) = 5556 $$$ $$$ $$$ $$$ f ( 111 2222 ) = 2121212 $$$ $$$ formally mishanya give array consist $$$ n $$$ integers $$$ a_i $$$ number array equal length ( consist number digits ) task help students calculate $$$ \sum _ { i = 1 } ^ { n } \sum _ { j = 1 } ^ { n } f ( a_i a_j ) $$$ modulo $$$ 998\,244\,353 $$$ first line input contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100\,000 $$$ ) — number elements array second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — elements array number $$$ a_1 a_2 \dots a_n $$$ equal length ( consist number digits ) print answer modulo $$$ 998\,244\,353 $$$",['math'],1500.0
1210/C,"<unknown> like stream competitive program videos <unknown> channel recently reach $$$ 100 $$$ <unknown> <unknown> order celebrate post a video interest problem could n't solve yet help ? 're give a tree — a connect undirected graph consist $$$ n $$$ vertices connect $$$ n - 1 $$$ edge tree root vertex $$$ 1 $$$ a vertex $$$ u $$$ call ancestor $$$ v $$$ lie shortest path root $$$ v $$$ particular a vertex ancestor vertex $$$ v $$$ assign beauty $$$ x_v $$$ — a non - negative integer larger $$$ 10^ { 12 } $$$ allow us define beauty a path let $$$ u $$$ ancestor $$$ v $$$ define beauty $$$ f ( u v ) $$$ greatest common divisor beauties vertices shortest path $$$ u $$$ $$$ v $$$ formally $$$ u = t_1 t_2 t_3 \dots t_k = v $$$ vertices shortest path $$$ u $$$ $$$ v $$$ $$$ f ( u v ) = \gcd ( x _ { t_1 } x _ { t_2 } \dots x _ { t_k } ) $$$ , $$$ \gcd $$$ denote greatest common divisor a set number particular $$$ f ( u u ) = \gcd ( x_u ) = x_u $$$ task find sum $$$ $$$ \sum _ { <unknown> { ancestor } v } f ( u v ) $$$ $$$ result might large please output modulo $$$ 1000000000 + 7 $$$ note $$$ y $$$ $$$ \gcd ( 0 y ) = \gcd ( y 0 ) = y $$$ particular $$$ \gcd ( 0 0 ) = 0 $$$ first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100\,000 $$$ ) — number vertices tree follow line contain $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ 0 \le x_i \le 10^ { 12 } $$$ ) value $$$ x_v $$$ denote beauty vertex $$$ v $$$ follow $$$ n - 1 $$$ line describe edge tree contain two integers $$$ a b $$$ ( $$$ 1 \le a b \le n $$$ $$$ a \neq b $$$ ) — vertices connect a single edge output sum beauties paths $$$ ( u v ) $$$ $$$ u $$$ ancestor $$$ v $$$ sum print modulo $$$ 1000000000 + 7 $$$ follow figure show $$$ 10 $$$ possible paths one endpoint ancestor another endpoint sum beauties paths equal $$$ 42 $$$ :",['math'],2000.0
1211/G,"$$$ n $$$ cities $$$ n-1 $$$ two - way roads treeland road connect a pair different cities city drive move along roads cities number $$$ 1 $$$ $$$ n $$$ yes course recognize undirected tree description exactly one flag city $$$ i $$$ -th city flag color $$$ c_i $$$ color flag different cities may king travel along route $$$ [ u_1 u_2 u_3 \dots u_k ] $$$ mean start city $$$ u_1 $$$ move city $$$ u_2 $$$ ( $$$ u_2 $$$ connect road $$$ u_1 $$$ ) $$$ u_2 $$$ $$$ u_3 $$$ ( $$$ u_3 $$$ connect road $$$ u_2 $$$ ) arrive city $$$ u_k $$$ possible route king visit city word route $$$ [ u_1 u_2 u_3 \dots u_k ] $$$ necessarily consist different cities term graph theory — king move $$$ u_1 $$$ $$$ u_k $$$ along path $$$ [ u_1 u_2 u_3 \dots u_k ] $$$ necessarily simple ( $$$ j $$$ $$$ 1 $$$ $$$ k-1 $$$ city $$$ u_j $$$ $$$ u _ { j+1 } $$$ connect road ) king move one city another city head exchange flag a sign friendship <unknown> reason king want flag color city $$$ i $$$ equal $$$ d_i $$$ $$$ i $$$ $$$ 1 $$$ $$$ n $$$ determine whether king choose route drive along city flag color turn equal desire color $$$ d_i $$$ note king choose ( drive ) exactly one route yes find shortest possible route king initial color flag already match king 's requirements ( i.e $$$ c_i = d_i $$$ $$$ i $$$ ) consider king make a route length $$$ k=0 $$$ first line contain integer $$$ t $$$ ( $$$ 1 \le t \le 100000 $$$ ) — number test case solve follow case case begin a line contain integer $$$ n $$$ ( $$$ 2 \le n \le 2\cdot100000 $$$ ) — number cities treeland follow a line $$$ n $$$ integers $$$ c_1 c_2 \dots c_n $$$ ( $$$ 1 \le c_i \le 1000000 $$$ ) $$$ c_i $$$ denote color flag $$$ i $$$ -th vertex king 's journey follow a line $$$ n $$$ integers $$$ d_1 d_2 \dots d_n $$$ ( $$$ 1 \le d_i \le 1000000 $$$ ) $$$ d_i $$$ denote require flag color $$$ i $$$ -th vertex completion king 's journey , $$$ n-1 $$$ line treeland 's roads list road give a line contain two integers $$$ x_j y_j $$$ ( $$$ 1 \le x_j y_j \le n $$$ ) — number cities connect $$$ j $$$ th road guarantee every city get road ( word system cities roads form undirected tree ) sum $$$ n $$$ value <unknown> case one test exceed $$$ 2\cdot100000 $$$ print answer case order appearance input data answer must begin a line contain ` ` yes '' ( case a positive answer ) ` ` '' ( case require route exist ) case a positive answer follow line must contain integer $$$ k $$$ — number cities shortest possible route king next line contain require route $$$ u_1 u_2 \dots u_k $$$ ( $$$ 1 \le u_i \le n $$$ ) skip line $$$ k=0 $$$",['math'],2500.0
1213/A,give $$$ n $$$ chip a number line $$$ i $$$ -th chip place integer coordinate $$$ x_i $$$ chip equal coordinate perform two follow type move ( possibly zero ) number time chip : note 's allow move chip integer coordinate include negative zero task find minimum total number coin require move $$$ n $$$ chip coordinate ( i.e $$$ x_i $$$ equal sequence move ) first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number chip second line input contain $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ 1 \le x_i \le 1000000000 $$$ ) $$$ x_i $$$ coordinate $$$ i $$$ -th chip print one integer — minimum total number coin require move $$$ n $$$ chip coordinate first example need move first chip $$$ 2 $$$ right second chip $$$ 1 $$$ right move third chip $$$ 2 $$$ leave second chip $$$ 1 $$$ leave answer $$$ 1 $$$ second example need move two chip coordinate $$$ 3 $$$ $$$ 1 $$$ leave answer $$$ 2 $$$,['math'],900.0
1216/D,$$$ n $$$ type swords theater basement use play moreover exactly $$$ x $$$ swords type $$$ y $$$ people break theater basement take exactly $$$ z $$$ swords single type note different people might take different type swords note value $$$ x y $$$ $$$ z $$$ unknown next morning director theater discover loss count swords — exactly $$$ a_i $$$ swords $$$ i $$$ -th type leave untouched director clue initial number swords type basement number people break basement many swords take example $$$ n=3 $$$ $$$ a = [ 3 12 6 ] $$$ one possible situations $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ first three people take swords first type two people take swords third type note n't know value $$$ x y $$$ $$$ z $$$ beforehand know value $$$ n $$$ $$$ a $$$ thus seek help determine minimum number people $$$ y $$$ could break theater basement number swords $$$ z $$$ take first line input contain one integer $$$ n $$$ $$$ ( 2 \le n \le 2 \cdot 10^ { 5 } ) $$$ — number type swords second line input contain sequence $$$ a_1 a_2 \dots a_n $$$ $$$ ( 0 \le a_i \le 10^ { 9 } ) $$$ $$$ a_i $$$ equal number swords $$$ i $$$ -th type remain basement <unknown> guarantee exist least one pair indices $$$ ( j k ) $$$ $$$ a_j \neq a_k $$$ print two integers $$$ y $$$ $$$ z $$$ — minimum number people could break basement number swords take first example minimum value $$$ y $$$ equal $$$ 5 $$$ i.e minimum number people could break basement $$$ 5 $$$ take $$$ 3 $$$ swords : three take $$$ 3 $$$ swords first type two others take $$$ 3 $$$ swords third type second example minimum value $$$ y $$$ $$$ 1 $$$ i.e minimum number people could break basement equal $$$ 1 $$$ take $$$ 7 $$$ swords first type,['math'],1300.0
1216/E2,difference easy hard versions maximum value $$$ k $$$ give infinite sequence form ` ` <unknown> $$$ \dots $$$ ` ` consist block consecutive positive integers write one another first block consist number $$$ 1 $$$ $$$ 1 $$$ second one — $$$ 1 $$$ $$$ 2 $$$ third one — $$$ 1 $$$ $$$ 3 $$$ $$$ \dots $$$ $$$ i $$$ -th block consist number $$$ 1 $$$ $$$ i $$$ first $$$ 56 $$$ elements sequence ` ` <unknown> '' elements sequence number one example $$$ 1 $$$ -st element sequence $$$ 1 $$$ $$$ 3 $$$ -rd element sequence $$$ 2 $$$ $$$ 20 $$$ -th element sequence $$$ 5 $$$ $$$ 38 $$$ -th element $$$ 2 $$$ $$$ 56 $$$ -th element sequence $$$ 0 $$$ task answer $$$ q $$$ independent query $$$ i $$$ -th query give one integer $$$ k_i $$$ calculate digit position $$$ k_i $$$ sequence first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 500 $$$ ) — number query $$$ i $$$ -th follow $$$ q $$$ line contain one integer $$$ k_i $$$ $$$ ( 1 \le k_i \le 10^ { 18 } ) $$$ — description correspond query print $$$ q $$$ line $$$ i $$$ -th line print one digit $$$ x_i $$$ $$$ ( 0 \le x_i \le 9 ) $$$ — answer query $$$ i $$$ i.e $$$ x_i $$$ equal element position $$$ k_i $$$ sequence answer query first example describe problem statement,['math'],2200.0
1217/A,play favourite game yet another time choose character n't play $$$ str $$$ point strength $$$ int $$$ point intelligence also start character $$$ exp $$$ free experience point invest either strength intelligence ( invest one point either raise strength $$$ 1 $$$ raise intelligence $$$ 1 $$$ ) since 'd like make fun want create a <unknown> character strength intelligence point ( result strength strictly greater result intelligence ) calculate number different character build create ( purpose <unknown> ) must invest free point two character build different strength and/or intellect different first line contain single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number query next $$$ t $$$ line contain descriptions query — one per line line contain three integers $$$ str $$$ $$$ int $$$ $$$ exp $$$ ( $$$ 1 \le str int \le 100000000 $$$ $$$ 0 \le exp \le 100000000 $$$ ) — initial strength intelligence character number free point respectively print $$$ t $$$ integers — one per query query print number different character build create first query three appropriate character build : $$$ ( str = 7 int = 5 ) $$$ $$$ ( 8 4 ) $$$ $$$ ( 9 3 ) $$$ build either smart n't use free point second query one possible build : $$$ ( 2 1 ) $$$ third query two appropriate build : $$$ ( 7 6 ) $$$ $$$ ( 8 5 ) $$$ fourth query build much brain,['math'],1300.0
1220/D,"boy dima give julian a birthday present — set $$$ b $$$ consist positive integers however n't know julian hat set enjoy bipartite graph anything else ! julian almost upset friend alex say build undirected graph use set a way : let integer number vertices connect two $$$ i $$$ $$$ j $$$ edge $$$ |i - j| $$$ belong $$$ b $$$ unfortunately julian n't like graph build use $$$ b $$$ alex decide <unknown> situation want erase number $$$ b $$$ graph build use new set bipartite difficulty task graph alex work infinite number vertices edge ! impossible solve task alone alex ask help write a program erase a subset minimum size $$$ b $$$ graph construct new set bipartite recall graph bipartite vertices divide two disjoint set every edge connect a vertex different set first line contain integer $$$ n ~ ( 1 \leqslant n \leqslant 200\,000 ) $$$ — size $$$ b $$$ second line contain $$$ n $$$ integers $$$ b_1 b_2 \ldots b_n ~ ( 1 \leqslant b_i \leqslant 10^ { 18 } ) $$$ — number $$$ b $$$ $$$ b_i $$$ <unknown> first line print single integer $$$ k $$$ – number erase elements second line print $$$ k $$$ integers — value erase elements multiple answer print",['math'],1900.0
1210/E,"wojtek a maths competition byteland ! <unknown> <unknown> — a great book call ' card trick everyone . ' ' great ! ' think ' i finally use old <unknown> deck card 's always lie unused desk ! ' the first <unknown> book ' <unknown> shuffle $$$ k $$$ card order want . ' 's <unknown> a list $$$ n $$$ <unknown> methods shuffle deck $$$ k $$$ card a <unknown> way specifically $$$ i $$$ -th recipe describe a permutation $$$ ( p _ { i,1 } p _ { i,2 } \dots p _ { i k } ) $$$ integers $$$ 1 $$$ $$$ k $$$ enumerate card deck $$$ 1 $$$ $$$ k $$$ top bottom $$$ p _ { i j } $$$ indicate number $$$ j $$$ -th card top deck shuffle day short wojtek want learn trick today pick two integers $$$ l r $$$ ( $$$ 1 \le l \le r \le n $$$ ) memorize trick $$$ l $$$ -th $$$ r $$$ -th inclusive take a sort deck $$$ k $$$ card repeatedly apply random memorize trick get bore still like maths start wonder : many different deck stop shuffle ? wojtek still n't choose integers $$$ l $$$ $$$ r $$$ still curious therefore define $$$ f ( l r ) $$$ number different deck get memorize trick $$$ l $$$ -th $$$ r $$$ -th inclusive value $$$ $$$ \sum _ { <unknown> } ^n \sum _ { r = l } ^n f ( l r ) ? $$$ $$$ first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 200\,000 $$$ $$$ 1 \le k \le 5 $$$ ) — number trick number card wojtek 's deck follow $$$ n $$$ line describe a single trick describe $$$ k $$$ distinct integers $$$ p _ { i,1 } p _ { i,2 } \dots p _ { i k } $$$ ( $$$ 1 \le p _ { i j } \le k $$$ ) output value sum describe statement consider first sample : first third trick allow wojtek generate two distinct deck ( either two card swap ) therefore $$$ f ( 1 1 ) = f ( 3 3 ) = 2 $$$ second trick allow shuffle deck a cyclic order therefore $$$ f ( 2,2 ) =3 $$$ turn two first trick two last trick enough shuffle deck way desire wojtek therefore $$$ f ( 1,2 ) = f ( 2,3 ) = f ( 1,3 ) = 3 ! = 6 $$$",['math'],2700.0
1221/C,may already know a standard icpc team consist exactly three members perfect team however restrictions a student specialization : coder mathematician she / he specialization ca n't time team consider perfect include least one coder least one mathematician consist exactly three members a coach a large university know $$$ c $$$ students coders $$$ m $$$ mathematicians $$$ x $$$ specialization maximum number full perfect team distribute ? note students leave without a team student a part one team also ask answer $$$ q $$$ independent query first line contain a single integer $$$ q $$$ ( $$$ 1 \le q \le 10000 $$$ ) — number query next $$$ q $$$ line contain three integers $$$ c $$$ $$$ m $$$ $$$ x $$$ ( $$$ 0 \le c m x \le 100000000 $$$ ) — number coders mathematicians students without specialization university respectively note student coder mathematician time print $$$ q $$$ integers — $$$ i $$$ -th answer $$$ i $$$ query order give input answer maximum number full perfect team distribute students first example team form :,['math'],1200.0
1187/A,"favorite shop sell $$$ n $$$ kinder surprise chocolate egg know exactly $$$ s $$$ stickers exactly $$$ t $$$ toy place $$$ n $$$ egg total kinder surprise one three type : n't know type a particular kinder surprise egg look identical indistinguishable minimum number kinder surprise egg buy sure whichever type 'll obtain least one sticker least one toy ? note open egg purchase process , buy number egg 's guarantee answer always exist first line contain single integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number query next $$$ t $$$ line contain three integers $$$ n $$$ $$$ s $$$ $$$ t $$$ ( $$$ 1 \le n \le 1000000000 $$$ $$$ 1 \le s t \le n $$$ $$$ s + t \ge n $$$ ) — number egg stickers toy query independent print $$$ t $$$ integers ( one number per query ) — minimum number kinder surprise egg buy sure whichever type 'll obtain least one sticker one <unknown> first query take least $$$ 6 $$$ egg $$$ 5 $$$ egg toy inside worst case 'll buy second query egg a sticker a toy inside 's 's enough buy one egg third query buy egg : one a sticker one a toy",['math'],900.0
1207/E,"interactive problem remember flush output communicate test program may use fflush ( stdout ) c++ system.out.flush ( ) java stdout.flush ( ) python flush ( output ) pascal flush output use program language consult documentation may also refer guide interactive problems : https : //codeforces.com / blog / entry/45307 jury pick integer $$$ x $$$ less $$$ 0 $$$ greater $$$ 2^ { 14 } - 1 $$$ guess integer , may ask $$$ 2 $$$ query query consist $$$ 100 $$$ integer number $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a _ { 100 } $$$ ( integer less $$$ 0 $$$ greater $$$ 2^ { 14 } - 1 $$$ ) response query jury pick one integer $$$ i $$$ ( $$$ 1 \le i \le 100 $$$ ) tell value $$$ a_i \oplus x $$$ ( bitwise xor $$$ a_i $$$ $$$ x $$$ ) additional constraint query : $$$ 200 $$$ integers use query distinct guarantee value $$$ x $$$ fix beforehand test choice $$$ i $$$ every query may depend integers send give answer program print one line $$$ ! $$$ $$$ x $$$ a line break end , flush output terminate gracefully give answer may submit $$$ 2 $$$ query ask a query print one line follow format : $$$ ? $$$ $$$ a_1 $$$ $$$ a_2 $$$ ... $$$ a _ { 100 } $$$ every $$$ a_j $$$ integer range $$$ [ 0 2^ { 14 } - 1 ] $$$ line end a line break character submit a query flush output read answer query — value $$$ a_i \oplus x $$$ $$$ i \in [ 1 100 ] $$$ integer use query submit incorrect query ( ask $$$ 2 $$$ query ) answer one integer $$$ -1 $$$ receive answer program terminate immediately — otherwise may receive verdict ` ` runtime error '' ` ` time limit exceed '' verdict instead ` ` wrong answer '' example interaction correct — <unknown> exactly $$$ 100 $$$ integers query everything else correct hack forbid problem",['math'],1900.0
1194/D,alice bob play a game a paper strip divide n + 1 cells number leave right start 0 . a chip place n - th cell ( last one ) players take turn alice first player turn move chip 1 2 k cells leave ( chip currently cell i player move cell i - 1 i - 2 i - k ) chip leave border paper strip : impossible example move k cells leave current cell number i < k. player ca n't make a move lose game win participants play optimally ? alice bob would like play several game determine winner game first line contain single integer t ( 1 ≤ t ≤ 100 ) — number game next t line contain one game per line game independent next t line contain two integers n k ( 0 ≤ n ≤ 109 3 ≤ k ≤ 109 ) — length strip constant denote third move respectively game print alice alice win game bob otherwise,['math'],1700.0
1141/C,array integers $$$ p_1 p_2 \dots p_n $$$ call a permutation contain number $$$ 1 $$$ $$$ n $$$ exactly example follow array permutations : $$$ [ 3 1 2 ] $$$ $$$ [ 1 ] $$$ $$$ [ 1 2 3 4 5 ] $$$ $$$ [ 4 3 1 2 ] $$$ follow array permutations : $$$ [ 2 ] $$$ $$$ [ 1 1 ] $$$ $$$ [ 2 3 4 ] $$$ polycarp invent a really cool permutation $$$ p_1 p_2 \dots p_n $$$ length $$$ n $$$ disappoint forget permutation remember array $$$ q_1 q_2 \dots q _ { n-1 } $$$ length $$$ n-1 $$$ $$$ q_i = p _ { i+1 } <unknown> $$$ give $$$ n $$$ $$$ q = q_1 q_2 \dots q _ { n-1 } $$$ help polycarp restore invent permutation first line contain integer $$$ n $$$ ( $$$ 2 \le n \le 2\cdot100000 $$$ ) — length permutation restore second line contain $$$ n-1 $$$ integers $$$ q_1 q_2 \dots q _ { n-1 } $$$ ( $$$ <unknown> < q_i < n $$$ ) print integer -1 permutation length $$$ n $$$ correspond give array $$$ q $$$ otherwise exist print $$$ p_1 p_2 \dots p_n $$$ print permutation many,['math'],1500.0
1141/E,a superhero fight a monster battle consist round last exactly $$$ n $$$ minutes a round end next round start immediately repeat round scenario describe a sequence $$$ n $$$ number : $$$ d_1 d_2 \dots d_n $$$ ( $$$ -1000000 \le d_i \le 1000000 $$$ ) $$$ i $$$ -th element mean monster 's hp ( hit point ) change value $$$ d_i $$$ $$$ i $$$ -th minute round formally $$$ i $$$ -th minute a round monster 's hp $$$ h $$$ $$$ i $$$ -th minute change $$$ h : = h + d_i $$$ monster 's initial hp $$$ h $$$ mean battle monster $$$ h $$$ hit point print first minute monster die monster die hp less equal $$$ 0 $$$ print -1 battle continue infinitely first line contain two integers $$$ h $$$ $$$ n $$$ ( $$$ 1 \le h \le 10^ { 12 } $$$ $$$ 1 \le n \le 2\cdot100000 $$$ ) second line contain sequence integers $$$ d_1 d_2 \dots d_n $$$ ( $$$ -1000000 \le d_i \le 1000000 $$$ ) $$$ d_i $$$ value change monster 's hp $$$ i $$$ -th minute a round print -1 superhero ca n't kill monster battle last infinitely otherwise print positive integer $$$ k $$$ $$$ k $$$ first minute monster dead,['math'],1700.0
1154/A,"polycarp guess three positive integers $$$ a $$$ $$$ b $$$ $$$ c $$$ keep number secret write four number a board arbitrary order — pairwise sum ( three number ) sum three number ( one number ) , four number a board random order : $$$ a+b $$$ $$$ a+c $$$ $$$ b+c $$$ $$$ a+b+c $$$ guess three number $$$ a $$$ $$$ b $$$ $$$ c $$$ use give number print three guess integers order pay attention give number $$$ a $$$ $$$ b $$$ $$$ c $$$ equal ( also possible $$$ a = b = c $$$ ) line input contain four positive integers $$$ x_1 x_2 x_3 x_4 $$$ ( $$$ 2 \le x_i \le 1000000000 $$$ ) — number write a board random order guarantee answer exist give number $$$ x_1 x_2 x_3 x_4 $$$ print positive integers $$$ a $$$ $$$ b $$$ $$$ c $$$ four number write a board value $$$ a+b $$$ $$$ a+c $$$ $$$ b+c $$$ $$$ a+b+c $$$ write order print $$$ a $$$ $$$ b $$$ $$$ c $$$ order several answer print guarantee answer exist",['math'],800.0
1155/C,ivan go sleep want set alarm clock many necessary events tomorrow $$$ i $$$ -th start $$$ x_i $$$ -th minute ivan n't want skip events set alarm clock a way ring minutes $$$ x_1 x_2 \dots x_n $$$ <unknown> minutes ( note matter alarm clock ring minute ) ivan choose two properties alarm clock — first minute ring ( let 's denote $$$ y $$$ ) interval two consecutive signal ( let 's denote $$$ p $$$ ) clock set ring minutes $$$ y y + p y + <unknown> y + <unknown> $$$ ivan choose minute first one choose arbitrary value $$$ p $$$ pick among give value $$$ p_1 p_2 \dots p_m $$$ ( phone support options set ) ivan choose first minute $$$ y $$$ alarm clock start ring interval two consecutive signal $$$ p_j $$$ a way ring give minutes $$$ x_1 x_2 \dots x_n $$$ ( matter alarm clock ring minutes ) task tell first minute $$$ y $$$ index $$$ j $$$ ivan set alarm clock properties $$$ y $$$ $$$ p_j $$$ ring give minutes $$$ x_1 x_2 \dots x_n $$$ say impossible choose value give properties multiple answer print first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 2 \le n \le 3 \cdot 100000 1 \le m \le 300000 $$$ ) — number events number possible settings interval signal second line input contain $$$ n $$$ integers $$$ x_1 x_2 \dots x_n $$$ ( $$$ 1 \le x_i \le 10^ { 18 } $$$ ) $$$ x_i $$$ minute $$$ i $$$ -th event start guarantee $$$ x_i $$$ give increase order ( i. e. condition $$$ x_1 < x_2 < \dots < x_n $$$ hold ) third line input contain $$$ m $$$ integers $$$ p_1 p_2 \dots p_m $$$ ( $$$ 1 \le p_j \le 10^ { 18 } $$$ ) $$$ p_j $$$ $$$ j $$$ -th option interval two consecutive signal 's impossible choose value $$$ y $$$ $$$ j $$$ constraints satisfy print ` ` '' first line otherwise print ` ` yes '' first line print two integers $$$ y $$$ ( $$$ 1 \le y \le 10^ { 18 } $$$ ) $$$ j $$$ ( $$$ 1 \le j \le m $$$ ) second line $$$ y $$$ first minute ivan 's alarm clock start ring $$$ j $$$ index option interval two consecutive signal ( options number $$$ 1 $$$ $$$ m $$$ order give input ) value choose a way alarm clock ring give minutes $$$ x_1 x_2 \dots x_n $$$ multiple answer print,['math'],1300.0
1158/E,"interactive problem vasya enjoy solve quiz find a strange device want know work device encrypt tree ( connect undirected graph without cycle ) $$$ n $$$ vertices number integers $$$ 1 $$$ $$$ n $$$ solve quiz guess tree fortunately device make one operation use guess cipher give device array $$$ d_1 d_2 \ldots d_n $$$ non - negative integers device $$$ n $$$ lamps $$$ i $$$ -th connect $$$ i $$$ -th vertex tree $$$ i $$$ light turn $$$ i $$$ -th lamp exist vertex tree number $$$ j \neq i $$$ $$$ dist ( i j ) \leq d_j $$$ let 's define $$$ dist ( i j ) $$$ distance vertices $$$ i $$$ $$$ j $$$ tree number edge simple path vertices $$$ i $$$ $$$ j $$$ vasya want solve quiz use $$$ \leq 80 $$$ operations device guess tree help ! begin program read one integer $$$ n $$$ — number vertices tree encrypt device ( $$$ 2 \leq n \leq 1000 $$$ ) , make several operations follow format operation print a symbol '' ? '' ( without quote ) $$$ n $$$ integers $$$ d_1 d_2 \ldots d_n $$$ separate space please note $$$ i $$$ use number satisfy inequality $$$ 0 \leq d_i < n $$$ , read a string $$$ s $$$ length $$$ n $$$ consist symbols ` ` 0 '' ` ` 1 '' ( without quote ) $$$ i $$$ symbol $$$ s_i $$$ equal ` ` 0 '' lamp device connect $$$ i $$$ -th vertex tree switch ` ` 1 '' otherwise several operations print guess tree print symbol ` ` ! '' ( without quote ) next $$$ n-1 $$$ line print $$$ 2 $$$ integers $$$ a_i $$$ $$$ b_i $$$ — index vertices connect $$$ i $$$ -th edge tree number satisfy condition $$$ 1 \leq a_i b_i \leq n $$$ $$$ a_i \neq b_i $$$ edge form a tree equal hide tree , program terminate guarantee test tree fix wo n't change depend program 's operations program make $$$ 0 $$$ $$$ 80 $$$ operations device guess tree equal hide program make $$$ 80 $$$ operations get verdict continue read close input program make operation print answer incorrect format get verdict careful n't forget flush output print question answer flush output use : hack : first line contain one integer $$$ n $$$ — number vertices tree ( $$$ 2 \leq n \leq 1000 $$$ ) next $$$ n-1 $$$ line contain $$$ 2 $$$ integers $$$ a_i $$$ $$$ b_i $$$ — index vertices connect $$$ i $$$ -th edge tree ( $$$ 1 \leq a_i b_i \leq n $$$ $$$ a_i \neq b_i $$$ ) edge form a tree careful extra space line break allow a picture tree encrypt device first test : a table pairwise distance vertices tree :",['math'],3400.0
1194/A,a list number $$$ 1 $$$ $$$ n $$$ write leave right blackboard perform algorithm consist several step ( step $$$ 1 $$$ -indexed ) $$$ i $$$ -th step wipe $$$ i $$$ -th number ( consider remain number ) wipe whole number ( one digit ) less $$$ i $$$ number remain stop algorithm wonder : value $$$ x $$$ -th remain number algorithm stop ? first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 100 $$$ ) — number query next $$$ t $$$ line contain query — one per line query independent line contain two space - separated integers $$$ n $$$ $$$ x $$$ ( $$$ 1 \le x < n \le 10^ { 9 } $$$ ) — length list position wonder 's guarantee algorithm end list still contain least $$$ x $$$ number print $$$ t $$$ integers ( one per query ) — value $$$ x $$$ -th number perform algorithm correspond query,['math'],800.0
1165/D,guess integer number $$$ x $$$ give a list almost divisors almost mean divisors except $$$ 1 $$$ $$$ x $$$ list task find minimum possible integer $$$ x $$$ guess number say input data contradictory impossible find number answer $$$ t $$$ independent query first line input contain one integer $$$ t $$$ ( $$$ 1 \le t \le 25 $$$ ) — number query $$$ t $$$ query follow first line query contain one integer $$$ n $$$ ( $$$ 1 \le n \le 300 $$$ ) — number divisors list second line query contain $$$ n $$$ integers $$$ d_1 d_2 \dots d_n $$$ ( $$$ 2 \le d_i \le 1000000 $$$ ) $$$ d_i $$$ $$$ i $$$ -th divisor guess number guarantee value $$$ d_i $$$ distinct query print answer input data query contradictory impossible find number $$$ x $$$ give list divisors list almost divisors print -1 . otherwise print minimum possible $$$ x $$$,['math'],1600.0
1176/B,give array $$$ a $$$ consist $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ one operation choose two elements array replace element equal sum ( matter insert new element ) example array $$$ [ 2 1 4 ] $$$ obtain follow array : $$$ [ 3 4 ] $$$ $$$ [ 1 6 ] $$$ $$$ [ 2 5 ] $$$ task find maximum possible number elements divisible $$$ 3 $$$ array perform operation arbitrary ( possibly zero ) number time answer $$$ t $$$ independent query first line contain one integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number query first line query contain one integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) second line query contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) query print one integer a single line — maximum possible number elements divisible $$$ 3 $$$ array perform describe operation arbitrary ( possibly zero ) number time first query example apply follow sequence operations obtain $$$ 3 $$$ elements divisible $$$ 3 $$$ : $$$ [ 3 1 2 3 1 ] \rightarrow [ 3 3 3 1 ] $$$ second query obtain $$$ 3 $$$ elements divisible $$$ 3 $$$ follow sequence operations : $$$ [ 1 1 1 1 1 2 2 ] \rightarrow [ 1 1 1 1 2 3 ] \rightarrow [ 1 1 1 3 3 ] \rightarrow [ 2 1 3 3 ] \rightarrow [ 3 3 3 ] $$$,['math'],1100.0
1183/B,$$$ n $$$ products shop price $$$ i $$$ -th product $$$ a_i $$$ owner shop want equalize price products however want change price smoothly fact owner shop change price product $$$ i $$$ a way difference old price product $$$ a_i $$$ new price $$$ b_i $$$ $$$ k $$$ word condition $$$ |a_i - b_i| \le k $$$ satisfy ( $$$ |x| $$$ absolute value $$$ x $$$ ) change price product note leave old price products new price $$$ b_i $$$ product $$$ i $$$ positive ( i.e $$$ b_i > 0 $$$ satisfy $$$ i $$$ $$$ 1 $$$ $$$ n $$$ ) task find maximum possible equal price $$$ b $$$ <unknown> restriction products <unknown> $$$ |a_i - b| \le k $$$ satisfy ( $$$ a_i $$$ old price product $$$ b $$$ new price products ) report impossible find price $$$ b $$$ note choose price $$$ b $$$ integer answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 100 $$$ ) — number query query present two line first line query contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le n \le 100 1 \le k \le 100000000 $$$ ) — number products value $$$ k $$$ second line query contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100000000 $$$ ) $$$ a_i $$$ price $$$ i $$$ -th product print $$$ q $$$ integers $$$ i $$$ -th integer answer $$$ b $$$ $$$ i $$$ -th query impossible equalize price give products restriction products condition $$$ |a_i - b| \le k $$$ satisfy ( $$$ a_i $$$ old price product $$$ b $$$ new equal price products ) print -1 . otherwise print maximum possible equal price products first example query choose price $$$ b=2 $$$ easy see difference old price new price $$$ b=2 $$$ $$$ 1 $$$ second example query choose price $$$ b=6 $$$ <unknown> old new price $$$ b=6 $$$ $$$ 2 $$$ third example query choose suitable price $$$ b $$$ value $$$ b $$$ least one condition two violate : $$$ |1 - b| \le 2 $$$ $$$ <unknown> - b| \le 2 $$$ fourth example query value $$$ b $$$ $$$ 1 $$$ $$$ 7 $$$ valid maximum $$$ 7 $$$ 's answer,['math'],900.0
1184/A3,heidi ready crack madame kovarian 's hash function madame kovarian a strict set rule name change two name <unknown> use follow hash function result a collision however hash function <unknown> one always find a set parameters cause a collision heidi decide <unknown> advantage give two string $$$ w_1 $$$ $$$ w_2 $$$ equal length $$$ n $$$ consist lowercase english letter integer $$$ m $$$ consider standard polynomial hash function : $$$ h_p ( w ) : = \left ( \sum _ { <unknown> } ^ { <unknown> } w_i <unknown> \right ) \mbox { mod } ( p ) $$$ $$$ p $$$ prime $$$ r $$$ number $$$ 2\leq r \leq p-2 $$$ goal find $$$ r $$$ a prime $$$ p $$$ ( $$$ m \leq p \leq 1000000000 $$$ ) $$$ h_p ( w_1 ) = h_p ( w_2 ) $$$ string $$$ w_1 $$$ $$$ w_2 $$$ sample independently random string length $$$ n $$$ lowercase english letter first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 10 \le n \le 100000 $$$ $$$ 2 \le m \le 100000 $$$ ) second third line respectively contain word $$$ w_1 $$$ $$$ w_2 $$$ sample independently random string length $$$ n $$$ lowercase english letter output integers $$$ p r $$$ $$$ p $$$ a prime range $$$ [ m 1000000000 ] $$$ $$$ r $$$ integer satisfy $$$ <unknown> [ 2 p-2 ] $$$ least one solution guarantee exist case multiple solutions exist print first example note even though $$$ <unknown> $$$ $$$ r=2 $$$ also cause a <unknown> hash a correct solution since $$$ m $$$ $$$ 5 $$$ thus want $$$ <unknown> 5 $$$ second example aware extra ' g ' end n't realize ` ` river song '' ` ` melody pond '' different lengths .,['math'],3100.0
1184/D2,heidi enjoy perform <unknown> know exactly a new universe would form a non - existent link would break however multiverse work mysterious ways well work use probabilities people mysterious unit time a decision make one two events happen randomly let 's denote $$$ l $$$ current length multiverse a probability $$$ p _ { create } = 1 - \frac { l } { m } $$$ a universe create a probability $$$ p _ { break } = \frac { l } { m } $$$ a non - existent link break position specifically earlier doctor remain universe however point multiverse break a way doctor find leftmost rightmost end <unknown> stop function a case doctor must actually walk across multiverse find tool fix interest expect value length multiverse event occur first line contain three integers $$$ n $$$ $$$ k $$$ $$$ m $$$ $$$ ( 1 \le k \le n \le m \le 250 ) $$$ initial length multiverse initial position doctor maximum possible length multiverse output a single integer a single line indicate expect length multiverse answer $$$ \frac { p } { q } $$$ please print $$$ r $$$ $$$ p \equiv r \cdot q ( \text { mod } 1000000000 + 7 ) $$$ first second test case without change multiverse doctor already one end third test case multiverse break a position <unknown> doctor one end fourth case things seem a little complicate multiverse grow break,['math'],3100.0
29/B,"a car move point a point b speed v meter per second action take place x - axis distance d meter a traffic light start time 0 first g second green light follow r second red light green light g second , car instantly accelerate 0 v vice versa instantly slow v 0 . consider pass traffic light green light instantly car approach traffic light moment red light turn n't time pass approach traffic light moment green light turn move car leave point a time 0 . minimum time car get point a point b without break traffic rule ? first line contain integers l d v g r ( 1 ≤ l d v g r ≤ 1000 d < l ) — distance a b ( meter ) distance a traffic light car 's speed duration green light duration red light output a single number — minimum time car need get point a point b. output must relative absolute error less 10 - 6",['implementation'],1500.0
30/B,king copa often report codeforces site rapidly get popular among brightest mind humanity use train compete recently copa understand conquer world need organize world codeforces tournament hop brightest mind become subordinate <unknown> part conquer world complete final round codeforces world finals <unknown> schedule dd mm yy dd day round mm month yy last two digits year bob lucky first <unknown> form berland one problem : accord rule competition participants must least 18 years old moment finals bob bear bd bm   date record passport copy already <unknown> organizers bob learn different countries way date write differ example us month write first day finally year bob wonder possible rearrange number date birth least 18 years old day dd mm yy always tell <unknown> date write differently help accord another strange rule eligible participant must bear century date finals day finals participant 's 18 - th birthday allow participate consider years 2001 <unknown> year finals use follow rule : year leap 's number divisible four first line contain date dd mm yy second line contain date bd bm   guarantee date correct yy always [ 01 ; 99 ] could passport bob bear finals case still change order number date possible rearrange number date birth bob least 18 years old dd mm yy output yes case output number contain exactly two digits stand day month year a date note permit rearrange number digits,['implementation'],1700.0
31/A,"professor <unknown> study evolution worm recently put forward <unknown> worm evolve division n form worm worm form lengths a1 a2 ... , prove theory professor need find 3 different form length first form equal sum lengths two form help first line contain integer n ( 3 ≤ n ≤ 100 ) — amount worm 's form second line contain n space - separated integers ai ( 1 ≤ ai ≤ 1000 ) — lengths worm form output 3 distinct integers i j k ( 1 ≤ i j k ≤ n ) — index worm 's form ai = aj + ak triple output -1 . several solutions output possible aj = ak",['implementation'],1200.0
31/C,begin new semester new schedule berland state university accord schedule n group lessons room 31 . group start time lesson finish time lesson know turn impossible hold lessons group periods lessons intersect moment time one group finish 's lesson group start lesson lessons n't intersect <unknown> want cancel lesson one group two time periods lessons remain group intersect find ways first line contain integer n ( 1 ≤ n ≤ 5000 ) — amount group lessons room 31 . n line follow contain two integers li ri ( 1 ≤ li < ri ≤ 106 ) — start finish time lesson i - th group possible initially two lessons intersect ( see sample 1 ) output integer k — amount ways cancel lesson exactly one group two time periods lessons remain group intersect second line output k number — index group possible cancel lesson group number start 1 order give input output number increase order,['implementation'],1700.0
32/B,ternary numeric notation quite popular berland <unknown> ternary number borze alphabet use digit 0 <unknown> « . » 1 « - . » 2 « -- » decode borze code i.e find ternary number give representation borze alphabet first line contain a number borze code length string 1 200 character 's guarantee give string a valid borze code ternary number ( number lead zero ) output decode ternary number lead zero,['implementation'],800.0
27/A,« polygon » a system allow create program task a simple professional way add a test problem correspond form ask test index case clear index next test system suggest default value index calculate smallest positive integer use index previously add test implement feature create a program determine default index next test give index previously add test first line contain one integer n ( 1 ≤ n ≤ 3000 ) — amount previously add test second line contain n distinct integers a1 a2 ... ( 1 ≤ ai ≤ 3000 ) — index test output require default value next test index,['implementation'],1200.0
34/A,n soldier stand a circle soldier height ai know a reconnaissance unit make two neighbour soldier whose heights difference minimal i.e <unknown> - <unknown> minimal less <unknown> output pair soldier form a reconnaissance unit first line contain integer n ( 2 ≤ n ≤ 100 ) — amount soldier follow heights soldier order circle — n space - separated integers a1 a2 ... ( 1 ≤ ai ≤ 1000 ) soldier heights give clockwise counterclockwise direction output two integers — index neighbour soldier form a reconnaissance unit many optimum solutions output remember soldier stand a circle,['implementation'],800.0
36/A,recently vasya get interest find extra - terrestrial intelligence make a simple extra - terrestrial signal ’ receiver keep a record signal n days a row n days vasya write a 1 notebook receive a signal day a 0 ’ t vasya think find extra - terrestrial intelligence a system way signal receive i.e intervals successive signal equal otherwise vasya think signal send stupid alien one care help vasya deduce information give receiver find extra - terrestrial intelligence first line contain integer n ( 3 ≤ n ≤ 100 ) — amount days vasya check signal second line contain n character 1 0 — record vasya keep n days ’ s guarantee give record sequence contain least three 1s vasya find extra - terrestrial intelligence output yes otherwise output,['implementation'],1300.0
36/B,ever since kalevitch a famous berland <unknown> hear fractals make main topic canvas every morning artist take a piece graph paper start make a model future canvas take a square big n × n square paint black take a clean square piece paper paint <unknown> use follow algorithm : step 1 . paper divide n2 identical square paint black accord model step 2 . every square remain white divide n2 smaller square paint black accord model every follow step repeat step 2 . unfortunately tiresome work demand much time paint genius kalevitch dream make process automatic move make 3d even <unknown> fractals first line contain integers n k ( 2 ≤ n ≤ 3 1 ≤ k ≤ 5 ) k amount step algorithm follow n line contain n symbols determine model symbol « . » stand a white square whereas « * » stand a black one guarantee model least one white square output a matrix nk × nk a picture look like k step algorithm,['implementation'],1600.0
38/A,berland <unknown> force system consist n rank number use natural number 1 n 1 lowest rank n highest rank one need exactly di years rise rank i rank i + 1 . reach a certain rank i reach previous i - 1 rank impossible vasya reach a new rank a dream hold rank b. find many years vasya serve army finally realize dream first input line contain integer n ( 2 ≤ n ≤ 100 ) second line contain n - 1 integers di ( 1 ≤ di ≤ 100 ) third input line contain two integers a b ( 1 ≤ a < b ≤ n ) number line space - separated print single number number years vasya need rise rank a rank b,['implementation'],800.0
38/D,"vasya play bricks bricks set regular cubical shape vasya <unknown> a talented architect however tower build keep fall apart let us consider build process vasya take a brick put top already build tower side brick parallel side bricks already use let 's introduce a cartesian coordinate system horizontal plane vasya put first brick projection brick number i plane a square side parallel ax coordinate opposite corner point ( xi 1 yi 1 ) ( xi 2 yi 2 ) bricks cast <unknown> <unknown> weight a brick a × a × a a3 grams guarantee vasya put brick except first one previous one area intersection upper side previous brick lower side next brick always positive ( vasya include ) live a normal world laws physical <unknown> work , perhaps put yet another brick tower <unknown> weight vasya put cub consecutively one top least one cube lose balance fall happen vasya get upset stop construction print number bricks maximal stable tower maximal number m satisfy condition tower consist bricks 1 2 ... k every integer k 1 m remain stable first input file contain integer n ( 1 ≤ n ≤ 100 ) number bricks next n line contain four number xi 1 yi 1 xi 2 yi 2 ( xi 1 ≠ xi 2 <unknown> 1 - xi 2| = <unknown> 1 - yi 2| ) coordinate opposite angle base brick number i. coordinate integers absolute value exceed 50 . cub give order vasya put guarantee area intersection upper side brick number i - 1 lower side brick number i strictly strictly greater zero i ≥ 2 . print number bricks maximal stable tower",['implementation'],1900.0
28/A,robot bender decide make <unknown> a birthday present drive n nail number 1 n order bender decide make a picture use metal rods picture a close polyline vertices nail ( give order ) segment polyline parallel coordinate ax polyline allow self - intersections bender take a rod fold exactly place form angle 90 degrees attach place fold unoccupied nail attach two end rod adjacent nail a nail consider unoccupied rod attach ( neither 's end fold place ) rod could use twice require use rods help bender solve difficult task first line contain two positive integers n m ( 4 ≤ n ≤ 500 2 ≤ m ≤ 500 n even ) — amount nail amount rods i - th follow n line contain a pair integers denote coordinate i - th nail nail connect order give input last line contain m integers — <unknown> rods coordinate exceed 104 absolute value lengths rods 1 200 000 . rod use twice guarantee segment give polyline parallel coordinate ax three consecutive nail lie line impossible solve bender 's problem output otherwise output yes first line second line output n number — i - th number rod fold place attach i - th nail -1 rod multiple solutions print,['implementation'],1600.0
39/F,thumbelina <unknown> find a little island middle a swamp want get shore much one get shore hill situate along a straight line connect little island shore let us assume hill number 1 n number a hill equal distance meter island distance n - th hill shore also 1 meter thumbelina small make jump fortunately a family frog live swamp suggest help frog agree give thumbelina a ride thumbelina choose one frog frog a certain jump length thumbelina agree accept help a frog whose jump length d frog jump island hill d — hill 2d 3d get shore ( i.e find beyond hill n ) however one problem : mosquitoes also live swamp moment a <unknown> a nap hill frog jump a hill a mosquito frog smash frog thumbelina meet <unknown> find death mosquito much sad help thumbelina choose a frog bring shore smash small number mosquitoes possible first line contain three integers n m k ( 1 ≤ n ≤ 109 1 ≤ m k ≤ 100 ) — number hill frog mosquitoes respectively second line contain m integers di ( 1 ≤ di ≤ 109 ) — lengths frog ’ jump third line contain k integers — number hill mosquito sleep one mosquito sleep hill number line separate single space first line output number frog smash minimal number mosquitoes second line — number increase order separate space frog number 1 m order jump length give input data,['implementation'],1300.0
35/B,upon a time world beautiful sun <unknown> <unknown> <unknown> <unknown> sausages taste better <unknown> powerful country capital place hero dravde work ’ t program make problems ( fact people saw a computer days ) nevertheless happy work a warehouse a magical non - <unknown> drink ogudar - olok keep ’ t describe work detail take a better look a simplify version warehouse warehouse one set shelve n shelve divide m section shelve number top bottom start 1 section shelf number leave right also start 1 . section contain exactly one box drink try might dravde never put a box a section already one course work dravde frequently notice put a box a fill section case solution simple dravde ignore section look next one right empty put box otherwise keep look first empty section right empty section find end shelf look shelf next one etc also time look a new shelf start shelf ’ s begin dravde still ’ t find empty section box immediately drink throw empty bottle away catch one great party a lot ogudar - olok drink dravde ask help unlike program therefore model process count box warehouse easy work process count contain two type query message : first input line contain integers n m k ( 1 ≤ n m ≤ 30 1 ≤ k ≤ 2000 ) — height width shelve amount operations warehouse need analyze follow k line query give order appearance format describe query « -1 i d » type output two number a separate line — index shelf index section box identifier lay box warehouse query make output « -1 -1 » without quote,['implementation'],1700.0
25/B,phone number berland a sequence n digits often make easier memorize number divide group two three digits example phone number <unknown> easier remember 11 - <unknown> - 33 . task find a give phone number divisions group two three digits first line contain integer n ( 2 ≤ n ≤ 100 ) — amount digits phone number second line contain n digits — phone number divide group output divisions give phone number group two three digits separate group single character - answer unique output,['implementation'],1100.0
20/A,new operate system <unknown> a nice feature possible use number character ' / ' a <unknown> path instead one traditional ' / ' example string <unknown> / <unknown> <unknown> / local / <unknown> equivalent character ' / ' ( sequence character ) end path require case path root directory represent single character ' / ' a path call normalize contain smallest possible number character ' / ' task transform a give path normalize form first line input contain lowercase latin letter character ' / ' — path directory paths start least one character ' / ' length give line 100 character empty path normalize form,['implementation'],1700.0
2/A,"winner card game popular berland ` ` <unknown> '' determine accord follow rule end game one player maximum number point winner situation become difficult number players one round a player gain lose a particular number point course game number point register line ` ` name score '' name a player 's name score number point gain round integer number score negative mean player lose round , two players maximum number point ( say equal m ) end game win one score least m point first initially player 0 point 's guarantee end game least one player a positive number point first line contain integer number n ( 1 ≤ n ≤ 1000 ) n number round play follow n line contain information round ` ` name score '' format chronological order name a string lower - case latin letter length 1 32 score integer number <unknown> 1000 inclusive print name winner",['implementation'],1500.0
5/A,polycarp work a new project call ` ` <unknown> '' follow modern <unknown> decide project contain chat well achieve goal polycarp spend several hours front laptop implement a chat server process three type command : polycarp want find amount outgo traffic server produce process a particular set command polycarp know chat server send traffic ' add ' ' remove ' command ' send ' command process server send l bytes participant chat l length message polycarp time ask help solve problem input file contain 100 command line line exceed 100 character format command follow : < name > < <unknown> > a non - empty sequence latin letter digits < message_text > contain letter digits space ca n't start end a space < message_text > empty line guarantee input data correct i.e ' add ' command person a name already chat ' remove ' command person a name chat etc name case - sensitive print a single number — answer problem,['implementation'],1000.0
6/B,"president berland a <unknown> office - room , apart work subordinate subordinate well president desk a unique colour desk rectangular side parallel office wall one day president decide establish assembly deputies members unfortunately remember exact amount deputies remember desk deputy adjacent desk say two desks ( president 's deputy 's ) a common side a positive length office - room plan view a matrix n row m columns cell matrix either empty contain a part a desk uppercase latin letter stand desk colour « period » character ( « . » ) stand empty cell first line contain two separate a space integer number n m ( 1 ≤ n m ≤ 100 ) — length width office - room c character — president 's desk colour follow n line contain m character — office - room description guarantee colour desk unique desk represent a continuous subrectangle give matrix colour mark uppercase latin letter print number — amount president 's deputies",['implementation'],1100.0
24/B,"formula one championship consist series race call grand <unknown> every race drivers receive point accord final position top 10 drivers receive point follow order 25 18 15 12 10 8 6 4 2 1 . conclusion championship driver point champion a tie champion one win ( i.e first place ) a tie still exist choose one second place , place use compare last year another score system propose reject champion one win tie champion one point a tie still exist proceed way original score system compare number second third <unknown> , place give result race season determine champion accord score systems guarantee systems produce unique champion first line contain integer t ( 1 ≤ t ≤ 20 ) t number race race describe one one every race description start integer n ( 1 ≤ n ≤ 50 ) a line n number <unknown> drivers give race n line follow <unknown> race contain name a driver name drivers give order first last place name driver consist lowercase uppercase english letter length 50 character compare name case - <unknown> output contain exactly two line first line name champion accord original rule second line name champion accord <unknown> rule guarantee drivers participate race championship consider every driver participate least one race total number drivers whole season 50",['implementation'],1500.0
7/B,little time leave release first national operate system <unknown> components finish yet — memory manager among accord developers ' plan first release memory manager simple <unknown> support three operations : memory model case simple a sequence m bytes number convenience first m - th first operation alloc n take parameter size memory block allocate process operation a free block n successive bytes allocate memory amount block one block closest begin memory ( i.e first <unknown> ) prefer bytes mark free memory manager return a 32 - bit integer numerical token identifier block impossible allocate a free block size function return <unknown> second operation erase x take parameter identifier block operation free system memory mark bytes block free use case identifier point previously allocate block erase yet function return illegal_erase_argument last operation defragment arguments simply bring occupy memory section closer begin memory without change respective order current implementation use successive integers start 1 identifiers successful alloc operation procession return follow number <unknown> alloc operations affect numeration write implementation memory manager output return value alloc command also output illegal_erase_argument fail erase command first line input data contain two positive integers t m ( 1 ≤ t ≤ 100 ; 1 ≤ m ≤ 100 ) t — amount operations give memory manager process m — available memory size bytes follow t line operations give first operation alloc n ( 1 ≤ n ≤ 100 ) n integer second one erase x x arbitrary 32 - bit integer numerical token third operation defragment output sequence line line contain either result alloc operation procession illegal_erase_argument a result fail erase operation procession output line go order operations process successful procession alloc operation return integers start 1 identifiers allocate block,['implementation'],1600.0
11/C,give a 0 - 1 rectangular matrix number square ? a square a solid square frame ( border ) <unknown> equal 1 . a square least 2 × 2 . interest two type square : regardless type a square must contain least one 1 ca n't touch ( side corner ) <unknown> 1 . course lengths side square equal many square give matrix ? first line contain integer t ( 1 ≤ t ≤ 10000 ) t number test case input test case follow case start a line contain integers n m ( 2 ≤ n m ≤ 250 ) n number row m number columns follow n line contain m character ( 0 1 ) total number character test case n't exceed 106 input file output exactly t line answer i - th test case i - th line,['implementation'],2200.0
12/A,"a secret base potatoland <unknown> <unknown> make accord a special recipe neighbour <unknown> decide <unknown> recipe sell <unknown> mission prepare special <unknown> pearlo many years , finally pearlo learn secrets <unknown> <unknown> potatoland territory reach secret base stand entrance get inside need pass combination lock minute ago one workers enter password terminal open door terminal a square digital keyboard 3 × 3 digits 1 9 . pearlo know password consist distinct digits probably symmetric respect central button terminal heat sensor allow detect digits worker press want check whether password enter worker symmetric respect central button terminal fact help pearlo reduce number different possible password combinations input contain matrix three row three symbols symbol « x » mean correspond button press « . » mean press matrix may contain « x » also may contain « . » print yes password symmetric respect central button terminal otherwise familiar term « central symmetry » may look http : //en.wikipedia.org / wiki / <unknown>",['implementation'],800.0
15/A,a new <unknown> village call « flatville » build flatland already build « flatville » n square house centre оx - axis house ' side parallel coordinate ax 's know two house overlap touch architect <unknown> peter work commission build a new house « flatville » customer want future house оx - axis square shape a side t touch least one already build house sure side parallel coordinate ax centre ox - axis n't overlap house village peter give a list house « flatville » would help find amount possible position new house ? first line input data contain number n t ( 1 ≤ n t ≤ 1000 ) follow n line contain two space - separated integer number : xi ai xi — x - coordinate centre i - th house ai — length side ( - 1000 ≤ xi ≤ 1000 1 ≤ ai ≤ 1000 ) output amount possible position new house possible x - coordinate new house non - integer value,['implementation'],1200.0
19/A,everyone know <unknown> fifa world cup hold south <unknown> decision bfa ( berland 's football <unknown> ) next world cup hold berland bfa take decision change world cup regulations : ask write a program give list compete team result match find list team manage get knockout stage first input line contain integer n ( 1 ≤ n ≤ 50 ) — amount team take part final tournament world cup follow n line contain name team a name a string lower - case upper - case latin letter length n't exceed 30 character follow n · ( n - 1 ) / 2 line describe hold match format name1 - name2 num1 : num2 name1 name2 — name team ; num1 num2 ( 0 ≤ num1 num2 ≤ 100 ) — amount goals score correspond team accuracy descriptions guarantee : two team name coincide accurate letter ' case ; match a team play ; match meet descriptions output n / 2 line — name team manage get knockout stage lexicographical order output name a separate line odd character ( include space ) allow 's guarantee describe regulations help order team without <unknown>,['implementation'],1400.0
10/A,tom interest power consumption favourite laptop laptop three modes normal mode laptop consume p1 watt per minute t1 minutes tom move mouse touch keyboard last time a screensaver start power consumption change p2 watt per minute finally t2 minutes start screensaver laptop switch ` ` sleep '' mode consume p3 watt per minute tom move mouse touch keyboard laptop second third mode switch first ( normal ) mode tom 's work laptop divide n time periods [ l1 r1 ] [ l2 r2 ] ... [ <unknown> rn ] interval tom <unknown> move mouse press button keyboard periods tom stay away laptop find total amount power consume laptop period [ l1 rn ] first line contain 6 integer number n p1 p2 p3 t1 t2 ( 1 ≤ n ≤ 100 0 ≤ p1 p2 p3 ≤ 100 1 ≤ t1 t2 ≤ 60 ) follow n line contain description tom 's work i - th line contain two space - separated integers li ri ( 0 ≤ li < ri ≤ <unknown> ri < li + 1 i < n ) stand start end i - th period work output answer problem,['implementation'],900.0
12/B,one cold winter even alice older brother bob sit home near <unknown> give interest problems solve alice 's turn tell number n bob say : — shuffle digits number order obtain smallest possible number without lead <unknown> problem ! — say bob immediately give answer alice say a random number n't know whether bob 's answer correct help find impatient brother wait verdict first line contain one integer n ( 0 ≤ n ≤ 109 ) without lead zero second line contain one integer m ( 0 ≤ m ≤ 109 ) — bob 's answer possibly lead zero print ok bob 's answer correct <unknown> otherwise,['implementation'],1100.0
14/B,among things bob keen <unknown> especially like take picture sportsmen reason place position x0 a long straight racetrack get ready take picture problem <unknown> pass total amount sportsmen train racetrack equal n. regularly run distance within a particular segment racetrack sportsman example first sportsman run position a1 position b1 second — a2 <unknown> minimum distance bob move a chance take picture sportsman ? bob take a picture a sportsman stand within segment sportsman cover racetrack first line input file contain integers n x0 ( 1 ≤ n ≤ 100 ; 0 ≤ x0 ≤ 1000 ) follow n line contain pair integers ai bi ( 0 ≤ ai bi ≤ 1000 ; ai ≠ bi ) output require minimum distance units position racetrack a position output -1,['implementation'],1000.0
39/G,"petya write a programme c++ calculate a interest function f ( n ) petya run program a certain value n go kitchen tea history record concern long program work time petya return complete calculations result however petya drink tea a <unknown> <unknown> manage destroy input file petya ca n't figure value n program run help petya carry inverse function ! <unknown> program consist a function c++ follow simplify <unknown> : whitespaces a <unknown> <unknown> thus a function body two kinds operators operator ` ` return arithmexpr ; '' return value expression value function conditional operator ` ` ( <unknown> ) return arithmexpr ; '' return value arithmetical expression logical expression true guarantee <unknown> c++ language — cycle assignment operators nest conditional operators etc variables except n parameter use function constants integers interval [ 0 .. 32767 ] operators perform sequentially function return a value operators sequence perform arithmetical expressions perform take consideration standard priority operations mean first products part sum calculate calculation products operations multiply division perform leave right summands sum addition subtraction also perform leave right operations ` ` > '' ( ) ` ` < ` ` ( less ) ` ` = = '' ( equal ) also standard mean ' ve get pay close attention ! program compile help 15 - bit berland c++ <unknown> invent a berland company <unknown> 's arithmetical operations perform a non - standard way addition subtraction multiplication perform modulo 32768 ( result subtraction negative 32768 add number belong interval [ 0 .. 32767 ] ) division ` ` / '' a usual integer division remainder omit examples arithmetical operations : guarantee value n 0 32767 give function perform correctly mean that:1 . division 0 never <unknown> perform a function value n = n recursive call function f may occur parameter value 0 1 ... n - 1 . consequently program never infinite <unknown> result sequence operators function always return a value mention due limitations value return function f independent either <unknown> variables order perform calculations arithmetical expressions part logical one anything else except value n parameter 's f function regard a function mathematical sense i.e a unique correspondence value n interval [ 0 .. 32767 ] a value f ( n ) interval give value f ( n ) find n. suitable n value unique find maximal one ( interval [ 0 .. 32767 ] ) first line integer f ( n ) interval [ 0 .. 32767 ] next line description function f. description find extra space line break ( see examples ) course ’ t break key word int , return number size input data ’ t exceed 100 bytes output a single number — answer problem ’ s answer output ` ` -1 '' ( without quote )",['implementation'],2400.0
41/C,sometimes one spell email address phone one usually pronounce a dot dot sign a result get something like <unknown> task transform a proper email address ( [ email protect ] ) know a proper email address contain symbols @ lower - case latin letter n't start n't end a dot also a proper email address n't start n't end sign moreover email address contain exactly one symbol @ yet may contain number ( possible zero ) dot carry a series replacements length result short possible a proper email address lengths equal print lexicographically minimal result overall two variants replacement possible : dot replace a dot replace first line contain email address description guarantee a proper email address dot replace dot sign replace line empty length exceed 100 symbols print shortest email address give line could make describe replacements several solutions problem print lexicographically minimal one ( lexicographical comparison line implement operator < modern program languages ) ascii table symbols go order : @ ab ... z,['implementation'],1300.0
75/A,imagine life remove zero ? sure many problems problem a simple example remove zero life 's addition operation let 's assume give equation a + b = c a b positive integers c sum a b. let 's remove zero equation equation remain correct remove zero ? example equation 101 + 102 = <unknown> remove zero 11 + 12 = 23 still a correct equation equation 105 + 106 = 211 remove zero 15 + 16 = 211 a correct equation input consist two line first line contain integer a second line contain integer b equation describe ( 1 ≤ a b ≤ 109 ) wo n't lead zero value c calculate c = a + b. output one line print ` ` yes '' equation remain correct remove zero print ` ` '' otherwise,['implementation'],1000.0
44/C,school holiday come berland holiday go continue n days students school № n time live teacher marina sergeyevna spend summer busy check <unknown> ( berland state <unknown> ) result finally take a vacation break ! people charge daily water flower shift accord schedule however marina sergeyevna make schedule tire work lose dream <unknown> vacation perhaps make several mistake fact possible accord schedule days holiday flower water water multiple time help marina sergeyevna find a mistake first input line contain two number n m ( 1 ≤ n m ≤ 100 ) — number days berland holiday number people charge water respectively next m line contain description duty schedule line contain two integers ai bi ( 1 ≤ ai ≤ bi ≤ n ) mean i - th person charge water flower ai - th bi - th day inclusively a day duty shift describe sequentially i.e bi ≤ ai + 1 i 1 n - 1 inclusively print ` ` ok '' ( without quote ) schedule contain mistake otherwise find minimal number a day flower water water multiple time output two integers — day number number time flower water day keep mind second sample mistake occur second day also sixth day nobody water flower however print second day i.e day minimal number,['implementation'],1300.0
44/A,<unknown> summer a beautiful time year ! a girl name alyona walk forest pick a <unknown> fall leave alyona <unknown> — n't take a leaf match color species tree one leave already find many leave alyona pick first line contain integer n ( 1 ≤ n ≤ 100 ) — number leave alyona find next n line contain leave ' descriptions leaf characterize species tree fall color species tree color give name consist 10 lowercase latin letter a name empty string species a tree color give line separate a space output single number — number alyona 's leave,['implementation'],900.0
1066/D,maksim $$$ n $$$ object $$$ m $$$ box box size exactly $$$ k $$$ object number $$$ 1 $$$ $$$ n $$$ order leave right size $$$ i $$$ -th object $$$ a_i $$$ maksim want pack object box pack object follow algorithm : take one empty box go leave right object $$$ i $$$ -th object fit current box ( remain size box greater equal $$$ a_i $$$ ) put box remain size box decrease $$$ a_i $$$ otherwise take new empty box continue process empty box least one object box maksim pack choose set object maksim want know maximum number object pack algorithm reach target throw leftmost object set remain set object pack box task say maximum number object maksim pack box time maksim try pack object box make empty box ( relative order remain set object change ) first line input contain three integers $$$ n $$$ $$$ m $$$ $$$ k $$$ ( $$$ 1 \le n m \le 200000 $$$ $$$ 1 \le k \le 1000000000 $$$ ) — number object number box size box second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le k $$$ ) $$$ a_i $$$ size $$$ i $$$ -th object print maximum number object maksim pack use algorithm describe problem statement first example maksim pack $$$ 4 $$$ object firstly try pack $$$ 5 $$$ object distribution object $$$ [ 5 ] [ 2 1 ] $$$ maxim pack next object second box empty box next throw first object object distribution $$$ [ 2 1 ] [ 4 2 ] $$$ answer $$$ 4 $$$ second example obvious maksim pack object start first second third fourth ( case distribution object $$$ [ 4 ] $$$ ) pack last object ( $$$ [ 1 ] $$$ ) third example maksim pack object distribution $$$ [ 1 2 ] [ 3 ] [ 1 1 ] $$$,['implementation'],1800.0
1066/C,get a shelf want put book give $$$ q $$$ query three type : assume first book put position ( matter ) query type $$$ 3 $$$ always valid ( guarantee book query already place ) also assume n't put book shelf twice $$$ i d $$$ s n't repeat query first two type problem answer query type $$$ 3 $$$ order appear input note answer query type $$$ 3 $$$ book remain shelf relative order book change python programmer consider use pypy instead python submit code first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 200000 $$$ ) — number query $$$ q $$$ line follow $$$ i $$$ -th line contain $$$ i $$$ -th query format problem statement guarantee query always valid ( query type $$$ 3 $$$ guarantee book query already place type guarantee book place ) guarantee least one query type $$$ 3 $$$ input query constraint $$$ 1 \le i d \le 200000 $$$ meet print answer query type $$$ 3 $$$ order appear input let 's take a look first example let 's consider query : let 's take a look second example let 's consider query :,['implementation'],1400.0
255/A,"greg a beginner <unknown> today gym coach give train plan n integers a1 a2 ... , number mean greg need exactly n exercise today besides greg repeat i - th order exercise ai time greg three type exercise : ` ` chest '' exercise ` ` biceps '' exercise ` ` back '' exercise besides train cyclic , first exercise a ` ` chest '' one second one ` ` biceps '' third one ` ` back '' fourth one ` ` chest '' fifth one ` ` biceps '' n - th exercise greg wonder muscle get exercise train know exercise greg repeat maximum number time train correspond muscle help greg determine muscle get train first line contain integer n ( 1 ≤ n ≤ 20 ) second line contain n integers a1 a2 ... ( 1 ≤ ai ≤ 25 ) — number time greg repeat exercise print word ` ` chest '' ( without quote ) chest get exercise ` ` biceps '' ( without quote ) biceps get exercise print ` ` back '' ( without quote ) back get exercise guarantee input answer problem unambiguous first sample greg 2 chest 8 biceps zero back exercise biceps get exercise second sample greg 5 chest 1 biceps 10 back exercise back get exercise third sample greg 18 chest 12 biceps 8 back exercise chest get exercise",['implementation'],800.0
42/B,volodya museum saw a regular chessboard a museum piece four chess piece : two white rook a white king a black king ` ` <unknown> black certainly n't win ! ` ` — volodya say right sure task say whether white piece chessboard guarantee represent a correct position ( every piece occupy one cell two piece occupy cell kings take ) thus task decide whether white mate black would remind mean black king take one opponent 's piece moment also move <unknown> position a rook move vertically horizontally number free cells ( assume piece path ) a king — adjacent cells ( either corner side ) certainly piece leave board black king might able take opponent 's rook turn ( see sample 3 ) input contain 4 space - separated piece position : position two rook white king black king position 8 × 8 chessboard denote two symbols — ( ' a ' - ' h ' ) ( ' 1 ' - ' 8 ' ) — stand horizontal vertical coordinate cell occupy piece guarantee two piece occupy cell kings take output contain one word : ` ` <unknown> '' white mate black ` ` '' otherwise,['implementation'],1700.0
228/A,valera horse go party friends follow <unknown> <unknown> a know popular wear horseshoe different color valera get four horseshoe leave last year maybe color case need go store buy horseshoe lose face front <unknown> <unknown> fortunately store sell horseshoe color sun valera enough money buy four however order save money would like spend little money possible need help valera determine minimum number horseshoe need buy wear four horseshoe different color a party first line contain four space - separated integers s1 s2 s3 s4 ( 1 ≤ s1 s2 s3 s4 ≤ 109 ) — color horseshoe valera consider possible color index integers print a single integer — minimum number horseshoe valera need buy,['implementation'],800.0
1100/A,morning roman wake open browser $$$ n $$$ open tabs number $$$ 1 $$$ $$$ n $$$ two kinds tabs : information require test social network sit roman decide many tabs open want close decide accomplish close every $$$ k $$$ -th ( $$$ 2 \leq k \leq n - 1 $$$ ) tab decide whether want study test chat social network formally roman choose one tab ( let number $$$ b $$$ ) close tabs number $$$ c = b + i \cdot k $$$ satisfy follow condition : $$$ 1 \leq c \leq n $$$ $$$ i $$$ integer ( may positive negative zero ) example $$$ k = 3 $$$ $$$ n = 14 $$$ roman choose $$$ b = 8 $$$ close tabs number $$$ 2 $$$ $$$ 5 $$$ $$$ 8 $$$ $$$ 11 $$$ $$$ 14 $$$ close tabs roman calculate amount remain tabs information test ( let 's denote $$$ e $$$ ) amount remain social network tabs ( $$$ s $$$ ) help roman calculate maximal absolute value difference value $$$ |e - s| $$$ would easy decide next first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 2 \leq k < n \leq 100 $$$ ) — amount tabs open currently distance tabs close second line consist $$$ n $$$ integers equal either $$$ 1 $$$ $$$ -1 $$$ $$$ i $$$ -th integer denote type $$$ i $$$ -th tab : equal $$$ 1 $$$ tab contain information test equal $$$ -1 $$$ 's a social network tab output a single integer — maximum absolute difference amount remain tabs different type $$$ |e - s| $$$ first example choose $$$ b = 1 $$$ $$$ b = 3 $$$ delete one tab type remain tabs contain test information thus $$$ e = 2 $$$ $$$ s = 0 $$$ $$$ |e - s| = 2 $$$ second example contrary leave open tabs social network open,['implementation'],1000.0
1056/A,arkady 's morning seem straight nightmare <unknown> whole morning still half - asleep get tram arrive first time leave tram realize sure line number tram ride arkady wake several time time saw tram stop stop stop know line tram stop give information help arkady determine possible line tram ? first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — number stop arkady saw next $$$ n $$$ line describe stop start a single integer $$$ r $$$ ( $$$ 1 \le r \le 100 $$$ ) — number tram line stop $$$ r $$$ distinct integers follow one $$$ 1 $$$ $$$ 100 $$$ inclusive — line number arbitrary order guarantee arkady 's information consistent i.e least one tram line arkady could take print tram line arkady could arbitrary order consider first example arkady wake three time first time saw a stop line $$$ 1 $$$ $$$ 4 $$$ $$$ 6 $$$ second time saw a stop line $$$ 1 $$$ $$$ 4 $$$ third time saw a stop line $$$ 10 $$$ $$$ 5 $$$ $$$ 6 $$$ $$$ 4 $$$ $$$ 1 $$$ a tram one two line : $$$ 1 $$$ $$$ 4 $$$,['implementation'],800.0
1055/B,"alice 's hair grow leap bound maybe cause <unknown> <unknown> maybe black magic ... prevent alice decide go hairdresser want hair length $$$ l $$$ centimeters haircut $$$ l $$$ favorite number suppose alice 's head a straight line $$$ n $$$ hairlines grow let 's number $$$ 1 $$$ $$$ n $$$ one swing scissor hairdresser shorten hairlines segment length $$$ l $$$ give hairlines segment length strictly greater $$$ l $$$ hairdresser want complete job fast possible make least possible number swing scissor since swing scissor take one second alice n't decide yet would go hairdresser ask calculate much time haircut would take depend time would go hairdresser particular need process query two type : note request $$$ 0 $$$ alice interest <unknown> scenario take a haircut hairlines change length first line contain three integers $$$ n $$$ $$$ m $$$ $$$ l $$$ ( $$$ 1 \le n m \le 100\,000 $$$ $$$ 1 \le l \le 1000000000 $$$ ) — number hairlines number request favorite number alice second line contain $$$ n $$$ integers $$$ a_i $$$ ( $$$ 1 \le a_i \le 1000000000 $$$ ) — initial lengths hairlines alice follow $$$ m $$$ line contain a request format describe statement request description start integer $$$ t_i $$$ $$$ t_i = 0 $$$ need find time haircut would take otherwise $$$ t_i = 1 $$$ moment one hairline grow rest line contain two integers : $$$ p_i $$$ $$$ d_i $$$ ( $$$ 1 \le p_i \le n $$$ $$$ 1 \le d_i \le 1000000000 $$$ ) — number hairline length grow query type $$$ 0 $$$ print time haircut would take consider first example :",['implementation'],1300.0
1054/B,"initially ildar empty array perform $$$ n $$$ step step take a subset integers already add array append mex subset array mex multiset integers smallest non - negative integer present multiset example mex multiset $$$ [ 0 2 3 ] $$$ $$$ 1 $$$ mex multiset $$$ [ 1 2 1 ] $$$ $$$ 0 $$$ formally step $$$ m $$$ ildar already array $$$ a_1 a_2 \ldots a _ { m-1 } $$$ choose subset indices $$$ 1 \leq i_1 < i_2 < \ldots < i_k < m $$$ ( possibly empty ) $$$ 0 \leq k < m $$$ append $$$ mex ( a _ { i_1 } a _ { i_2 } \ldots a _ { i_k } ) $$$ end array perform step ildar think might make a mistake somewhere ask determine a give array $$$ a_1 a_2 \ldots a_n $$$ minimum step $$$ t $$$ definitely make a mistake least one step $$$ 1 2 \ldots t $$$ determine could obtain array without mistake first line contain a single integer $$$ n $$$ ( $$$ 1 \leq n \leq 100\,000 $$$ ) — number step ildar make second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 0 \leq a_i \leq 1000000000 $$$ ) — array ildar obtain ildar could choose subsets step a way result array $$$ a_1 a_2 \ldots a_n $$$ print $$$ -1 $$$ otherwise print a single integer $$$ t $$$ — smallest index a step a mistake make least one step among step $$$ 1 2 \ldots t $$$ first example possible ildar make mistake process could follow thus get array without mistake answer $$$ -1 $$$ second example definitely make a mistake first step could obtain anything different $$$ 0 $$$ third example could obtain $$$ [ 0 1 2 ] $$$ without mistake $$$ <unknown> $$$ definitely wrong",['implementation'],1000.0
1054/A,masha live a multi - <unknown> build floor number positive integers two floor call adjacent number differ one masha decide visit egor masha live floor $$$ x $$$ egor floor $$$ y $$$ ( floor masha ) house a <unknown> elevator masha use stairs take $$$ t_1 $$$ second walk adjacent floor ( direction ) elevator pass adjacent floor ( way ) $$$ t_2 $$$ second elevator move doors close elevator spend $$$ t_3 $$$ second open close doors assume time spend action except move adjacent floor wait doors open close masha use elevator immediately go directly desire floor come apartment floor masha notice elevator floor $$$ z $$$ close doors choose whether use stairs use elevator time masha need get egor 's floor stairs strictly less time take use elevator use stairs otherwise choose elevator help <unknown> understand whether use elevator stairs line contain six integers $$$ x $$$ $$$ y $$$ $$$ z $$$ $$$ t_1 $$$ $$$ t_2 $$$ $$$ t_3 $$$ ( $$$ 1 \leq x y z t_1 t_2 t_3 \leq 1000 $$$ ) — floor masha floor masha want get floor elevator locate time take masha pass two floor stairs time take elevator pass two floor time take elevator close open doors guarantee $$$ x \ne y $$$ time take use elevator greater time take use stairs print « yes » ( without quote ) otherwise print « > ( without quote ) print letter case ( upper lower ) first example : masha go stairs time spend $$$ 16 = 16 $$$ go $$$ 4 $$$ time adjacent floor time spend $$$ 4 $$$ second choose elevator wait $$$ 2 $$$ second elevator leave $$$ 4 $$$ -th floor go $$$ 5 $$$ -th doors open another $$$ 1 $$$ second masha enter elevator wait $$$ 1 $$$ second doors close next elevator spend $$$ 8 = 8 $$$ second go $$$ 5 $$$ -th floor $$$ 1 $$$ -st elevator pass $$$ 4 $$$ time adjacent floor spend $$$ 2 $$$ second time finally take another $$$ 1 $$$ second doors open masha come thus way elevator take $$$ 2 + 1 + 1 + 8 + 1 = 13 $$$ second less $$$ 16 $$$ second masha choose elevator second example profitable masha use stairs take $$$ 13 $$$ second use elevator $$$ 10 $$$ second take go foot third example time take use elevator equal time take walk stairs equal $$$ 12 $$$ second mean masha take elevator,['implementation'],800.0
1046/F,"find move new planet support human life discussions start currency use long negotiations bitcoin ultimately choose <unknown> currency great news alice whose grandfather get bitcoin mine 2013 <unknown> a lot throughout years unfortunately pay something bitcoin everyone see many bitcoins public address wallet worry alice decide split bitcoins among multiple different address every address $$$ x $$$ satoshi ( 1 bitcoin = $$$ 100000000 $$$ satoshi ) create new public address wallets free will pay $$$ f $$$ fee satoshi per transaction ensure acceptable speed transfer fee <unknown> address transaction send tell alice much total fee satoshi need pay achieve goal first line contain number $$$ n $$$ ( $$$ 1 \leq n \leq 200\,000 $$$ ) represent total number public address alice next line contain $$$ n $$$ integer number $$$ a_i $$$ ( $$$ 1 \leq a_i \leq 1000000000 $$$ ) separate a single space represent many satoshi alice public address last line contain two number $$$ x $$$ $$$ f $$$ ( $$$ 1 \leq f < x \leq 1000000000 $$$ ) represent maximum number satoshies alice one address well fee satoshies will pay per transaction output one integer number represent total fee satoshi alice need pay achieve goal alice make two <unknown> a follow <unknown> 13 7 6 ( initial state ) 1 6 7 6 5 ( create new address transfer first public address 5 satoshies ) 2 6 4 6 5 1 ( create new address transfer second address 1 satoshi ) since cost per transaction 2 satoshies total fee 4",['implementation'],1400.0
1044/E,"give $$$ n \times m $$$ grid grid cell fill a unique integer $$$ 1 $$$ $$$ nm $$$ integer appear exactly one operation choose arbitrary cycle grid move integers along cycle one space , a cycle sequence satisfy follow condition : example follow grid : choose arbitrary cycle like one : get follow grid : particular case choose cycle represent sequence $$$ [ 1 2 3 6 5 8 7 4 ] $$$ number direction want rotate find sequence operations sort grid array create concatenate row highest lowest sort ( look first picture ) note need minimize number operations sum cycle lengths constraint sum cycle lengths must greater $$$ 100000 $$$ show answer always exist give constraints output valid sequence move sort grid first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 3 \leq n m \leq 20 $$$ ) — dimension grid next $$$ n $$$ line contain $$$ m $$$ integers $$$ x _ { i,1 } x _ { i,2 } \ldots x _ { i m } $$$ ( $$$ 1 \leq x _ { i j } \leq nm $$$ ) denote value block row $$$ i $$$ column $$$ j $$$ guarantee $$$ x _ { i j } $$$ distinct first print a single integer $$$ k $$$ number operations ( $$$ k \geq 0 $$$ ) next $$$ k $$$ line print a cycle follow : $$$ $$$ s\ <unknown> <unknown> <unknown> y_s $$$ $$$ $$$ s $$$ number block move ( $$$ s \geq 4 $$$ ) block $$$ y_1 $$$ move block $$$ y_2 $$$ block $$$ y_2 $$$ move block $$$ y_3 $$$ block $$$ y_s $$$ move block $$$ y_1 $$$ sum $$$ s $$$ operations must $$$ 100000 $$$ first sample case statement , use cycle reverse order sort grid",['implementation'],3100.0
1043/B,bajtek know unusual gift recently get integer array $$$ x_0 x_1 \ldots x _ { k-1 } $$$ unfortunately a huge array - party extraordinary friends realize 'd lose hours spend search a new toy bajtek find array <unknown> 's website another array $$$ a $$$ length $$$ n + 1 $$$ a formal description $$$ a $$$ say $$$ a_0 = 0 $$$ $$$ i $$$ ( $$$ 1 \le i \le n $$$ ) $$$ a_i = x _ { ( i-1 ) \bmod k } + a _ { i-1 } $$$ $$$ p \bmod q $$$ denote remainder division $$$ p $$$ $$$ q $$$ example $$$ x = [ 1 2 3 ] $$$ $$$ n = 5 $$$ : $$$ x = [ 1 2 3 ] $$$ $$$ n = 5 $$$ $$$ a = [ 0 1 3 6 7 9 ] $$$ boy hop able restore $$$ x $$$ $$$ a $$$ ! know $$$ 1 \le k \le n $$$ help find possible value $$$ k $$$ — possible lengths lose array first line contain exactly one integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — length array $$$ a $$$ exclude element $$$ a_0 $$$ second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \le a_i \le 1000000 $$$ ) note $$$ a_0 $$$ always $$$ 0 $$$ give input first line output contain one integer $$$ l $$$ denote number correct lengths lose array second line output contain $$$ l $$$ integers — possible lengths lose array increase order first example $$$ k $$$ suitable since $$$ a $$$ arithmetic <unknown> possible array $$$ x $$$ : second example bajtek 's array three five elements possible array $$$ x $$$ : example $$$ k = 4 $$$ bad since lead $$$ 6 + x_0 = 8 $$$ $$$ 0 + x_0 = 1 $$$ obvious contradiction third example $$$ k = n $$$ good array $$$ [ 1 4 -2 ] $$$ satisfy requirements note $$$ x_i $$$ may negative,['implementation'],1200.0
1042/A,"$$$ n $$$ bench berland central park know $$$ a_i $$$ people currently sit $$$ i $$$ -th bench another $$$ m $$$ people come park go a seat bench $$$ n $$$ available let $$$ k $$$ maximum number people sit one bench additional $$$ m $$$ people come park calculate minimum possible $$$ k $$$ maximum possible $$$ k $$$ nobody leave take seat whole process first line contain a single integer $$$ n $$$ $$$ ( 1 \le n \le 100 ) $$$ — number bench park second line contain a single integer $$$ m $$$ $$$ ( 1 \le m \le 10\,000 ) $$$ — number people additionally come park next $$$ n $$$ line contain a single integer $$$ a_i $$$ $$$ ( 1 \le a_i \le 100 ) $$$ — initial number people $$$ i $$$ -th bench print minimum possible $$$ k $$$ maximum possible $$$ k $$$ $$$ k $$$ maximum number people sit one bench additional $$$ m $$$ people come park first example four bench occupy a single person minimum $$$ k $$$ $$$ 3 $$$ example possible achieve two <unknown> occupy first bench one occupy second bench one occupy third bench two remain — fourth bench maximum $$$ k $$$ $$$ 7 $$$ require six new people occupy bench second example minimum $$$ k $$$ equal $$$ 15 $$$ maximum $$$ k $$$ equal $$$ 15 $$$ a single bench park $$$ 10 $$$ people occupy",['implementation'],1100.0
1030/C,recently vasya find a golden ticket — a sequence consist $$$ n $$$ digits $$$ <unknown> a_n $$$ vasya consider a ticket lucky divide two non - intersecting segment equal sum example ticket $$$ <unknown> $$$ lucky since divide three segment $$$ <unknown> $$$ $$$ 17 $$$ $$$ 8 $$$ : $$$ 3 + 5 + <unknown> + <unknown> $$$ note digit sequence belong exactly one segment help vasya ! tell golden ticket find lucky first line contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100 $$$ ) — number digits ticket second line contain $$$ n $$$ digits $$$ a_1 a_2 \dots a_n $$$ ( $$$ 0 \le a_i \le 9 $$$ ) — golden ticket digits print without space golden ticket lucky print ` ` yes '' otherwise print ` ` '' ( case insensitive ) first example ticket divide $$$ 7 $$$ $$$ 34 $$$ $$$ 52 $$$ : $$$ <unknown> + <unknown> + 2 $$$ second example impossible divide ticket segment equal sum,['implementation'],1300.0
1108/A,give two segment $$$ [ l_1 ; r_1 ] $$$ $$$ [ l_2 ; r_2 ] $$$ $$$ x $$$ -axis guarantee $$$ l_1 < r_1 $$$ $$$ l_2 < r_2 $$$ segment may intersect overlap even coincide problem find two integers $$$ a $$$ $$$ b $$$ $$$ l_1 \le a \le r_1 $$$ $$$ l_2 \le b \le r_2 $$$ $$$ a \ne b $$$ word choose two distinct integer point a way first point belong segment $$$ [ l_1 ; r_1 ] $$$ second one belong segment $$$ [ l_2 ; r_2 ] $$$ guarantee answer exist multiple answer print answer $$$ q $$$ independent query first line input contain one integer $$$ q $$$ ( $$$ 1 \le q \le 500 $$$ ) — number query next $$$ q $$$ line contain four integers $$$ l _ { 1_i } r _ { 1_i } l _ { 2_i } $$$ $$$ r _ { 2_i } $$$ ( $$$ 1 \le l _ { 1_i } r _ { 1_i } l _ { 2_i } r _ { 2_i } \le 1000000000 l _ { 1_i } < r _ { 1_i } l _ { 2_i } < r _ { 2_i } $$$ ) — end segment $$$ i $$$ -th query print $$$ <unknown> $$$ integers $$$ i $$$ -th query print two integers $$$ a_i $$$ $$$ b_i $$$ — number $$$ l _ { 1_i } \le a_i \le r _ { 1_i } $$$ $$$ l _ { 2_i } \le b_i \le r _ { 2_i } $$$ $$$ a_i \ne b_i $$$ query number order input guarantee answer exist multiple answer print,['implementation'],800.0
1030/A,prepare a tournament codeforces <unknown> try <unknown> best make first problem easy possible time coordinator choose problem ask $$$ n $$$ people opinions person answer whether problem easy hard least one $$$ n $$$ people answer problem hard coordinator decide change problem give responses check problem easy enough first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100 $$$ ) — number people ask give opinions second line contain $$$ n $$$ integers integer either $$$ 0 $$$ $$$ 1 $$$ $$$ i $$$ -th integer $$$ 0 $$$ $$$ i $$$ -th person think problem easy ; $$$ 1 $$$ $$$ i $$$ -th person think problem hard print one word : ` ` easy '' problem easy accord responses ` ` hard '' least one person think problem hard may print every letter register : ` ` easy '' ` ` easy '' ` ` easy '' ` ` easy '' process correctly first example third person say 's a hard problem replace second example problem easy person n't replace,['implementation'],800.0
1028/A,consider a table size $$$ n \times m $$$ initially fully white row number $$$ 1 $$$ $$$ n $$$ top bottom columns $$$ 1 $$$ $$$ m $$$ leave right square inside table odd side length paint black find center square first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le <unknown> $$$ ) — number row number columns table $$$ i $$$ -th next $$$ n $$$ line contain a string $$$ m $$$ character $$$ s _ { i1 } s _ { i2 } \ldots s _ { i m } $$$ ( $$$ s _ { ij } $$$ ' w ' white cells ' b ' black cells ) describe $$$ i $$$ -th row table output two integers $$$ r $$$ $$$ c $$$ ( $$$ 1 \le r \le n $$$ $$$ 1 \le c \le m $$$ ) separate a space — row column number center black square,['implementation'],800.0
1059/A,vasya recently get a job a cashier a local store day work $$$ l $$$ minutes long vasya already memorize $$$ n $$$ regular customers $$$ i $$$ -th come $$$ t _ { i } $$$ minutes begin day service consume $$$ l _ { i } $$$ minutes guarantee customer arrive vasya service another customer vasya a bite lazy like take <unknown> break $$$ a $$$ minutes break may go one another vasya must present work time periods must serve regular customers otherwise one may <unknown> boss maximum number break vasya take day ? first line contain three integers $$$ n $$$ $$$ l $$$ $$$ a $$$ ( $$$ 0 \le n \le 10^ { 5 } $$$ $$$ 1 \le l \le 10^ { 9 } $$$ $$$ 1 \le a \le l $$$ ) $$$ i $$$ -th next $$$ n $$$ line contain two integers $$$ t _ { i } $$$ $$$ l _ { i } $$$ ( $$$ 0 \le t _ { i } \le l - 1 $$$ $$$ 1 \le l _ { i } \le l $$$ ) guarantee $$$ t _ { i } + l _ { i } \le t _ { i + 1 } $$$ $$$ t _ { n } + l _ { n } \le l $$$ output one integer — maximum number break first sample vasya take $$$ 3 $$$ break start $$$ 2 $$$ $$$ 5 $$$ $$$ 8 $$$ minutes begin day second sample vasya take $$$ 2 $$$ break start $$$ 0 $$$ $$$ 2 $$$ minutes begin day third sample vasya ca n't take break,['implementation'],1000.0
263/A,' ve get a 5 × 5 matrix consist 24 zero a single number one let 's index matrix row number 1 5 top bottom let 's index matrix columns number 1 5 leave right one move allow apply one two follow <unknown> matrix : think a matrix look beautiful single number one matrix locate middle ( cell intersection third row third column ) count minimum number move need make matrix beautiful input consist five line line contain five integers : j - th integer i - th line input represent element matrix locate intersection i - th row j - th column guarantee matrix consist 24 zero a single number one print a single integer — minimum number move need make matrix beautiful,['implementation'],800.0
1017/A,"john smith know son thomas smith among best students class even school students school take exams english german math history a table result form $$$ n $$$ students a unique i d ( $$$ 1 $$$ $$$ n $$$ ) thomas 's i d $$$ 1 $$$ every student four score correspond english german math history score students give order increase ids table students sort decrease sum score , a student largest sum get first place two students sum students sort increase ids please help john find rank son first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 1000 $$$ ) — number students next $$$ n $$$ line contain four integers $$$ a_i $$$ $$$ b_i $$$ $$$ c_i $$$ $$$ d_i $$$ ( $$$ 0\leq a_i b_i c_i <unknown> 100 $$$ ) — grade $$$ i $$$ -th student english german math history i d $$$ i $$$ -th student equal $$$ i $$$ print rank thomas smith thomas 's i d $$$ 1 $$$ first sample students get total score : $$$ 398 $$$ $$$ 400 $$$ $$$ 398 $$$ $$$ <unknown> $$$ $$$ 357 $$$ among $$$ 5 $$$ students thomas third student second highest score thomas a smaller i d rank $$$ 2 $$$ second sample students get total score : $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ <unknown> $$$ $$$ 300 $$$ $$$ 300 $$$ $$$ 0 $$$ among $$$ 6 $$$ students thomas get highest score rank $$$ 1 $$$",['implementation'],800.0
265/A,a sequence colorful stone color stone one red green blue give a string s. i - th ( 1 - based ) character s represent color i - th stone character ` ` r '' ` ` g '' ` ` b '' color correspond stone red green blue respectively initially squirrel liss stand first stone perform instructions one time instruction one three type : ` ` red '' ` ` green '' ` ` blue '' instruction c liss stand a stone whose color c liss move one stone forward else move give a string t. number instructions equal length t i - th character t represent i - th instruction calculate final position liss ( number stone go stand end ) perform instructions print 1 - based position guarantee liss n't move sequence input contain two line first line contain string s ( 1 ≤ |s| ≤ 50 ) second line contain string t ( 1 ≤ |t| ≤ 50 ) character string one ` ` r '' ` ` g '' ` ` b '' guarantee liss n't move sequence print final 1 - based position liss a single line,['implementation'],800.0
1015/B,give two string $$$ s $$$ $$$ t $$$ string length $$$ n $$$ consist lowercase latin letter character string number $$$ 1 $$$ $$$ n $$$ successively perform follow move number time ( possibly zero ) : ca n't apply a move string $$$ t $$$ move apply string $$$ s $$$ one another task obtain string $$$ t $$$ string $$$ s $$$ find way $$$ 10000 $$$ move minimize number move find sequence move length $$$ 10000 $$$ less transform $$$ s $$$ $$$ t $$$ first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 50 $$$ ) — length string $$$ s $$$ $$$ t $$$ second line input contain string $$$ s $$$ consist $$$ n $$$ lowercase latin letter third line input contain string $$$ t $$$ consist $$$ n $$$ lowercase latin letter impossible obtain string $$$ t $$$ use move print ` ` -1 '' otherwise first line print one integer $$$ k $$$ — number move transform $$$ s $$$ $$$ t $$$ note $$$ k $$$ must integer number $$$ 0 $$$ $$$ 10000 $$$ inclusive second line print $$$ k $$$ integers $$$ c_j $$$ ( $$$ 1 \le c_j < n $$$ ) $$$ c_j $$$ mean $$$ j $$$ -th move swap character $$$ s _ { c_j } $$$ $$$ s _ { c_j + 1 } $$$ need apply move print a single integer $$$ 0 $$$ first line either leave second line empty print first example string $$$ s $$$ change follow : ` ` <unknown> '' $$$ \rightarrow $$$ ` ` <unknown> '' $$$ \rightarrow $$$ ` ` <unknown> '' $$$ \rightarrow $$$ ` ` <unknown> '' $$$ \rightarrow $$$ ` ` <unknown> '' second example way transform string $$$ s $$$ string $$$ t $$$ allow move,['implementation'],1200.0
1070/K,polycarp take $$$ n $$$ videos duration $$$ i $$$ -th video $$$ a_i $$$ second videos list chronological order i.e $$$ 1 $$$ -st video earliest $$$ 2 $$$ -nd video next ... $$$ n $$$ -th video last polycarp want publish exactly $$$ k $$$ ( $$$ 1 \le k \le n $$$ ) post <unknown> video a part a single post post preserve chronological order mean first post contain one earliest videos second post contain a block ( one videos ) go next word number videos $$$ j $$$ -th post $$$ <unknown> $$$ : polycarp a perfectionist want total duration videos post help polycarp find positive integer value $$$ s_1 s_2 \dots s_k $$$ satisfy condition first line contain two integers $$$ n $$$ $$$ k $$$ ( $$$ 1 \le k \le n \le 100000 $$$ ) next line contain $$$ n $$$ positive integer number $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 10000 $$$ ) $$$ a_i $$$ duration $$$ i $$$ -th video solution exist print ` ` yes '' first line print $$$ k $$$ positive integers $$$ s_1 s_2 \dots s_k $$$ ( $$$ <unknown> = n $$$ ) second line total duration videos post easily prove answer unique ( exist ) solution print a single line ` ` '',['implementation'],1100.0
1075/B,palo alto unusual city endless coordinate line also know office lyft level 5 . lyft become popular use $$$ m $$$ taxi drivers city every day transport rest city residents — $$$ n $$$ riders resident ( include taxi drivers ) palo - alto live unique location ( pair residents coordinate ) lyft system clever : a rider call a taxi call go taxi drivers one closest person multiple ones distance taxi driver a smaller coordinate select one morning taxi drivers wonder : many riders would call give taxi driver first order a taxi day ? word need find taxi driver $$$ i $$$ number $$$ a _ { i } $$$ — number riders would call $$$ i $$$ -th taxi driver drivers riders home ? taxi driver neither transport taxi drivers first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100000 $$$ ) — number riders taxi drivers second line contain $$$ n + m $$$ integers $$$ x_1 x_2 \ldots x _ { n+m } $$$ ( $$$ 1 \le x_1 < x_2 < \ldots < x _ { n+m } \le 1000000000 $$$ ) $$$ x_i $$$ coordinate $$$ i $$$ -th resident live third line contain $$$ n + m $$$ integers $$$ t_1 t_2 \ldots t _ { n+m } $$$ ( $$$ 0 \le t_i \le 1 $$$ ) $$$ t_i = 1 $$$ $$$ i $$$ -th resident a taxi driver otherwise $$$ t_i = 0 $$$ guarantee number $$$ i $$$ $$$ t_i = 1 $$$ equal $$$ m $$$ print $$$ m $$$ integers $$$ a_1 a_2 \ldots a _ { m } $$$ $$$ a_i $$$ answer $$$ i $$$ -th taxi driver taxi driver number $$$ i $$$ among taxi drivers live $$$ i $$$ -th smallest coordinate ( see examples better understand ) first example one taxi driver mean order $$$ n $$$ riders go second example first taxi driver live point coordinate $$$ 2 $$$ second one live point coordinate $$$ 6 $$$ obviously nearest taxi driver rider live $$$ 3 $$$ coordinate first one rider live coordinate $$$ 5 $$$ second one rider live $$$ 4 $$$ coordinate distance first second taxi drivers since first taxi driver a smaller coordinate call rider go first taxi driver third example one rider taxi driver nearest fourth one,['implementation'],1200.0
1080/C,"recently masha present a chessboard a height $$$ n $$$ a width $$$ m $$$ row chessboard number $$$ 1 $$$ $$$ n $$$ bottom top columns number $$$ 1 $$$ $$$ m $$$ leave right therefore cell specify coordinate $$$ ( x y ) $$$ $$$ x $$$ column number $$$ y $$$ row number ( mix ) let us call a rectangle coordinate $$$ ( a b c d ) $$$ a rectangle lower leave point coordinate $$$ ( a b ) $$$ upper right one — $$$ ( c d ) $$$ chessboard paint black white follow : masha happy gift therefore invite friends maxim denis show guy decide make a treat — buy a white a black paint old board <unknown> repaint come masha something unpleasant happen : first maxim go threshold spill white paint rectangle $$$ ( x_1 y_1 x_2 y_2 ) $$$ denis spill black paint rectangle $$$ ( x_3 y_3 x_4 y_4 ) $$$ spill paint color $$$ color $$$ onto a certain rectangle mean cells belong give rectangle become $$$ color $$$ cell dye <unknown> ( first cell spill white paint black one color black ) masha shock ! drive away guests decide find spoil gift , need know number cells white black color help find number ! first line contain a single integer $$$ t $$$ ( $$$ 1 \le t \le 1000 $$$ ) — number test case describe follow format : first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 1000000000 $$$ ) — size board second line contain four integers $$$ x_1 $$$ $$$ y_1 $$$ $$$ x_2 $$$ $$$ y_2 $$$ ( $$$ 1 \le x_1 \le x_2 \le m 1 \le y_1 \le y_2 \le n $$$ ) — coordinate rectangle white paint spill third line contain four integers $$$ x_3 $$$ $$$ y_3 $$$ $$$ x_4 $$$ $$$ y_4 $$$ ( $$$ 1 \le x_3 \le x_4 \le m 1 \le y_3 \le y_4 \le n $$$ ) — coordinate rectangle black paint spill output $$$ t $$$ line contain two number — number white black cells spill paint respectively explanation examples : first picture illustration show field look dye spill second picture illustration show field look maxim spoil white dye ( rectangle dye spill highlight red ) third picture illustration show field look denis spoil black dye ( rectangle dye spill highlight red ) first test paint field change follow : second test paint field change follow : third test paint field change follow : fourth test paint field change follow : fifth test paint field change follow :",['implementation'],1500.0
248/A,one <unknown> <unknown> morning karlsson decide snack jam friend <unknown> <unknown> 's house fortunately karlsson n't anybody friend 's house karlsson go hungry longer decide get food house karlsson 's gaze immediately fell n wooden cupboards stand kitchen immediately realize cupboards hide jam stock karlsson begin fly <unknown> around kitchen open close cupboards ' doors <unknown> empty jar jam could find jar jam empty karlsson enough want leave <unknown> stay let friend cupboards two doors : leave one right one karlsson remember <unknown> kitchen cupboards ' leave doors position ( open close ) similarly cupboards ' right doors position ( open close ) karlsson want doors meet condition well time family return karlsson remember position leave doors also remember position right doors therefore matter position leave right doors important leave leave doors position right doors position example leave doors may close right ones may open karlsson need one second open close a door a cupboard understand little time family return want know minimum number second t able bring cupboard doors require position task write a program determine require number second t. first input line contain a single integer n — number cupboards kitchen ( 2 ≤ n ≤ 104 ) follow n line contain two integers li ri ( 0 ≤ li ri ≤ 1 ) number li equal one leave door i - th cupboard open otherwise number li equal zero similarly number ri equal one right door i - th cupboard open otherwise number ri equal zero number line separate single space output line print a single integer t — minimum number second karlsson need change doors cupboards position need,['implementation'],800.0
220/A,"little elephant get a problem — somebody touch sort non - decreasing array a length n possibly swap elements array little elephant n't want call police understand could accidentally change array think could accidentally change array a array a sort one operation swap elements ( necessarily adjacent ) , little elephant could accidentally swap two elements help little elephant determine could accidentally change array a sort non - decreasing , first line contain a single integer n ( 2 ≤ n ≤ 105 ) — size array a. next line contain n positive integers separate single space exceed 109 — array a. note elements array necessarily distinct number a single line print ` ` yes '' ( without quote ) little elephant could accidentally change array ` ` '' ( without quote ) otherwise first sample array already sort sort need 0 swap operations 1 . thus answer ` ` yes '' second sample sort array swap elements 1 3 need 1 swap operation sort array thus answer ` ` yes '' third sample ca n't sort array one swap operation answer ` ` ''",['implementation'],1300.0
1118/B,tanya $$$ n $$$ candy number $$$ 1 $$$ $$$ n $$$ $$$ i $$$ -th candy weight $$$ a_i $$$ plan eat exactly $$$ n-1 $$$ candy give remain candy dad tanya eat candy order increase number exactly one candy per day task find number candy $$$ i $$$ ( let 's call candy good ) dad get $$$ i $$$ -th candy sum weight candy tanya eat even days equal sum weight candy tanya eat odd days note first give candy eat remain candy one one example $$$ n=4 $$$ weight $$$ [ 1 4 3 3 ] $$$ consider possible case give a candy dad : total $$$ 2 $$$ case count ( candy good ) answer $$$ 2 $$$ first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 200000 $$$ ) — number candy second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 10000 $$$ ) $$$ a_i $$$ weight $$$ i $$$ -th candy print one integer — number candy $$$ i $$$ ( good candy ) dad get $$$ i $$$ -th candy sum weight candy tanya eat even days equal sum weight candy tanya eat odd days first example indices good candy $$$ [ 1 2 ] $$$ second example indices good candy $$$ [ 2 3 ] $$$ third example indices good candy $$$ [ 4 5 9 ] $$$,['implementation'],1200.0
262/A,roma ( a popular russian name mean ' roman ' ) love little <unknown> elephant 's lucky number let us remind lucky number positive integers whose decimal representation contain lucky digits 4 7 . example number 47 744 4 lucky 5 17 467 roma 's get n positive integers wonder many integers k lucky digits ? help write program solve problem first line contain two integers n k ( 1 ≤ n k ≤ 100 ) second line contain n integers ai ( 1 ≤ ai ≤ 109 ) — number roma number line separate single space a single line print a single integer — answer problem first sample number contain four lucky digits answer 3 . second sample number <unknown> n't fit contain two lucky digits number fine answer 2,['implementation'],800.0
1025/A,panic rise committee <unknown> <unknown> — puppies new <unknown> bear multi - colored ! total 26 possible color puppies nature denote letter ' a ' ' z ' inclusive committee rule strictly prohibit even smallest diversity <unknown> hence puppies color thus slava committee employee assign task recolor puppies color order <unknown> difference make puppies one common color unfortunately due <unknown> reason restrict budget 's one operation slava perform : choose a color $$$ x $$$ currently least two puppies color $$$ x $$$ recolor puppies color $$$ x $$$ arbitrary color $$$ y $$$ luckily operation apply multiple time ( include zero ) example number puppies $$$ 7 $$$ color represent string ` ` abababc '' one operation slava get result ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' ` ` <unknown> '' others however current color sequence ` ` abababc '' ca n't choose $$$ x $$$ = ' c ' right currently one puppy color ' c ' help slava committee determine whether possible <unknown> puppies i.e slava 's operations puppies color first line contain a single integer $$$ n $$$ ( $$$ 1 \le n \le 100000 $$$ ) — number puppies second line contain a string $$$ s $$$ length $$$ n $$$ consist lowercase latin letter $$$ i $$$ -th symbol denote $$$ i $$$ -th puppy 's color 's possible recolor puppies one color print ` ` yes '' otherwise print ` ` '' output answer without quotation sign first example slava perform follow step : second example 's impossible recolor puppies third example puppies ' color ; thus 's need recolor anything,['implementation'],900.0
1101/E,polycarp recently get a new job earn much old wallet ca n't even store money berland bill somehow come lot different size however shape rectangles ( possibly square ) wallets also produce form rectangles ( possibly square ) a bill $$$ x \times y $$$ fit wallet $$$ h \times w $$$ either $$$ x \le h $$$ $$$ y \le w $$$ $$$ y \le h $$$ $$$ x \le w $$$ bill overlap a wallet infinite amount bill fit a wallet imply bill polycarp currently fit a wallet every single one fit independently others ask perform query two type : guarantee least one query type $$$ 1 $$$ first query type $$$ 2 $$$ least one query type $$$ 2 $$$ input data query type $$$ 2 $$$ print ` ` yes '' bill earn moment fit a wallet give size print ` ` '' otherwise first line contain a single integer $$$ n $$$ ( $$$ 2 \le n \le 500000 $$$ ) — number query next $$$ n $$$ line contain a query one two type : guarantee least one query type $$$ 1 $$$ first query type $$$ 2 $$$ least one query type $$$ 2 $$$ input data query type $$$ 2 $$$ print ` ` yes '' bill earn moment fit a wallet give size print ` ` '' otherwise query type $$$ 2 $$$ example :,['implementation'],1500.0
1060/C,give two array $$$ a $$$ $$$ b $$$ positive integers length $$$ n $$$ $$$ m $$$ respectively let $$$ c $$$ $$$ n \times m $$$ matrix $$$ c _ { i j } = a_i \cdot b_j $$$ need find a subrectangle matrix $$$ c $$$ sum elements $$$ x $$$ area ( total number elements ) largest possible formally need find largest number $$$ s $$$ possible choose integers $$$ x_1 x_2 y_1 y_2 $$$ subject $$$ 1 \leq x_1 \leq x_2 \leq n $$$ $$$ 1 \leq y_1 \leq y_2 \leq m $$$ $$$ ( x_2 - x_1 + 1 ) \times ( y_2 - y_1 + 1 ) = s $$$ $$$ $$$ \sum _ { i = x_1 } ^ { x_2 } { \sum _ { j = y_1 } ^ { y_2 } { c _ { i j } } } \leq x $$$ $$$ first line contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \leq n m \leq 2000 $$$ ) second line contain $$$ n $$$ integers $$$ a_1 a_2 \ldots a_n $$$ ( $$$ 1 \leq a_i \leq 2000 $$$ ) third line contain $$$ m $$$ integers $$$ b_1 b_2 \ldots b_m $$$ ( $$$ 1 \leq b_i \leq 2000 $$$ ) fourth line contain a single integer $$$ x $$$ ( $$$ 1 \leq x \leq 2 \cdot 10^ { 9 } $$$ ) possible choose four integers $$$ x_1 x_2 y_1 y_2 $$$ $$$ 1 \leq x_1 \leq x_2 \leq n $$$ $$$ 1 \leq y_1 \leq y_2 \leq m $$$ $$$ \sum _ { i = x_1 } ^ { x_2 } { \sum _ { j = y_1 } ^ { y_2 } { c _ { i j } } } \leq x $$$ output largest value $$$ ( x_2 - x_1 + 1 ) \times ( y_2 - y_1 + 1 ) $$$ among <unknown> otherwise output $$$ 0 $$$ matrix first sample choose subrectangle ( blue color ) : matrix second sample choose subrectangle ( blue color ) :,['implementation'],1600.0
221/B,little elephant love number a positive integer x. little elephant want find number positive integers d d divisor x x d least one common ( ) digit decimal representations help little elephant find describe number a single line contain a single integer x ( 1 ≤ x ≤ 109 ) a single line print integer — answer problem,['implementation'],1300.0
234/A,one fine <unknown> day a <unknown> teacher vasily petrov go a class saw n <unknown> sit desks two people desk vasily quickly realize number n even like true mathematicians vasily students number 1 n. vasily petrov like way children seat desks accord students whose number differ 1 sit together talk time distract others <unknown> hand a <unknown> student sit leave end desk a <unknown> student sit right end desk hit elbow time distract case students sit desk interfere vasily know well students <unknown> ones <unknown> ask come order meet two <unknown> condition ( students talk <unknown> elbow ) guarantee input least one way seat students always exist first input line contain a single even integer n ( 4 ≤ n ≤ 100 ) — number students class second line contain exactly n capital english letter ` ` l '' ` ` r '' i - th letter second line equal ` ` l '' student number i a <unknown> otherwise a <unknown> print integer pair one pair per line i - th line print number students sit i - th desk first number pair stand student sit leave second number stand student sit right separate number pair space multiple solutions print,['implementation'],1200.0
1099/A,"today 's morning <unknown> <unknown> meshanya decide go outside notice a huge snowball roll mountain ! luckily two stone mountain initially snowball height $$$ h $$$ weight $$$ w $$$ second follow sequence events happen : snowball 's weight increase $$$ i $$$ $$$ i $$$ — current height snowball snowball hit stone ( 's present current height ) snowball move one meter snowball reach height zero stop exactly two stone mountain first stone weight $$$ u_1 $$$ locate height $$$ d_1 $$$ second one — $$$ u_2 $$$ $$$ d_2 $$$ respectively snowball hit either two stone lose weight equal weight stone snowball negative weight weight become zero snowball continue move find weight snowball stop move , reach height 0 . first line contain two integers $$$ w $$$ $$$ h $$$ — initial weight height snowball ( $$$ 0 \le w \le 100 $$$ ; $$$ 1 \le h \le 100 $$$ ) second line contain two integers $$$ u_1 $$$ $$$ d_1 $$$ — weight height first stone ( $$$ 0 \le u_1 \le 100 $$$ ; $$$ 1 \le d_1 \le h $$$ ) third line contain two integers $$$ u_2 $$$ $$$ d_2 $$$ — weight <unknown> second stone ( $$$ 0 \le u_2 \le 100 $$$ ; $$$ 1 \le d_2 \le h $$$ ; $$$ d_1 \ne d_2 $$$ ) notice stone always different heights output a single integer — final weight snowball reach height 0 . first example initially a snowball weight 4 locate a height 3 two stone weight 1 a height 1 2 respectively follow events occur sequentially : thus end weight snowball equal 8",['implementation'],800.0
1015/A,give a set $$$ n $$$ segment axis $$$ ox $$$ segment integer endpoints $$$ 1 $$$ $$$ m $$$ inclusive segment may intersect overlap even coincide segment characterize two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le m $$$ ) — coordinate leave right endpoints consider integer point $$$ 1 $$$ $$$ m $$$ inclusive task print point n't belong segment point $$$ x $$$ belong segment $$$ [ l ; r ] $$$ $$$ l \le x \le r $$$ first line input contain two integers $$$ n $$$ $$$ m $$$ ( $$$ 1 \le n m \le 100 $$$ ) — number segment upper bind coordinate next $$$ n $$$ line contain two integers $$$ l_i $$$ $$$ r_i $$$ ( $$$ 1 \le l_i \le r_i \le m $$$ ) — endpoints $$$ i $$$ -th segment segment may intersect overlap even coincide note possible $$$ l_i = r_i $$$ i.e a segment degenerate a point first line print one integer $$$ k $$$ — number point n't belong segment second line print exactly $$$ k $$$ integers order — point n't belong segment point print distinct point print a single integer $$$ 0 $$$ first line either leave second line empty print first example point $$$ 1 $$$ belong second segment point $$$ 2 $$$ belong first second segment point $$$ 5 $$$ belong third segment point $$$ 3 $$$ $$$ 4 $$$ belong segment second example point $$$ 1 $$$ $$$ 7 $$$ belong first segment,['implementation'],800.0
234/E,"<unknown> year two russian team come group stage prestigious football club competition world — <unknown> champion league , team already start play group stage fight advance <unknown> problem interest draw stage process sort team group process draw go follow ( rule describe problem somehow simplify compare real life ) suppose n team take part group stage ( n divisible four ) team divide group four let 's denote number group m ( ) team a rat — integer characterize team 's previous <unknown> team sort rat 's decrease ( two team rat ) four ` ` baskets '' form contain m team : first m team highest rat go first basket follow m team go second one , follow procedure repeat m - 1 time a team randomly take basket first first basket second third last fourth take team form another group , remove baskets four team remain baskets ( m - 1 ) <unknown> perform form last group real draw random selection team basket perform people — a rule well - known players past none use a random number generator construct follow parameters four positive integers x a b c. every time a call random number generator produce follow action : operation mean take remainder division : , a random number generator use draw follow : time need randomly choose a team basket generate a random number k. team yet remain basket consider number consecutive integers 0 s - 1 order decrease rat s current size basket a team number take basket give a list team parameters random number generator determine result draw first input line contain integer n ( 4 ≤ n ≤ 64 n divisible four ) — number team take part sort second line contain four space - separated integers x a b c ( 1 ≤ x a b c ≤ 1000 ) — parameters random number generator follow n line describe one team description consist name team rat separate a single space name a team consist uppercase lowercase english letter length 1 20 character a team 's rat integer 0 1000 . team ' name distinct team 's rat also distinct print way team must sort group print group order form sort number group consecutive uppercase english letter start letter ' a ' inside group print team ' name one per line order decrease team ' rat see sample a better understand output format give sample random number generator execute four time :",['implementation'],1600.0
1095/D,$$$ n $$$ kid number $$$ 1 $$$ $$$ n $$$ dance a circle around christmas tree let 's enumerate a clockwise direction $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_n $$$ ( number $$$ 1 $$$ $$$ n $$$ distinct $$$ p $$$ a permutation ) let next kid a kid $$$ p_i $$$ kid $$$ p _ { i + 1 } $$$ $$$ i < n $$$ $$$ p_1 $$$ otherwise dance kid remember two kid : next kid ( let 's call $$$ x $$$ ) next kid $$$ x $$$ kid tell kid he / she remember : kid $$$ i $$$ remember kid $$$ a _ { i 1 } $$$ $$$ a _ { i 2 } $$$ however order $$$ a _ { i 1 } $$$ $$$ a _ { i 2 } $$$ differ order circle restore order kid circle use information several answer may print guarantee least one solution exist python programmer consider use pypy instead python submit code first line input contain one integer $$$ n $$$ ( $$$ 3 \le n \le 200000 $$$ ) — number kid next $$$ n $$$ line contain $$$ 2 $$$ integers $$$ i $$$ -th line contain two integers $$$ a _ { i 1 } $$$ $$$ a _ { i 2 } $$$ ( $$$ 1 \le a _ { i 1 } a _ { i 2 } \le n a _ { i 1 } \ne a _ { i 2 } $$$ ) — kid $$$ i $$$ -th kid remember give arbitrary order print $$$ n $$$ integers $$$ p_1 $$$ $$$ p_2 $$$ ... $$$ p_n $$$ — permutation integers $$$ 1 $$$ $$$ n $$$ correspond order kid circle several answer may print ( example n't matter kid first circle ) guarantee least one solution exist,['implementation'],1600.0
1095/B,give array $$$ a $$$ consist $$$ n $$$ integer number let instability array follow value : $$$ \max\limits _ { i = 1 } ^ { n } a_i - \min\limits _ { i = 1 } ^ { n } a_i $$$ remove exactly one element array minimize instability result $$$ ( n-1 ) $$$ <unknown> array task calculate minimum possible instability first line input contain one integer $$$ n $$$ ( $$$ 2 \le n \le 100000 $$$ ) — number elements array $$$ a $$$ second line input contain $$$ n $$$ integers $$$ a_1 a_2 \dots a_n $$$ ( $$$ 1 \le a_i \le 100000 $$$ ) — elements array $$$ a $$$ print one integer — minimum possible instability array remove exactly one element array $$$ a $$$ first example remove $$$ 7 $$$ instability remain array $$$ 3 - 1 = 2 $$$ second example remove either $$$ 1 $$$ $$$ 100000 $$$ instability remain array $$$ 100000 - 100000 = 0 $$$ $$$ 1 - 1 = 0 $$$ correspondingly,['implementation'],900.0
236/B,let 's denote d ( n ) number divisors a positive integer n. give three integers a b c. task calculate follow sum : find sum modulo 1073741824 ( 230 ) first line contain three space - separated integers a b c ( 1 ≤ a b c ≤ 100 ) print a single integer — require sum modulo 1073741824 ( 230 ) first example result 1 + 2 + 2 + 3 + 2 + 3 + 3 + 4 = 20,['implementation'],1300.0
237/A,valera run a <unknown> fast food cafe magically learn next day n people visit cafe person know arrival time : i - th person come exactly hi hours mi minutes cafe spend less a minute serve client a client come see free cash n't want wait leave cafe immediately valera greedy want serve n customers next day ( get profit ) however need ensure moment time number work cash less number clients cafe help valera count minimum number cash work cafe next day serve visitors first line contain a single integer n ( 1 ≤ n ≤ 105 ) number cafe visitors follow n line two space - separated integers hi mi ( 0 ≤ hi ≤ 23 ; 0 ≤ mi ≤ 59 ) represent time i - th person come cafe note time give chronological order time give within one 24 - hour period print a single integer — minimum number cash need serve clients next day first sample enough one cash serve clients two visitors come cafe <unknown> . therefore one cash cafe one customer serve another one wait go away second sample visitors come different time enough one cash,['implementation'],1000.0
237/B,"' ve get table a consist n row number 1 n. i - th line table a contain ci cells i ( 1 < i ≤ n ) hold ci ≤ ci - 1 . let 's denote s total number cells table a , know cell table contain a single integer 1 s write integers distinct let 's assume cells i - th row table a number 1 ci let 's denote number write j - th cell i - th row ai j. task perform several swap operations rearrange number table fulfill follow condition : one swap operation allow choose two different cells table swap record number number record first select cells swap write second cell similarly number record second select cells write first cell swap rearrange number require manner note allow perform number operations s. minimize number operations first line contain a single integer n ( 1 ≤ n ≤ 50 ) show number row table second line contain n space - separated integers ci ( 1 ≤ ci ≤ 50 ; ci ≤ ci - 1 ) — number cells correspond row next n line contain table а . i - th contain ci space - separated integers : j - th integer line represent ai j. guarantee give number ai j positive exceed s. guarantee ai j distinct first line print a single integer m ( 0 ≤ m ≤ s ) represent number perform swap next m line print description swap operations i - th line print four space - separated integers xi yi pi qi ( 1 ≤ xi pi ≤ n ; 1 ≤ yi ≤ cxi ; 1 ≤ qi ≤ <unknown> ) print number denote swap content cells <unknown> yi <unknown> qi note a swap operation change content distinct table cells print swap order execute",['implementation'],1500.0
227/B,"a team train vasya petya sasha get a problem implement linear search array accord boys linear search work follow array elements a pre - <unknown> order turn compare number need find find array element equal require one search end efficiency algorithm number perform comparisons fewer comparisons linear search make <unknown> vasya believe a linear search would work better sequentially iterate elements start 1 - st one ( problem consider elements array index 1 n ) end n - th one petya say vasya wrong : search need less comparisons sequentially iterate elements start n - th end 1 - st one sasha argue two approach equivalent finally begin task <unknown> decide settle <unknown> compare two approach example , take array a permutation integers 1 n generate m query form : find element value bi array want calculate approach many comparisons total linear search need respond query first search need fewer comparisons winner dispute vasya second one winner petya approach make number comparisons sasha 's get upper hand problem linear search slow 's boys n't go find right end train unless come help determine win dispute first line contain integer n ( 1 ≤ n ≤ 105 ) — number elements array second line contain n distinct space - separated integers a1 a2 ... ( 1 ≤ ai ≤ n ) — elements array third line contain integer m ( 1 ≤ m ≤ 105 ) — number query last line contain m space - separated integers b1 b2 ... bm ( 1 ≤ bi ≤ n ) — search query note query repeat print two integers show many comparisons vasya 's approach need many comparisons petya 's approach need separate number space please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier first sample vasya 's approach make one comparison ( start 1 - st element immediately find require number ) petya 's approach make two comparisons ( first compare 2 - nd array element n't find search item compare 1 - st element ) second sample contrary vasya 's approach need two comparisons ( first 1 - st element 2 - nd ) petya 's approach find require value one comparison ( first comparison 2 - nd element )",['implementation'],1100.0
1095/A,polycarp love cipher invent cipher call repeat repeat cipher use string encrypt string $$$ s = s _ { 1 } s _ { 2 } \dots s _ { m } $$$ ( $$$ 1 \le m \le 10 $$$ ) polycarp use follow algorithm : example $$$ s $$$ = '' bab '' process : ` ` b '' $$$ \to $$$ ` ` baa '' $$$ \to $$$ ` ` baabbb '' encrypt $$$ s $$$ = '' bab '' ` ` baabbb '' give string $$$ t $$$ — result encryption string $$$ s $$$ task decrypt i. e. find string $$$ s $$$ first line contain integer $$$ n $$$ ( $$$ 1 \le n \le <unknown> $$$ ) — length encrypt string second line input contain $$$ t $$$ — result encryption string $$$ s $$$ contain lowercase latin letter length $$$ t $$$ exactly $$$ n $$$ guarantee answer test exist print string $$$ s $$$ encryption equal $$$ t $$$,['implementation'],800.0
1088/B,"'re give array $$$ a $$$ repeat follow operation $$$ k $$$ time : find minimum non - zero element array print subtract non - zero elements array elements <unknown> print 0 . first line contain integers $$$ n $$$ $$$ k $$$ $$$ ( 1 \le n k \le 100000 ) $$$ length array number operations perform second line contain $$$ n $$$ space - separated integers $$$ a_1 a_2 \ldots a_n $$$ $$$ ( 1 \le a_i \le 1000000000 ) $$$ elements array print minimum non - zero element operation a new line first sample : first step : array $$$ [ 1,2,3 ] $$$ minimum non - zero element 1 . second step : array $$$ [ 0,1,2 ] $$$ minimum non - zero element 1 . third step : array $$$ [ <unknown> ] $$$ minimum non - zero element 1 . fourth fifth step : array $$$ [ <unknown> ] $$$ print 0 . second sample : first step : array $$$ [ <unknown> ] $$$ minimum non - zero element 3 . second step : array $$$ [ <unknown> ] $$$ minimum non - zero element 2",['implementation'],1000.0
255/B,little vitaly love different algorithms today invent a new algorithm vitaly 's algorithm work string s consist character ` ` x '' ` ` y '' use two follow operations runtime : input new algorithm string s algorithm work follow : vitaly wonder go print result algorithm 's work input receive string s. first line contain a non - empty string s. guarantee string consist character ` ` x '' ` ` y '' guarantee string consist 106 character guarantee result algorithm 's execution wo n't empty string line print string print result algorithm 's work input algorithm input receive string s. first test algorithm end first step algorithm impossible apply operation thus string wo n't change second test transformation like : a result ' ve get string ` ` y '' third test case one transformation take place : string ` ` <unknown> '' transform string ` ` xxxx '' thus answer string ` ` xxxx '',['implementation'],1200.0
242/B,a coordinate line n segment i - th segment start position li end position ri denote a segment [ li ri ] suggest one define segment cover others word segment give set contain ones want test assumption find give set segment cover segment print number a segment n't exist print -1 . formally assume segment [ a b ] cover segment [ c d ] meet condition a ≤ c ≤ d ≤ b. first line contain integer n ( 1 ≤ n ≤ 105 ) — number segment next n line contain descriptions segment i - th line contain two space - separated integers li ri ( 1 ≤ li ≤ ri ≤ 109 ) — border i - th segment guarantee two segment coincide print a single integer — number segment cover segment set 's solution print -1 . segment number start 1 order appear input,['implementation'],1100.0
245/A,"polycarpus a system administrator two servers strict <unknown> — a b. stay inform servers ' performance polycarpus execute command ` ` ping a '' ` ` ping b '' ping command send exactly ten packets server specify argument command execute a program result two integers x y ( x + y = 10 ; x y ≥ 0 ) number mean x packets successfully reach correspond server network y packets lose today polycarpus perform overall n ping command <unknown> server polycarpus want know whether server ` ` alive '' polycarpus think server ` ` alive '' least half packets send server reach successfully along network help polycarpus determine server whether ` ` alive '' give command result first line contain a single integer n ( 2 ≤ n ≤ 1000 ) — number command polycarpus fulfil follow n line contain three integers — description command i - th line contain three space - separated integers ti xi yi ( 1 ≤ ti ≤ 2 ; xi yi ≥ 0 ; xi + yi = 10 ) ti = 1 i - th command ` ` ping a '' otherwise i - th command ` ` ping b '' number xi yi represent result execute command , xi packets reach correspond server successfully yi packets lose guarantee input least one ` ` ping a '' command least one ` ` ping b '' command first line print string ` ` live '' ( without quote ) server a ` ` alive '' otherwise print ` ` dead '' ( without quote ) second line print state server b similar format consider first test case 10 packets send server a 5 reach therefore least half packets send server successfully reach network overall 10 packets send server b 6 reach therefore least half packets send server successfully reach network consider second test case overall 20 package send server a 10 reach therefore least half packets send server successfully reach network overall 10 packets send server b 0 reach therefore less half packets send server successfully reach network",['implementation'],800.0
1095/E,give a bracket sequence $$$ s $$$ consist $$$ n $$$ open ' ( ' close ' ) ' bracket a regular bracket sequence a bracket sequence transform a correct arithmetic expression insert character ' 1 ' ' + ' original character sequence example bracket sequence ` ` ( ) ( ) '' ` ` ( ( ) ) '' regular ( result expressions : ` ` ( 1 ) + ( 1 ) '' ` ` ( ( 1 + 1 ) +1 ) '' ) ` ` ) ( ` ` ` ` ( ` ` change type bracket $$$ s_i $$$ mean $$$ s_i = $$$ ' ) ' change ' ( ' vice versa task calculate number position $$$ i $$$ change type $$$ i $$$ -th bracket result bracket sequence become regular first line input contain one integer $$$ n $$$ ( $$$ 1 \le n \le 1000000 $$$ ) — length bracket sequence second line input contain string $$$ s $$$ consist $$$ n $$$ open ' ( ' close ' ) ' bracket print one integer — number position $$$ i $$$ change type $$$ i $$$ -th bracket result bracket sequence become regular,['implementation'],1900.0
219/B,polycarpus <unknown> businessman recently surprise find market paper scissor completely free ! without <unknown> polycarpus decide start produce sell scissor <unknown> calculate optimal <unknown> price scissor would p bourles however read somewhere customers attract price say something like ` ` special offer ! super price 999 bourles ! ` ` polycarpus decide lower price a little lead desire effect polycarpus agree lower price d bourles number nines end result price maximum several ways choose maximum possible price note polycarpus count trail nines a price first line contain two integers p d ( 1 ≤ p ≤ 1018 ; 0 ≤ d < p ) — initial price scissor maximum possible price <unknown> please use % lld specifier read write 64 - bit integers с++ prefer use cin cout stream % i64d specifier print require price — maximum price end largest number nines less p d. require number n't lead zero,['implementation'],1400.0
